import { i as gn } from "./chunk-DgFtVqg1.js";
import { Selection as vK, makeClient as il, isSelection as o3, MosaicClient as O_, queryFieldInfo as yK, coordinator as _F } from "@uwdata/mosaic-core";
import * as T from "@uwdata/mosaic-sql";
import { Query as dd, sql as eD, eq as bK, column as lm, literal as xK, cast as tD, row_number as wK, desc as kK, count as CK } from "@uwdata/mosaic-sql";
import { parseSpec as _K, astToDOM as SK } from "@uwdata/mosaic-spec";
import { createAPIContext as AK } from "@uwdata/vgplot";
function EK(t, e = 1e3) {
  let r;
  return (...i) => {
    r && clearTimeout(r), r = setTimeout(() => {
      t(...i);
    }, e);
  };
}
function F_(t, e) {
  if (t === e)
    return !0;
  if (t === null || e === null || typeof t != "object" || typeof e != "object" || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (let r in t)
    if (e.hasOwnProperty(r)) {
      if (!F_(t[r], e[r]))
        return !1;
    } else
      return !1;
  return !0;
}
function rD(t) {
  let e;
  return (...r) => {
    let n = t(...r);
    return e !== void 0 && F_(n, e) ? e : (e = n, n);
  };
}
function T_(t, e) {
  if (nD(t) && nD(e)) {
    let r;
    for (let n in e)
      if (e[n] !== t[n])
        if (e[n] === void 0)
          r === void 0 && (r = { ...t }), delete r[n];
        else {
          let i = T_(t[n], e[n]);
          i !== void 0 && (r === void 0 && (r = { ...t }), r[n] = i);
        }
    return r;
  } else return F_(t, e) ? void 0 : e;
}
function pd(t, e, r, n) {
  switch (r) {
    case "merge": {
      let i = T_(t, e);
      return i !== void 0 ? n(i) : void 0;
    }
    case "replace":
      return t !== e ? n(e) : void 0;
  }
}
function _y(t, e, r, n, i) {
  switch (n) {
    case "merge": {
      let o = T_(t, { [e]: r });
      return o !== void 0 ? i(o) : void 0;
    }
    case "replace":
      if (t[e] !== r) {
        let o = { ...t };
        return o[e] = r, i(o);
      } else
        return;
  }
}
function nD(t) {
  return t != null && typeof t == "object" && !Array.isArray(t);
}
const pi = 2, xb = 4, wb = 8, ol = 16, eu = 32, Nh = 64, kb = 128, Gs = 512, ii = 1024, ao = 2048, tu = 4096, qo = 8192, zu = 16384, Vg = 32768, Ql = 65536, iD = 1 << 17, SF = 1 << 18, Wd = 1 << 19, AF = 1 << 20, Hm = 32768, s3 = 1 << 21, M_ = 1 << 22, ju = 1 << 23, ja = Symbol("$state"), P_ = Symbol("legacy props"), DK = Symbol(""), Of = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), Cb = 3, $h = 8, OK = !1;
var R_ = Array.isArray, FK = Array.prototype.indexOf, N_ = Array.from, $_ = Object.defineProperty, qu = Object.getOwnPropertyDescriptor, EF = Object.getOwnPropertyDescriptors, TK = Object.prototype, MK = Array.prototype, I_ = Object.getPrototypeOf, oD = Object.isExtensible;
function _f(t) {
  return typeof t == "function";
}
const zt = () => {
};
function DF(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function OF() {
  var t, e, r = new Promise((n, i) => {
    t = n, e = i;
  });
  return { promise: r, resolve: t, reject: e };
}
function sD(t, e) {
  if (Array.isArray(t))
    return t;
  if (!(Symbol.iterator in t))
    return Array.from(t);
  const r = [];
  for (const n of t)
    if (r.push(n), r.length === e) break;
  return r;
}
function FF(t) {
  return t === this.v;
}
function B_(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function TF(t) {
  return !B_(t, this.v);
}
function MF(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function PK() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function RK(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function NK() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function $K(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function IK() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function BK() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function LK(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function zK() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function jK() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function qK() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function UK() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let HK = !1;
const L_ = 1, z_ = 2, PF = 4, VK = 8, WK = 16, GK = 1, KK = 4, QK = 8, XK = 16, JK = 1, YK = 2, ZK = 4, RF = 1, eQ = 2, NF = "[", _b = "[!", j_ = "]", gh = {}, Vn = Symbol(), tQ = "http://www.w3.org/1999/xhtml", rQ = "@attach";
let lo = null;
function md(t) {
  lo = t;
}
function nt(t, e = !1, r) {
  lo = {
    p: lo,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: null
  };
}
function it(t) {
  var e = (
    /** @type {ComponentContext} */
    lo
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      cT(n);
  }
  return t !== void 0 && (e.x = t), e.i = !0, lo = e.p, t ?? /** @type {T} */
  {};
}
function $F() {
  return !0;
}
let jc = [];
function IF() {
  var t = jc;
  jc = [], DF(t);
}
function ru(t) {
  if (jc.length === 0 && !Cm) {
    var e = jc;
    queueMicrotask(() => {
      e === jc && IF();
    });
  }
  jc.push(t);
}
function nQ() {
  for (; jc.length > 0; )
    IF();
}
function Wg(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function iQ() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function oQ() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Ct = !1;
function Us(t) {
  Ct = t;
}
let jt;
function ui(t) {
  if (t === null)
    throw Wg(), gh;
  return jt = t;
}
function tc() {
  return ui(
    /** @type {TemplateNode} */
    /* @__PURE__ */ na(jt)
  );
}
function J(t) {
  if (Ct) {
    if (/* @__PURE__ */ na(jt) !== null)
      throw Wg(), gh;
    jt = t;
  }
}
function q_(t = 1) {
  if (Ct) {
    for (var e = t, r = jt; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ na(r);
    jt = r;
  }
}
function t1(t = !0) {
  for (var e = 0, r = jt; ; ) {
    if (r.nodeType === $h) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === j_) {
        if (e === 0) return r;
        e -= 1;
      } else (n === NF || n === _b) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ na(r)
    );
    t && r.remove(), r = i;
  }
}
function BF(t) {
  if (!t || t.nodeType !== $h)
    throw Wg(), gh;
  return (
    /** @type {Comment} */
    t.data
  );
}
function fs(t) {
  if (typeof t != "object" || t === null || ja in t)
    return t;
  const e = I_(t);
  if (e !== TK && e !== MK)
    return t;
  var r = /* @__PURE__ */ new Map(), n = R_(t), i = /* @__PURE__ */ De(0), o = nh, s = (a) => {
    if (nh === o)
      return a();
    var l = Xt, u = nh;
    eo(null), fD(o);
    var c = a();
    return eo(l), fD(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ De(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && zK();
        var c = r.get(l);
        return c === void 0 ? c = s(() => {
          var h = /* @__PURE__ */ De(u.value);
          return r.set(l, h), h;
        }) : ue(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = s(() => /* @__PURE__ */ De(Vn));
            r.set(l, c), _m(i);
          }
        } else
          ue(u, Vn), _m(i);
        return !0;
      },
      get(a, l, u) {
        if (l === ja)
          return t;
        var c = r.get(l), h = l in a;
        if (c === void 0 && (!h || qu(a, l)?.writable) && (c = s(() => {
          var p = fs(h ? a[l] : Vn), g = /* @__PURE__ */ De(p);
          return g;
        }), r.set(l, c)), c !== void 0) {
          var d = x(c);
          return d === Vn ? void 0 : d;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = x(c));
        } else if (u === void 0) {
          var h = r.get(l), d = h?.v;
          if (h !== void 0 && d !== Vn)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === ja)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== Vn || Reflect.has(a, l);
        if (u !== void 0 || Wt !== null && (!c || qu(a, l)?.writable)) {
          u === void 0 && (u = s(() => {
            var d = c ? fs(a[l]) : Vn, p = /* @__PURE__ */ De(d);
            return p;
          }), r.set(l, u));
          var h = x(u);
          if (h === Vn)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var h = r.get(l), d = l in a;
        if (n && l === "length")
          for (var p = u; p < /** @type {Source<number>} */
          h.v; p += 1) {
            var g = r.get(p + "");
            g !== void 0 ? ue(g, Vn) : p in a && (g = s(() => /* @__PURE__ */ De(Vn)), r.set(p + "", g));
          }
        if (h === void 0)
          (!d || qu(a, l)?.writable) && (h = s(() => /* @__PURE__ */ De(void 0)), ue(h, fs(u)), r.set(l, h));
        else {
          d = h.v !== Vn;
          var v = s(() => fs(u));
          ue(h, v);
        }
        var y = Reflect.getOwnPropertyDescriptor(a, l);
        if (y?.set && y.set.call(c, u), !d) {
          if (n && typeof l == "string") {
            var b = (
              /** @type {Source<number>} */
              r.get("length")
            ), k = Number(l);
            Number.isInteger(k) && k >= b.v && ue(b, k + 1);
          }
          _m(i);
        }
        return !0;
      },
      ownKeys(a) {
        x(i);
        var l = Reflect.ownKeys(a).filter((h) => {
          var d = r.get(h);
          return d === void 0 || d.v !== Vn;
        });
        for (var [u, c] of r)
          c.v !== Vn && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        jK();
      }
    }
  );
}
function aD(t) {
  try {
    if (t !== null && typeof t == "object" && ja in t)
      return t[ja];
  } catch {
  }
  return t;
}
function sQ(t, e) {
  return Object.is(aD(t), aD(e));
}
var a3, LF, zF, jF;
function l3() {
  if (a3 === void 0) {
    a3 = window, LF = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    zF = qu(e, "firstChild").get, jF = qu(e, "nextSibling").get, oD(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), oD(r) && (r.__t = void 0);
  }
}
function bs(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function ri(t) {
  return zF.call(t);
}
// @__NO_SIDE_EFFECTS__
function na(t) {
  return jF.call(t);
}
function Y(t, e) {
  if (!Ct)
    return /* @__PURE__ */ ri(t);
  var r = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ ri(jt)
  );
  if (r === null)
    r = jt.appendChild(bs());
  else if (e && r.nodeType !== Cb) {
    var n = bs();
    return r?.before(n), ui(n), n;
  }
  return ui(r), r;
}
function Ve(t, e = !1) {
  if (!Ct) {
    var r = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ ri(
        /** @type {Node} */
        t
      )
    );
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ na(r) : r;
  }
  if (e && jt?.nodeType !== Cb) {
    var n = bs();
    return jt?.before(n), ui(n), n;
  }
  return jt;
}
function ae(t, e = 1, r = !1) {
  let n = Ct ? jt : t;
  for (var i; e--; )
    i = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ na(n);
  if (!Ct)
    return n;
  if (r && n?.nodeType !== Cb) {
    var o = bs();
    return n === null ? i?.after(o) : n.before(o), ui(o), o;
  }
  return ui(n), /** @type {TemplateNode} */
  n;
}
function qF(t) {
  t.textContent = "";
}
function aQ() {
  return !1;
}
function UF(t) {
  var e = Wt;
  if (e === null)
    return Xt.f |= ju, t;
  if ((e.f & Vg) === 0) {
    if ((e.f & kb) === 0)
      throw t;
    e.b.error(t);
  } else
    gd(t, e);
}
function gd(t, e) {
  for (; e !== null; ) {
    if ((e.f & kb) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const bv = /* @__PURE__ */ new Set();
let jr = null, Sy = null, No = null, _a = [], Sb = null, u3 = !1, Cm = !1;
class Ta {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #l = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #a = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    _a = [], Sy = null, this.apply();
    var r = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const n of e)
      this.#o(n, r);
    this.is_fork || this.#u(), this.#n > 0 || this.is_fork ? (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects)) : (Sy = this, jr = null, lD(r.render_effects), lD(r.effects), Sy = null, this.#l?.resolve()), No = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(e, r) {
    e.f ^= ii;
    for (var n = e.first; n !== null; ) {
      var i = n.f, o = (i & (eu | Nh)) !== 0, s = o && (i & ii) !== 0, a = s || (i & qo) !== 0 || this.skipped_effects.has(n);
      if ((n.f & kb) !== 0 && n.b?.is_pending() && (r = {
        parent: r,
        effect: n,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !a && n.fn !== null) {
        o ? n.f ^= ii : (i & xb) !== 0 ? r.effects.push(n) : Gg(n) && ((n.f & ol) !== 0 && r.block_effects.push(n), Wm(n));
        var l = n.first;
        if (l !== null) {
          n = l;
          continue;
        }
      }
      var u = n.parent;
      for (n = n.next; n === null && u !== null; )
        u === r.effect && (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects), r = /** @type {EffectTarget} */
        r.parent), n = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #s(e) {
    for (const r of e)
      ((r.f & ao) !== 0 ? this.#a : this.#i).push(r), ci(r, ii);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    this.previous.has(e) || this.previous.set(e, r), (e.f & ju) === 0 && (this.current.set(e, e.v), No?.set(e, e.v));
  }
  activate() {
    jr = this, this.apply();
  }
  deactivate() {
    jr = null, No = null;
  }
  flush() {
    if (this.activate(), _a.length > 0) {
      if (VF(), jr !== null && jr !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#n === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#r === 0 && this.#c();
  }
  #c() {
    if (bv.size > 1) {
      this.previous.clear();
      var e = No, r = !0, n = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of bv) {
        if (i === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (i.current.has(a))
            if (r && l !== i.current.get(a))
              i.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const s = [...i.current.keys()].filter((a) => !this.current.has(a));
        if (s.length > 0) {
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            WF(u, s, a, l);
          if (_a.length > 0) {
            jr = i, i.apply();
            for (const u of _a)
              i.#o(u, n);
            _a = [], i.deactivate();
          }
        }
      }
      jr = null, No = e;
    }
    this.committed = !0, bv.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), this.revive();
  }
  revive() {
    for (const e of this.#a)
      ci(e, ao), vh(e);
    for (const e of this.#i)
      ci(e, tu), vh(e);
    this.#a = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#l ??= OF()).promise;
  }
  static ensure() {
    if (jr === null) {
      const e = jr = new Ta();
      bv.add(jr), Cm || Ta.enqueue(() => {
        jr === e && e.flush();
      });
    }
    return jr;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    ru(e);
  }
  apply() {
  }
}
function HF(t) {
  var e = Cm;
  Cm = !0;
  try {
    for (var r; ; ) {
      if (nQ(), _a.length === 0 && (jr?.flush(), _a.length === 0))
        return Sb = null, /** @type {T} */
        r;
      VF();
    }
  } finally {
    Cm = e;
  }
}
function VF() {
  var t = rh;
  u3 = !0;
  try {
    var e = 0;
    for (cD(!0); _a.length > 0; ) {
      var r = Ta.ensure();
      if (e++ > 1e3) {
        var n, i;
        lQ();
      }
      r.process(_a), Uu.clear();
    }
  } finally {
    u3 = !1, cD(t), Sb = null;
  }
}
function lQ() {
  try {
    IK();
  } catch (t) {
    gd(t, Sb);
  }
}
let Dl = null;
function lD(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (zu | qo)) === 0 && Gg(n) && (Dl = /* @__PURE__ */ new Set(), Wm(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null && n.ac === null ? pT(n) : n.fn = null), Dl?.size > 0)) {
        Uu.clear();
        for (const i of Dl) {
          if ((i.f & (zu | qo)) !== 0) continue;
          const o = [i];
          let s = i.parent;
          for (; s !== null; )
            Dl.has(s) && (Dl.delete(s), o.push(s)), s = s.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (zu | qo)) === 0 && Wm(l);
          }
        }
        Dl.clear();
      }
    }
    Dl = null;
  }
}
function WF(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const o = i.f;
      (o & pi) !== 0 ? WF(
        /** @type {Derived} */
        i,
        e,
        r,
        n
      ) : (o & (M_ | ol)) !== 0 && (o & ao) === 0 && // we may have scheduled this one already
      GF(i, e, n) && (ci(i, ao), vh(
        /** @type {Effect} */
        i
      ));
    }
}
function GF(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & pi) !== 0 && GF(
        /** @type {Derived} */
        i,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function vh(t) {
  for (var e = Sb = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (u3 && e === Wt && (r & ol) !== 0 && (r & SF) === 0)
      return;
    if ((r & (Nh | eu)) !== 0) {
      if ((r & ii) === 0) return;
      e.f ^= ii;
    }
  }
  _a.push(e);
}
function uQ(t) {
  let e = 0, r = yh(0), n;
  return () => {
    Eb() && (x(r), Ob(() => (e === 0 && (n = Go(() => t(() => _m(r)))), e += 1, () => {
      ru(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, _m(r));
      });
    })));
  };
}
var cQ = Ql | Wd | kb;
function KF(t, e, r) {
  new hQ(t, e, r);
}
class hQ {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #r = Ct ? jt : null;
  /** @type {BoundaryProps} */
  #n;
  /** @type {((anchor: Node) => void)} */
  #l;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #h = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #f = null;
  #v = uQ(() => (this.#f = yh(this.#d), () => {
    this.#f = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#t = e, this.#n = r, this.#l = n, this.parent = /** @type {Effect} */
    Wt.b, this.#e = !!this.#n.pending, this.#a = dc(() => {
      if (Wt.b = this, Ct) {
        const o = this.#r;
        tc(), /** @type {Comment} */
        o.nodeType === $h && /** @type {Comment} */
        o.data === _b ? this.#b() : this.#y();
      } else {
        var i = this.#x();
        try {
          this.#i = Po(() => n(i));
        } catch (o) {
          this.error(o);
        }
        this.#h > 0 ? this.#g() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, cQ), Ct && (this.#t = jt);
  }
  #y() {
    try {
      this.#i = Po(() => this.#l(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #b() {
    const e = this.#n.pending;
    e && (this.#o = Po(() => e(this.#t)), Ta.enqueue(() => {
      var r = this.#x();
      this.#i = this.#m(() => (Ta.ensure(), Po(() => this.#l(r)))), this.#h > 0 ? this.#g() : (jf(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = bs(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#n.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(e) {
    var r = Wt, n = Xt, i = lo;
    Qa(this.#a), eo(this.#a), md(this.#a.ctx);
    try {
      return e();
    } catch (o) {
      return UF(o), null;
    } finally {
      Qa(r), eo(n), md(i);
    }
  }
  #g() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#n.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), vT(this.#i, this.#u)), this.#o === null && (this.#o = Po(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#h += e, this.#h === 0 && (this.#e = !1, this.#o && jf(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#f && vd(this.#f, this.#d);
  }
  get_effect_pending() {
    return this.#v(), x(
      /** @type {Source<number>} */
      this.#f
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#n.onerror;
    let n = this.#n.failed;
    if (this.#p || !r && !n)
      throw e;
    this.#i && (Ln(this.#i), this.#i = null), this.#o && (Ln(this.#o), this.#o = null), this.#s && (Ln(this.#s), this.#s = null), Ct && (ui(
      /** @type {TemplateNode} */
      this.#r
    ), q_(), ui(t1()));
    var i = !1, o = !1;
    const s = () => {
      if (i) {
        oQ();
        return;
      }
      i = !0, o && UK(), Ta.ensure(), this.#d = 0, this.#s !== null && jf(this.#s, () => {
        this.#s = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#m(() => (this.#p = !1, Po(() => this.#l(this.#t)))), this.#h > 0 ? this.#g() : this.#e = !1;
    };
    var a = Xt;
    try {
      eo(null), o = !0, r?.(e, s), o = !1;
    } catch (l) {
      gd(l, this.#a && this.#a.parent);
    } finally {
      eo(a);
    }
    n && ru(() => {
      this.#s = this.#m(() => {
        Ta.ensure(), this.#p = !0;
        try {
          return Po(() => {
            n(
              this.#t,
              () => e,
              () => s
            );
          });
        } catch (l) {
          return gd(
            l,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function QF(t, e, r, n) {
  const i = Ab;
  if (r.length === 0 && t.length === 0) {
    n(e.map(i));
    return;
  }
  var o = jr, s = (
    /** @type {Effect} */
    Wt
  ), a = fQ();
  function l() {
    Promise.all(r.map((u) => /* @__PURE__ */ dQ(u))).then((u) => {
      a();
      try {
        n([...e.map(i), ...u]);
      } catch (c) {
        (s.f & zu) === 0 && gd(c, s);
      }
      o?.deactivate(), r1();
    }).catch((u) => {
      gd(u, s);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    a();
    try {
      return l();
    } finally {
      o?.deactivate(), r1();
    }
  }) : l();
}
function fQ() {
  var t = Wt, e = Xt, r = lo, n = jr;
  return function(i = !0) {
    Qa(t), eo(e), md(r), i && n?.activate();
  };
}
function r1() {
  Qa(null), eo(null), md(null);
}
// @__NO_SIDE_EFFECTS__
function Ab(t) {
  var e = pi | ao, r = Xt !== null && (Xt.f & pi) !== 0 ? (
    /** @type {Derived} */
    Xt
  ) : null;
  return Wt !== null && (Wt.f |= Wd), {
    ctx: lo,
    deps: null,
    effects: null,
    equals: FF,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      Vn
    ),
    wv: 0,
    parent: r ?? Wt,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function dQ(t, e) {
  let r = (
    /** @type {Effect | null} */
    Wt
  );
  r === null && PK();
  var n = (
    /** @type {Boundary} */
    r.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), o = yh(
    /** @type {V} */
    Vn
  ), s = !Xt, a = /* @__PURE__ */ new Map();
  return SQ(() => {
    var l = OF();
    i = l.promise;
    try {
      Promise.resolve(t()).then(l.resolve, l.reject).then(() => {
        u === jr && u.committed && u.deactivate(), r1();
      });
    } catch (d) {
      l.reject(d), r1();
    }
    var u = (
      /** @type {Batch} */
      jr
    );
    if (s) {
      var c = !n.is_pending();
      n.update_pending_count(1), u.increment(c), a.get(u)?.reject(Of), a.delete(u), a.set(u, l);
    }
    const h = (d, p = void 0) => {
      if (u.activate(), p)
        p !== Of && (o.f |= ju, vd(o, p));
      else {
        (o.f & ju) !== 0 && (o.f ^= ju), vd(o, d);
        for (const [g, v] of a) {
          if (a.delete(g), g === u) break;
          v.reject(Of);
        }
      }
      s && (n.update_pending_count(-1), u.decrement(c));
    };
    l.promise.then(h, (d) => h(null, d || "unknown"));
  }), Db(() => {
    for (const l of a.values())
      l.reject(Of);
  }), new Promise((l) => {
    function u(c) {
      function h() {
        c === i ? l(o) : u(i);
      }
      c.then(h, h);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function K(t) {
  const e = /* @__PURE__ */ Ab(t);
  return rT(e), e;
}
// @__NO_SIDE_EFFECTS__
function XF(t) {
  const e = /* @__PURE__ */ Ab(t);
  return e.equals = TF, e;
}
function JF(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Ln(
        /** @type {Effect} */
        e[r]
      );
  }
}
function pQ(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & pi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function U_(t) {
  var e, r = Wt;
  Qa(pQ(t));
  try {
    t.f &= ~Hm, JF(t), e = sT(t);
  } finally {
    Qa(r);
  }
  return e;
}
function YF(t) {
  var e = U_(t);
  if (t.equals(e) || (t.v = e, t.wv = iT()), !Ih)
    if (No !== null)
      Eb() && No.set(t, t.v);
    else {
      var r = (t.f & Gs) === 0 ? tu : ii;
      ci(t, r);
    }
}
let c3 = /* @__PURE__ */ new Set();
const Uu = /* @__PURE__ */ new Map();
let ZF = !1;
function yh(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: FF,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function De(t, e) {
  const r = yh(t);
  return rT(r), r;
}
// @__NO_SIDE_EFFECTS__
function H_(t, e = !1, r = !0) {
  const n = yh(t);
  return e || (n.equals = TF), n;
}
function ue(t, e, r = !1) {
  Xt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Ma || (Xt.f & iD) !== 0) && $F() && (Xt.f & (pi | ol | M_ | iD)) !== 0 && !Ul?.includes(t) && qK();
  let n = r ? fs(e) : e;
  return vd(t, n);
}
function vd(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Ih ? Uu.set(t, e) : Uu.set(t, r), t.v = e;
    var n = Ta.ensure();
    n.capture(t, r), (t.f & pi) !== 0 && ((t.f & ao) !== 0 && U_(
      /** @type {Derived} */
      t
    ), ci(t, (t.f & Gs) !== 0 ? ii : tu)), t.wv = iT(), eT(t, ao), Wt !== null && (Wt.f & ii) !== 0 && (Wt.f & (eu | Nh)) === 0 && (as === null ? yQ([t]) : as.push(t)), !n.is_fork && c3.size > 0 && !ZF && mQ();
  }
  return e;
}
function mQ() {
  ZF = !1;
  const t = Array.from(c3);
  for (const e of t)
    (e.f & ii) !== 0 && ci(e, tu), Gg(e) && Wm(e);
  c3.clear();
}
function _m(t) {
  ue(t, t.v + 1);
}
function eT(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = r.length, i = 0; i < n; i++) {
      var o = r[i], s = o.f, a = (s & ao) === 0;
      if (a && ci(o, e), (s & pi) !== 0) {
        var l = (
          /** @type {Derived} */
          o
        );
        No?.delete(l), (s & Hm) === 0 && (s & Gs && (o.f |= Hm), eT(l, tu));
      } else a && ((s & ol) !== 0 && Dl !== null && Dl.add(
        /** @type {Effect} */
        o
      ), vh(
        /** @type {Effect} */
        o
      ));
    }
}
function gQ(t, e) {
  if (e) {
    const r = document.body;
    t.autofocus = !0, ru(() => {
      document.activeElement === r && t.focus();
    });
  }
}
let uD = !1;
function tT() {
  uD || (uD = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function Gd(t) {
  var e = Xt, r = Wt;
  eo(null), Qa(null);
  try {
    return t();
  } finally {
    eo(e), Qa(r);
  }
}
function vQ(t, e, r, n = r) {
  t.addEventListener(e, () => Gd(r));
  const i = t.__on_r;
  i ? t.__on_r = () => {
    i(), n(!0);
  } : t.__on_r = () => n(!0), tT();
}
let rh = !1;
function cD(t) {
  rh = t;
}
let Ih = !1;
function hD(t) {
  Ih = t;
}
let Xt = null, Ma = !1;
function eo(t) {
  Xt = t;
}
let Wt = null;
function Qa(t) {
  Wt = t;
}
let Ul = null;
function rT(t) {
  Xt !== null && (Ul === null ? Ul = [t] : Ul.push(t));
}
let Si = null, Do = 0, as = null;
function yQ(t) {
  as = t;
}
let nT = 1, Vm = 0, nh = Vm;
function fD(t) {
  nh = t;
}
function iT() {
  return ++nT;
}
function Gg(t) {
  var e = t.f;
  if ((e & ao) !== 0)
    return !0;
  if (e & pi && (t.f &= ~Hm), (e & tu) !== 0) {
    var r = t.deps;
    if (r !== null)
      for (var n = r.length, i = 0; i < n; i++) {
        var o = r[i];
        if (Gg(
          /** @type {Derived} */
          o
        ) && YF(
          /** @type {Derived} */
          o
        ), o.wv > t.wv)
          return !0;
      }
    (e & Gs) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    No === null && ci(t, ii);
  }
  return !1;
}
function oT(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !Ul?.includes(t))
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      (o.f & pi) !== 0 ? oT(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? ci(o, ao) : (o.f & ii) !== 0 && ci(o, tu), vh(
        /** @type {Effect} */
        o
      ));
    }
}
function sT(t) {
  var e = Si, r = Do, n = as, i = Xt, o = Ul, s = lo, a = Ma, l = nh, u = t.f;
  Si = /** @type {null | Value[]} */
  null, Do = 0, as = null, Xt = (u & (eu | Nh)) === 0 ? t : null, Ul = null, md(t.ctx), Ma = !1, nh = ++Vm, t.ac !== null && (Gd(() => {
    t.ac.abort(Of);
  }), t.ac = null);
  try {
    t.f |= s3;
    var c = (
      /** @type {Function} */
      t.fn
    ), h = c(), d = t.deps;
    if (Si !== null) {
      var p;
      if (n1(t, Do), d !== null && Do > 0)
        for (d.length = Do + Si.length, p = 0; p < Si.length; p++)
          d[Do + p] = Si[p];
      else
        t.deps = d = Si;
      if (rh && Eb() && (t.f & Gs) !== 0)
        for (p = Do; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Do < d.length && (n1(t, Do), d.length = Do);
    if ($F() && as !== null && !Ma && d !== null && (t.f & (pi | tu | ao)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      as.length; p++)
        oT(
          as[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (Vm++, as !== null && (n === null ? n = as : n.push(.../** @type {Source[]} */
    as))), (t.f & ju) !== 0 && (t.f ^= ju), h;
  } catch (g) {
    return UF(g);
  } finally {
    t.f ^= s3, Si = e, Do = r, as = n, Xt = i, Ul = o, md(s), Ma = a, nh = l;
  }
}
function bQ(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = FK.call(r, t);
    if (n !== -1) {
      var i = r.length - 1;
      i === 0 ? r = e.reactions = null : (r[n] = r[i], r.pop());
    }
  }
  r === null && (e.f & pi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Si === null || !Si.includes(e)) && (ci(e, tu), (e.f & Gs) !== 0 && (e.f ^= Gs, e.f &= ~Hm), JF(
    /** @type {Derived} **/
    e
  ), n1(
    /** @type {Derived} **/
    e,
    0
  ));
}
function n1(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      bQ(t, r[n]);
}
function Wm(t) {
  var e = t.f;
  if ((e & zu) === 0) {
    ci(t, ii);
    var r = Wt, n = rh;
    Wt = t, rh = !0;
    try {
      (e & ol) !== 0 ? AQ(t) : fT(t), hT(t);
      var i = sT(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = nT;
      var o;
      OK && HK && (t.f & ao) !== 0 && t.deps;
    } finally {
      rh = n, Wt = r;
    }
  }
}
async function xQ() {
  await Promise.resolve(), HF();
}
function x(t) {
  var e = t.f, r = (e & pi) !== 0;
  if (Xt !== null && !Ma) {
    var n = Wt !== null && (Wt.f & zu) !== 0;
    if (!n && !Ul?.includes(t)) {
      var i = Xt.deps;
      if ((Xt.f & s3) !== 0)
        t.rv < Vm && (t.rv = Vm, Si === null && i !== null && i[Do] === t ? Do++ : Si === null ? Si = [t] : Si.includes(t) || Si.push(t));
      else {
        (Xt.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Xt] : o.includes(Xt) || o.push(Xt);
      }
    }
  }
  if (Ih) {
    if (Uu.has(t))
      return Uu.get(t);
    if (r) {
      var s = (
        /** @type {Derived} */
        t
      ), a = s.v;
      return ((s.f & ii) === 0 && s.reactions !== null || lT(s)) && (a = U_(s)), Uu.set(s, a), a;
    }
  } else if (r) {
    if (s = /** @type {Derived} */
    t, No?.has(s))
      return No.get(s);
    Gg(s) && YF(s), rh && Eb() && (s.f & Gs) === 0 && aT(s);
  } else if (No?.has(t))
    return No.get(t);
  if ((t.f & ju) !== 0)
    throw t.v;
  return t.v;
}
function aT(t) {
  if (t.deps !== null) {
    t.f ^= Gs;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & pi) !== 0 && (e.f & Gs) === 0 && aT(
        /** @type {Derived} */
        e
      );
  }
}
function lT(t) {
  if (t.v === Vn) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Uu.has(e) || (e.f & pi) !== 0 && lT(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function Go(t) {
  var e = Ma;
  try {
    return Ma = !0, t();
  } finally {
    Ma = e;
  }
}
const wQ = -7169;
function ci(t, e) {
  t.f = t.f & wQ | e;
}
function kQ(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (ja in t)
      h3(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && ja in r && h3(r);
      }
  }
}
function h3(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        h3(t[n], e);
      } catch {
      }
    const r = I_(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = EF(r);
      for (let i in n) {
        const o = n[i].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
function uT(t) {
  Wt === null && (Xt === null && $K(), NK()), Ih && RK();
}
function CQ(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function sl(t, e, r, n = !0) {
  var i = Wt;
  i !== null && (i.f & qo) !== 0 && (t |= qo);
  var o = {
    ctx: lo,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | ao | Gs,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      Wm(o), o.f |= Vg;
    } catch (l) {
      throw Ln(o), l;
    }
  else e !== null && vh(o);
  if (n) {
    var s = o;
    if (r && s.deps === null && s.teardown === null && s.nodes_start === null && s.first === s.last && // either `null`, or a singular child
    (s.f & Wd) === 0 && (s = s.first, (t & ol) !== 0 && (t & Ql) !== 0 && s !== null && (s.f |= Ql)), s !== null && (s.parent = i, i !== null && CQ(s, i), Xt !== null && (Xt.f & pi) !== 0 && (t & Nh) === 0)) {
      var a = (
        /** @type {Derived} */
        Xt
      );
      (a.effects ??= []).push(s);
    }
  }
  return o;
}
function Eb() {
  return Xt !== null && !Ma;
}
function Db(t) {
  const e = sl(wb, null, !1);
  return ci(e, ii), e.teardown = t, e;
}
function Vs(t) {
  uT();
  var e = (
    /** @type {Effect} */
    Wt.f
  ), r = !Xt && (e & eu) !== 0 && (e & Vg) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      lo
    );
    (n.e ??= []).push(t);
  } else
    return cT(t);
}
function cT(t) {
  return sl(xb | AF, t, !1);
}
function mt(t) {
  return uT(), sl(wb | AF, t, !0);
}
function _Q(t) {
  Ta.ensure();
  const e = sl(Nh | Wd, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? jf(e, () => {
      Ln(e), n(void 0);
    }) : (Ln(e), n(void 0));
  });
}
function Kd(t) {
  return sl(xb, t, !1);
}
function SQ(t) {
  return sl(M_ | Wd, t, !0);
}
function Ob(t, e = 0) {
  return sl(wb | e, t, !0);
}
function Ae(t, e = [], r = [], n = [], i = !1) {
  QF(n, e, r, (o) => {
    sl(i ? xb : wb, () => t(...o.map(x)), !0);
  });
}
function dc(t, e = 0) {
  var r = sl(ol | e, t, !0);
  return r;
}
function Po(t, e = !0) {
  return sl(eu | Wd, t, !0, e);
}
function hT(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Ih, n = Xt;
    hD(!0), eo(null);
    try {
      e.call(null);
    } finally {
      hD(r), eo(n);
    }
  }
}
function fT(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const i = r.ac;
    i !== null && Gd(() => {
      i.abort(Of);
    });
    var n = r.next;
    (r.f & Nh) !== 0 ? r.parent = null : Ln(r, e), r = n;
  }
}
function AQ(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & eu) === 0 && Ln(e), e = r;
  }
}
function Ln(t, e = !0) {
  var r = !1;
  (e || (t.f & SF) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (dT(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), r = !0), fT(t, e && !r), n1(t, 0), ci(t, zu);
  var n = t.transitions;
  if (n !== null)
    for (const o of n)
      o.stop();
  hT(t);
  var i = t.parent;
  i !== null && i.first !== null && pT(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function dT(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ na(t)
    );
    t.remove(), t = r;
  }
}
function pT(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function jf(t, e, r = !0) {
  var n = [];
  V_(t, n, !0), mT(n, () => {
    r && Ln(t), e && e();
  });
}
function mT(t, e) {
  var r = t.length;
  if (r > 0) {
    var n = () => --r || e();
    for (var i of t)
      i.out(n);
  } else
    e();
}
function V_(t, e, r) {
  if ((t.f & qo) === 0) {
    if (t.f ^= qo, t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || r) && e.push(s);
    for (var n = t.first; n !== null; ) {
      var i = n.next, o = (n.f & Ql) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (n.f & eu) !== 0 && (t.f & ol) !== 0;
      V_(n, e, o ? r : !1), n = i;
    }
  }
}
function W_(t) {
  gT(t, !0);
}
function gT(t, e) {
  if ((t.f & qo) !== 0) {
    t.f ^= qo, (t.f & ii) === 0 && (ci(t, ao), vh(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, i = (r.f & Ql) !== 0 || (r.f & eu) !== 0;
      gT(r, i ? e : !1), r = n;
    }
    if (t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || e) && o.in();
  }
}
function vT(t, e) {
  for (var r = t.nodes_start, n = t.nodes_end; r !== null; ) {
    var i = r === n ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ na(r)
    );
    e.append(r), r = i;
  }
}
const yT = /* @__PURE__ */ new Set(), f3 = /* @__PURE__ */ new Set();
function bT(t, e, r, n = {}) {
  function i(o) {
    if (n.capture || um.call(e, o), !o.cancelBubble)
      return Gd(() => r?.call(this, o));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? ru(() => {
    e.addEventListener(t, i, n);
  }) : e.addEventListener(t, i, n), i;
}
function EQ(t, e, r, n, i) {
  var o = { capture: n, passive: i }, s = bT(t, e, r, o);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && Db(() => {
    e.removeEventListener(t, s, o);
  });
}
function nn(t) {
  for (var e = 0; e < t.length; e++)
    yT.add(t[e]);
  for (var r of f3)
    r(t);
}
let dD = null;
function um(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, i = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  dD = t;
  var s = 0, a = dD === t && t.__root;
  if (a) {
    var l = i.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    l <= u && (s = l);
  }
  if (o = /** @type {Element} */
  i[s] || t.target, o !== e) {
    $_(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Xt, h = Wt;
    eo(null), Qa(null);
    try {
      for (var d, p = []; o !== null; ) {
        var g = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var v = o["__" + n];
          v != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && v.call(o, t);
        } catch (y) {
          d ? p.push(y) : d = y;
        }
        if (t.cancelBubble || g === e || g === null)
          break;
        o = g;
      }
      if (d) {
        for (let y of p)
          queueMicrotask(() => {
            throw y;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, eo(c), Qa(h);
    }
  }
}
function G_(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Uo(t, e) {
  var r = (
    /** @type {Effect} */
    Wt
  );
  r.nodes_start === null && (r.nodes_start = t, r.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function me(t, e) {
  var r = (e & RF) !== 0, n = (e & eQ) !== 0, i, o = !t.startsWith("<!>");
  return () => {
    if (Ct)
      return Uo(jt, null), jt;
    i === void 0 && (i = G_(o ? t : "<!>" + t), r || (i = /** @type {Node} */
    /* @__PURE__ */ ri(i)));
    var s = (
      /** @type {TemplateNode} */
      n || LF ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ri(s)
      ), l = (
        /** @type {TemplateNode} */
        s.lastChild
      );
      Uo(a, l);
    } else
      Uo(s, s);
    return s;
  };
}
// @__NO_SIDE_EFFECTS__
function DQ(t, e, r = "svg") {
  var n = !t.startsWith("<!>"), i = (e & RF) !== 0, o = `<${r}>${n ? t : "<!>" + t}</${r}>`, s;
  return () => {
    if (Ct)
      return Uo(jt, null), jt;
    if (!s) {
      var a = (
        /** @type {DocumentFragment} */
        G_(o)
      ), l = (
        /** @type {Element} */
        /* @__PURE__ */ ri(a)
      );
      if (i)
        for (s = document.createDocumentFragment(); /* @__PURE__ */ ri(l); )
          s.appendChild(
            /** @type {Node} */
            /* @__PURE__ */ ri(l)
          );
      else
        s = /** @type {Element} */
        /* @__PURE__ */ ri(l);
    }
    var u = (
      /** @type {TemplateNode} */
      s.cloneNode(!0)
    );
    if (i) {
      var c = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ri(u)
      ), h = (
        /** @type {TemplateNode} */
        u.lastChild
      );
      Uo(c, h);
    } else
      Uo(u, u);
    return u;
  };
}
// @__NO_SIDE_EFFECTS__
function Dt(t, e) {
  return /* @__PURE__ */ DQ(t, e, "svg");
}
function Ro(t = "") {
  if (!Ct) {
    var e = bs(t + "");
    return Uo(e, e), e;
  }
  var r = jt;
  return r.nodeType !== Cb && (r.before(r = bs()), ui(r)), Uo(r, r), r;
}
function kr() {
  if (Ct)
    return Uo(jt, null), jt;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = bs();
  return t.append(e, r), Uo(e, r), t;
}
function X(t, e) {
  if (Ct) {
    var r = (
      /** @type {Effect} */
      Wt
    );
    ((r.f & Vg) === 0 || r.nodes_end === null) && (r.nodes_end = jt), tc();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
function OQ(t) {
  return t.endsWith("capture") && t !== "gotpointercapture" && t !== "lostpointercapture";
}
const FQ = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function TQ(t) {
  return FQ.includes(t);
}
const MQ = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function PQ(t) {
  return t = t.toLowerCase(), MQ[t] ?? t;
}
const RQ = ["touchstart", "touchmove"];
function NQ(t) {
  return RQ.includes(t);
}
let d3 = !0;
function ut(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function xT(t, e) {
  return wT(t, e);
}
function $Q(t, e) {
  l3(), e.intro = e.intro ?? !1;
  const r = e.target, n = Ct, i = jt;
  try {
    for (var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ri(r)
    ); o && (o.nodeType !== $h || /** @type {Comment} */
    o.data !== NF); )
      o = /** @type {TemplateNode} */
      /* @__PURE__ */ na(o);
    if (!o)
      throw gh;
    Us(!0), ui(
      /** @type {Comment} */
      o
    );
    const s = wT(t, { ...e, anchor: o });
    return Us(!1), /**  @type {Exports} */
    s;
  } catch (s) {
    if (s instanceof Error && s.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw s;
    return s !== gh && console.warn("Failed to hydrate: ", s), e.recover === !1 && BK(), l3(), qF(r), Us(!1), xT(t, e);
  } finally {
    Us(n), ui(i);
  }
}
const mf = /* @__PURE__ */ new Map();
function wT(t, { target: e, anchor: r, props: n = {}, events: i, context: o, intro: s = !0 }) {
  l3();
  var a = /* @__PURE__ */ new Set(), l = (h) => {
    for (var d = 0; d < h.length; d++) {
      var p = h[d];
      if (!a.has(p)) {
        a.add(p);
        var g = NQ(p);
        e.addEventListener(p, um, { passive: g });
        var v = mf.get(p);
        v === void 0 ? (document.addEventListener(p, um, { passive: g }), mf.set(p, 1)) : mf.set(p, v + 1);
      }
    }
  };
  l(N_(yT)), f3.add(l);
  var u = void 0, c = _Q(() => {
    var h = r ?? e.appendChild(bs());
    return KF(
      /** @type {TemplateNode} */
      h,
      {
        pending: () => {
        }
      },
      (d) => {
        if (o) {
          nt({});
          var p = (
            /** @type {ComponentContext} */
            lo
          );
          p.c = o;
        }
        if (i && (n.$$events = i), Ct && Uo(
          /** @type {TemplateNode} */
          d,
          null
        ), d3 = s, u = t(d, n) || {}, d3 = !0, Ct && (Wt.nodes_end = jt, jt === null || jt.nodeType !== $h || /** @type {Comment} */
        jt.data !== j_))
          throw Wg(), gh;
        o && it();
      }
    ), () => {
      for (var d of a) {
        e.removeEventListener(d, um);
        var p = (
          /** @type {number} */
          mf.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, um), mf.delete(d)) : mf.set(d, p);
      }
      f3.delete(l), h !== r && h.parentNode?.removeChild(h);
    };
  });
  return p3.set(u, c), u;
}
let p3 = /* @__PURE__ */ new WeakMap();
function IQ(t, e) {
  const r = p3.get(t);
  return r ? (p3.delete(t), r(e)) : Promise.resolve();
}
function kT(t) {
  return new BQ(t);
}
class BQ {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, s) => {
      var a = /* @__PURE__ */ H_(s, !1, !1);
      return r.set(o, a), a;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, s) {
          return x(r.get(s) ?? n(s, Reflect.get(o, s)));
        },
        has(o, s) {
          return s === P_ ? !0 : (x(r.get(s) ?? n(s, Reflect.get(o, s))), Reflect.has(o, s));
        },
        set(o, s, a) {
          return ue(r.get(s) ?? n(s, a), a), Reflect.set(o, s, a);
        }
      }
    );
    this.#t = (e.hydrate ? $Q : xT)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && HF(), this.#e = i.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || $_(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(s) {
          this.#t[o] = s;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(i, o);
    }, this.#t.$destroy = () => {
      IQ(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...i) => r.call(this, ...i);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const LQ = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(LQ);
class Fb {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #r = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#n = r;
  }
  #l = () => {
    var e = (
      /** @type {Batch} */
      jr
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        W_(n);
      else {
        var i = this.#r.get(r);
        i && (this.#t.set(r, i.effect), this.#r.delete(r), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), n = i.effect);
      }
      for (const [o, s] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(s);
        a && (Ln(a.effect), this.#r.delete(s));
      }
      for (const [o, s] of this.#t) {
        if (o === r) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var l = document.createDocumentFragment();
            vT(s, l), l.append(bs()), this.#r.set(o, { effect: s, fragment: l });
          } else
            Ln(s);
          this.#t.delete(o);
        };
        this.#n || !n ? jf(s, a, !1) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #a = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, i] of this.#r)
      r.includes(n) || (Ln(i.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      jr
    ), i = aQ();
    r && !this.#t.has(e) && !this.#r.has(e) && this.#t.set(
      e,
      Po(() => r(this.anchor))
    ), this.#e.set(n, e), i || (Ct && (this.anchor = jt), this.#l());
  }
}
function Xl(t, e, ...r) {
  var n = new Fb(t);
  dc(() => {
    const i = e() ?? null;
    n.ensure(i, i && ((o) => i(o, ...r)));
  }, Ql);
}
function Kg(t) {
  lo === null && MF(), Vs(() => {
    const e = Go(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function CT(t) {
  lo === null && MF(), Kg(() => () => Go(t));
}
function Oe(t, e, r = !1) {
  Ct && tc();
  var n = new Fb(t), i = r ? Ql : 0;
  function o(s, a) {
    if (Ct) {
      const u = BF(t) === _b;
      if (s === u) {
        var l = t1();
        ui(l), n.anchor = l, Us(!1), n.ensure(s, a), Us(!0);
        return;
      }
    }
    n.ensure(s, a);
  }
  dc(() => {
    var s = !1;
    e((a, l = !0) => {
      s = !0, o(l, a);
    }), s || o(!1, null);
  }, i);
}
function _T(t, e, r) {
  Ct && tc();
  var n = new Fb(t);
  dc(() => {
    var i = e();
    n.ensure(i, r);
  });
}
let Ay = null;
function cr(t, e) {
  return e;
}
function zQ(t, e, r) {
  for (var n = t.items, i = [], o = e.length, s = 0; s < o; s++)
    V_(e[s].e, i, !0);
  var a = o > 0 && i.length === 0 && r !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      r.parentNode
    );
    qF(l), l.append(
      /** @type {Element} */
      r
    ), n.clear(), xa(t, e[0].prev, e[o - 1].next);
  }
  mT(i, () => {
    for (var u = 0; u < o; u++) {
      var c = e[u];
      a || (n.delete(c.k), xa(t, c.prev, c.next)), Ln(c.e, !a);
    }
  });
}
function Nt(t, e, r, n, i, o = null) {
  var s = t, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & PF) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    s = Ct ? ui(
      /** @type {Comment | Text} */
      /* @__PURE__ */ ri(u)
    ) : u.appendChild(bs());
  }
  Ct && tc();
  var c = null, h = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ XF(() => {
    var b = r();
    return R_(b) ? b : b == null ? [] : N_(b);
  }), g, v;
  function y() {
    jQ(
      v,
      g,
      a,
      d,
      s,
      i,
      e,
      n,
      r
    ), o !== null && (g.length === 0 ? c ? W_(c) : c = Po(() => o(s)) : c !== null && jf(c, () => {
      c = null;
    }));
  }
  dc(() => {
    v ??= /** @type {Effect} */
    Wt, g = /** @type {V[]} */
    x(p);
    var b = g.length;
    if (h && b === 0)
      return;
    h = b === 0;
    let k = !1;
    if (Ct) {
      var C = BF(s) === _b;
      C !== (b === 0) && (s = t1(), ui(s), Us(!1), k = !0);
    }
    if (Ct) {
      for (var S = null, _, D = 0; D < b; D++) {
        if (jt.nodeType === $h && /** @type {Comment} */
        jt.data === j_) {
          s = /** @type {Comment} */
          jt, k = !0, Us(!1);
          break;
        }
        var A = g[D], O = n(A, D);
        _ = ST(
          jt,
          a,
          S,
          null,
          A,
          O,
          D,
          i,
          e,
          r
        ), a.items.set(O, _), S = _;
      }
      b > 0 && ui(t1());
    }
    Ct ? b === 0 && o && (c = Po(() => o(s))) : y(), k && Us(!0), x(p);
  }), Ct && (s = jt);
}
function jQ(t, e, r, n, i, o, s, a, l) {
  var u = (s & VK) !== 0, c = (s & (L_ | z_)) !== 0, h = e.length, d = r.items, p = r.first, g = p, v, y = null, b, k = [], C = [], S, _, D, A;
  if (u)
    for (A = 0; A < h; A += 1)
      S = e[A], _ = a(S, A), D = d.get(_), D !== void 0 && (D.a?.measure(), (b ??= /* @__PURE__ */ new Set()).add(D));
  for (A = 0; A < h; A += 1) {
    if (S = e[A], _ = a(S, A), D = d.get(_), D === void 0) {
      var O = n.get(_);
      if (O !== void 0) {
        n.delete(_), d.set(_, O);
        var M = y ? y.next : g;
        xa(r, y, O), xa(r, O, M), h2(O, M, i), y = O;
      } else {
        var z = g ? (
          /** @type {TemplateNode} */
          g.e.nodes_start
        ) : i;
        y = ST(
          z,
          r,
          y,
          y === null ? r.first : y.next,
          S,
          _,
          A,
          o,
          s,
          l
        );
      }
      d.set(_, y), k = [], C = [], g = y.next;
      continue;
    }
    if (c && qQ(D, S, A, s), (D.e.f & qo) !== 0 && (W_(D.e), u && (D.a?.unfix(), (b ??= /* @__PURE__ */ new Set()).delete(D))), D !== g) {
      if (v !== void 0 && v.has(D)) {
        if (k.length < C.length) {
          var R = C[0], N;
          y = R.prev;
          var I = k[0], B = k[k.length - 1];
          for (N = 0; N < k.length; N += 1)
            h2(k[N], R, i);
          for (N = 0; N < C.length; N += 1)
            v.delete(C[N]);
          xa(r, I.prev, B.next), xa(r, y, I), xa(r, B, R), g = R, y = B, A -= 1, k = [], C = [];
        } else
          v.delete(D), h2(D, g, i), xa(r, D.prev, D.next), xa(r, D, y === null ? r.first : y.next), xa(r, y, D), y = D;
        continue;
      }
      for (k = [], C = []; g !== null && g.k !== _; )
        (g.e.f & qo) === 0 && (v ??= /* @__PURE__ */ new Set()).add(g), C.push(g), g = g.next;
      if (g === null)
        continue;
      D = g;
    }
    k.push(D), y = D, g = D.next;
  }
  if (g !== null || v !== void 0) {
    for (var $ = v === void 0 ? [] : N_(v); g !== null; )
      (g.e.f & qo) === 0 && $.push(g), g = g.next;
    var q = $.length;
    if (q > 0) {
      var U = (s & PF) !== 0 && h === 0 ? i : null;
      if (u) {
        for (A = 0; A < q; A += 1)
          $[A].a?.measure();
        for (A = 0; A < q; A += 1)
          $[A].a?.fix();
      }
      zQ(r, $, U);
    }
  }
  u && ru(() => {
    if (b !== void 0)
      for (D of b)
        D.a?.apply();
  }), t.first = r.first && r.first.e, t.last = y && y.e;
  for (var H of n.values())
    Ln(H.e);
  n.clear();
}
function qQ(t, e, r, n) {
  (n & L_) !== 0 && vd(t.v, e), (n & z_) !== 0 ? vd(
    /** @type {Value<number>} */
    t.i,
    r
  ) : t.i = r;
}
function ST(t, e, r, n, i, o, s, a, l, u, c) {
  var h = Ay, d = (l & L_) !== 0, p = (l & WK) === 0, g = d ? p ? /* @__PURE__ */ H_(i, !1, !1) : yh(i) : i, v = (l & z_) === 0 ? s : yh(s), y = {
    i: v,
    v: g,
    k: o,
    a: null,
    // @ts-expect-error
    e: null,
    prev: r,
    next: n
  };
  Ay = y;
  try {
    if (t === null) {
      var b = document.createDocumentFragment();
      b.append(t = bs());
    }
    return y.e = Po(() => a(
      /** @type {Node} */
      t,
      g,
      v,
      u
    ), Ct), y.e.prev = r && r.e, y.e.next = n && n.e, r === null ? c || (e.first = y) : (r.next = y, r.e.next = y.e), n !== null && (n.prev = y, n.e.prev = y.e), y;
  } finally {
    Ay = h;
  }
}
function h2(t, e, r) {
  for (var n = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : r, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : r, o = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); o !== null && o !== n; ) {
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ na(o)
    );
    i.before(o), o = s;
  }
}
function xa(t, e, r) {
  e === null ? t.first = r : (e.next = r, e.e.next = r && r.e), r !== null && (r.prev = e, r.e.prev = e && e.e);
}
function UQ(t, e, r = !1, n = !1, i = !1) {
  var o = t, s = "";
  Ae(() => {
    var a = (
      /** @type {Effect} */
      Wt
    );
    if (s === (s = e() ?? "")) {
      Ct && tc();
      return;
    }
    if (a.nodes_start !== null && (dT(
      a.nodes_start,
      /** @type {TemplateNode} */
      a.nodes_end
    ), a.nodes_start = a.nodes_end = null), s !== "") {
      if (Ct) {
        jt.data;
        for (var l = tc(), u = l; l !== null && (l.nodeType !== $h || /** @type {Comment} */
        l.data !== ""); )
          u = l, l = /** @type {TemplateNode} */
          /* @__PURE__ */ na(l);
        if (l === null)
          throw Wg(), gh;
        Uo(jt, u), o = ui(l);
        return;
      }
      var c = s + "";
      r ? c = `<svg>${c}</svg>` : n && (c = `<math>${c}</math>`);
      var h = G_(c);
      if ((r || n) && (h = /** @type {Element} */
      /* @__PURE__ */ ri(h)), Uo(
        /** @type {TemplateNode} */
        /* @__PURE__ */ ri(h),
        /** @type {TemplateNode} */
        h.lastChild
      ), r || n)
        for (; /* @__PURE__ */ ri(h); )
          o.before(
            /** @type {Node} */
            /* @__PURE__ */ ri(h)
          );
      else
        o.before(h);
    }
  });
}
function Qd(t, e, r) {
  Ct && tc();
  var n = new Fb(t);
  dc(() => {
    var i = e() ?? null;
    n.ensure(i, i && ((o) => r(o, i)));
  }, Ql);
}
function To(t, e, r) {
  Kd(() => {
    var n = Go(() => e(t, r?.()) || {});
    if (r && n?.update) {
      var i = !1, o = (
        /** @type {any} */
        {}
      );
      Ob(() => {
        var s = r();
        kQ(s), i && B_(o, s) && (o = s, n.update(s));
      }), i = !0;
    }
    if (n?.destroy)
      return () => (
        /** @type {Function} */
        n.destroy()
      );
  });
}
function HQ(t, e) {
  var r = void 0, n;
  dc(() => {
    r !== (r = e()) && (n && (Ln(n), n = null), r && (n = Po(() => {
      Kd(() => (
        /** @type {(node: Element) => void} */
        r(t)
      ));
    })));
  });
}
function AT(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (r = AT(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function VQ() {
  for (var t, e, r = 0, n = "", i = arguments.length; r < i; r++) (t = arguments[r]) && (e = AT(t)) && (n && (n += " "), n += e);
  return n;
}
function Tb(t) {
  return typeof t == "object" ? VQ(t) : t ?? "";
}
const pD = [...` 	
\r\fÂ \v\uFEFF`];
function WQ(t, e, r) {
  var n = t == null ? "" : "" + t;
  if (e && (n = n ? n + " " + e : e), r) {
    for (var i in r)
      if (r[i])
        n = n ? n + " " + i : i;
      else if (n.length)
        for (var o = i.length, s = 0; (s = n.indexOf(i, s)) >= 0; ) {
          var a = s + o;
          (s === 0 || pD.includes(n[s - 1])) && (a === n.length || pD.includes(n[a])) ? n = (s === 0 ? "" : n.substring(0, s)) + n.substring(a + 1) : s = a;
        }
  }
  return n === "" ? null : n;
}
function mD(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var i in t) {
    var o = t[i];
    o != null && o !== "" && (n += " " + i + ": " + o + r);
  }
  return n;
}
function f2(t) {
  return t[0] !== "-" || t[1] !== "-" ? t.toLowerCase() : t;
}
function GQ(t, e) {
  if (e) {
    var r = "", n, i;
    if (Array.isArray(e) ? (n = e[0], i = e[1]) : n = e, t) {
      t = String(t).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var o = !1, s = 0, a = !1, l = [];
      n && l.push(...Object.keys(n).map(f2)), i && l.push(...Object.keys(i).map(f2));
      var u = 0, c = -1;
      const v = t.length;
      for (var h = 0; h < v; h++) {
        var d = t[h];
        if (a ? d === "/" && t[h - 1] === "*" && (a = !1) : o ? o === d && (o = !1) : d === "/" && t[h + 1] === "*" ? a = !0 : d === '"' || d === "'" ? o = d : d === "(" ? s++ : d === ")" && s--, !a && o === !1 && s === 0) {
          if (d === ":" && c === -1)
            c = h;
          else if (d === ";" || h === v - 1) {
            if (c !== -1) {
              var p = f2(t.substring(u, c).trim());
              if (!l.includes(p)) {
                d !== ";" && h++;
                var g = t.substring(u, h).trim();
                r += " " + g + ";";
              }
            }
            u = h + 1, c = -1;
          }
        }
      }
    }
    return n && (r += mD(n)), i && (r += mD(i, !0)), r = r.trim(), r === "" ? null : r;
  }
  return t == null ? null : String(t);
}
function Yr(t, e, r, n, i, o) {
  var s = t.__className;
  if (Ct || s !== r || s === void 0) {
    var a = WQ(r, n, o);
    (!Ct || a !== t.getAttribute("class")) && (a == null ? t.removeAttribute("class") : e ? t.className = a : t.setAttribute("class", a)), t.__className = r;
  } else if (o && i !== o)
    for (var l in o) {
      var u = !!o[l];
      (i == null || u !== !!i[l]) && t.classList.toggle(l, u);
    }
  return o;
}
function d2(t, e = {}, r, n) {
  for (var i in r) {
    var o = r[i];
    e[i] !== o && (r[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, o, n));
  }
}
function ft(t, e, r, n) {
  var i = t.__style;
  if (Ct || i !== e) {
    var o = GQ(e, n);
    (!Ct || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (d2(t, r?.[0], n[0]), d2(t, r?.[1], n[1], "important")) : d2(t, r, n));
  return n;
}
function yd(t, e, r = !1) {
  if (t.multiple) {
    if (e == null)
      return;
    if (!R_(e))
      return iQ();
    for (var n of t.options)
      n.selected = e.includes(gD(n));
    return;
  }
  for (n of t.options) {
    var i = gD(n);
    if (sQ(i, e)) {
      n.selected = !0;
      return;
    }
  }
  (!r || e !== void 0) && (t.selectedIndex = -1);
}
function i1(t) {
  var e = new MutationObserver(() => {
    yd(t, t.__value);
  });
  e.observe(t, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), Db(() => {
    e.disconnect();
  });
}
function gD(t) {
  return "__value" in t ? t.__value : t.value;
}
const Up = Symbol("class"), Hp = Symbol("style"), ET = Symbol("is custom element"), DT = Symbol("is html");
function OT(t) {
  if (Ct) {
    var e = !1, r = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var n = t.value;
          te(t, "value", null), t.value = n;
        }
        if (t.hasAttribute("checked")) {
          var i = t.checked;
          te(t, "checked", null), t.checked = i;
        }
      }
    };
    t.__on_r = r, ru(r), tT();
  }
}
function KQ(t, e) {
  e ? t.hasAttribute("selected") || t.setAttribute("selected", "") : t.removeAttribute("selected");
}
function te(t, e, r, n) {
  var i = FT(t);
  Ct && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = r) && (e === "loading" && (t[DK] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && TT(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function QQ(t, e, r, n, i = !1, o = !1) {
  if (Ct && i && t.tagName === "INPUT") {
    var s = (
      /** @type {HTMLInputElement} */
      t
    ), a = s.type === "checkbox" ? "defaultChecked" : "defaultValue";
    a in r || OT(s);
  }
  var l = FT(t), u = l[ET], c = !l[DT];
  let h = Ct && u;
  h && Us(!1);
  var d = e || {}, p = t.tagName === "OPTION";
  for (var g in e)
    g in r || (r[g] = null);
  r.class ? r.class = Tb(r.class) : r[Up] && (r.class = null), r[Hp] && (r.style ??= null);
  var v = TT(t);
  for (const D in r) {
    let A = r[D];
    if (p && D === "value" && A == null) {
      t.value = t.__value = "", d[D] = A;
      continue;
    }
    if (D === "class") {
      var y = t.namespaceURI === "http://www.w3.org/1999/xhtml";
      Yr(t, y, A, n, e?.[Up], r[Up]), d[D] = A, d[Up] = r[Up];
      continue;
    }
    if (D === "style") {
      ft(t, A, e?.[Hp], r[Hp]), d[D] = A, d[Hp] = r[Hp];
      continue;
    }
    var b = d[D];
    if (!(A === b && !(A === void 0 && t.hasAttribute(D)))) {
      d[D] = A;
      var k = D[0] + D[1];
      if (k !== "$$")
        if (k === "on") {
          const O = {}, M = "$$" + D;
          let z = D.slice(2);
          var C = TQ(z);
          if (OQ(z) && (z = z.slice(0, -7), O.capture = !0), !C && b) {
            if (A != null) continue;
            t.removeEventListener(z, d[M], O), d[M] = null;
          }
          if (A != null)
            if (C)
              t[`__${z}`] = A, nn([z]);
            else {
              let R = function(N) {
                d[D].call(this, N);
              };
              d[M] = bT(z, t, R, O);
            }
          else C && (t[`__${z}`] = void 0);
        } else if (D === "style")
          te(t, D, A);
        else if (D === "autofocus")
          gQ(
            /** @type {HTMLElement} */
            t,
            !!A
          );
        else if (!u && (D === "__value" || D === "value" && A != null))
          t.value = t.__value = A;
        else if (D === "selected" && p)
          KQ(
            /** @type {HTMLOptionElement} */
            t,
            A
          );
        else {
          var S = D;
          c || (S = PQ(S));
          var _ = S === "defaultValue" || S === "defaultChecked";
          if (A == null && !u && !_)
            if (l[D] = null, S === "value" || S === "checked") {
              let O = (
                /** @type {HTMLInputElement} */
                t
              );
              const M = e === void 0;
              if (S === "value") {
                let z = O.defaultValue;
                O.removeAttribute(S), O.defaultValue = z, O.value = O.__value = M ? z : null;
              } else {
                let z = O.defaultChecked;
                O.removeAttribute(S), O.defaultChecked = z, O.checked = M ? z : !1;
              }
            } else
              t.removeAttribute(D);
          else _ || v.includes(S) && (u || typeof A != "string") ? (t[S] = A, S in l && (l[S] = Vn)) : typeof A != "function" && te(t, S, A);
        }
    }
  }
  return h && Us(!0), d;
}
function Qo(t, e, r = [], n = [], i = [], o, s = !1, a = !1) {
  QF(i, r, n, (l) => {
    var u = void 0, c = {}, h = t.nodeName === "SELECT", d = !1;
    if (dc(() => {
      var g = e(...l.map(x)), v = QQ(
        t,
        u,
        g,
        o,
        s,
        a
      );
      d && h && "value" in g && yd(
        /** @type {HTMLSelectElement} */
        t,
        g.value
      );
      for (let b of Object.getOwnPropertySymbols(c))
        g[b] || Ln(c[b]);
      for (let b of Object.getOwnPropertySymbols(g)) {
        var y = g[b];
        b.description === rQ && (!u || y !== u[b]) && (c[b] && Ln(c[b]), c[b] = Po(() => HQ(t, () => y))), v[b] = y;
      }
      u = v;
    }), h) {
      var p = (
        /** @type {HTMLSelectElement} */
        t
      );
      Kd(() => {
        yd(
          p,
          /** @type {Record<string | symbol, any>} */
          u.value,
          !0
        ), i1(p);
      });
    }
    d = !0;
  });
}
function FT(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [ET]: t.nodeName.includes("-"),
      [DT]: t.namespaceURI === tQ
    }
  );
}
var vD = /* @__PURE__ */ new Map();
function TT(t) {
  var e = t.getAttribute("is") || t.nodeName, r = vD.get(e);
  if (r) return r;
  vD.set(e, r = []);
  for (var n, i = t, o = Element.prototype; o !== i; ) {
    n = EF(i);
    for (var s in n)
      n[s].set && r.push(s);
    i = I_(i);
  }
  return r;
}
const XQ = () => performance.now(), Pl = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    ((t) => requestAnimationFrame(t))
  ),
  now: () => XQ(),
  tasks: /* @__PURE__ */ new Set()
};
function MT() {
  const t = Pl.now();
  Pl.tasks.forEach((e) => {
    e.c(t) || (Pl.tasks.delete(e), e.f());
  }), Pl.tasks.size !== 0 && Pl.tick(MT);
}
function JQ(t) {
  let e;
  return Pl.tasks.size === 0 && Pl.tick(MT), {
    promise: new Promise((r) => {
      Pl.tasks.add(e = { c: t, f: r });
    }),
    abort() {
      Pl.tasks.delete(e);
    }
  };
}
function xv(t, e) {
  Gd(() => {
    t.dispatchEvent(new CustomEvent(e));
  });
}
function YQ(t) {
  if (t === "float") return "cssFloat";
  if (t === "offset") return "cssOffset";
  if (t.startsWith("--")) return t;
  const e = t.split("-");
  return e.length === 1 ? e[0] : e[0] + e.slice(1).map(
    /** @param {any} word */
    (r) => r[0].toUpperCase() + r.slice(1)
  ).join("");
}
function yD(t) {
  const e = {}, r = t.split(";");
  for (const n of r) {
    const [i, o] = n.split(":");
    if (!i || o === void 0) break;
    const s = YQ(i.trim());
    e[s] = o.trim();
  }
  return e;
}
const ZQ = (t) => t;
function bD(t, e, r) {
  var n = (
    /** @type {EachItem} */
    Ay
  ), i, o, s, a = null;
  n.a ??= {
    element: t,
    measure() {
      i = this.element.getBoundingClientRect();
    },
    apply() {
      if (s?.abort(), o = this.element.getBoundingClientRect(), i.left !== o.left || i.right !== o.right || i.top !== o.top || i.bottom !== o.bottom) {
        const l = e()(this.element, { from: i, to: o }, r?.());
        s = o1(this.element, l, void 0, 1, () => {
          s?.abort(), s = void 0;
        });
      }
    },
    fix() {
      if (!t.getAnimations().length) {
        var { position: l, width: u, height: c } = getComputedStyle(t);
        if (l !== "absolute" && l !== "fixed") {
          var h = (
            /** @type {HTMLElement | SVGElement} */
            t.style
          );
          a = {
            position: h.position,
            width: h.width,
            height: h.height,
            transform: h.transform
          }, h.position = "absolute", h.width = u, h.height = c;
          var d = t.getBoundingClientRect();
          if (i.left !== d.left || i.top !== d.top) {
            var p = `translate(${i.left - d.left}px, ${i.top - d.top}px)`;
            h.transform = h.transform ? `${h.transform} ${p}` : p;
          }
        }
      }
    },
    unfix() {
      if (a) {
        var l = (
          /** @type {HTMLElement | SVGElement} */
          t.style
        );
        l.position = a.position, l.width = a.width, l.height = a.height, l.transform = a.transform;
      }
    }
  }, n.a.element = t;
}
function cm(t, e, r, n) {
  var i = (t & JK) !== 0, o = (t & YK) !== 0, s = i && o, a = (t & ZK) !== 0, l = s ? "both" : i ? "in" : "out", u, c = e.inert, h = e.style.overflow, d, p;
  function g() {
    return Gd(() => u ??= r()(e, n?.() ?? /** @type {P} */
    {}, {
      direction: l
    }));
  }
  var v = {
    is_global: a,
    in() {
      if (e.inert = c, !i) {
        p?.abort(), p?.reset?.();
        return;
      }
      o || d?.abort(), xv(e, "introstart"), d = o1(e, g(), p, 1, () => {
        xv(e, "introend"), d?.abort(), d = u = void 0, e.style.overflow = h;
      });
    },
    out(C) {
      if (!o) {
        C?.(), u = void 0;
        return;
      }
      e.inert = !0, xv(e, "outrostart"), p = o1(e, g(), d, 0, () => {
        xv(e, "outroend"), C?.();
      });
    },
    stop: () => {
      d?.abort(), p?.abort();
    }
  }, y = (
    /** @type {Effect} */
    Wt
  );
  if ((y.transitions ??= []).push(v), i && d3) {
    var b = a;
    if (!b) {
      for (var k = (
        /** @type {Effect | null} */
        y.parent
      ); k && (k.f & Ql) !== 0; )
        for (; (k = k.parent) && (k.f & ol) === 0; )
          ;
      b = !k || (k.f & Vg) !== 0;
    }
    b && Kd(() => {
      Go(() => v.in());
    });
  }
}
function o1(t, e, r, n, i) {
  var o = n === 1;
  if (_f(e)) {
    var s, a = !1;
    return ru(() => {
      if (!a) {
        var y = e({ direction: o ? "in" : "out" });
        s = o1(t, y, r, n, i);
      }
    }), {
      abort: () => {
        a = !0, s?.abort();
      },
      deactivate: () => s.deactivate(),
      reset: () => s.reset(),
      t: () => s.t()
    };
  }
  if (r?.deactivate(), !e?.duration)
    return i(), {
      abort: zt,
      deactivate: zt,
      reset: zt,
      t: () => n
    };
  const { delay: l = 0, css: u, tick: c, easing: h = ZQ } = e;
  var d = [];
  if (o && r === void 0 && (c && c(0, 1), u)) {
    var p = yD(u(0, 1));
    d.push(p, p);
  }
  var g = () => 1 - n, v = t.animate(d, { duration: l, fill: "forwards" });
  return v.onfinish = () => {
    v.cancel();
    var y = r?.t() ?? 1 - n;
    r?.abort();
    var b = n - y, k = (
      /** @type {number} */
      e.duration * Math.abs(b)
    ), C = [];
    if (k > 0) {
      var S = !1;
      if (u)
        for (var _ = Math.ceil(k / 16.666666666666668), D = 0; D <= _; D += 1) {
          var A = y + b * h(D / _), O = yD(u(A, 1 - A));
          C.push(O), S ||= O.overflow === "hidden";
        }
      S && (t.style.overflow = "hidden"), g = () => {
        var M = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          v.currentTime
        );
        return y + b * h(M / k);
      }, c && JQ(() => {
        if (v.playState !== "running") return !1;
        var M = g();
        return c(M, 1 - M), !0;
      });
    }
    v = t.animate(C, { duration: k, fill: "forwards" }), v.onfinish = () => {
      g = () => n, c?.(n, 1 - n), i();
    };
  }, {
    abort: () => {
      v && (v.cancel(), v.effect = null, v.onfinish = zt);
    },
    deactivate: () => {
      i = zt;
    },
    reset: () => {
      n === 0 && c?.(1, 0);
    },
    t: () => g()
  };
}
function eX(t, e, r = e) {
  var n = /* @__PURE__ */ new WeakSet();
  vQ(t, "input", async (i) => {
    var o = i ? t.defaultValue : t.value;
    if (o = p2(t) ? m2(o) : o, r(o), jr !== null && n.add(jr), await xQ(), o !== (o = e())) {
      var s = t.selectionStart, a = t.selectionEnd, l = t.value.length;
      if (t.value = o ?? "", a !== null) {
        var u = t.value.length;
        s === a && a === l && u > l ? (t.selectionStart = u, t.selectionEnd = u) : (t.selectionStart = s, t.selectionEnd = Math.min(a, u));
      }
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (Ct && t.defaultValue !== t.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  Go(e) == null && t.value) && (r(p2(t) ? m2(t.value) : t.value), jr !== null && n.add(jr)), Ob(() => {
    var i = e();
    if (t === document.activeElement) {
      var o = (
        /** @type {Batch} */
        Sy ?? jr
      );
      if (n.has(o))
        return;
    }
    p2(t) && i === m2(t.value) || t.type === "date" && !i && !t.value || i !== t.value && (t.value = i ?? "");
  });
}
function p2(t) {
  var e = t.type;
  return e === "number" || e === "range";
}
function m2(t) {
  return t === "" ? null : +t;
}
class K_ {
  /** */
  #e = /* @__PURE__ */ new WeakMap();
  /** @type {ResizeObserver | undefined} */
  #t;
  /** @type {ResizeObserverOptions} */
  #r;
  /** @static */
  static entries = /* @__PURE__ */ new WeakMap();
  /** @param {ResizeObserverOptions} options */
  constructor(e) {
    this.#r = e;
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(e, r) {
    var n = this.#e.get(e) || /* @__PURE__ */ new Set();
    return n.add(r), this.#e.set(e, n), this.#n().observe(e, this.#r), () => {
      var i = this.#e.get(e);
      i.delete(r), i.size === 0 && (this.#e.delete(e), this.#t.unobserve(e));
    };
  }
  #n() {
    return this.#t ?? (this.#t = new ResizeObserver(
      /** @param {any} entries */
      (e) => {
        for (var r of e) {
          K_.entries.set(r.target, r);
          for (var n of this.#e.get(r.target) || [])
            n(r);
        }
      }
    ));
  }
}
var tX = /* @__PURE__ */ new K_({
  box: "border-box"
});
function Ks(t, e, r) {
  var n = tX.observe(t, () => r(t[e]));
  Kd(() => (Go(() => r(t[e])), n));
}
function xD(t, e) {
  return t === e || t?.[ja] === e;
}
function Qs(t = {}, e, r, n) {
  return Kd(() => {
    var i, o;
    return Ob(() => {
      i = o, o = [], Go(() => {
        t !== r(...o) && (e(t, ...o), i && xD(r(...i), t) && e(null, ...i));
      });
    }), () => {
      ru(() => {
        o && xD(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
function Q_(t, e, r) {
  if (t == null)
    return e(void 0), r && r(void 0), zt;
  const n = Go(
    () => t.subscribe(
      e,
      // @ts-expect-error
      r
    )
  );
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
const gf = [];
function rX(t, e) {
  return {
    subscribe: qf(t, e).subscribe
  };
}
function qf(t, e = zt) {
  let r = null;
  const n = /* @__PURE__ */ new Set();
  function i(a) {
    if (B_(t, a) && (t = a, r)) {
      const l = !gf.length;
      for (const u of n)
        u[1](), gf.push(u, t);
      if (l) {
        for (let u = 0; u < gf.length; u += 2)
          gf[u][0](gf[u + 1]);
        gf.length = 0;
      }
    }
  }
  function o(a) {
    i(a(
      /** @type {T} */
      t
    ));
  }
  function s(a, l = zt) {
    const u = [a, l];
    return n.add(u), n.size === 1 && (r = e(i, o) || zt), a(
      /** @type {T} */
      t
    ), () => {
      n.delete(u), n.size === 0 && r && (r(), r = null);
    };
  }
  return { set: i, update: o, subscribe: s };
}
function nX(t, e, r) {
  const n = !Array.isArray(t), i = n ? [t] : t;
  if (!i.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const o = e.length < 2;
  return rX(r, (s, a) => {
    let l = !1;
    const u = [];
    let c = 0, h = zt;
    const d = () => {
      if (c)
        return;
      h();
      const g = e(n ? u[0] : u, s, a);
      o ? s(g) : h = typeof g == "function" ? g : zt;
    }, p = i.map(
      (g, v) => Q_(
        g,
        (y) => {
          u[v] = y, c &= ~(1 << v), l && d();
        },
        () => {
          c |= 1 << v;
        }
      )
    );
    return l = !0, d(), function() {
      DF(p), h(), l = !1;
    };
  });
}
function iX(t) {
  let e;
  return Q_(t, (r) => e = r)(), e;
}
let wv = !1, m3 = Symbol();
function mi(t, e, r) {
  const n = r[e] ??= {
    store: null,
    source: /* @__PURE__ */ H_(void 0),
    unsubscribe: zt
  };
  if (n.store !== t && !(m3 in r))
    if (n.unsubscribe(), n.store = t ?? null, t == null)
      n.source.v = void 0, n.unsubscribe = zt;
    else {
      var i = !0;
      n.unsubscribe = Q_(t, (o) => {
        i ? n.source.v = o : ue(n.source, o);
      }), i = !1;
    }
  return t && m3 in r ? iX(t) : x(n.source);
}
function wD(t, e) {
  return t.set(e), e;
}
function Xo() {
  const t = {};
  function e() {
    Db(() => {
      for (var r in t)
        t[r].unsubscribe();
      $_(t, m3, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [t, e];
}
function oX(t) {
  var e = wv;
  try {
    return wv = !1, [t(), wv];
  } finally {
    wv = e;
  }
}
const sX = {
  get(t, e) {
    if (!t.exclude.includes(e))
      return t.props[e];
  },
  set(t, e) {
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    if (!t.exclude.includes(e) && e in t.props)
      return {
        enumerable: !0,
        configurable: !0,
        value: t.props[e]
      };
  },
  has(t, e) {
    return t.exclude.includes(e) ? !1 : e in t.props;
  },
  ownKeys(t) {
    return Reflect.ownKeys(t.props).filter((e) => !t.exclude.includes(e));
  }
};
// @__NO_SIDE_EFFECTS__
function zn(t, e, r) {
  return new Proxy(
    { props: t, exclude: e },
    sX
  );
}
const aX = {
  get(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (_f(n) && (n = n()), typeof n == "object" && n !== null && e in n) return n[e];
    }
  },
  set(t, e, r) {
    let n = t.props.length;
    for (; n--; ) {
      let i = t.props[n];
      _f(i) && (i = i());
      const o = qu(i, e);
      if (o && o.set)
        return o.set(r), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (_f(n) && (n = n()), typeof n == "object" && n !== null && e in n) {
        const i = qu(n, e);
        return i && !i.configurable && (i.configurable = !0), i;
      }
    }
  },
  has(t, e) {
    if (e === ja || e === P_) return !1;
    for (let r of t.props)
      if (_f(r) && (r = r()), r != null && e in r) return !0;
    return !1;
  },
  ownKeys(t) {
    const e = [];
    for (let r of t.props)
      if (_f(r) && (r = r()), !!r) {
        for (const n in r)
          e.includes(n) || e.push(n);
        for (const n of Object.getOwnPropertySymbols(r))
          e.includes(n) || e.push(n);
      }
    return e;
  }
};
function lX(...t) {
  return new Proxy({ props: t }, aX);
}
function ct(t, e, r, n) {
  var i = (r & QK) !== 0, o = (r & XK) !== 0, s = (
    /** @type {V} */
    n
  ), a = !0, l = () => (a && (a = !1, s = o ? Go(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), s), u;
  if (i) {
    var c = ja in t || P_ in t;
    u = qu(t, e)?.set ?? (c && e in t ? (k) => t[e] = k : void 0);
  }
  var h, d = !1;
  i ? [h, d] = oX(() => (
    /** @type {V} */
    t[e]
  )) : h = /** @type {V} */
  t[e], h === void 0 && n !== void 0 && (h = l(), u && (LK(), u(h)));
  var p;
  if (p = () => {
    var k = (
      /** @type {V} */
      t[e]
    );
    return k === void 0 ? l() : (a = !0, k);
  }, (r & KK) === 0)
    return p;
  if (u) {
    var g = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(k, C) {
        return arguments.length > 0 ? ((!C || g || d) && u(C ? p() : k), k) : p();
      })
    );
  }
  var v = !1, y = ((r & GK) !== 0 ? Ab : XF)(() => (v = !1, p()));
  i && x(y);
  var b = (
    /** @type {Effect} */
    Wt
  );
  return (
    /** @type {() => V} */
    (function(k, C) {
      if (arguments.length > 0) {
        const S = C ? x(y) : i ? fs(k) : k;
        return ue(y, S), v = !0, s !== void 0 && (s = S), k;
      }
      return Ih && v || (b.f & zu) !== 0 ? y.v : x(y);
    })
  );
}
var uX = /* @__PURE__ */ me('<div class="bg-white dark:bg-black rounded-md flex flex-col overflow-hidden"><div class="p-2 bg-slate-100"> </div> <!></div>'), cX = /* @__PURE__ */ me('<div class="w-full h-full flex flex-row flex-wrap gap-2 overflow-y-scroll"></div>');
function hX(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(100), n = /* @__PURE__ */ De(100), i = /* @__PURE__ */ K(() => Object.keys(e.charts)), o = /* @__PURE__ */ K(() => x(r) / 3 - 10), s = 300;
  var a = cX();
  Nt(a, 20, () => x(i), (l) => l, (l, u) => {
    var c = uX();
    let h;
    var d = Y(c), p = Y(d, !0);
    J(d);
    var g = ae(d, 2);
    Xl(g, () => e.chartView, () => ({ id: u, width: x(o), height: s })), J(c), Ae(() => {
      h = ft(c, "", h, { width: `${x(o) ?? ""}px` }), ut(p, e.charts[u].title);
    }), X(l, c);
  }), J(a), Ks(a, "clientWidth", (l) => ue(r, l)), Ks(a, "clientHeight", (l) => ue(n, l)), X(t, a), it();
}
function PT(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function kD(t, { from: e, to: r }, n = {}) {
  var { delay: i = 0, duration: o = (D) => Math.sqrt(D) * 120, easing: s = PT } = n, a = getComputedStyle(t), l = a.transform === "none" ? "" : a.transform, [u, c] = a.transformOrigin.split(" ").map(parseFloat);
  u /= t.clientWidth, c /= t.clientHeight;
  var h = fX(t), d = t.clientWidth / r.width / h, p = t.clientHeight / r.height / h, g = e.left + e.width * u, v = e.top + e.height * c, y = r.left + r.width * u, b = r.top + r.height * c, k = (g - y) * d, C = (v - b) * p, S = e.width / r.width, _ = e.height / r.height;
  return {
    delay: i,
    duration: typeof o == "function" ? o(Math.sqrt(k * k + C * C)) : o,
    easing: s,
    css: (D, A) => {
      var O = A * k, M = A * C, z = D + A * S, R = D + A * _;
      return `transform: ${l} translate(${O}px, ${M}px) scale(${z}, ${R});`;
    }
  };
}
function fX(t) {
  if ("currentCSSZoom" in t)
    return (
      /** @type {number} */
      t.currentCSSZoom
    );
  for (var e = t, r = 1; e !== null; )
    r *= +getComputedStyle(e).zoom, e = /** @type {Element | null} */
    e.parentElement;
  return r;
}
function dX(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function hm(t, { delay: e = 0, duration: r = 400, easing: n = dX, axis: i = "y" } = {}) {
  const o = getComputedStyle(t), s = +o.opacity, a = i === "y" ? "height" : "width", l = parseFloat(o[a]), u = i === "y" ? ["top", "bottom"] : ["left", "right"], c = u.map(
    (b) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${b[0].toUpperCase()}${b.slice(1)}`
    )
  ), h = parseFloat(o[`padding${c[0]}`]), d = parseFloat(o[`padding${c[1]}`]), p = parseFloat(o[`margin${c[0]}`]), g = parseFloat(o[`margin${c[1]}`]), v = parseFloat(
    o[`border${c[0]}Width`]
  ), y = parseFloat(
    o[`border${c[1]}Width`]
  );
  return {
    delay: e,
    duration: r,
    easing: n,
    css: (b) => `overflow: hidden;opacity: ${Math.min(b * 20, 1) * s};${a}: ${b * l}px;padding-${u[0]}: ${b * h}px;padding-${u[1]}: ${b * d}px;margin-${u[0]}: ${b * p}px;margin-${u[1]}: ${b * g}px;border-${u[0]}-width: ${b * v}px;border-${u[1]}-width: ${b * y}px;min-${a}: 0`
  };
}
var pX = /* @__PURE__ */ me("<div></div>");
function CD(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  function n(o, s) {
    o.preventDefault();
    let a = o.pageX, l = o.pageY, u = (h) => {
      h.preventDefault();
      let d = h.pageX - a, p = h.pageY - l;
      s(d, p);
    }, c = () => {
      window.removeEventListener("mousemove", u), window.removeEventListener("mouseup", c);
    };
    window.addEventListener("mousemove", u), window.addEventListener("mouseup", c);
  }
  var i = pX();
  i.__mousedown = (o) => {
    let s = e.value;
    n(o, (a, l) => {
      let u = s + (e.axis == "x" ? a : l) * e.scaler;
      u < e.min && (u = r.min), u > e.max && (u = r.max), e.onChange(u);
    });
  }, Ae(() => Yr(i, 1, `${e.class ?? ""} ${e.axis == "x" ? "cursor-col-resize" : "cursor-row-resize"}`)), X(t, i), it();
}
nn(["mousedown"]);
function _D(t, e = "") {
  let r = 1, n;
  do
    n = e + r, r++;
  while (n in t);
  return n;
}
let g3 = [], RT = [];
(() => {
  let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, r = 0; e < t.length; e++)
    (e % 2 ? RT : g3).push(r = r + t[e]);
})();
function mX(t) {
  if (t < 768) return !1;
  for (let e = 0, r = g3.length; ; ) {
    let n = e + r >> 1;
    if (t < g3[n]) r = n;
    else if (t >= RT[n]) e = n + 1;
    else return !0;
    if (e == r) return !1;
  }
}
function SD(t) {
  return t >= 127462 && t <= 127487;
}
const AD = 8205;
function gX(t, e, r = !0, n = !0) {
  return (r ? NT : vX)(t, e, n);
}
function NT(t, e, r) {
  if (e == t.length) return e;
  e && $T(t.charCodeAt(e)) && IT(t.charCodeAt(e - 1)) && e--;
  let n = g2(t, e);
  for (e += ED(n); e < t.length; ) {
    let i = g2(t, e);
    if (n == AD || i == AD || r && mX(i))
      e += ED(i), n = i;
    else if (SD(i)) {
      let o = 0, s = e - 2;
      for (; s >= 0 && SD(g2(t, s)); )
        o++, s -= 2;
      if (o % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function vX(t, e, r) {
  for (; e > 0; ) {
    let n = NT(t, e - 2, r);
    if (n < e) return n;
    e--;
  }
  return 0;
}
function g2(t, e) {
  let r = t.charCodeAt(e);
  if (!IT(r) || e + 1 == t.length) return r;
  let n = t.charCodeAt(e + 1);
  return $T(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function $T(t) {
  return t >= 56320 && t < 57344;
}
function IT(t) {
  return t >= 55296 && t < 56320;
}
function ED(t) {
  return t < 65536 ? 1 : 2;
}
let ir = class BT {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, n) {
    [e, r] = bd(this, e, r);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      i,
      1
      /* Open.From */
    ), Sa.from(i, this.length - (r - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = bd(this, e, r);
    let n = [];
    return this.decompose(e, r, n, 0), Sa.from(n, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), i = new Sm(this), o = new Sm(e);
    for (let s = r, a = r; ; ) {
      if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
        return !1;
      if (a += i.value.length, i.done || a >= n)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Sm(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new LT(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      n = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new zT(n);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? BT.empty : e.length <= 32 ? new fn(e) : Sa.from(fn.split(e, []));
  }
};
class fn extends ir {
  constructor(e, r = yX(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, n, i) {
    for (let o = 0; ; o++) {
      let s = this.text[o], a = i + s.length;
      if ((r ? n : a) >= e)
        return new bX(i, a, n, s);
      i = a + 1, n++;
    }
  }
  decompose(e, r, n, i) {
    let o = e <= 0 && r >= this.length ? this : new fn(DD(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let s = n.pop(), a = Ey(o.text, s.text.slice(), 0, o.length);
      if (a.length <= 32)
        n.push(new fn(a, s.length + o.length));
      else {
        let l = a.length >> 1;
        n.push(new fn(a.slice(0, l)), new fn(a.slice(l)));
      }
    } else
      n.push(o);
  }
  replace(e, r, n) {
    if (!(n instanceof fn))
      return super.replace(e, r, n);
    [e, r] = bd(this, e, r);
    let i = Ey(this.text, Ey(n.text, DD(this.text, 0, e)), r), o = this.length + n.length - (r - e);
    return i.length <= 32 ? new fn(i, o) : Sa.from(fn.split(i, []), o);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = bd(this, e, r);
    let i = "";
    for (let o = 0, s = 0; o <= r && s < this.text.length; s++) {
      let a = this.text[s], l = o + a.length;
      o > e && s && (i += n), e < l && r > o && (i += a.slice(Math.max(0, e - o), r - o)), o = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let n = [], i = -1;
    for (let o of e)
      n.push(o), i += o.length + 1, n.length == 32 && (r.push(new fn(n, i)), n = [], i = -1);
    return i > -1 && r.push(new fn(n, i)), r;
  }
}
class Sa extends ir {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, r, n, i) {
    for (let o = 0; ; o++) {
      let s = this.children[o], a = i + s.length, l = n + s.lines - 1;
      if ((r ? l : a) >= e)
        return s.lineInner(e, r, n, i);
      i = a + 1, n = l + 1;
    }
  }
  decompose(e, r, n, i) {
    for (let o = 0, s = 0; s <= r && o < this.children.length; o++) {
      let a = this.children[o], l = s + a.length;
      if (e <= l && r >= s) {
        let u = i & ((s <= e ? 1 : 0) | (l >= r ? 2 : 0));
        s >= e && l <= r && !u ? n.push(a) : a.decompose(e - s, r - s, n, u);
      }
      s = l + 1;
    }
  }
  replace(e, r, n) {
    if ([e, r] = bd(this, e, r), n.lines < this.lines)
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let s = this.children[i], a = o + s.length;
        if (e >= o && r <= a) {
          let l = s.replace(e - o, r - o, n), u = this.lines - s.lines + l.lines;
          if (l.lines < u >> 4 && l.lines > u >> 6) {
            let c = this.children.slice();
            return c[i] = l, new Sa(c, this.length - (r - e) + n.length);
          }
          return super.replace(o, a, l);
        }
        o = a + 1;
      }
    return super.replace(e, r, n);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = bd(this, e, r);
    let i = "";
    for (let o = 0, s = 0; o < this.children.length && s <= r; o++) {
      let a = this.children[o], l = s + a.length;
      s > e && o && (i += n), e < l && r > s && (i += a.sliceString(e - s, r - s, n)), s = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof Sa))
      return 0;
    let n = 0, [i, o, s, a] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, o += r) {
      if (i == s || o == a)
        return n;
      let l = this.children[i], u = e.children[o];
      if (l != u)
        return n + l.scanIdentical(u, r);
      n += l.length + 1;
    }
  }
  static from(e, r = e.reduce((n, i) => n + i.length + 1, -1)) {
    let n = 0;
    for (let p of e)
      n += p.lines;
    if (n < 32) {
      let p = [];
      for (let g of e)
        g.flatten(p);
      return new fn(p, r);
    }
    let i = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), o = i << 1, s = i >> 1, a = [], l = 0, u = -1, c = [];
    function h(p) {
      let g;
      if (p.lines > o && p instanceof Sa)
        for (let v of p.children)
          h(v);
      else p.lines > s && (l > s || !l) ? (d(), a.push(p)) : p instanceof fn && l && (g = c[c.length - 1]) instanceof fn && p.lines + g.lines <= 32 ? (l += p.lines, u += p.length + 1, c[c.length - 1] = new fn(g.text.concat(p.text), g.length + 1 + p.length)) : (l + p.lines > i && d(), l += p.lines, u += p.length + 1, c.push(p));
    }
    function d() {
      l != 0 && (a.push(c.length == 1 ? c[0] : Sa.from(c, u)), u = -1, l = c.length = 0);
    }
    for (let p of e)
      h(p);
    return d(), a.length == 1 ? a[0] : new Sa(a, r);
  }
}
ir.empty = /* @__PURE__ */ new fn([""], 0);
function yX(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function Ey(t, e, r = 0, n = 1e9) {
  for (let i = 0, o = 0, s = !0; o < t.length && i <= n; o++) {
    let a = t[o], l = i + a.length;
    l >= r && (l > n && (a = a.slice(0, n - i)), i < r && (a = a.slice(r - i)), s ? (e[e.length - 1] += a, s = !1) : e.push(a)), i = l + 1;
  }
  return e;
}
function DD(t, e, r) {
  return Ey(t, [""], e, r);
}
class Sm {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof fn ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1, i = this.nodes[n], o = this.offsets[n], s = o >> 1, a = i instanceof fn ? i.text.length : i.children.length;
      if (s == (r > 0 ? a : 0)) {
        if (n == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[n] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof fn) {
        let l = i.text[s + (r < 0 ? -1 : 0)];
        if (this.offsets[n] += r, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : r > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = i.children[s + (r < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[n] += r) : (r < 0 && this.offsets[n]--, this.nodes.push(l), this.offsets.push(r > 0 ? 1 : (l instanceof fn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class LT {
  constructor(e, r, n) {
    this.value = "", this.done = !1, this.cursor = new Sm(e, r > n ? -1 : 1), this.pos = r > n ? e.length : 0, this.from = Math.min(r, n), this.to = Math.max(r, n);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let n = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * r, this.value = i.length <= n ? i : r < 0 ? i.slice(i.length - n) : i.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class zT {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: n, value: i } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (ir.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Sm.prototype[Symbol.iterator] = LT.prototype[Symbol.iterator] = zT.prototype[Symbol.iterator] = function() {
  return this;
});
class bX {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.number = n, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function bd(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
function Qn(t, e, r = !0, n = !0) {
  return gX(t, e, r, n);
}
function xX(t) {
  return t >= 56320 && t < 57344;
}
function wX(t) {
  return t >= 55296 && t < 56320;
}
function Ji(t, e) {
  let r = t.charCodeAt(e);
  if (!wX(r) || e + 1 == t.length)
    return r;
  let n = t.charCodeAt(e + 1);
  return xX(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function X_(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Aa(t) {
  return t < 65536 ? 1 : 2;
}
const v3 = /\r\n?|\n/;
var Kn = /* @__PURE__ */ (function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
})(Kn || (Kn = {}));
class qa {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r + 1];
      e += n < 0 ? this.sections[r] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, n = 0, i = 0; r < this.sections.length; ) {
      let o = this.sections[r++], s = this.sections[r++];
      s < 0 ? (e(n, i, o), i += o) : i += s, n += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    y3(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      i < 0 ? e.push(n, i) : e.push(i, n);
    }
    return new qa(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : jT(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : b3(this, e, r);
  }
  mapPos(e, r = -1, n = Kn.Simple) {
    let i = 0, o = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], l = this.sections[s++], u = i + a;
      if (l < 0) {
        if (u > e)
          return o + (e - i);
        o += a;
      } else {
        if (n != Kn.Simple && u >= e && (n == Kn.TrackDel && i < e && u > e || n == Kn.TrackBefore && i < e || n == Kn.TrackAfter && u > e))
          return null;
        if (u > e || u == e && r < 0 && !a)
          return e == i || r < 0 ? o : o + l;
        o += l;
      }
      i = u;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let n = 0, i = 0; n < this.sections.length && i <= r; ) {
      let o = this.sections[n++], s = this.sections[n++], a = i + o;
      if (s >= 0 && i <= r && a >= e)
        return i < e && a > r ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      e += (e ? " " : "") + n + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new qa(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new qa(e);
  }
}
class En extends qa {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return y3(this, (r, n, i, o, s) => e = e.replace(i, i + (n - r), s), !1), e;
  }
  mapDesc(e, r = !1) {
    return b3(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), n = [];
    for (let i = 0, o = 0; i < r.length; i += 2) {
      let s = r[i], a = r[i + 1];
      if (a >= 0) {
        r[i] = a, r[i + 1] = s;
        let l = i >> 1;
        for (; n.length < l; )
          n.push(ir.empty);
        n.push(s ? e.slice(o, o + s) : ir.empty);
      }
      o += s;
    }
    return new En(r, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the
  returned value will represent the change `docA` â†’ `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : jT(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : b3(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    y3(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return qa.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], n = [], i = [], o = new Gm(this);
    e: for (let s = 0, a = 0; ; ) {
      let l = s == e.length ? 1e9 : e[s++];
      for (; a < l || a == l && o.len == 0; ) {
        if (o.done)
          break e;
        let c = Math.min(o.len, l - a);
        ti(i, c, -1);
        let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
        ti(r, c, h), h > 0 && Mu(n, r, o.text), o.forward(c), a += c;
      }
      let u = e[s++];
      for (; a < u; ) {
        if (o.done)
          break e;
        let c = Math.min(o.len, u - a);
        ti(r, c, -1), ti(i, c, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(c), a += c;
      }
    }
    return {
      changes: new En(r, n),
      filtered: qa.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r], i = this.sections[r + 1];
      i < 0 ? e.push(n) : i == 0 ? e.push([n]) : e.push([n].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, n) {
    let i = [], o = [], s = 0, a = null;
    function l(c = !1) {
      if (!c && !i.length)
        return;
      s < r && ti(i, r - s, -1);
      let h = new En(i, o);
      a = a ? a.compose(h.map(a)) : h, i = [], o = [], s = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let h of c)
          u(h);
      else if (c instanceof En) {
        if (c.length != r)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${r})`);
        l(), a = a ? a.compose(c.map(a)) : c;
      } else {
        let { from: h, to: d = h, insert: p } = c;
        if (h > d || h < 0 || d > r)
          throw new RangeError(`Invalid change range ${h} to ${d} (in doc of length ${r})`);
        let g = p ? typeof p == "string" ? ir.of(p.split(n || v3)) : p : ir.empty, v = g.length;
        if (h == d && v == 0)
          return;
        h < s && l(), h > s && ti(i, h - s, -1), ti(i, d - h, v), Mu(o, i, g), s = d;
      }
    }
    return u(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new En(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], n = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (typeof o == "number")
        r.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          r.push(o[0], 0);
        else {
          for (; n.length < i; )
            n.push(ir.empty);
          n[i] = ir.of(o.slice(1)), r.push(o[0], n[i].length);
        }
      }
    }
    return new En(r, n);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new En(e, r);
  }
}
function ti(t, e, r, n = !1) {
  if (e == 0 && r <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += r : n ? (t[i] += e, t[i + 1] += r) : t.push(e, r);
}
function Mu(t, e, r) {
  if (r.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < n; )
      t.push(ir.empty);
    t.push(r);
  }
}
function y3(t, e, r) {
  let n = t.inserted;
  for (let i = 0, o = 0, s = 0; s < t.sections.length; ) {
    let a = t.sections[s++], l = t.sections[s++];
    if (l < 0)
      i += a, o += a;
    else {
      let u = i, c = o, h = ir.empty;
      for (; u += a, c += l, l && n && (h = h.append(n[s - 2 >> 1])), !(r || s == t.sections.length || t.sections[s + 1] < 0); )
        a = t.sections[s++], l = t.sections[s++];
      e(i, u, o, c, h), i = u, o = c;
    }
  }
}
function b3(t, e, r, n = !1) {
  let i = [], o = n ? [] : null, s = new Gm(t), a = new Gm(e);
  for (let l = -1; ; ) {
    if (s.done && a.len || a.done && s.len)
      throw new Error("Mismatched change set lengths");
    if (s.ins == -1 && a.ins == -1) {
      let u = Math.min(s.len, a.len);
      ti(i, u, -1), s.forward(u), a.forward(u);
    } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !r))) {
      let u = a.len;
      for (ti(i, a.ins, -1); u; ) {
        let c = Math.min(s.len, u);
        s.ins >= 0 && l < s.i && s.len <= c && (ti(i, 0, s.ins), o && Mu(o, i, s.text), l = s.i), s.forward(c), u -= c;
      }
      a.next();
    } else if (s.ins >= 0) {
      let u = 0, c = s.len;
      for (; c; )
        if (a.ins == -1) {
          let h = Math.min(c, a.len);
          u += h, c -= h, a.forward(h);
        } else if (a.ins == 0 && a.len < c)
          c -= a.len, a.next();
        else
          break;
      ti(i, u, l < s.i ? s.ins : 0), o && l < s.i && Mu(o, i, s.text), l = s.i, s.forward(s.len - c);
    } else {
      if (s.done && a.done)
        return o ? En.createSet(i, o) : qa.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function jT(t, e, r = !1) {
  let n = [], i = r ? [] : null, o = new Gm(t), s = new Gm(e);
  for (let a = !1; ; ) {
    if (o.done && s.done)
      return i ? En.createSet(n, i) : qa.create(n);
    if (o.ins == 0)
      ti(n, o.len, 0, a), o.next();
    else if (s.len == 0 && !s.done)
      ti(n, 0, s.ins, a), i && Mu(i, n, s.text), s.next();
    else {
      if (o.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(o.len2, s.len), u = n.length;
        if (o.ins == -1) {
          let c = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          ti(n, l, c, a), i && c && Mu(i, n, s.text);
        } else s.ins == -1 ? (ti(n, o.off ? 0 : o.len, l, a), i && Mu(i, n, o.textBit(l))) : (ti(n, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && Mu(i, n, s.text));
        a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || n.length > u), o.forward2(l), s.forward(l);
      }
    }
  }
}
class Gm {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? ir.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, n = this.i - 2 >> 1;
    return n >= r.length && !e ? ir.empty : r[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class qc {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.flags = n;
  }
  /**
  The anchor of the rangeâ€”the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let n, i;
    return this.empty ? n = i = e.mapPos(this.from, r) : (n = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), n == this.from && i == this.to ? this : new qc(n, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return de.range(e, r);
    let n = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return de.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return de.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new qc(e, r, n);
  }
}
class de {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : de.create(this.ranges.map((n) => n.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new de([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return de.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let n = this.ranges.slice();
    return n[r] = e, de.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new de(e.ranges.map((r) => qc.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new de([de.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, i = 0; i < e.length; i++) {
      let o = e[i];
      if (o.empty ? o.from <= n : o.from < n)
        return de.normalized(e.slice(), r);
      n = o.to;
    }
    return new de(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, n, i) {
    return qc.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, n, i) {
    let o = (n ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return r < e ? qc.create(r, e, 48 | o) : qc.create(e, r, (r > e ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let n = e[r];
    e.sort((i, o) => i.from - o.from), r = e.indexOf(n);
    for (let i = 1; i < e.length; i++) {
      let o = e[i], s = e[i - 1];
      if (o.empty ? o.from <= s.to : o.from < s.to) {
        let a = s.from, l = Math.max(o.to, s.to);
        i <= r && r--, e.splice(--i, 2, o.anchor > o.head ? de.range(l, a) : de.range(a, l));
      }
    }
    return new de(e, r);
  }
}
function qT(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let J_ = 0;
class Le {
  constructor(e, r, n, i, o) {
    this.combine = e, this.compareInput = r, this.compare = n, this.isStatic = i, this.id = J_++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Le(e.combine || ((r) => r), e.compareInput || ((r, n) => r === n), e.compare || (e.combine ? (r, n) => r === n : Y_), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Dy([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Dy(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Dy(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (n) => n), this.compute([e], (n) => r(n.field(e)));
  }
}
function Y_(t, e) {
  return t == e || t.length == e.length && t.every((r, n) => r === e[n]);
}
class Dy {
  constructor(e, r, n, i) {
    this.dependencies = e, this.facet = r, this.type = n, this.value = i, this.id = J_++;
  }
  dynamicSlot(e) {
    var r;
    let n = this.value, i = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, l = !1, u = !1, c = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? u = !0 : (((r = e[h.id]) !== null && r !== void 0 ? r : 1) & 1) == 0 && c.push(e[h.id]);
    return {
      create(h) {
        return h.values[s] = n(h), 1;
      },
      update(h, d) {
        if (l && d.docChanged || u && (d.docChanged || d.selection) || x3(h, c)) {
          let p = n(h);
          if (a ? !OD(p, h.values[s], i) : !i(p, h.values[s]))
            return h.values[s] = p, 1;
        }
        return 0;
      },
      reconfigure: (h, d) => {
        let p, g = d.config.address[o];
        if (g != null) {
          let v = a1(d, g);
          if (this.dependencies.every((y) => y instanceof Le ? d.facet(y) === h.facet(y) : y instanceof jn ? d.field(y, !1) == h.field(y, !1) : !0) || (a ? OD(p = n(h), v, i) : i(p = n(h), v)))
            return h.values[s] = v, 0;
        } else
          p = n(h);
        return h.values[s] = p, 1;
      }
    };
  }
}
function OD(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!r(t[n], e[n]))
      return !1;
  return !0;
}
function x3(t, e) {
  let r = !1;
  for (let n of e)
    Am(t, n) & 1 && (r = !0);
  return r;
}
function kX(t, e, r) {
  let n = r.map((l) => t[l.id]), i = r.map((l) => l.type), o = n.filter((l) => !(l & 1)), s = t[e.id] >> 1;
  function a(l) {
    let u = [];
    for (let c = 0; c < n.length; c++) {
      let h = a1(l, n[c]);
      if (i[c] == 2)
        for (let d of h)
          u.push(d);
      else
        u.push(h);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of n)
        Am(l, u);
      return l.values[s] = a(l), 1;
    },
    update(l, u) {
      if (!x3(l, o))
        return 0;
      let c = a(l);
      return e.compare(c, l.values[s]) ? 0 : (l.values[s] = c, 1);
    },
    reconfigure(l, u) {
      let c = x3(l, n), h = u.config.facets[e.id], d = u.facet(e);
      if (h && !c && Y_(r, h))
        return l.values[s] = d, 0;
      let p = a(l);
      return e.compare(p, d) ? (l.values[s] = d, 0) : (l.values[s] = p, 1);
    }
  };
}
const kv = /* @__PURE__ */ Le.define({ static: !0 });
class jn {
  constructor(e, r, n, i, o) {
    this.id = e, this.createF = r, this.updateF = n, this.compareF = i, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new jn(J_++, e.create, e.update, e.compare || ((n, i) => n === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    return (e.facet(kv).find((n) => n.field == this)?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (n) => (n.values[r] = this.create(n), 1),
      update: (n, i) => {
        let o = n.values[r], s = this.updateF(o, i);
        return this.compareF(o, s) ? 0 : (n.values[r] = s, 1);
      },
      reconfigure: (n, i) => {
        let o = n.facet(kv), s = i.facet(kv), a;
        return (a = o.find((l) => l.field == this)) && a != s.find((l) => l.field == this) ? (n.values[r] = a.create(n), 1) : i.config.address[this.id] != null ? (n.values[r] = i.field(this), 0) : (n.values[r] = this.create(n), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, kv.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Bc = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Vp(t) {
  return (e) => new UT(e, t);
}
const pc = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Vp(Bc.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Vp(Bc.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Vp(Bc.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Vp(Bc.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Vp(Bc.lowest)
};
class UT {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class Mb {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new w3(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Mb.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class w3 {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class s1 {
  constructor(e, r, n, i, o, s) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = n, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, n) {
    let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let d of CX(e, r, s))
      d instanceof jn ? i.push(d) : (o[d.facet.id] || (o[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let d of i)
      a[d.id] = u.length << 1, u.push((p) => d.slot(p));
    let c = n?.config.facets;
    for (let d in o) {
      let p = o[d], g = p[0].facet, v = c && c[d] || [];
      if (p.every(
        (y) => y.type == 0
        /* Provider.Static */
      ))
        if (a[g.id] = l.length << 1 | 1, Y_(v, p))
          l.push(n.facet(g));
        else {
          let y = g.combine(p.map((b) => b.value));
          l.push(n && g.compare(y, n.facet(g)) ? n.facet(g) : y);
        }
      else {
        for (let y of p)
          y.type == 0 ? (a[y.id] = l.length << 1 | 1, l.push(y.value)) : (a[y.id] = u.length << 1, u.push((b) => y.dynamicSlot(b)));
        a[g.id] = u.length << 1, u.push((y) => kX(y, g, p));
      }
    }
    let h = u.map((d) => d(a));
    return new s1(e, s, h, a, l, o);
  }
}
function CX(t, e, r) {
  let n = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function o(s, a) {
    let l = i.get(s);
    if (l != null) {
      if (l <= a)
        return;
      let u = n[l].indexOf(s);
      u > -1 && n[l].splice(u, 1), s instanceof w3 && r.delete(s.compartment);
    }
    if (i.set(s, a), Array.isArray(s))
      for (let u of s)
        o(u, a);
    else if (s instanceof w3) {
      if (r.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(s.compartment) || s.inner;
      r.set(s.compartment, u), o(u, a);
    } else if (s instanceof UT)
      o(s.inner, s.prec);
    else if (s instanceof jn)
      n[a].push(s), s.provides && o(s.provides, a);
    else if (s instanceof Dy)
      n[a].push(s), s.facet.extensions && o(s.facet.extensions, Bc.default);
    else {
      let u = s.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(u, a);
    }
  }
  return o(t, Bc.default), n.reduce((s, a) => s.concat(a));
}
function Am(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, n = t.status[r];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | i;
}
function a1(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const HT = /* @__PURE__ */ Le.define(), k3 = /* @__PURE__ */ Le.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), VT = /* @__PURE__ */ Le.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), WT = /* @__PURE__ */ Le.define(), GT = /* @__PURE__ */ Le.define(), KT = /* @__PURE__ */ Le.define(), QT = /* @__PURE__ */ Le.define({
  combine: (t) => t.length ? t[0] : !1
});
class nu {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new _X();
  }
}
class _X {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new nu(this, e);
  }
}
class SX {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new _t(this, e);
  }
}
class _t {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new _t(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new SX(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let n = [];
    for (let i of e) {
      let o = i.map(r);
      o && n.push(o);
    }
    return n;
  }
}
_t.reconfigure = /* @__PURE__ */ _t.define();
_t.appendConfig = /* @__PURE__ */ _t.define();
class bn {
  constructor(e, r, n, i, o, s) {
    this.startState = e, this.changes = r, this.selection = n, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, n && qT(n, r.newLength), o.some((a) => a.type == bn.time) || (this.annotations = o.concat(bn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, n, i, o, s) {
    return new bn(e, r, n, i, o, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(bn.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
bn.time = /* @__PURE__ */ nu.define();
bn.userEvent = /* @__PURE__ */ nu.define();
bn.addToHistory = /* @__PURE__ */ nu.define();
bn.remote = /* @__PURE__ */ nu.define();
function AX(t, e) {
  let r = [];
  for (let n = 0, i = 0; ; ) {
    let o, s;
    if (n < t.length && (i == e.length || e[i] >= t[n]))
      o = t[n++], s = t[n++];
    else if (i < e.length)
      o = e[i++], s = e[i++];
    else
      return r;
    !r.length || r[r.length - 1] < o ? r.push(o, s) : r[r.length - 1] < s && (r[r.length - 1] = s);
  }
}
function XT(t, e, r) {
  var n;
  let i, o, s;
  return r ? (i = e.changes, o = En.empty(e.changes.length), s = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, !0), s = t.changes.compose(i)), {
    changes: s,
    selection: e.selection ? e.selection.map(o) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(i),
    effects: _t.mapEffects(t.effects, i).concat(_t.mapEffects(e.effects, o)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function C3(t, e, r) {
  let n = e.selection, i = Uf(e.annotations);
  return e.userEvent && (i = i.concat(bn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof En ? e.changes : En.of(e.changes || [], r, t.facet(VT)),
    selection: n && (n instanceof de ? n : de.single(n.anchor, n.head)),
    effects: Uf(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function JT(t, e, r) {
  let n = C3(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (r = !1);
    let s = !!e[o].sequential;
    n = XT(n, C3(t, e[o], s ? n.changes.newLength : t.doc.length), s);
  }
  let i = bn.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return DX(r ? EX(i) : i);
}
function EX(t) {
  let e = t.startState, r = !0;
  for (let i of e.facet(WT)) {
    let o = i(t);
    if (o === !1) {
      r = !1;
      break;
    }
    Array.isArray(o) && (r = r === !0 ? o : AX(r, o));
  }
  if (r !== !0) {
    let i, o;
    if (r === !1)
      o = t.changes.invertedDesc, i = En.empty(e.doc.length);
    else {
      let s = t.changes.filter(r);
      i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    t = bn.create(e, i, t.selection && t.selection.map(o), _t.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
  }
  let n = e.facet(GT);
  for (let i = n.length - 1; i >= 0; i--) {
    let o = n[i](t);
    o instanceof bn ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof bn ? t = o[0] : t = JT(e, Uf(o), !1);
  }
  return t;
}
function DX(t) {
  let e = t.startState, r = e.facet(KT), n = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let o = r[i](t);
    o && Object.keys(o).length && (n = XT(n, C3(e, o, t.changes.newLength), !0));
  }
  return n == t ? t : bn.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
const OX = [];
function Uf(t) {
  return t == null ? OX : Array.isArray(t) ? t : [t];
}
var Hr = /* @__PURE__ */ (function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
})(Hr || (Hr = {}));
const FX = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let _3;
try {
  _3 = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function TX(t) {
  if (_3)
    return _3.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "Â€" && (r.toUpperCase() != r.toLowerCase() || FX.test(r)))
      return !0;
  }
  return !1;
}
function MX(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Hr.Space;
    if (TX(e))
      return Hr.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return Hr.Word;
    return Hr.Other;
  };
}
class nr {
  constructor(e, r, n, i, o, s) {
    this.config = e, this.doc = r, this.selection = n, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Am(this, a << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Am(this, n), a1(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return JT(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: n, compartments: i } = r;
    for (let a of e.effects)
      a.is(Mb.reconfigure) ? (r && (i = /* @__PURE__ */ new Map(), r.compartments.forEach((l, u) => i.set(u, l)), r = null), i.set(a.value.compartment, a.value.extension)) : a.is(_t.reconfigure) ? (r = null, n = a.value) : a.is(_t.appendConfig) && (r = null, n = Uf(n).concat(a.value));
    let o;
    r ? o = e.startState.values.slice() : (r = s1.resolve(n, i, this), o = new nr(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (a, l) => l.reconfigure(a, this), null).values);
    let s = e.startState.facet(k3) ? e.newSelection : e.newSelection.asSingle();
    new nr(r, e.newDoc, s, o, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: de.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, n = e(r.ranges[0]), i = this.changes(n.changes), o = [n.range], s = Uf(n.effects);
    for (let a = 1; a < r.ranges.length; a++) {
      let l = e(r.ranges[a]), u = this.changes(l.changes), c = u.map(i);
      for (let d = 0; d < a; d++)
        o[d] = o[d].map(c);
      let h = i.mapDesc(u, !0);
      o.push(l.range.map(h)), i = i.compose(c), s = _t.mapEffects(s, c).concat(_t.mapEffects(Uf(l.effects), h));
    }
    return {
      changes: i,
      selection: de.create(o, r.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof En ? e : En.of(e, this.doc.length, this.facet(nr.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return ir.of(e.split(this.facet(nr.lineSeparator) || v3));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Am(this, r), a1(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let i = e[n];
        i instanceof jn && this.config.address[i.id] != null && (r[n] = i.spec.toJSON(this.field(e[n]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (n) {
      for (let o in n)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let s = n[o], a = e[o];
          i.push(s.init((l) => s.spec.fromJSON(a, l)));
        }
    }
    return nr.create({
      doc: e.doc,
      selection: de.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorâ€”updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = s1.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof ir ? e.doc : ir.of((e.doc || "").split(r.staticFacet(nr.lineSeparator) || v3)), i = e.selection ? e.selection instanceof de ? e.selection : de.single(e.selection.anchor, e.selection.head) : de.single(0);
    return qT(i, n.length), r.staticFacet(k3) || (i = i.asSingle()), new nr(r, n, i, r.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(nr.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(nr.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(QT);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let n of this.facet(nr.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (n, i) => {
      if (i == "$")
        return "$";
      let o = +(i || 1);
      return !o || o > r.length ? n : r[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, n = -1) {
    let i = [];
    for (let o of this.facet(HT))
      for (let s of o(this, r, n))
        Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return MX(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: n, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - n, a = e - n;
    for (; s > 0; ) {
      let l = Qn(r, s, !1);
      if (o(r.slice(l, s)) != Hr.Word)
        break;
      s = l;
    }
    for (; a < i; ) {
      let l = Qn(r, a);
      if (o(r.slice(a, l)) != Hr.Word)
        break;
      a = l;
    }
    return s == a ? null : de.range(s + n, a + n);
  }
}
nr.allowMultipleSelections = k3;
nr.tabSize = /* @__PURE__ */ Le.define({
  combine: (t) => t.length ? t[0] : 4
});
nr.lineSeparator = VT;
nr.readOnly = QT;
nr.phrases = /* @__PURE__ */ Le.define({
  compare(t, e) {
    let r = Object.keys(t), n = Object.keys(e);
    return r.length == n.length && r.every((i) => t[i] == e[i]);
  }
});
nr.languageData = HT;
nr.changeFilter = WT;
nr.transactionFilter = GT;
nr.transactionExtender = KT;
Mb.reconfigure = /* @__PURE__ */ _t.define();
function iu(t, e, r = {}) {
  let n = {};
  for (let i of t)
    for (let o of Object.keys(i)) {
      let s = i[o], a = n[o];
      if (a === void 0)
        n[o] = s;
      else if (!(a === s || s === void 0)) if (Object.hasOwnProperty.call(r, o))
        n[o] = r[o](a, s);
      else
        throw new Error("Config merge conflict for field " + o);
    }
  for (let i in e)
    n[i] === void 0 && (n[i] = e[i]);
  return n;
}
class bh {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return S3.create(e, r, this);
  }
}
bh.prototype.startSide = bh.prototype.endSide = 0;
bh.prototype.point = !1;
bh.prototype.mapMode = Kn.TrackDel;
let S3 = class YT {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.value = n;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new YT(e, r, n);
  }
};
function A3(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class Z_ {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.value = n, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, n, i = 0) {
    let o = n ? this.to : this.from;
    for (let s = i, a = o.length; ; ) {
      if (s == a)
        return s;
      let l = s + a >> 1, u = o[l] - e || (n ? this.value[l].endSide : this.value[l].startSide) - r;
      if (l == s)
        return u >= 0 ? s : a;
      u >= 0 ? a = l : s = l + 1;
    }
  }
  between(e, r, n, i) {
    for (let o = this.findIndex(r, -1e9, !0), s = this.findIndex(n, 1e9, !1, o); o < s; o++)
      if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === !1)
        return !1;
  }
  map(e, r) {
    let n = [], i = [], o = [], s = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], c = this.from[l] + e, h = this.to[l] + e, d, p;
      if (c == h) {
        let g = r.mapPos(c, u.startSide, u.mapMode);
        if (g == null || (d = p = g, u.startSide != u.endSide && (p = r.mapPos(c, u.endSide), p < d)))
          continue;
      } else if (d = r.mapPos(c, u.startSide), p = r.mapPos(h, u.endSide), d > p || d == p && u.startSide > 0 && u.endSide <= 0)
        continue;
      (p - d || u.endSide - u.startSide) < 0 || (s < 0 && (s = d), u.point && (a = Math.max(a, p - d)), n.push(u), i.push(d - s), o.push(p - s));
    }
    return { mapped: n.length ? new Z_(i, o, n, a) : null, pos: s };
  }
}
class hr {
  constructor(e, r, n, i) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = n, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, r, n, i) {
    return new hr(e, r, n, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: n = !1, filterFrom: i = 0, filterTo: o = this.length } = e, s = e.filter;
    if (r.length == 0 && !s)
      return this;
    if (n && (r = r.slice().sort(A3)), this.isEmpty)
      return r.length ? hr.of(r) : this;
    let a = new ZT(this, null, -1).goto(0), l = 0, u = [], c = new rc();
    for (; a.value || l < r.length; )
      if (l < r.length && (a.from - r[l].from || a.startSide - r[l].value.startSide) >= 0) {
        let h = r[l++];
        c.addInner(h.from, h.to, h.value) || u.push(h);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == r.length || this.chunkEnd(a.chunkIndex) < r[l].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && c.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (c.addInner(a.from, a.to, a.value) || u.push(S3.create(a.from, a.to, a.value))), a.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? hr.empty : this.nextLayer.update({ add: u, filter: s, filterFrom: i, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], n = [], i = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], l = this.chunk[s], u = e.touchesRange(a, a + l.length);
      if (u === !1)
        i = Math.max(i, l.maxPoint), r.push(l), n.push(e.mapPos(a));
      else if (u === !0) {
        let { mapped: c, pos: h } = l.map(a, e);
        c && (i = Math.max(i, c.maxPoint), r.push(c), n.push(h));
      }
    }
    let o = this.nextLayer.map(e);
    return r.length == 0 ? o : new hr(n, r, o || hr.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, n) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i], s = this.chunk[i];
        if (r >= o && e <= o + s.length && s.between(o, e - o, r - o, n) === !1)
          return;
      }
      this.nextLayer.between(e, r, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Km.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return Km.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, n, i, o = -1) {
    let s = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), a = r.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), l = FD(s, a, n), u = new Wp(s, l, o), c = new Wp(a, l, o);
    n.iterGaps((h, d, p) => TD(u, h, c, d, p, i)), n.empty && n.length == 0 && TD(u, 0, c, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, n = 0, i) {
    i == null && (i = 999999999);
    let o = e.filter((c) => !c.isEmpty && r.indexOf(c) < 0), s = r.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (o.length != s.length)
      return !1;
    if (!o.length)
      return !0;
    let a = FD(o, s), l = new Wp(o, a, 0).goto(n), u = new Wp(s, a, 0).goto(n);
    for (; ; ) {
      if (l.to != u.to || !E3(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, n, i, o = -1) {
    let s = new Wp(e, null, o).goto(r), a = r, l = s.openStart;
    for (; ; ) {
      let u = Math.min(s.to, n);
      if (s.point) {
        let c = s.activeForPoint(s.to), h = s.pointFrom < r ? c.length + 1 : s.point.startSide < 0 ? c.length : Math.min(c.length, l);
        i.point(a, u, s.point, c, h, s.pointRank), l = Math.min(s.openEnd(u), c.length);
      } else u > a && (i.span(a, u, s.active, l), l = s.openEnd(u));
      if (s.to > n)
        return l + (s.point && s.to > n ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let n = new rc();
    for (let i of e instanceof S3 ? [e] : r ? PX(e) : e)
      n.add(i.from, i.to, i.value);
    return n.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return hr.empty;
    let r = e[e.length - 1];
    for (let n = e.length - 2; n >= 0; n--)
      for (let i = e[n]; i != hr.empty; i = i.nextLayer)
        r = new hr(i.chunkPos, i.chunk, r, Math.max(i.maxPoint, r.maxPoint));
    return r;
  }
}
hr.empty = /* @__PURE__ */ new hr([], [], null, -1);
function PX(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let n = t[r];
      if (A3(e, n) > 0)
        return t.slice().sort(A3);
      e = n;
    }
  return t;
}
hr.empty.nextLayer = hr.empty;
class rc {
  finishChunk(e) {
    this.chunks.push(new Z_(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, n) {
    this.addInner(e, r, n) || (this.nextLayer || (this.nextLayer = new rc())).add(e, r, n);
  }
  /**
  @internal
  */
  addInner(e, r, n) {
    let i = e - this.lastTo || n.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = r, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let n = r.value.length - 1;
    return this.last = r.value[n], this.lastFrom = r.from[n] + e, this.lastTo = r.to[n] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(hr.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = hr.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function FD(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  for (let o of t)
    for (let s = 0; s < o.chunk.length; s++)
      o.chunk[s].maxPoint <= 0 && n.set(o.chunk[s], o.chunkPos[s]);
  let i = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let s = 0; s < o.chunk.length; s++) {
      let a = n.get(o.chunk[s]);
      a != null && (r ? r.mapPos(a) : a) == o.chunkPos[s] && !r?.touchesRange(a, a + o.chunk[s].length) && i.add(o.chunk[s]);
    }
  return i;
}
class ZT {
  constructor(e, r, n, i = 0) {
    this.layer = e, this.skip = r, this.minPoint = n, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!n || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], n = e + r.from[this.rangeIndex];
        if (this.from = n, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Km {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, n = -1) {
    let i = [];
    for (let o = 0; o < e.length; o++)
      for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= n && i.push(new ZT(s, r, n, o));
    return i.length == 1 ? i[0] : new Km(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let n of this.heap)
      n.goto(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      v2(this.heap, n);
    return this.next(), this;
  }
  forward(e, r) {
    for (let n of this.heap)
      n.forward(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      v2(this.heap, n);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), v2(this.heap, 0);
    }
  }
}
function v2(t, e) {
  for (let r = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length)
      break;
    let i = t[n];
    if (n + 1 < t.length && i.compare(t[n + 1]) >= 0 && (i = t[n + 1], n++), r.compare(i) < 0)
      break;
    t[n] = r, t[e] = i, e = n;
  }
}
class Wp {
  constructor(e, r, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Km.from(e, r, n);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    Cv(this.active, e), Cv(this.activeTo, e), Cv(this.activeRank, e), this.minActive = MD(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: n, to: i, rank: o } = this.cursor;
    for (; r < this.activeRank.length && (o - this.activeRank[r] || i - this.activeTo[r]) > 0; )
      r++;
    _v(this.active, r, n), _v(this.activeTo, r, i), _v(this.activeRank, r, o), e && _v(e, r, this.cursor.from), this.minActive = MD(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), n && Cv(n, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(n), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let i = n.length - 1; i >= 0 && n[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && r.push(this.active[n]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      r++;
    return r;
  }
}
function TD(t, e, r, n, i, o) {
  t.goto(e), r.goto(n);
  let s = n + i, a = n, l = n - e;
  for (; ; ) {
    let u = t.to + l - r.to, c = u || t.endSide - r.endSide, h = c < 0 ? t.to + l : r.to, d = Math.min(h, s);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && E3(t.activeForPoint(t.to), r.activeForPoint(r.to)) || o.comparePoint(a, d, t.point, r.point) : d > a && !E3(t.active, r.active) && o.compareRange(a, d, t.active, r.active), h > s)
      break;
    (u || t.openEnd != r.openEnd) && o.boundChange && o.boundChange(h), a = h, c <= 0 && t.next(), c >= 0 && r.next();
  }
}
function E3(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function Cv(t, e) {
  for (let r = e, n = t.length - 1; r < n; r++)
    t[r] = t[r + 1];
  t.pop();
}
function _v(t, e, r) {
  for (let n = t.length - 1; n >= e; n--)
    t[n + 1] = t[n];
  t[e] = r;
}
function MD(t, e) {
  let r = -1, n = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - n || t[i].endSide - t[r].endSide) < 0 && (r = i, n = e[i]);
  return r;
}
function Xd(t, e, r = t.length) {
  let n = 0;
  for (let i = 0; i < r && i < t.length; )
    t.charCodeAt(i) == 9 ? (n += e - n % e, i++) : (n++, i = Qn(t, i));
  return n;
}
function D3(t, e, r, n) {
  for (let i = 0, o = 0; ; ) {
    if (o >= e)
      return i;
    if (i == t.length)
      break;
    o += t.charCodeAt(i) == 9 ? r - o % r : 1, i = Qn(t, i);
  }
  return n === !0 ? -1 : t.length;
}
const O3 = "Í¼", PD = typeof Symbol > "u" ? "__" + O3 : Symbol.for(O3), F3 = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), RD = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class nc {
  // :: (Object<Style>, ?{finish: ?(string) â†’ string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: n } = r || {};
    function i(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function o(s, a, l, u) {
      let c = [], h = /^@(\w+)\b/.exec(s[0]), d = h && h[1] == "keyframes";
      if (h && a == null) return l.push(s[0] + ";");
      for (let p in a) {
        let g = a[p];
        if (/&/.test(p))
          o(
            p.split(/,\s*/).map((v) => s.map((y) => v.replace(/&/, y))).reduce((v, y) => v.concat(y)),
            g,
            l
          );
        else if (g && typeof g == "object") {
          if (!h) throw new RangeError("The value of a property (" + p + ") should be a primitive value.");
          o(i(p), g, c, d);
        } else g != null && c.push(p.replace(/_.*/, "").replace(/[A-Z]/g, (v) => "-" + v.toLowerCase()) + ": " + g + ";");
      }
      (c.length || d) && l.push((n && !h && !u ? s.map(n) : s).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let s in e) o(i(s), e[s], this.rules);
  }
  // :: () â†’ string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () â†’ string
  // Generate a new unique CSS class name.
  static newName() {
    let e = RD[PD] || 1;
    return RD[PD] = e + 1, O3 + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, n) {
    let i = e[F3], o = n && n.nonce;
    i ? o && i.setNonce(o) : i = new RX(e, o), i.mount(Array.isArray(r) ? r : [r], e);
  }
}
let ND = /* @__PURE__ */ new Map();
class RX {
  constructor(e, r) {
    let n = e.ownerDocument || e, i = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = ND.get(n);
      if (o) return e[F3] = o;
      this.sheet = new i.CSSStyleSheet(), ND.set(n, this);
    } else
      this.styleTag = n.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
    this.modules = [], e[F3] = this;
  }
  mount(e, r) {
    let n = this.sheet, i = 0, o = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = this.modules.indexOf(a);
      if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
        if (this.modules.splice(o++, 0, a), n) for (let u = 0; u < a.rules.length; u++)
          n.insertRule(a.rules[u], i++);
      } else {
        for (; o < l; ) i += this.modules[o++].rules.length;
        i += a.rules.length, o++;
      }
    }
    if (n)
      r.adoptedStyleSheets.indexOf(this.sheet) < 0 && (r.adoptedStyleSheets = [this.sheet, ...r.adoptedStyleSheets]);
    else {
      let s = "";
      for (let l = 0; l < this.modules.length; l++)
        s += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = s;
      let a = r.head || r;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var ic = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Qm = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, NX = typeof navigator < "u" && /Mac/.test(navigator.platform), $X = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Gn = 0; Gn < 10; Gn++) ic[48 + Gn] = ic[96 + Gn] = String(Gn);
for (var Gn = 1; Gn <= 24; Gn++) ic[Gn + 111] = "F" + Gn;
for (var Gn = 65; Gn <= 90; Gn++)
  ic[Gn] = String.fromCharCode(Gn + 32), Qm[Gn] = String.fromCharCode(Gn);
for (var y2 in ic) Qm.hasOwnProperty(y2) || (Qm[y2] = ic[y2]);
function IX(t) {
  var e = NX && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || $X && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? Qm : ic)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function Er() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var n in r) if (Object.prototype.hasOwnProperty.call(r, n)) {
      var i = r[n];
      typeof i == "string" ? t.setAttribute(n, i) : i != null && (t[n] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) eM(t, arguments[e]);
  return t;
}
function eM(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var r = 0; r < e.length; r++) eM(t, e[r]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
let Oi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, T3 = typeof document < "u" ? document : { documentElement: { style: {} } };
const M3 = /* @__PURE__ */ /Edge\/(\d+)/.exec(Oi.userAgent), tM = /* @__PURE__ */ /MSIE \d/.test(Oi.userAgent), P3 = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Oi.userAgent), Pb = !!(tM || P3 || M3), $D = !Pb && /* @__PURE__ */ /gecko\/(\d+)/i.test(Oi.userAgent), b2 = !Pb && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Oi.userAgent), BX = "webkitFontSmoothing" in T3.documentElement.style, R3 = !Pb && /* @__PURE__ */ /Apple Computer/.test(Oi.vendor), ID = R3 && (/* @__PURE__ */ /Mobile\/\w+/.test(Oi.userAgent) || Oi.maxTouchPoints > 2);
var Ie = {
  mac: ID || /* @__PURE__ */ /Mac/.test(Oi.platform),
  windows: /* @__PURE__ */ /Win/.test(Oi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Oi.platform),
  ie: Pb,
  ie_version: tM ? T3.documentMode || 6 : P3 ? +P3[1] : M3 ? +M3[1] : 0,
  gecko: $D,
  gecko_version: $D ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Oi.userAgent) || [0, 0])[1] : 0,
  chrome: !!b2,
  chrome_version: b2 ? +b2[1] : 0,
  ios: ID,
  android: /* @__PURE__ */ /Android\b/.test(Oi.userAgent),
  webkit_version: BX ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Oi.userAgent) || [0, 0])[1] : 0,
  safari: R3,
  safari_version: R3 ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(Oi.userAgent) || [0, 0])[1] : 0,
  tabSize: T3.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function Xm(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function N3(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Oy(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return N3(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Jm(t) {
  return t.nodeType == 3 ? wh(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Em(t, e, r, n) {
  return r ? BD(t, e, r, n, -1) || BD(t, e, r, n, 1) : !1;
}
function xh(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function l1(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function BD(t, e, r, n, i) {
  for (; ; ) {
    if (t == r && e == n)
      return !0;
    if (e == (i < 0 ? 0 : Xa(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let o = t.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      e = xh(t) + (i < 0 ? 0 : 1), t = o;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? Xa(t) : 0;
    } else
      return !1;
  }
}
function Xa(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Rb(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function LX(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function rM(t, e) {
  let r = e.width / t.offsetWidth, n = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.height - t.offsetHeight) < 1) && (n = 1), { scaleX: r, scaleY: n };
}
function zX(t, e, r, n, i, o, s, a) {
  let l = t.ownerDocument, u = l.defaultView || window;
  for (let c = t, h = !1; c && !h; )
    if (c.nodeType == 1) {
      let d, p = c == l.body, g = 1, v = 1;
      if (p)
        d = LX(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (h = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let k = c.getBoundingClientRect();
        ({ scaleX: g, scaleY: v } = rM(c, k)), d = {
          left: k.left,
          right: k.left + c.clientWidth * g,
          top: k.top,
          bottom: k.top + c.clientHeight * v
        };
      }
      let y = 0, b = 0;
      if (i == "nearest")
        e.top < d.top ? (b = e.top - (d.top + s), r > 0 && e.bottom > d.bottom + b && (b = e.bottom - d.bottom + s)) : e.bottom > d.bottom && (b = e.bottom - d.bottom + s, r < 0 && e.top - b < d.top && (b = e.top - (d.top + s)));
      else {
        let k = e.bottom - e.top, C = d.bottom - d.top;
        b = (i == "center" && k <= C ? e.top + k / 2 - C / 2 : i == "start" || i == "center" && r < 0 ? e.top - s : e.bottom - C + s) - d.top;
      }
      if (n == "nearest" ? e.left < d.left ? (y = e.left - (d.left + o), r > 0 && e.right > d.right + y && (y = e.right - d.right + o)) : e.right > d.right && (y = e.right - d.right + o, r < 0 && e.left < d.left + y && (y = e.left - (d.left + o))) : y = (n == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : n == "start" == a ? e.left - o : e.right - (d.right - d.left) + o) - d.left, y || b)
        if (p)
          u.scrollBy(y, b);
        else {
          let k = 0, C = 0;
          if (b) {
            let S = c.scrollTop;
            c.scrollTop += b / v, C = (c.scrollTop - S) * v;
          }
          if (y) {
            let S = c.scrollLeft;
            c.scrollLeft += y / g, k = (c.scrollLeft - S) * g;
          }
          e = {
            left: e.left - k,
            top: e.top - C,
            right: e.right - k,
            bottom: e.bottom - C
          }, k && Math.abs(k - y) < 1 && (n = "nearest"), C && Math.abs(C - b) < 1 && (i = "nearest");
        }
      if (p)
        break;
      (e.top < d.top || e.bottom > d.bottom || e.left < d.left || e.right > d.right) && (e = {
        left: Math.max(e.left, d.left),
        right: Math.min(e.right, d.right),
        top: Math.max(e.top, d.top),
        bottom: Math.min(e.bottom, d.bottom)
      }), c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function jX(t) {
  let e = t.ownerDocument, r, n;
  for (let i = t.parentNode; i && !(i == e.body || r && n); )
    if (i.nodeType == 1)
      !n && i.scrollHeight > i.clientHeight && (n = i), !r && i.scrollWidth > i.clientWidth && (r = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: r, y: n };
}
class qX {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: n } = e;
    this.set(r, Math.min(e.anchorOffset, r ? Xa(r) : 0), n, Math.min(e.focusOffset, n ? Xa(n) : 0));
  }
  set(e, r, n, i) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = n, this.focusOffset = i;
  }
}
let Rc = null;
Ie.safari && Ie.safari_version >= 26 && (Rc = !1);
function nM(t) {
  if (t.setActive)
    return t.setActive();
  if (Rc)
    return t.focus(Rc);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(Rc == null ? {
    get preventScroll() {
      return Rc = { preventScroll: !0 }, !0;
    }
  } : void 0), !Rc) {
    Rc = !1;
    for (let r = 0; r < e.length; ) {
      let n = e[r++], i = e[r++], o = e[r++];
      n.scrollTop != i && (n.scrollTop = i), n.scrollLeft != o && (n.scrollLeft = o);
    }
  }
}
let LD;
function wh(t, e, r = e) {
  let n = LD || (LD = document.createRange());
  return n.setEnd(t, r), n.setStart(t, e), n;
}
function Hf(t, e, r, n) {
  let i = { key: e, code: e, keyCode: r, which: r, cancelable: !0 };
  n && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = n);
  let o = new KeyboardEvent("keydown", i);
  o.synthetic = !0, t.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function UX(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function iM(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function HX(t, e) {
  let r = e.focusNode, n = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != n)
    return !1;
  for (n = Math.min(n, Xa(r)); ; )
    if (n) {
      if (r.nodeType != 1)
        return !1;
      let i = r.childNodes[n - 1];
      i.contentEditable == "false" ? n-- : (r = i, n = Xa(r));
    } else {
      if (r == t)
        return !0;
      n = xh(r), r = r.parentNode;
    }
}
function oM(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function sM(t, e) {
  for (let r = t, n = e; ; ) {
    if (r.nodeType == 3 && n > 0)
      return { node: r, offset: n };
    if (r.nodeType == 1 && n > 0) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[n - 1], n = Xa(r);
    } else if (r.parentNode && !l1(r))
      n = xh(r), r = r.parentNode;
    else
      return null;
  }
}
function aM(t, e) {
  for (let r = t, n = e; ; ) {
    if (r.nodeType == 3 && n < r.nodeValue.length)
      return { node: r, offset: n };
    if (r.nodeType == 1 && n < r.childNodes.length) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[n], n = 0;
    } else if (r.parentNode && !l1(r))
      n = xh(r) + 1, r = r.parentNode;
    else
      return null;
  }
}
class ni {
  constructor(e, r, n = !0) {
    this.node = e, this.offset = r, this.precise = n;
  }
  static before(e, r) {
    return new ni(e.parentNode, xh(e), r);
  }
  static after(e, r) {
    return new ni(e.parentNode, xh(e) + 1, r);
  }
}
const e4 = [];
class _r {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return r;
      r += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let n = this.dom, i = null, o;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (o = i ? i.nextSibling : n.firstChild)) {
            let a = _r.get(o);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
          }
          s.sync(e, r), s.flags &= -8;
        }
        if (o = i ? i.nextSibling : n.firstChild, r && !r.written && r.node == n && o != s.dom && (r.written = !0), s.dom.parentNode == n)
          for (; o && o != s.dom; )
            o = zD(o);
        else
          n.insertBefore(s.dom, o);
        i = s.dom;
      }
      for (o = i ? i.nextSibling : n.firstChild, o && r && r.node == n && (r.written = !0); o; )
        o = zD(o);
    } else if (this.flags & 1)
      for (let n of this.children)
        n.flags & 7 && (n.sync(e, r), n.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[r];
    else {
      let i = Xa(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
      }
      i < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !_r.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let i = 0, o = 0; ; i++) {
      let s = this.children[i];
      if (s.dom == n)
        return o;
      o += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, r, n = 0) {
    let i = -1, o = -1, s = -1, a = -1;
    for (let l = 0, u = n, c = n; l < this.children.length; l++) {
      let h = this.children[l], d = u + h.length;
      if (u < e && d > r)
        return h.domBoundsAround(e, r, u);
      if (d >= e && i == -1 && (i = l, o = u), u > r && h.dom.parentNode == this.dom) {
        s = l, a = c;
        break;
      }
      c = d, u = d + h.breakAfter;
    }
    return {
      from: o,
      to: a < 0 ? n + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, n = e4) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let o = this.children[i];
      o.parent == this && n.indexOf(o) < 0 && o.destroy();
    }
    n.length < 250 ? this.children.splice(e, r - e, ...n) : this.children = [].concat(this.children.slice(0, e), n, this.children.slice(r));
    for (let i = 0; i < n.length; i++)
      n[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new lM(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, n, i, o, s) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
_r.prototype.breakAfter = 0;
function zD(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class lM {
  constructor(e, r, n) {
    this.children = e, this.pos = r, this.i = n, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function uM(t, e, r, n, i, o, s, a, l) {
  let { children: u } = t, c = u.length ? u[e] : null, h = o.length ? o[o.length - 1] : null, d = h ? h.breakAfter : s;
  if (!(e == n && c && !s && !d && o.length < 2 && c.merge(r, i, o.length ? h : null, r == 0, a, l))) {
    if (n < u.length) {
      let p = u[n];
      p && (i < p.length || p.breakAfter && h?.breakAfter) ? (e == n && (p = p.split(i), i = 0), !d && h && p.merge(0, i, h, !0, 0, l) ? o[o.length - 1] = p : ((i || p.children.length && !p.children[0].length) && p.merge(0, i, null, !1, 0, l), o.push(p))) : p?.breakAfter && (h ? h.breakAfter = 1 : s = 1), n++;
    }
    for (c && (c.breakAfter = s, r > 0 && (!s && o.length && c.merge(r, c.length, o[0], !1, a, 0) ? c.breakAfter = o.shift().breakAfter : (r < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(r, c.length, null, !1, a, 0), e++)); e < n && o.length; )
      if (u[n - 1].become(o[o.length - 1]))
        n--, o.pop(), l = o.length ? 0 : a;
      else if (u[e].become(o[0]))
        e++, o.shift(), a = o.length ? 0 : l;
      else
        break;
    !o.length && e && n < u.length && !u[e - 1].breakAfter && u[n].merge(0, 0, u[e - 1], !1, a, l) && e--, (e < n || o.length) && t.replaceChildren(e, n, o);
  }
}
function cM(t, e, r, n, i, o) {
  let s = t.childCursor(), { i: a, off: l } = s.findPos(r, 1), { i: u, off: c } = s.findPos(e, -1), h = e - r;
  for (let d of n)
    h += d.length;
  t.length += h, uM(t, u, c, a, l, n, 0, i, o);
}
const VX = 256;
class Xs extends _r {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, n) {
    return this.flags & 8 || n && (!(n instanceof Xs) || this.length - (r - e) + n.length > VX || n.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new Xs(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new ni(this.dom, e);
  }
  domBoundsAround(e, r, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return WX(this.dom, e, r);
  }
}
class Jl extends _r {
  constructor(e, r = [], n = 0) {
    super(), this.mark = e, this.children = r, this.length = n;
    for (let i of r)
      i.setParent(this);
  }
  setAttrs(e) {
    if (iM(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, n, i, o, s) {
    return n && (!(n instanceof Jl && n.mark.eq(this.mark)) || e && o <= 0 || r < this.length && s <= 0) ? !1 : (cM(this, e, r, n ? n.children.slice() : [], o - 1, s - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], n = 0, i = -1, o = 0;
    for (let a of this.children) {
      let l = n + a.length;
      l > e && r.push(n < e ? a.split(e - n) : a), i < 0 && n >= e && (i = o), n = l, o++;
    }
    let s = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Jl(this.mark, r, s);
  }
  domAtPos(e) {
    return hM(this, e);
  }
  coordsAt(e, r) {
    return dM(this, e, r);
  }
}
function WX(t, e, r) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let i = e, o = e, s = 0;
  e == 0 && r < 0 || e == n && r >= 0 ? Ie.chrome || Ie.gecko || (e ? (i--, s = 1) : o < n && (o++, s = -1)) : r < 0 ? i-- : o < n && o++;
  let a = wh(t, i, o).getClientRects();
  if (!a.length)
    return null;
  let l = a[(s ? s < 0 : r >= 0) ? 0 : a.length - 1];
  return Ie.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (u) => u.width) || l), s ? Rb(l, s < 0) : l || null;
}
class Pu extends _r {
  static create(e, r, n) {
    return new Pu(e, r, n);
  }
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.side = n, this.prevWidget = null;
  }
  split(e) {
    let r = Pu.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, n, i, o, s) {
    return n && (!(n instanceof Pu) || !this.widget.compare(n.widget) || e > 0 && o <= 0 || r < this.length && s <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof Pu && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return ir.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, n = r && r.state.doc, i = this.posAtStart;
    return n ? n.slice(i, i + this.length) : ir.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? ni.before(this.dom) : ni.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let n = this.widget.coordsAt(this.dom, e, r);
    if (n)
      return n;
    let i = this.dom.getClientRects(), o = null;
    if (!i.length)
      return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let a = s ? i.length - 1 : 0; o = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
      ;
    return Rb(o, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class xd extends _r {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof xd && e.side == this.side;
  }
  split() {
    return new xd(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? ni.before(this.dom) : ni.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return ir.empty;
  }
  get isHidden() {
    return !0;
  }
}
Xs.prototype.children = Pu.prototype.children = xd.prototype.children = e4;
function hM(t, e) {
  let r = t.dom, { children: n } = t, i = 0;
  for (let o = 0; i < n.length; i++) {
    let s = n[i], a = o + s.length;
    if (!(a == o && s.getSide() <= 0)) {
      if (e > o && e < a && s.dom.parentNode == r)
        return s.domAtPos(e - o);
      if (e <= o)
        break;
      o = a;
    }
  }
  for (let o = i; o > 0; o--) {
    let s = n[o - 1];
    if (s.dom.parentNode == r)
      return s.domAtPos(s.length);
  }
  for (let o = i; o < n.length; o++) {
    let s = n[o];
    if (s.dom.parentNode == r)
      return s.domAtPos(0);
  }
  return new ni(r, 0);
}
function fM(t, e, r) {
  let n, { children: i } = t;
  r > 0 && e instanceof Jl && i.length && (n = i[i.length - 1]) instanceof Jl && n.mark.eq(e.mark) ? fM(n, e.children[0], r - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function dM(t, e, r) {
  let n = null, i = -1, o = null, s = -1;
  function a(u, c) {
    for (let h = 0, d = 0; h < u.children.length && d <= c; h++) {
      let p = u.children[h], g = d + p.length;
      g >= c && (p.children.length ? a(p, c - d) : (!o || o.isHidden && (r > 0 || KX(o, p))) && (g > c || d == g && p.getSide() > 0) ? (o = p, s = c - d) : (d < c || d == g && p.getSide() < 0 && !p.isHidden) && (n = p, i = c - d)), d = g;
    }
  }
  a(t, e);
  let l = (r < 0 ? n : o) || n || o;
  return l ? l.coordsAt(Math.max(0, l == n ? i : s), r) : GX(t);
}
function GX(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = Jm(e);
  return r[r.length - 1] || null;
}
function KX(t, e) {
  let r = t.coordsAt(0, 1), n = e.coordsAt(0, 1);
  return r && n && n.top < r.bottom;
}
function $3(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const jD = /* @__PURE__ */ Object.create(null);
function u1(t, e, r) {
  if (t == e)
    return !0;
  t || (t = jD), e || (e = jD);
  let n = Object.keys(t), i = Object.keys(e);
  if (n.length - (r && n.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let o of n)
    if (o != r && (i.indexOf(o) == -1 || t[o] !== e[o]))
      return !1;
  return !0;
}
function I3(t, e, r) {
  let n = !1;
  if (e)
    for (let i in e)
      r && i in r || (n = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (r)
    for (let i in r)
      e && e[i] == r[i] || (n = !0, i == "style" ? t.style.cssText = r[i] : t.setAttribute(i, r[i]));
  return n;
}
function QX(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let n = t.attributes[r];
    e[n.name] = n.value;
  }
  return e;
}
class Bh {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, n) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Ni = /* @__PURE__ */ (function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
})(Ni || (Ni = {}));
class pt extends bh {
  constructor(e, r, n, i) {
    super(), this.startSide = e, this.endSide = r, this.widget = n, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Qg(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), n = !!e.block;
    return r += n && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new oc(e, r, r, n, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, n, i;
    if (e.isBlockGap)
      n = -5e8, i = 4e8;
    else {
      let { start: o, end: s } = pM(e, r);
      n = (o ? r ? -3e8 : -1 : 5e8) - 1, i = (s ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new oc(e, n, i, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Xg(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return hr.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
pt.none = hr.empty;
class Qg extends pt {
  constructor(e) {
    let { start: r, end: n } = pM(e);
    super(r ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, n;
    return this == e || e instanceof Qg && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) && u1(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
Qg.prototype.point = !1;
class Xg extends pt {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Xg && this.spec.class == e.spec.class && u1(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Xg.prototype.mapMode = Kn.TrackBefore;
Xg.prototype.point = !0;
class oc extends pt {
  constructor(e, r, n, i, o, s) {
    super(r, n, o, e), this.block = i, this.isReplace = s, this.mapMode = i ? r <= 0 ? Kn.TrackBefore : Kn.TrackAfter : Kn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Ni.WidgetRange : this.startSide <= 0 ? Ni.WidgetBefore : Ni.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof oc && XX(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
oc.prototype.point = !0;
function pM(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: n } = t;
  return r == null && (r = t.inclusive), n == null && (n = t.inclusive), { start: r ?? e, end: n ?? e };
}
function XX(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Fy(t, e, r, n = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + n >= t ? r[i] = Math.max(r[i], e) : r.push(t, e);
}
class vn extends _r {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, n, i, o, s) {
    if (n) {
      if (!(n instanceof vn))
        return !1;
      this.dom || n.transferDOM(this);
    }
    return i && this.setDeco(n ? n.attrs : null), cM(this, e, r, n ? n.children.slice() : [], o, s), !0;
  }
  split(e) {
    let r = new vn();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i: n, off: i } = this.childPos(e);
    i && (r.append(this.children[n].split(i), 0), this.children[n].merge(i, this.children[n].length, null, !1, 0, 0), n++);
    for (let o = n; o < this.children.length; o++)
      r.append(this.children[o], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    u1(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    fM(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, n = e.spec.class;
    r && (this.attrs = $3(r, this.attrs || {})), n && (this.attrs = $3({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return hM(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var n;
    this.dom ? this.flags & 4 && (iM(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (I3(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && _r.get(i) instanceof Jl; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((n = _r.get(i)) === null || n === void 0 ? void 0 : n.isEditable) == !1 && (!Ie.ios || !this.children.some((o) => o instanceof Xs))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let n of this.children) {
      if (!(n instanceof Xs) || /[^ -~]/.test(n.text))
        return null;
      let i = Jm(n.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, r = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let n = dM(this, e, r);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, o = n.bottom - n.top;
      if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
        let s = (o - i.textHeight) / 2;
        return { top: n.top + s, bottom: n.bottom - s, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return e instanceof vn && this.children.length == 0 && e.children.length == 0 && u1(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let n = 0, i = 0; n < e.children.length; n++) {
      let o = e.children[n], s = i + o.length;
      if (s >= r) {
        if (o instanceof vn)
          return o;
        if (s > r)
          break;
      }
      i = s + o.breakAfter;
    }
    return null;
  }
}
class Hl extends _r {
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.deco = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, n, i, o, s) {
    return n && (!(n instanceof Hl) || !this.widget.compare(n.widget) || e > 0 && o <= 0 || r < this.length && s <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? ni.before(this.dom) : ni.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let n = new Hl(this.widget, r, this.deco);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return e4;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ir.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Hl && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r) || (this.widget instanceof B3 ? null : Rb(this.dom.getBoundingClientRect(), this.length ? e == 0 : r <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: n } = this.deco;
    return r == n ? !1 : e < 0 ? r < 0 : n > 0;
  }
}
class B3 extends Bh {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Dm {
  constructor(e, r, n, i) {
    this.doc = e, this.pos = r, this.end = n, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Hl && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new vn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Sv(new xd(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Hl) && this.getLine();
  }
  buildText(e, r, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: a, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(this.text.length - this.textOff, e), o = Math.min(
        i,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - n)), this.getLine().append(Sv(new Xs(this.text.slice(this.textOff, this.textOff + o)), r), n), this.atCursorPos = !0, this.textOff += o, e -= o, n = i <= o ? 0 : r.length;
    }
  }
  span(e, r, n, i) {
    this.buildText(r - e, n, i), this.pos = r, this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, n, i, o, s) {
    if (this.disallowBlockEffectsFor[s] && n instanceof oc) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = r - e;
    if (n instanceof oc)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Hl(n.widget || wd.block, a, n));
      else {
        let l = Pu.create(n.widget || wd.inline, a, a ? 0 : n.startSide), u = this.atCursorPos && !l.isEditable && o <= i.length && (e < r || n.startSide > 0), c = !l.isEditable && (e < r || o > i.length || n.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), u && (h.append(Sv(new xd(1), i), o), o = i.length + Math.max(0, o - i.length)), h.append(Sv(l, i), o), this.atCursorPos = c, this.pendingBuffer = c ? e < r || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, r, n, i, o) {
    let s = new Dm(e, r, n, o);
    return s.openEnd = hr.spans(i, r, n, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function Sv(t, e) {
  for (let r of e)
    t = new Jl(r, [t], t.length);
  return t;
}
class wd extends Bh {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
wd.inline = /* @__PURE__ */ new wd("span");
wd.block = /* @__PURE__ */ new wd("div");
var Ir = /* @__PURE__ */ (function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
})(Ir || (Ir = {}));
const kh = Ir.LTR, t4 = Ir.RTL;
function mM(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const JX = /* @__PURE__ */ mM("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), YX = /* @__PURE__ */ mM("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), L3 = /* @__PURE__ */ Object.create(null), da = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  L3[e] = r, L3[r] = -e;
}
function gM(t) {
  return t <= 247 ? JX[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? YX[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const ZX = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ru {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? t4 : kh;
  }
  /**
  @internal
  */
  constructor(e, r, n) {
    this.from = e, this.to = r, this.level = n;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, n, i) {
    let o = -1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      if (a.from <= r && a.to >= r) {
        if (a.level == n)
          return s;
        (o < 0 || (i != 0 ? i < 0 ? a.from < r : a.to > r : e[o].level > a.level)) && (o = s);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function vM(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], i = e[r];
    if (n.from != i.from || n.to != i.to || n.direction != i.direction || !vM(n.inner, i.inner))
      return !1;
  }
  return !0;
}
const Dr = [];
function eJ(t, e, r, n, i) {
  for (let o = 0; o <= n.length; o++) {
    let s = o ? n[o - 1].to : e, a = o < n.length ? n[o].from : r, l = o ? 256 : i;
    for (let u = s, c = l, h = l; u < a; u++) {
      let d = gM(t.charCodeAt(u));
      d == 512 ? d = c : d == 8 && h == 4 && (d = 16), Dr[u] = d == 4 ? 2 : d, d & 7 && (h = d), c = d;
    }
    for (let u = s, c = l, h = l; u < a; u++) {
      let d = Dr[u];
      if (d == 128)
        u < a - 1 && c == Dr[u + 1] && c & 24 ? d = Dr[u] = c : Dr[u] = 256;
      else if (d == 64) {
        let p = u + 1;
        for (; p < a && Dr[p] == 64; )
          p++;
        let g = u && c == 8 || p < r && Dr[p] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let v = u; v < p; v++)
          Dr[v] = g;
        u = p - 1;
      } else d == 8 && h == 1 && (Dr[u] = 1);
      c = d, d & 7 && (h = d);
    }
  }
}
function tJ(t, e, r, n, i) {
  let o = i == 1 ? 2 : 1;
  for (let s = 0, a = 0, l = 0; s <= n.length; s++) {
    let u = s ? n[s - 1].to : e, c = s < n.length ? n[s].from : r;
    for (let h = u, d, p, g; h < c; h++)
      if (p = L3[d = t.charCodeAt(h)])
        if (p < 0) {
          for (let v = a - 3; v >= 0; v -= 3)
            if (da[v + 1] == -p) {
              let y = da[v + 2], b = y & 2 ? i : y & 4 ? y & 1 ? o : i : 0;
              b && (Dr[h] = Dr[da[v]] = b), a = v;
              break;
            }
        } else {
          if (da.length == 189)
            break;
          da[a++] = h, da[a++] = d, da[a++] = l;
        }
      else if ((g = Dr[h]) == 2 || g == 1) {
        let v = g == i;
        l = v ? 0 : 1;
        for (let y = a - 3; y >= 0; y -= 3) {
          let b = da[y + 2];
          if (b & 2)
            break;
          if (v)
            da[y + 2] |= 2;
          else {
            if (b & 4)
              break;
            da[y + 2] |= 4;
          }
        }
      }
  }
}
function rJ(t, e, r, n) {
  for (let i = 0, o = n; i <= r.length; i++) {
    let s = i ? r[i - 1].to : t, a = i < r.length ? r[i].from : e;
    for (let l = s; l < a; ) {
      let u = Dr[l];
      if (u == 256) {
        let c = l + 1;
        for (; ; )
          if (c == a) {
            if (i == r.length)
              break;
            c = r[i++].to, a = i < r.length ? r[i].from : e;
          } else if (Dr[c] == 256)
            c++;
          else
            break;
        let h = o == 1, d = (c < e ? Dr[c] : n) == 1, p = h == d ? h ? 1 : 2 : n;
        for (let g = c, v = i, y = v ? r[v - 1].to : t; g > l; )
          g == y && (g = r[--v].from, y = v ? r[v - 1].to : t), Dr[--g] = p;
        l = c;
      } else
        o = u, l++;
    }
  }
}
function z3(t, e, r, n, i, o, s) {
  let a = n % 2 ? 2 : 1;
  if (n % 2 == i % 2)
    for (let l = e, u = 0; l < r; ) {
      let c = !0, h = !1;
      if (u == o.length || l < o[u].from) {
        let v = Dr[l];
        v != a && (c = !1, h = v == 16);
      }
      let d = !c && a == 1 ? [] : null, p = c ? n : n + 1, g = l;
      e: for (; ; )
        if (u < o.length && g == o[u].from) {
          if (h)
            break e;
          let v = o[u];
          if (!c)
            for (let y = v.to, b = u + 1; ; ) {
              if (y == r)
                break e;
              if (b < o.length && o[b].from == y)
                y = o[b++].to;
              else {
                if (Dr[y] == a)
                  break e;
                break;
              }
            }
          if (u++, d)
            d.push(v);
          else {
            v.from > l && s.push(new Ru(l, v.from, p));
            let y = v.direction == kh != !(p % 2);
            j3(t, y ? n + 1 : n, i, v.inner, v.from, v.to, s), l = v.to;
          }
          g = v.to;
        } else {
          if (g == r || (c ? Dr[g] != a : Dr[g] == a))
            break;
          g++;
        }
      d ? z3(t, l, g, n + 1, i, d, s) : l < g && s.push(new Ru(l, g, p)), l = g;
    }
  else
    for (let l = r, u = o.length; l > e; ) {
      let c = !0, h = !1;
      if (!u || l > o[u - 1].to) {
        let v = Dr[l - 1];
        v != a && (c = !1, h = v == 16);
      }
      let d = !c && a == 1 ? [] : null, p = c ? n : n + 1, g = l;
      e: for (; ; )
        if (u && g == o[u - 1].to) {
          if (h)
            break e;
          let v = o[--u];
          if (!c)
            for (let y = v.from, b = u; ; ) {
              if (y == e)
                break e;
              if (b && o[b - 1].to == y)
                y = o[--b].from;
              else {
                if (Dr[y - 1] == a)
                  break e;
                break;
              }
            }
          if (d)
            d.push(v);
          else {
            v.to < l && s.push(new Ru(v.to, l, p));
            let y = v.direction == kh != !(p % 2);
            j3(t, y ? n + 1 : n, i, v.inner, v.from, v.to, s), l = v.from;
          }
          g = v.from;
        } else {
          if (g == e || (c ? Dr[g - 1] != a : Dr[g - 1] == a))
            break;
          g--;
        }
      d ? z3(t, g, l, n + 1, i, d, s) : g < l && s.push(new Ru(g, l, p)), l = g;
    }
}
function j3(t, e, r, n, i, o, s) {
  let a = e % 2 ? 2 : 1;
  eJ(t, i, o, n, a), tJ(t, i, o, n, a), rJ(i, o, n, a), z3(t, i, o, e, r, n, s);
}
function nJ(t, e, r) {
  if (!t)
    return [new Ru(0, 0, e == t4 ? 1 : 0)];
  if (e == kh && !r.length && !ZX.test(t))
    return yM(t.length);
  if (r.length)
    for (; t.length > Dr.length; )
      Dr[Dr.length] = 256;
  let n = [], i = e == kh ? 0 : 1;
  return j3(t, i, i, r, 0, t.length, n), n;
}
function yM(t) {
  return [new Ru(0, t, 0)];
}
let bM = "";
function iJ(t, e, r, n, i) {
  var o;
  let s = n.head - t.from, a = Ru.find(e, s, (o = n.bidiLevel) !== null && o !== void 0 ? o : -1, n.assoc), l = e[a], u = l.side(i, r);
  if (s == u) {
    let d = a += i ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    l = e[a = d], s = l.side(!i, r), u = l.side(i, r);
  }
  let c = Qn(t.text, s, l.forward(i, r));
  (c < l.from || c > l.to) && (c = u), bM = t.text.slice(Math.min(s, c), Math.max(s, c));
  let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return h && c == u && h.level + (i ? 0 : 1) < l.level ? de.cursor(h.side(!i, r) + t.from, h.forward(i, r) ? 1 : -1, h.level) : de.cursor(c + t.from, l.forward(i, r) ? -1 : 1, l.level);
}
function oJ(t, e, r) {
  for (let n = e; n < r; n++) {
    let i = gM(t.charCodeAt(n));
    if (i == 1)
      return kh;
    if (i == 2 || i == 4)
      return t4;
  }
  return kh;
}
const xM = /* @__PURE__ */ Le.define(), wM = /* @__PURE__ */ Le.define(), kM = /* @__PURE__ */ Le.define(), CM = /* @__PURE__ */ Le.define(), q3 = /* @__PURE__ */ Le.define(), _M = /* @__PURE__ */ Le.define(), SM = /* @__PURE__ */ Le.define(), r4 = /* @__PURE__ */ Le.define(), n4 = /* @__PURE__ */ Le.define(), AM = /* @__PURE__ */ Le.define({
  combine: (t) => t.some((e) => e)
}), EM = /* @__PURE__ */ Le.define({
  combine: (t) => t.some((e) => e)
}), DM = /* @__PURE__ */ Le.define();
class Vf {
  constructor(e, r = "nearest", n = "nearest", i = 5, o = 5, s = !1) {
    this.range = e, this.y = r, this.x = n, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
  }
  map(e) {
    return e.empty ? this : new Vf(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Vf(de.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Av = /* @__PURE__ */ _t.define({ map: (t, e) => t.map(e) }), OM = /* @__PURE__ */ _t.define();
function Pi(t, e, r) {
  let n = t.facet(CM);
  n.length ? n[0](e) : window.onerror && window.onerror(String(e), r, void 0, void 0, e) || (r ? console.error(r + ":", e) : console.error(e));
}
const Rl = /* @__PURE__ */ Le.define({ combine: (t) => t.length ? t[0] : !0 });
let sJ = 0;
const Ff = /* @__PURE__ */ Le.define({
  combine(t) {
    return t.filter((e, r) => {
      for (let n = 0; n < r; n++)
        if (t[n].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class wn {
  constructor(e, r, n, i, o) {
    this.id = e, this.create = r, this.domEventHandlers = n, this.domEventObservers = i, this.baseExtensions = o(this), this.extension = this.baseExtensions.concat(Ff.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(Ff.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: n, eventObservers: i, provide: o, decorations: s } = r || {};
    return new wn(sJ++, e, n, i, (a) => {
      let l = [];
      return s && l.push(Ym.of((u) => {
        let c = u.plugin(a);
        return c ? s(c) : pt.none;
      })), o && l.push(o(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return wn.define((n, i) => new e(n, i), r);
  }
}
class x2 {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (n) {
            if (Pi(r.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (r) {
        Pi(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        Pi(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const FM = /* @__PURE__ */ Le.define(), i4 = /* @__PURE__ */ Le.define(), Ym = /* @__PURE__ */ Le.define(), TM = /* @__PURE__ */ Le.define(), Jg = /* @__PURE__ */ Le.define(), MM = /* @__PURE__ */ Le.define();
function qD(t, e) {
  let r = t.state.facet(MM);
  if (!r.length)
    return r;
  let n = r.map((o) => o instanceof Function ? o(t) : o), i = [];
  return hr.spans(n, e.from, e.to, {
    point() {
    },
    span(o, s, a, l) {
      let u = o - e.from, c = s - e.from, h = i;
      for (let d = a.length - 1; d >= 0; d--, l--) {
        let p = a[d].spec.bidiIsolate, g;
        if (p == null && (p = oJ(e.text, u, c)), l > 0 && h.length && (g = h[h.length - 1]).to == u && g.direction == p)
          g.to = c, h = g.inner;
        else {
          let v = { from: u, to: c, direction: p, inner: [] };
          h.push(v), h = v.inner;
        }
      }
    }
  }), i;
}
const PM = /* @__PURE__ */ Le.define();
function o4(t) {
  let e = 0, r = 0, n = 0, i = 0;
  for (let o of t.state.facet(PM)) {
    let s = o(t);
    s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (r = Math.max(r, s.right)), s.top != null && (n = Math.max(n, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
  }
  return { left: e, right: r, top: n, bottom: i };
}
const fm = /* @__PURE__ */ Le.define();
class gs {
  constructor(e, r, n, i) {
    this.fromA = e, this.toA = r, this.fromB = n, this.toB = i;
  }
  join(e) {
    return new gs(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, n = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > n.toA)) {
        if (i.toA < n.fromA)
          break;
        n = n.join(i), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, n), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let n = [];
    for (let i = 0, o = 0, s = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i], u = s - a, c = l ? l.fromB : 1e9;
      for (; o < r.length && r[o] < c; ) {
        let h = r[o], d = r[o + 1], p = Math.max(a, h), g = Math.min(c, d);
        if (p <= g && new gs(p + u, g + u, p, g).addToSet(n), d > c)
          break;
        o += 2;
      }
      if (!l)
        return n;
      new gs(l.fromA, l.toA, l.fromB, l.toB).addToSet(n), s = l.toA, a = l.toB;
    }
  }
}
class c1 {
  constructor(e, r, n) {
    this.view = e, this.state = r, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = En.empty(this.startState.doc.length);
    for (let o of n)
      this.changes = this.changes.compose(o.changes);
    let i = [];
    this.changes.iterChangedRanges((o, s, a, l) => i.push(new gs(o, s, a, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new c1(e, r, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class UD extends _r {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = pt.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new vn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new gs(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let n = e.changedRanges;
    this.minWidth > 0 && n.length && (n.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? i = this.domChanged.newSel.head : !dJ(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let o = i > -1 ? lJ(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      n = new gs(u, c, e.changes.mapPos(u, -1), e.changes.mapPos(c, 1)).addToSet(n.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (Ie.ie || Ie.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let s = this.decorations, a = this.updateDeco(), l = hJ(s, a, e.changes);
    return n = gs.extendWithRanges(n, l), !(this.flags & 7) && n.length == 0 ? !1 : (this.updateInner(n, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, n) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, n);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = Ie.chrome || Ie.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s), this.flags &= -8, s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s) => s.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof Hl && s.widget instanceof B3 && o.push(s.dom);
    i.updateGaps(o);
  }
  updateChildren(e, r, n) {
    let i = n ? n.range.addToSet(e.slice()) : e, o = this.childCursor(r);
    for (let s = i.length - 1; ; s--) {
      let a = s >= 0 ? i[s] : null;
      if (!a)
        break;
      let { fromA: l, toA: u, fromB: c, toB: h } = a, d, p, g, v;
      if (n && n.range.fromB < h && n.range.toB > c) {
        let S = Dm.build(this.view.state.doc, c, n.range.fromB, this.decorations, this.dynamicDecorationMap), _ = Dm.build(this.view.state.doc, n.range.toB, h, this.decorations, this.dynamicDecorationMap);
        p = S.breakAtStart, g = S.openStart, v = _.openEnd;
        let D = this.compositionView(n);
        _.breakAtStart ? D.breakAfter = 1 : _.content.length && D.merge(D.length, D.length, _.content[0], !1, _.openStart, 0) && (D.breakAfter = _.content[0].breakAfter, _.content.shift()), S.content.length && D.merge(0, 0, S.content[S.content.length - 1], !0, 0, S.openEnd) && S.content.pop(), d = S.content.concat(D).concat(_.content);
      } else
        ({ content: d, breakAtStart: p, openStart: g, openEnd: v } = Dm.build(this.view.state.doc, c, h, this.decorations, this.dynamicDecorationMap));
      let { i: y, off: b } = o.findPos(u, 1), { i: k, off: C } = o.findPos(l, -1);
      uM(this, k, C, y, b, d, p, g, v);
    }
    n && this.fixCompositionDOM(n);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(OM) && (this.editContextFormatting = n.value);
  }
  compositionView(e) {
    let r = new Xs(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks)
      r = new Jl(i, [r], r.length);
    let n = new vn();
    return n.append(r, 0), n;
  }
  fixCompositionDOM(e) {
    let r = (o, s) => {
      s.flags |= 8 | (s.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s);
      let a = _r.get(o);
      a && a != s && (a.dom = null), s.setDOM(o);
    }, n = this.childPos(e.range.fromB, 1), i = this.children[n.i];
    r(e.line, i);
    for (let o = e.marks.length - 1; o >= -1; o--)
      n = i.childPos(n.off, 1), i = i.children[n.i], r(o >= 0 ? e.marks[o].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement, i = n == this.dom, o = !i && !(this.view.state.facet(Rl) || this.dom.tabIndex > -1) && Oy(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(i || r || o))
      return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), u = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (Ie.gecko && a.empty && !this.hasComposition && aJ(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = u = new ni(h, 0), s = !0;
    }
    let c = this.view.observer.selectionRange;
    (s || !c.focusNode || (!Em(l.node, l.offset, c.anchorNode, c.anchorOffset) || !Em(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, a)) && (this.view.observer.ignore(() => {
      Ie.android && Ie.chrome && this.dom.contains(c.focusNode) && fJ(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Xm(this.view.root);
      if (h) if (a.empty) {
        if (Ie.gecko) {
          let d = uJ(l.node, l.offset);
          if (d && d != 3) {
            let p = (d == 1 ? sM : aM)(l.node, l.offset);
            p && (l = new ni(p.node, p.offset));
          }
        }
        h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
      } else if (h.extend) {
        h.collapse(l.node, l.offset);
        try {
          h.extend(u.node, u.offset);
        } catch {
        }
      } else {
        let d = document.createRange();
        a.anchor > a.head && ([l, u] = [u, l]), d.setEnd(u.node, u.offset), d.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(d);
      }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new ni(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new ni(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Em(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, n = Xm(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
    if (!n || !r.empty || !r.assoc || !n.modify)
      return;
    let s = vn.find(this, r.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (r.head == a || r.head == a + s.length)
      return;
    let l = this.coordsAt(r.head, -1), u = this.coordsAt(r.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let c = this.domAtPos(r.head + r.assoc);
    n.collapse(c.node, c.offset), n.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != r.from && n.collapse(i, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, n;
    if (e.node != r)
      return e;
    for (let i = e.offset; !n && i < r.childNodes.length; i++) {
      let o = _r.get(r.childNodes[i]);
      o instanceof vn && (n = o.domAtPos(0));
    }
    for (let i = e.offset - 1; !n && i >= 0; i--) {
      let o = _r.get(r.childNodes[i]);
      o instanceof vn && (n = o.domAtPos(o.length));
    }
    return n ? new ni(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let n = _r.get(r);
      if (n && n.rootView == this)
        return n;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, r) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: n } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (n < i.length || i instanceof vn)
        break;
      r++, n = 0;
    }
    return this.children[r].domAtPos(n);
  }
  coordsAt(e, r) {
    let n = null, i = 0;
    for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
      let a = this.children[s], l = o - a.breakAfter, u = l - a.length;
      if (l < e)
        break;
      if (u <= e && (u < e || a.covers(-1)) && (l > e || a.covers(1)) && (!n || a instanceof vn && !(n instanceof vn && r >= 0)))
        n = a, i = u;
      else if (n && u == e && l == e && a instanceof Hl && Math.abs(r) < 2) {
        if (a.deco.startSide < 0)
          break;
        s && (n = null);
      }
      o = u;
    }
    return n ? n.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: n } = this.childPos(e, 1), i = this.children[r];
    if (!(i instanceof vn))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(n, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      n = l;
    }
    if (!(i instanceof Xs))
      return null;
    let o = Qn(i.text, n);
    if (o == n)
      return null;
    let s = wh(i.dom, n, o).getClientRects();
    for (let a = 0; a < s.length; a++) {
      let l = s[a];
      if (a == s.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: n, to: i } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == Ir.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let h = this.children[c], d = u + h.length;
      if (d > i)
        break;
      if (u >= n) {
        let p = h.dom.getBoundingClientRect();
        if (r.push(p.height), s) {
          let g = h.dom.lastChild, v = g ? Jm(g) : [];
          if (v.length) {
            let y = v[v.length - 1], b = l ? y.right - p.left : p.right - y.left;
            b > a && (a = b, this.minWidth = o, this.minWidthFrom = u, this.minWidthTo = d);
          }
        }
      }
      u = d + h.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? Ir.RTL : Ir.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof vn) {
        let s = o.measureTextSize();
        if (s)
          return s;
      }
    let e = document.createElement("div"), r, n, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let o = Jm(e.firstChild)[0];
      r = e.getBoundingClientRect().height, n = o ? o.width / 27 : 7, i = o ? o.height : r, e.remove();
    }), { lineHeight: r, charWidth: n, textHeight: i };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new lM(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let n = 0, i = 0; ; i++) {
      let o = i == r.viewports.length ? null : r.viewports[i], s = o ? o.from - 1 : this.length;
      if (s > n) {
        let a = (r.lineBlockAt(s).bottom - r.lineBlockAt(n).top) / this.view.scaleY;
        e.push(pt.replace({
          widget: new B3(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(n, s));
      }
      if (!o)
        break;
      n = o.to + 1;
    }
    return pt.set(e);
  }
  updateDeco() {
    let e = 1, r = this.view.state.facet(Ym).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), n = !1, i = this.view.state.facet(TM).map((o, s) => {
      let a = typeof o == "function";
      return a && (n = !0), a ? o(this.view) : o;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = n, r.push(hr.join(i))), this.decorations = [
      this.editContextFormatting,
      ...r,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = u.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let u of this.view.state.facet(DM))
      try {
        if (u(this.view, e.range, e))
          return !0;
      } catch (c) {
        Pi(this.view.state, c, "scroll handler");
      }
    let { range: r } = e, n = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), i;
    if (!n)
      return;
    !r.empty && (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, i.left),
      top: Math.min(n.top, i.top),
      right: Math.max(n.right, i.right),
      bottom: Math.max(n.bottom, i.bottom)
    });
    let o = o4(this.view), s = {
      left: n.left - o.left,
      top: n.top - o.top,
      right: n.right + o.right,
      bottom: n.bottom + o.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    zX(this.view.scrollDOM, s, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Ir.LTR);
  }
}
function aJ(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
function RM(t, e) {
  let r = t.observer.selectionRange;
  if (!r.focusNode)
    return null;
  let n = sM(r.focusNode, r.focusOffset), i = aM(r.focusNode, r.focusOffset), o = n || i;
  if (i && n && i.node != n.node) {
    let a = _r.get(i.node);
    if (!a || a instanceof Xs && a.text != i.node.nodeValue)
      o = i;
    else if (t.docView.lastCompositionAfterCursor) {
      let l = _r.get(n.node);
      !l || l instanceof Xs && l.text != n.node.nodeValue || (o = i);
    }
  }
  if (t.docView.lastCompositionAfterCursor = o != n, !o)
    return null;
  let s = e - o.offset;
  return { from: s, to: s + o.node.nodeValue.length, node: o.node };
}
function lJ(t, e, r) {
  let n = RM(t, r);
  if (!n)
    return null;
  let { node: i, from: o, to: s } = n, a = i.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(n.from, n.to) != a)
    return null;
  let l = e.invertedDesc, u = new gs(l.mapPos(o), l.mapPos(s), o, s), c = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let d = _r.get(h);
    if (d instanceof Jl)
      c.push({ node: h, deco: d.mark });
    else {
      if (d instanceof vn || h.nodeName == "DIV" && h.parentNode == t.contentDOM)
        return { range: u, text: i, marks: c, line: h };
      if (h != t.contentDOM)
        c.push({ node: h, deco: new Qg({
          inclusive: !0,
          attributes: QX(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function uJ(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let cJ = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    Fy(t, e, this.changes);
  }
  comparePoint(t, e) {
    Fy(t, e, this.changes);
  }
  boundChange(t) {
    Fy(t, t, this.changes);
  }
};
function hJ(t, e, r) {
  let n = new cJ();
  return hr.compare(t, e, r, n), n.changes;
}
function fJ(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function dJ(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((n, i) => {
    n < e.to && i > e.from && (r = !0);
  }), r;
}
function pJ(t, e, r = 1) {
  let n = t.charCategorizer(e), i = t.doc.lineAt(e), o = e - i.from;
  if (i.length == 0)
    return de.cursor(e);
  o == 0 ? r = 1 : o == i.length && (r = -1);
  let s = o, a = o;
  r < 0 ? s = Qn(i.text, o, !1) : a = Qn(i.text, o);
  let l = n(i.text.slice(s, a));
  for (; s > 0; ) {
    let u = Qn(i.text, s, !1);
    if (n(i.text.slice(u, s)) != l)
      break;
    s = u;
  }
  for (; a < i.length; ) {
    let u = Qn(i.text, a);
    if (n(i.text.slice(a, u)) != l)
      break;
    a = u;
  }
  return de.range(s + i.from, a + i.from);
}
function mJ(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function gJ(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function w2(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function HD(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function VD(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function U3(t, e, r) {
  let n, i, o, s, a = !1, l, u, c, h;
  for (let g = t.firstChild; g; g = g.nextSibling) {
    let v = Jm(g);
    for (let y = 0; y < v.length; y++) {
      let b = v[y];
      i && w2(i, b) && (b = HD(VD(b, i.bottom), i.top));
      let k = mJ(e, b), C = gJ(r, b);
      if (k == 0 && C == 0)
        return g.nodeType == 3 ? WD(g, e, r) : U3(g, e, r);
      (!n || s > C || s == C && o > k) && (n = g, i = b, o = k, s = C, a = k ? e < b.left ? y > 0 : y < v.length - 1 : !0), k == 0 ? r > b.bottom && (!c || c.bottom < b.bottom) ? (l = g, c = b) : r < b.top && (!h || h.top > b.top) && (u = g, h = b) : c && w2(c, b) ? c = VD(c, b.bottom) : h && w2(h, b) && (h = HD(h, b.top));
    }
  }
  if (c && c.bottom >= r ? (n = l, i = c) : h && h.top <= r && (n = u, i = h), !n)
    return { node: t, offset: 0 };
  let d = Math.max(i.left, Math.min(i.right, e));
  if (n.nodeType == 3)
    return WD(n, d, r);
  if (a && n.contentEditable != "false")
    return U3(n, d, r);
  let p = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: p };
}
function WD(t, e, r) {
  let n = t.nodeValue.length, i = -1, o = 1e9, s = 0;
  for (let a = 0; a < n; a++) {
    let l = wh(t, a, a + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let c = l[u];
      if (c.top == c.bottom)
        continue;
      s || (s = e - c.left);
      let h = (c.top > r ? c.top - r : r - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && h < o) {
        let d = e >= (c.left + c.right) / 2, p = d;
        if ((Ie.chrome || Ie.gecko) && wh(t, a).getBoundingClientRect().left == c.right && (p = !d), h <= 0)
          return { node: t, offset: a + (p ? 1 : 0) };
        i = a + (p ? 1 : 0), o = h;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : s > 0 ? t.nodeValue.length : 0 };
}
function NM(t, e, r, n = -1) {
  var i, o;
  let s = t.contentDOM.getBoundingClientRect(), a = s.top + t.viewState.paddingTop, l, { docHeight: u } = t.viewState, { x: c, y: h } = e, d = h - a;
  if (d < 0)
    return 0;
  if (d > u)
    return t.state.doc.length;
  for (let S = t.viewState.heightOracle.textHeight / 2, _ = !1; l = t.elementAtHeight(d), l.type != Ni.Text; )
    for (; d = n > 0 ? l.bottom + S : l.top - S, !(d >= 0 && d <= u); ) {
      if (_)
        return r ? null : 0;
      _ = !0, n = -n;
    }
  h = a + d;
  let p = l.from;
  if (p < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : GD(t, s, l, c, h);
  if (p > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : GD(t, s, l, c, h);
  let g = t.dom.ownerDocument, v = t.root.elementFromPoint ? t.root : g, y = v.elementFromPoint(c, h);
  y && !t.contentDOM.contains(y) && (y = null), y || (c = Math.max(s.left + 1, Math.min(s.right - 1, c)), y = v.elementFromPoint(c, h), y && !t.contentDOM.contains(y) && (y = null));
  let b, k = -1;
  if (y && ((i = t.docView.nearest(y)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (g.caretPositionFromPoint) {
      let S = g.caretPositionFromPoint(c, h);
      S && ({ offsetNode: b, offset: k } = S);
    } else if (g.caretRangeFromPoint) {
      let S = g.caretRangeFromPoint(c, h);
      S && ({ startContainer: b, startOffset: k } = S);
    }
    b && (!t.contentDOM.contains(b) || Ie.safari && vJ(b, k, c) || Ie.chrome && yJ(b, k, c)) && (b = void 0), b && (k = Math.min(Xa(b), k));
  }
  if (!b || !t.docView.dom.contains(b)) {
    let S = vn.find(t.docView, p);
    if (!S)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: b, offset: k } = U3(S.dom, c, h));
  }
  let C = t.docView.nearest(b);
  if (!C)
    return null;
  if (C.isWidget && ((o = C.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let S = C.dom.getBoundingClientRect();
    return e.y < S.top || e.y <= S.bottom && e.x <= (S.left + S.right) / 2 ? C.posAtStart : C.posAtEnd;
  } else
    return C.localPosFromDOM(b, k) + C.posAtStart;
}
function GD(t, e, r, n, i) {
  let o = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - r.top - (t.defaultLineHeight - a) * 0.5) / a);
    o += l * t.viewState.heightOracle.lineLength;
  }
  let s = t.state.sliceDoc(r.from, r.to);
  return r.from + D3(s, o, t.state.tabSize);
}
function $M(t, e, r) {
  let n, i = t;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length))
    return !1;
  for (; ; ) {
    let o = i.nextSibling;
    if (o) {
      if (o.nodeName == "BR")
        break;
      return !1;
    } else {
      let s = i.parentNode;
      if (!s || s.nodeName == "DIV")
        break;
      i = s;
    }
  }
  return wh(t, n - 1, n).getBoundingClientRect().right > r;
}
function vJ(t, e, r) {
  return $M(t, e, r);
}
function yJ(t, e, r) {
  if (e != 0)
    return $M(t, e, r);
  for (let i = t; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    i = o;
  }
  let n = t.nodeType == 1 ? t.getBoundingClientRect() : wh(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - n.left > 5;
}
function H3(t, e, r) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    let i;
    for (let o of n.type) {
      if (o.from > e)
        break;
      if (!(o.to < e)) {
        if (o.from < e && o.to > e)
          return o;
        (!i || o.type == Ni.Text && (i.type != o.type || (r < 0 ? o.from < e : o.to > e))) && (i = o);
      }
    }
    return i || n;
  }
  return n;
}
function bJ(t, e, r, n) {
  let i = H3(t, e.head, e.assoc || -1), o = !n || i.type != Ni.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (o) {
    let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({
      x: r == (a == Ir.LTR) ? s.right - 1 : s.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (l != null)
      return de.cursor(l, r ? -1 : 1);
  }
  return de.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function KD(t, e, r, n) {
  let i = t.state.doc.lineAt(e.head), o = t.bidiSpans(i), s = t.textDirectionAt(i.from);
  for (let a = e, l = null; ; ) {
    let u = iJ(i, o, s, a, r), c = bM;
    if (!u) {
      if (i.number == (r ? t.state.doc.lines : 1))
        return a;
      c = `
`, i = t.state.doc.line(i.number + (r ? 1 : -1)), o = t.bidiSpans(i), u = t.visualLineSide(i, !r);
    }
    if (l) {
      if (!l(c))
        return a;
    } else {
      if (!n)
        return u;
      l = n(c);
    }
    a = u;
  }
}
function xJ(t, e, r) {
  let n = t.state.charCategorizer(e), i = n(r);
  return (o) => {
    let s = n(o);
    return i == Hr.Space && (i = s), i == s;
  };
}
function wJ(t, e, r, n) {
  let i = e.head, o = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0))
    return de.cursor(i, e.assoc);
  let s = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), u = t.coordsAtPos(i, e.assoc || -1), c = t.documentTop;
  if (u)
    s == null && (s = u.left - l.left), a = o < 0 ? u.top : u.bottom;
  else {
    let p = t.viewState.lineBlockAt(i);
    s == null && (s = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - p.from))), a = (o < 0 ? p.top : p.bottom) + c;
  }
  let h = l.left + s, d = n ?? t.viewState.heightOracle.textHeight >> 1;
  for (let p = 0; ; p += 10) {
    let g = a + (d + p) * o, v = NM(t, { x: h, y: g }, !1, o);
    if (g < l.top || g > l.bottom || (o < 0 ? v < i : v > i)) {
      let y = t.docView.coordsForChar(v), b = !y || g < y.top ? -1 : 1;
      return de.cursor(v, b, void 0, s);
    }
  }
}
function Om(t, e, r) {
  for (; ; ) {
    let n = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (o, s, a) => {
        if (e > o && e < s) {
          let l = n || r || (e - o < s - e ? -1 : 1);
          e = l < 0 ? o : s, n = l;
        }
      });
    if (!n)
      return e;
  }
}
function IM(t, e) {
  let r = null;
  for (let n = 0; n < e.ranges.length; n++) {
    let i = e.ranges[n], o = null;
    if (i.empty) {
      let s = Om(t, i.from, 0);
      s != i.from && (o = de.cursor(s, -1));
    } else {
      let s = Om(t, i.from, -1), a = Om(t, i.to, 1);
      (s != i.from || a != i.to) && (o = de.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
    }
    o && (r || (r = e.ranges.slice()), r[n] = o);
  }
  return r ? de.create(r, e.mainIndex) : e;
}
function k2(t, e, r) {
  let n = Om(t.state.facet(Jg).map((i) => i(t)), r.from, e.head > r.from ? -1 : 1);
  return n == r.from ? r : de.cursor(n, n < r.from ? 1 : -1);
}
const dm = "ï¿¿";
class kJ {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(nr.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += dm;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(n, i);
      let o = this.text.length;
      this.readNode(i);
      let s = i.nextSibling;
      if (s == r)
        break;
      let a = _r.get(i), l = _r.get(s);
      (a && l ? a.breakAfter : (a ? a.breakAfter : l1(i)) || l1(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && !_J(s, r) && this.lineBreak(), i = s;
    }
    return this.findPointBefore(n, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, r.length));
    for (let n = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, s = 1, a;
      if (this.lineSeparator ? (o = r.indexOf(this.lineSeparator, n), s = this.lineSeparator.length) : (a = i.exec(r)) && (o = a.index, s = a[0].length), this.append(r.slice(n, o < 0 ? r.length : o)), o < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
      n = o + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = _r.get(e), n = r && r.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let i = n.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == r && (n.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (CJ(e, n.node, n.offset) ? r : 0));
  }
}
function CJ(t, e, r) {
  for (; ; ) {
    if (!e || r < Xa(e))
      return !1;
    if (e == t)
      return !0;
    r = xh(e) + 1, e = e.parentNode;
  }
}
function _J(t, e) {
  let r;
  for (; !(t == e || !t); t = t.nextSibling) {
    let n = _r.get(t);
    if (!(n?.isWidget || t.cmIgnore))
      return !1;
    n && (r || (r = [])).push(n);
  }
  if (r) {
    for (let n of r)
      if (n.overrideDOMText?.length)
        return !1;
  }
  return !0;
}
class QD {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class SJ {
  constructor(e, r, n, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = r > -1;
    let { impreciseHead: o, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, n, 0))) {
      let a = o || s ? [] : EJ(e), l = new kJ(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = DJ(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !N3(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), u = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !N3(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), c = e.viewport;
      if ((Ie.ios || Ie.chrome) && e.state.selection.main.empty && l != u && (c.from > 0 || c.to < e.state.doc.length)) {
        let h = Math.min(l, u), d = Math.max(l, u), p = c.from - h, g = c.to - d;
        (p == 0 || p == 1 || h == 0) && (g == 0 || g == -1 || d == e.state.doc.length) && (l = 0, u = e.state.doc.length);
      }
      this.newSel = de.single(u, l);
    }
  }
}
function BM(t, e) {
  let r, { newSel: n } = e, i = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: a } = e.bounds, l = i.from, u = null;
    (o === 8 || Ie.android && e.text.length < a - s) && (l = i.to, u = "end");
    let c = LM(t.state.doc.sliceString(s, a, dm), e.text, l - s, u);
    c && (Ie.chrome && o == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == dm + dm && c.toB--, r = {
      from: s + c.from,
      to: s + c.toA,
      insert: ir.of(e.text.slice(c.from, c.toB).split(dm))
    });
  } else n && (!t.hasFocus && t.state.facet(Rl) || n.main.eq(i)) && (n = null);
  if (!r && !n)
    return !1;
  if (!r && e.typeOver && !i.empty && n && n.main.empty ? r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : (Ie.mac || Ie.android) && r && r.from == r.to && r.from == i.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (n && r.insert.length == 2 && (n = de.single(n.main.anchor - 1, n.main.head - 1)), r = { from: r.from, to: r.to, insert: ir.of([r.insert.toString().replace(".", " ")]) }) : r && r.from >= i.from && r.to <= i.to && (r.from != i.from || r.to != i.to) && i.to - i.from - (r.to - r.from) <= 4 ? r = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to))
  } : Ie.chrome && r && r.from == r.to && r.from == i.head && r.insert.toString() == `
 ` && t.lineWrapping && (n && (n = de.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: ir.of([" "]) }), r)
    return s4(t, r, n, o);
  if (n && !n.main.eq(i)) {
    let s = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = !0), a = t.inputState.lastSelectionOrigin, a == "select.pointer" && (n = IM(t.state.facet(Jg).map((l) => l(t)), n))), t.dispatch({ selection: n, scrollIntoView: s, userEvent: a }), !0;
  } else
    return !1;
}
function s4(t, e, r, n = -1) {
  if (Ie.ios && t.inputState.flushIOSKey(e))
    return !0;
  let i = t.state.selection.main;
  if (Ie.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Hf(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || n == 8 && e.insert.length < e.to - e.from && e.to > i.head) && Hf(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Hf(t.contentDOM, "Delete", 46)))
    return !0;
  let o = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let s, a = () => s || (s = AJ(t, e, r));
  return t.state.facet(_M).some((l) => l(t, e.from, e.to, o, a)) || t.dispatch(a()), !0;
}
function AJ(t, e, r) {
  let n, i = t.state, o = i.selection.main, s = -1;
  if (e.from == e.to && e.from < o.from || e.from > o.to) {
    let l = e.from < o.from ? -1 : 1, u = l < 0 ? o.from : o.to, c = Om(i.facet(Jg).map((h) => h(t)), u, l);
    e.from == c && (s = c);
  }
  if (s > -1)
    n = {
      changes: e,
      selection: de.cursor(e.from + e.insert.length, -1)
    };
  else if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let l = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", u = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
    n = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + u));
  } else {
    let l = i.changes(e), u = r && r.main.to <= l.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), h, d = r && RM(t, r.main.head);
      if (d) {
        let v = e.insert.length - (e.to - e.from);
        h = { from: d.from, to: d.to - v };
      } else
        h = t.state.doc.lineAt(o.head);
      let p = o.to - e.to, g = o.to - o.from;
      n = i.changeByRange((v) => {
        if (v.from == o.from && v.to == o.to)
          return { changes: l, range: u || v.map(l) };
        let y = v.to - p, b = y - c.length;
        if (v.to - v.from != g || t.state.sliceDoc(b, y) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        v.to >= h.from && v.from <= h.to)
          return { range: v };
        let k = i.changes({ from: b, to: y, insert: e.insert }), C = v.to - o.to;
        return {
          changes: k,
          range: u ? de.range(Math.max(0, u.anchor + C), Math.max(0, u.head + C)) : v.map(k)
        };
      });
    } else
      n = {
        changes: l,
        selection: u && i.selection.replaceRange(u)
      };
  }
  let a = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = !1)), i.update(n, { userEvent: a, scrollIntoView: !0 });
}
function LM(t, e, r, n) {
  let i = Math.min(t.length, e.length), o = 0;
  for (; o < i && t.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == i && t.length == e.length)
    return null;
  let s = t.length, a = e.length;
  for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
    s--, a--;
  if (n == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    r -= s + l - o;
  }
  if (s < o && t.length < e.length) {
    let l = r <= o && r >= s ? o - r : 0;
    o -= l, a = o + (a - s), s = o;
  } else if (a < o) {
    let l = r <= o && r >= a ? o - r : 0;
    o -= l, s = o + (s - a), a = o;
  }
  return { from: o, toA: s, toB: a };
}
function EJ(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: o } = t.observer.selectionRange;
  return r && (e.push(new QD(r, n)), (i != r || o != n) && e.push(new QD(i, o))), e;
}
function DJ(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, n = t.length == 2 ? t[1].pos : r;
  return r > -1 && n > -1 ? de.single(r + e, n + e) : null;
}
class OJ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, Ie.safari && e.contentDOM.addEventListener("input", () => null), Ie.gecko && VJ(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !IJ(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, r) {
    let n = this.handlers[e];
    if (n) {
      for (let i of n.observers)
        i(this.view, r);
      for (let i of n.handlers) {
        if (r.defaultPrevented)
          break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = FJ(e), n = this.handlers, i = this.view.contentDOM;
    for (let o in r)
      if (o != "scroll") {
        let s = !r[o].handlers.length, a = n[o];
        a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, { passive: s });
      }
    for (let o in n)
      o != "scroll" && !r[o] && i.removeEventListener(o, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && jM.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), Ie.android && Ie.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return Ie.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = zM.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || TJ.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let r = this.pendingIOSKey;
    return !r || r.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Hf(this.view.contentDOM, r.key, r.keyCode, r instanceof KeyboardEvent ? r : void 0));
  }
  ignoreDuringComposition(e) {
    return !/^key/.test(e.type) || e.synthetic ? !1 : this.composing > 0 ? !0 : Ie.safari && !Ie.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function XD(t, e) {
  return (r, n) => {
    try {
      return e.call(t, n, r);
    } catch (i) {
      Pi(r.state, i);
    }
  };
}
function FJ(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of t) {
    let i = n.spec, o = i && i.plugin.domEventHandlers, s = i && i.plugin.domEventObservers;
    if (o)
      for (let a in o) {
        let l = o[a];
        l && r(a).handlers.push(XD(n.value, l));
      }
    if (s)
      for (let a in s) {
        let l = s[a];
        l && r(a).observers.push(XD(n.value, l));
      }
  }
  for (let n in Js)
    r(n).handlers.push(Js[n]);
  for (let n in xs)
    r(n).observers.push(xs[n]);
  return e;
}
const zM = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], TJ = "dthko", jM = [16, 17, 18, 20, 91, 92, 224, 225], Ev = 6;
function Dv(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function MJ(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class PJ {
  constructor(e, r, n, i) {
    this.view = e, this.startEvent = r, this.style = n, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParents = jX(e.contentDOM), this.atoms = e.state.facet(Jg).map((s) => s(e));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(nr.allowMultipleSelections) && RJ(e, r), this.dragging = $J(e, r) && HM(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && MJ(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let r = 0, n = 0, i = 0, o = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = o4(this.view);
    e.clientX - l.left <= i + Ev ? r = -Dv(i - e.clientX) : e.clientX + l.right >= s - Ev && (r = Dv(e.clientX - s)), e.clientY - l.top <= o + Ev ? n = -Dv(o - e.clientY) : e.clientY + l.bottom >= a - Ev && (n = Dv(e.clientY - a)), this.setScrollSpeed(r, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: r } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), r && this.scrollParents.y && (this.scrollParents.y.scrollTop += r, r = 0), (e || r) && this.view.win.scrollBy(e, r), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: r } = this, n = IM(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !n.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: n,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((r) => r.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function RJ(t, e) {
  let r = t.state.facet(xM);
  return r.length ? r[0](e) : Ie.mac ? e.metaKey : e.ctrlKey;
}
function NJ(t, e) {
  let r = t.state.facet(wM);
  return r.length ? r[0](e) : Ie.mac ? !e.altKey : !e.ctrlKey;
}
function $J(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let n = Xm(t.root);
  if (!n || n.rangeCount == 0)
    return !0;
  let i = n.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let s = i[o];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function IJ(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, n; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (n = _r.get(r)) && n.ignoreEvent(e))
      return !1;
  return !0;
}
const Js = /* @__PURE__ */ Object.create(null), xs = /* @__PURE__ */ Object.create(null), qM = Ie.ie && Ie.ie_version < 15 || Ie.ios && Ie.webkit_version < 604;
function BJ(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), UM(t, r.value);
  }, 50);
}
function Nb(t, e, r) {
  for (let n of t.facet(e))
    r = n(r, t);
  return r;
}
function UM(t, e) {
  e = Nb(t.state, r4, e);
  let { state: r } = t, n, i = 1, o = r.toText(e), s = o.lines == r.selection.ranges.length;
  if (V3 != null && r.selection.ranges.every((a) => a.empty) && V3 == o.toString()) {
    let a = -1;
    n = r.changeByRange((l) => {
      let u = r.doc.lineAt(l.from);
      if (u.from == a)
        return { range: l };
      a = u.from;
      let c = r.toText((s ? o.line(i++).text : e) + r.lineBreak);
      return {
        changes: { from: u.from, insert: c },
        range: de.cursor(l.from + c.length)
      };
    });
  } else s ? n = r.changeByRange((a) => {
    let l = o.line(i++);
    return {
      changes: { from: a.from, to: a.to, insert: l.text },
      range: de.cursor(a.from + l.length)
    };
  }) : n = r.replaceSelection(o);
  t.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
xs.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
Js.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
xs.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
xs.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Js.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let n of t.state.facet(kM))
    if (r = n(t, e), r)
      break;
  if (!r && e.button == 0 && (r = jJ(t, e)), r) {
    let n = !t.hasFocus;
    t.inputState.startMouseSelection(new PJ(t, e, r, n)), n && t.observer.ignore(() => {
      nM(t.contentDOM);
      let o = t.root.activeElement;
      o && !o.contains(t.contentDOM) && o.blur();
    });
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    t.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function JD(t, e, r, n) {
  if (n == 1)
    return de.cursor(e, r);
  if (n == 2)
    return pJ(t.state, e, r);
  {
    let i = vn.find(t.docView, e), o = t.state.doc.lineAt(i ? i.posAtEnd : e), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
    return a < t.state.doc.length && a == o.to && a++, de.range(s, a);
  }
}
let YD = (t, e, r) => e >= r.top && e <= r.bottom && t >= r.left && t <= r.right;
function LJ(t, e, r, n) {
  let i = vn.find(t.docView, e);
  if (!i)
    return 1;
  let o = e - i.posAtStart;
  if (o == 0)
    return 1;
  if (o == i.length)
    return -1;
  let s = i.coordsAt(o, -1);
  if (s && YD(r, n, s))
    return -1;
  let a = i.coordsAt(o, 1);
  return a && YD(r, n, a) ? 1 : s && s.bottom >= n ? -1 : 1;
}
function ZD(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: LJ(t, r, e.clientX, e.clientY) };
}
const zJ = Ie.ie && Ie.ie_version <= 11;
let e6 = null, t6 = 0, r6 = 0;
function HM(t) {
  if (!zJ)
    return t.detail;
  let e = e6, r = r6;
  return e6 = t, r6 = Date.now(), t6 = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (t6 + 1) % 3 : 1;
}
function jJ(t, e) {
  let r = ZD(t, e), n = HM(e), i = t.state.selection;
  return {
    update(o) {
      o.docChanged && (r.pos = o.changes.mapPos(r.pos), i = i.map(o.changes));
    },
    get(o, s, a) {
      let l = ZD(t, o), u, c = JD(t, l.pos, l.bias, n);
      if (r.pos != l.pos && !s) {
        let h = JD(t, r.pos, r.bias, n), d = Math.min(h.from, c.from), p = Math.max(h.to, c.to);
        c = d < c.from ? de.range(d, p) : de.range(p, d);
      }
      return s ? i.replaceRange(i.main.extend(c.from, c.to)) : a && n == 1 && i.ranges.length > 1 && (u = qJ(i, l.pos)) ? u : a ? i.addRange(c) : de.create([c]);
    }
  };
}
function qJ(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: n, to: i } = t.ranges[r];
    if (n <= e && i >= e)
      return de.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
Js.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let o = i.posAtStart, s = o + i.length;
      (o >= r.to || s <= r.from) && (r = de.range(o, s));
    }
  }
  let { inputState: n } = t;
  return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", Nb(t.state, n4, t.state.sliceDoc(r.from, r.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Js.dragend = (t) => (t.inputState.draggedContent = null, !1);
function n6(t, e, r, n) {
  if (r = Nb(t.state, r4, r), !r)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: o } = t.inputState, s = n && o && NJ(t, e) ? { from: o.from, to: o.to } : null, a = { from: i, insert: r }, l = t.state.changes(s ? [s, a] : a);
  t.focus(), t.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
Js.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let n = Array(r.length), i = 0, o = () => {
      ++i == r.length && n6(t, e, n.filter((s) => s != null).join(t.state.lineBreak), !1);
    };
    for (let s = 0; s < r.length; s++) {
      let a = new FileReader();
      a.onerror = o, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (n[s] = a.result), o();
      }, a.readAsText(r[s]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData("Text");
    if (n)
      return n6(t, e, n, !0), !0;
  }
  return !1;
};
Js.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = qM ? null : e.clipboardData;
  return r ? (UM(t, r.getData("text/plain") || r.getData("text/uri-list")), !0) : (BJ(t), !1);
};
function UJ(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let n = r.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), t.focus();
  }, 50);
}
function HJ(t) {
  let e = [], r = [], n = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: o } of t.selection.ranges) {
      let s = t.doc.lineAt(o);
      s.number > i && (e.push(s.text), r.push({ from: s.from, to: Math.min(t.doc.length, s.to + 1) })), i = s.number;
    }
    n = !0;
  }
  return { text: Nb(t, n4, e.join(t.lineBreak)), ranges: r, linewise: n };
}
let V3 = null;
Js.copy = Js.cut = (t, e) => {
  let { text: r, ranges: n, linewise: i } = HJ(t.state);
  if (!r && !i)
    return !1;
  V3 = i ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: n,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = qM ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", r), !0) : (UJ(t, r), !1);
};
const VM = /* @__PURE__ */ nu.define();
function WM(t, e) {
  let r = [];
  for (let n of t.facet(SM)) {
    let i = n(t, e);
    i && r.push(i);
  }
  return r.length ? t.update({ effects: r, annotations: VM.of(!0) }) : null;
}
function GM(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = WM(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
xs.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), GM(t);
};
xs.blur = (t) => {
  t.observer.clearSelectionRange(), GM(t);
};
xs.compositionstart = xs.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
xs.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, Ie.chrome && Ie.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
xs.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Js.beforeinput = (t, e) => {
  var r, n;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let o = (r = e.dataTransfer) === null || r === void 0 ? void 0 : r.getData("text/plain"), s = e.getTargetRanges();
    if (o && s.length) {
      let a = s[0], l = t.posAtDOM(a.startContainer, a.startOffset), u = t.posAtDOM(a.endContainer, a.endOffset);
      return s4(t, { from: l, to: u, insert: t.state.toText(o) }, null), !0;
    }
  }
  let i;
  if (Ie.chrome && Ie.android && (i = zM.find((o) => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let o = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return Ie.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), Ie.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => xs.compositionend(t, e), 20), !1;
};
const i6 = /* @__PURE__ */ new Set();
function VJ(t) {
  i6.has(t) || (i6.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const o6 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let kd = !1;
function s6() {
  kd = !1;
}
class WJ {
  constructor(e) {
    this.lineWrapping = e, this.doc = ir.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, r) {
    let n = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((r - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return o6.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      i < 0 ? n++ : this.heightSamples[Math.floor(i * 10)] || (r = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, n, i, o, s) {
    let a = o6.indexOf(e) > -1, l = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = r, this.charWidth = n, this.textHeight = i, this.lineLength = o, l) {
      this.heightSamples = {};
      for (let u = 0; u < s.length; u++) {
        let c = s[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return l;
  }
}
class GJ {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Ea {
  /**
  @internal
  */
  constructor(e, r, n, i, o) {
    this.from = e, this.length = r, this.top = n, this.height = i, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Ni.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof oc ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Ea(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var $r = /* @__PURE__ */ (function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
})($r || ($r = {}));
const Ty = 1e-3;
class $i {
  constructor(e, r, n = 2) {
    this.length = e, this.height = r, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Ty && (kd = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, n) {
    return $i.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, n, i) {
    let o = this, s = n.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: u, fromB: c, toB: h } = i[a], d = o.lineAt(l, $r.ByPosNoHeight, n.setDoc(r), 0, 0), p = d.to >= u ? d : o.lineAt(u, $r.ByPosNoHeight, n, 0, 0);
      for (h += p.to - u, u = p.to; a > 0 && d.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, c = i[a - 1].fromB, a--, l < d.from && (d = o.lineAt(l, $r.ByPosNoHeight, n, 0, 0));
      c += d.from - l, l = d.from;
      let g = a4.build(n.setDoc(s), e, c, h);
      o = h1(o, o.replace(l, u, g));
    }
    return o.updateHeight(n, 0);
  }
  static empty() {
    return new Mo(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, n = e.length, i = 0, o = 0;
    for (; ; )
      if (r == n)
        if (i > o * 2) {
          let a = e[r - 1];
          a.break ? e.splice(--r, 1, a.left, null, a.right) : e.splice(--r, 1, a.left, a.right), n += 1 + a.break, i -= a.size;
        } else if (o > i * 2) {
          let a = e[n];
          a.break ? e.splice(n, 1, a.left, null, a.right) : e.splice(n, 1, a.left, a.right), n += 2 + a.break, o -= a.size;
        } else
          break;
      else if (i < o) {
        let a = e[r++];
        a && (i += a.size);
      } else {
        let a = e[--n];
        a && (o += a.size);
      }
    let s = 0;
    return e[r - 1] == null ? (s = 1, r--) : e[r] == null && (s = 1, n++), new KJ($i.of(e.slice(0, r)), s, $i.of(e.slice(n)));
  }
}
function h1(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (kd = !0), e);
}
$i.prototype.size = 1;
class KM extends $i {
  constructor(e, r, n) {
    super(e, r), this.deco = n;
  }
  blockAt(e, r, n, i) {
    return new Ea(i, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, r, n, i, o) {
    return this.blockAt(0, n, i, o);
  }
  forEachLine(e, r, n, i, o, s) {
    e <= o + this.length && r >= o && s(this.blockAt(0, n, i, o));
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Mo extends KM {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, n, i) {
    return new Ea(i, this.length, n, this.height, this.breaks);
  }
  replace(e, r, n) {
    let i = n[0];
    return n.length == 1 && (i instanceof Mo || i instanceof Wn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Wn ? i = new Mo(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : $i.of(n);
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more ? this.setHeight(i.heights[i.index++]) : (n || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Wn extends $i {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let n = e.doc.lineAt(r).number, i = e.doc.lineAt(r + this.length).number, o = i - n + 1, s, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * o);
      s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
    } else
      s = this.height / o;
    return { firstLine: n, lastLine: i, perLine: s, perChar: a };
  }
  blockAt(e, r, n, i) {
    let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let u = i + (e < r.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length)), c = r.doc.lineAt(u), h = a + c.length * l, d = Math.max(n, e - h / 2);
      return new Ea(c.from, c.length, d, h, 0);
    } else {
      let u = Math.max(0, Math.min(s - o, Math.floor((e - n) / a))), { from: c, length: h } = r.doc.line(o + u);
      return new Ea(c, h, n + a * u, a, 0);
    }
  }
  lineAt(e, r, n, i, o) {
    if (r == $r.ByHeight)
      return this.blockAt(e, n, i, o);
    if (r == $r.ByPosNoHeight) {
      let { from: p, to: g } = n.doc.lineAt(e);
      return new Ea(p, g - p, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(n, o), u = n.doc.lineAt(e), c = a + u.length * l, h = u.number - s, d = i + a * h + l * (u.from - o - h);
    return new Ea(u.from, u.length, Math.max(i, Math.min(d, i + this.height - c)), c, 0);
  }
  forEachLine(e, r, n, i, o, s) {
    e = Math.max(e, o), r = Math.min(r, o + this.length);
    let { firstLine: a, perLine: l, perChar: u } = this.heightMetrics(n, o);
    for (let c = e, h = i; c <= r; ) {
      let d = n.doc.lineAt(c);
      if (c == e) {
        let g = d.number - a;
        h += l * g + u * (e - o - g);
      }
      let p = l + u * d.length;
      s(new Ea(d.from, d.length, h, p, 0)), h += p, c = d.to + 1;
    }
  }
  replace(e, r, n) {
    let i = this.length - r;
    if (i > 0) {
      let o = n[n.length - 1];
      o instanceof Wn ? n[n.length - 1] = new Wn(o.length + i) : n.push(null, new Wn(i - 1));
    }
    if (e > 0) {
      let o = n[0];
      o instanceof Wn ? n[0] = new Wn(e + o.length) : n.unshift(new Wn(e - 1), null);
    }
    return $i.of(n);
  }
  decomposeLeft(e, r) {
    r.push(new Wn(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new Wn(this.length - e - 1));
  }
  updateHeight(e, r = 0, n = !1, i) {
    let o = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let s = [], a = Math.max(r, i.from), l = -1;
      for (i.from > r && s.push(new Wn(i.from - r - 1).updateHeight(e, r)); a <= o && i.more; ) {
        let c = e.doc.lineAt(a).length;
        s.length && s.push(null);
        let h = i.heights[i.index++];
        l == -1 ? l = h : Math.abs(h - l) >= Ty && (l = -2);
        let d = new Mo(c, h);
        d.outdated = !1, s.push(d), a += c + 1;
      }
      a <= o && s.push(null, new Wn(o - a).updateHeight(e, a));
      let u = $i.of(s);
      return (l < 0 || Math.abs(u.height - this.height) >= Ty || Math.abs(l - this.heightMetrics(e, r).perLine) >= Ty) && (kd = !0), h1(this, u);
    } else (n || this.outdated) && (this.setHeight(e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class KJ extends $i {
  constructor(e, r, n) {
    super(e.length + r + n.length, e.height + n.height, r | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, n, i) {
    let o = n + this.left.height;
    return e < o ? this.left.blockAt(e, r, n, i) : this.right.blockAt(e, r, o, i + this.left.length + this.break);
  }
  lineAt(e, r, n, i, o) {
    let s = i + this.left.height, a = o + this.left.length + this.break, l = r == $r.ByHeight ? e < s : e < a, u = l ? this.left.lineAt(e, r, n, i, o) : this.right.lineAt(e, r, n, s, a);
    if (this.break || (l ? u.to < a : u.from > a))
      return u;
    let c = r == $r.ByPosNoHeight ? $r.ByPosNoHeight : $r.ByPos;
    return l ? u.join(this.right.lineAt(a, c, n, s, a)) : this.left.lineAt(a, c, n, i, o).join(u);
  }
  forEachLine(e, r, n, i, o, s) {
    let a = i + this.left.height, l = o + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, r, n, i, o, s), r >= l && this.right.forEachLine(e, r, n, a, l, s);
    else {
      let u = this.lineAt(l, $r.ByPos, n, i, o);
      e < u.from && this.left.forEachLine(e, u.from - 1, n, i, o, s), u.to >= e && u.from <= r && s(u), r > u.to && this.right.forEachLine(u.to + 1, r, n, a, l, s);
    }
  }
  replace(e, r, n) {
    let i = this.left.length + this.break;
    if (r < i)
      return this.balanced(this.left.replace(e, r, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, r - i, n));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let s = o.length;
    for (let a of n)
      o.push(a);
    if (e > 0 && a6(o, s - 1), r < this.length) {
      let a = o.length;
      this.decomposeRight(r, o), a6(o, a);
    }
    return $i.of(o);
  }
  decomposeLeft(e, r) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (n++, e >= n && r.push(null)), e > n && this.right.decomposeLeft(e - n, r);
  }
  decomposeRight(e, r) {
    let n = this.left.length, i = n + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, r);
    e < n && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? $i.of(this.break ? [e, null, r] : [e, r]) : (this.left = h1(this.left, e), this.right = h1(this.right, r), this.setHeight(e.height + r.height), this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, n = !1, i) {
    let { left: o, right: s } = this, a = r + o.length + this.break, l = null;
    return i && i.from <= r + o.length && i.more ? l = o = o.updateHeight(e, r, n, i) : o.updateHeight(e, r, n), i && i.from <= a + s.length && i.more ? l = s = s.updateHeight(e, a, n, i) : s.updateHeight(e, a, n), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function a6(t, e) {
  let r, n;
  t[e] == null && (r = t[e - 1]) instanceof Wn && (n = t[e + 1]) instanceof Wn && t.splice(e - 1, 3, new Wn(r.length + 1 + n.length));
}
const QJ = 5;
class a4 {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let n = Math.min(r, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Mo ? i.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new Mo(n - this.pos, -1)), this.writtenTo = n, r > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, n) {
    if (e < r || n.heightRelevant) {
      let i = n.widget ? n.widget.estimatedHeight : 0, o = n.widget ? n.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let s = r - e;
      n.block ? this.addBlock(new KM(s, i, n)) : (s || o || i >= QJ) && this.addLineDeco(i, o, s);
    } else r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Mo(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let n = new Wn(r - e);
    return this.oracle.doc.lineAt(e).to == r && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Mo)
      return e;
    let r = new Mo(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, n) {
    let i = this.ensureLine();
    i.length += n, i.collapsed += n, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += r, this.writtenTo = this.pos = this.pos + n;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof Mo) && !this.isCovered ? this.nodes.push(new Mo(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let i of this.nodes)
      i instanceof Mo && i.updateHeight(this.oracle, n), n += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, n, i) {
    let o = new a4(n, e);
    return hr.spans(r, n, i, o, 0), o.finish(n);
  }
}
function XJ(t, e, r) {
  let n = new JJ();
  return hr.compare(t, e, r, n, 0), n.changes;
}
class JJ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, n, i) {
    (e < r || n && n.heightRelevant || i && i.heightRelevant) && Fy(e, r, this.changes, 5);
  }
}
function YJ(t, e) {
  let r = t.getBoundingClientRect(), n = t.ownerDocument, i = n.defaultView || window, o = Math.max(0, r.left), s = Math.min(i.innerWidth, r.right), a = Math.max(0, r.top), l = Math.min(i.innerHeight, r.bottom);
  for (let u = t.parentNode; u && u != n.body; )
    if (u.nodeType == 1) {
      let c = u, h = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && h.overflow != "visible") {
        let d = c.getBoundingClientRect();
        o = Math.max(o, d.left), s = Math.min(s, d.right), a = Math.max(a, d.top), l = Math.min(u == t.parentNode ? i.innerHeight : l, d.bottom);
      }
      u = h.position == "absolute" || h.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: o - r.left,
    right: Math.max(o, s) - r.left,
    top: a - (r.top + e),
    bottom: Math.max(a, l) - (r.top + e)
  };
}
function ZJ(t) {
  let e = t.getBoundingClientRect(), r = t.ownerDocument.defaultView || window;
  return e.left < r.innerWidth && e.right > 0 && e.top < r.innerHeight && e.bottom > 0;
}
function eY(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class C2 {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.size = n, this.displaySize = i;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n], o = r[n];
      if (i.from != o.from || i.to != o.to || i.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return pt.replace({
      widget: new tY(this.displaySize * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class tY extends Bh {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class l6 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = u6, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Ir.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(i4).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new WJ(r), this.stateDeco = e.facet(Ym).filter((n) => typeof n != "function"), this.heightMap = $i.empty().applyChanges(this.stateDeco, ir.empty, this.heightOracle.setDoc(e.doc), [new gs(0, 0, 0, e.doc.length)]);
    for (let n = 0; n < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); n++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = pt.set(this.lineGaps.map((n) => n.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let i = n ? r.head : r.anchor;
      if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
        let { from: o, to: s } = this.lineBlockAt(i);
        e.push(new Ov(o, s));
      }
    }
    return this.viewports = e.sort((n, i) => n.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? u6 : new l4(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(pm(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(Ym).filter((c) => typeof c != "function");
    let i = e.changedRanges, o = gs.extendWithRanges(i, XJ(n, this.stateDeco, e ? e.changes : En.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    s6(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || kd) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = s);
    let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < l.from || r.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, r));
    let u = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (u || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(EM) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, n = window.getComputedStyle(r), i = this.heightOracle, o = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? Ir.RTL : Ir.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(o), a = r.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (a.width && a.height) {
      let { scaleX: S, scaleY: _ } = rM(r, a);
      (S > 5e-3 && Math.abs(this.scaleX - S) > 5e-3 || _ > 5e-3 && Math.abs(this.scaleY - _) > 5e-3) && (this.scaleX = S, this.scaleY = _, u |= 16, s = l = !0);
    }
    let h = (parseInt(n.paddingTop) || 0) * this.scaleY, d = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != d) && (this.paddingTop = h, this.paddingBottom = d, u |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 16);
    let p = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != p && (this.scrollAnchorHeight = -1, this.scrollTop = p), this.scrolledToBottom = oM(e.scrollDOM);
    let g = (this.printing ? eY : YJ)(r, this.paddingTop), v = g.top - this.pixelViewport.top, y = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (l = !0)), !this.inView && !this.scrollTarget && !ZJ(e.dom))
      return 0;
    let k = a.width;
    if ((this.contentDOMWidth != k || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 16), l) {
      let S = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(S) && (s = !0), s || i.lineWrapping && Math.abs(k - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: _, charWidth: D, textHeight: A } = e.docView.measureTextSize();
        s = _ > 0 && i.refresh(o, _, D, A, Math.max(5, k / D), S), s && (e.docView.minWidth = 0, u |= 16);
      }
      v > 0 && y > 0 ? c = Math.max(v, y) : v < 0 && y < 0 && (c = Math.min(v, y)), s6();
      for (let _ of this.viewports) {
        let D = _.from == this.viewport.from ? S : e.docView.measureVisibleLineHeights(_);
        this.heightMap = (s ? $i.empty().applyChanges(this.stateDeco, ir.empty, this.heightOracle, [new gs(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, s, new GJ(_.from, D));
      }
      kd && (u |= 2);
    }
    let C = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return C && (u & 2 && (u |= this.updateScaler()), this.viewport = this.getViewport(c, this.scrollTarget), u |= this.updateForViewport()), (u & 2 || C) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new Ov(i.lineAt(s - n * 1e3, $r.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - n) * 1e3, $r.ByHeight, o, 0, 0).to);
    if (r) {
      let { head: u } = r.range;
      if (u < l.from || u > l.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(u, $r.ByPos, o, 0, 0), d;
        r.y == "center" ? d = (h.top + h.bottom) / 2 - c / 2 : r.y == "start" || r.y == "nearest" && u < l.from ? d = h.top : d = h.bottom - c, l = new Ov(i.lineAt(d - 1e3 / 2, $r.ByHeight, o, 0, 0).from, i.lineAt(d + c + 1e3 / 2, $r.ByHeight, o, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, r) {
    let n = r.mapPos(e.from, -1), i = r.mapPos(e.to, 1);
    return new Ov(this.heightMap.lineAt(n, $r.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, $r.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, n = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, $r.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(r, $r.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (e == 0 || i <= s - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || o >= a + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let n = [];
    for (let i of e)
      r.touchesRange(i.from, i.to) || n.push(new C2(r.mapPos(i.from), r.mapPos(i.to), i.size, i.displaySize));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let n = this.heightOracle.lineWrapping, i = n ? 1e4 : 2e3, o = i >> 1, s = i << 1;
    if (this.defaultTextDirection != Ir.LTR && !n)
      return [];
    let a = [], l = (c, h, d, p) => {
      if (h - c < o)
        return;
      let g = this.state.selection.main, v = [g.from];
      g.empty || v.push(g.to);
      for (let b of v)
        if (b > c && b < h) {
          l(c, b - 10, d, p), l(b + 10, h, d, p);
          return;
        }
      let y = nY(e, (b) => b.from >= d.from && b.to <= d.to && Math.abs(b.from - c) < o && Math.abs(b.to - h) < o && !v.some((k) => b.from < k && b.to > k));
      if (!y) {
        if (h < d.to && r && n && r.visibleRanges.some((C) => C.from <= h && C.to >= h)) {
          let C = r.moveToLineBoundary(de.cursor(h), !1, !0).head;
          C > c && (h = C);
        }
        let b = this.gapSize(d, c, h, p), k = n || b < 2e6 ? b : 2e6;
        y = new C2(c, h, b, k);
      }
      a.push(y);
    }, u = (c) => {
      if (c.length < s || c.type != Ni.Text)
        return;
      let h = rY(c.from, c.to, this.stateDeco);
      if (h.total < s)
        return;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, p, g;
      if (n) {
        let v = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, y, b;
        if (d != null) {
          let k = Tv(h, d), C = ((this.visibleBottom - this.visibleTop) / 2 + v) / c.height;
          y = k - C, b = k + C;
        } else
          y = (this.visibleTop - c.top - v) / c.height, b = (this.visibleBottom - c.top + v) / c.height;
        p = Fv(h, y), g = Fv(h, b);
      } else {
        let v = h.total * this.heightOracle.charWidth, y = i * this.heightOracle.charWidth, b = 0;
        if (v > 2e6)
          for (let D of e)
            D.from >= c.from && D.from < c.to && D.size != D.displaySize && D.from * this.heightOracle.charWidth + b < this.pixelViewport.left && (b = D.size - D.displaySize);
        let k = this.pixelViewport.left + b, C = this.pixelViewport.right + b, S, _;
        if (d != null) {
          let D = Tv(h, d), A = ((C - k) / 2 + y) / v;
          S = D - A, _ = D + A;
        } else
          S = (k - y) / v, _ = (C + y) / v;
        p = Fv(h, S), g = Fv(h, _);
      }
      p > c.from && l(c.from, p, c, h), g < c.to && l(g, c.to, c, h);
    };
    for (let c of this.viewportLines)
      Array.isArray(c.type) ? c.type.forEach(u) : u(c);
    return a;
  }
  gapSize(e, r, n, i) {
    let o = Tv(i, n) - Tv(i, r);
    return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    C2.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = pt.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let r = this.stateDeco;
    this.lineGaps.length && (r = r.concat(this.lineGapDeco));
    let n = [];
    hr.spans(r, this.viewport.from, this.viewport.to, {
      span(o, s) {
        n.push({ from: o, to: s });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (n.length != this.visibleRanges.length)
      i = 12;
    else
      for (let o = 0; o < n.length && !(i & 8); o++) {
        let s = this.visibleRanges[o], a = n[o];
        (s.from != a.from || s.to != a.to) && (i |= 4, e && e.mapPos(s.from, -1) == a.from && e.mapPos(s.to, 1) == a.to || (i |= 8));
      }
    return this.visibleRanges = n, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || pm(this.heightMap.lineAt(e, $r.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((r) => r.top <= e && r.bottom >= e) || pm(this.heightMap.lineAt(this.scaler.fromDOM(e), $r.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return pm(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Ov {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function rY(t, e, r) {
  let n = [], i = t, o = 0;
  return hr.spans(r, t, e, {
    span() {
    },
    point(s, a) {
      s > i && (n.push({ from: i, to: s }), o += s - i), i = a;
    }
  }, 20), i < e && (n.push({ from: i, to: e }), o += e - i), { total: o, ranges: n };
}
function Fv({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: o, to: s } = e[i], a = s - o;
    if (n <= a)
      return o + n;
    n -= a;
  }
}
function Tv(t, e) {
  let r = 0;
  for (let { from: n, to: i } of t.ranges) {
    if (e <= i) {
      r += e - n;
      break;
    }
    r += i - n;
  }
  return r / t.total;
}
function nY(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const u6 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class l4 {
  constructor(e, r, n) {
    let i = 0, o = 0, s = 0;
    this.viewports = n.map(({ from: a, to: l }) => {
      let u = r.lineAt(a, $r.ByPos, e, 0, 0).top, c = r.lineAt(l, $r.ByPos, e, 0, 0).bottom;
      return i += c - u, { from: a, to: l, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (r.height - i);
    for (let a of this.viewports)
      a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
  }
  toDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let o = r < this.viewports.length ? this.viewports[r] : null;
      if (!o || e < o.top)
        return i + (e - n) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      n = o.bottom, i = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let o = r < this.viewports.length ? this.viewports[r] : null;
      if (!o || e < o.domTop)
        return n + (e - i) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      n = o.bottom, i = o.domBottom;
    }
  }
  eq(e) {
    return e instanceof l4 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((r, n) => r.from == e.viewports[n].from && r.to == e.viewports[n].to) : !1;
  }
}
function pm(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), n = e.toDOM(t.bottom);
  return new Ea(t.from, t.length, r, n - r, Array.isArray(t._content) ? t._content.map((i) => pm(i, e)) : t._content);
}
const Mv = /* @__PURE__ */ Le.define({ combine: (t) => t.join(" ") }), W3 = /* @__PURE__ */ Le.define({ combine: (t) => t.indexOf(!0) > -1 }), G3 = /* @__PURE__ */ nc.newName(), QM = /* @__PURE__ */ nc.newName(), XM = /* @__PURE__ */ nc.newName(), JM = { "&light": "." + QM, "&dark": "." + XM };
function K3(t, e, r) {
  return new nc(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!r || !r[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return r[i];
      }) : t + " " + n;
    }
  });
}
const iY = /* @__PURE__ */ K3("." + G3, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, JM), oY = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, _2 = Ie.ie && Ie.ie_version <= 11;
class sY {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new qX(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let n of r)
        this.queue.push(n);
      (Ie.ie && Ie.ie_version <= 11 || Ie.ios && e.composing) && r.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && Ie.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(Ie.chrome && Ie.chrome_version < 126) && (this.editContext = new lY(e), e.state.facet(Rl) && (e.contentDOM.editContext = this.editContext.editContext)), _2 && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, n) => r != e[n]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, i = this.selectionRange;
    if (n.state.facet(Rl) ? n.root.activeElement != this.dom : !Oy(this.dom, i))
      return;
    let o = i.anchorNode && n.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (Ie.ie && Ie.ie_version <= 11 || Ie.android && Ie.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Em(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = Xm(e.root);
    if (!r)
      return !1;
    let n = Ie.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && aY(this.view, r) || r;
    if (!n || this.selectionRange.eq(n))
      return !1;
    let i = Oy(this.dom, n);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && HX(this.dom, n) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(n), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = r)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, oY), _2 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), _2 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var n;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Hf(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, n = -1, i = !1;
    for (let o of e) {
      let s = this.readMutation(o);
      s && (s.typeOver && (i = !0), r == -1 ? { from: r, to: n } = s : (r = Math.min(s.from, r), n = Math.max(s.to, n)));
    }
    return { from: r, to: n, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: n } = this.processRecords(), i = this.selectionChanged && Oy(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new SJ(this.view, e, r, n);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let n = this.view.state, i = BM(this.view, r);
    return this.view.state == n && (r.domChanged || r.newSel && !r.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let n = c6(r, e.previousSibling || e.target.previousSibling, -1), i = c6(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? r.posAfter(n) : r.posAtStart,
        to: i ? r.posBefore(i) : r.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Rl) != e.state.facet(Rl) && (e.view.contentDOM.editContext = e.state.facet(Rl) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, r, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function c6(t, e, r) {
  for (; e; ) {
    let n = _r.get(e);
    if (n && n.parent == t)
      return n;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function h6(t, e) {
  let r = e.startContainer, n = e.startOffset, i = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor);
  return Em(s.node, s.offset, i, o) && ([r, n, i, o] = [i, o, r, n]), { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: o };
}
function aY(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return h6(t, i);
  }
  let r = null;
  function n(i) {
    i.preventDefault(), i.stopImmediatePropagation(), r = i.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", n, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", n, !0), r ? h6(t, r) : null;
}
class lY {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let r = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (n) => {
      let i = e.state.selection.main, { anchor: o, head: s } = i, a = this.toEditorPos(n.updateRangeStart), l = this.toEditorPos(n.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: n.updateRangeStart, editorBase: a, drifted: !1 });
      let u = l - a > n.text.length;
      a == this.from && o < this.from ? a = o : l == this.to && o > this.to && (l = o);
      let c = LM(e.state.sliceDoc(a, l), n.text, (u ? i.from : i.to) - a, u ? "end" : null);
      if (!c) {
        let d = de.single(this.toEditorPos(n.selectionStart), this.toEditorPos(n.selectionEnd));
        d.main.eq(i) || e.dispatch({ selection: d, userEvent: "select" });
        return;
      }
      let h = {
        from: c.from + a,
        to: c.toA + a,
        insert: ir.of(n.text.slice(c.from, c.toB).split(`
`))
      };
      if ((Ie.mac || Ie.android) && h.from == s - 1 && /^\. ?$/.test(n.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (h = { from: a, to: l, insert: ir.of([n.text.replace(".", " ")]) }), this.pendingContextChange = h, !e.state.readOnly) {
        let d = this.to - this.from + (h.to - h.from + h.insert.length);
        s4(e, h, de.single(this.toEditorPos(n.selectionStart, d), this.toEditorPos(n.selectionEnd, d)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), h.from < h.to && !h.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(r.text.slice(Math.max(0, n.updateRangeStart - 1), Math.min(r.text.length, n.updateRangeStart + 1))) && this.handlers.compositionend(n);
    }, this.handlers.characterboundsupdate = (n) => {
      let i = [], o = null;
      for (let s = this.toEditorPos(n.rangeStart), a = this.toEditorPos(n.rangeEnd); s < a; s++) {
        let l = e.coordsForChar(s);
        o = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || o || new DOMRect(), i.push(o);
      }
      r.updateCharacterBounds(n.rangeStart, i);
    }, this.handlers.textformatupdate = (n) => {
      let i = [];
      for (let o of n.getTextFormats()) {
        let s = o.underlineStyle, a = o.underlineThickness;
        if (!/none/i.test(s) && !/none/i.test(a)) {
          let l = this.toEditorPos(o.rangeStart), u = this.toEditorPos(o.rangeEnd);
          if (l < u) {
            let c = `text-decoration: underline ${/^[a-z]/.test(s) ? s + " " : s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${/thin/i.test(a) ? 1 : 2}px`;
            i.push(pt.mark({ attributes: { style: c } }).range(l, u));
          }
        }
      }
      e.dispatch({ effects: OM.of(pt.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: n } = this.composing;
        this.composing = null, n && this.reset(e.state);
      }
    };
    for (let n in this.handlers)
      r.addEventListener(n, this.handlers[n]);
    this.measureReq = { read: (n) => {
      this.editContext.updateControlBounds(n.contentDOM.getBoundingClientRect());
      let i = Xm(n.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let r = 0, n = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((o, s, a, l, u) => {
      if (n)
        return;
      let c = u.length - (s - o);
      if (i && s >= i.to)
        if (i.from == o && i.to == s && i.insert.eq(u)) {
          i = this.pendingContextChange = null, r += c, this.to += c;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (o += r, s += r, s <= this.from)
        this.from += c, this.to += c;
      else if (o < this.to) {
        if (o < this.from || s > this.to || this.to - this.from + u.length > 3e4) {
          n = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), u.toString()), this.to += c;
      }
      r += c;
    }), i && !n && this.revertPending(e.state), !n;
  }
  update(e) {
    let r = this.pendingContextChange, n = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(n.from, n.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || r) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: r } = e.selection.main;
    this.from = Math.max(
      0,
      r - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      r + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let r = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(r.from), this.toContextPos(r.from + r.insert.length), e.doc.sliceString(r.from, r.to));
  }
  setSelection(e) {
    let { main: r } = e.selection, n = this.toContextPos(Math.max(this.from, Math.min(this.to, r.anchor))), i = this.toContextPos(r.head);
    (this.editContext.selectionStart != n || this.editContext.selectionEnd != i) && this.editContext.updateSelection(n, i);
  }
  rangeIsValid(e) {
    let { head: r } = e.selection.main;
    return !(this.from > 0 && r - this.from < 500 || this.to < e.doc.length && this.to - r < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, r = this.to - this.from) {
    e = Math.min(e, r);
    let n = this.composing;
    return n && n.drifted ? n.editorBase + (e - n.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let r = this.composing;
    return r && r.drifted ? r.contextBase + (e - r.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class Be {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var r;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    this.dispatchTransactions = e.dispatchTransactions || n && ((i) => i.forEach((o) => n(o, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || UX(e.parent) || document, this.viewState = new l6(e.state || nr.create(e)), e.scrollTo && e.scrollTo.is(Av) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Ff).map((i) => new x2(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new sY(this), this.inputState = new OJ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new UD(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((r = document.fonts) === null || r === void 0) && r.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof bn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, n = !1, i, o = this.state;
    for (let d of e) {
      if (d.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let s = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(VM)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = WM(o, s), l || (a = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (c = null)) : this.observer.clear(), o.facet(nr.phrases) != this.state.facet(nr.phrases))
      return this.setState(o);
    i = c1.create(this, o, e), i.flags |= a;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (h && (h = h.map(d.changes)), d.scrollIntoView) {
          let { main: p } = d.state.selection;
          h = new Vf(p.empty ? p : de.cursor(p.head, p.head > p.anchor ? -1 : 1));
        }
        for (let p of d.effects)
          p.is(Av) && (h = p.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = f1.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), r = this.docView.update(i), this.state.facet(fm) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(Mv) != i.state.facet(Mv) && (this.viewState.mustMeasureContent = !0), (r || n || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), r && this.docViewUpdate(), !i.empty)
      for (let d of this.state.facet(q3))
        try {
          d(i);
        } catch (p) {
          Pi(this.state, p, "update listener");
        }
    (l || c) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), c && !BM(this, c) && u.force && Hf(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new l6(e), this.plugins = e.facet(Ff).map((n) => new x2(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView.destroy(), this.docView = new UD(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(Ff), n = e.state.facet(Ff);
    if (r != n) {
      let i = [];
      for (let o of n) {
        let s = r.indexOf(o);
        if (s < 0)
          i.push(new x2(o));
        else {
          let a = this.plugins[s];
          a.mustUpdate = e, i.push(a);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    r != n && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let r = e.value;
      if (r && r.docViewUpdate)
        try {
          r.docViewUpdate(this);
        } catch (n) {
          Pi(this.state, n, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, n = this.scrollDOM, i = n.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (s < 0)
          if (oM(n))
            o = -1, s = this.viewState.heightMap.height;
          else {
            let p = this.viewState.scrollAnchorAt(i);
            o = p.from, s = p.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        l & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((p) => {
          try {
            return p.read(this);
          } catch (g) {
            return Pi(this.state, g), f6;
          }
        }), h = c1.create(this, this.state, []), d = !1;
        h.flags |= l, r ? r.flags |= l : r = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), d = this.docView.update(h), d && this.docViewUpdate());
        for (let p = 0; p < u.length; p++)
          if (c[p] != f6)
            try {
              let g = u[p];
              g.write && g.write(c[p], this);
            } catch (g) {
              Pi(this.state, g);
            }
        if (d && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
              if (p > 1 || p < -1) {
                i = i + p, n.scrollTop = i / this.scaleY, s = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let a of this.state.facet(q3))
        a(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return G3 + " " + (this.state.facet(W3) ? XM : QM) + " " + this.state.facet(Mv);
  }
  updateAttrs() {
    let e = d6(this, FM, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Rl) ? "true" : "false",
      class: "cm-content",
      style: `${Ie.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), d6(this, i4, r);
    let n = this.observer.ignore(() => {
      let i = I3(this.contentDOM, this.contentAttrs, r), o = I3(this.dom, this.editorAttrs, e);
      return i || o;
    });
    return this.editorAttrs = e, this.contentAttrs = r, n;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let n of e)
      for (let i of n.effects)
        if (i.is(Be.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(fm);
    let e = this.state.facet(Be.cspNonce);
    nc.mount(this.root, this.styleModules.concat(iY).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.plugin != e) && this.pluginMap.set(e, r = this.plugins.find((n) => n.plugin == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, n) {
    return k2(this, e, KD(this, e, r, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return k2(this, e, KD(this, e, r, (n) => xJ(this, e.head, n)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let n = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = n[r ? n.length - 1 : 0];
    return de.cursor(o.side(r, i) + e.from, o.forward(!r, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, n = !0) {
    return bJ(this, e, r, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, n) {
    return k2(this, e, wJ(this, e, r, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), NM(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, r);
    if (!n || n.left == n.right)
      return n;
    let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), s = o[Ru.find(o, e - i.from, -1, r)];
    return Rb(n, s.dir == Ir.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(AM) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > uY)
      return yM(e.length);
    let r = this.textDirectionAt(e.from), n;
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == r && (o.fresh || vM(o.isolates, n = qD(this, e))))
        return o.order;
    n || (n = qD(this, e));
    let i = nJ(e.text, r, n);
    return this.bidiCache.push(new f1(e.from, e.to, r, n, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Ie.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      nM(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return Av.of(new Vf(typeof e == "number" ? de.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
    return Av.of(new Vf(de.cursor(n.from), "start", "start", n.top - e, r, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return wn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return wn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let n = nc.newName(), i = [Mv.of(n), fm.of(K3(`.${n}`, e))];
    return r && r.dark && i.push(W3.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return pc.lowest(fm.of(K3("." + G3, e, JM)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let n = e.querySelector(".cm-content");
    return ((r = (n && _r.get(n) || _r.get(e))?.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
Be.styleModule = fm;
Be.inputHandler = _M;
Be.clipboardInputFilter = r4;
Be.clipboardOutputFilter = n4;
Be.scrollHandler = DM;
Be.focusChangeEffect = SM;
Be.perLineTextDirection = AM;
Be.exceptionSink = CM;
Be.updateListener = q3;
Be.editable = Rl;
Be.mouseSelectionStyle = kM;
Be.dragMovesSelection = wM;
Be.clickAddsSelectionRange = xM;
Be.decorations = Ym;
Be.outerDecorations = TM;
Be.atomicRanges = Jg;
Be.bidiIsolatedRanges = MM;
Be.scrollMargins = PM;
Be.darkTheme = W3;
Be.cspNonce = /* @__PURE__ */ Le.define({ combine: (t) => t.length ? t[0] : "" });
Be.contentAttributes = i4;
Be.editorAttributes = FM;
Be.lineWrapping = /* @__PURE__ */ Be.contentAttributes.of({ class: "cm-lineWrapping" });
Be.announce = /* @__PURE__ */ _t.define();
const uY = 4096, f6 = {};
class f1 {
  constructor(e, r, n, i, o, s) {
    this.from = e, this.to = r, this.dir = n, this.isolates = i, this.fresh = o, this.order = s;
  }
  static update(e, r) {
    if (r.empty && !e.some((o) => o.fresh))
      return e;
    let n = [], i = e.length ? e[e.length - 1].dir : Ir.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let s = e[o];
      s.dir == i && !r.touchesRange(s.from, s.to) && n.push(new f1(r.mapPos(s.from, 1), r.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order));
    }
    return n;
  }
}
function d6(t, e, r) {
  for (let n = t.state.facet(e), i = n.length - 1; i >= 0; i--) {
    let o = n[i], s = typeof o == "function" ? o(t) : o;
    s && $3(s, r);
  }
  return r;
}
const cY = Ie.mac ? "mac" : Ie.windows ? "win" : Ie.linux ? "linux" : "key";
function hY(t, e) {
  const r = t.split(/-(?!$)/);
  let n = r[r.length - 1];
  n == "Space" && (n = " ");
  let i, o, s, a;
  for (let l = 0; l < r.length - 1; ++l) {
    const u = r[l];
    if (/^(cmd|meta|m)$/i.test(u))
      a = !0;
    else if (/^a(lt)?$/i.test(u))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      o = !0;
    else if (/^s(hift)?$/i.test(u))
      s = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? a = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return i && (n = "Alt-" + n), o && (n = "Ctrl-" + n), a && (n = "Meta-" + n), s && (n = "Shift-" + n), n;
}
function Pv(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const fY = /* @__PURE__ */ pc.default(/* @__PURE__ */ Be.domEventHandlers({
  keydown(t, e) {
    return ZM(YM(e.state), t, e, "editor");
  }
})), $b = /* @__PURE__ */ Le.define({ enables: fY }), p6 = /* @__PURE__ */ new WeakMap();
function YM(t) {
  let e = t.facet($b), r = p6.get(e);
  return r || p6.set(e, r = mY(e.reduce((n, i) => n.concat(i), []))), r;
}
function dY(t, e, r) {
  return ZM(YM(t.state), e, t, r);
}
let Ou = null;
const pY = 4e3;
function mY(t, e = cY) {
  let r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = (s, a) => {
    let l = n[s];
    if (l == null)
      n[s] = a;
    else if (l != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (s, a, l, u, c) => {
    var h, d;
    let p = r[s] || (r[s] = /* @__PURE__ */ Object.create(null)), g = a.split(/ (?!$)/).map((b) => hY(b, e));
    for (let b = 1; b < g.length; b++) {
      let k = g.slice(0, b).join(" ");
      i(k, !0), p[k] || (p[k] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(C) => {
          let S = Ou = { view: C, prefix: k, scope: s };
          return setTimeout(() => {
            Ou == S && (Ou = null);
          }, pY), !0;
        }]
      });
    }
    let v = g.join(" ");
    i(v, !1);
    let y = p[v] || (p[v] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (h = p._any) === null || h === void 0 ? void 0 : h.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && y.run.push(l), u && (y.preventDefault = !0), c && (y.stopPropagation = !0);
  };
  for (let s of t) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let u of a) {
        let c = r[u] || (r[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = s;
        for (let d in c)
          c[d].run.push((p) => h(p, Q3));
      }
    let l = s[e] || s.key;
    if (l)
      for (let u of a)
        o(u, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(u, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
  }
  return r;
}
let Q3 = null;
function ZM(t, e, r, n) {
  Q3 = e;
  let i = IX(e), o = Ji(i, 0), s = Aa(o) == i.length && i != " ", a = "", l = !1, u = !1, c = !1;
  Ou && Ou.view == r && Ou.scope == n && (a = Ou.prefix + " ", jM.indexOf(e.keyCode) < 0 && (u = !0, Ou = null));
  let h = /* @__PURE__ */ new Set(), d = (y) => {
    if (y) {
      for (let b of y.run)
        if (!h.has(b) && (h.add(b), b(r)))
          return y.stopPropagation && (c = !0), !0;
      y.preventDefault && (y.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, p = t[n], g, v;
  return p && (d(p[a + Pv(i, e, !s)]) ? l = !0 : s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Ie.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(Ie.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (g = ic[e.keyCode]) && g != i ? (d(p[a + Pv(g, e, !0)]) || e.shiftKey && (v = Qm[e.keyCode]) != i && v != g && d(p[a + Pv(v, e, !1)])) && (l = !0) : s && e.shiftKey && d(p[a + Pv(i, e, !0)]) && (l = !0), !l && d(p._any) && (l = !0)), u && (l = !0), l && c && e.stopPropagation(), Q3 = null, l;
}
class Yg {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, n, i, o) {
    this.className = e, this.left = r, this.top = n, this.width = i, this.height = o;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, n) {
    if (n.empty) {
      let i = e.coordsAtPos(n.head, n.assoc || 1);
      if (!i)
        return [];
      let o = eP(e);
      return [new Yg(r, i.left - o.left, i.top - o.top, null, i.bottom - i.top)];
    } else
      return gY(e, r, n);
  }
}
function eP(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == Ir.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function m6(t, e, r, n) {
  let i = t.coordsAtPos(e, r * 2);
  if (!i)
    return n;
  let o = t.dom.getBoundingClientRect(), s = (i.top + i.bottom) / 2, a = t.posAtCoords({ x: o.left + 1, y: s }), l = t.posAtCoords({ x: o.right - 1, y: s });
  return a == null || l == null ? n : { from: Math.max(n.from, Math.min(a, l)), to: Math.min(n.to, Math.max(a, l)) };
}
function gY(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let n = Math.max(r.from, t.viewport.from), i = Math.min(r.to, t.viewport.to), o = t.textDirection == Ir.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), l = eP(t), u = s.querySelector(".cm-line"), c = u && window.getComputedStyle(u), h = a.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), d = a.right - (c ? parseInt(c.paddingRight) : 0), p = H3(t, n, 1), g = H3(t, i, -1), v = p.type == Ni.Text ? p : null, y = g.type == Ni.Text ? g : null;
  if (v && (t.lineWrapping || p.widgetLineBreaks) && (v = m6(t, n, 1, v)), y && (t.lineWrapping || g.widgetLineBreaks) && (y = m6(t, i, -1, y)), v && y && v.from == y.from && v.to == y.to)
    return k(C(r.from, r.to, v));
  {
    let _ = v ? C(r.from, null, v) : S(p, !1), D = y ? C(null, r.to, y) : S(g, !0), A = [];
    return (v || p).to < (y || g).from - (v && y ? 1 : 0) || p.widgetLineBreaks > 1 && _.bottom + t.defaultLineHeight / 2 < D.top ? A.push(b(h, _.bottom, d, D.top)) : _.bottom < D.top && t.elementAtHeight((_.bottom + D.top) / 2).type == Ni.Text && (_.bottom = D.top = (_.bottom + D.top) / 2), k(_).concat(A).concat(k(D));
  }
  function b(_, D, A, O) {
    return new Yg(e, _ - l.left, D - l.top, A - _, O - D);
  }
  function k({ top: _, bottom: D, horizontal: A }) {
    let O = [];
    for (let M = 0; M < A.length; M += 2)
      O.push(b(A[M], _, A[M + 1], D));
    return O;
  }
  function C(_, D, A) {
    let O = 1e9, M = -1e9, z = [];
    function R(B, $, q, U, H) {
      let G = t.coordsAtPos(B, B == A.to ? -2 : 2), re = t.coordsAtPos(q, q == A.from ? 2 : -2);
      !G || !re || (O = Math.min(G.top, re.top, O), M = Math.max(G.bottom, re.bottom, M), H == Ir.LTR ? z.push(o && $ ? h : G.left, o && U ? d : re.right) : z.push(!o && U ? h : re.left, !o && $ ? d : G.right));
    }
    let N = _ ?? A.from, I = D ?? A.to;
    for (let B of t.visibleRanges)
      if (B.to > N && B.from < I)
        for (let $ = Math.max(B.from, N), q = Math.min(B.to, I); ; ) {
          let U = t.state.doc.lineAt($);
          for (let H of t.bidiSpans(U)) {
            let G = H.from + U.from, re = H.to + U.from;
            if (G >= q)
              break;
            re > $ && R(Math.max(G, $), _ == null && G <= N, Math.min(re, q), D == null && re >= I, H.dir);
          }
          if ($ = U.to + 1, $ >= q)
            break;
        }
    return z.length == 0 && R(N, _ == null, I, D == null, t.textDirection), { top: O, bottom: M, horizontal: z };
  }
  function S(_, D) {
    let A = a.top + (D ? _.top : _.bottom);
    return { top: A, bottom: A, horizontal: [] };
  }
}
function vY(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class yY {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(My) != e.state.facet(My) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let r = 0, n = e.facet(My);
    for (; r < n.length && n[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, n) => !vY(r, this.drawn[n]))) {
      let r = this.dom.firstChild, n = 0;
      for (let i of e)
        i.update && r && i.constructor && this.drawn[n].constructor && i.update(r, this.drawn[n]) ? (r = r.nextSibling, n++) : this.dom.insertBefore(i.draw(), r);
      for (; r; ) {
        let i = r.nextSibling;
        r.remove(), r = i;
      }
      this.drawn = e, Ie.safari && Ie.safari_version >= 26 && (this.dom.style.display = this.dom.firstChild ? "" : "none");
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const My = /* @__PURE__ */ Le.define();
function tP(t) {
  return [
    wn.define((e) => new yY(e, t)),
    My.of(t)
  ];
}
const Zm = /* @__PURE__ */ Le.define({
  combine(t) {
    return iu(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function bY(t = {}) {
  return [
    Zm.of(t),
    xY,
    wY,
    kY,
    EM.of(!0)
  ];
}
function rP(t) {
  return t.startState.facet(Zm) != t.state.facet(Zm);
}
const xY = /* @__PURE__ */ tP({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(Zm), n = [];
    for (let i of e.selection.ranges) {
      let o = i == e.selection.main;
      if (i.empty || r.drawRangeCursor) {
        let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : de.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of Yg.forRange(t, s, a))
          n.push(l);
      }
    }
    return n;
  },
  update(t, e) {
    t.transactions.some((n) => n.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = rP(t);
    return r && g6(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    g6(e.state, t);
  },
  class: "cm-cursorLayer"
});
function g6(t, e) {
  e.style.animationDuration = t.facet(Zm).cursorBlinkRate + "ms";
}
const wY = /* @__PURE__ */ tP({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Yg.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || rP(t);
  },
  class: "cm-selectionLayer"
}), kY = /* @__PURE__ */ pc.highest(/* @__PURE__ */ Be.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), nP = /* @__PURE__ */ _t.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), mm = /* @__PURE__ */ jn.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, n) => n.is(nP) ? n.value : r, t);
  }
}), CY = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(mm);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(mm) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(mm), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let n = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - n.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - n.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(mm) != t && this.view.dispatch({ effects: nP.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function _Y() {
  return [mm, CY];
}
function v6(t, e, r, n, i) {
  e.lastIndex = 0;
  for (let o = t.iterRange(r, n), s = r, a; !o.next().done; s += o.value.length)
    if (!o.lineBreak)
      for (; a = e.exec(o.value); )
        i(s + a.index, a);
}
function SY(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let n = [];
  for (let { from: i, to: o } of r)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), n.length && n[n.length - 1].to >= i ? n[n.length - 1].to = o : n.push({ from: i, to: o });
  return n;
}
class AY {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: n, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, i)
      this.addMatch = (a, l, u, c) => i(c, u, u + a[0].length, a, l);
    else if (typeof n == "function")
      this.addMatch = (a, l, u, c) => {
        let h = n(a, l, u);
        h && c(u, u + a[0].length, h);
      };
    else if (n)
      this.addMatch = (a, l, u, c) => c(u, u + a[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new rc(), n = r.add.bind(r);
    for (let { from: i, to: o } of SY(e, this.maxLength))
      v6(e.state.doc, this.regexp, i, o, (s, a) => this.addMatch(a, e, s, n));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let n = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((o, s, a, l) => {
      l >= e.view.viewport.from && a <= e.view.viewport.to && (n = Math.min(a, n), i = Math.max(l, i));
    }), e.viewportMoved || i - n > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, r.map(e.changes), n, i) : r;
  }
  updateRange(e, r, n, i) {
    for (let o of e.visibleRanges) {
      let s = Math.max(o.from, n), a = Math.min(o.to, i);
      if (a >= s) {
        let l = e.state.doc.lineAt(s), u = l.to < a ? e.state.doc.lineAt(a) : l, c = Math.max(o.from, l.from), h = Math.min(o.to, u.to);
        if (this.boundary) {
          for (; s > l.from; s--)
            if (this.boundary.test(l.text[s - 1 - l.from])) {
              c = s;
              break;
            }
          for (; a < u.to; a++)
            if (this.boundary.test(u.text[a - u.from])) {
              h = a;
              break;
            }
        }
        let d = [], p, g = (v, y, b) => d.push(b.range(v, y));
        if (l == u)
          for (this.regexp.lastIndex = c - l.from; (p = this.regexp.exec(l.text)) && p.index < h - l.from; )
            this.addMatch(p, e, p.index + l.from, g);
        else
          v6(e.state.doc, this.regexp, c, h, (v, y) => this.addMatch(y, e, v, g));
        r = r.update({ filterFrom: c, filterTo: h, filter: (v, y) => v < c || y > h, add: d });
      }
    }
    return r;
  }
}
const X3 = /x/.unicode != null ? "gu" : "g", EY = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, X3), DY = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let S2 = null;
function OY() {
  var t;
  if (S2 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    S2 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return S2 || !1;
}
const Py = /* @__PURE__ */ Le.define({
  combine(t) {
    let e = iu(t, {
      render: null,
      specialChars: EY,
      addSpecialChars: null
    });
    return (e.replaceTabs = !OY()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, X3)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, X3)), e;
  }
});
function FY(t = {}) {
  return [Py.of(t), TY()];
}
let y6 = null;
function TY() {
  return y6 || (y6 = wn.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = pt.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Py)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new AY({
        regexp: t.specialChars,
        decoration: (e, r, n) => {
          let { doc: i } = r.state, o = Ji(e[0], 0);
          if (o == 9) {
            let s = i.lineAt(n), a = r.state.tabSize, l = Xd(s.text, a, n - s.from);
            return pt.replace({
              widget: new NY((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = pt.replace({ widget: new RY(t, o) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Py);
      t.startState.facet(Py) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const MY = "â€¢";
function PY(t) {
  return t >= 32 ? MY : t == 10 ? "â¤" : String.fromCharCode(9216 + t);
}
class RY extends Bh {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = PY(this.code), n = e.state.phrase("Control character") + " " + (DY[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, n, r);
    if (i)
      return i;
    let o = document.createElement("span");
    return o.textContent = r, o.title = n, o.setAttribute("aria-label", n), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class NY extends Bh {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function $Y() {
  return BY;
}
const IY = /* @__PURE__ */ pt.line({ class: "cm-activeLine" }), BY = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let n of t.state.selection.ranges) {
      let i = t.lineBlockAt(n.head);
      i.from > e && (r.push(IY.range(i.from)), e = i.from);
    }
    return pt.set(r);
  }
}, {
  decorations: (t) => t.decorations
}), J3 = 2e3;
function LY(t, e, r) {
  let n = Math.min(e.line, r.line), i = Math.max(e.line, r.line), o = [];
  if (e.off > J3 || r.off > J3 || e.col < 0 || r.col < 0) {
    let s = Math.min(e.off, r.off), a = Math.max(e.off, r.off);
    for (let l = n; l <= i; l++) {
      let u = t.doc.line(l);
      u.length <= a && o.push(de.range(u.from + s, u.to + a));
    }
  } else {
    let s = Math.min(e.col, r.col), a = Math.max(e.col, r.col);
    for (let l = n; l <= i; l++) {
      let u = t.doc.line(l), c = D3(u.text, s, t.tabSize, !0);
      if (c < 0)
        o.push(de.cursor(u.to));
      else {
        let h = D3(u.text, a, t.tabSize);
        o.push(de.range(u.from + c, u.from + h));
      }
    }
  }
  return o;
}
function zY(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function b6(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = t.state.doc.lineAt(r), i = r - n.from, o = i > J3 ? -1 : i == n.length ? zY(t, e.clientX) : Xd(n.text, t.state.tabSize, r - n.from);
  return { line: n.number, col: o, off: i };
}
function jY(t, e) {
  let r = b6(t, e), n = t.state.selection;
  return r ? {
    update(i) {
      if (i.docChanged) {
        let o = i.changes.mapPos(i.startState.doc.line(r.line).from), s = i.state.doc.lineAt(o);
        r = { line: s.number, col: r.col, off: Math.min(r.off, s.length) }, n = n.map(i.changes);
      }
    },
    get(i, o, s) {
      let a = b6(t, i);
      if (!a)
        return n;
      let l = LY(t.state, r, a);
      return l.length ? s ? de.create(l.concat(n.ranges)) : de.create(l) : n;
    }
  } : null;
}
function qY(t) {
  let e = ((r) => r.altKey && r.button == 0);
  return Be.mouseSelectionStyle.of((r, n) => e(n) ? jY(r, n) : null);
}
const UY = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, HY = { style: "cursor: crosshair" };
function VY(t = {}) {
  let [e, r] = UY[t.key || "Alt"], n = wn.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || r(i));
      },
      keyup(i) {
        (i.keyCode == e || !r(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(r(i));
      }
    }
  });
  return [
    n,
    Be.contentAttributes.of((i) => {
      var o;
      return !((o = i.plugin(n)) === null || o === void 0) && o.isDown ? HY : null;
    })
  ];
}
const Gp = "-10000px";
class iP {
  constructor(e, r, n, i) {
    this.facet = r, this.createTooltipView = n, this.removeTooltipView = i, this.input = e.state.facet(r), this.tooltips = this.input.filter((s) => s);
    let o = null;
    this.tooltipViews = this.tooltips.map((s) => o = n(s, o));
  }
  update(e, r) {
    var n;
    let i = e.state.facet(this.facet), o = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let s = [], a = r ? [] : null;
    for (let l = 0; l < o.length; l++) {
      let u = o[l], c = -1;
      if (u) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let d = this.tooltips[h];
          d && d.create == u.create && (c = h);
        }
        if (c < 0)
          s[l] = this.createTooltipView(u, l ? s[l - 1] : null), a && (a[l] = !!u.above);
        else {
          let h = s[l] = this.tooltipViews[c];
          a && (a[l] = r[c]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      s.indexOf(l) < 0 && (this.removeTooltipView(l), (n = l.destroy) === null || n === void 0 || n.call(l));
    return r && (a.forEach((l, u) => r[u] = l), r.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, !0;
  }
}
function WY(t = {}) {
  return Ry.of(t);
}
function GY(t) {
  let e = t.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const Ry = /* @__PURE__ */ Le.define({
  combine: (t) => {
    var e, r, n;
    return {
      position: Ie.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((n = t.find((i) => i.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || GY
    };
  }
}), x6 = /* @__PURE__ */ new WeakMap(), u4 = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Ry);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new iP(t, c4, (r, n) => this.createTooltip(r, n), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, n = t.state.facet(Ry);
    if (n.position != this.position && !this.madeAbsolute) {
      this.position = n.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      r = !0;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      r = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), n = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", r.dom.appendChild(i);
    }
    return r.dom.style.position = this.position, r.dom.style.top = Gp, r.dom.style.left = "0px", this.container.insertBefore(r.dom, n), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = 1, e = 1, r = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: o } = this.manager.tooltipViews[0];
      if (Ie.gecko)
        r = o.offsetParent != this.container.ownerDocument.body;
      else if (o.style.top == Gp && o.style.left == "0px") {
        let s = o.getBoundingClientRect();
        r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let o = this.parent.getBoundingClientRect();
        o.width && o.height && (t = o.width / this.parent.offsetWidth, e = o.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    let n = this.view.scrollDOM.getBoundingClientRect(), i = o4(this.view);
    return {
      visible: {
        left: n.left + i.left,
        top: n.top + i.top,
        right: n.right - i.right,
        bottom: n.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((o, s) => {
        let a = this.manager.tooltipViews[s];
        return a.getCoords ? a.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
      space: this.view.state.facet(Ry).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: r
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: r, space: n, scaleX: i, scaleY: o } = t, s = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], u = this.manager.tooltipViews[a], { dom: c } = u, h = t.pos[a], d = t.size[a];
      if (!h || l.clip !== !1 && (h.bottom <= Math.max(r.top, n.top) || h.top >= Math.min(r.bottom, n.bottom) || h.right < Math.max(r.left, n.left) - 0.1 || h.left > Math.min(r.right, n.right) + 0.1)) {
        c.style.top = Gp;
        continue;
      }
      let p = l.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, g = p ? 7 : 0, v = d.right - d.left, y = (e = x6.get(u)) !== null && e !== void 0 ? e : d.bottom - d.top, b = u.offset || QY, k = this.view.textDirection == Ir.LTR, C = d.width > n.right - n.left ? k ? n.left : n.right - d.width : k ? Math.max(n.left, Math.min(h.left - (p ? 14 : 0) + b.x, n.right - v)) : Math.min(Math.max(n.left, h.left - v + (p ? 14 : 0) - b.x), n.right - v), S = this.above[a];
      !l.strictSide && (S ? h.top - y - g - b.y < n.top : h.bottom + y + g + b.y > n.bottom) && S == n.bottom - h.bottom > h.top - n.top && (S = this.above[a] = !S);
      let _ = (S ? h.top - n.top : n.bottom - h.bottom) - g;
      if (_ < y && u.resize !== !1) {
        if (_ < this.view.defaultLineHeight) {
          c.style.top = Gp;
          continue;
        }
        x6.set(u, y), c.style.height = (y = _) / o + "px";
      } else c.style.height && (c.style.height = "");
      let D = S ? h.top - y - g - b.y : h.bottom + g + b.y, A = C + v;
      if (u.overlap !== !0)
        for (let O of s)
          O.left < A && O.right > C && O.top < D + y && O.bottom > D && (D = S ? O.top - y - 2 - g : O.bottom + g + 2);
      if (this.position == "absolute" ? (c.style.top = (D - t.parent.top) / o + "px", w6(c, (C - t.parent.left) / i)) : (c.style.top = D / o + "px", w6(c, C / i)), p) {
        let O = h.left + (k ? b.x : -b.x) - (C + 14 - 7);
        p.style.left = O / i + "px";
      }
      u.overlap !== !0 && s.push({ left: C, top: D, right: A, bottom: D + y }), c.classList.toggle("cm-tooltip-above", S), c.classList.toggle("cm-tooltip-below", !S), u.positioned && u.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = Gp;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function w6(t, e) {
  let r = parseInt(t.style.left, 10);
  (isNaN(r) || Math.abs(e - r) > 1) && (t.style.left = e + "px");
}
const KY = /* @__PURE__ */ Be.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), QY = { x: 0, y: 0 }, c4 = /* @__PURE__ */ Le.define({
  enables: [u4, KY]
}), d1 = /* @__PURE__ */ Le.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class Ib {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Ib(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new iP(e, d1, (r, n) => this.createHostedView(r, n), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let n = e.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(n.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let n of this.manager.tooltipViews) {
      let i = n[e];
      if (i !== void 0) {
        if (r === void 0)
          r = i;
        else if (r !== i)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const XY = /* @__PURE__ */ c4.compute([d1], (t) => {
  let e = t.facet(d1);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var n;
      return (n = r.end) !== null && n !== void 0 ? n : r.pos;
    })),
    create: Ib.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class JY {
  constructor(e, r, n, i, o) {
    this.view = e, this.source = r, this.field = n, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, n = e.docView.nearest(r.target);
    if (!n)
      return;
    let i, o = 1;
    if (n instanceof Pu)
      i = n.posAtStart;
    else {
      if (i = e.posAtCoords(r), i == null)
        return;
      let a = e.coordsAtPos(i);
      if (!a || r.y < a.top || r.y > a.bottom || r.x < a.left - e.defaultCharacterWidth || r.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(i)).find((c) => c.from <= i && c.to >= i), u = l && l.dir == Ir.RTL ? -1 : 1;
      o = r.x < a.left ? -u : u;
    }
    let s = this.source(e, i, o);
    if (s?.then) {
      let a = this.pending = { pos: i };
      s.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => Pi(e.state, l, "hover tooltip"));
    } else s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let e = this.view.plugin(u4), r = e ? e.manager.tooltips.findIndex((n) => n.create == Ib.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, n;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: o } = this;
    if (i.length && o && !YY(o.dom, e) || this.pending) {
      let { pos: s } = i[0] || this.pending, a = (n = (r = i[0]) === null || r === void 0 ? void 0 : r.end) !== null && n !== void 0 ? n : s;
      (s == a ? this.view.posAtCoords(this.lastMove) != s : !ZY(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: n } = this;
      n && n.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(n.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (n) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(n.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Rv = 4;
function YY(t, e) {
  let { left: r, right: n, top: i, bottom: o } = t.getBoundingClientRect(), s;
  if (s = t.querySelector(".cm-tooltip-arrow")) {
    let a = s.getBoundingClientRect();
    i = Math.min(a.top, i), o = Math.max(a.bottom, o);
  }
  return e.clientX >= r - Rv && e.clientX <= n + Rv && e.clientY >= i - Rv && e.clientY <= o + Rv;
}
function ZY(t, e, r, n, i, o) {
  let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (s.left > n || s.right < n || s.top > i || Math.min(s.bottom, a) < i)
    return !1;
  let l = t.posAtCoords({ x: n, y: i }, !1);
  return l >= e && l <= r;
}
function oP(t, e = {}) {
  let r = _t.define(), n = jn.define({
    create() {
      return [];
    },
    update(i, o) {
      if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
        let s = [];
        for (let a of i) {
          let l = o.changes.mapPos(a.pos, -1, Kn.TrackDel);
          if (l != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), a);
            u.pos = l, u.end != null && (u.end = o.changes.mapPos(u.end)), s.push(u);
          }
        }
        i = s;
      }
      for (let s of o.effects)
        s.is(r) && (i = s.value), s.is(eZ) && (i = []);
      return i;
    },
    provide: (i) => d1.from(i)
  });
  return {
    active: n,
    extension: [
      n,
      wn.define((i) => new JY(
        i,
        t,
        n,
        r,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      XY
    ]
  };
}
function sP(t, e) {
  let r = t.plugin(u4);
  if (!r)
    return null;
  let n = r.manager.tooltips.indexOf(e);
  return n < 0 ? null : r.manager.tooltipViews[n];
}
const eZ = /* @__PURE__ */ _t.define(), k6 = /* @__PURE__ */ Le.define({
  combine(t) {
    let e, r;
    for (let n of t)
      e = e || n.topContainer, r = r || n.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function eg(t, e) {
  let r = t.plugin(aP), n = r ? r.specs.indexOf(e) : -1;
  return n > -1 ? r.panels[n] : null;
}
const aP = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(tg), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(k6);
    this.top = new Nv(t, !0, e.topContainer), this.bottom = new Nv(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(k6);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Nv(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Nv(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(tg);
    if (r != this.input) {
      let n = r.filter((l) => l), i = [], o = [], s = [], a = [];
      for (let l of n) {
        let u = this.specs.indexOf(l), c;
        u < 0 ? (c = l(t.view), a.push(c)) : (c = this.panels[u], c.update && c.update(t)), i.push(c), (c.top ? o : s).push(c);
      }
      this.specs = n, this.panels = i, this.top.sync(o), this.bottom.sync(s);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let n of this.panels)
        n.update && n.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => Be.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class Nv {
  constructor(e, r, n) {
    this.view = e, this.top = r, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = C6(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = C6(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function C6(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const tg = /* @__PURE__ */ Le.define({
  enables: aP
});
class sc extends bh {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
sc.prototype.elementClass = "";
sc.prototype.toDOM = void 0;
sc.prototype.mapMode = Kn.TrackBefore;
sc.prototype.startSide = sc.prototype.endSide = -1;
sc.prototype.point = !0;
const Ny = /* @__PURE__ */ Le.define(), tZ = /* @__PURE__ */ Le.define(), $y = /* @__PURE__ */ Le.define(), _6 = /* @__PURE__ */ Le.define({
  combine: (t) => t.some((e) => e)
});
function rZ(t) {
  return [
    nZ
  ];
}
const nZ = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.view = t, this.domAfter = null, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet($y).map((e) => new A6(t, e)), this.fixed = !t.state.facet(_6);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, n = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(n < (r.to - r.from) * 0.8);
    }
    if (t.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(_6) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let r = hr.iter(this.view.state.facet(Ny), this.view.viewport.from), n = [], i = this.gutters.map((o) => new iZ(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (n.length && (n = []), Array.isArray(o.type)) {
        let s = !0;
        for (let a of o.type)
          if (a.type == Ni.Text && s) {
            Y3(r, n, a.from);
            for (let l of i)
              l.line(this.view, a, n);
            s = !1;
          } else if (a.widget)
            for (let l of i)
              l.widget(this.view, a);
      } else if (o.type == Ni.Text) {
        Y3(r, n, o.from);
        for (let s of i)
          s.line(this.view, o, n);
      } else if (o.widget)
        for (let s of i)
          s.widget(this.view, o);
    for (let o of i)
      o.finish();
    t && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(t) {
    let e = t.startState.facet($y), r = t.state.facet($y), n = t.docChanged || t.heightChanged || t.viewportChanged || !hr.eq(t.startState.facet(Ny), t.state.facet(Ny), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let i of this.gutters)
        i.update(t) && (n = !0);
    else {
      n = !0;
      let i = [];
      for (let o of r) {
        let s = e.indexOf(o);
        s < 0 ? i.push(new A6(this.view, o)) : (this.gutters[s].update(t), i.push(this.gutters[s]));
      }
      for (let o of this.gutters)
        o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
      for (let o of i)
        o.config.side == "after" ? this.getDOMAfter().appendChild(o.dom) : this.dom.appendChild(o.dom);
      this.gutters = i;
    }
    return n;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (t) => Be.scrollMargins.of((e) => {
    let r = e.plugin(t);
    if (!r || r.gutters.length == 0 || !r.fixed)
      return null;
    let n = r.dom.offsetWidth * e.scaleX, i = r.domAfter ? r.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == Ir.LTR ? { left: n, right: i } : { right: n, left: i };
  })
});
function S6(t) {
  return Array.isArray(t) ? t : [t];
}
function Y3(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class iZ {
  constructor(e, r, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = hr.iter(e.markers, r.from);
  }
  addElement(e, r, n) {
    let { gutter: i } = this, o = (r.top - this.height) / e.scaleY, s = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new lP(e, s, o, n);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(e, s, o, n);
    this.height = r.bottom, this.i++;
  }
  line(e, r, n) {
    let i = [];
    Y3(this.cursor, i, r.from), n.length && (i = i.concat(n));
    let o = this.gutter.config.lineMarker(e, r, i);
    o && i.unshift(o);
    let s = this.gutter;
    i.length == 0 && !s.config.renderEmptyElements || this.addElement(e, r, i);
  }
  widget(e, r) {
    let n = this.gutter.config.widgetMarker(e, r.widget, r), i = n ? [n] : null;
    for (let o of e.state.facet(tZ)) {
      let s = o(e, r.widget, r);
      s && (i || (i = [])).push(s);
    }
    i && this.addElement(e, r, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class A6 {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in r.domEventHandlers)
      this.dom.addEventListener(n, (i) => {
        let o = i.target, s;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let l = o.getBoundingClientRect();
          s = (l.top + l.bottom) / 2;
        } else
          s = i.clientY;
        let a = e.lineBlockAtHeight(s - e.documentTop);
        r.domEventHandlers[n](e, a, i) && i.preventDefault();
      });
    this.markers = S6(r.markers(e)), r.initialSpacer && (this.spacer = new lP(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = S6(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let n = e.view.viewport;
    return !hr.eq(this.markers, r, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class lP {
  constructor(e, r, n, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, n, i);
  }
  update(e, r, n, i) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), oZ(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let n = "cm-gutterElement", i = this.dom.firstChild;
    for (let o = 0, s = 0; ; ) {
      let a = s, l = o < r.length ? r[o++] : null, u = !1;
      if (l) {
        let c = l.elementClass;
        c && (n += " " + c);
        for (let h = s; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            a = h, u = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; s < a; ) {
        let c = this.markers[s++];
        if (c.toDOM) {
          c.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), u && s++;
    }
    this.dom.className = n, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function oZ(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const sZ = /* @__PURE__ */ Le.define(), aZ = /* @__PURE__ */ Le.define(), Tf = /* @__PURE__ */ Le.define({
  combine(t) {
    return iu(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let n = Object.assign({}, e);
        for (let i in r) {
          let o = n[i], s = r[i];
          n[i] = o ? (a, l, u) => o(a, l, u) || s(a, l, u) : s;
        }
        return n;
      }
    });
  }
});
class A2 extends sc {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function E2(t, e) {
  return t.state.facet(Tf).formatNumber(e, t.state);
}
const lZ = /* @__PURE__ */ $y.compute([Tf], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(sZ);
  },
  lineMarker(e, r, n) {
    return n.some((i) => i.toDOM) ? null : new A2(E2(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: (e, r, n) => {
    for (let i of e.state.facet(aZ)) {
      let o = i(e, r, n);
      if (o)
        return o;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Tf) != e.state.facet(Tf),
  initialSpacer(e) {
    return new A2(E2(e, E6(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let n = E2(r.view, E6(r.view.state.doc.lines));
    return n == e.number ? e : new A2(n);
  },
  domEventHandlers: t.facet(Tf).domEventHandlers,
  side: "before"
}));
function uZ(t = {}) {
  return [
    Tf.of(t),
    rZ(),
    lZ
  ];
}
function E6(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const cZ = /* @__PURE__ */ new class extends sc {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), hZ = /* @__PURE__ */ Ny.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.head).from;
    i > r && (r = i, e.push(cZ.range(i)));
  }
  return hr.of(e);
});
function fZ() {
  return hZ;
}
const uP = 1024;
let dZ = 0;
class D2 {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class Pt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = dZ++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    }), this.combine = e.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = uo.match(e)), (r) => {
      let n = e(r);
      return n === void 0 ? null : [this, n];
    };
  }
}
Pt.closedBy = new Pt({ deserialize: (t) => t.split(" ") });
Pt.openedBy = new Pt({ deserialize: (t) => t.split(" ") });
Pt.group = new Pt({ deserialize: (t) => t.split(" ") });
Pt.isolate = new Pt({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Pt.contextHash = new Pt({ perNode: !0 });
Pt.lookAhead = new Pt({ perNode: !0 });
Pt.mounted = new Pt({ perNode: !0 });
class p1 {
  constructor(e, r, n) {
    this.tree = e, this.overlay = r, this.parser = n;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Pt.mounted.id];
  }
}
const pZ = /* @__PURE__ */ Object.create(null);
class uo {
  /**
  @internal
  */
  constructor(e, r, n, i = 0) {
    this.name = e, this.props = r, this.id = n, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : pZ, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new uo(e.name || "", r, e.id, n);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(i)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[o[0].id] = o[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(Pt.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let i of n.split(" "))
        r[i] = e[n];
    return (n) => {
      for (let i = n.prop(Pt.group), o = -1; o < (i ? i.length : 0); o++) {
        let s = r[o < 0 ? n.name : i[o]];
        if (s)
          return s;
      }
    };
  }
}
uo.none = new uo(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class h4 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let r = [];
    for (let n of this.types) {
      let i = null;
      for (let o of e) {
        let s = o(n);
        if (s) {
          i || (i = Object.assign({}, n.props));
          let a = s[1], l = s[0];
          l.combine && l.id in i && (a = l.combine(i[l.id], a)), i[l.id] = a;
        }
      }
      r.push(i ? new uo(n.name, i, n.id, n.flags) : n);
    }
    return new h4(r);
  }
}
const $v = /* @__PURE__ */ new WeakMap(), D6 = /* @__PURE__ */ new WeakMap();
var Nn;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Nn || (Nn = {}));
class xn {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, n, i, o) {
    if (this.type = e, this.children = r, this.positions = n, this.length = i, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of o)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = p1.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let n of this.children) {
      let i = n.toString();
      i && (r && (r += ","), r += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new eC(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, n = 0) {
    let i = $v.get(this) || this.topNode, o = new eC(i);
    return o.moveTo(e, r), $v.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new vs(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let n = rg($v.get(this) || this.topNode, e, r, !1);
    return $v.set(this, n), n;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let n = rg(D6.get(this) || this.topNode, e, r, !0);
    return D6.set(this, n), n;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return vZ(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: n, from: i = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & Nn.IncludeAnonymous) > 0;
    for (let l = this.cursor(s | Nn.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= o && l.to >= i && (!a && l.type.isAnonymous || r(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && n && (a || !l.type.isAnonymous) && n(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : p4(uo.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, n, i) => new xn(this.type, r, n, i, this.propValues), e.makeTree || ((r, n, i) => new xn(uo.none, r, n, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return yZ(e);
  }
}
xn.empty = new xn(uo.none, [], [], 0);
class f4 {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new f4(this.buffer, this.index);
  }
}
class ac {
  /**
  Create a tree buffer.
  */
  constructor(e, r, n) {
    this.buffer = e, this.length = r, this.set = n;
  }
  /**
  @internal
  */
  get type() {
    return uo.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], n = this.buffer[e + 3], i = this.set.types[r], o = i.name;
    if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, n == e)
      return o;
    let s = [];
    for (; e < n; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, n, i, o) {
    let { buffer: s } = this, a = -1;
    for (let l = e; l != r && !(cP(o, i, s[l + 1], s[l + 2]) && (a = l, n > 0)); l = s[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, r, n) {
    let i = this.buffer, o = new Uint16Array(r - e), s = 0;
    for (let a = e, l = 0; a < r; ) {
      o[l++] = i[a++], o[l++] = i[a++] - n;
      let u = o[l++] = i[a++] - n;
      o[l++] = i[a++] - e, s = Math.max(s, u);
    }
    return new ac(o, s, this.set);
  }
}
function cP(t, e, r, n) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return n >= e && r < e;
    case 0:
      return r < e && n > e;
    case 1:
      return r <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function rg(t, e, r, n) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let s = !n && t instanceof vs && t.index < 0 ? null : t.parent;
    if (!s)
      return t;
    t = s;
  }
  let o = n ? 0 : Nn.IgnoreOverlays;
  if (n)
    for (let s = t, a = s.parent; a; s = a, a = s.parent)
      s instanceof vs && s.index < 0 && ((i = a.enter(e, r, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t = a);
  for (; ; ) {
    let s = t.enter(e, r, o);
    if (!s)
      return t;
    t = s;
  }
}
class hP {
  cursor(e = 0) {
    return new eC(this, e);
  }
  getChild(e, r = null, n = null) {
    let i = O6(this, e, r, n);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, n = null) {
    return O6(this, e, r, n);
  }
  resolve(e, r = 0) {
    return rg(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return rg(this, e, r, !0);
  }
  matchContext(e) {
    return Z3(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), n = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to)
        break;
      i.type.isError && i.from == i.to ? (n = r, r = i.prevSibling) : r = i;
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class vs extends hP {
  constructor(e, r, n, i) {
    super(), this._tree = e, this.from = r, this.index = n, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, n, i, o = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: l } = s._tree, u = r > 0 ? a.length : -1; e != u; e += r) {
        let c = a[e], h = l[e] + s.from;
        if (cP(i, n, h, h + c.length)) {
          if (c instanceof ac) {
            if (o & Nn.ExcludeBuffers)
              continue;
            let d = c.findChild(0, c.buffer.length, r, n - h, i);
            if (d > -1)
              return new Nu(new mZ(s, c, e, h), null, d);
          } else if (o & Nn.IncludeAnonymous || !c.type.isAnonymous || d4(c)) {
            let d;
            if (!(o & Nn.IgnoreMounts) && (d = p1.get(c)) && !d.overlay)
              return new vs(d.tree, h, e, s);
            let p = new vs(c, h, e, s);
            return o & Nn.IncludeAnonymous || !p.type.isAnonymous ? p : p.nextChild(r < 0 ? c.children.length - 1 : 0, r, n, i);
          }
        }
      }
      if (o & Nn.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + r : e = r < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    let i;
    if (!(n & Nn.IgnoreOverlays) && (i = p1.get(this._tree)) && i.overlay) {
      let o = e - this.from;
      for (let { from: s, to: a } of i.overlay)
        if ((r > 0 ? s <= o : s < o) && (r < 0 ? a >= o : a > o))
          return new vs(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function O6(t, e, r, n) {
  let i = t.cursor(), o = [];
  if (!i.firstChild())
    return o;
  if (r != null) {
    for (let s = !1; !s; )
      if (s = i.type.is(r), !i.nextSibling())
        return o;
  }
  for (; ; ) {
    if (n != null && i.type.is(n))
      return o;
    if (i.type.is(e) && o.push(i.node), !i.nextSibling())
      return n == null ? o : [];
  }
}
function Z3(t, e, r = e.length - 1) {
  for (let n = t; r >= 0; n = n.parent) {
    if (!n)
      return !1;
    if (!n.type.isAnonymous) {
      if (e[r] && e[r] != n.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class mZ {
  constructor(e, r, n, i) {
    this.parent = e, this.buffer = r, this.index = n, this.start = i;
  }
}
class Nu extends hP {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, n) {
    super(), this.context = e, this._parent = r, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, r, n) {
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, n);
    return o < 0 ? null : new Nu(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    if (n & Nn.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return o < 0 ? null : new Nu(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Nu(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new Nu(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: n } = this.context, i = this.index + 4, o = n.buffer[this.index + 3];
    if (o > i) {
      let s = n.buffer[this.index + 1];
      e.push(n.slice(i, o, s)), r.push(0);
    }
    return new xn(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function fP(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let o = 1; o < t.length; o++) {
    let s = t[o];
    (s.from > r.from || s.to < r.to) && (r = s, e = o);
  }
  let n = r instanceof vs && r.index < 0 ? null : r.parent, i = t.slice();
  return n ? i[e] = n : i.splice(e, 1), new gZ(i, r);
}
class gZ {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return fP(this.heads);
  }
}
function vZ(t, e, r) {
  let n = t.resolveInner(e, r), i = null;
  for (let o = n instanceof vs ? n : n.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let s = o.parent;
      (i || (i = [n])).push(s.resolve(e, r)), o = s;
    } else {
      let s = p1.get(o.tree);
      if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
        let a = new vs(s.tree, s.overlay[0].from + o.from, -1, o);
        (i || (i = [n])).push(rg(a, e, r, !1));
      }
    }
  return i ? fP(i) : n;
}
class eC {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof vs)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: n, buffer: i } = this.buffer;
    return this.type = r || i.set.types[i.buffer[e]], this.from = n + i.buffer[e + 1], this.to = n + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof vs ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, n, this.mode));
    let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, n);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, n = this.mode) {
    return this.buffer ? n & Nn.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, n));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Nn.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Nn.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let i = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != i)
        return this.yieldBuf(r.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (n < 0 ? r.buffer.length : r.buffer[this.stack[n] + 3]))
        return this.yieldBuf(i);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, n, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (i.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: r, parent: n } = i);
    } else
      ({ index: r, _parent: n } = this._tree);
    for (; n; { index: r, _parent: n } = n)
      if (r > -1)
        for (let o = r + e, s = e < 0 ? -1 : n._tree.children.length; o != s; o += e) {
          let a = n._tree.children[o];
          if (this.mode & Nn.IncludeAnonymous || a instanceof ac || !a.type.isAnonymous || d4(a))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, n = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, o = this.stack.length; o >= 0; ) {
        for (let s = e; s; s = s._parent)
          if (s.index == i) {
            if (i == this.index)
              return s;
            r = s, n = o + 1;
            break e;
          }
        i = this.stack[--o];
      }
    for (let i = n; i < this.stack.length; i++)
      r = new Nu(this.buffer, r, this.stack[i]);
    return this.bufferNode = new Nu(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let n = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && r && r(this), i = this.type.isAnonymous, !n)
          return;
        if (this.nextSibling())
          break;
        this.parent(), n--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contextâ€”a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Z3(this.node.parent, e);
    let { buffer: r } = this.buffer, { types: n } = r.set;
    for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0)
        return Z3(this._tree, e, i);
      let s = n[r.buffer[this.stack[o]]];
      if (!s.isAnonymous) {
        if (e[i] && e[i] != s.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function d4(t) {
  return t.children.some((e) => e instanceof ac || !e.type.isAnonymous || d4(e));
}
function yZ(t) {
  var e;
  let { buffer: r, nodeSet: n, maxBufferLength: i = uP, reused: o = [], minRepeatType: s = n.types.length } = t, a = Array.isArray(r) ? new f4(r, r.length) : r, l = n.types, u = 0, c = 0;
  function h(_, D, A, O, M, z) {
    let { id: R, start: N, end: I, size: B } = a, $ = c, q = u;
    if (B < 0)
      if (a.next(), B == -1) {
        let ie = o[R];
        A.push(ie), O.push(N - _);
        return;
      } else if (B == -3) {
        u = R;
        return;
      } else if (B == -4) {
        c = R;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${B}`);
    let U = l[R], H, G, re = N - _;
    if (I - N <= i && (G = y(a.pos - D, M))) {
      let ie = new Uint16Array(G.size - G.skip), se = a.pos - G.size, ne = ie.length;
      for (; a.pos > se; )
        ne = b(G.start, ie, ne);
      H = new ac(ie, I - G.start, n), re = G.start - _;
    } else {
      let ie = a.pos - B;
      a.next();
      let se = [], ne = [], ce = R >= s ? R : -1, Ce = 0, Pe = I;
      for (; a.pos > ie; )
        ce >= 0 && a.id == ce && a.size >= 0 ? (a.end <= Pe - i && (g(se, ne, N, Ce, a.end, Pe, ce, $, q), Ce = se.length, Pe = a.end), a.next()) : z > 2500 ? d(N, ie, se, ne) : h(N, ie, se, ne, ce, z + 1);
      if (ce >= 0 && Ce > 0 && Ce < se.length && g(se, ne, N, Ce, N, Pe, ce, $, q), se.reverse(), ne.reverse(), ce > -1 && Ce > 0) {
        let Me = p(U, q);
        H = p4(U, se, ne, 0, se.length, 0, I - N, Me, Me);
      } else
        H = v(U, se, ne, I - N, $ - I, q);
    }
    A.push(H), O.push(re);
  }
  function d(_, D, A, O) {
    let M = [], z = 0, R = -1;
    for (; a.pos > D; ) {
      let { id: N, start: I, end: B, size: $ } = a;
      if ($ > 4)
        a.next();
      else {
        if (R > -1 && I < R)
          break;
        R < 0 && (R = B - i), M.push(N, I, B), z++, a.next();
      }
    }
    if (z) {
      let N = new Uint16Array(z * 4), I = M[M.length - 2];
      for (let B = M.length - 3, $ = 0; B >= 0; B -= 3)
        N[$++] = M[B], N[$++] = M[B + 1] - I, N[$++] = M[B + 2] - I, N[$++] = $;
      A.push(new ac(N, M[2] - I, n)), O.push(I - _);
    }
  }
  function p(_, D) {
    return (A, O, M) => {
      let z = 0, R = A.length - 1, N, I;
      if (R >= 0 && (N = A[R]) instanceof xn) {
        if (!R && N.type == _ && N.length == M)
          return N;
        (I = N.prop(Pt.lookAhead)) && (z = O[R] + N.length + I);
      }
      return v(_, A, O, M, z, D);
    };
  }
  function g(_, D, A, O, M, z, R, N, I) {
    let B = [], $ = [];
    for (; _.length > O; )
      B.push(_.pop()), $.push(D.pop() + A - M);
    _.push(v(n.types[R], B, $, z - M, N - z, I)), D.push(M - A);
  }
  function v(_, D, A, O, M, z, R) {
    if (z) {
      let N = [Pt.contextHash, z];
      R = R ? [N].concat(R) : [N];
    }
    if (M > 25) {
      let N = [Pt.lookAhead, M];
      R = R ? [N].concat(R) : [N];
    }
    return new xn(_, D, A, O, R);
  }
  function y(_, D) {
    let A = a.fork(), O = 0, M = 0, z = 0, R = A.end - i, N = { size: 0, start: 0, skip: 0 };
    e: for (let I = A.pos - _; A.pos > I; ) {
      let B = A.size;
      if (A.id == D && B >= 0) {
        N.size = O, N.start = M, N.skip = z, z += 4, O += 4, A.next();
        continue;
      }
      let $ = A.pos - B;
      if (B < 0 || $ < I || A.start < R)
        break;
      let q = A.id >= s ? 4 : 0, U = A.start;
      for (A.next(); A.pos > $; ) {
        if (A.size < 0)
          if (A.size == -3)
            q += 4;
          else
            break e;
        else A.id >= s && (q += 4);
        A.next();
      }
      M = U, O += B, z += q;
    }
    return (D < 0 || O == _) && (N.size = O, N.start = M, N.skip = z), N.size > 4 ? N : void 0;
  }
  function b(_, D, A) {
    let { id: O, start: M, end: z, size: R } = a;
    if (a.next(), R >= 0 && O < s) {
      let N = A;
      if (R > 4) {
        let I = a.pos - (R - 4);
        for (; a.pos > I; )
          A = b(_, D, A);
      }
      D[--A] = N, D[--A] = z - _, D[--A] = M - _, D[--A] = O;
    } else R == -3 ? u = O : R == -4 && (c = O);
    return A;
  }
  let k = [], C = [];
  for (; a.pos > 0; )
    h(t.start || 0, t.bufferStart || 0, k, C, -1, 0);
  let S = (e = t.length) !== null && e !== void 0 ? e : k.length ? C[0] + k[0].length : 0;
  return new xn(l[t.topID], k.reverse(), C.reverse(), S);
}
const F6 = /* @__PURE__ */ new WeakMap();
function Iy(t, e) {
  if (!t.isAnonymous || e instanceof ac || e.type != t)
    return 1;
  let r = F6.get(e);
  if (r == null) {
    r = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof xn)) {
        r = 1;
        break;
      }
      r += Iy(t, n);
    }
    F6.set(e, r);
  }
  return r;
}
function p4(t, e, r, n, i, o, s, a, l) {
  let u = 0;
  for (let g = n; g < i; g++)
    u += Iy(t, e[g]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], d = [];
  function p(g, v, y, b, k) {
    for (let C = y; C < b; ) {
      let S = C, _ = v[C], D = Iy(t, g[C]);
      for (C++; C < b; C++) {
        let A = Iy(t, g[C]);
        if (D + A >= c)
          break;
        D += A;
      }
      if (C == S + 1) {
        if (D > c) {
          let A = g[S];
          p(A.children, A.positions, 0, A.children.length, v[S] + k);
          continue;
        }
        h.push(g[S]);
      } else {
        let A = v[C - 1] + g[C - 1].length - _;
        h.push(p4(t, g, v, S, C, _, A, null, l));
      }
      d.push(_ + k - o);
    }
  }
  return p(e, r, n, i, 0), (a || l)(h, d, s);
}
class ih {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, n, i, o = !1, s = !1) {
    this.from = e, this.to = r, this.tree = n, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], n = !1) {
    let i = [new ih(0, e.length, e, 0, !1, n)];
    for (let o of r)
      o.to > e.length && i.push(o);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, n = 128) {
    if (!r.length)
      return e;
    let i = [], o = 1, s = e.length ? e[0] : null;
    for (let a = 0, l = 0, u = 0; ; a++) {
      let c = a < r.length ? r[a] : null, h = c ? c.fromA : 1e9;
      if (h - l >= n)
        for (; s && s.from < h; ) {
          let d = s;
          if (l >= d.from || h <= d.to || u) {
            let p = Math.max(d.from, l) - u, g = Math.min(d.to, h) - u;
            d = p >= g ? null : new ih(p, g, d.tree, d.offset + u, a > 0, !!c);
          }
          if (d && i.push(d), s.to > h)
            break;
          s = o < e.length ? e[o++] : null;
        }
      if (!c)
        break;
      l = c.toA, u = c.toA - c.toB;
    }
    return i;
  }
}
let dP = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, r) {
    return typeof t == "string" && (t = new bZ(t)), r = r ? r.length ? r.map((n) => new D2(n.from, n.to)) : [new D2(0, 0)] : [new D2(0, t.length)], this.createParse(t, e || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, r) {
    let n = this.startParse(t, e, r);
    for (; ; ) {
      let i = n.advance();
      if (i)
        return i;
    }
  }
};
class bZ {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
new Pt({ perNode: !0 });
let xZ = 0;
class hs {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.name = e, this.set = r, this.base = n, this.modified = i, this.id = xZ++;
  }
  toString() {
    let { name: e } = this;
    for (let r of this.modified)
      r.name && (e = `${r.name}(${e})`);
    return e;
  }
  static define(e, r) {
    let n = typeof e == "string" ? e : "?";
    if (e instanceof hs && (r = e), r?.base)
      throw new Error("Can not derive from a modified tag");
    let i = new hs(n, [], null, []);
    if (i.set.push(i), r)
      for (let o of r.set)
        i.set.push(o);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let r = new m1(e);
    return (n) => n.modified.indexOf(r) > -1 ? n : m1.get(n.base || n, n.modified.concat(r).sort((i, o) => i.id - o.id));
  }
}
let wZ = 0;
class m1 {
  constructor(e) {
    this.name = e, this.instances = [], this.id = wZ++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let n = r[0].instances.find((a) => a.base == e && kZ(r, a.modified));
    if (n)
      return n;
    let i = [], o = new hs(e.name, i, e, r);
    for (let a of r)
      a.instances.push(o);
    let s = CZ(r);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of s)
          i.push(m1.get(a, l));
    return o;
  }
}
function kZ(t, e) {
  return t.length == e.length && t.every((r, n) => r == e[n]);
}
function CZ(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let n = 0, i = e.length; n < i; n++)
      e.push(e[n].concat(t[r]));
  return e.sort((r, n) => n.length - r.length);
}
function m4(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let n = t[r];
    Array.isArray(n) || (n = [n]);
    for (let i of r.split(" "))
      if (i) {
        let o = [], s = 2, a = i;
        for (let h = 0; ; ) {
          if (a == "..." && h > 0 && h + 3 == i.length) {
            s = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + i);
          if (o.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), h += d[0].length, h == i.length)
            break;
          let p = i[h++];
          if (h == i.length && p == "!") {
            s = 0;
            break;
          }
          if (p != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(h);
        }
        let l = o.length - 1, u = o[l];
        if (!u)
          throw new RangeError("Invalid path: " + i);
        let c = new ng(n, s, l > 0 ? o.slice(0, l) : null);
        e[u] = c.sort(e[u]);
      }
  }
  return pP.add(e);
}
const pP = new Pt({
  combine(t, e) {
    let r, n, i;
    for (; t || e; ) {
      if (!t || e && t.depth >= e.depth ? (i = e, e = e.next) : (i = t, t = t.next), r && r.mode == i.mode && !i.context && !r.context)
        continue;
      let o = new ng(i.tags, i.mode, i.context);
      r ? r.next = o : n = o, r = o;
    }
    return n;
  }
});
let ng = class {
  constructor(t, e, r, n) {
    this.tags = t, this.mode = e, this.context = r, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
ng.empty = new ng([], 2, null);
function mP(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let o of t)
    if (!Array.isArray(o.tag))
      r[o.tag.id] = o.class;
    else
      for (let s of o.tag)
        r[s.id] = o.class;
  let { scope: n, all: i = null } = e || {};
  return {
    style: (o) => {
      let s = i;
      for (let a of o)
        for (let l of a.set) {
          let u = r[l.id];
          if (u) {
            s = s ? s + " " + u : u;
            break;
          }
        }
      return s;
    },
    scope: n
  };
}
function _Z(t, e) {
  let r = null;
  for (let n of t) {
    let i = n.style(e);
    i && (r = r ? r + " " + i : i);
  }
  return r;
}
function SZ(t, e, r, n = 0, i = t.length) {
  let o = new AZ(n, Array.isArray(e) ? e : [e], r);
  o.highlightRange(t.cursor(), n, i, "", o.highlighters), o.flush(i);
}
class AZ {
  constructor(e, r, n) {
    this.at = e, this.highlighters = r, this.span = n, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, n, i, o) {
    let { type: s, from: a, to: l } = e;
    if (a >= n || l <= r)
      return;
    s.isTop && (o = this.highlighters.filter((p) => !p.scope || p.scope(s)));
    let u = i, c = EZ(e) || ng.empty, h = _Z(o, c.tags);
    if (h && (u && (u += " "), u += h, c.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(r, a), u), c.opaque)
      return;
    let d = e.tree && e.tree.prop(Pt.mounted);
    if (d && d.overlay) {
      let p = e.node.enter(d.overlay[0].from + a, 1), g = this.highlighters.filter((y) => !y.scope || y.scope(d.tree.type)), v = e.firstChild();
      for (let y = 0, b = a; ; y++) {
        let k = y < d.overlay.length ? d.overlay[y] : null, C = k ? k.from + a : l, S = Math.max(r, b), _ = Math.min(n, C);
        if (S < _ && v)
          for (; e.from < _ && (this.highlightRange(e, S, _, i, o), this.startSpan(Math.min(_, e.to), u), !(e.to >= C || !e.nextSibling())); )
            ;
        if (!k || C > n)
          break;
        b = k.to + a, b > r && (this.highlightRange(p.cursor(), Math.max(r, k.from + a), Math.min(n, b), "", g), this.startSpan(Math.min(n, b), u));
      }
      v && e.parent();
    } else if (e.firstChild()) {
      d && (i = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, r, n, i, o), this.startSpan(Math.min(n, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function EZ(t) {
  let e = t.type.prop(pP);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const Re = hs.define, Iv = Re(), Su = Re(), T6 = Re(Su), M6 = Re(Su), Au = Re(), Bv = Re(Au), O2 = Re(Au), ga = Re(), Fc = Re(ga), pa = Re(), ma = Re(), tC = Re(), Kp = Re(tC), Lv = Re(), oe = {
  /**
  A comment.
  */
  comment: Iv,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Re(Iv),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Re(Iv),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Re(Iv),
  /**
  Any kind of identifier.
  */
  name: Su,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Re(Su),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: T6,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Re(T6),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: M6,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Re(M6),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Re(Su),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Re(Su),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Re(Su),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Re(Su),
  /**
  A literal value.
  */
  literal: Au,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Bv,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Re(Bv),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Re(Bv),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Re(Bv),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: O2,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Re(O2),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Re(O2),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Re(Au),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Re(Au),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Re(Au),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Re(Au),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Re(Au),
  /**
  A language keyword.
  */
  keyword: pa,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Re(pa),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Re(pa),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Re(pa),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Re(pa),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Re(pa),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Re(pa),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Re(pa),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Re(pa),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Re(pa),
  /**
  An operator.
  */
  operator: ma,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Re(ma),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Re(ma),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Re(ma),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Re(ma),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Re(ma),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Re(ma),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Re(ma),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Re(ma),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Re(ma),
  /**
  Program or markup punctuation.
  */
  punctuation: tC,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Re(tC),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Kp,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Re(Kp),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Re(Kp),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Re(Kp),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Re(Kp),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: ga,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Fc,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Re(Fc),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Re(Fc),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Re(Fc),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Re(Fc),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Re(Fc),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Re(Fc),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: Re(ga),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Re(ga),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Re(ga),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Re(ga),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Re(ga),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Re(ga),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Re(ga),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Re(ga),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Re(),
  /**
  Deleted text.
  */
  deleted: Re(),
  /**
  Changed text.
  */
  changed: Re(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Re(),
  /**
  Metadata or meta-instruction.
  */
  meta: Lv,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Re(Lv),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Re(Lv),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Re(Lv),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: hs.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: hs.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: hs.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: hs.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: hs.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: hs.defineModifier("special")
};
for (let t in oe) {
  let e = oe[t];
  e instanceof hs && (e.name = t);
}
mP([
  { tag: oe.link, class: "tok-link" },
  { tag: oe.heading, class: "tok-heading" },
  { tag: oe.emphasis, class: "tok-emphasis" },
  { tag: oe.strong, class: "tok-strong" },
  { tag: oe.keyword, class: "tok-keyword" },
  { tag: oe.atom, class: "tok-atom" },
  { tag: oe.bool, class: "tok-bool" },
  { tag: oe.url, class: "tok-url" },
  { tag: oe.labelName, class: "tok-labelName" },
  { tag: oe.inserted, class: "tok-inserted" },
  { tag: oe.deleted, class: "tok-deleted" },
  { tag: oe.literal, class: "tok-literal" },
  { tag: oe.string, class: "tok-string" },
  { tag: oe.number, class: "tok-number" },
  { tag: [oe.regexp, oe.escape, oe.special(oe.string)], class: "tok-string2" },
  { tag: oe.variableName, class: "tok-variableName" },
  { tag: oe.local(oe.variableName), class: "tok-variableName tok-local" },
  { tag: oe.definition(oe.variableName), class: "tok-variableName tok-definition" },
  { tag: oe.special(oe.variableName), class: "tok-variableName2" },
  { tag: oe.definition(oe.propertyName), class: "tok-propertyName tok-definition" },
  { tag: oe.typeName, class: "tok-typeName" },
  { tag: oe.namespace, class: "tok-namespace" },
  { tag: oe.className, class: "tok-className" },
  { tag: oe.macroName, class: "tok-macroName" },
  { tag: oe.propertyName, class: "tok-propertyName" },
  { tag: oe.operator, class: "tok-operator" },
  { tag: oe.comment, class: "tok-comment" },
  { tag: oe.meta, class: "tok-meta" },
  { tag: oe.invalid, class: "tok-invalid" },
  { tag: oe.punctuation, class: "tok-punctuation" }
]);
var F2;
const Mf = /* @__PURE__ */ new Pt();
function DZ(t) {
  return Le.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const OZ = /* @__PURE__ */ new Pt();
class Hs {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, n = [], i = "") {
    this.data = e, this.name = i, nr.prototype.hasOwnProperty("tree") || Object.defineProperty(nr.prototype, "tree", { get() {
      return Dn(this);
    } }), this.parser = r, this.extension = [
      _d.of(this),
      nr.languageData.of((o, s, a) => {
        let l = P6(o, s, a), u = l.type.prop(Mf);
        if (!u)
          return [];
        let c = o.facet(u), h = l.type.prop(OZ);
        if (h) {
          let d = l.resolve(s - l.from, a);
          for (let p of h)
            if (p.test(d, o)) {
              let g = o.facet(p.facet);
              return p.type == "replace" ? g : g.concat(c);
            }
        }
        return c;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, n = -1) {
    return P6(e, r, n).type.prop(Mf) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(_d);
    if (r?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let n = [], i = (o, s) => {
      if (o.prop(Mf) == this.data) {
        n.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(Pt.mounted);
      if (a) {
        if (a.tree.prop(Mf) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              n.push({ from: l.from + s, to: l.to + s });
          else
            n.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let l = n.length;
          if (i(a.tree, a.overlay[0].from + s), n.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let u = o.children[l];
        u instanceof xn && i(u, o.positions[l] + s);
      }
    };
    return i(Dn(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Hs.setState = /* @__PURE__ */ _t.define();
function P6(t, e, r) {
  let n = t.facet(_d), i = Dn(t).topNode;
  if (!n || n.allowsNesting)
    for (let o = i; o; o = o.enter(e, r, Nn.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
class ig extends Hs {
  constructor(e, r, n) {
    super(e, r, [], n), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let r = DZ(e.languageData);
    return new ig(r, e.parser.configure({
      props: [Mf.add((n) => n.isTop ? r : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, r) {
    return new ig(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Dn(t) {
  let e = t.field(Hs.state, !1);
  return e ? e.tree : xn.empty;
}
class FZ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let n = this.cursorPos - this.string.length;
    return e < n || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - n, r - n);
  }
}
let Qp = null;
class g1 {
  constructor(e, r, n = [], i, o, s, a, l) {
    this.parser = e, this.state = r, this.fragments = n, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new g1(e, r, [], xn.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new FZ(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != xn.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(ih.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(ih.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = Qp;
    Qp = this;
    try {
      return e();
    } finally {
      Qp = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = R6(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: n, tree: i, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, c, h, d) => l.push({ fromA: u, toA: c, fromB: h, toB: d })), n = ih.applyChanges(n, l), i = xn.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let u of this.skipped) {
          let c = e.mapPos(u.from, 1), h = e.mapPos(u.to, -1);
          c < h && a.push({ from: c, to: h });
        }
      }
    }
    return new g1(this.parser, r, n, i, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: i, to: o } = this.skipped[n];
      i < e.to && o > e.from && (this.fragments = R6(this.fragments, i, o), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends dP {
      createParse(r, n, i) {
        let o = i[0].from, s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let a = Qp;
            if (a) {
              for (let l of i)
                a.tempSkipped.push(l);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new xn(uo.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Qp;
  }
}
function R6(t, e, r) {
  return ih.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class Cd {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, n) || r.takeTree(), new Cd(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), n = g1.create(e.facet(_d).parser, e, { from: 0, to: r });
    return n.work(20, r) || n.takeTree(), new Cd(n);
  }
}
Hs.state = /* @__PURE__ */ jn.define({
  create: Cd.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(Hs.setState))
        return r.value;
    return e.startState.facet(_d) != e.state.facet(_d) ? Cd.init(e.state) : t.apply(e);
  }
});
let gP = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (gP = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const T2 = typeof navigator < "u" && !((F2 = navigator.scheduling) === null || F2 === void 0) && F2.isInputPending ? () => navigator.scheduling.isInputPending() : null, TZ = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Hs.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Hs.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = gP(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: n } } = this.view, i = r.field(Hs.state);
    if (i.tree == i.context.tree && i.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, t && !T2 ? Math.max(25, t.timeRemaining() - 5) : 1e9), s = i.context.treeLen < n && r.doc.length > n + 1e3, a = i.context.work(() => T2 && T2() || Date.now() > o, n + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (a || this.chunkBudget <= 0) && (i.context.takeTree(), this.view.dispatch({ effects: Hs.setState.of(new Cd(i.context)) })), this.chunkBudget > 0 && !(a && !s) && this.scheduleWork(), this.checkAsyncSchedule(i.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Pi(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), _d = /* @__PURE__ */ Le.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    Hs.state,
    TZ,
    Be.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
class vP {
  /**
  Create a language support object.
  */
  constructor(e, r = []) {
    this.language = e, this.support = r, this.extension = [e, r];
  }
}
const MZ = /* @__PURE__ */ Le.define(), Bb = /* @__PURE__ */ Le.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function v1(t) {
  let e = t.facet(Bb);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function og(t, e) {
  let r = "", n = t.tabSize, i = t.facet(Bb)[0];
  if (i == "	") {
    for (; e >= n; )
      r += "	", e -= n;
    i = " ";
  }
  for (let o = 0; o < e; o++)
    r += i;
  return r;
}
function g4(t, e) {
  t instanceof nr && (t = new Lb(t));
  for (let n of t.state.facet(MZ)) {
    let i = n(t, e);
    if (i !== void 0)
      return i;
  }
  let r = Dn(t.state);
  return r.length >= e ? PZ(t, r, e) : null;
}
class Lb {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = v1(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= n.from && i <= n.to ? o && i == e ? { text: "", from: e } : (r < 0 ? i < e : i <= e) ? { text: n.text.slice(i - n.from), from: i } : { text: n.text.slice(0, i - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: i } = this.lineAt(e, r);
    return n.slice(e - i, Math.min(n.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), o = this.countColumn(n, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return s > -1 && (o += s - this.countColumn(n, n.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return Xd(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), o = this.options.overrideIndentation;
    if (o) {
      let s = o(i);
      if (s > -1)
        return s;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const v4 = /* @__PURE__ */ new Pt();
function PZ(t, e, r) {
  let n = e.resolveStack(r), i = e.resolveInner(r, -1).resolve(r, 0).enterUnfinishedNodesBefore(r);
  if (i != n.node) {
    let o = [];
    for (let s = i; s && !(s.from < n.node.from || s.to > n.node.to || s.from == n.node.from && s.type == n.node.type); s = s.parent)
      o.push(s);
    for (let s = o.length - 1; s >= 0; s--)
      n = { node: o[s], next: n };
  }
  return yP(n, t, r);
}
function yP(t, e, r) {
  for (let n = t; n; n = n.next) {
    let i = NZ(n.node);
    if (i)
      return i(y4.create(e, r, n));
  }
  return 0;
}
function RZ(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function NZ(t) {
  let e = t.type.prop(v4);
  if (e)
    return e;
  let r = t.firstChild, n;
  if (r && (n = r.type.prop(Pt.closedBy))) {
    let i = t.lastChild, o = i && n.indexOf(i.name) > -1;
    return (s) => LZ(s, !0, 1, void 0, o && !RZ(s) ? i.from : void 0);
  }
  return t.parent == null ? $Z : null;
}
function $Z() {
  return 0;
}
class y4 extends Lb {
  constructor(e, r, n) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = n;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new y4(e, r, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let n = e.resolve(r.from);
      for (; n.parent && n.parent.from == n.from; )
        n = n.parent;
      if (IZ(n, e))
        break;
      r = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return yP(this.context.next, this.base, this.pos);
  }
}
function IZ(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function BZ(t) {
  let e = t.node, r = e.childAfter(e.from), n = e.lastChild;
  if (!r)
    return null;
  let i = t.options.simulateBreak, o = t.state.doc.lineAt(r.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let a = r.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == n)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= s)
        return null;
      let u = /^ */.exec(o.text.slice(r.to - o.from))[0].length;
      return { from: r.from, to: r.to + u };
    }
    a = l.to;
  }
}
function LZ(t, e, r, n, i) {
  let o = t.textAfter, s = o.match(/^\s*/)[0].length, a = i == t.pos + s, l = BZ(t);
  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * r);
}
function rC({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let n = t && t.test(r.textAfter);
    return r.baseIndent + (n ? 0 : e * r.unit);
  };
}
const zZ = 200;
function jZ() {
  return nr.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: n } = t.newSelection.main, i = r.lineAt(n);
    if (n > i.from + zZ)
      return t;
    let o = r.sliceString(i.from, n);
    if (!e.some((u) => u.test(o)))
      return t;
    let { state: s } = t, a = -1, l = [];
    for (let { head: u } of s.selection.ranges) {
      let c = s.doc.lineAt(u);
      if (c.from == a)
        continue;
      a = c.from;
      let h = g4(s, c.from);
      if (h == null)
        continue;
      let d = /^\s*/.exec(c.text)[0], p = og(s, h);
      d != p && l.push({ from: c.from, to: c.from + d.length, insert: p });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const bP = /* @__PURE__ */ new Pt();
function qZ(t) {
  let e = t.firstChild, r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
class Zg {
  constructor(e, r) {
    this.specs = e;
    let n;
    function i(a) {
      let l = nc.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof r.all == "string" ? r.all : r.all ? i(r.all) : void 0, s = r.scope;
    this.scope = s instanceof Hs ? (a) => a.prop(Mf) == s.data : s ? (a) => a == s : void 0, this.style = mP(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = n ? new nc(n) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new Zg(e, r || {});
  }
}
const nC = /* @__PURE__ */ Le.define(), xP = /* @__PURE__ */ Le.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function M2(t) {
  let e = t.facet(nC);
  return e.length ? e : t.facet(xP);
}
function wP(t, e) {
  let r = [HZ], n;
  return t instanceof Zg && (t.module && r.push(Be.styleModule.of(t.module)), n = t.themeType), e?.fallback ? r.push(xP.of(t)) : n ? r.push(nC.computeN([Be.darkTheme], (i) => i.facet(Be.darkTheme) == (n == "dark") ? [t] : [])) : r.push(nC.of(t)), r;
}
class UZ {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Dn(e.state), this.decorations = this.buildDeco(e, M2(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = Dn(e.state), n = M2(e.state), i = n != M2(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    r.length < o.to && !i && r.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (r != this.tree || e.viewportChanged || i) && (this.tree = r, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = o.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return pt.none;
    let n = new rc();
    for (let { from: i, to: o } of e.visibleRanges)
      SZ(this.tree, r, (s, a, l) => {
        n.add(s, a, this.markCache[l] || (this.markCache[l] = pt.mark({ class: l })));
      }, i, o);
    return n.finish();
  }
}
const HZ = /* @__PURE__ */ pc.high(/* @__PURE__ */ wn.fromClass(UZ, {
  decorations: (t) => t.decorations
})), VZ = /* @__PURE__ */ Zg.define([
  {
    tag: oe.meta,
    color: "#404740"
  },
  {
    tag: oe.link,
    textDecoration: "underline"
  },
  {
    tag: oe.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: oe.emphasis,
    fontStyle: "italic"
  },
  {
    tag: oe.strong,
    fontWeight: "bold"
  },
  {
    tag: oe.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: oe.keyword,
    color: "#708"
  },
  {
    tag: [oe.atom, oe.bool, oe.url, oe.contentSeparator, oe.labelName],
    color: "#219"
  },
  {
    tag: [oe.literal, oe.inserted],
    color: "#164"
  },
  {
    tag: [oe.string, oe.deleted],
    color: "#a11"
  },
  {
    tag: [oe.regexp, oe.escape, /* @__PURE__ */ oe.special(oe.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ oe.definition(oe.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ oe.local(oe.variableName),
    color: "#30a"
  },
  {
    tag: [oe.typeName, oe.namespace],
    color: "#085"
  },
  {
    tag: oe.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ oe.special(oe.variableName), oe.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ oe.definition(oe.propertyName),
    color: "#00c"
  },
  {
    tag: oe.comment,
    color: "#940"
  },
  {
    tag: oe.invalid,
    color: "#f00"
  }
]), WZ = /* @__PURE__ */ Be.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), kP = 1e4, CP = "()[]{}", _P = /* @__PURE__ */ Le.define({
  combine(t) {
    return iu(t, {
      afterCursor: !0,
      brackets: CP,
      maxScanDistance: kP,
      renderMatch: QZ
    });
  }
}), GZ = /* @__PURE__ */ pt.mark({ class: "cm-matchingBracket" }), KZ = /* @__PURE__ */ pt.mark({ class: "cm-nonmatchingBracket" });
function QZ(t) {
  let e = [], r = t.matched ? GZ : KZ;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const XZ = /* @__PURE__ */ jn.define({
  create() {
    return pt.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], n = e.state.facet(_P);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = Pa(e.state, i.head, -1, n) || i.head > 0 && Pa(e.state, i.head - 1, 1, n) || n.afterCursor && (Pa(e.state, i.head, 1, n) || i.head < e.state.doc.length && Pa(e.state, i.head + 1, -1, n));
      o && (r = r.concat(n.renderMatch(o, e.state)));
    }
    return pt.set(r, !0);
  },
  provide: (t) => Be.decorations.from(t)
}), JZ = [
  XZ,
  WZ
];
function YZ(t = {}) {
  return [_P.of(t), JZ];
}
const ZZ = /* @__PURE__ */ new Pt();
function iC(t, e, r) {
  let n = t.prop(e < 0 ? Pt.openedBy : Pt.closedBy);
  if (n)
    return n;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [r[i + e]];
  }
  return null;
}
function oC(t) {
  let e = t.type.prop(ZZ);
  return e ? e(t.node) : t;
}
function Pa(t, e, r, n = {}) {
  let i = n.maxScanDistance || kP, o = n.brackets || CP, s = Dn(t), a = s.resolveInner(e, r);
  for (let l = a; l; l = l.parent) {
    let u = iC(l.type, r, o);
    if (u && l.from < l.to) {
      let c = oC(l);
      if (c && (r > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return eee(t, e, r, l, c, u, o);
    }
  }
  return tee(t, e, r, s, a.type, i, o);
}
function eee(t, e, r, n, i, o, s) {
  let a = n.parent, l = { from: i.from, to: i.to }, u = 0, c = a?.cursor();
  if (c && (r < 0 ? c.childBefore(n.from) : c.childAfter(n.to)))
    do
      if (r < 0 ? c.to <= n.from : c.from >= n.to) {
        if (u == 0 && o.indexOf(c.type.name) > -1 && c.from < c.to) {
          let h = oC(c);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (iC(c.type, r, s))
          u++;
        else if (iC(c.type, -r, s)) {
          if (u == 0) {
            let h = oC(c);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (r < 0 ? c.prevSibling() : c.nextSibling());
  return { start: l, matched: !1 };
}
function tee(t, e, r, n, i, o, s) {
  let a = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = s.indexOf(a);
  if (l < 0 || l % 2 == 0 != r > 0)
    return null;
  let u = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, c = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), h = 0;
  for (let d = 0; !c.next().done && d <= o; ) {
    let p = c.value;
    r < 0 && (d += p.length);
    let g = e + d * r;
    for (let v = r > 0 ? 0 : p.length - 1, y = r > 0 ? p.length : -1; v != y; v += r) {
      let b = s.indexOf(p[v]);
      if (!(b < 0 || n.resolveInner(g + v, 1).type != i))
        if (b % 2 == 0 == r > 0)
          h++;
        else {
          if (h == 1)
            return { start: u, end: { from: g + v, to: g + v + 1 }, matched: b >> 1 == l >> 1 };
          h--;
        }
    }
    r > 0 && (d += p.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const ree = /* @__PURE__ */ Object.create(null), N6 = [uo.none], $6 = [], I6 = /* @__PURE__ */ Object.create(null), nee = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  nee[t] = /* @__PURE__ */ iee(ree, e);
function P2(t, e) {
  $6.indexOf(t) > -1 || ($6.push(t), console.warn(e));
}
function iee(t, e) {
  let r = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let u of a.split(".")) {
      let c = t[u] || oe[u];
      c ? typeof c == "function" ? l.length ? l = l.map(c) : P2(u, `Modifier ${u} used at start of tag`) : l.length ? P2(u, `Tag ${u} used as modifier`) : l = Array.isArray(c) ? c : [c] : P2(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of l)
      r.push(u);
  }
  if (!r.length)
    return 0;
  let n = e.replace(/ /g, "_"), i = n + " " + r.map((a) => a.id), o = I6[i];
  if (o)
    return o.id;
  let s = I6[i] = uo.define({
    id: N6.length,
    name: n,
    props: [m4({ [n]: r })]
  });
  return N6.push(s), s.id;
}
Ir.RTL, Ir.LTR;
class SP {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesâ€”in the editor, the extension will create
  these for you.)
  */
  constructor(e, r, n, i) {
    this.state = e, this.pos = r, this.explicit = n, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = Dn(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), n = Math.max(r.from, this.pos - 250), i = r.text.slice(n - r.from, this.pos - r.from), o = i.search(EP(e, !1));
    return o < 0 ? null : { from: n + o, to: this.pos, text: i.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, r, n) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(r), n && n.onDocChange && (this.abortOnDocChange = !0));
  }
}
function B6(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function oee(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let o = 1; o < i.length; o++)
      r[i[o]] = !0;
  }
  let n = B6(e) + B6(r) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function AP(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [r, n] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : oee(e);
  return (i) => {
    let o = i.matchBefore(n);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: e, validFor: r } : null;
  };
}
function see(t, e) {
  return (r) => {
    for (let n = Dn(r.state).resolveInner(r.pos, -1); n; n = n.parent) {
      if (t.indexOf(n.name) > -1)
        return null;
      if (n.type.isTop)
        break;
    }
    return e(r);
  };
}
class L6 {
  constructor(e, r, n, i) {
    this.completion = e, this.source = r, this.match = n, this.score = i;
  }
}
function oh(t) {
  return t.selection.main.from;
}
function EP(t, e) {
  var r;
  let { source: n } = t, i = e && n[0] != "^", o = n[n.length - 1] != "$";
  return !i && !o ? t : new RegExp(`${i ? "^" : ""}(?:${n})${o ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const b4 = /* @__PURE__ */ nu.define();
function aee(t, e, r, n) {
  let { main: i } = t.selection, o = r - i.from, s = n - i.from;
  return {
    ...t.changeByRange((a) => {
      if (a != i && r != n && t.sliceDoc(a.from + o, a.from + s) != t.sliceDoc(r, n))
        return { range: a };
      let l = t.toText(e);
      return {
        changes: { from: a.from + o, to: n == i.from ? a.to : a.from + s, insert: l },
        range: de.cursor(a.from + o + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const z6 = /* @__PURE__ */ new WeakMap();
function lee(t) {
  if (!Array.isArray(t))
    return t;
  let e = z6.get(t);
  return e || z6.set(t, e = AP(t)), e;
}
const y1 = /* @__PURE__ */ _t.define(), sg = /* @__PURE__ */ _t.define();
class uee {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let n = Ji(e, r), i = Aa(n);
      this.chars.push(n);
      let o = e.slice(r, r + i), s = o.toUpperCase();
      this.folded.push(Ji(s == o ? o.toLowerCase() : s, 0)), r += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: r, folded: n, any: i, precise: o, byWord: s } = this;
    if (r.length == 1) {
      let k = Ji(e, 0), C = Aa(k), S = C == e.length ? 0 : -100;
      if (k != r[0]) if (k == n[0])
        S += -200;
      else
        return null;
      return this.ret(S, [0, C]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = r.length, u = 0;
    if (a < 0) {
      for (let k = 0, C = Math.min(e.length, 200); k < C && u < l; ) {
        let S = Ji(e, k);
        (S == r[u] || S == n[u]) && (i[u++] = k), k += Aa(S);
      }
      if (u < l)
        return null;
    }
    let c = 0, h = 0, d = !1, p = 0, g = -1, v = -1, y = /[a-z]/.test(e), b = !0;
    for (let k = 0, C = Math.min(e.length, 200), S = 0; k < C && h < l; ) {
      let _ = Ji(e, k);
      a < 0 && (c < l && _ == r[c] && (o[c++] = k), p < l && (_ == r[p] || _ == n[p] ? (p == 0 && (g = k), v = k + 1, p++) : p = 0));
      let D, A = _ < 255 ? _ >= 48 && _ <= 57 || _ >= 97 && _ <= 122 ? 2 : _ >= 65 && _ <= 90 ? 1 : 0 : (D = X_(_)) != D.toLowerCase() ? 1 : D != D.toUpperCase() ? 2 : 0;
      (!k || A == 1 && y || S == 0 && A != 0) && (r[h] == _ || n[h] == _ && (d = !0) ? s[h++] = k : s.length && (b = !1)), S = A, k += Aa(_);
    }
    return h == l && s[0] == 0 && b ? this.result(-100 + (d ? -200 : 0), s, e) : p == l && g == 0 ? this.ret(-200 - e.length + (v == e.length ? 0 : -100), [0, v]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : p == l ? this.ret(-900 - e.length, [g, v]) : h == l ? this.result(-100 + (d ? -200 : 0) + -700 + (b ? 0 : -1100), s, e) : r.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, n) {
    let i = [], o = 0;
    for (let s of r) {
      let a = s + (this.astral ? Aa(Ji(n, s)) : 1);
      o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
    }
    return this.ret(e - n.length, i);
  }
}
class cee {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let r = e.slice(0, this.pattern.length), n = r == this.pattern ? 0 : r.toLowerCase() == this.folded ? -200 : null;
    return n == null ? null : (this.matched = [0, r.length], this.score = n + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const In = /* @__PURE__ */ Le.define({
  combine(t) {
    return iu(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: hee,
      filterStrict: !1,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (n) => j6(e(n), r(n)),
      optionClass: (e, r) => (n) => j6(e(n), r(n)),
      addToOptions: (e, r) => e.concat(r),
      filterStrict: (e, r) => e || r
    });
  }
});
function j6(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function hee(t, e, r, n, i, o) {
  let s = t.textDirection == Ir.RTL, a = s, l = !1, u = "top", c, h, d = e.left - i.left, p = i.right - e.right, g = n.right - n.left, v = n.bottom - n.top;
  if (a && d < Math.min(g, p) ? a = !1 : !a && p < Math.min(g, d) && (a = !0), g <= (a ? d : p))
    c = Math.max(i.top, Math.min(r.top, i.bottom - v)) - e.top, h = Math.min(400, a ? d : p);
  else {
    l = !0, h = Math.min(
      400,
      (s ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let k = i.bottom - e.bottom;
    k >= v || k > e.top ? c = r.bottom - e.top : (u = "bottom", c = e.bottom - r.top);
  }
  let y = (e.bottom - e.top) / o.offsetHeight, b = (e.right - e.left) / o.offsetWidth;
  return {
    style: `${u}: ${c / y}px; max-width: ${h / b}px`,
    class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function fee(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), r.type && n.classList.add(...r.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(r, n, i, o) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let a = r.displayLabel || r.label, l = 0;
      for (let u = 0; u < o.length; ) {
        let c = o[u++], h = o[u++];
        c > l && s.appendChild(document.createTextNode(a.slice(l, c)));
        let d = s.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(a.slice(c, h))), d.className = "cm-completionMatchedText", l = h;
      }
      return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = r.detail, n;
    },
    position: 80
  }), e.sort((r, n) => r.position - n.position).map((r) => r.render);
}
function R2(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let n = Math.floor((t - e) / r);
  return { from: t - (n + 1) * r, to: t - n * r };
}
class dee {
  constructor(e, r, n) {
    this.view = e, this.stateField = r, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(r), { options: o, selected: s } = i.open, a = e.state.facet(In);
    this.optionContent = fee(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = R2(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: u } = e.state.field(r).open;
      for (let c = l.target, h; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (h = /-(\d+)$/.exec(c.id)) && +h[1] < u.length) {
          this.applyCompletion(e, u[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(In).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: sg.of(null) });
    }), this.showOptions(o, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let n = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), n != i) {
      let { options: o, selected: s, disabled: a } = n.open;
      (!i.open || i.open.options != o) && (this.range = R2(o.length, s, e.state.facet(In).maxRenderedOptions), this.showOptions(o, n.id)), this.updateSel(), a != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of r.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    (r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = R2(r.options.length, r.selected, this.view.state.facet(In).maxRenderedOptions), this.showOptions(r.options, e.id));
    let n = this.updateSelectedOption(r.selected);
    if (n) {
      this.destroyInfo();
      let { completion: i } = r.options[r.selected], { info: o } = i;
      if (!o)
        return;
      let s = typeof o == "string" ? document.createTextNode(o) : o(i);
      if (!s)
        return;
      "then" in s ? s.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, i);
      }).catch((a) => Pi(this.view.state, a, "completion info")) : (this.addInfoPane(s, i), n.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let n = this.info = document.createElement("div");
    if (n.className = "cm-tooltip cm-completionInfo", n.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), e.nodeType != null)
      n.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: o } = e;
      n.appendChild(i), this.infoDestroy = o || null;
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let n = this.list.firstChild, i = this.range.from; n; n = n.nextSibling, i++)
      n.nodeName != "LI" || !n.id ? i-- : i == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), r = n) : n.hasAttribute("aria-selected") && (n.removeAttribute("aria-selected"), n.removeAttribute("aria-describedby"));
    return r && mee(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
    if (!o) {
      let s = this.dom.ownerDocument.documentElement;
      o = { left: 0, top: 0, right: s.clientWidth, bottom: s.clientHeight };
    }
    return i.top > Math.min(o.bottom, r.bottom) - 10 || i.bottom < Math.max(o.top, r.top) + 10 ? null : this.view.state.facet(In).positionInfo(this.view, r, i, n, o, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, n) {
    const i = document.createElement("ul");
    i.id = r, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (s) => {
      s.target == i && s.preventDefault();
    });
    let o = null;
    for (let s = n.from; s < n.to; s++) {
      let { completion: a, match: l } = e[s], { section: u } = a;
      if (u) {
        let d = typeof u == "string" ? u : u.name;
        if (d != o && (s > n.from || n.from == 0))
          if (o = d, typeof u != "string" && u.header)
            i.appendChild(u.header(u));
          else {
            let p = i.appendChild(document.createElement("completion-section"));
            p.textContent = d;
          }
      }
      const c = i.appendChild(document.createElement("li"));
      c.id = r + "-" + s, c.setAttribute("role", "option");
      let h = this.optionClass(a);
      h && (c.className = h);
      for (let d of this.optionContent) {
        let p = d(a, this.view.state, this.view, l);
        p && c.appendChild(p);
      }
    }
    return n.from && i.classList.add("cm-completionListIncompleteTop"), n.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function pee(t, e) {
  return (r) => new dee(r, t, e);
}
function mee(t, e) {
  let r = t.getBoundingClientRect(), n = e.getBoundingClientRect(), i = r.height / t.offsetHeight;
  n.top < r.top ? t.scrollTop -= (r.top - n.top) / i : n.bottom > r.bottom && (t.scrollTop += (n.bottom - r.bottom) / i);
}
function q6(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function gee(t, e) {
  let r = [], n = null, i = null, o = (c) => {
    r.push(c);
    let { section: h } = c.completion;
    if (h) {
      n || (n = []);
      let d = typeof h == "string" ? h : h.name;
      n.some((p) => p.name == d) || n.push(typeof h == "string" ? { name: d } : h);
    }
  }, s = e.facet(In);
  for (let c of t)
    if (c.hasResult()) {
      let h = c.result.getMatch;
      if (c.result.filter === !1)
        for (let d of c.result.options)
          o(new L6(d, c.source, h ? h(d) : [], 1e9 - r.length));
      else {
        let d = e.sliceDoc(c.from, c.to), p, g = s.filterStrict ? new cee(d) : new uee(d);
        for (let v of c.result.options)
          if (p = g.match(v.label)) {
            let y = v.displayLabel ? h ? h(v, p.matched) : [] : p.matched, b = p.score + (v.boost || 0);
            if (o(new L6(v, c.source, y, b)), typeof v.section == "object" && v.section.rank === "dynamic") {
              let { name: k } = v.section;
              i || (i = /* @__PURE__ */ Object.create(null)), i[k] = Math.max(b, i[k] || -1e9);
            }
          }
      }
    }
  if (n) {
    let c = /* @__PURE__ */ Object.create(null), h = 0, d = (p, g) => (p.rank === "dynamic" && g.rank === "dynamic" ? i[g.name] - i[p.name] : 0) || (typeof p.rank == "number" ? p.rank : 1e9) - (typeof g.rank == "number" ? g.rank : 1e9) || (p.name < g.name ? -1 : 1);
    for (let p of n.sort(d))
      h -= 1e5, c[p.name] = h;
    for (let p of r) {
      let { section: g } = p.completion;
      g && (p.score += c[typeof g == "string" ? g : g.name]);
    }
  }
  let a = [], l = null, u = s.compareCompletions;
  for (let c of r.sort((h, d) => d.score - h.score || u(h.completion, d.completion))) {
    let h = c.completion;
    !l || l.label != h.label || l.detail != h.detail || l.type != null && h.type != null && l.type != h.type || l.apply != h.apply || l.boost != h.boost ? a.push(c) : q6(c.completion) > q6(l) && (a[a.length - 1] = c), l = c.completion;
  }
  return a;
}
class Pf {
  constructor(e, r, n, i, o, s) {
    this.options = e, this.attrs = r, this.tooltip = n, this.timestamp = i, this.selected = o, this.disabled = s;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new Pf(this.options, U6(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, n, i, o, s) {
    if (i && !s && e.some((u) => u.isPending))
      return i.setDisabled();
    let a = gee(e, r);
    if (!a.length)
      return i && e.some((u) => u.isPending) ? i.setDisabled() : null;
    let l = r.facet(In).selectOnOpen ? 0 : -1;
    if (i && i.selected != l && i.selected != -1) {
      let u = i.options[i.selected].completion;
      for (let c = 0; c < a.length; c++)
        if (a[c].completion == u) {
          l = c;
          break;
        }
    }
    return new Pf(a, U6(n, l), {
      pos: e.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: kee,
      above: o.aboveCursor
    }, i ? i.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Pf(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Pf(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class b1 {
  constructor(e, r, n) {
    this.active = e, this.id = r, this.open = n;
  }
  static start() {
    return new b1(xee, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, n = r.facet(In), i = (n.override || r.languageDataAt("autocomplete", oh(r)).map(lee)).map((a) => (this.active.find((l) => l.source == a) || new ds(
      a,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    i.length == this.active.length && i.every((a, l) => a == this.active[l]) && (i = this.active);
    let o = this.open, s = e.effects.some((a) => a.is(x4));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || i.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !vee(i, this.active) || s ? o = Pf.build(i, r, this.id, o, n, s) : o && o.disabled && !i.some((a) => a.isPending) && (o = null), !o && i.every((a) => !a.isPending) && i.some((a) => a.hasResult()) && (i = i.map((a) => a.hasResult() ? new ds(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(OP) && (o = o && o.setSelected(a.value, this.id));
    return i == this.active && o == this.open ? this : new b1(i, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? yee : bee;
  }
}
function vee(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, n = 0; ; ) {
    for (; r < t.length && !t[r].hasResult(); )
      r++;
    for (; n < e.length && !e[n].hasResult(); )
      n++;
    let i = r == t.length, o = n == e.length;
    if (i || o)
      return i == o;
    if (t[r++].result != e[n++].result)
      return !1;
  }
}
const yee = {
  "aria-autocomplete": "list"
}, bee = {};
function U6(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const xee = [];
function DP(t, e) {
  if (t.isUserEvent("input.complete")) {
    let n = t.annotation(b4);
    if (n && e.activateOnCompletion(n))
      return 12;
  }
  let r = t.isUserEvent("input.type");
  return r && e.activateOnTyping ? 5 : r ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class ds {
  constructor(e, r, n = !1) {
    this.source = e, this.state = r, this.explicit = n;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, r) {
    let n = DP(e, r), i = this;
    (n & 8 || n & 16 && this.touches(e)) && (i = new ds(
      i.source,
      0
      /* State.Inactive */
    )), n & 4 && i.state == 0 && (i = new ds(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, n);
    for (let o of e.effects)
      if (o.is(y1))
        i = new ds(i.source, 1, o.value);
      else if (o.is(sg))
        i = new ds(
          i.source,
          0
          /* State.Inactive */
        );
      else if (o.is(x4))
        for (let s of o.value)
          s.source == i.source && (i = s);
    return i;
  }
  updateFor(e, r) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(oh(e.state));
  }
}
class Wf extends ds {
  constructor(e, r, n, i, o, s) {
    super(e, 3, r), this.limit = n, this.result = i, this.from = o, this.to = s;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, r) {
    var n;
    if (!(r & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = oh(e.state);
    if (a > s || !i || r & 2 && (oh(e.startState) == this.from || a < this.limit))
      return new ds(
        this.source,
        r & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return wee(i.validFor, e.state, o, s) ? new Wf(this.source, this.explicit, l, i, o, s) : i.update && (i = i.update(i, o, s, new SP(e.state, a, !1))) ? new Wf(this.source, this.explicit, l, i, i.from, (n = i.to) !== null && n !== void 0 ? n : oh(e.state)) : new ds(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Wf(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new ds(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function wee(t, e, r, n) {
  if (!t)
    return !1;
  let i = e.sliceDoc(r, n);
  return typeof t == "function" ? t(i, r, n, e) : EP(t, !0).test(i);
}
const x4 = /* @__PURE__ */ _t.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), OP = /* @__PURE__ */ _t.define(), Yi = /* @__PURE__ */ jn.define({
  create() {
    return b1.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    c4.from(t, (e) => e.tooltip),
    Be.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function w4(t, e) {
  const r = e.completion.apply || e.completion.label;
  let n = t.state.field(Yi).active.find((i) => i.source == e.source);
  return n instanceof Wf ? (typeof r == "string" ? t.dispatch({
    ...aee(t.state, r, n.from, n.to),
    annotations: b4.of(e.completion)
  }) : r(t, e.completion, n.from, n.to), !0) : !1;
}
const kee = /* @__PURE__ */ pee(Yi, w4);
function zv(t, e = "option") {
  return (r) => {
    let n = r.state.field(Yi, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < r.state.facet(In).interactionDelay)
      return !1;
    let i = 1, o;
    e == "page" && (o = sP(r, n.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = n.open.options, a = n.open.selected > -1 ? n.open.selected + i * (t ? 1 : -1) : t ? 0 : s - 1;
    return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), r.dispatch({ effects: OP.of(a) }), !0;
  };
}
const Cee = (t) => {
  let e = t.state.field(Yi, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(In).interactionDelay ? !1 : w4(t, e.open.options[e.open.selected]);
}, N2 = (t) => t.state.field(Yi, !1) ? (t.dispatch({ effects: y1.of(!0) }), !0) : !1, _ee = (t) => {
  let e = t.state.field(Yi, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: sg.of(null) }), !0);
};
class See {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Aee = 50, Eee = 1e3, Dee = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(Yi).active)
      e.isPending && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(Yi), r = t.state.facet(In);
    if (!t.selectionSet && !t.docChanged && t.startState.field(Yi) == e)
      return;
    let n = t.transactions.some((o) => {
      let s = DP(o, r);
      return s & 8 || (o.selection || o.docChanged) && !(s & 3);
    });
    for (let o = 0; o < this.running.length; o++) {
      let s = this.running[o];
      if (n || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > Aee && Date.now() - s.time > Eee) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (l) {
            Pi(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(o--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((o) => o.effects.some((s) => s.is(y1))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : r.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((o) => o.isPending && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let o of t.transactions)
        o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(Yi);
    for (let r of e.active)
      r.isPending && !this.running.some((n) => n.active.source == r.source) && this.startQuery(r);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(In).updateSyncTime));
  }
  startQuery(t) {
    let { state: e } = this.view, r = oh(e), n = new SP(e, r, t.explicit, this.view), i = new See(t, n);
    this.running.push(i), Promise.resolve(t.source(n)).then((o) => {
      i.context.aborted || (i.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: sg.of(null) }), Pi(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(In).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(In), n = this.view.state.field(Yi);
    for (let i = 0; i < this.running.length; i++) {
      let o = this.running[i];
      if (o.done === void 0)
        continue;
      if (this.running.splice(i--, 1), o.done) {
        let a = oh(o.updates.length ? o.updates[0].startState : this.view.state), l = Math.min(a, o.done.from + (o.active.explicit ? 0 : 1)), u = new Wf(o.active.source, o.active.explicit, l, o.done, o.done.from, (t = o.done.to) !== null && t !== void 0 ? t : a);
        for (let c of o.updates)
          u = u.update(c, r);
        if (u.hasResult()) {
          e.push(u);
          continue;
        }
      }
      let s = n.active.find((a) => a.source == o.active.source);
      if (s && s.isPending)
        if (o.done == null) {
          let a = new ds(
            o.active.source,
            0
            /* State.Inactive */
          );
          for (let l of o.updates)
            a = a.update(l, r);
          a.isPending || e.push(a);
        } else
          this.startQuery(s);
    }
    (e.length || n.open && n.open.disabled) && this.view.dispatch({ effects: x4.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(Yi, !1);
      if (e && e.tooltip && this.view.state.facet(In).closeOnBlur) {
        let r = e.open && sP(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: sg.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: y1.of(!1) }), 20), this.composing = 0;
    }
  }
}), Oee = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Fee = /* @__PURE__ */ pc.highest(/* @__PURE__ */ Be.domEventHandlers({
  keydown(t, e) {
    let r = e.state.field(Yi, !1);
    if (!r || !r.open || r.open.disabled || r.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(Oee && t.altKey) || t.metaKey)
      return !1;
    let n = r.open.options[r.open.selected], i = r.active.find((s) => s.source == n.source), o = n.completion.commitCharacters || i.result.commitCharacters;
    return o && o.indexOf(t.key) > -1 && w4(e, n), !1;
  }
})), FP = /* @__PURE__ */ Be.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"Â·Â·Â·"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'Æ’'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'â—‹'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'â—Œ'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'ð‘¥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'ð¶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'ð‘¡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'âˆª'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'â–¡'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'ðŸ”‘ï¸Ž'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'â–¢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Tee {
  constructor(e, r, n, i) {
    this.field = e, this.line = r, this.from = n, this.to = i;
  }
}
class k4 {
  constructor(e, r, n) {
    this.field = e, this.from = r, this.to = n;
  }
  map(e) {
    let r = e.mapPos(this.from, -1, Kn.TrackDel), n = e.mapPos(this.to, 1, Kn.TrackDel);
    return r == null || n == null ? null : new k4(this.field, r, n);
  }
}
class C4 {
  constructor(e, r) {
    this.lines = e, this.fieldPositions = r;
  }
  instantiate(e, r) {
    let n = [], i = [r], o = e.doc.lineAt(r), s = /^\s*/.exec(o.text)[0];
    for (let l of this.lines) {
      if (n.length) {
        let u = s, c = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < c; h++)
          u += e.facet(Bb);
        i.push(r + u.length - c), l = u + l.slice(c);
      }
      n.push(l), r += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new k4(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: n, ranges: a };
  }
  static parse(e) {
    let r = [], n = [], i = [], o;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; o = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(s); ) {
        let a = o[1] ? +o[1] : null, l = o[2] || o[3] || "", u = -1, c = l.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < r.length; h++)
          (a != null ? r[h].seq == a : c && r[h].name == c) && (u = h);
        if (u < 0) {
          let h = 0;
          for (; h < r.length && (a == null || r[h].seq != null && r[h].seq < a); )
            h++;
          r.splice(h, 0, { seq: a, name: c }), u = h;
          for (let d of i)
            d.field >= u && d.field++;
        }
        for (let h of i)
          if (h.line == n.length && h.from > o.index) {
            let d = o[2] ? 3 + (o[1] || "").length : 2;
            h.from -= d, h.to -= d;
          }
        i.push(new Tee(u, n.length, o.index, o.index + c.length)), s = s.slice(0, o.index) + l + s.slice(o.index + o[0].length);
      }
      s = s.replace(/\\([{}])/g, (a, l, u) => {
        for (let c of i)
          c.line == n.length && c.from > u && (c.from--, c.to--);
        return l;
      }), n.push(s);
    }
    return new C4(n, i);
  }
}
let Mee = /* @__PURE__ */ pt.widget({ widget: /* @__PURE__ */ new class extends Bh {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Pee = /* @__PURE__ */ pt.mark({ class: "cm-snippetField" });
class Jd {
  constructor(e, r) {
    this.ranges = e, this.active = r, this.deco = pt.set(e.map((n) => (n.from == n.to ? Mee : Pee).range(n.from, n.to)), !0);
  }
  map(e) {
    let r = [];
    for (let n of this.ranges) {
      let i = n.map(e);
      if (!i)
        return null;
      r.push(i);
    }
    return new Jd(r, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((r) => this.ranges.some((n) => n.field == this.active && n.from <= r.from && n.to >= r.to));
  }
}
const e0 = /* @__PURE__ */ _t.define({
  map(t, e) {
    return t && t.map(e);
  }
}), Ree = /* @__PURE__ */ _t.define(), ag = /* @__PURE__ */ jn.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let r of e.effects) {
      if (r.is(e0))
        return r.value;
      if (r.is(Ree) && t)
        return new Jd(t.ranges, r.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => Be.decorations.from(t, (e) => e ? e.deco : pt.none)
});
function _4(t, e) {
  return de.create(t.filter((r) => r.field == e).map((r) => de.range(r.from, r.to)));
}
function Nee(t) {
  let e = C4.parse(t);
  return (r, n, i, o) => {
    let { text: s, ranges: a } = e.instantiate(r.state, i), { main: l } = r.state.selection, u = {
      changes: { from: i, to: o == l.from ? l.to : o, insert: ir.of(s) },
      scrollIntoView: !0,
      annotations: n ? [b4.of(n), bn.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (u.selection = _4(a, 0)), a.some((c) => c.field > 0)) {
      let c = new Jd(a, 0), h = u.effects = [e0.of(c)];
      r.state.field(ag, !1) === void 0 && h.push(_t.appendConfig.of([ag, zee, qee, FP]));
    }
    r.dispatch(r.state.update(u));
  };
}
function TP(t) {
  return ({ state: e, dispatch: r }) => {
    let n = e.field(ag, !1);
    if (!n || t < 0 && n.active == 0)
      return !1;
    let i = n.active + t, o = t > 0 && !n.ranges.some((s) => s.field == i + t);
    return r(e.update({
      selection: _4(n.ranges, i),
      effects: e0.of(o ? null : new Jd(n.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const $ee = ({ state: t, dispatch: e }) => t.field(ag, !1) ? (e(t.update({ effects: e0.of(null) })), !0) : !1, Iee = /* @__PURE__ */ TP(1), Bee = /* @__PURE__ */ TP(-1), Lee = [
  { key: "Tab", run: Iee, shift: Bee },
  { key: "Escape", run: $ee }
], H6 = /* @__PURE__ */ Le.define({
  combine(t) {
    return t.length ? t[0] : Lee;
  }
}), zee = /* @__PURE__ */ pc.highest(/* @__PURE__ */ $b.compute([H6], (t) => t.facet(H6)));
function jee(t, e) {
  return { ...e, apply: Nee(t) };
}
const qee = /* @__PURE__ */ Be.domEventHandlers({
  mousedown(t, e) {
    let r = e.state.field(ag, !1), n;
    if (!r || (n = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let i = r.ranges.find((o) => o.from <= n && o.to >= n);
    return !i || i.field == r.active ? !1 : (e.dispatch({
      selection: _4(r.ranges, i.field),
      effects: e0.of(r.ranges.some((o) => o.field > i.field) ? new Jd(r.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), lg = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Uc = /* @__PURE__ */ _t.define({
  map(t, e) {
    return e.mapPos(t, -1, Kn.TrackAfter) ?? void 0;
  }
}), S4 = /* @__PURE__ */ new class extends bh {
}();
S4.startSide = 1;
S4.endSide = -1;
const MP = /* @__PURE__ */ jn.define({
  create() {
    return hr.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (n) => n >= r.from && n <= r.to });
    }
    for (let r of e.effects)
      r.is(Uc) && (t = t.update({ add: [S4.range(r.value, r.value + 1)] }));
    return t;
  }
});
function Uee() {
  return [Vee, MP];
}
const $2 = "()[]{}<>Â«Â»Â»Â«ï¼»ï¼½ï½›ï½";
function PP(t) {
  for (let e = 0; e < $2.length; e += 2)
    if ($2.charCodeAt(e) == t)
      return $2.charAt(e + 1);
  return X_(t < 128 ? t : t + 1);
}
function RP(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || lg;
}
const Hee = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Vee = /* @__PURE__ */ Be.inputHandler.of((t, e, r, n) => {
  if ((Hee ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (n.length > 2 || n.length == 2 && Aa(Ji(n, 0)) == 1 || e != i.from || r != i.to)
    return !1;
  let o = Kee(t.state, n);
  return o ? (t.dispatch(o), !0) : !1;
}), Wee = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = RP(t, t.selection.main.head).brackets || lg.brackets, n = null, i = t.changeByRange((o) => {
    if (o.empty) {
      let s = Qee(t.doc, o.head);
      for (let a of r)
        if (a == s && zb(t.doc, o.head) == PP(Ji(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: de.cursor(o.head - a.length)
          };
    }
    return { range: n = o };
  });
  return n || e(t.update(i, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, Gee = [
  { key: "Backspace", run: Wee }
];
function Kee(t, e) {
  let r = RP(t, t.selection.main.head), n = r.brackets || lg.brackets;
  for (let i of n) {
    let o = PP(Ji(i, 0));
    if (e == i)
      return o == i ? Yee(t, i, n.indexOf(i + i + i) > -1, r) : Xee(t, i, o, r.before || lg.before);
    if (e == o && NP(t, t.selection.main.from))
      return Jee(t, i, o);
  }
  return null;
}
function NP(t, e) {
  let r = !1;
  return t.field(MP).between(0, t.doc.length, (n) => {
    n == e && (r = !0);
  }), r;
}
function zb(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, Aa(Ji(r, 0)));
}
function Qee(t, e) {
  let r = t.sliceString(e - 2, e);
  return Aa(Ji(r, 0)) == r.length ? r : r.slice(1);
}
function Xee(t, e, r, n) {
  let i = null, o = t.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: r, from: s.to }],
        effects: Uc.of(s.to + e.length),
        range: de.range(s.anchor + e.length, s.head + e.length)
      };
    let a = zb(t.doc, s.head);
    return !a || /\s/.test(a) || n.indexOf(a) > -1 ? {
      changes: { insert: e + r, from: s.head },
      effects: Uc.of(s.head + e.length),
      range: de.cursor(s.head + e.length)
    } : { range: i = s };
  });
  return i ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Jee(t, e, r) {
  let n = null, i = t.changeByRange((o) => o.empty && zb(t.doc, o.head) == r ? {
    changes: { from: o.head, to: o.head + r.length, insert: r },
    range: de.cursor(o.head + r.length)
  } : n = { range: o });
  return n ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Yee(t, e, r, n) {
  let i = n.stringPrefixes || lg.stringPrefixes, o = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Uc.of(a.to + e.length),
        range: de.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, u = zb(t.doc, l), c;
    if (u == e) {
      if (V6(t, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Uc.of(l + e.length),
          range: de.cursor(l + e.length)
        };
      if (NP(t, l)) {
        let h = r && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + h.length, insert: h },
          range: de.cursor(l + h.length)
        };
      }
    } else {
      if (r && t.sliceDoc(l - 2 * e.length, l) == e + e && (c = W6(t, l - 2 * e.length, i)) > -1 && V6(t, c))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Uc.of(l + e.length),
          range: de.cursor(l + e.length)
        };
      if (t.charCategorizer(l)(u) != Hr.Word && W6(t, l, i) > -1 && !Zee(t, l, e, i))
        return {
          changes: { insert: e + e, from: l },
          effects: Uc.of(l + e.length),
          range: de.cursor(l + e.length)
        };
    }
    return { range: o = a };
  });
  return o ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function V6(t, e) {
  let r = Dn(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function Zee(t, e, r, n) {
  let i = Dn(t).resolveInner(e, -1), o = n.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + o)), l = a.indexOf(r);
    if (!l || l > -1 && n.indexOf(a.slice(0, l)) > -1) {
      let c = i.firstChild;
      for (; c && c.from == i.from && c.to - c.from > r.length + l; ) {
        if (t.sliceDoc(c.to - r.length, c.to) == r)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = i.to == e && i.parent;
    if (!u)
      break;
    i = u;
  }
  return !1;
}
function W6(t, e, r) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != Hr.Word)
    return e;
  for (let i of r) {
    let o = e - i.length;
    if (t.sliceDoc(o, e) == i && n(t.sliceDoc(o - 1, o)) != Hr.Word)
      return o;
  }
  return -1;
}
function ete(t = {}) {
  return [
    Fee,
    Yi,
    In.of(t),
    Dee,
    tte,
    FP
  ];
}
const $P = [
  { key: "Ctrl-Space", run: N2 },
  { mac: "Alt-`", run: N2 },
  { mac: "Alt-i", run: N2 },
  { key: "Escape", run: _ee },
  { key: "ArrowDown", run: /* @__PURE__ */ zv(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ zv(!1) },
  { key: "PageDown", run: /* @__PURE__ */ zv(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ zv(!1, "page") },
  { key: "Enter", run: Cee }
], tte = /* @__PURE__ */ pc.highest(/* @__PURE__ */ $b.computeN([In], (t) => t.facet(In).defaultKeymap ? [$P] : [])), rte = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), n = E4(t.state, r.from);
  return n.line ? nte(t) : n.block ? ote(t) : !1;
};
function A4(t, e) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly)
      return !1;
    let i = t(e, r);
    return i ? (n(r.update(i)), !0) : !1;
  };
}
const nte = /* @__PURE__ */ A4(
  lte,
  0
  /* CommentOption.Toggle */
), ite = /* @__PURE__ */ A4(
  IP,
  0
  /* CommentOption.Toggle */
), ote = /* @__PURE__ */ A4(
  (t, e) => IP(t, e, ate(e)),
  0
  /* CommentOption.Toggle */
);
function E4(t, e) {
  let r = t.languageDataAt("commentTokens", e, 1);
  return r.length ? r[0] : {};
}
const Xp = 50;
function ste(t, { open: e, close: r }, n, i) {
  let o = t.sliceDoc(n - Xp, n), s = t.sliceDoc(i, i + Xp), a = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(s)[0].length, u = o.length - a;
  if (o.slice(u - e.length, u) == e && s.slice(l, l + r.length) == r)
    return {
      open: { pos: n - a, margin: a && 1 },
      close: { pos: i + l, margin: l && 1 }
    };
  let c, h;
  i - n <= 2 * Xp ? c = h = t.sliceDoc(n, i) : (c = t.sliceDoc(n, n + Xp), h = t.sliceDoc(i - Xp, i));
  let d = /^\s*/.exec(c)[0].length, p = /\s*$/.exec(h)[0].length, g = h.length - p - r.length;
  return c.slice(d, d + e.length) == e && h.slice(g, g + r.length) == r ? {
    open: {
      pos: n + d + e.length,
      margin: /\s/.test(c.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: i - p - r.length,
      margin: /\s/.test(h.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
function ate(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let n = t.doc.lineAt(r.from), i = r.to <= n.to ? n : t.doc.lineAt(r.to);
    i.from > n.from && i.from == r.to && (i = r.to == n.to + 1 ? n : t.doc.lineAt(r.to - 1));
    let o = e.length - 1;
    o >= 0 && e[o].to > n.from ? e[o].to = i.to : e.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: i.to });
  }
  return e;
}
function IP(t, e, r = e.selection.ranges) {
  let n = r.map((o) => E4(e, o.from).block);
  if (!n.every((o) => o))
    return null;
  let i = r.map((o, s) => ste(e, n[s], o.from, o.to));
  if (t != 2 && !i.every((o) => o))
    return { changes: e.changes(r.map((o, s) => i[s] ? [] : [{ from: o.from, insert: n[s].open + " " }, { from: o.to, insert: " " + n[s].close }])) };
  if (t != 1 && i.some((o) => o)) {
    let o = [];
    for (let s = 0, a; s < i.length; s++)
      if (a = i[s]) {
        let l = n[s], { open: u, close: c } = a;
        o.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + l.close.length });
      }
    return { changes: o };
  }
  return null;
}
function lte(t, e, r = e.selection.ranges) {
  let n = [], i = -1;
  for (let { from: o, to: s } of r) {
    let a = n.length, l = 1e9, u = E4(e, o).line;
    if (u) {
      for (let c = o; c <= s; ) {
        let h = e.doc.lineAt(c);
        if (h.from > i && (o == s || s > h.from)) {
          i = h.from;
          let d = /^\s*/.exec(h.text)[0].length, p = d == h.length, g = h.text.slice(d, d + u.length) == u ? d : -1;
          d < h.text.length && d < l && (l = d), n.push({ line: h, comment: g, token: u, indent: d, empty: p, single: !1 });
        }
        c = h.to + 1;
      }
      if (l < 1e9)
        for (let c = a; c < n.length; c++)
          n[c].indent < n[c].line.text.length && (n[c].indent = l);
      n.length == a + 1 && (n[a].single = !0);
    }
  }
  if (t != 2 && n.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: a, token: l, indent: u, empty: c, single: h } of n)
      (h || !c) && o.push({ from: a.from + u, insert: l + " " });
    let s = e.changes(o);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (t != 1 && n.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: s, comment: a, token: l } of n)
      if (a >= 0) {
        let u = s.from + a, c = u + l.length;
        s.text[c - s.from] == " " && c++, o.push({ from: u, to: c });
      }
    return { changes: o };
  }
  return null;
}
const sC = /* @__PURE__ */ nu.define(), ute = /* @__PURE__ */ nu.define(), cte = /* @__PURE__ */ Le.define(), BP = /* @__PURE__ */ Le.define({
  combine(t) {
    return iu(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (n, i) => e(n, i) || r(n, i)
    });
  }
}), LP = /* @__PURE__ */ jn.define({
  create() {
    return Ra.empty;
  },
  update(t, e) {
    let r = e.state.facet(BP), n = e.annotation(sC);
    if (n) {
      let l = to.fromTransaction(e, n.selection), u = n.side, c = u == 0 ? t.undone : t.done;
      return l ? c = x1(c, c.length, r.minDepth, l) : c = qP(c, e.startState.selection), new Ra(u == 0 ? n.rest : c, u == 0 ? c : n.rest);
    }
    let i = e.annotation(ute);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(bn.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let o = to.fromTransaction(e), s = e.annotation(bn.time), a = e.annotation(bn.userEvent);
    return o ? t = t.addChanges(o, s, a, r, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, r.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Ra(t.done.map(to.fromJSON), t.undone.map(to.fromJSON));
  }
});
function hte(t = {}) {
  return [
    LP,
    BP.of(t),
    Be.domEventHandlers({
      beforeinput(e, r) {
        let n = e.inputType == "historyUndo" ? zP : e.inputType == "historyRedo" ? aC : null;
        return n ? (e.preventDefault(), n(r)) : !1;
      }
    })
  ];
}
function jb(t, e) {
  return function({ state: r, dispatch: n }) {
    if (!e && r.readOnly)
      return !1;
    let i = r.field(LP, !1);
    if (!i)
      return !1;
    let o = i.pop(t, r, e);
    return o ? (n(o), !0) : !1;
  };
}
const zP = /* @__PURE__ */ jb(0, !1), aC = /* @__PURE__ */ jb(1, !1), fte = /* @__PURE__ */ jb(0, !0), dte = /* @__PURE__ */ jb(1, !0);
class to {
  constructor(e, r, n, i, o) {
    this.changes = e, this.effects = r, this.mapped = n, this.startSelection = i, this.selectionsAfter = o;
  }
  setSelAfter(e) {
    return new to(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new to(e.changes && En.fromJSON(e.changes), [], e.mapped && qa.fromJSON(e.mapped), e.startSelection && de.fromJSON(e.startSelection), e.selectionsAfter.map(de.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let n = ps;
    for (let i of e.startState.facet(cte)) {
      let o = i(e);
      o.length && (n = n.concat(o));
    }
    return !n.length && e.changes.empty ? null : new to(e.changes.invert(e.startState.doc), n, void 0, r || e.startState.selection, ps);
  }
  static selection(e) {
    return new to(void 0, ps, void 0, void 0, e);
  }
}
function x1(t, e, r, n) {
  let i = e + 1 > r + 20 ? e - r - 1 : 0, o = t.slice(i, e);
  return o.push(n), o;
}
function pte(t, e) {
  let r = [], n = !1;
  return t.iterChangedRanges((i, o) => r.push(i, o)), e.iterChangedRanges((i, o, s, a) => {
    for (let l = 0; l < r.length; ) {
      let u = r[l++], c = r[l++];
      a >= u && s <= c && (n = !0);
    }
  }), n;
}
function mte(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, n) => r.empty != e.ranges[n].empty).length === 0;
}
function jP(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const ps = [], gte = 200;
function qP(t, e) {
  if (t.length) {
    let r = t[t.length - 1], n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - gte));
    return n.length && n[n.length - 1].eq(e) ? t : (n.push(e), x1(t, t.length - 1, 1e9, r.setSelAfter(n)));
  } else
    return [to.selection([e])];
}
function vte(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function I2(t, e) {
  if (!t.length)
    return t;
  let r = t.length, n = ps;
  for (; r; ) {
    let i = yte(t[r - 1], e, n);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let o = t.slice(0, r);
      return o[r - 1] = i, o;
    } else
      e = i.mapped, r--, n = i.selectionsAfter;
  }
  return n.length ? [to.selection(n)] : ps;
}
function yte(t, e, r) {
  let n = jP(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : ps, r);
  if (!t.changes)
    return to.selection(n);
  let i = t.changes.map(e), o = e.mapDesc(t.changes, !0), s = t.mapped ? t.mapped.composeDesc(o) : o;
  return new to(i, _t.mapEffects(t.effects, e), s, t.startSelection.map(o), n);
}
const bte = /^(input\.type|delete)($|\.)/;
class Ra {
  constructor(e, r, n = 0, i = void 0) {
    this.done = e, this.undone = r, this.prevTime = n, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new Ra(this.done, this.undone) : this;
  }
  addChanges(e, r, n, i, o) {
    let s = this.done, a = s[s.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!n || bte.test(n)) && (!a.selectionsAfter.length && r - this.prevTime < i.newGroupDelay && i.joinToEvent(o, pte(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? s = x1(s, s.length - 1, i.minDepth, new to(e.changes.compose(a.changes), jP(_t.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, ps)) : s = x1(s, s.length, i.minDepth, e), new Ra(s, ps, r, n);
  }
  addSelection(e, r, n, i) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ps;
    return o.length > 0 && r - this.prevTime < i && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && mte(o[o.length - 1], e) ? this : new Ra(qP(this.done, e), this.undone, r, n);
  }
  addMapping(e) {
    return new Ra(I2(this.done, e), I2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, n) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let o = i[i.length - 1], s = o.selectionsAfter[0] || r.selection;
    if (n && o.selectionsAfter.length)
      return r.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: sC.of({ side: e, rest: vte(i), selection: s }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let a = i.length == 1 ? ps : i.slice(0, i.length - 1);
      return o.mapped && (a = I2(a, o.mapped)), r.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: sC.of({ side: e, rest: a, selection: s }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Ra.empty = /* @__PURE__ */ new Ra(ps, ps);
const xte = [
  { key: "Mod-z", run: zP, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: aC, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: aC, preventDefault: !0 },
  { key: "Mod-u", run: fte, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: dte, preventDefault: !0 }
];
function Yd(t, e) {
  return de.create(t.ranges.map(e), t.mainIndex);
}
function ia(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function oa({ state: t, dispatch: e }, r) {
  let n = Yd(t.selection, r);
  return n.eq(t.selection, !0) ? !1 : (e(ia(t, n)), !0);
}
function qb(t, e) {
  return de.cursor(e ? t.to : t.from);
}
function UP(t, e) {
  return oa(t, (r) => r.empty ? t.moveByChar(r, e) : qb(r, e));
}
function bi(t) {
  return t.textDirectionAt(t.state.selection.main.head) == Ir.LTR;
}
const HP = (t) => UP(t, !bi(t)), VP = (t) => UP(t, bi(t));
function WP(t, e) {
  return oa(t, (r) => r.empty ? t.moveByGroup(r, e) : qb(r, e));
}
const wte = (t) => WP(t, !bi(t)), kte = (t) => WP(t, bi(t));
function Cte(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let n = e.to - e.from;
  return n && (n > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Ub(t, e, r) {
  let n = Dn(t).resolveInner(e.head), i = r ? Pt.closedBy : Pt.openedBy;
  for (let l = e.head; ; ) {
    let u = r ? n.childAfter(l) : n.childBefore(l);
    if (!u)
      break;
    Cte(t, u, i) ? n = u : l = r ? u.to : u.from;
  }
  let o = n.type.prop(i), s, a;
  return o && (s = r ? Pa(t, n.from, 1) : Pa(t, n.to, -1)) && s.matched ? a = r ? s.end.to : s.end.from : a = r ? n.to : n.from, de.cursor(a, r ? -1 : 1);
}
const _te = (t) => oa(t, (e) => Ub(t.state, e, !bi(t))), Ste = (t) => oa(t, (e) => Ub(t.state, e, bi(t)));
function GP(t, e) {
  return oa(t, (r) => {
    if (!r.empty)
      return qb(r, e);
    let n = t.moveVertically(r, e);
    return n.head != r.head ? n : t.moveToLineBoundary(r, e);
  });
}
const KP = (t) => GP(t, !1), QP = (t) => GP(t, !0);
function XP(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, n = 0, i;
  if (e) {
    for (let o of t.state.facet(Be.scrollMargins)) {
      let s = o(t);
      s?.top && (r = Math.max(s?.top, r)), s?.bottom && (n = Math.max(s?.bottom, n));
    }
    i = t.scrollDOM.clientHeight - r - n;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: n,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function JP(t, e) {
  let r = XP(t), { state: n } = t, i = Yd(n.selection, (s) => s.empty ? t.moveVertically(s, e, r.height) : qb(s, e));
  if (i.eq(n.selection))
    return !1;
  let o;
  if (r.selfScroll) {
    let s = t.coordsAtPos(n.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + r.marginTop, u = a.bottom - r.marginBottom;
    s && s.top > l && s.bottom < u && (o = Be.scrollIntoView(i.main.head, { y: "start", yMargin: s.top - l }));
  }
  return t.dispatch(ia(n, i), { effects: o }), !0;
}
const G6 = (t) => JP(t, !1), lC = (t) => JP(t, !0);
function mc(t, e, r) {
  let n = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, r);
  if (i.head == e.head && i.head != (r ? n.to : n.from) && (i = t.moveToLineBoundary(e, r, !1)), !r && i.head == n.from && n.length) {
    let o = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    o && e.head != n.from + o && (i = de.cursor(n.from + o));
  }
  return i;
}
const Ate = (t) => oa(t, (e) => mc(t, e, !0)), Ete = (t) => oa(t, (e) => mc(t, e, !1)), Dte = (t) => oa(t, (e) => mc(t, e, !bi(t))), Ote = (t) => oa(t, (e) => mc(t, e, bi(t))), Fte = (t) => oa(t, (e) => de.cursor(t.lineBlockAt(e.head).from, 1)), Tte = (t) => oa(t, (e) => de.cursor(t.lineBlockAt(e.head).to, -1));
function Mte(t, e, r) {
  let n = !1, i = Yd(t.selection, (o) => {
    let s = Pa(t, o.head, -1) || Pa(t, o.head, 1) || o.head > 0 && Pa(t, o.head - 1, 1) || o.head < t.doc.length && Pa(t, o.head + 1, -1);
    if (!s || !s.end)
      return o;
    n = !0;
    let a = s.start.from == o.head ? s.end.to : s.end.from;
    return de.cursor(a);
  });
  return n ? (e(ia(t, i)), !0) : !1;
}
const Pte = ({ state: t, dispatch: e }) => Mte(t, e);
function Cs(t, e) {
  let r = Yd(t.state.selection, (n) => {
    let i = e(n);
    return de.range(n.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(ia(t.state, r)), !0);
}
function YP(t, e) {
  return Cs(t, (r) => t.moveByChar(r, e));
}
const ZP = (t) => YP(t, !bi(t)), eR = (t) => YP(t, bi(t));
function tR(t, e) {
  return Cs(t, (r) => t.moveByGroup(r, e));
}
const Rte = (t) => tR(t, !bi(t)), Nte = (t) => tR(t, bi(t)), $te = (t) => Cs(t, (e) => Ub(t.state, e, !bi(t))), Ite = (t) => Cs(t, (e) => Ub(t.state, e, bi(t)));
function rR(t, e) {
  return Cs(t, (r) => t.moveVertically(r, e));
}
const nR = (t) => rR(t, !1), iR = (t) => rR(t, !0);
function oR(t, e) {
  return Cs(t, (r) => t.moveVertically(r, e, XP(t).height));
}
const K6 = (t) => oR(t, !1), Q6 = (t) => oR(t, !0), Bte = (t) => Cs(t, (e) => mc(t, e, !0)), Lte = (t) => Cs(t, (e) => mc(t, e, !1)), zte = (t) => Cs(t, (e) => mc(t, e, !bi(t))), jte = (t) => Cs(t, (e) => mc(t, e, bi(t))), qte = (t) => Cs(t, (e) => de.cursor(t.lineBlockAt(e.head).from)), Ute = (t) => Cs(t, (e) => de.cursor(t.lineBlockAt(e.head).to)), X6 = ({ state: t, dispatch: e }) => (e(ia(t, { anchor: 0 })), !0), J6 = ({ state: t, dispatch: e }) => (e(ia(t, { anchor: t.doc.length })), !0), Y6 = ({ state: t, dispatch: e }) => (e(ia(t, { anchor: t.selection.main.anchor, head: 0 })), !0), Z6 = ({ state: t, dispatch: e }) => (e(ia(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), Hte = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), Vte = ({ state: t, dispatch: e }) => {
  let r = Hb(t).map(({ from: n, to: i }) => de.range(n, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: de.create(r), userEvent: "select" })), !0;
}, Wte = ({ state: t, dispatch: e }) => {
  let r = Yd(t.selection, (n) => {
    let i = Dn(t), o = i.resolveStack(n.from, 1);
    if (n.empty) {
      let s = i.resolveStack(n.from, -1);
      s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s);
    }
    for (let s = o; s; s = s.next) {
      let { node: a } = s;
      if ((a.from < n.from && a.to >= n.to || a.to > n.to && a.from <= n.from) && s.next)
        return de.range(a.to, a.from);
    }
    return n;
  });
  return r.eq(t.selection) ? !1 : (e(ia(t, r)), !0);
};
function sR(t, e) {
  let { state: r } = t, n = r.selection, i = r.selection.ranges.slice();
  for (let o of r.selection.ranges) {
    let s = r.doc.lineAt(o.head);
    if (e ? s.to < t.state.doc.length : s.from > 0)
      for (let a = o; ; ) {
        let l = t.moveVertically(a, e);
        if (l.head < s.from || l.head > s.to) {
          i.some((u) => u.head == l.head) || i.push(l);
          break;
        } else {
          if (l.head == a.head)
            break;
          a = l;
        }
      }
  }
  return i.length == n.ranges.length ? !1 : (t.dispatch(ia(r, de.create(i, i.length - 1))), !0);
}
const Gte = (t) => sR(t, !1), Kte = (t) => sR(t, !0), Qte = ({ state: t, dispatch: e }) => {
  let r = t.selection, n = null;
  return r.ranges.length > 1 ? n = de.create([r.main]) : r.main.empty || (n = de.create([de.cursor(r.main.head)])), n ? (e(ia(t, n)), !0) : !1;
};
function t0(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: n } = t, i = n.changeByRange((o) => {
    let { from: s, to: a } = o;
    if (s == a) {
      let l = e(o);
      l < s ? (r = "delete.backward", l = jv(t, l, !1)) : l > s && (r = "delete.forward", l = jv(t, l, !0)), s = Math.min(s, l), a = Math.max(a, l);
    } else
      s = jv(t, s, !1), a = jv(t, a, !0);
    return s == a ? { range: o } : { changes: { from: s, to: a }, range: de.cursor(s, s < o.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(n.update(i, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? Be.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function jv(t, e, r) {
  if (t instanceof Be)
    for (let n of t.state.facet(Be.atomicRanges).map((i) => i(t)))
      n.between(e, e, (i, o) => {
        i < e && o > e && (e = r ? o : i);
      });
  return e;
}
const aR = (t, e, r) => t0(t, (n) => {
  let i = n.from, { state: o } = t, s = o.doc.lineAt(i), a, l;
  if (r && !e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
    if (a[a.length - 1] == "	")
      return i - 1;
    let u = Xd(a, o.tabSize), c = u % v1(o) || v1(o);
    for (let h = 0; h < c && a[a.length - 1 - h] == " "; h++)
      i--;
    l = i;
  } else
    l = Qn(s.text, i - s.from, e, e) + s.from, l == i && s.number != (e ? o.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, i - s.from)) && (l = Qn(s.text, l - s.from, !1, !1) + s.from);
  return l;
}), uC = (t) => aR(t, !1, !0), lR = (t) => aR(t, !0, !1), uR = (t, e) => t0(t, (r) => {
  let n = r.head, { state: i } = t, o = i.doc.lineAt(n), s = i.charCategorizer(n);
  for (let a = null; ; ) {
    if (n == (e ? o.to : o.from)) {
      n == r.head && o.number != (e ? i.doc.lines : 1) && (n += e ? 1 : -1);
      break;
    }
    let l = Qn(o.text, n - o.from, e) + o.from, u = o.text.slice(Math.min(n, l) - o.from, Math.max(n, l) - o.from), c = s(u);
    if (a != null && c != a)
      break;
    (u != " " || n != r.head) && (a = c), n = l;
  }
  return n;
}), cR = (t) => uR(t, !1), Xte = (t) => uR(t, !0), Jte = (t) => t0(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), Yte = (t) => t0(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), Zte = (t) => t0(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), ere = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: ir.of(["", ""]) },
    range: de.cursor(n.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, tre = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == t.doc.length)
      return { range: n };
    let i = n.from, o = t.doc.lineAt(i), s = i == o.from ? i - 1 : Qn(o.text, i - o.from, !1) + o.from, a = i == o.to ? i + 1 : Qn(o.text, i - o.from, !0) + o.from;
    return {
      changes: { from: s, to: a, insert: t.doc.slice(i, a).append(t.doc.slice(s, i)) },
      range: de.cursor(a)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Hb(t) {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from), o = t.doc.lineAt(n.to);
    if (!n.empty && n.to == o.from && (o = t.doc.lineAt(n.to - 1)), r >= i.number) {
      let s = e[e.length - 1];
      s.to = o.to, s.ranges.push(n);
    } else
      e.push({ from: i.from, to: o.to, ranges: [n] });
    r = o.number + 1;
  }
  return e;
}
function hR(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [], i = [];
  for (let o of Hb(t)) {
    if (r ? o.to == t.doc.length : o.from == 0)
      continue;
    let s = t.doc.lineAt(r ? o.to + 1 : o.from - 1), a = s.length + 1;
    if (r) {
      n.push({ from: o.to, to: s.to }, { from: o.from, insert: s.text + t.lineBreak });
      for (let l of o.ranges)
        i.push(de.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
    } else {
      n.push({ from: s.from, to: o.from }, { from: o.to, insert: t.lineBreak + s.text });
      for (let l of o.ranges)
        i.push(de.range(l.anchor - a, l.head - a));
    }
  }
  return n.length ? (e(t.update({
    changes: n,
    scrollIntoView: !0,
    selection: de.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const rre = ({ state: t, dispatch: e }) => hR(t, e, !1), nre = ({ state: t, dispatch: e }) => hR(t, e, !0);
function fR(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [];
  for (let i of Hb(t))
    r ? n.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : n.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const ire = ({ state: t, dispatch: e }) => fR(t, e, !1), ore = ({ state: t, dispatch: e }) => fR(t, e, !0), sre = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(Hb(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, { from: i, to: o }))), n = Yd(e.selection, (i) => {
    let o;
    if (t.lineWrapping) {
      let s = t.lineBlockAt(i.head), a = t.coordsAtPos(i.head, i.assoc || 1);
      a && (o = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(i, !0, o);
  }).map(r);
  return t.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function are(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = Dn(t).resolveInner(e), n = r.childBefore(e), i = r.childAfter(e), o;
  return n && i && n.to <= e && i.from >= e && (o = n.type.prop(Pt.closedBy)) && o.indexOf(i.name) > -1 && t.doc.lineAt(n.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(n.to, i.from)) ? { from: n.to, to: i.from } : null;
}
const e8 = /* @__PURE__ */ dR(!1), lre = /* @__PURE__ */ dR(!0);
function dR(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let n = e.changeByRange((i) => {
      let { from: o, to: s } = i, a = e.doc.lineAt(o), l = !t && o == s && are(e, o);
      t && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
      let u = new Lb(e, { simulateBreak: o, simulateDoubleBreak: !!l }), c = g4(u, o);
      for (c == null && (c = Xd(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
        s++;
      l ? { from: o, to: s } = l : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
      let h = ["", og(e, c)];
      return l && h.push(og(e, u.lineIndent(a.from, -1))), {
        changes: { from: o, to: s, insert: ir.of(h) },
        range: de.cursor(o + 1 + h[1].length)
      };
    });
    return r(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function D4(t, e) {
  let r = -1;
  return t.changeByRange((n) => {
    let i = [];
    for (let s = n.from; s <= n.to; ) {
      let a = t.doc.lineAt(s);
      a.number > r && (n.empty || n.to > a.from) && (e(a, i, n), r = a.number), s = a.to + 1;
    }
    let o = t.changes(i);
    return {
      changes: i,
      range: de.range(o.mapPos(n.anchor, 1), o.mapPos(n.head, 1))
    };
  });
}
const ure = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), n = new Lb(t, { overrideIndentation: (o) => r[o] ?? -1 }), i = D4(t, (o, s, a) => {
    let l = g4(n, o.from);
    if (l == null)
      return;
    /\S/.test(o.text) || (l = 0);
    let u = /^\s*/.exec(o.text)[0], c = og(t, l);
    (u != c || a.from < o.from + u.length) && (r[o.from] = l, s.push({ from: o.from, to: o.from + u.length, insert: c }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, pR = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(D4(t, (r, n) => {
  n.push({ from: r.from, insert: t.facet(Bb) });
}), { userEvent: "input.indent" })), !0), mR = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(D4(t, (r, n) => {
  let i = /^\s*/.exec(r.text)[0];
  if (!i)
    return;
  let o = Xd(i, t.tabSize), s = 0, a = og(t, Math.max(0, o - v1(t)));
  for (; s < i.length && s < a.length && i.charCodeAt(s) == a.charCodeAt(s); )
    s++;
  n.push({ from: r.from + s, to: r.from + i.length, insert: a.slice(s) });
}), { userEvent: "delete.dedent" })), !0), cre = (t) => (t.setTabFocusMode(), !0), hre = ({ state: t, dispatch: e }) => t.selection.ranges.some((r) => !r.empty) ? pR({ state: t, dispatch: e }) : (e(t.update(t.replaceSelection("	"), { scrollIntoView: !0, userEvent: "input" })), !0), fre = [
  { key: "Ctrl-b", run: HP, shift: ZP, preventDefault: !0 },
  { key: "Ctrl-f", run: VP, shift: eR },
  { key: "Ctrl-p", run: KP, shift: nR },
  { key: "Ctrl-n", run: QP, shift: iR },
  { key: "Ctrl-a", run: Fte, shift: qte },
  { key: "Ctrl-e", run: Tte, shift: Ute },
  { key: "Ctrl-d", run: lR },
  { key: "Ctrl-h", run: uC },
  { key: "Ctrl-k", run: Jte },
  { key: "Ctrl-Alt-h", run: cR },
  { key: "Ctrl-o", run: ere },
  { key: "Ctrl-t", run: tre },
  { key: "Ctrl-v", run: lC }
], dre = /* @__PURE__ */ [
  { key: "ArrowLeft", run: HP, shift: ZP, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: wte, shift: Rte, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: Dte, shift: zte, preventDefault: !0 },
  { key: "ArrowRight", run: VP, shift: eR, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: kte, shift: Nte, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: Ote, shift: jte, preventDefault: !0 },
  { key: "ArrowUp", run: KP, shift: nR, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: X6, shift: Y6 },
  { mac: "Ctrl-ArrowUp", run: G6, shift: K6 },
  { key: "ArrowDown", run: QP, shift: iR, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: J6, shift: Z6 },
  { mac: "Ctrl-ArrowDown", run: lC, shift: Q6 },
  { key: "PageUp", run: G6, shift: K6 },
  { key: "PageDown", run: lC, shift: Q6 },
  { key: "Home", run: Ete, shift: Lte, preventDefault: !0 },
  { key: "Mod-Home", run: X6, shift: Y6 },
  { key: "End", run: Ate, shift: Bte, preventDefault: !0 },
  { key: "Mod-End", run: J6, shift: Z6 },
  { key: "Enter", run: e8, shift: e8 },
  { key: "Mod-a", run: Hte },
  { key: "Backspace", run: uC, shift: uC, preventDefault: !0 },
  { key: "Delete", run: lR, preventDefault: !0 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: cR, preventDefault: !0 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Xte, preventDefault: !0 },
  { mac: "Mod-Backspace", run: Yte, preventDefault: !0 },
  { mac: "Mod-Delete", run: Zte, preventDefault: !0 }
].concat(/* @__PURE__ */ fre.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), pre = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: _te, shift: $te },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: Ste, shift: Ite },
  { key: "Alt-ArrowUp", run: rre },
  { key: "Shift-Alt-ArrowUp", run: ire },
  { key: "Alt-ArrowDown", run: nre },
  { key: "Shift-Alt-ArrowDown", run: ore },
  { key: "Mod-Alt-ArrowUp", run: Gte },
  { key: "Mod-Alt-ArrowDown", run: Kte },
  { key: "Escape", run: Qte },
  { key: "Mod-Enter", run: lre },
  { key: "Alt-l", mac: "Ctrl-l", run: Vte },
  { key: "Mod-i", run: Wte, preventDefault: !0 },
  { key: "Mod-[", run: mR },
  { key: "Mod-]", run: pR },
  { key: "Mod-Alt-\\", run: ure },
  { key: "Shift-Mod-k", run: sre },
  { key: "Shift-Mod-\\", run: Pte },
  { key: "Mod-/", run: rte },
  { key: "Alt-A", run: ite },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: cre }
].concat(dre);
class w1 {
  /**
  @internal
  */
  constructor(e, r, n, i, o, s, a, l, u, c = 0, h) {
    this.p = e, this.stack = r, this.state = n, this.reducePos = i, this.pos = o, this.score = s, this.buffer = a, this.bufferBase = l, this.curContext = u, this.lookAhead = c, this.parent = h;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, r, n = 0) {
    let i = e.parser.context;
    return new w1(e, [], r, n, n, 0, [], 0, i ? new t8(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var r;
    let n = e >> 19, i = e & 65535, { parser: o } = this.p, s = this.reducePos < this.pos - 25;
    s && this.setLookAhead(this.pos);
    let a = o.dynamicPrecedence(i);
    if (a && (this.score += a), n == 0) {
      this.pushState(o.getGoto(this.state, i, !0), this.reducePos), i < o.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, s ? 8 : 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let l = this.stack.length - (n - 1) * 3 - (e & 262144 ? 6 : 0), u = l ? this.stack[l - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((r = this.p.parser.nodeSet.types[i]) === null || r === void 0) && r.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let h = l ? this.stack[l - 1] : 0, d = this.bufferBase + this.buffer.length - h;
    if (i < o.minRepeatTerm || e & 131072) {
      let p = o.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, u, p, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let p = this.stack[l - 3];
      this.state = o.getGoto(p, i, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(i, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, r, n, i = 4, o = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (r == n)
          return;
        if (s.buffer[a - 2] >= r) {
          s.buffer[a - 2] = n;
          return;
        }
      }
    }
    if (!o || this.pos == n)
      this.buffer.push(e, r, n, i);
    else {
      let s = this.buffer.length;
      if (s > 0 && (this.buffer[s - 4] != 0 || this.buffer[s - 1] < 0)) {
        let a = !1;
        for (let l = s; l > 0 && this.buffer[l - 2] > n; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; s > 0 && this.buffer[s - 2] > n; )
            this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, i > 4 && (i -= 4);
      }
      this.buffer[s] = e, this.buffer[s + 1] = r, this.buffer[s + 2] = n, this.buffer[s + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, r, n, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let o = e, { parser: s } = this.p;
      (i > this.pos || r <= s.maxNode) && (this.pos = i, s.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(o, n), this.shiftContext(r, n), r <= s.maxNode && this.buffer.push(r, n, i, 4);
    } else
      this.pos = i, this.shiftContext(r, n), r <= this.p.parser.maxNode && this.buffer.push(r, n, i, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, r, n, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, n, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, r) {
    let n = this.p.reused.length - 1;
    (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(r, i), this.buffer.push(
      n,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; )
      r -= 4;
    let n = e.buffer.slice(r), i = e.bufferBase + r;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new w1(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, r) {
    let n = e <= this.p.parser.maxNode;
    n && this.storeNode(e, this.pos, r, 4), this.storeNode(0, this.pos, r, n ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let r = new mre(this); ; ) {
      let n = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, e);
      if (n == 0)
        return !1;
      if ((n & 65536) == 0)
        return !0;
      r.reduce(n);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, s; o < r.length; o += 2)
        (s = r[o + 1]) != this.state && this.p.parser.hasAction(s, e) && i.push(r[o], s);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 8 && o < r.length; o += 2) {
          let s = r[o + 1];
          i.some((a, l) => l & 1 && a == s) || i.push(r[o], s);
        }
      r = i;
    }
    let n = [];
    for (let i = 0; i < r.length && n.length < 4; i += 2) {
      let o = r[i + 1];
      if (o == this.state)
        continue;
      let s = this.split();
      s.pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(r[i], this.pos), s.reducePos = this.pos, s.score -= 200, n.push(s);
    }
    return n;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, r = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((r & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, r)) {
      let n = r >> 19, i = r & 65535, o = this.stack.length - n * 3;
      if (o < 0 || e.getGoto(this.stack[o], i, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return !1;
        r = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, r = [], n = (i, o) => {
      if (!r.includes(i))
        return r.push(i), e.allActions(i, (s) => {
          if (!(s & 393216)) if (s & 65536) {
            let a = (s >> 19) - o;
            if (a > 1) {
              let l = s & 65535, u = this.stack.length - a * 3;
              if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                return a << 19 | 65536 | l;
            }
          } else {
            let a = n(s, o + 1);
            if (a != null)
              return a;
          }
        });
    };
    return n(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != e.stack[r])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new t8(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class t8 {
  constructor(e, r) {
    this.tracker = e, this.context = r, this.hash = e.strict ? e.hash(r) : 0;
  }
}
class mre {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let r = e & 65535, n = e >> 19;
    n == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (n - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = i;
  }
}
class k1 {
  constructor(e, r, n) {
    this.stack = e, this.pos = r, this.index = n, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new k1(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new k1(this.stack, this.pos, this.index);
  }
}
function qv(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let r = null;
  for (let n = 0, i = 0; n < t.length; ) {
    let o = 0;
    for (; ; ) {
      let s = t.charCodeAt(n++), a = !1;
      if (s == 126) {
        o = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let l = s - 32;
      if (l >= 46 && (l -= 46, a = !0), o += l, a)
        break;
      o *= 46;
    }
    r ? r[i++] = o : r = new e(o);
  }
  return r;
}
class By {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const r8 = new By();
class gre {
  /**
  @internal
  */
  constructor(e, r) {
    this.input = e, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = r8, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, r) {
    let n = this.range, i = this.rangeIndex, o = this.pos + e;
    for (; o < n.from; ) {
      if (!i)
        return null;
      let s = this.ranges[--i];
      o -= n.from - s.to, n = s;
    }
    for (; r < 0 ? o > n.to : o >= n.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let s = this.ranges[++i];
      o += s.from - n.to, n = s;
    }
    return o;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let r of this.ranges)
      if (r.to > e)
        return Math.max(e, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingâ€”when looking forwardâ€”or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let r = this.chunkOff + e, n, i;
    if (r >= 0 && r < this.chunk.length)
      n = this.pos + e, i = this.chunk.charCodeAt(r);
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null)
        return -1;
      if (n = o, n >= this.chunk2Pos && n < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(n - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= n; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = n), n + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - n)), i = this.chunk2.charCodeAt(0);
      }
    }
    return n >= this.token.lookAhead && (this.token.lookAhead = n + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, r = 0) {
    let n = r ? this.resolveOffset(r, -1) : this.pos;
    if (n == null || n < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = n;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, r) {
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), r = this.pos + e.length;
      this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, r) {
    if (r ? (this.token = r, r.start = e, r.lookAhead = e + 1, r.value = r.extended = -1) : this.token = r8, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to)
      return this.input.read(e, r);
    let n = "";
    for (let i of this.ranges) {
      if (i.from >= r)
        break;
      i.to > e && (n += this.input.read(Math.max(i.from, e), Math.min(i.to, r)));
    }
    return n;
  }
}
class Gf {
  constructor(e, r) {
    this.data = e, this.id = r;
  }
  token(e, r) {
    let { parser: n } = r.p;
    yre(this.data, e, r, this.id, n.data, n.tokenPrecTable);
  }
}
Gf.prototype.contextual = Gf.prototype.fallback = Gf.prototype.extend = !1;
Gf.prototype.fallback = Gf.prototype.extend = !1;
class vre {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, r = {}) {
    this.token = e, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
}
function yre(t, e, r, n, i, o) {
  let s = 0, a = 1 << n, { dialect: l } = r.p.parser;
  e: for (; (a & t[s]) != 0; ) {
    let u = t[s + 1];
    for (let p = s + 3; p < u; p += 2)
      if ((t[p + 1] & a) > 0) {
        let g = t[p];
        if (l.allows(g) && (e.token.value == -1 || e.token.value == g || bre(g, e.token.value, i, o))) {
          e.acceptToken(g);
          break;
        }
      }
    let c = e.next, h = 0, d = t[s + 2];
    if (e.next < 0 && d > h && t[u + d * 3 - 3] == 65535) {
      s = t[u + d * 3 - 1];
      continue e;
    }
    for (; h < d; ) {
      let p = h + d >> 1, g = u + p + (p << 1), v = t[g], y = t[g + 1] || 65536;
      if (c < v)
        d = p;
      else if (c >= y)
        h = p + 1;
      else {
        s = t[g + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function n8(t, e, r) {
  for (let n = e, i; (i = t[n]) != 65535; n++)
    if (i == r)
      return n - e;
  return -1;
}
function bre(t, e, r, n) {
  let i = n8(r, n, e);
  return i < 0 || n8(r, n, t) < i;
}
const So = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let B2 = null;
function i8(t, e, r) {
  let n = t.cursor(Nn.IncludeAnonymous);
  for (n.moveTo(e); ; )
    if (!(r < 0 ? n.childBefore(e) : n.childAfter(e)))
      for (; ; ) {
        if ((r < 0 ? n.to < e : n.from > e) && !n.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            n.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            n.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (r < 0 ? n.prevSibling() : n.nextSibling())
          break;
        if (!n.parent())
          return r < 0 ? 0 : t.length;
      }
}
class xre {
  constructor(e, r) {
    this.fragments = e, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? i8(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? i8(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let n = this.trees[r], i = this.index[r];
      if (i == n.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = n.children[i], s = this.start[r] + n.positions[i];
      if (s > e)
        return this.nextStart = s, null;
      if (o instanceof xn) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let a = s + o.length;
          if (a <= this.safeTo) {
            let l = o.prop(Pt.lookAhead);
            if (!l || a + l < this.fragment.to)
              return o;
          }
        }
        this.index[r]++, s + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(s), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = s + o.length;
    }
  }
}
class wre {
  constructor(e, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((n) => new By());
  }
  getActions(e) {
    let r = 0, n = null, { parser: i } = e.p, { tokenizers: o } = i, s = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < o.length; u++) {
      if ((1 << u & s) == 0)
        continue;
      let c = o[u], h = this.tokens[u];
      if (!(n && !c.fallback) && ((c.contextual || h.start != e.pos || h.mask != s || h.context != a) && (this.updateCachedToken(h, c, e), h.mask = s, h.context = a), h.lookAhead > h.end + 25 && (l = Math.max(h.lookAhead, l)), h.value != 0)) {
        let d = r;
        if (h.extended > -1 && (r = this.addActions(e, h.extended, h.end, r)), r = this.addActions(e, h.value, h.end, r), !c.extend && (n = h, r > d))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return l && e.setLookAhead(l), !n && e.pos == this.stream.end && (n = new By(), n.value = e.p.parser.eofTerm, n.start = n.end = e.pos, r = this.addActions(e, n.value, n.end, r)), this.mainToken = n, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let r = new By(), { pos: n, p: i } = e;
    return r.start = n, r.end = Math.min(n + 1, i.stream.end), r.value = n == i.stream.end ? i.parser.eofTerm : 0, r;
  }
  updateCachedToken(e, r, n) {
    let i = this.stream.clipPos(n.pos);
    if (r.token(this.stream.reset(i, e), n), e.value > -1) {
      let { parser: o } = n.p;
      for (let s = 0; s < o.specialized.length; s++)
        if (o.specialized[s] == e.value) {
          let a = o.specializers[s](this.stream.read(e.start, e.end), n);
          if (a >= 0 && n.p.parser.dialect.allows(a >> 1)) {
            (a & 1) == 0 ? e.value = a >> 1 : e.extended = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, r, n, i) {
    for (let o = 0; o < i; o += 3)
      if (this.actions[o] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = r, this.actions[i++] = n, i;
  }
  addActions(e, r, n, i) {
    let { state: o } = e, { parser: s } = e.p, { data: a } = s;
    for (let l = 0; l < 2; l++)
      for (let u = s.stateSlot(
        o,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (a[u] == 65535)
          if (a[u + 1] == 1)
            u = Ml(a, u + 2);
          else {
            i == 0 && a[u + 1] == 2 && (i = this.putAction(Ml(a, u + 2), r, n, i));
            break;
          }
        a[u] == r && (i = this.putAction(Ml(a, u + 1), r, n, i));
      }
    return i;
  }
}
class kre {
  constructor(e, r, n, i) {
    this.parser = e, this.input = r, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new gre(r, i), this.tokens = new wre(e, this.stream), this.topTerm = e.top[1];
    let { from: o } = i[0];
    this.stacks = [w1.start(this, e.top[0], o)], this.fragments = n.length && this.stream.end - o > e.bufferLength * 4 ? new xre(n, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, r = this.minStackPos, n = this.stacks = [], i, o;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > r)
          n.push(a);
        else {
          if (this.advanceStack(a, n, e))
            continue;
          {
            i || (i = [], o = []), i.push(a);
            let l = this.tokens.getMainToken(a);
            o.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!n.length) {
      let s = i && _re(i);
      if (s)
        return So && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw So && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let s = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, n);
      if (s)
        return So && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n.length > s)
        for (n.sort((a, l) => l.score - a.score); n.length > s; )
          n.pop();
      n.some((a) => a.reducePos > r) && this.recovering--;
    } else if (n.length > 1) {
      e: for (let s = 0; s < n.length - 1; s++) {
        let a = n[s];
        for (let l = s + 1; l < n.length; l++) {
          let u = n[l];
          if (a.sameState(u) || a.buffer.length > 500 && u.buffer.length > 500)
            if ((a.score - u.score || a.buffer.length - u.buffer.length) > 0)
              n.splice(l--, 1);
            else {
              n.splice(s--, 1);
              continue e;
            }
        }
      }
      n.length > 12 && n.splice(
        12,
        n.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = n[0].pos;
    for (let s = 1; s < n.length; s++)
      n[s].pos < this.minStackPos && (this.minStackPos = n[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, r, n) {
    let i = e.pos, { parser: o } = this, s = So ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, c = u ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(i); h; ) {
        let d = this.parser.nodeSet.types[h.type.id] == h.type ? o.getGoto(e.state, h.type.id) : -1;
        if (d > -1 && h.length && (!u || (h.prop(Pt.contextHash) || 0) == c))
          return e.useNode(h, d), So && console.log(s + this.stackID(e) + ` (via reuse of ${o.getName(h.type.id)})`), !0;
        if (!(h instanceof xn) || h.children.length == 0 || h.positions[0] > 0)
          break;
        let p = h.children[0];
        if (p instanceof xn && h.positions[0] == 0)
          h = p;
        else
          break;
      }
    }
    let a = o.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), So && console.log(s + this.stackID(e) + ` (via always-reduce ${o.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let c = l[u++], h = l[u++], d = l[u++], p = u == l.length || !n, g = p ? e : e.split(), v = this.tokens.mainToken;
      if (g.apply(c, h, v ? v.start : g.pos, d), So && console.log(s + this.stackID(g) + ` (via ${(c & 65536) == 0 ? "shift" : `reduce of ${o.getName(
        c & 65535
        /* Action.ValueMask */
      )}`} for ${o.getName(h)} @ ${i}${g == e ? "" : ", split"})`), p)
        return !0;
      g.pos > i ? r.push(g) : n.push(g);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, r) {
    let n = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > n)
        return o8(e, r), !0;
    }
  }
  runRecovery(e, r, n) {
    let i = null, o = !1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = r[s << 1], u = r[(s << 1) + 1], c = So ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (o || (o = !0, a.restart(), So && console.log(c + this.stackID(a) + " (restarted)"), this.advanceFully(a, n))))
        continue;
      let h = a.split(), d = c;
      for (let p = 0; p < 10 && h.forceReduce() && (So && console.log(d + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, n)); p++)
        So && (d = this.stackID(h) + " -> ");
      for (let p of a.recoverByInsert(l))
        So && console.log(c + this.stackID(p) + " (via recover-insert)"), this.advanceFully(p, n);
      this.stream.end > a.pos ? (u == a.pos && (u++, l = 0), a.recoverByDelete(l, u), So && console.log(c + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), o8(a, n)) : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), xn.build({
      buffer: k1.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let r = (B2 || (B2 = /* @__PURE__ */ new WeakMap())).get(e);
    return r || B2.set(e, r = String.fromCodePoint(this.nextStackID++)), r + e;
  }
}
function o8(t, e) {
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    if (n.pos == t.pos && n.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class Cre {
  constructor(e, r, n) {
    this.source = e, this.flags = r, this.disabled = n;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
class ug extends dP {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      r.push("");
    let n = Object.keys(e.topRules).map((a) => e.topRules[a][1]), i = [];
    for (let a = 0; a < r.length; a++)
      i.push([]);
    function o(a, l, u) {
      i[a].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = Pt[l]);
        for (let u = 1; u < a.length; ) {
          let c = a[u++];
          if (c >= 0)
            o(c, l, a[u++]);
          else {
            let h = a[u + -c];
            for (let d = -c; d > 0; d--)
              o(a[u++], l, h);
            u++;
          }
        }
      }
    this.nodeSet = new h4(r.map((a, l) => uo.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: i[l],
      top: n.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = uP;
    let s = qv(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(s8), this.states = qv(e.states, Uint32Array), this.data = qv(e.stateData), this.goto = qv(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new Gf(s, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, r, n) {
    let i = new kre(this, e, r, n);
    for (let o of this.wrappers)
      i = o(i, e, r, n);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, r, n = !1) {
    let i = this.goto;
    if (r >= i[0])
      return -1;
    for (let o = i[r + 1]; ; ) {
      let s = i[o++], a = s & 1, l = i[o++];
      if (a && n)
        return l;
      for (let u = o + (s >> 1); o < u; o++)
        if (i[o] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, r) {
    let n = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), s; ; o += 3) {
        if ((s = n[o]) == 65535)
          if (n[o + 1] == 1)
            s = n[o = Ml(n, o + 2)];
          else {
            if (n[o + 1] == 2)
              return Ml(n, o + 2);
            break;
          }
        if (s == r || s == 0)
          return Ml(n, o + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(e, r) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(e, r) {
    return !!this.allActions(e, (n) => n == r ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, r) {
    let n = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = n ? r(n) : void 0;
    for (let o = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1)
          o = Ml(this.data, o + 2);
        else
          break;
      i = r(Ml(this.data, o + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let r = [];
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = Ml(this.data, n + 2);
        else
          break;
      if ((this.data[n + 2] & 1) == 0) {
        let i = this.data[n + 1];
        r.some((o, s) => s & 1 && o == i) || r.push(this.data[n], i);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let r = Object.assign(Object.create(ug.prototype), this);
    if (e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let n = this.topRules[e.top];
      if (!n)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = n;
    }
    return e.tokenizers && (r.tokenizers = this.tokenizers.map((n) => {
      let i = e.tokenizers.find((o) => o.from == n);
      return i ? i.to : n;
    })), e.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((n, i) => {
      let o = e.specializers.find((a) => a.from == n.external);
      if (!o)
        return n;
      let s = Object.assign(Object.assign({}, n), { external: o.to });
      return r.specializers[i] = s8(s), s;
    })), e.contextTracker && (r.context = e.contextTracker), e.dialect && (r.dialect = this.parseDialect(e.dialect)), e.strict != null && (r.strict = e.strict), e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)), e.bufferLength != null && (r.bufferLength = e.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let r = Object.keys(this.dialects), n = r.map(() => !1);
    if (e)
      for (let o of e.split(" ")) {
        let s = r.indexOf(o);
        s >= 0 && (n[s] = !0);
      }
    let i = null;
    for (let o = 0; o < r.length; o++)
      if (!n[o])
        for (let s = this.dialects[r[o]], a; (a = this.data[s++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new Cre(e, n, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new ug(e);
  }
}
function Ml(t, e) {
  return t[e] | t[e + 1] << 16;
}
function _re(t) {
  let e = null;
  for (let r of t) {
    let n = r.p.stoppedAt;
    (r.pos == r.p.stream.end || n != null && r.pos > n) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < r.score) && (e = r);
  }
  return e;
}
function s8(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, n) => t.external(r, n) << 1 | e;
  }
  return t.get;
}
const Sre = 36, a8 = 1, Are = 2, vf = 3, L2 = 4, Ere = 5, Dre = 6, Ore = 7, Fre = 8, Tre = 9, Mre = 10, Pre = 11, Rre = 12, Nre = 13, $re = 14, Ire = 15, Bre = 16, Lre = 17, l8 = 18, zre = 19, gR = 20, vR = 21, u8 = 22, jre = 23, qre = 24;
function cC(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57;
}
function Ure(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function Nc(t, e, r) {
  for (let n = !1; ; ) {
    if (t.next < 0)
      return;
    if (t.next == e && !n) {
      t.advance();
      return;
    }
    n = r && !n && t.next == 92, t.advance();
  }
}
function Hre(t, e) {
  e: for (; ; ) {
    if (t.next < 0)
      return;
    if (t.next == 36) {
      t.advance();
      for (let r = 0; r < e.length; r++) {
        if (t.next != e.charCodeAt(r))
          continue e;
        t.advance();
      }
      if (t.next == 36) {
        t.advance();
        return;
      }
    } else
      t.advance();
  }
}
function Vre(t, e) {
  let r = "[{<(".indexOf(String.fromCharCode(e)), n = r < 0 ? e : "]}>)".charCodeAt(r);
  for (; ; ) {
    if (t.next < 0)
      return;
    if (t.next == n && t.peek(1) == 39) {
      t.advance(2);
      return;
    }
    t.advance();
  }
}
function hC(t, e) {
  for (; !(t.next != 95 && !cC(t.next)); )
    e != null && (e += String.fromCharCode(t.next)), t.advance();
  return e;
}
function Wre(t) {
  if (t.next == 39 || t.next == 34 || t.next == 96) {
    let e = t.next;
    t.advance(), Nc(t, e, !1);
  } else
    hC(t);
}
function c8(t, e) {
  for (; t.next == 48 || t.next == 49; )
    t.advance();
  e && t.next == e && t.advance();
}
function h8(t, e) {
  for (; ; ) {
    if (t.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (t.next < 48 || t.next > 57)
      break;
    t.advance();
  }
  if (t.next == 69 || t.next == 101)
    for (t.advance(), (t.next == 43 || t.next == 45) && t.advance(); t.next >= 48 && t.next <= 57; )
      t.advance();
}
function f8(t) {
  for (; !(t.next < 0 || t.next == 10); )
    t.advance();
}
function Tc(t, e) {
  for (let r = 0; r < e.length; r++)
    if (e.charCodeAt(r) == t)
      return !0;
  return !1;
}
const z2 = ` 	\r
`;
function yR(t, e, r) {
  let n = /* @__PURE__ */ Object.create(null);
  n.true = n.false = Ere, n.null = n.unknown = Dre;
  for (let i of t.split(" "))
    i && (n[i] = gR);
  for (let i of e.split(" "))
    i && (n[i] = vR);
  for (let i of (r || "").split(" "))
    i && (n[i] = qre);
  return n;
}
const bR = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", xR = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", fC = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: !1,
  words: /* @__PURE__ */ yR(xR, bR)
};
function Gre(t, e, r, n) {
  let i = {};
  for (let o in fC)
    i[o] = (t.hasOwnProperty(o) ? t : fC)[o];
  return e && (i.words = yR(e, r || "", n)), i;
}
function wR(t) {
  return new vre((e) => {
    var r;
    let { next: n } = e;
    if (e.advance(), Tc(n, z2)) {
      for (; Tc(e.next, z2); )
        e.advance();
      e.acceptToken(Sre);
    } else if (n == 36 && t.doubleDollarQuotedStrings) {
      let i = hC(e, "");
      e.next == 36 && (e.advance(), Hre(e, i), e.acceptToken(vf));
    } else if (n == 39 || n == 34 && t.doubleQuotedStrings)
      Nc(e, n, t.backslashEscapes), e.acceptToken(vf);
    else if (n == 35 && t.hashComments || n == 47 && e.next == 47 && t.slashComments)
      f8(e), e.acceptToken(a8);
    else if (n == 45 && e.next == 45 && (!t.spaceAfterDashes || e.peek(1) == 32))
      f8(e), e.acceptToken(a8);
    else if (n == 47 && e.next == 42) {
      e.advance();
      for (let i = 1; ; ) {
        let o = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), o == 42 && e.next == 47) {
          if (i--, e.advance(), !i)
            break;
        } else o == 47 && e.next == 42 && (i++, e.advance());
      }
      e.acceptToken(Are);
    } else if ((n == 101 || n == 69) && e.next == 39)
      e.advance(), Nc(e, 39, !0), e.acceptToken(vf);
    else if ((n == 110 || n == 78) && e.next == 39 && t.charSetCasts)
      e.advance(), Nc(e, 39, t.backslashEscapes), e.acceptToken(vf);
    else if (n == 95 && t.charSetCasts)
      for (let i = 0; ; i++) {
        if (e.next == 39 && i > 1) {
          e.advance(), Nc(e, 39, t.backslashEscapes), e.acceptToken(vf);
          break;
        }
        if (!cC(e.next))
          break;
        e.advance();
      }
    else if (t.plsqlQuotingMechanism && (n == 113 || n == 81) && e.next == 39 && e.peek(1) > 0 && !Tc(e.peek(1), z2)) {
      let i = e.peek(1);
      e.advance(2), Vre(e, i), e.acceptToken(vf);
    } else if (Tc(n, t.identifierQuotes)) {
      const i = n == 91 ? 93 : n;
      Nc(e, i, !1), e.acceptToken(zre);
    } else if (n == 40)
      e.acceptToken(Ore);
    else if (n == 41)
      e.acceptToken(Fre);
    else if (n == 123)
      e.acceptToken(Tre);
    else if (n == 125)
      e.acceptToken(Mre);
    else if (n == 91)
      e.acceptToken(Pre);
    else if (n == 93)
      e.acceptToken(Rre);
    else if (n == 59)
      e.acceptToken(Nre);
    else if (t.unquotedBitLiterals && n == 48 && e.next == 98)
      e.advance(), c8(e), e.acceptToken(u8);
    else if ((n == 98 || n == 66) && (e.next == 39 || e.next == 34)) {
      const i = e.next;
      e.advance(), t.treatBitsAsBytes ? (Nc(e, i, t.backslashEscapes), e.acceptToken(jre)) : (c8(e, i), e.acceptToken(u8));
    } else if (n == 48 && (e.next == 120 || e.next == 88) || (n == 120 || n == 88) && e.next == 39) {
      let i = e.next == 39;
      for (e.advance(); Ure(e.next); )
        e.advance();
      i && e.next == 39 && e.advance(), e.acceptToken(L2);
    } else if (n == 46 && e.next >= 48 && e.next <= 57)
      h8(e, !0), e.acceptToken(L2);
    else if (n == 46)
      e.acceptToken($re);
    else if (n >= 48 && n <= 57)
      h8(e, !1), e.acceptToken(L2);
    else if (Tc(n, t.operatorChars)) {
      for (; Tc(e.next, t.operatorChars); )
        e.advance();
      e.acceptToken(Ire);
    } else if (Tc(n, t.specialVar))
      e.next == n && e.advance(), Wre(e), e.acceptToken(Lre);
    else if (n == 58 || n == 44)
      e.acceptToken(Bre);
    else if (cC(n)) {
      let i = hC(e, String.fromCharCode(n));
      e.acceptToken(e.next == 46 || e.peek(-i.length - 1) == 46 ? l8 : (r = t.words[i.toLowerCase()]) !== null && r !== void 0 ? r : l8);
    }
  });
}
const kR = /* @__PURE__ */ wR(fC), Kre = /* @__PURE__ */ ug.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "âš  LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, kR],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function dC(t) {
  let e = t.cursor().moveTo(t.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function cg(t, e) {
  let r = t.sliceString(e.from, e.to), n = /^([`'"\[])(.*)([`'"\]])$/.exec(r);
  return n ? n[2] : r;
}
function C1(t) {
  return t && (t.name == "Identifier" || t.name == "QuotedIdentifier");
}
function Qre(t, e) {
  if (e.name == "CompositeIdentifier") {
    let r = [];
    for (let n = e.firstChild; n; n = n.nextSibling)
      C1(n) && r.push(cg(t, n));
    return r;
  }
  return [cg(t, e)];
}
function d8(t, e) {
  for (let r = []; ; ) {
    if (!e || e.name != ".")
      return r;
    let n = dC(e);
    if (!C1(n))
      return r;
    r.unshift(cg(t, n)), e = dC(n);
  }
}
function Xre(t, e) {
  let r = Dn(t).resolveInner(e, -1), n = Yre(t.doc, r);
  return r.name == "Identifier" || r.name == "QuotedIdentifier" || r.name == "Keyword" ? {
    from: r.from,
    quoted: r.name == "QuotedIdentifier" ? t.doc.sliceString(r.from, r.from + 1) : null,
    parents: d8(t.doc, dC(r)),
    aliases: n
  } : r.name == "." ? { from: e, quoted: null, parents: d8(t.doc, r), aliases: n } : { from: e, quoted: null, parents: [], empty: !0, aliases: n };
}
const Jre = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function Yre(t, e) {
  let r;
  for (let i = e; !r; i = i.parent) {
    if (!i)
      return null;
    i.name == "Statement" && (r = i);
  }
  let n = null;
  for (let i = r.firstChild, o = !1, s = null; i; i = i.nextSibling) {
    let a = i.name == "Keyword" ? t.sliceString(i.from, i.to).toLowerCase() : null, l = null;
    if (!o)
      o = a == "from";
    else if (a == "as" && s && C1(i.nextSibling))
      l = cg(t, i.nextSibling);
    else {
      if (a && Jre.has(a))
        break;
      s && C1(i) && (l = cg(t, i));
    }
    l && (n || (n = /* @__PURE__ */ Object.create(null)), n[l] = Qre(t, s)), s = /Identifier$/.test(i.name) ? i : null;
  }
  return n;
}
function Zre(t, e, r) {
  return r.map((n) => ({ ...n, label: n.label[0] == t ? n.label : t + n.label + e, apply: void 0 }));
}
const ene = /^\w*$/, tne = /^[`'"\[]?\w*[`'"\]]?$/;
function p8(t) {
  return t.self && typeof t.self.label == "string";
}
class O4 {
  constructor(e, r) {
    this.idQuote = e, this.idCaseInsensitive = r, this.list = [], this.children = void 0;
  }
  child(e) {
    let r = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return r[e] || (e && !this.list.some((i) => i.label == e) && this.list.push(m8(e, "type", this.idQuote, this.idCaseInsensitive)), r[e] = new O4(this.idQuote, this.idCaseInsensitive));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let r = this.list.findIndex((n) => n.label == e.label);
    r > -1 ? this.list[r] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let r of e)
      this.addCompletion(typeof r == "string" ? m8(r, "property", this.idQuote, this.idCaseInsensitive) : r);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : p8(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let r of Object.keys(e)) {
      let n = e[r], i = null, o = r.replace(/\\?\./g, (a) => a == "." ? "\0" : a).split("\0"), s = this;
      p8(n) && (i = n.self, n = n.children);
      for (let a = 0; a < o.length; a++)
        i && a == o.length - 1 && s.addCompletion(i), s = s.child(o[a].replace(/\\\./g, "."));
      s.addNamespace(n);
    }
  }
}
function m8(t, e, r, n) {
  return new RegExp("^[a-z_][a-z_\\d]*$", n ? "i" : "").test(t) ? { label: t, type: e } : { label: t, type: e, apply: r + t + CR(r) };
}
function CR(t) {
  return t === "[" ? "]" : t;
}
function rne(t, e, r, n, i, o) {
  var s;
  let a = ((s = o?.spec.identifierQuotes) === null || s === void 0 ? void 0 : s[0]) || '"', l = new O4(a, !!o?.spec.caseInsensitiveIdentifiers), u = i ? l.child(i) : null;
  return l.addNamespace(t), e && (u || l).addCompletions(e), r && l.addCompletions(r), u && l.addCompletions(u.list), n && l.addCompletions((u || l).child(n).list), (c) => {
    let { parents: h, from: d, quoted: p, empty: g, aliases: v } = Xre(c.state, c.pos);
    if (g && !c.explicit)
      return null;
    v && h.length == 1 && (h = v[h[0]] || h);
    let y = l;
    for (let k of h) {
      for (; !y.children || !y.children[k]; )
        if (y == l && u)
          y = u;
        else if (y == u && n)
          y = y.child(n);
        else
          return null;
      let C = y.maybeChild(k);
      if (!C)
        return null;
      y = C;
    }
    let b = y.list;
    if (y == l && v && (b = b.concat(Object.keys(v).map((k) => ({ label: k, type: "constant" })))), p) {
      let k = p[0], C = CR(k), S = c.state.sliceDoc(c.pos, c.pos + 1) == C;
      return {
        from: d,
        to: S ? c.pos + 1 : void 0,
        options: Zre(k, C, b),
        validFor: tne
      };
    } else
      return {
        from: d,
        options: b,
        validFor: ene
      };
  };
}
function nne(t) {
  return t == vR ? "type" : t == gR ? "keyword" : "variable";
}
function ine(t, e, r) {
  let n = Object.keys(t).map((i) => r(e ? i.toUpperCase() : i, nne(t[i])));
  return see(["QuotedIdentifier", "String", "LineComment", "BlockComment", "."], AP(n));
}
let one = /* @__PURE__ */ Kre.configure({
  props: [
    /* @__PURE__ */ v4.add({
      Statement: /* @__PURE__ */ rC()
    }),
    /* @__PURE__ */ bP.add({
      Statement(t, e) {
        return { from: Math.min(t.from + 100, e.doc.lineAt(t.from).to), to: t.to };
      },
      BlockComment(t) {
        return { from: t.from + 2, to: t.to - 2 };
      }
    }),
    /* @__PURE__ */ m4({
      Keyword: oe.keyword,
      Type: oe.typeName,
      Builtin: /* @__PURE__ */ oe.standard(oe.name),
      Bits: oe.number,
      Bytes: oe.string,
      Bool: oe.bool,
      Null: oe.null,
      Number: oe.number,
      String: oe.string,
      Identifier: oe.name,
      QuotedIdentifier: /* @__PURE__ */ oe.special(oe.string),
      SpecialVar: /* @__PURE__ */ oe.special(oe.name),
      LineComment: oe.lineComment,
      BlockComment: oe.blockComment,
      Operator: oe.operator,
      "Semi Punctuation": oe.punctuation,
      "( )": oe.paren,
      "{ }": oe.brace,
      "[ ]": oe.squareBracket
    })
  ]
});
class hg {
  constructor(e, r, n) {
    this.dialect = e, this.language = r, this.spec = n;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Reconfigure the parser used by this dialect. Returns a new
  dialect object.
  */
  configureLanguage(e, r) {
    return new hg(this.dialect, this.language.configure(e, r), this.spec);
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let r = Gre(e, e.keywords, e.types, e.builtin), n = ig.define({
      name: "sql",
      parser: one.configure({
        tokenizers: [{ from: kR, to: wR(r) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new hg(r, n, e);
  }
}
function sne(t, e) {
  return { label: t, type: e, boost: -1 };
}
function ane(t, e = !1, r) {
  return ine(t.dialect.words, e, r || sne);
}
function lne(t) {
  return t.schema ? rne(t.schema, t.tables, t.schemas, t.defaultTable, t.defaultSchema, t.dialect || F4) : () => null;
}
function une(t) {
  return t.schema ? (t.dialect || F4).language.data.of({
    autocomplete: lne(t)
  }) : [];
}
function cne(t = {}) {
  let e = t.dialect || F4;
  return new vP(e.language, [
    une(t),
    e.language.data.of({
      autocomplete: ane(e, t.upperCaseKeywords, t.keywordCompletion)
    })
  ]);
}
const F4 = /* @__PURE__ */ hg.define({}), hne = /* @__PURE__ */ hg.define({
  charSetCasts: !0,
  doubleDollarQuotedStrings: !0,
  operatorChars: "+-*/<>=~!@#%^&|`?",
  specialVar: "",
  keywords: xR + "abort abs absent access according ada admin aggregate alias also always analyse analyze array_agg array_max_cardinality asensitive assert assignment asymmetric atomic attach attribute attributes avg backward base64 begin_frame begin_partition bernoulli bit_length blocked bom cache called cardinality catalog_name ceil ceiling chain char_length character_length character_set_catalog character_set_name character_set_schema characteristics characters checkpoint class class_origin cluster coalesce cobol collation_catalog collation_name collation_schema collect column_name columns command_function command_function_code comment comments committed concurrently condition_number configuration conflict connection_name constant constraint_catalog constraint_name constraint_schema contains content control conversion convert copy corr cost covar_pop covar_samp csv cume_dist current_catalog current_row current_schema cursor_name database datalink datatype datetime_interval_code datetime_interval_precision db debug defaults defined definer degree delimiter delimiters dense_rank depends derived detach detail dictionary disable discard dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue document dump dynamic_function dynamic_function_code element elsif empty enable encoding encrypted end_frame end_partition endexec enforced enum errcode error event every exclude excluding exclusive exp explain expression extension extract family file filter final first_value flag floor following force foreach fortran forward frame_row freeze fs functions fusion generated granted greatest groups handler header hex hierarchy hint id ignore ilike immediately immutable implementation implicit import include including increment indent index indexes info inherit inherits inline insensitive instance instantiable instead integrity intersection invoker isnull key_member key_type label lag last_value lead leakproof least length library like_regex link listen ln load location lock locked log logged lower mapping matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text min minvalue mod mode more move multiset mumps name namespace nfc nfd nfkc nfkd nil normalize normalized nothing notice notify notnull nowait nth_value ntile nullable nullif nulls number occurrences_regex octet_length octets off offset oids operator options ordering others over overlay overriding owned owner parallel parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partition pascal passing passthrough password percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding prepared print_strict_params procedural procedures program publication query quote raise range rank reassign recheck recovery refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex rename repeatable replace replica requiring reset respect restart restore result_oid returned_cardinality returned_length returned_octet_length returned_sqlstate returning reverse routine_catalog routine_name routine_schema routines row_count row_number rowtype rule scale schema_name schemas scope scope_catalog scope_name scope_schema security selective self sensitive sequence sequences serializable server server_name setof share show simple skip slice snapshot source specific_name sqlcode sqlerror sqrt stable stacked standalone statement statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time table_name tables tablesample tablespace temp template ties token top_level_count transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex trigger_catalog trigger_name trigger_schema trim trim_array truncate trusted type types uescape unbounded uncommitted unencrypted unlink unlisten unlogged unnamed untyped upper uri use_column use_variable user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema vacuum valid validate validator value_of var_pop var_samp varbinary variable_conflict variadic verbose version versioning views volatile warning whitespace width_bucket window within wrapper xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate yes",
  types: bR + "bigint int8 bigserial serial8 varbit bool box bytea cidr circle precision float8 inet int4 json jsonb line lseg macaddr macaddr8 money numeric pg_lsn point polygon float4 int2 smallserial serial2 serial serial4 text timetz timestamptz tsquery tsvector txid_snapshot uuid xml"
});
class g8 {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.diagnostic = n;
  }
}
class Lc {
  constructor(e, r, n) {
    this.diagnostics = e, this.panel = r, this.selected = n;
  }
  static init(e, r, n) {
    let i = n.facet(Na).markerFilter;
    i && (e = i(e, n));
    let o = e.slice().sort((p, g) => p.from - g.from || p.to - g.to), s = new rc(), a = [], l = 0, u = n.doc.iter(), c = 0, h = n.doc.length;
    for (let p = 0; ; ) {
      let g = p == o.length ? null : o[p];
      if (!g && !a.length)
        break;
      let v, y;
      if (a.length)
        v = l, y = a.reduce((C, S) => Math.min(C, S.to), g && g.from > v ? g.from : 1e8);
      else {
        if (v = g.from, v > h)
          break;
        y = g.to, a.push(g), p++;
      }
      for (; p < o.length; ) {
        let C = o[p];
        if (C.from == v && (C.to > C.from || C.to == v))
          a.push(C), p++, y = Math.min(C.to, y);
        else {
          y = Math.min(C.from, y);
          break;
        }
      }
      y = Math.min(y, h);
      let b = !1;
      if (a.some((C) => C.from == v && (C.to == y || y == h)) && (b = v == y, !b && y - v < 10)) {
        let C = v - (c + u.value.length);
        C > 0 && (u.next(C), c = v);
        for (let S = v; ; ) {
          if (S >= y) {
            b = !0;
            break;
          }
          if (!u.lineBreak && c + u.value.length > S)
            break;
          S = c + u.value.length, c += u.value.length, u.next();
        }
      }
      let k = Ane(a);
      if (b)
        s.add(v, v, pt.widget({
          widget: new kne(k),
          diagnostics: a.slice()
        }));
      else {
        let C = a.reduce((S, _) => _.markClass ? S + " " + _.markClass : S, "");
        s.add(v, y, pt.mark({
          class: "cm-lintRange cm-lintRange-" + k + C,
          diagnostics: a.slice(),
          inclusiveEnd: a.some((S) => S.to > y)
        }));
      }
      if (l = y, l == h)
        break;
      for (let C = 0; C < a.length; C++)
        a[C].to <= l && a.splice(C--, 1);
    }
    let d = s.finish();
    return new Lc(d, r, Sd(d));
  }
}
function Sd(t, e = null, r = 0) {
  let n = null;
  return t.between(r, 1e9, (i, o, { spec: s }) => {
    if (!(e && s.diagnostics.indexOf(e) < 0))
      if (!n)
        n = new g8(i, o, e || s.diagnostics[0]);
      else {
        if (s.diagnostics.indexOf(n.diagnostic) < 0)
          return !1;
        n = new g8(n.from, o, n.diagnostic);
      }
  }), n;
}
function fne(t, e) {
  let r = e.pos, n = e.end || r, i = t.state.facet(Na).hideOn(t, r, n);
  if (i != null)
    return i;
  let o = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((s) => s.is(T4)) || t.changes.touchesRange(o.from, Math.max(o.to, n)));
}
function _R(t, e) {
  return t.field(jo, !1) ? e : e.concat(_t.appendConfig.of(DR));
}
function dne(t, e) {
  return {
    effects: _R(t, [T4.of(e)])
  };
}
const T4 = /* @__PURE__ */ _t.define(), M4 = /* @__PURE__ */ _t.define(), SR = /* @__PURE__ */ _t.define(), jo = /* @__PURE__ */ jn.define({
  create() {
    return new Lc(pt.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let r = t.diagnostics.map(e.changes), n = null, i = t.panel;
      if (t.selected) {
        let o = e.changes.mapPos(t.selected.from, 1);
        n = Sd(r, t.selected.diagnostic, o) || Sd(r, null, o);
      }
      !r.size && i && e.state.facet(Na).autoPanel && (i = null), t = new Lc(r, i, n);
    }
    for (let r of e.effects)
      if (r.is(T4)) {
        let n = e.state.facet(Na).autoPanel ? r.value.length ? fg.open : null : t.panel;
        t = Lc.init(r.value, n, e.state);
      } else r.is(M4) ? t = new Lc(t.diagnostics, r.value ? fg.open : null, t.selected) : r.is(SR) && (t = new Lc(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    tg.from(t, (e) => e.panel),
    Be.decorations.from(t, (e) => e.diagnostics)
  ]
}), pne = /* @__PURE__ */ pt.mark({ class: "cm-lintRange cm-lintRange-active" });
function mne(t, e, r) {
  let { diagnostics: n } = t.state.field(jo), i, o = -1, s = -1;
  n.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (l, u, { spec: c }) => {
    if (e >= l && e <= u && (l == u || (e > l || r > 0) && (e < u || r < 0)))
      return i = c.diagnostics, o = l, s = u, !1;
  });
  let a = t.state.facet(Na).tooltipFilter;
  return i && a && (i = a(i, t.state)), i ? {
    pos: o,
    end: s,
    above: t.state.doc.lineAt(o).to < s,
    create() {
      return { dom: gne(t, i) };
    }
  } : null;
}
function gne(t, e) {
  return Er("ul", { class: "cm-tooltip-lint" }, e.map((r) => ER(t, r, !1)));
}
const vne = (t) => {
  let e = t.state.field(jo, !1);
  (!e || !e.panel) && t.dispatch({ effects: _R(t.state, [M4.of(!0)]) });
  let r = eg(t, fg.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, v8 = (t) => {
  let e = t.state.field(jo, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: M4.of(!1) }), !0);
}, yne = (t) => {
  let e = t.state.field(jo, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, n = e.diagnostics.iter(r.to + 1);
  return !n.value && (n = e.diagnostics.iter(0), !n.value || n.from == r.from && n.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0 }), !0);
}, bne = [
  { key: "Mod-Shift-m", run: vne, preventDefault: !0 },
  { key: "F8", run: yne }
], xne = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.view = t, this.timeout = -1, this.set = !0;
    let { delay: e } = t.state.facet(Na);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    clearTimeout(this.timeout);
    let t = Date.now();
    if (t < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - t);
    else {
      this.set = !1;
      let { state: e } = this.view, { sources: r } = e.facet(Na);
      r.length && wne(r.map((n) => Promise.resolve(n(this.view))), (n) => {
        this.view.state.doc == e.doc && this.view.dispatch(dne(this.view.state, n.reduce((i, o) => i.concat(o))));
      }, (n) => {
        Pi(this.view.state, n);
      });
    }
  }
  update(t) {
    let e = t.state.facet(Na);
    (t.docChanged || e != t.startState.facet(Na) || e.needsRefresh && e.needsRefresh(t)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function wne(t, e, r) {
  let n = [], i = -1;
  for (let o of t)
    o.then((s) => {
      n.push(s), clearTimeout(i), n.length == t.length ? e(n) : i = setTimeout(() => e(n), 200);
    }, r);
}
const Na = /* @__PURE__ */ Le.define({
  combine(t) {
    return {
      sources: t.map((e) => e.source).filter((e) => e != null),
      ...iu(t.map((e) => e.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        delay: Math.max,
        markerFilter: y8,
        tooltipFilter: y8,
        needsRefresh: (e, r) => e ? r ? (n) => e(n) || r(n) : e : r,
        hideOn: (e, r) => e ? r ? (n, i, o) => e(n, i, o) || r(n, i, o) : e : r,
        autoPanel: (e, r) => e || r
      })
    };
  }
});
function y8(t, e) {
  return t ? e ? (r, n) => e(t(r, n), n) : t : e;
}
function b8(t, e = {}) {
  return [
    Na.of({ source: t, config: e }),
    xne,
    DR
  ];
}
function AR(t) {
  let e = [];
  if (t)
    e: for (let { name: r } of t) {
      for (let n = 0; n < r.length; n++) {
        let i = r[n];
        if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function ER(t, e, r) {
  var n;
  let i = r ? AR(e.actions) : [];
  return Er("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Er("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (n = e.actions) === null || n === void 0 ? void 0 : n.map((o, s) => {
    let a = !1, l = (p) => {
      if (p.preventDefault(), a)
        return;
      a = !0;
      let g = Sd(t.state.field(jo).diagnostics, e);
      g && o.apply(t, g.from, g.to);
    }, { name: u } = o, c = i[s] ? u.indexOf(i[s]) : -1, h = c < 0 ? u : [
      u.slice(0, c),
      Er("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ], d = o.markClass ? " " + o.markClass : "";
    return Er("button", {
      type: "button",
      class: "cm-diagnosticAction" + d,
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${i[s]})"`}.`
    }, h);
  }), e.source && Er("div", { class: "cm-diagnosticSource" }, e.source));
}
class kne extends Bh {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Er("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class x8 {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = ER(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class fg {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (i) => {
      if (i.keyCode == 27)
        v8(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: o } = this.items[this.selectedIndex], s = AR(o.actions);
        for (let a = 0; a < s.length; a++)
          if (s[a].toUpperCase().charCodeAt(0) == i.keyCode) {
            let l = Sd(this.view.state.field(jo).diagnostics, o);
            l && o.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      i.preventDefault();
    }, n = (i) => {
      for (let o = 0; o < this.items.length; o++)
        this.items[o].dom.contains(i.target) && this.moveSelection(o);
    };
    this.list = Er("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: n
    }), this.dom = Er("div", { class: "cm-panel-lint" }, this.list, Er("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => v8(this.view)
    }, "Ã—")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(jo).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(jo), n = 0, i = !1, o = null, s = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: u }) => {
      for (let c of u.diagnostics) {
        if (s.has(c))
          continue;
        s.add(c);
        let h = -1, d;
        for (let p = n; p < this.items.length; p++)
          if (this.items[p].diagnostic == c) {
            h = p;
            break;
          }
        h < 0 ? (d = new x8(this.view, c), this.items.splice(n, 0, d), i = !0) : (d = this.items[h], h > n && (this.items.splice(n, h - n), i = !0)), r && d.diagnostic == r.diagnostic ? d.dom.hasAttribute("aria-selected") || (d.dom.setAttribute("aria-selected", "true"), o = d) : d.dom.hasAttribute("aria-selected") && d.dom.removeAttribute("aria-selected"), n++;
      }
    }); n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new x8(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let u = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / u : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let n = e;
      e = n.nextSibling, n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; )
          r();
        e = n.dom.nextSibling;
      } else
        this.list.insertBefore(n.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(jo), n = Sd(r.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({
      selection: { anchor: n.from, head: n.to },
      scrollIntoView: !0,
      effects: SR.of(n)
    });
  }
  static open(e) {
    return new fg(e);
  }
}
function Cne(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Uv(t) {
  return Cne(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const _ne = /* @__PURE__ */ Be.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Uv("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Uv("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Uv("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Uv("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function Sne(t) {
  return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
}
function Ane(t) {
  let e = "hint", r = 1;
  for (let n of t) {
    let i = Sne(n.severity);
    i > r && (r = i, e = n.severity);
  }
  return e;
}
const DR = [
  jo,
  /* @__PURE__ */ Be.decorations.compute([jo], (t) => {
    let { selected: e, panel: r } = t.field(jo);
    return !e || !r || e.from == e.to ? pt.none : pt.set([
      pne.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ oP(mne, { hideOn: fne }),
  _ne
], w8 = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class Ad {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, n = 0, i = e.length, o, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, i), this.bufferStart = n, this.normalize = o ? (a) => o(w8(a)) : w8, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Ji(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = X_(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += Aa(e);
      let i = this.normalize(r);
      if (i.length)
        for (let o = 0, s = n; ; o++) {
          let a = i.charCodeAt(o), l = this.match(a, s, this.bufferPos + this.bufferStart);
          if (o == i.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          s == n && o < r.length && r.charCodeAt(o) == a && s++;
        }
    }
  }
  match(e, r, n) {
    let i = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let s = this.matches[o], a = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = { from: this.matches[o + 1], to: n } : (this.matches[o]++, a = !0)), a || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: r, to: n } : this.matches.push(1, r)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Ad.prototype[Symbol.iterator] = function() {
  return this;
});
const OR = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, P4 = "gm" + (/x/.unicode == null ? "" : "u");
class FR {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, n, i = 0, o = e.length) {
    if (this.text = e, this.to = o, this.curLine = "", this.done = !1, this.value = OR, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new TR(e, r, n, i, o);
    this.re = new RegExp(r, P4 + (n?.ignoreCase ? "i" : "")), this.test = n?.test, this.iter = e.iter();
    let s = e.lineAt(i);
    this.curLineStart = s.from, this.matchPos = _1(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let n = this.curLineStart + r.index, i = n + r[0].length;
        if (this.matchPos = _1(this.text, i + (n == i ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < i || n > this.value.to) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const j2 = /* @__PURE__ */ new WeakMap();
class Kf {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, n) {
    let i = j2.get(e);
    if (!i || i.from >= n || i.to <= r) {
      let a = new Kf(r, e.sliceString(r, n));
      return j2.set(e, a), a;
    }
    if (i.from == r && i.to == n)
      return i;
    let { text: o, from: s } = i;
    return s > r && (o = e.sliceString(r, s) + o, s = r), i.to < n && (o += e.sliceString(i.to, n)), j2.set(e, new Kf(s, o)), new Kf(r, o.slice(r - s, n - s));
  }
}
class TR {
  constructor(e, r, n, i, o) {
    this.text = e, this.to = o, this.done = !1, this.value = OR, this.matchPos = _1(e, i), this.re = new RegExp(r, P4 + (n?.ignoreCase ? "i" : "")), this.test = n?.test, this.flat = Kf.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let n = this.flat.from + r.index, i = n + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this.matchPos = _1(this.text, i + (n == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Kf.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (FR.prototype[Symbol.iterator] = TR.prototype[Symbol.iterator] = function() {
  return this;
});
function Ene(t) {
  try {
    return new RegExp(t, P4), !0;
  } catch {
    return !1;
  }
}
function _1(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), n;
  for (; e < r.to && (n = r.text.charCodeAt(e - r.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function pC(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = Er("input", { class: "cm-textfield", name: "line", value: e }), n = Er("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), t.dispatch({ effects: Fm.of(!1) }), t.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
    },
    onsubmit: (o) => {
      o.preventDefault(), i();
    }
  }, Er("label", t.state.phrase("Go to line"), ": ", r), " ", Er("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")), Er("button", {
    name: "close",
    onclick: () => {
      t.dispatch({ effects: Fm.of(!1) }), t.focus();
    },
    "aria-label": t.state.phrase("close"),
    type: "button"
  }, ["Ã—"]));
  function i() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!o)
      return;
    let { state: s } = t, a = s.doc.lineAt(s.selection.main.head), [, l, u, c, h] = o, d = c ? +c.slice(1) : 0, p = u ? +u : a.number;
    if (u && h) {
      let y = p / 100;
      l && (y = y * (l == "-" ? -1 : 1) + a.number / s.doc.lines), p = Math.round(s.doc.lines * y);
    } else u && l && (p = p * (l == "-" ? -1 : 1) + a.number);
    let g = s.doc.line(Math.max(1, Math.min(s.doc.lines, p))), v = de.cursor(g.from + Math.max(0, Math.min(d, g.length)));
    t.dispatch({
      effects: [Fm.of(!1), Be.scrollIntoView(v.from, { y: "center" })],
      selection: v
    }), t.focus();
  }
  return { dom: n };
}
const Fm = /* @__PURE__ */ _t.define(), k8 = /* @__PURE__ */ jn.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(Fm) && (t = r.value);
    return t;
  },
  provide: (t) => tg.from(t, (e) => e ? pC : null)
}), Dne = (t) => {
  let e = eg(t, pC);
  if (!e) {
    let r = [Fm.of(!0)];
    t.state.field(k8, !1) == null && r.push(_t.appendConfig.of([k8, One])), t.dispatch({ effects: r }), e = eg(t, pC);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, One = /* @__PURE__ */ Be.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), Fne = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Tne = /* @__PURE__ */ Le.define({
  combine(t) {
    return iu(t, Fne, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Mne(t) {
  return [Ine, $ne];
}
const Pne = /* @__PURE__ */ pt.mark({ class: "cm-selectionMatch" }), Rne = /* @__PURE__ */ pt.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function C8(t, e, r, n) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != Hr.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != Hr.Word);
}
function Nne(t, e, r, n) {
  return t(e.sliceDoc(r, r + 1)) == Hr.Word && t(e.sliceDoc(n - 1, n)) == Hr.Word;
}
const $ne = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(Tne), { state: r } = t, n = r.selection;
    if (n.ranges.length > 1)
      return pt.none;
    let i = n.main, o, s = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return pt.none;
      let l = r.wordAt(i.head);
      if (!l)
        return pt.none;
      s = r.charCategorizer(i.head), o = r.sliceDoc(l.from, l.to);
    } else {
      let l = i.to - i.from;
      if (l < e.minSelectionLength || l > 200)
        return pt.none;
      if (e.wholeWords) {
        if (o = r.sliceDoc(i.from, i.to), s = r.charCategorizer(i.head), !(C8(s, r, i.from, i.to) && Nne(s, r, i.from, i.to)))
          return pt.none;
      } else if (o = r.sliceDoc(i.from, i.to), !o)
        return pt.none;
    }
    let a = [];
    for (let l of t.visibleRanges) {
      let u = new Ad(r.doc, o, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: c, to: h } = u.value;
        if ((!s || C8(s, r, c, h)) && (i.empty && c <= i.from && h >= i.to ? a.push(Rne.range(c, h)) : (c >= i.to || h <= i.from) && a.push(Pne.range(c, h)), a.length > e.maxMatches))
          return pt.none;
      }
    }
    return pt.set(a);
  }
}, {
  decorations: (t) => t.decorations
}), Ine = /* @__PURE__ */ Be.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Bne = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, n = de.create(r.ranges.map((i) => t.wordAt(i.head) || de.cursor(i.head)), r.mainIndex);
  return n.eq(r) ? !1 : (e(t.update({ selection: n })), !0);
};
function Lne(t, e) {
  let { main: r, ranges: n } = t.selection, i = t.wordAt(r.head), o = i && i.from == r.from && i.to == r.to;
  for (let s = !1, a = new Ad(t.doc, e, n[n.length - 1].to); ; )
    if (a.next(), a.done) {
      if (s)
        return null;
      a = new Ad(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), s = !0;
    } else {
      if (s && n.some((l) => l.from == a.value.from))
        continue;
      if (o) {
        let l = t.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const zne = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((o) => o.from === o.to))
    return Bne({ state: t, dispatch: e });
  let n = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != n))
    return !1;
  let i = Lne(t, n);
  return i ? (e(t.update({
    selection: t.selection.addRange(de.range(i.from, i.to), !1),
    effects: Be.scrollIntoView(i.to)
  })), !0) : !1;
}, Zd = /* @__PURE__ */ Le.define({
  combine(t) {
    return iu(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Yne(e),
      scrollToMatch: (e) => Be.scrollIntoView(e)
    });
  }
});
class MR {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Ene(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Hne(this) : new qne(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, n) {
    let i = e.doc ? e : nr.create({ doc: e });
    return n == null && (n = i.doc.length), this.regexp ? Af(this, i, r, n) : Sf(this, i, r, n);
  }
}
class PR {
  constructor(e) {
    this.spec = e;
  }
}
function Sf(t, e, r, n) {
  return new Ad(e.doc, t.unquoted, r, n, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? jne(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function jne(t, e) {
  return (r, n, i, o) => ((o > r || o + i.length < n) && (o = Math.max(0, r - 2), i = t.sliceString(o, Math.min(t.length, n + 2))), (e(S1(i, r - o)) != Hr.Word || e(A1(i, r - o)) != Hr.Word) && (e(A1(i, n - o)) != Hr.Word || e(S1(i, n - o)) != Hr.Word));
}
class qne extends PR {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, n) {
    let i = Sf(this.spec, e, n, e.doc.length).nextOverlapping();
    if (i.done) {
      let o = Math.min(e.doc.length, r + this.spec.unquoted.length);
      i = Sf(this.spec, e, 0, o).nextOverlapping();
    }
    return i.done || i.value.from == r && i.value.to == n ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, n) {
    for (let i = n; ; ) {
      let o = Math.max(r, i - 1e4 - this.spec.unquoted.length), s = Sf(this.spec, e, o, i), a = null;
      for (; !s.nextOverlapping().done; )
        a = s.value;
      if (a)
        return a;
      if (o == r)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, n) {
    let i = this.prevMatchInRange(e, 0, r);
    return i || (i = this.prevMatchInRange(e, Math.max(0, n - this.spec.unquoted.length), e.doc.length)), i && (i.from != r || i.to != n) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let n = Sf(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let o = Sf(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
function Af(t, e, r, n) {
  return new FR(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? Une(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, n);
}
function S1(t, e) {
  return t.slice(Qn(t, e, !1), e);
}
function A1(t, e) {
  return t.slice(e, Qn(t, e));
}
function Une(t) {
  return (e, r, n) => !n[0].length || (t(S1(n.input, n.index)) != Hr.Word || t(A1(n.input, n.index)) != Hr.Word) && (t(A1(n.input, n.index + n[0].length)) != Hr.Word || t(S1(n.input, n.index + n[0].length)) != Hr.Word);
}
class Hne extends PR {
  nextMatch(e, r, n) {
    let i = Af(this.spec, e, n, e.doc.length).next();
    return i.done && (i = Af(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = 1; ; i++) {
      let o = Math.max(
        r,
        n - i * 1e4
        /* FindPrev.ChunkSize */
      ), s = Af(this.spec, e, o, n), a = null;
      for (; !s.next().done; )
        a = s.value;
      if (a && (o == r || a.from > o + 10))
        return a;
      if (o == r)
        return null;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (r, n) => {
      if (n == "&")
        return e.match[0];
      if (n == "$")
        return "$";
      for (let i = n.length; i > 0; i--) {
        let o = +n.slice(0, i);
        if (o > 0 && o < e.match.length)
          return e.match[o] + n.slice(i);
      }
      return r;
    });
  }
  matchAll(e, r) {
    let n = Af(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let o = Af(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
const dg = /* @__PURE__ */ _t.define(), R4 = /* @__PURE__ */ _t.define(), Hu = /* @__PURE__ */ jn.define({
  create(t) {
    return new q2(mC(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(dg) ? t = new q2(r.value.create(), t.panel) : r.is(R4) && (t = new q2(t.query, r.value ? N4 : null));
    return t;
  },
  provide: (t) => tg.from(t, (e) => e.panel)
});
class q2 {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const Vne = /* @__PURE__ */ pt.mark({ class: "cm-searchMatch" }), Wne = /* @__PURE__ */ pt.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Gne = /* @__PURE__ */ wn.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Hu));
  }
  update(t) {
    let e = t.state.field(Hu);
    (e != t.startState.field(Hu) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return pt.none;
    let { view: r } = this, n = new rc();
    for (let i = 0, o = r.visibleRanges, s = o.length; i < s; i++) {
      let { from: a, to: l } = o[i];
      for (; i < s - 1 && l > o[i + 1].from - 500; )
        l = o[++i].to;
      t.highlight(r.state, a, l, (u, c) => {
        let h = r.state.selection.ranges.some((d) => d.from == u && d.to == c);
        n.add(u, c, h ? Wne : Vne);
      });
    }
    return n.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function r0(t) {
  return (e) => {
    let r = e.state.field(Hu, !1);
    return r && r.query.spec.valid ? t(e, r) : $R(e);
  };
}
const E1 = /* @__PURE__ */ r0((t, { query: e }) => {
  let { to: r } = t.state.selection.main, n = e.nextMatch(t.state, r, r);
  if (!n)
    return !1;
  let i = de.single(n.from, n.to), o = t.state.facet(Zd);
  return t.dispatch({
    selection: i,
    effects: [$4(t, n), o.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), NR(t), !0;
}), D1 = /* @__PURE__ */ r0((t, { query: e }) => {
  let { state: r } = t, { from: n } = r.selection.main, i = e.prevMatch(r, n, n);
  if (!i)
    return !1;
  let o = de.single(i.from, i.to), s = t.state.facet(Zd);
  return t.dispatch({
    selection: o,
    effects: [$4(t, i), s.scrollToMatch(o.main, t)],
    userEvent: "select.search"
  }), NR(t), !0;
}), Kne = /* @__PURE__ */ r0((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: de.create(r.map((n) => de.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Qne = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: n, to: i } = r.main, o = [], s = 0;
  for (let a = new Ad(t.doc, t.sliceDoc(n, i)); !a.next().done; ) {
    if (o.length > 1e3)
      return !1;
    a.value.from == n && (s = o.length), o.push(de.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: de.create(o, s),
    userEvent: "select.search.matches"
  })), !0;
}, _8 = /* @__PURE__ */ r0((t, { query: e }) => {
  let { state: r } = t, { from: n, to: i } = r.selection.main;
  if (r.readOnly)
    return !1;
  let o = e.nextMatch(r, n, n);
  if (!o)
    return !1;
  let s = o, a = [], l, u, c = [];
  s.from == n && s.to == i && (u = r.toText(e.getReplacement(s)), a.push({ from: s.from, to: s.to, insert: u }), s = e.nextMatch(r, s.from, s.to), c.push(Be.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(n).number) + ".")));
  let h = t.state.changes(a);
  return s && (l = de.single(s.from, s.to).map(h), c.push($4(t, s)), c.push(r.facet(Zd).scrollToMatch(l.main, t))), t.dispatch({
    changes: h,
    selection: l,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), Xne = /* @__PURE__ */ r0((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((i) => {
    let { from: o, to: s } = i;
    return { from: o, to: s, insert: e.getReplacement(i) };
  });
  if (!r.length)
    return !1;
  let n = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: Be.announce.of(n),
    userEvent: "input.replace.all"
  }), !0;
});
function N4(t) {
  return t.state.facet(Zd).createPanel(t);
}
function mC(t, e) {
  var r, n, i, o, s;
  let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let u = t.facet(Zd);
  return new MR({
    search: ((r = e?.literal) !== null && r !== void 0 ? r : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (n = e?.caseSensitive) !== null && n !== void 0 ? n : u.caseSensitive,
    literal: (i = e?.literal) !== null && i !== void 0 ? i : u.literal,
    regexp: (o = e?.regexp) !== null && o !== void 0 ? o : u.regexp,
    wholeWord: (s = e?.wholeWord) !== null && s !== void 0 ? s : u.wholeWord
  });
}
function RR(t) {
  let e = eg(t, N4);
  return e && e.dom.querySelector("[main-field]");
}
function NR(t) {
  let e = RR(t);
  e && e == t.root.activeElement && e.select();
}
const $R = (t) => {
  let e = t.state.field(Hu, !1);
  if (e && e.panel) {
    let r = RR(t);
    if (r && r != t.root.activeElement) {
      let n = mC(t.state, e.query.spec);
      n.valid && t.dispatch({ effects: dg.of(n) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      R4.of(!0),
      e ? dg.of(mC(t.state, e.query.spec)) : _t.appendConfig.of(eie)
    ] });
  return !0;
}, IR = (t) => {
  let e = t.state.field(Hu, !1);
  if (!e || !e.panel)
    return !1;
  let r = eg(t, N4);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: R4.of(!1) }), !0;
}, Jne = [
  { key: "Mod-f", run: $R, scope: "editor search-panel" },
  { key: "F3", run: E1, shift: D1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: E1, shift: D1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: IR, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Qne },
  { key: "Mod-Alt-g", run: Dne },
  { key: "Mod-d", run: zne, preventDefault: !0 }
];
class Yne {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(Hu).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Er("input", {
      value: r.search,
      placeholder: Ao(e, "Find"),
      "aria-label": Ao(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Er("input", {
      value: r.replace,
      placeholder: Ao(e, "Replace"),
      "aria-label": Ao(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Er("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = Er("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = Er("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function n(i, o, s) {
      return Er("button", { class: "cm-button", name: i, onclick: o, type: "button" }, s);
    }
    this.dom = Er("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      n("next", () => E1(e), [Ao(e, "next")]),
      n("prev", () => D1(e), [Ao(e, "previous")]),
      n("select", () => Kne(e), [Ao(e, "all")]),
      Er("label", null, [this.caseField, Ao(e, "match case")]),
      Er("label", null, [this.reField, Ao(e, "regexp")]),
      Er("label", null, [this.wordField, Ao(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Er("br"),
        this.replaceField,
        n("replace", () => _8(e), [Ao(e, "replace")]),
        n("replaceAll", () => Xne(e), [Ao(e, "replace all")])
      ],
      Er("button", {
        name: "close",
        onclick: () => IR(e),
        "aria-label": Ao(e, "close"),
        type: "button"
      }, ["Ã—"])
    ]);
  }
  commit() {
    let e = new MR({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: dg.of(e) }));
  }
  keydown(e) {
    dY(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? D1 : E1)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), _8(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(dg) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Zd).top;
  }
}
function Ao(t, e) {
  return t.state.phrase(e);
}
const Hv = 30, Vv = /[\s\.,:;?!]/;
function $4(t, { from: e, to: r }) {
  let n = t.state.doc.lineAt(e), i = t.state.doc.lineAt(r).to, o = Math.max(n.from, e - Hv), s = Math.min(i, r + Hv), a = t.state.sliceDoc(o, s);
  if (o != n.from) {
    for (let l = 0; l < Hv; l++)
      if (!Vv.test(a[l + 1]) && Vv.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (s != i) {
    for (let l = a.length - 1; l > a.length - Hv; l--)
      if (!Vv.test(a[l - 1]) && Vv.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return Be.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${n.number}.`);
}
const Zne = /* @__PURE__ */ Be.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), eie = [
  Hu,
  /* @__PURE__ */ pc.low(Gne),
  Zne
], tie = "#e5c07b", S8 = "#e06c75", rie = "#56b6c2", nie = "#ffffff", Ly = "#abb2bf", gC = "#7d8799", iie = "#61afef", oie = "#98c379", A8 = "#d19a66", sie = "#c678dd", aie = "#21252b", E8 = "#2c313a", D8 = "#282c34", U2 = "#353a42", lie = "#3E4451", O8 = "#528bff", uie = /* @__PURE__ */ Be.theme({
  "&": {
    color: Ly,
    backgroundColor: D8
  },
  ".cm-content": {
    caretColor: O8
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: O8 },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: lie },
  ".cm-panels": { backgroundColor: aie, color: Ly },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: D8,
    color: gC,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: E8
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: U2
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: U2,
    borderBottomColor: U2
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: E8,
      color: Ly
    }
  }
}, { dark: !0 }), cie = /* @__PURE__ */ Zg.define([
  {
    tag: oe.keyword,
    color: sie
  },
  {
    tag: [oe.name, oe.deleted, oe.character, oe.propertyName, oe.macroName],
    color: S8
  },
  {
    tag: [/* @__PURE__ */ oe.function(oe.variableName), oe.labelName],
    color: iie
  },
  {
    tag: [oe.color, /* @__PURE__ */ oe.constant(oe.name), /* @__PURE__ */ oe.standard(oe.name)],
    color: A8
  },
  {
    tag: [/* @__PURE__ */ oe.definition(oe.name), oe.separator],
    color: Ly
  },
  {
    tag: [oe.typeName, oe.className, oe.number, oe.changed, oe.annotation, oe.modifier, oe.self, oe.namespace],
    color: tie
  },
  {
    tag: [oe.operator, oe.operatorKeyword, oe.url, oe.escape, oe.regexp, oe.link, /* @__PURE__ */ oe.special(oe.string)],
    color: rie
  },
  {
    tag: [oe.meta, oe.comment],
    color: gC
  },
  {
    tag: oe.strong,
    fontWeight: "bold"
  },
  {
    tag: oe.emphasis,
    fontStyle: "italic"
  },
  {
    tag: oe.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: oe.link,
    color: gC,
    textDecoration: "underline"
  },
  {
    tag: oe.heading,
    fontWeight: "bold",
    color: S8
  },
  {
    tag: [oe.atom, oe.bool, /* @__PURE__ */ oe.special(oe.variableName)],
    color: A8
  },
  {
    tag: [oe.processingInstruction, oe.string, oe.inserted],
    color: oie
  },
  {
    tag: oe.invalid,
    color: nie
  }
]), hie = [uie, /* @__PURE__ */ wP(cie)];
function Lh(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var vC = { exports: {} }, fie = vC.exports, F8;
function die() {
  return F8 || (F8 = 1, (function(t) {
    (function(e, r) {
      t.exports ? t.exports = r() : e.log = r();
    })(fie, function() {
      var e = function() {
      }, r = "undefined", n = typeof window !== r && typeof window.navigator !== r && /Trident\/|MSIE /.test(window.navigator.userAgent), i = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], o = {}, s = null;
      function a(v, y) {
        var b = v[y];
        if (typeof b.bind == "function")
          return b.bind(v);
        try {
          return Function.prototype.bind.call(b, v);
        } catch {
          return function() {
            return Function.prototype.apply.apply(b, [v, arguments]);
          };
        }
      }
      function l() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function u(v) {
        return v === "debug" && (v = "log"), typeof console === r ? !1 : v === "trace" && n ? l : console[v] !== void 0 ? a(console, v) : console.log !== void 0 ? a(console, "log") : e;
      }
      function c() {
        for (var v = this.getLevel(), y = 0; y < i.length; y++) {
          var b = i[y];
          this[b] = y < v ? e : this.methodFactory(b, v, this.name);
        }
        if (this.log = this.debug, typeof console === r && v < this.levels.SILENT)
          return "No console available for logging";
      }
      function h(v) {
        return function() {
          typeof console !== r && (c.call(this), this[v].apply(this, arguments));
        };
      }
      function d(v, y, b) {
        return u(v) || h.apply(this, arguments);
      }
      function p(v, y) {
        var b = this, k, C, S, _ = "loglevel";
        typeof v == "string" ? _ += ":" + v : typeof v == "symbol" && (_ = void 0);
        function D(R) {
          var N = (i[R] || "silent").toUpperCase();
          if (!(typeof window === r || !_)) {
            try {
              window.localStorage[_] = N;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(_) + "=" + N + ";";
            } catch {
            }
          }
        }
        function A() {
          var R;
          if (!(typeof window === r || !_)) {
            try {
              R = window.localStorage[_];
            } catch {
            }
            if (typeof R === r)
              try {
                var N = window.document.cookie, I = encodeURIComponent(_), B = N.indexOf(I + "=");
                B !== -1 && (R = /^([^;]+)/.exec(
                  N.slice(B + I.length + 1)
                )[1]);
              } catch {
              }
            return b.levels[R] === void 0 && (R = void 0), R;
          }
        }
        function O() {
          if (!(typeof window === r || !_)) {
            try {
              window.localStorage.removeItem(_);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(_) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function M(R) {
          var N = R;
          if (typeof N == "string" && b.levels[N.toUpperCase()] !== void 0 && (N = b.levels[N.toUpperCase()]), typeof N == "number" && N >= 0 && N <= b.levels.SILENT)
            return N;
          throw new TypeError("log.setLevel() called with invalid level: " + R);
        }
        b.name = v, b.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, b.methodFactory = y || d, b.getLevel = function() {
          return S ?? C ?? k;
        }, b.setLevel = function(R, N) {
          return S = M(R), N !== !1 && D(S), c.call(b);
        }, b.setDefaultLevel = function(R) {
          C = M(R), A() || b.setLevel(R, !1);
        }, b.resetLevel = function() {
          S = null, O(), c.call(b);
        }, b.enableAll = function(R) {
          b.setLevel(b.levels.TRACE, R);
        }, b.disableAll = function(R) {
          b.setLevel(b.levels.SILENT, R);
        }, b.rebuild = function() {
          if (s !== b && (k = M(s.getLevel())), c.call(b), s === b)
            for (var R in o)
              o[R].rebuild();
        }, k = M(
          s ? s.getLevel() : "WARN"
        );
        var z = A();
        z != null && (S = M(z)), c.call(b);
      }
      s = new p(), s.getLogger = function(v) {
        if (typeof v != "symbol" && typeof v != "string" || v === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var y = o[v];
        return y || (y = o[v] = new p(
          v,
          s.methodFactory
        )), y;
      };
      var g = typeof window !== r ? window.log : void 0;
      return s.noConflict = function() {
        return typeof window !== r && window.log === s && (window.log = g), s;
      }, s.getLoggers = function() {
        return o;
      }, s.default = s, s;
    });
  })(vC)), vC.exports;
}
var pie = die();
const BR = /* @__PURE__ */ Lh(pie);
BR.setLevel("silent");
const Gr = BR, wt = {
  STRING: "String",
  NUMBER: "Number",
  TRUE: "True",
  FALSE: "False",
  NULL: "Null",
  OBJECT: "Object",
  ARRAY: "Array",
  PROPERTY: "Property",
  PROPERTY_NAME: "PropertyName",
  PROPERTY_COLON: "PropertyColon",
  // used in json5 grammar
  ITEM: "Item",
  // used in yaml grammar
  JSON_TEXT: "JsonText",
  INVALID: "âš "
}, mie = {
  Pair: wt.PROPERTY,
  Key: wt.PROPERTY_NAME,
  BlockSequence: wt.ARRAY,
  BlockMapping: wt.OBJECT,
  FlowSequence: wt.ARRAY,
  FlowMapping: wt.OBJECT,
  QuotedLiteral: wt.STRING,
  Literal: wt.STRING,
  // best guess
  Stream: wt.JSON_TEXT,
  Document: wt.OBJECT
}, gie = {
  File: wt.JSON_TEXT
}, I4 = [
  wt.STRING,
  wt.NUMBER,
  wt.TRUE,
  wt.FALSE,
  wt.NULL
], LR = [wt.OBJECT, wt.ARRAY, wt.ITEM], qr = {
  JSON5: "json5",
  JSON: "json4",
  YAML: "yaml"
}, dn = (t, e) => {
  var r, n;
  switch (e) {
    case qr.YAML:
      return (r = mie[t]) !== null && r !== void 0 ? r : t;
    case qr.JSON5:
      return (n = gie[t]) !== null && n !== void 0 ? n : t;
    default:
      return t;
  }
};
function zR(t, e, r) {
  const n = [];
  for (let i = e; i?.parent; i = i.parent)
    switch (dn(i.parent.name, r)) {
      case wt.PROPERTY: {
        const o = yC(i.parent, wt.PROPERTY_NAME, r);
        if (o) {
          let s = Ef(t, o).replace(/[/~]/g, (a) => a === "~" ? "~0" : "~1");
          n.unshift(s);
        }
        break;
      }
      case wt.ARRAY: {
        if (yie(i, r)) {
          const o = UR(i.parent, i, r);
          n.unshift(`${o}`);
        }
        break;
      }
    }
  return n.length === 0 ? "" : "/" + n.join("/");
}
const jR = (t, e, r = -1, n) => zR(t.doc, Dn(t).resolve(e, r), n), B4 = (t, e) => {
  const r = Dn(t), n = /* @__PURE__ */ new Map();
  return r.iterate({
    enter: (i) => {
      var o, s, a, l, u, c, h, d;
      if ([wt.PROPERTY_NAME, wt.OBJECT].includes(dn(i.name, e))) {
        const p = zR(t.doc, i.node, e), { from: g, to: v } = i.node;
        if (!(!((s = (o = i.node) === null || o === void 0 ? void 0 : o.nextSibling) === null || s === void 0) && s.node))
          return n.set(p, { keyFrom: g, keyTo: v }), !0;
        const y = e === qr.JSON ? (l = (a = i.node) === null || a === void 0 ? void 0 : a.nextSibling) === null || l === void 0 ? void 0 : l.node : (d = (h = (c = (u = i.node) === null || u === void 0 ? void 0 : u.nextSibling) === null || c === void 0 ? void 0 : c.node) === null || h === void 0 ? void 0 : h.nextSibling) === null || d === void 0 ? void 0 : d.node;
        if (!y)
          return n.set(p, { keyFrom: g, keyTo: v }), !0;
        const { from: b, to: k } = y;
        return n.set(p, { keyFrom: g, keyTo: v, valueFrom: b, valueTo: k }), !0;
      }
    }
  }), n;
}, H2 = (t, e, r = -1) => Dn(t).resolveInner(e, r), zy = (t) => t.replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1"), vie = (t) => t.replace(/^"(.*)"$/, "'$1'"), Ef = (t, e, r = !0, n = !0) => {
  const i = e ? t.sliceString(e.from, e.to) : "";
  return r ? n ? zy(i) : i.replace(/(^["'])|(["']$)/g, "") : i;
}, qR = (t, e) => {
  var r, n, i, o;
  return dn(t.name, e) === wt.INVALID && (dn((n = (r = t.prevSibling) === null || r === void 0 ? void 0 : r.name) !== null && n !== void 0 ? n : "", e) === wt.PROPERTY_NAME || dn((o = (i = t.prevSibling) === null || i === void 0 ? void 0 : i.name) !== null && o !== void 0 ? o : "", e) === wt.PROPERTY_COLON);
}, jy = (t, e) => I4.includes(dn(t.name, e)) || qR(t, e), yie = (t, e) => [...I4, ...LR].includes(dn(t.name, e)) || qR(t, e), Wv = (t, e) => {
  var r, n, i, o, s, a;
  return dn(t.name, e) === wt.PROPERTY_NAME || dn(t.name, e) === wt.INVALID && (dn((n = (r = t.prevSibling) === null || r === void 0 ? void 0 : r.name) !== null && n !== void 0 ? n : "", e) === wt.PROPERTY || dn((o = (i = t.prevSibling) === null || i === void 0 ? void 0 : i.name) !== null && o !== void 0 ? o : "", e) === "{") || // TODO: Can we make this work without checking for the mode?
  e === qr.YAML && dn((a = (s = t.parent) === null || s === void 0 ? void 0 : s.name) !== null && a !== void 0 ? a : "", e) === wt.OBJECT;
}, n0 = (t) => {
  const e = [];
  let r = t.firstChild;
  for (; r; )
    r && e.push(r), r = r?.nextSibling;
  return e;
}, bie = (t, e, r) => n0(t).filter((n) => dn(n.name, r) === e), yC = (t, e, r) => {
  var n;
  return (n = n0(t).find((i) => dn(i.name, r) === e)) !== null && n !== void 0 ? n : null;
}, T8 = (t, e) => n0(t).find((r) => jy(r, e)), xie = (t, e) => n0(t).filter((r) => I4.includes(dn(r.name, e)) || LR.includes(dn(r.name, e))), UR = (t, e, r) => xie(t, r).findIndex((n) => n.from === e.from && n.to === e.to), M8 = (t, e, r, n = 1 / 0) => {
  let i = t;
  for (; i && n > 0; ) {
    if (dn(i.name, r) === e)
      return i;
    i = i.parent, n--;
  }
  return null;
}, wie = _t.define(), O1 = jn.define({
  create() {
  },
  update(t, e) {
    for (const r of e.effects)
      if (r.is(wie))
        return r.value;
    return t;
  }
}), L4 = (t) => t.field(O1), kie = (t) => [
  O1.init(() => t)
], Cie = {
  // validation errors
  AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",
  AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",
  AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",
  AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",
  ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",
  containsAnyError: "The array at `{{pointer}}` must contain at least one item",
  ContainsArrayError: "The property at `{{pointer}}` must not be an array",
  ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",
  EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",
  ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",
  FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",
  FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",
  FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",
  FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",
  FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",
  FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",
  FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",
  FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",
  FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",
  FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",
  FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",
  FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",
  FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",
  InvalidDataError: "No value may be specified in `{{pointer}}`",
  InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",
  MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",
  MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",
  MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",
  MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`",
  MinItemsOneError: "At least one item is required in `{{pointer}}`",
  MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",
  MinLengthOneError: "A value is required in `{{pointer}}`",
  MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`",
  MissingDependencyError: "The required propery '{{missingProperty}}' in `{{pointer}}` is missing",
  MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",
  MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",
  MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",
  NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",
  NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",
  OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",
  OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",
  PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",
  PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",
  RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",
  SchemaWarning: "Failed retrieving a schema from '{{pointer}}' to key '{{key}}'",
  TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",
  UndefinedValueError: "Value must not be undefined in `{{pointer}}`",
  UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",
  UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",
  ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"
}, _ie = Object.prototype.toString;
function er(t) {
  const e = _ie.call(t).match(/\s([^\]]+)\]/).pop().toLowerCase();
  return e === "file" ? "object" : e;
}
const Sie = "object", Aie = "array";
function Eie(t, e = {}) {
  return t.replace(/\{\{\w+\}\}/g, (r) => {
    const n = r.replace(/[{}]/g, ""), i = e[n], o = er(i);
    return o === Sie || o === Aie ? JSON.stringify(i) : i;
  });
}
function Die(t, e, r = t) {
  var n;
  const i = (n = Cie[t]) !== null && n !== void 0 ? n : r;
  return Eie(i, e);
}
function Oie(t) {
  return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function Fie(t, e) {
  return {
    type: "error",
    name: t,
    code: Oie(t),
    message: Die(t, e),
    data: e
  };
}
function Xe(t) {
  return Fie.bind(null, t);
}
function pg(t, e = []) {
  for (let r = 0; r < t.length; r += 1) {
    const n = t[r];
    Array.isArray(n) ? pg(n, e) : e.push(n);
  }
  return e;
}
const ep = {
  DECLARATOR_ONEOF: "oneOfProperty",
  GET_TEMPLATE_RECURSION_LIMIT: 1,
  propertyBlacklist: ["_id"],
  templateDefaultOptions: {
    addOptionalProps: !1,
    removeInvalidData: !1,
    extendDefaults: !0
  }
};
function Tm(t, e, r) {
  const n = { ...e };
  return Object.defineProperty(n, "getOneOfOrigin", {
    enumerable: !1,
    value: () => ({
      index: r,
      schema: t
    })
  }), n;
}
function gi(t) {
  return t?.type === "error";
}
function Tie(t) {
  return t instanceof Promise;
}
function F1(t) {
  return gi(t) || Tie(t);
}
const { DECLARATOR_ONEOF: Qf } = ep;
function HR(t, e, r = t.rootSchema, n = "#") {
  if (e != null && r[Qf]) {
    const s = [], a = r[Qf], l = e[r[Qf]];
    if (l === void 0)
      return t.errors.missingOneOfPropertyError({
        property: a,
        pointer: n,
        schema: r,
        value: e
      });
    for (let u = 0; u < r.oneOf.length; u += 1) {
      const c = t.resolveRef(r.oneOf[u]), h = t.step(a, c, e, n);
      if (gi(h))
        return h;
      let d = pg(t.validate(l, h, n));
      if (d = d.filter(F1), d.length > 0)
        s.push(...d);
      else
        return Tm(r, c, u);
    }
    return t.errors.oneOfPropertyError({
      property: a,
      value: l,
      pointer: n,
      schema: r,
      errors: s
    });
  }
  const i = [], o = [];
  for (let s = 0; s < r.oneOf.length; s += 1) {
    const a = t.resolveRef(r.oneOf[s]);
    let l = pg(t.validate(e, a, n));
    l = l.filter(F1), l.length > 0 ? o.push(...l) : i.push({ index: s, schema: a });
  }
  return i.length === 1 ? Tm(r, i[0].schema, i[0].index) : i.length > 1 ? t.errors.multipleOneOfError({
    value: e,
    pointer: n,
    schema: r,
    matches: i
  }) : t.errors.oneOfError({
    value: JSON.stringify(e),
    pointer: n,
    schema: r,
    oneOf: r.oneOf,
    errors: o
  });
}
function Mie(t, e, r, n) {
  if (r == null || e.properties == null)
    return -1;
  let i = 0;
  const o = Object.keys(e.properties);
  for (let s = 0; s < o.length; s += 1) {
    const a = o[s];
    r[a] != null && t.isValid(r[a], e.properties[a], n) && (i += 1);
  }
  return i;
}
function z4(t, e, r = t.rootSchema, n = "#") {
  if (e != null && r[Qf]) {
    const o = [], s = r[Qf], a = e[r[Qf]];
    if (a === void 0)
      return t.errors.missingOneOfPropertyError({
        property: s,
        pointer: n,
        schema: r,
        value: e
      });
    for (let l = 0; l < r.oneOf.length; l += 1) {
      const u = t.resolveRef(r.oneOf[l]), c = t.step(s, u, e, n);
      if (gi(c))
        return c;
      let h = pg(t.validate(a, c, n));
      if (h = h.filter(F1), h.length > 0)
        o.push(...h);
      else
        return Tm(r, u, l);
    }
    return t.errors.oneOfPropertyError({
      property: s,
      value: a,
      pointer: n,
      schema: r,
      errors: o
    });
  }
  const i = [];
  for (let o = 0; o < r.oneOf.length; o += 1) {
    const s = t.resolveRef(r.oneOf[o]);
    t.isValid(e, s, n) && i.push({ schema: s, index: o });
  }
  if (i.length === 1)
    return Tm(r, i[0].schema, i[0].index);
  if (er(e) === "object") {
    let o, s = -1, a = 0;
    for (let l = 0; l < r.oneOf.length; l += 1) {
      const u = t.resolveRef(r.oneOf[l]), c = Mie(t, u, e);
      a < c && (a = c, o = r.oneOf[l], s = l);
    }
    return o === void 0 ? t.errors.oneOfError({
      value: JSON.stringify(e),
      pointer: n,
      schema: r,
      oneOf: r.oneOf
    }) : Tm(r, o, s);
  }
  return i.length > 1 ? t.errors.multipleOneOfError({ matches: i, pointer: n, schema: r, value: e }) : t.errors.oneOfError({
    value: JSON.stringify(e),
    pointer: n,
    schema: r,
    oneOf: r.oneOf
  });
}
const Pie = (t, e, r, n) => {
  if (Array.isArray(e.oneOf)) {
    const i = t.resolveOneOf(r, e, n);
    if (gi(i))
      return i;
  }
};
var V2, P8;
function Rie() {
  if (P8) return V2;
  P8 = 1;
  var t = function(b) {
    return e(b) && !r(b);
  };
  function e(b) {
    return !!b && typeof b == "object";
  }
  function r(b) {
    var k = Object.prototype.toString.call(b);
    return k === "[object RegExp]" || k === "[object Date]" || o(b);
  }
  var n = typeof Symbol == "function" && Symbol.for, i = n ? Symbol.for("react.element") : 60103;
  function o(b) {
    return b.$$typeof === i;
  }
  function s(b) {
    return Array.isArray(b) ? [] : {};
  }
  function a(b, k) {
    return k.clone !== !1 && k.isMergeableObject(b) ? v(s(b), b, k) : b;
  }
  function l(b, k, C) {
    return b.concat(k).map(function(S) {
      return a(S, C);
    });
  }
  function u(b, k) {
    if (!k.customMerge)
      return v;
    var C = k.customMerge(b);
    return typeof C == "function" ? C : v;
  }
  function c(b) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(b).filter(function(k) {
      return Object.propertyIsEnumerable.call(b, k);
    }) : [];
  }
  function h(b) {
    return Object.keys(b).concat(c(b));
  }
  function d(b, k) {
    try {
      return k in b;
    } catch {
      return !1;
    }
  }
  function p(b, k) {
    return d(b, k) && !(Object.hasOwnProperty.call(b, k) && Object.propertyIsEnumerable.call(b, k));
  }
  function g(b, k, C) {
    var S = {};
    return C.isMergeableObject(b) && h(b).forEach(function(_) {
      S[_] = a(b[_], C);
    }), h(k).forEach(function(_) {
      p(b, _) || (d(b, _) && C.isMergeableObject(k[_]) ? S[_] = u(_, C)(b[_], k[_], C) : S[_] = a(k[_], C));
    }), S;
  }
  function v(b, k, C) {
    C = C || {}, C.arrayMerge = C.arrayMerge || l, C.isMergeableObject = C.isMergeableObject || t, C.cloneUnlessOtherwiseSpecified = a;
    var S = Array.isArray(k), _ = Array.isArray(b), D = S === _;
    return D ? S ? C.arrayMerge(b, k, C) : g(b, k, C) : a(k, C);
  }
  v.all = function(b, k) {
    if (!Array.isArray(b))
      throw new Error("first argument should be an array");
    return b.reduce(function(C, S) {
      return v(C, S, k);
    }, {});
  };
  var y = v;
  return V2 = y, V2;
}
var Nie = Rie();
const VR = /* @__PURE__ */ Lh(Nie), $ie = (t, e) => e, j4 = (t, e) => VR(t, e, { arrayMerge: $ie }), Iie = (t, e) => {
  const r = t.concat(e);
  return r.filter((n, i) => r.indexOf(n) === i);
}, Bie = (t, e) => VR(t, e, { arrayMerge: Iie });
function Fi(t, e) {
  const r = er(t), n = er(e);
  if (r !== n)
    return t;
  const i = Bie(t, e);
  return t.getOneOfOrigin ? Object.defineProperty(i, "getOneOfOrigin", {
    enumerable: !1,
    value: t.getOneOfOrigin
  }) : e.getOneOfOrigin && Object.defineProperty(i, "getOneOfOrigin", {
    enumerable: !1,
    value: e.getOneOfOrigin
  }), i;
}
function mg(t, ...e) {
  const r = {};
  return Object.keys(t).forEach((n) => {
    e.includes(n) || (r[n] = t[n]);
  }), t.getOneOfOrigin && Object.defineProperty(r, "getOneOfOrigin", {
    enumerable: !1,
    value: t.getOneOfOrigin
  }), r;
}
var Lie = Function.prototype.toString, W2 = Object.create, zie = Object.prototype.toString, jie = (
  /** @class */
  (function() {
    function t() {
      this._keys = [], this._values = [];
    }
    return t.prototype.has = function(e) {
      return !!~this._keys.indexOf(e);
    }, t.prototype.get = function(e) {
      return this._values[this._keys.indexOf(e)];
    }, t.prototype.set = function(e, r) {
      this._keys.push(e), this._values.push(r);
    }, t;
  })()
);
function qie() {
  return new jie();
}
function Uie() {
  return /* @__PURE__ */ new WeakMap();
}
var Hie = typeof WeakMap < "u" ? Uie : qie;
function q4(t) {
  if (!t)
    return W2(null);
  var e = t.constructor;
  if (e === Object)
    return t === Object.prototype ? {} : W2(t);
  if (e && ~Lie.call(e).indexOf("[native code]"))
    try {
      return new e();
    } catch {
    }
  return W2(t);
}
function Vie(t) {
  var e = "";
  return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.unicode && (e += "u"), t.sticky && (e += "y"), e;
}
function Wie(t) {
  return t.flags;
}
var Gie = /test/g.flags === "g" ? Wie : Vie;
function WR(t) {
  var e = zie.call(t);
  return e.substring(8, e.length - 1);
}
function Kie(t) {
  return t[Symbol.toStringTag] || WR(t);
}
var Qie = typeof Symbol < "u" ? Kie : WR, Xie = Object.defineProperty, Jie = Object.getOwnPropertyDescriptor, GR = Object.getOwnPropertyNames, U4 = Object.getOwnPropertySymbols, KR = Object.prototype, QR = KR.hasOwnProperty, Yie = KR.propertyIsEnumerable, XR = typeof U4 == "function";
function Zie(t) {
  return GR(t).concat(U4(t));
}
var eoe = XR ? Zie : GR;
function Vb(t, e, r) {
  for (var n = eoe(t), i = 0, o = n.length, s = void 0, a = void 0; i < o; ++i)
    if (s = n[i], !(s === "callee" || s === "caller")) {
      if (a = Jie(t, s), !a) {
        e[s] = r.copier(t[s], r);
        continue;
      }
      !a.get && !a.set && (a.value = r.copier(a.value, r));
      try {
        Xie(e, s, a);
      } catch {
        e[s] = a.value;
      }
    }
  return e;
}
function toe(t, e) {
  var r = new e.Constructor();
  e.cache.set(t, r);
  for (var n = 0, i = t.length; n < i; ++n)
    r[n] = e.copier(t[n], e);
  return r;
}
function roe(t, e) {
  var r = new e.Constructor();
  return e.cache.set(t, r), Vb(t, r, e);
}
function JR(t, e) {
  return t.slice(0);
}
function noe(t, e) {
  return t.slice(0, t.size, t.type);
}
function ioe(t, e) {
  return new e.Constructor(JR(t.buffer));
}
function ooe(t, e) {
  return new e.Constructor(t.getTime());
}
function YR(t, e) {
  var r = new e.Constructor();
  return e.cache.set(t, r), t.forEach(function(n, i) {
    r.set(i, e.copier(n, e));
  }), r;
}
function soe(t, e) {
  return Vb(t, YR(t, e), e);
}
function aoe(t, e) {
  var r = q4(e.prototype);
  e.cache.set(t, r);
  for (var n in t)
    QR.call(t, n) && (r[n] = e.copier(t[n], e));
  return r;
}
function loe(t, e) {
  var r = q4(e.prototype);
  e.cache.set(t, r);
  for (var n in t)
    QR.call(t, n) && (r[n] = e.copier(t[n], e));
  for (var i = U4(t), o = 0, s = i.length, a = void 0; o < s; ++o)
    a = i[o], Yie.call(t, a) && (r[a] = e.copier(t[a], e));
  return r;
}
var uoe = XR ? loe : aoe;
function coe(t, e) {
  var r = q4(e.prototype);
  return e.cache.set(t, r), Vb(t, r, e);
}
function G2(t, e) {
  return new e.Constructor(t.valueOf());
}
function hoe(t, e) {
  var r = new e.Constructor(t.source, Gie(t));
  return r.lastIndex = t.lastIndex, r;
}
function qy(t, e) {
  return t;
}
function ZR(t, e) {
  var r = new e.Constructor();
  return e.cache.set(t, r), t.forEach(function(n) {
    r.add(e.copier(n, e));
  }), r;
}
function foe(t, e) {
  return Vb(t, ZR(t, e), e);
}
var doe = Array.isArray, H4 = Object.assign, poe = Object.getPrototypeOf || (function(t) {
  return t.__proto__;
}), eN = {
  array: toe,
  arrayBuffer: JR,
  blob: noe,
  dataView: ioe,
  date: ooe,
  error: qy,
  map: YR,
  object: uoe,
  regExp: hoe,
  set: ZR
}, moe = H4({}, eN, {
  array: roe,
  map: soe,
  object: coe,
  set: foe
});
function goe(t) {
  return {
    Arguments: t.object,
    Array: t.array,
    ArrayBuffer: t.arrayBuffer,
    Blob: t.blob,
    Boolean: G2,
    DataView: t.dataView,
    Date: t.date,
    Error: t.error,
    Float32Array: t.arrayBuffer,
    Float64Array: t.arrayBuffer,
    Int8Array: t.arrayBuffer,
    Int16Array: t.arrayBuffer,
    Int32Array: t.arrayBuffer,
    Map: t.map,
    Number: G2,
    Object: t.object,
    Promise: qy,
    RegExp: t.regExp,
    Set: t.set,
    String: G2,
    WeakMap: qy,
    WeakSet: qy,
    Uint8Array: t.arrayBuffer,
    Uint8ClampedArray: t.arrayBuffer,
    Uint16Array: t.arrayBuffer,
    Uint32Array: t.arrayBuffer,
    Uint64Array: t.arrayBuffer
  };
}
function tN(t) {
  var e = H4({}, eN, t), r = goe(e), n = r.Array, i = r.Object;
  function o(s, a) {
    if (a.prototype = a.Constructor = void 0, !s || typeof s != "object")
      return s;
    if (a.cache.has(s))
      return a.cache.get(s);
    if (a.prototype = poe(s), a.Constructor = a.prototype && a.prototype.constructor, !a.Constructor || a.Constructor === Object)
      return i(s, a);
    if (doe(s))
      return n(s, a);
    var l = r[Qie(s)];
    return l ? l(s, a) : typeof s.then == "function" ? s : i(s, a);
  }
  return function(s) {
    return o(s, {
      Constructor: void 0,
      cache: Hie(),
      copier: o,
      prototype: void 0
    });
  };
}
function voe(t) {
  return tN(H4({}, moe, t));
}
voe({});
var T1 = tN({});
function Wb(t, e, r) {
  if (e.if != null) {
    if (e.if === !1)
      return e.else;
    if (e.if && (e.then || e.else)) {
      const n = t.validate(r, t.resolveRef(e.if));
      if (n.length === 0 && e.then)
        return t.resolveRef(e.then);
      if (n.length !== 0 && e.else)
        return t.resolveRef(e.else);
    }
  }
}
const yoe = (t, e, r, n) => {
  const i = Wb(t, e, r);
  if (i)
    return t.validate(r, i, n);
};
function rN(t, e, r) {
  var n;
  const i = { ...(n = t.resolveRef(e)) !== null && n !== void 0 ? n : {} };
  return Wb(t, i, r) || mg(i, "if", "then", "else");
}
function nN(t, e, r = t.rootSchema) {
  let n = T1(r);
  for (let i = 0; i < r.allOf.length; i += 1) {
    const o = rN(t, r.allOf[i], e);
    n = Fi(n, o);
  }
  return delete n.allOf, n;
}
function iN(t, e) {
  const { allOf: r } = e;
  if (!Array.isArray(r) || r.length === 0)
    return;
  let n = {};
  return r.forEach((i) => {
    n = Fi(n, t.resolveRef(i));
  }), n;
}
const boe = (t, e, r, n) => {
  const { allOf: i } = e;
  if (!Array.isArray(i) || i.length === 0)
    return;
  const o = [];
  return e.allOf.forEach((s) => {
    o.push(...t.validate(r, s, n));
  }), o;
};
function oN(t, e) {
  return t == null || t.$ref == null ? t : t.getRoot ? t.getRoot().getRef(t) : e.getRef(t);
}
function xoe(t) {
  return t.filter((e, r) => t.indexOf(e) === r);
}
function Vu(t) {
  return er(t) === "object";
}
function sN(t, e, r) {
  const { dependencies: n } = e;
  if (!Vu(n) || !Vu(r))
    return;
  let i = !1, o = { required: [] };
  if (Object.keys(n).forEach((s) => {
    var a, l;
    if (r[s] == null && !(!((a = e.required) === null || a === void 0) && a.includes(s) || !((l = o.required) === null || l === void 0) && l.includes(s)))
      return;
    const u = n[s];
    if (Array.isArray(u)) {
      i = !0, o.required.push(...u);
      return;
    }
    if (Vu(u)) {
      i = !0, o = Fi(o, t.resolveRef(u));
      return;
    }
  }), i)
    return o.required = xoe(o.required), o;
}
const woe = (t, e, r, n) => {
  if (er(e.dependencies) !== "object")
    return;
  const i = [];
  return Object.keys(r).forEach((o) => {
    if (e.dependencies[o] === void 0 || e.dependencies[o] === !0)
      return;
    if (e.dependencies[o] === !1) {
      i.push(t.errors.missingDependencyError({ pointer: n, schema: e, value: r }));
      return;
    }
    let s;
    const a = er(e.dependencies[o]);
    if (a === "array")
      s = e.dependencies[o].filter((l) => r[l] === void 0).map((l) => t.errors.missingDependencyError({ missingProperty: l, pointer: n, schema: e, value: r }));
    else if (a === "object")
      s = t.validate(r, e.dependencies[o], n);
    else
      throw new Error(`Invalid dependency definition for ${n}/${o}. Must be string[] or schema`);
    i.push(...s);
  }), i.length > 0 ? i : void 0;
};
function aN(t, e, r) {
  if (!Array.isArray(e.anyOf) || e.anyOf.length === 0)
    return;
  let n;
  return e.anyOf.forEach((i) => {
    i = t.resolveRef(i), t.isValid(r, i) && (n = n ? Fi(n, i) : i);
  }), n;
}
function lN(t, e, r = t.rootSchema, n = "#") {
  const { anyOf: i } = r;
  if (!Array.isArray(i) || i.length === 0)
    return r;
  const o = aN(t, r, e);
  if (o == null)
    return t.errors.anyOfError({ pointer: n, schema: r, value: e, anyOf: JSON.stringify(i) });
  const s = Fi(r, o);
  return mg(s, "anyOf");
}
const koe = (t, e, r, n) => {
  if (!(!Array.isArray(e.anyOf) || e.anyOf.length === 0)) {
    for (let i = 0; i < e.anyOf.length; i += 1)
      if (t.isValid(r, e.anyOf[i]))
        return;
    return t.errors.anyOfError({ pointer: n, schema: e, value: r, anyOf: e.anyOf });
  }
}, R8 = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"], Coe = ["allOf", "anyOf", "oneOf", "dependencies", "if"];
function _oe(t) {
  const e = Object.keys(t);
  return Coe.findIndex((r) => e.includes(r)) !== -1;
}
function bC(t, e, r, n) {
  let i, o;
  if (e = t.resolveRef(e), e.oneOf) {
    const c = z4(t, r, e, n);
    gi(c) ? o = c : c && (i = Fi(i ?? {}, c));
  }
  if (Array.isArray(e.allOf)) {
    const c = e.allOf.map((h) => {
      if (_oe(h)) {
        let d = bC(t, h, r, n);
        return d ? (d = Fi(h, d), mg(d, ...R8)) : void 0;
      }
      return h;
    });
    if (c.length > 0) {
      const h = iN(t, { allOf: c });
      i = Fi(i ?? {}, h);
    }
  }
  const s = aN(t, e, r);
  s && (i = Fi(i ?? {}, s));
  const a = sN(t, e, r);
  a && (i = Fi(i ?? {}, a));
  const l = Wb(t, e, r);
  if (l && (i = Fi(i ?? {}, l)), i == null)
    return o;
  const u = bC(t, i, r, n);
  return u && (i = Fi(i, u)), mg(i, ...R8);
}
const Soe = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
function N8(t, e, r, n) {
  let i = bC(t, e, r, n);
  return i ? (i = Fi(e, i), mg(i, ...Soe)) : e;
}
class uN {
  constructor(e, r) {
    this.remotes = {}, this.errors = {}, this.typeKeywords = {}, this.validateKeyword = {}, this.validateType = {}, this.validateFormat = {}, this.config = e, this.typeKeywords = T1(e.typeKeywords), this.validateKeyword = Object.assign({}, e.validateKeyword), this.validateType = Object.assign({}, e.validateType), this.validateFormat = Object.assign({}, e.validateFormat), this.errors = Object.assign({}, e.errors), this.setSchema(r);
  }
  get rootSchema() {
    return this.__rootSchema;
  }
  set rootSchema(e) {
    e != null && (this.__rootSchema = this.config.compileSchema(this, e));
  }
  /**
   * register a json-schema to be referenced from another json-schema
   * @param url - base-url of json-schema (aka id)
   * @param schema - json-schema root
   */
  addRemoteSchema(e, r) {
    this.config.addRemoteSchema(this, e, r);
  }
  compileSchema(e) {
    var r;
    return this.config.compileSchema(this, e, (r = this.rootSchema) !== null && r !== void 0 ? r : e);
  }
  createSchemaOf(e) {
    return this.config.createSchemaOf(e);
  }
  /**
   * Iterates over data, retrieving its schema
   *
   * @param data - the data to iterate
   * @param callback - will be called with (schema, data, pointer) on each item
   * @param [schema] - the schema matching the data. Defaults to rootSchema
   * @param [pointer] - pointer to current data. Default to rootPointer
   */
  each(e, r, n, i) {
    return this.config.each(this, e, r, n, i);
  }
  eachSchema(e, r = this.rootSchema) {
    return this.config.eachSchema(r, e);
  }
  getChildSchemaSelection(e, r) {
    return this.config.getChildSchemaSelection(this, e, r);
  }
  /**
   * Returns the json-schema of a data-json-pointer.
   *
   * To resolve dynamic schema where the type of json-schema is evaluated by
   * its value, a data object has to be passed in options.
   *
   * Per default this function will return `undefined` for valid properties that
   * do not have a defined schema. Use the option `withSchemaWarning: true` to
   * receive an error with `code: schema-warning` containing the location of its
   * last evaluated json-schema.
   *
   * Notes
   *      - uses draft.step to walk through data and schema
   *
   * @param draft
   * @param pointer - json pointer in data to get the json schema for
   * @param [options.data] - the data object, which includes the json pointers value. This is optional, as
   *    long as no oneOf, anyOf, etc statement is part of the pointers schema
   * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema
   * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition
   * @return resolved json-schema object of requested json-pointer location
   */
  getSchema(e) {
    return this.config.getSchema(this, e);
  }
  /**
   * Create data object matching the given schema
   *
   * @param [data] - optional template data
   * @param [schema] - json schema, defaults to rootSchema
   * @return created template data
   */
  getTemplate(e, r, n = this.config.templateDefaultOptions) {
    return this.config.getTemplate(this, e, r, n);
  }
  isValid(e, r, n) {
    return this.config.isValid(this, e, r, n);
  }
  resolveAnyOf(e, r, n) {
    return this.config.resolveAnyOf(this, e, r, n);
  }
  resolveAllOf(e, r) {
    return this.config.resolveAllOf(this, e, r);
  }
  resolveRef(e) {
    return this.config.resolveRef(e, this.rootSchema);
  }
  resolveOneOf(e, r, n) {
    return this.config.resolveOneOf(this, e, r, n);
  }
  setSchema(e) {
    this.rootSchema = e;
  }
  /**
   * Returns the json-schema of the given object property or array item.
   * e.g. it steps by one key into the data
   *
   *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and
   *  returns the correct schema.
   *
   * @param  key       - property-name or array-index
   * @param  schema    - json schema of current data
   * @param  data      - parent of key
   * @param  [pointer] - pointer to schema and data (parent of key)
   * @return Schema or Error if failed resolving key
   */
  step(e, r, n, i) {
    return this.config.step(this, e, r, n, i);
  }
  /**
   * Validate data by a json schema
   *
   * @param value - value to validate
   * @param [schema] - json schema, defaults to rootSchema
   * @param [pointer] - json pointer pointing to value (used for error-messages only)
   * @return list of errors or empty
   */
  validate(e, r, n) {
    return this.config.validate(this, e, r, n);
  }
}
function cN(t, e, r) {
  r.id = r.id || e, t.remotes[e] = t.compileSchema(r);
}
var xC = { exports: {} }, Aoe = xC.exports, $8;
function Eoe() {
  return $8 || ($8 = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(typeof self < "u" ? self : Aoe, (() => (() => {
      var r = { d: (I, B) => {
        for (var $ in B) r.o(B, $) && !r.o(I, $) && Object.defineProperty(I, $, { enumerable: !0, get: B[$] });
      }, o: (I, B) => Object.prototype.hasOwnProperty.call(I, B), r: (I) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(I, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(I, "__esModule", { value: !0 });
      } }, n = {};
      function i(I) {
        return I === "#" || I === "" || Array.isArray(I) && I.length === 0 || !1;
      }
      r.r(n), r.d(n, { default: () => N, get: () => d, isRoot: () => i, join: () => z, remove: () => _, removeUndefinedItems: () => S, set: () => b, split: () => h, splitLast: () => R });
      const o = /~1/g, s = /~0/g, a = /\/+/g, l = /(^[#/]*|\/+$)/g;
      function u(I) {
        return I.replace(o, "/").replace(s, "~");
      }
      function c(I) {
        return u(decodeURIComponent(I));
      }
      function h(I) {
        if (I == null || typeof I != "string" || i(I)) return Array.isArray(I) ? I : [];
        const B = I.indexOf("#") >= 0 ? c : u, $ = (I = (I = I.replace(a, "/")).replace(l, "")).split("/");
        for (let q = 0, U = $.length; q < U; q += 1) $[q] = B($[q]);
        return $;
      }
      function d(I, B, $ = void 0) {
        if (B == null || I == null) return $;
        if (i(B)) return I;
        const q = p(I, h(B));
        return q === void 0 ? $ : q;
      }
      function p(I, B) {
        const $ = B.shift();
        if (I !== void 0) return $ !== void 0 ? p(I[$], B) : I;
      }
      const g = /^\[.*\]$/, v = /^\[(.+)\]$/;
      function y(I, B) {
        return I === "__proto__" || I == "constructor" && B.length > 0 && B[0] == "prototype";
      }
      function b(I, B, $) {
        if (B == null) return I;
        const q = h(B);
        if (q.length === 0) return I;
        I == null && (I = g.test(q[0]) ? [] : {});
        let U, H, G = I;
        for (; q.length > 1; ) U = q.shift(), H = g.test(q[0]), y(U, q) || (G = C(G, U, H));
        return U = q.pop(), k(G, U, $), I;
      }
      function k(I, B, $) {
        let q;
        const U = B.match(v);
        B === "[]" && Array.isArray(I) ? I.push($) : U ? (q = U.pop(), I[q] = $) : I[B] = $;
      }
      function C(I, B, $) {
        if (I[B] != null) return I[B];
        const q = $ ? [] : {};
        return k(I, B, q), q;
      }
      function S(I) {
        let B = 0, $ = 0;
        for (; B + $ < I.length; ) I[B + $] === void 0 && ($ += 1), I[B] = I[B + $], B += 1;
        return I.length = I.length - $, I;
      }
      function _(I, B, $) {
        const q = h(B), U = q.pop(), H = d(I, q);
        return H && delete H[U], Array.isArray(H) && $ !== !0 && S(H), I;
      }
      const D = /\/+/g, A = /~/g, O = /\//g;
      function M(I, B) {
        if (I.length === 0) return B ? "#" : "";
        for (let $ = 0, q = I.length; $ < q; $ += 1) I[$] = I[$].replace(A, "~0").replace(O, "~1"), B && (I[$] = encodeURIComponent(I[$]));
        return ((B ? "#/" : "/") + I.join("/")).replace(D, "/");
      }
      function z(I, ...B) {
        const $ = [];
        if (Array.isArray(I)) return M(I, arguments[1] === !0);
        const q = arguments[arguments.length - 1], U = typeof q == "boolean" ? q : I && I[0] === "#";
        for (let G = 0, re = arguments.length; G < re; G += 1) $.push.apply($, h(arguments[G]));
        const H = [];
        for (let G = 0, re = $.length; G < re; G += 1) if ($[G] === "..") {
          if (H.length === 0) return U ? "#" : "";
          H.pop();
        } else H.push($[G]);
        return M(H, U);
      }
      function R(I) {
        const B = h(I);
        if (B.length === 0) return typeof I == "string" && I[0] === "#" ? ["#", B[0]] : ["", void 0];
        if (B.length === 1) return I[0] === "#" ? ["#", B[0]] : ["", B[0]];
        const $ = B.pop();
        return [z(B, I[0] === "#"), $];
      }
      const N = { get: d, set: b, remove: _, join: z, split: h, splitLast: R, isRoot: i, removeUndefinedItems: S };
      return n;
    })()));
  })(xC)), xC.exports;
}
var Hc = Eoe();
const gg = /* @__PURE__ */ Lh(Hc);
var Gv = {}, Hi = {}, Jp = {}, I8;
function Doe() {
  if (I8) return Jp;
  I8 = 1, Object.defineProperty(Jp, "__esModule", { value: !0 }), Jp.TokenError = void 0;
  let t = class extends Error {
    constructor(e, r) {
      if (super(e), this.message = e, this.token = r, r && r.errors)
        r.errors.push(this);
      else
        throw this;
    }
    inspect() {
      return "SyntaxError: " + this.message;
    }
  };
  return Jp.TokenError = t, Jp;
}
var B8;
function Ooe() {
  if (B8) return Hi;
  B8 = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.Parser = Hi.findRuleByName = Hi.parseRuleName = Hi.escapeRegExp = Hi.readToken = void 0;
  const t = /^[A-Z0-9_]+$/, e = /(\?|\+|\*)$/, r = /^(@|&|!)/, n = "WS", i = Doe();
  function o(v, y) {
    let b = y.exec(v);
    return b && b.index == 0 ? b[0].length == 0 && y.source.length > 0 ? null : {
      type: null,
      text: b[0],
      rest: v.substr(b[0].length),
      start: 0,
      end: b[0].length - 1,
      fullText: b[0],
      errors: [],
      children: [],
      parent: null
    } : null;
  }
  Hi.readToken = o;
  function s(v) {
    return v.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  Hi.escapeRegExp = s;
  function a(v) {
    v.rest = "", v.children && v.children.forEach((y) => a(y));
  }
  function l(v, y) {
    v.start += y, v.end += y, v.children && v.children.forEach((b) => l(b, v.start));
  }
  function u(v, y) {
    y.errors && y.errors.length && y.errors.forEach((b) => v.push(b)), y.children && y.children.forEach((b) => u(v, b));
  }
  function c(v) {
    let y = e.exec(v), b = r.exec(v), k = y && y[0] || "", C = b && b[0] || "", S = {
      raw: v,
      name: v.replace(e, "").replace(r, ""),
      isOptional: k == "?" || k == "*",
      allowRepetition: k == "+" || k == "*",
      atLeastOne: k == "+",
      lookupPositive: C == "&",
      lookupNegative: C == "!",
      pinned: C == "@",
      lookup: !1,
      isLiteral: !1
    };
    return S.isLiteral = S.name[0] == "'" || S.name[0] == '"', S.lookup = S.lookupNegative || S.lookupPositive, S;
  }
  Hi.parseRuleName = c;
  function h(v, y) {
    let b = c(v);
    return y.cachedRules[b.name] || null;
  }
  Hi.findRuleByName = h;
  function d(v, y) {
    if (v.children) {
      let b = v.children.filter((k) => k.type && y.test(k.type));
      for (let k = 0; k < b.length; k++) {
        let C = v.children.indexOf(b[k]);
        C != -1 && v.children.splice(C, 1);
      }
      v.children.forEach((k) => d(k, y));
    }
  }
  const p = ["EOF"];
  class g {
    constructor(y, b) {
      this.grammarRules = y, this.options = b, this.cachedRules = {}, this.debug = b ? b.debug === !0 : !1;
      let k = [], C = [];
      if (y.forEach((S) => {
        let _ = c(S.name);
        if (_.name in this.cachedRules) {
          k.push("Duplicated rule " + _.name);
          return;
        } else
          this.cachedRules[_.name] = S;
        if (!S.bnf || !S.bnf.length) {
          let D = "Missing rule content, rule: " + S.name;
          k.indexOf(D) == -1 && k.push(D);
        } else
          S.bnf.forEach((D) => {
            if (typeof D[0] == "string" && c(D[0]).name == S.name) {
              let A = "Left recursion is not allowed, rule: " + S.name;
              k.indexOf(A) == -1 && k.push(A);
            }
            D.forEach((A) => {
              if (typeof A == "string") {
                let O = c(A);
                !O.isLiteral && C.indexOf(O.name) == -1 && p.indexOf(O.name) == -1 && C.push(O.name);
              }
            });
          });
        n == S.name && (S.implicitWs = !1), S.implicitWs && C.indexOf(n) == -1 && C.push(n), S.recover && C.indexOf(S.recover) == -1 && C.push(S.recover);
      }), C.forEach((S) => {
        S in this.cachedRules || k.push("Missing rule " + S);
      }), k.length)
        throw new Error(k.join(`
`));
    }
    getAST(y, b) {
      b || (b = this.grammarRules.filter((C) => !C.fragment && C.name.indexOf("%") != 0)[0].name);
      let k = this.parse(y, b);
      if (k) {
        u(k.errors, k), l(k, 0), d(k, /^%/), (!this.options || !this.options.keepUpperRules) && d(k, t);
        let C = k.rest;
        C && new i.TokenError(`Unexpected end of input: 
` + C, k), a(k), k.rest = C;
      }
      return k;
    }
    emitSource() {
      return "CANNOT EMIT SOURCE FROM BASE Parser";
    }
    parse(y, b, k = 0) {
      let C = null, S = c(b), _, D = this.debug && /*!isLiteral &*/
      !t.test(S.name);
      D && console.log(new Array(k).join("â”‚  ") + "Trying to get " + b + " from " + JSON.stringify(y.split(`
`)[0]));
      let A = S.name, O = h(S.name, this);
      if (S.name == "EOF") {
        if (y.length)
          return null;
        if (y.length == 0)
          return {
            type: "EOF",
            text: "",
            rest: "",
            start: 0,
            end: 0,
            fullText: "",
            errors: [],
            children: [],
            parent: null
          };
      }
      try {
        if (!O && S.isLiteral) {
          let M = S.name.trim();
          if (M.startsWith('"') ? M = JSON.parse(M) : M.startsWith("'") && (M = M.replace(/^'(.+)'$/, "$1").replace(/\\'/g, "'")), M === "")
            return {
              type: "%%EMPTY%%",
              text: "",
              rest: y,
              start: 0,
              end: 0,
              fullText: "",
              errors: [],
              children: [],
              parent: null
            };
          _ = new RegExp(s(M)), A = null;
        }
      } catch (M) {
        return M instanceof ReferenceError && console.error(M), null;
      }
      if (_) {
        let M = o(y, _);
        if (M)
          return M.type = A, M;
      } else {
        let M = O.bnf;
        M instanceof Array && M.forEach((z) => {
          if (C)
            return;
          let R = null, N = {
            type: S.name,
            text: "",
            children: [],
            end: 0,
            errors: [],
            fullText: "",
            parent: null,
            start: 0,
            rest: y
          };
          O.fragment && (N.fragment = !0);
          let I = y, B = 0, $ = z.length > 0, q = !1;
          for (let U = 0; U < z.length; U++)
            if (typeof z[U] == "string") {
              let H = c(z[U]);
              $ = $ && H.isOptional;
              let G, re = !1;
              do {
                if (G = null, O.implicitWs && (G = this.parse(I, H.name, k + 1), !G)) {
                  let ie;
                  do
                    if (ie = this.parse(I, n, k + 1), ie)
                      N.text = N.text + ie.text, N.end = N.text.length, ie.parent = N, N.children.push(ie), I = I.substr(ie.text.length), B += ie.text.length;
                    else
                      break;
                  while (ie && ie.text.length);
                }
                if (G = G || this.parse(I, H.name, k + 1), H.lookupNegative) {
                  if (G)
                    return;
                  break;
                }
                if (H.lookupPositive && !G)
                  return;
                if (!G && (H.isOptional || H.atLeastOne && re))
                  break;
                if (G && O.pinned == U + 1 && (R = G, D && console.log(new Array(k + 1).join("â”‚  ") + "â””â”€ " + G.type + " PINNED")), G || (G = this.parseRecovery(O, I, k + 1)), !G)
                  if (R)
                    C = N, G = {
                      type: "SyntaxError",
                      text: I,
                      children: [],
                      end: I.length,
                      errors: [],
                      fullText: "",
                      parent: null,
                      start: 0,
                      rest: ""
                    }, I.length ? new i.TokenError(`Unexpected end of input. Expecting ${H.name} Got: ${I}`, G) : new i.TokenError(`Unexpected end of input. Missing ${H.name}`, G), D && console.log(new Array(k + 1).join("â”‚  ") + "â””â”€ " + G.type + " " + JSON.stringify(G.text));
                  else
                    return;
                if (re = !0, q = !0, G.type == "%%EMPTY%%")
                  break;
                G.start += B, G.end += B, !H.lookupPositive && G.type && (G.fragment ? G.children && G.children.forEach((ie) => {
                  ie.start += B, ie.end += B, ie.parent = N, N.children.push(ie);
                }) : (G.parent = N, N.children.push(G))), H.lookup && (G.lookup = !0), D && console.log(new Array(k + 1).join("â”‚  ") + "â””â”€ " + G.type + " " + JSON.stringify(G.text)), !H.lookup && !G.lookup && (N.text = N.text + G.text, N.end = N.text.length, I = I.substr(G.text.length), B += G.text.length), N.rest = I;
              } while (G && H.allowRepetition && I.length && !G.lookup);
            } else {
              let H = o(I, z[U]);
              if (!H)
                return;
              D && console.log(new Array(k + 1).join("â”‚  ") + "â””> " + JSON.stringify(H.text) + z[U].source), q = !0, H.start += B, H.end += B, N.text = N.text + H.text, N.end = N.text.length, I = I.substr(H.text.length), B += H.text.length, N.rest = I;
            }
          q && (C = N, D && console.log(new Array(k).join("â”‚  ") + "â”œ<â”€â”´< PUSHING " + C.type + " " + JSON.stringify(C.text)));
        }), C && O.simplifyWhenOneChildren && C.children.length == 1 && (C = C.children[0]);
      }
      return C || D && console.log(b + " NOT RESOLVED FROM " + y), C;
    }
    parseRecovery(y, b, k) {
      if (y.recover && b.length) {
        let C = this.debug;
        C && console.log(new Array(k + 1).join("â”‚  ") + "Trying to recover until token " + y.recover + " from " + JSON.stringify(b.split(`
`)[0] + b.split(`
`)[1]));
        let S = {
          type: "SyntaxError",
          text: "",
          children: [],
          end: 0,
          errors: [],
          fullText: "",
          parent: null,
          start: 0,
          rest: ""
        }, _;
        do
          if (_ = this.parse(b, y.recover, k + 1), _) {
            new i.TokenError('Unexpected input: "' + S.text + `" Expecting: ${y.name}`, S);
            break;
          } else
            S.text = S.text + b[0], S.end = S.text.length, b = b.substr(1);
        while (!_ && b.length > 0);
        if (S.text.length > 0 && _)
          return C && console.log(new Array(k + 1).join("â”‚  ") + "Recovered text: " + JSON.stringify(S.text)), S;
      }
      return null;
    }
  }
  return Hi.Parser = g, Hi.default = g, Hi;
}
var L8;
function Foe() {
  if (L8) return Gv;
  L8 = 1, Object.defineProperty(Gv, "__esModule", { value: !0 });
  const t = Ooe();
  var e;
  return (function(r) {
    r.RULES = [
      {
        name: "Grammar",
        bnf: [["RULE_S*", "%Atomic*", "EOF"]]
      },
      {
        name: "%Atomic",
        bnf: [["Production", "RULE_S*"]],
        fragment: !0
      },
      {
        name: "Production",
        bnf: [["NCName", "RULE_S*", '"::="', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", "RULE_EOL+", "RULE_S*"]]
      },
      {
        name: "NCName",
        bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]
      },
      {
        name: "Choice",
        bnf: [["SequenceOrDifference", "%_Choice_1*"]],
        fragment: !0
      },
      {
        name: "%_Choice_1",
        bnf: [["RULE_WHITESPACE*", '"|"', "RULE_WHITESPACE*", "SequenceOrDifference"]],
        fragment: !0
      },
      {
        name: "SequenceOrDifference",
        bnf: [["Item", "RULE_WHITESPACE*", "%_Item_1?"]]
      },
      {
        name: "%_Item_1",
        bnf: [["Minus", "Item"], ["Item*"]],
        fragment: !0
      },
      {
        name: "Minus",
        bnf: [['"-"']]
      },
      {
        name: "Item",
        bnf: [["RULE_WHITESPACE*", "%Primary", "PrimaryDecoration?"]],
        fragment: !0
      },
      {
        name: "PrimaryDecoration",
        bnf: [['"?"'], ['"*"'], ['"+"']]
      },
      {
        name: "DecorationName",
        bnf: [['"ebnf://"', /[^\x5D#]+/]]
      },
      {
        name: "%Primary",
        bnf: [["NCName"], ["StringLiteral"], ["CharCode"], ["CharClass"], ["SubItem"]],
        fragment: !0
      },
      {
        name: "SubItem",
        bnf: [['"("', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", '")"']]
      },
      {
        name: "StringLiteral",
        bnf: [[`'"'`, /[^"]*/, `'"'`], [`"'"`, /[^']*/, `"'"`]],
        pinned: 1
      },
      {
        name: "CharCode",
        bnf: [['"#x"', /[0-9a-zA-Z]+/]]
      },
      {
        name: "CharClass",
        bnf: [["'['", "'^'?", "%RULE_CharClass_1+", '"]"']]
      },
      {
        name: "%RULE_CharClass_1",
        bnf: [["CharCodeRange"], ["CharRange"], ["CharCode"], ["RULE_Char"]],
        fragment: !0
      },
      {
        name: "RULE_Char",
        bnf: [[/\x09/], [/\x0A/], [/\x0D/], [/[\x20-\x5c]/], [/[\x5e-\uD7FF]/], [/[\uE000-\uFFFD]/]]
      },
      {
        name: "CharRange",
        bnf: [["RULE_Char", '"-"', "RULE_Char"]]
      },
      {
        name: "CharCodeRange",
        bnf: [["CharCode", '"-"', "CharCode"]]
      },
      {
        name: "RULE_WHITESPACE",
        bnf: [["%RULE_WHITESPACE_CHAR*"], ["Comment", "RULE_WHITESPACE*"]]
      },
      {
        name: "RULE_S",
        bnf: [["RULE_WHITESPACE", "RULE_S*"], ["RULE_EOL", "RULE_S*"]]
      },
      {
        name: "%RULE_WHITESPACE_CHAR",
        bnf: [[/\x09/], [/\x20/]],
        fragment: !0
      },
      {
        name: "Comment",
        bnf: [['"/*"', "%RULE_Comment_Body*", '"*/"']]
      },
      {
        name: "%RULE_Comment_Body",
        bnf: [['!"*/"', /[^*]/]],
        fragment: !0
      },
      {
        name: "RULE_EOL",
        bnf: [[/\x0D/, /\x0A/], [/\x0A/], [/\x0D/]]
      },
      {
        name: "Link",
        bnf: [["'['", "Url", "']'"]]
      },
      {
        name: "Url",
        bnf: [[/[^\x5D:/?#]/, '"://"', /[^\x5D#]+/, "%Url1?"]]
      },
      {
        name: "%Url1",
        bnf: [['"#"', "NCName"]],
        fragment: !0
      }
    ], r.defaultParser = new t.Parser(r.RULES, { debug: !1 });
    const n = /^(!|&)/, i = /(\?|\+|\*)$/, o = /^%/;
    function s(C, S) {
      if (typeof C == "string") {
        if (n.test(C))
          return "";
        if (o.test(C)) {
          let _ = i.exec(C), D = _ ? _[0] + " " : "";
          return a(C, S) ? u(C, S) + D : "(" + u(C, S) + ")" + D;
        }
        return C;
      } else
        return C.source.replace(/\\(?:x|u)([a-zA-Z0-9]+)/g, "#x$1").replace(/\[\\(?:x|u)([a-zA-Z0-9]+)-\\(?:x|u)([a-zA-Z0-9]+)\]/g, "[#x$1-#x$2]");
    }
    function a(C, S) {
      let _ = t.findRuleByName(C, S);
      return _ && _.bnf.length == 1 && _.bnf[0].length == 1 && (_.bnf[0][0] instanceof RegExp || _.bnf[0][0][0] == '"' || _.bnf[0][0][0] == "'");
    }
    function l(C, S) {
      return C.map((_) => s(_, S)).join(" ");
    }
    function u(C, S) {
      let _ = t.findRuleByName(C, S);
      return _ ? _.bnf.map((D) => l(D, S)).join(" | ") : "RULE_NOT_FOUND {" + C + "}";
    }
    function c(C) {
      let S = [];
      return C.grammarRules.forEach((_) => {
        if (!/^%/.test(_.name)) {
          let D = _.recover ? " /* { recoverUntil=" + _.recover + " } */" : "";
          S.push(_.name + " ::= " + u(_.name, C) + D);
        }
      }), S.join(`
`);
    }
    r.emit = c;
    let h = 0;
    function d(C, S) {
      throw console.log("reberia restar " + S + " a " + C), new Error("Difference not supported yet");
    }
    function p(C) {
      return new RegExp(C.replace(/#x([a-zA-Z0-9]{4})/g, "\\u$1").replace(/#x([a-zA-Z0-9]{3})/g, "\\u0$1").replace(/#x([a-zA-Z0-9]{2})/g, "\\x$1").replace(/#x([a-zA-Z0-9]{1})/g, "\\x0$1"));
    }
    function g(C, S, _) {
      let D = null, A = [];
      return S.children.forEach((O, M) => {
        O.type == "Minus" && d(D, O);
        let z = S.children[M + 1];
        z = z && z.type == "PrimaryDecoration" && z.text || "";
        let R = "";
        switch (O.type) {
          case "SubItem":
            let N = "%" + (_ + h++);
            v(C, O, N), A.push(R + N + z);
            break;
          case "NCName":
          case "StringLiteral":
            A.push(R + O.text + z);
            break;
          case "CharCode":
          case "CharClass":
            if (z || R) {
              let I = {
                name: "%" + (_ + h++),
                bnf: [[p(O.text)]]
              };
              C.push(I), A.push(R + I.name + z);
            } else
              A.push(p(O.text));
            break;
          case "PrimaryDecoration":
            break;
          default:
            throw new Error(" HOW SHOULD I PARSE THIS? " + O.type + " -> " + JSON.stringify(O.text));
        }
        D = O;
      }), A;
    }
    function v(C, S, _) {
      let D = S.children.filter((M) => M.type == "SequenceOrDifference").map((M) => g(C, M, _)), A = {
        name: _,
        bnf: D
      }, O = null;
      D.forEach((M) => {
        O = O || M.recover, delete M.recover;
      }), _.indexOf("%") == 0 && (A.fragment = !0), O && (A.recover = O), C.push(A);
    }
    function y(C, S = r.defaultParser) {
      let _ = S.getAST(C);
      if (!_)
        throw new Error("Could not parse " + C);
      if (_.errors && _.errors.length)
        throw _.errors[0];
      let D = [];
      return _.children.filter((A) => A.type == "Production").map((A) => {
        let O = A.children.filter((M) => M.type == "NCName")[0].text;
        v(D, A, O);
      }), D;
    }
    r.getRules = y;
    function b(C, S = r.defaultParser) {
      return y(C.join(""), S);
    }
    r.Transform = b;
    class k extends t.Parser {
      constructor(S, _) {
        const D = _ && _.debugRulesParser === !0 ? new t.Parser(r.RULES, { debug: !0 }) : r.defaultParser;
        super(y(S, D), _);
      }
      emitSource() {
        return c(this);
      }
    }
    r.Parser = k;
  })(e || (e = {})), Gv.default = e, Gv;
}
var Toe = Foe();
const Moe = /* @__PURE__ */ Lh(Toe), Poe = "[^?/{}*,()#]+", Roe = `
root ::= ("#" recursion | recursion | (query | pattern) recursion* | "#" SEP? | SEP)
recursion ::= (SEP query | pattern)*

query ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?
property ::= ${Poe}
regex ::= "{" [^}]+ "}"
SEP ::= "/"
all ::= "**"
any ::= "*"

typecheck ::= "?:" ("value" | "boolean" | "string" | "number" | "object" | "array")
lookahead ::= "?" expression ((andExpr | orExpr) expression)*
andExpr ::= S? "&&" S?
orExpr ::= S? "||" S?

expression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*
exprProperty ::= [a-zA-Z0-9-_ $]+
escaped ::= [^"]+
is ::= ":"
isnot ::= ":!"
ESC ::= '"'

pattern ::= S? "(" (SEP query | pattern (orPattern? pattern)*)* ")" quantifier? S? lookahead?
quantifier ::= "+" | "*" | [0-9]+
orPattern ::= S? "," S?

S ::= [ ]*
`, Noe = new Moe.Parser(Roe), $oe = (t) => Noe.getAST(t), Ki = 0, Ed = 3, M1 = (t, e) => `${t}/${e}`, hN = Object.prototype.toString, Ioe = /Object|Array/, wC = (t) => Ioe.test(hN.call(t)), Boe = (t) => hN.call(t).match(/\s([^\]]+)\]/).pop().toLowerCase();
function fN(t) {
  return new RegExp(t.text.replace(/(^{|}$)/g, ""));
}
function Loe(t, e) {
  Array.isArray(t) ? t.forEach(e) : Object.prototype.toString.call(t) === "[object Object]" && Object.keys(t).forEach(function(r) {
    e(t[r], r, t);
  });
}
function z8(t) {
  return Array.isArray(t) ? t.map(function(e, r) {
    return `${r}`;
  }) : Object.prototype.toString.call(t) === "[object Object]" ? Object.keys(t) : [];
}
const Wu = {
  mem: [],
  get(t, e) {
    const r = t[Ki][e];
    if (!Wu.mem.includes(r))
      return wC(r) && Wu.mem.push(r), [r, e, t[Ki], M1(t[Ed], e)];
  },
  reset() {
    Wu.mem.length = 0;
  }
}, kC = {
  any(t, e) {
    const r = e[Ki];
    return z8(r).map((n) => [
      r[n],
      n,
      r,
      M1(e[Ed], n)
    ]);
  },
  all(t, e) {
    const r = [e];
    return Loe(e[Ki], (n, i) => {
      const o = Wu.get(e, i);
      o && r.push(...kC.all(t, o));
    }), r;
  },
  regex(t, e) {
    const r = fN(t), n = e[Ki];
    return z8(n).filter((i) => r.test(i)).map((i) => [
      n[i],
      i,
      n,
      M1(e[Ed], i)
    ]);
  }
}, P1 = {
  // alias to property (but escaped)
  escaped: (t, e) => P1.property(t, e),
  property: (t, e) => {
    const r = t.text;
    if (e[Ki] && e[Ki][r] !== void 0)
      return [
        e[Ki][r],
        r,
        e[Ki],
        M1(e[Ed], r)
      ];
  },
  typecheck: (t, e) => {
    const r = t.text.replace(/^\?:/, "");
    if (r === "value")
      return wC(e[Ki]) ? void 0 : e;
    if (Boe(e[Ki]) === r)
      return e;
  },
  lookahead: (t, e) => {
    let r = !0, n = !1;
    return t.children.forEach((i) => {
      if (i.type === "expression") {
        const o = P1.expression(i, e) !== void 0;
        r = n === !0 ? r || o : r && o;
      } else
        n = i.type === "orExpr";
    }), r ? e : void 0;
  },
  expression: (t, e) => {
    const r = t.children[0].text, n = t.children[1], i = t.children[2], o = e[Ki];
    if (wC(o) !== !1)
      return zoe(o[r], n, i) ? e : void 0;
  }
};
function zoe(t, e, r) {
  if (e === void 0)
    return t !== void 0;
  let n;
  const i = `${t}`;
  return r.type === "regex" ? n = fN(r).test(i) : n = i === r.text, e.type === "isnot" && (n = n === !1 && t !== void 0), n;
}
function joe(t, e, r, n) {
  const i = [];
  for (let o = 0, s = e.length; o < s; o += 1)
    i.push(...t(r, e[o], r, n));
  return i;
}
function qoe(t, e, r, n) {
  const i = [];
  for (let o = 0, s = e.length; o < s; o += 1) {
    const a = t(r, e[o], n);
    a && i.push(a);
  }
  return i;
}
function Uoe(t, e, r) {
  let n = t;
  return e.children.forEach((i) => {
    if (kC[i.type])
      n = joe(kC[i.type], n, i, r);
    else if (P1[i.type])
      n = qoe(P1[i.type], n, i, r);
    else
      throw new Error(`Unknown filter ${i.type}`);
  }), n;
}
function Hoe(t, e, r) {
  const n = [];
  let i = t;
  return e.children.forEach((o) => {
    if (o.type === "orPattern") {
      n.push(...i), i = t;
      return;
    }
    i = V4(i, o, r);
  }), n.push(...i), n;
}
function Voe(t) {
  if (t == null)
    return 1;
  if (t === "*" || t === "+")
    return 1 / 0;
  const e = parseInt(t);
  return isNaN(e) ? 1 : e;
}
function Woe(t, e, r) {
  const n = [], i = e.children.find((l) => l.type === "quantifier"), o = Voe(i && i.text);
  let s = t;
  i && i.text === "*" && n.push(...s);
  let a = 0;
  for (; s.length > 0 && a < o; )
    s = Hoe(s, e, r), n.push(...s), a += 1;
  return n;
}
function Goe(t, e, r) {
  let n = t;
  return e.children.forEach((i) => n = V4(n, i, r)), n;
}
function V4(t, e, r) {
  let n;
  return e.type === "query" ? n = Uoe(t, e, r) : e.type === "pattern" ? n = Woe(t, e, r) : n = Goe(t, e, r), Wu.reset(), Wu.mem.push(t), n;
}
function Koe(t, e) {
  return Wu.reset(), Wu.mem.push(t), V4([[t, null, null, "#"]], e);
}
const j8 = {
  value: (t) => t.map((e) => e[Ki]),
  pointer: (t) => t.map((e) => e[Ed]),
  all: (t) => t,
  map: (t) => {
    const e = {};
    return t.forEach((r) => e[r[Ed]] = r[Ki]), e;
  }
};
var Ch;
(function(t) {
  t.POINTER = "pointer", t.VALUE = "value", t.ALL = "all", t.MAP = "map";
})(Ch || (Ch = {}));
i0.POINTER = Ch.POINTER;
i0.VALUE = Ch.VALUE;
i0.ALL = Ch.ALL;
i0.MAP = Ch.MAP;
function i0(t, e, r = Ch.VALUE) {
  if (e == null)
    return [];
  e = e.replace(/(\/$)/g, ""), e === "" && (e = "#");
  const n = $oe(e);
  if (n == null)
    throw new Error(`empty ast for '${e}'`);
  if (n.rest !== "")
    throw new Error(`Failed parsing queryString from: '${n.rest}'`);
  const i = Koe(t, n);
  return typeof r == "function" ? i.map((o) => r(...o)) : j8[r] ? j8[r](i) : i;
}
var R1;
(function(t) {
  t.REPLACE_ITEMS = "replace", t.INSERT_ITEMS = "insert";
})(R1 || (R1 = {}));
R1.REPLACE_ITEMS;
R1.INSERT_ITEMS;
const Nl = {
  $ref: {
    type: !1
  },
  allOf: {
    type: !1,
    definitions: ["allOf/*"]
  },
  anyOf: {
    type: !1,
    definitions: ["anyOf/*"]
  },
  array: {
    type: !0,
    // ignore additionalItems:TypeDef, when items:TypeDef
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "items",
      "items/*",
      "additionalItems"
    ],
    validationKeywords: ["minItems", "maxItems", "uniqueItems"],
    keywords: ["items", "additionalItems", "minItems", "maxItems", "uniqueItems"]
  },
  boolean: {
    type: !0
  },
  enum: {
    type: !1
  },
  integer: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  not: {
    type: !1,
    definitions: ["not"]
  },
  number: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  null: {
    type: !0
  },
  object: {
    type: !0,
    // patternProperties also validate properties
    // dependencies:(string, TypeDef) extend current TypeDef
    // additional Properties validate only remaining properties (after properties & pattern)
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "properties/*",
      "additionalProperties",
      "patternProperties/*",
      "dependencies/*"
    ],
    validationKeywords: ["minProperties", "maxProperties", "required"],
    keywords: [
      "properties",
      "additionalProperties",
      "patternProperties",
      "dependencies",
      "minProperties",
      "maxProperties",
      "required"
    ]
  },
  oneOf: {
    type: !1,
    definitions: ["oneOf/*"]
  },
  string: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minLength", "maxLength", "pattern"]
  }
}, Qoe = Object.keys(Nl).filter((t) => Nl[t].type === !1), q8 = Object.prototype.hasOwnProperty;
function U8(t) {
  if (Vu(t) === !1)
    return;
  if (t.enum)
    return "enum";
  const e = t.type;
  if (Array.isArray(e) || Nl[e])
    return e;
  const r = Qoe.filter((n) => t[n]);
  if (r.length === 1)
    return r[0];
  if (r.length === 0) {
    for (let n = 0, i = Nl.object.keywords.length; n < i; n += 1) {
      const o = Nl.object.keywords[n];
      if (q8.call(t, o))
        return "object";
    }
    for (let n = 0, i = Nl.array.keywords.length; n < i; n += 1) {
      const o = Nl.array.keywords[n];
      if (q8.call(t, o))
        return "array";
    }
    return;
  }
  throw new Error(`Mutiple typeIds [${r.join(", ")}] matched in ${JSON.stringify(t)}`);
}
function Xoe(t) {
  const e = [], r = U8(t);
  if (r == null)
    return e;
  let n;
  if (Array.isArray(r)) {
    n = {};
    for (let i = 0, o = r.length; i < o; i += 1)
      Object.assign(n, Nl[r[i]]);
  } else
    n = Nl[r];
  return n.definitions == null || n.definitions.forEach((i) => {
    i0(t, i, (o, s, a, l) => {
      Vu(o) && U8(o) && e.push({ pointer: gg.join(gg.split(l), !1), def: o });
    });
  }), e;
}
function Joe(t, e) {
  this.callback(t, e) !== !0 && Xoe(t).forEach((r) => this.nextTypeDefs(r.def, gg.join(e, r.pointer, !1)));
}
function Kv(t, e, r, n = "definitions") {
  const i = e[n];
  Object.keys(i).forEach((o) => {
    if (i[o] === !1 || Vu(i[o])) {
      t.nextTypeDefs(i[o], gg.join(r, n, o, !1));
      return;
    }
  });
}
function Gb(t, e, r = "#") {
  const n = { callback: e, nextTypeDefs: Joe };
  n.nextTypeDefs(t, r), t.definitions != null && (n.callback = (i, o) => {
    e(i, o), i.definitions != null && Kv(n, i, o);
  }, Kv(n, t, r)), t.$defs != null && (n.callback = (i, o) => {
    e(i, o), i.definitions != null && Kv(n, i, o);
  }, Kv(n, t, r, "$defs"));
}
const Yoe = /(#|\/)+$/, Qv = /#$/, Zoe = /^[^:]+:\/\/[^/]+\//, ese = /\/[^/]*$/, tse = /#.*$/;
function N1(t, e) {
  return t == null && e == null ? "#" : e == null ? t.replace(Qv, "") : t == null ? e.replace(Qv, "") : e[0] === "#" ? `${t.replace(tse, "")}${e.replace(Yoe, "")}` : Zoe.test(e) ? e.replace(Qv, "") : `${t.replace(ese, "")}/${e.replace(Qv, "")}`;
}
const Yp = /(#|\/)+$/g, rse = ["", null, "#"];
function nse(t) {
  if (rse.includes(t))
    return [];
  if (t = t.replace(Yp, ""), t.indexOf("#") === -1)
    return [t.replace(Yp, "")];
  if (t.indexOf("#") === 0)
    return [t.replace(Yp, "")];
  const e = t.split("#");
  return e[0] = e[0].replace(Yp, ""), e[1] = `#${e[1].replace(Yp, "")}`, e;
}
const ise = /(#|\/)+$/g, ose = (t) => er(t) === "object";
function Ol(t, e, r) {
  if (ose(r) && (r = r.__ref || r.$ref), r == null)
    return e;
  let n;
  const i = r.replace(ise, "");
  if (t.remotes[i])
    return n = t.remotes[i], n && n.$ref ? Ol(t, e, n.$ref) : n;
  if (t.ids[r])
    return n = Hc.get(e, t.ids[r]), n && n.$ref ? Ol(t, e, n.$ref) : n;
  const o = nse(r);
  if (o.length === 0)
    return e;
  if (o.length === 1) {
    if (r = o[0], t.remotes[r])
      return n = t.remotes[r], Ol(t, e, n.$ref);
    if (t.ids[r])
      return n = Hc.get(e, t.ids[r]), n && n.$ref ? Ol(t, e, n.$ref) : n;
  }
  if (o.length === 2) {
    const s = o[0];
    if (r = o[1], t.remotes[s])
      return t.remotes[s].getRef ? t.remotes[s].getRef(r) : Ol(t, t.remotes[s], r);
    if (t.ids[s])
      return Ol(t, Hc.get(e, t.ids[s]), r);
  }
  return n = Hc.get(e, t.ids[r] || r), n && n.$ref ? Ol(t, e, n.$ref) : n;
}
const H8 = "__compiled", V8 = "__ref", sse = "getRef", ase = "getRoot", lse = /(#|\/)+$/g;
function use(t, e, r = e, n = !1) {
  if (!e || e[H8] !== void 0)
    return e;
  const i = { ids: {}, remotes: t.remotes }, o = JSON.stringify(e), s = JSON.parse(o);
  if (Object.defineProperty(s, H8, { enumerable: !1, value: !0 }), Object.defineProperty(s, sse, {
    enumerable: !1,
    value: Ol.bind(null, i, s)
  }), n === !1 && o.includes("$ref") === !1)
    return s;
  e !== r && Object.defineProperty(s, "definitions", {
    enumerable: !1,
    value: Object.assign({}, r.definitions, r.$defs, e.definitions, e.$defs)
  });
  const a = {}, l = () => s;
  return Gb(s, (u, c) => {
    var h;
    if (u.id) {
      if (u.id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(c)) {
        const y = c.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, ""), b = Hc.get(s, y);
        u.id = (h = b.id) !== null && h !== void 0 ? h : u.id;
      }
      i.ids[u.id.replace(lse, "")] = c;
    }
    c = `#${c}`.replace(/##+/, "#");
    const d = c.replace(/\/[^/]+$/, ""), p = c.replace(/\/[^/]+\/[^/]+$/, ""), g = a[d] || a[p], v = N1(g, u.id);
    a[c] = v, i.ids[v] == null && (i.ids[v] = c), u.$ref && !u[V8] && (Object.defineProperty(u, V8, {
      enumerable: !1,
      value: N1(v, u.$ref)
    }), Object.defineProperty(u, ase, { enumerable: !1, value: l }));
  }), s;
}
function dN(t, e, r, n = t.rootSchema, i = "#") {
  n = t.resolveRef(n), r(n, e, i);
  const o = er(e);
  o === "object" ? Object.keys(e).forEach((s) => {
    const a = t.step(s, n, e, i), l = e[s];
    t.each(l, r, a, `${i}/${s}`);
  }) : o === "array" && e.forEach((s, a) => {
    const l = t.step(a, n, e, i);
    t.each(s, r, l, `${i}/${a}`);
  });
}
const pN = {
  additionalItemsError: Xe("AdditionalItemsError"),
  additionalPropertiesError: Xe("AdditionalPropertiesError"),
  anyOfError: Xe("AnyOfError"),
  allOfError: Xe("AllOfError"),
  constError: Xe("ConstError"),
  containsError: Xe("ContainsError"),
  containsArrayError: Xe("ContainsArrayError"),
  containsAnyError: Xe("ContainsAnyError"),
  enumError: Xe("EnumError"),
  forbiddenPropertyError: Xe("ForbiddenPropertyError"),
  formatURLError: Xe("FormatURLError"),
  formatURIError: Xe("FormatURIError"),
  formatURIReferenceError: Xe("FormatURIReferenceError"),
  formatURITemplateError: Xe("FormatURITemplateError"),
  formatDateError: Xe("FormatDateError"),
  formatDateTimeError: Xe("FormatDateTimeError"),
  formatEmailError: Xe("FormatEmailError"),
  formatHostnameError: Xe("FormatHostnameError"),
  formatIPV4Error: Xe("FormatIPV4Error"),
  formatIPV4LeadingZeroError: Xe("FormatIPV4LeadingZeroError"),
  formatIPV6Error: Xe("FormatIPV6Error"),
  formatIPV6LeadingZeroError: Xe("FormatIPV6LeadingZeroError"),
  formatJsonPointerError: Xe("FormatJsonPointerError"),
  formatRegExError: Xe("FormatRegExError"),
  formatTimeError: Xe("FormatTimeError"),
  invalidSchemaError: Xe("InvalidSchemaError"),
  invalidDataError: Xe("InvalidDataError"),
  invalidTypeError: Xe("InvalidTypeError"),
  invalidPropertyNameError: Xe("InvalidPropertyNameError"),
  maximumError: Xe("MaximumError"),
  maxItemsError: Xe("MaxItemsError"),
  maxLengthError: Xe("MaxLengthError"),
  maxPropertiesError: Xe("MaxPropertiesError"),
  minimumError: Xe("MinimumError"),
  minItemsError: Xe("MinItemsError"),
  minItemsOneError: Xe("MinItemsOneError"),
  minLengthError: Xe("MinLengthError"),
  minLengthOneError: Xe("MinLengthOneError"),
  minPropertiesError: Xe("MinPropertiesError"),
  missingDependencyError: Xe("MissingDependencyError"),
  missingOneOfPropertyError: Xe("MissingOneOfPropertyError"),
  multipleOfError: Xe("MultipleOfError"),
  multipleOneOfError: Xe("MultipleOneOfError"),
  noAdditionalPropertiesError: Xe("NoAdditionalPropertiesError"),
  notError: Xe("NotError"),
  oneOfError: Xe("OneOfError"),
  oneOfPropertyError: Xe("OneOfPropertyError"),
  patternError: Xe("PatternError"),
  patternPropertiesError: Xe("PatternPropertiesError"),
  requiredPropertyError: Xe("RequiredPropertyError"),
  schemaWarning: Xe("SchemaWarning"),
  typeError: Xe("TypeError"),
  undefinedValueError: Xe("UndefinedValueError"),
  uniqueItemsError: Xe("UniqueItemsError"),
  unknownPropertyError: Xe("UnknownPropertyError"),
  valueNotEmptyError: Xe("ValueNotEmptyError")
};
var W8 = { exports: {} }, G8;
function cse() {
  return G8 || (G8 = 1, (function(t) {
    (function(e) {
      e.exports.is_uri = n, e.exports.is_http_uri = i, e.exports.is_https_uri = o, e.exports.is_web_uri = s, e.exports.isUri = n, e.exports.isHttpUri = i, e.exports.isHttpsUri = o, e.exports.isWebUri = s;
      var r = function(a) {
        var l = a.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return l;
      };
      function n(a) {
        if (a && !/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(a) && !/%[^0-9a-f]/i.test(a) && !/%[0-9a-f](:?[^0-9a-f]|$)/i.test(a)) {
          var l = [], u = "", c = "", h = "", d = "", p = "", g = "";
          if (l = r(a), u = l[1], c = l[2], h = l[3], d = l[4], p = l[5], !!(u && u.length && h.length >= 0)) {
            if (c && c.length) {
              if (!(h.length === 0 || /^\//.test(h))) return;
            } else if (/^\/\//.test(h)) return;
            if (/^[a-z][a-z0-9\+\-\.]*$/.test(u.toLowerCase()))
              return g += u + ":", c && c.length && (g += "//" + c), g += h, d && d.length && (g += "?" + d), p && p.length && (g += "#" + p), g;
          }
        }
      }
      function i(a, l) {
        if (n(a)) {
          var u = [], c = "", h = "", d = "", p = "", g = "", v = "", y = "";
          if (u = r(a), c = u[1], h = u[2], d = u[3], g = u[4], v = u[5], !!c) {
            if (l) {
              if (c.toLowerCase() != "https") return;
            } else if (c.toLowerCase() != "http") return;
            if (h)
              return /:(\d+)$/.test(h) && (p = h.match(/:(\d+)$/)[0], h = h.replace(/:\d+$/, "")), y += c + ":", y += "//" + h, p && (y += p), y += d, g && g.length && (y += "?" + g), v && v.length && (y += "#" + v), y;
          }
        }
      }
      function o(a) {
        return i(a, !0);
      }
      function s(a) {
        return i(a) || o(a);
      }
    })(t);
  })(W8)), W8.exports;
}
var hse = cse();
const K8 = /* @__PURE__ */ Lh(hse);
var _i = {}, CC = { exports: {} }, fse = CC.exports, Q8;
function dse() {
  return Q8 || (Q8 = 1, (function(t) {
    (function(e, r) {
      t.exports ? t.exports = r() : e.nearley = r();
    })(fse, function() {
      function e(u, c, h) {
        return this.id = ++e.highestId, this.name = u, this.symbols = c, this.postprocess = h, this;
      }
      e.highestId = 0, e.prototype.toString = function(u) {
        var c = typeof u > "u" ? this.symbols.map(l).join(" ") : this.symbols.slice(0, u).map(l).join(" ") + " â— " + this.symbols.slice(u).map(l).join(" ");
        return this.name + " â†’ " + c;
      };
      function r(u, c, h, d) {
        this.rule = u, this.dot = c, this.reference = h, this.data = [], this.wantedBy = d, this.isComplete = this.dot === u.symbols.length;
      }
      r.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      }, r.prototype.nextState = function(u) {
        var c = new r(this.rule, this.dot + 1, this.reference, this.wantedBy);
        return c.left = this, c.right = u, c.isComplete && (c.data = c.build(), c.right = void 0), c;
      }, r.prototype.build = function() {
        var u = [], c = this;
        do
          u.push(c.right.data), c = c.left;
        while (c.left);
        return u.reverse(), u;
      }, r.prototype.finish = function() {
        this.rule.postprocess && (this.data = this.rule.postprocess(this.data, this.reference, s.fail));
      };
      function n(u, c) {
        this.grammar = u, this.index = c, this.states = [], this.wants = {}, this.scannable = [], this.completed = {};
      }
      n.prototype.process = function(u) {
        for (var c = this.states, h = this.wants, d = this.completed, p = 0; p < c.length; p++) {
          var g = c[p];
          if (g.isComplete) {
            if (g.finish(), g.data !== s.fail) {
              for (var v = g.wantedBy, y = v.length; y--; ) {
                var b = v[y];
                this.complete(b, g);
              }
              if (g.reference === this.index) {
                var k = g.rule.name;
                (this.completed[k] = this.completed[k] || []).push(g);
              }
            }
          } else {
            var k = g.rule.symbols[g.dot];
            if (typeof k != "string") {
              this.scannable.push(g);
              continue;
            }
            if (h[k]) {
              if (h[k].push(g), d.hasOwnProperty(k))
                for (var C = d[k], y = 0; y < C.length; y++) {
                  var S = C[y];
                  this.complete(g, S);
                }
            } else
              h[k] = [g], this.predict(k);
          }
        }
      }, n.prototype.predict = function(u) {
        for (var c = this.grammar.byName[u] || [], h = 0; h < c.length; h++) {
          var d = c[h], p = this.wants[u], g = new r(d, 0, this.index, p);
          this.states.push(g);
        }
      }, n.prototype.complete = function(u, c) {
        var h = u.nextState(c);
        this.states.push(h);
      };
      function i(u, c) {
        this.rules = u, this.start = c || this.rules[0].name;
        var h = this.byName = {};
        this.rules.forEach(function(d) {
          h.hasOwnProperty(d.name) || (h[d.name] = []), h[d.name].push(d);
        });
      }
      i.fromCompiled = function(d, c) {
        var h = d.Lexer;
        d.ParserStart && (c = d.ParserStart, d = d.ParserRules);
        var d = d.map(function(g) {
          return new e(g.name, g.symbols, g.postprocess);
        }), p = new i(d, c);
        return p.lexer = h, p;
      };
      function o() {
        this.reset("");
      }
      o.prototype.reset = function(u, c) {
        this.buffer = u, this.index = 0, this.line = c ? c.line : 1, this.lastLineBreak = c ? -c.col : 0;
      }, o.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var u = this.buffer[this.index++];
          return u === `
` && (this.line += 1, this.lastLineBreak = this.index), { value: u };
        }
      }, o.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      }, o.prototype.formatError = function(u, c) {
        var h = this.buffer;
        if (typeof h == "string") {
          var d = h.split(`
`).slice(
            Math.max(0, this.line - 5),
            this.line
          ), p = h.indexOf(`
`, this.index);
          p === -1 && (p = h.length);
          var g = this.index - this.lastLineBreak, v = String(this.line).length;
          return c += " at line " + this.line + " col " + g + `:

`, c += d.map(function(b, k) {
            return y(this.line - d.length + k + 1, v) + " " + b;
          }, this).join(`
`), c += `
` + y("", v + g) + `^
`, c;
        } else
          return c + " at index " + (this.index - 1);
        function y(b, k) {
          var C = String(b);
          return Array(k - C.length + 1).join(" ") + C;
        }
      };
      function s(u, c, d) {
        if (u instanceof i)
          var p = u, d = c;
        else
          var p = i.fromCompiled(u, c);
        this.grammar = p, this.options = {
          keepHistory: !1,
          lexer: p.lexer || new o()
        };
        for (var g in d || {})
          this.options[g] = d[g];
        this.lexer = this.options.lexer, this.lexerState = void 0;
        var v = new n(p, 0);
        this.table = [v], v.wants[p.start] = [], v.predict(p.start), v.process(), this.current = 0;
      }
      s.fail = {}, s.prototype.feed = function(u) {
        var c = this.lexer;
        c.reset(u, this.lexerState);
        for (var h; ; ) {
          try {
            if (h = c.next(), !h)
              break;
          } catch (A) {
            var v = new n(this.grammar, this.current + 1);
            this.table.push(v);
            var d = new Error(this.reportLexerError(A));
            throw d.offset = this.current, d.token = A.token, d;
          }
          var p = this.table[this.current];
          this.options.keepHistory || delete this.table[this.current - 1];
          var g = this.current + 1, v = new n(this.grammar, g);
          this.table.push(v);
          for (var y = h.text !== void 0 ? h.text : h.value, b = c.constructor === o ? h.value : h, k = p.scannable, C = k.length; C--; ) {
            var S = k[C], _ = S.rule.symbols[S.dot];
            if (_.test ? _.test(b) : _.type ? _.type === h.type : _.literal === y) {
              var D = S.nextState({ data: b, token: h, isToken: !0, reference: g - 1 });
              v.states.push(D);
            }
          }
          if (v.process(), v.states.length === 0) {
            var d = new Error(this.reportError(h));
            throw d.offset = this.current, d.token = h, d;
          }
          this.options.keepHistory && (p.lexerState = c.save()), this.current++;
        }
        return p && (this.lexerState = c.save()), this.results = this.finish(), this;
      }, s.prototype.reportLexerError = function(u) {
        var c, h, d = u.token;
        return d ? (c = "input " + JSON.stringify(d.text[0]) + " (lexer error)", h = this.lexer.formatError(d, "Syntax error")) : (c = "input (lexer error)", h = u.message), this.reportErrorCommon(h, c);
      }, s.prototype.reportError = function(u) {
        var c = (u.type ? u.type + " token: " : "") + JSON.stringify(u.value !== void 0 ? u.value : u), h = this.lexer.formatError(u, "Syntax error");
        return this.reportErrorCommon(h, c);
      }, s.prototype.reportErrorCommon = function(u, c) {
        var h = [];
        h.push(u);
        var d = this.table.length - 2, p = this.table[d], g = p.states.filter(function(y) {
          var b = y.rule.symbols[y.dot];
          return b && typeof b != "string";
        });
        if (g.length === 0)
          h.push("Unexpected " + c + `. I did not expect any more input. Here is the state of my parse table:
`), this.displayStateStack(p.states, h);
        else {
          h.push("Unexpected " + c + `. Instead, I was expecting to see one of the following:
`);
          var v = g.map(function(y) {
            return this.buildFirstStateStack(y, []) || [y];
          }, this);
          v.forEach(function(y) {
            var b = y[0], k = b.rule.symbols[b.dot], C = this.getSymbolDisplay(k);
            h.push("A " + C + " based on:"), this.displayStateStack(y, h);
          }, this);
        }
        return h.push(""), h.join(`
`);
      }, s.prototype.displayStateStack = function(u, c) {
        for (var h, d = 0, p = 0; p < u.length; p++) {
          var g = u[p], v = g.rule.toString(g.dot);
          v === h ? d++ : (d > 0 && c.push("    ^ " + d + " more lines identical to this"), d = 0, c.push("    " + v)), h = v;
        }
      }, s.prototype.getSymbolDisplay = function(u) {
        return a(u);
      }, s.prototype.buildFirstStateStack = function(u, c) {
        if (c.indexOf(u) !== -1)
          return null;
        if (u.wantedBy.length === 0)
          return [u];
        var h = u.wantedBy[0], d = [u].concat(c), p = this.buildFirstStateStack(h, d);
        return p === null ? null : [u].concat(p);
      }, s.prototype.save = function() {
        var u = this.table[this.current];
        return u.lexerState = this.lexerState, u;
      }, s.prototype.restore = function(u) {
        var c = u.index;
        this.current = c, this.table[c] = u, this.table.splice(c + 1), this.lexerState = u.lexerState, this.results = this.finish();
      }, s.prototype.rewind = function(u) {
        if (!this.options.keepHistory)
          throw new Error("set option `keepHistory` to enable rewinding");
        this.restore(this.table[u]);
      }, s.prototype.finish = function() {
        var u = [], c = this.grammar.start, h = this.table[this.table.length - 1];
        return h.states.forEach(function(d) {
          d.rule.name === c && d.dot === d.rule.symbols.length && d.reference === 0 && d.data !== s.fail && u.push(d);
        }), u.map(function(d) {
          return d.data;
        });
      };
      function a(u) {
        var c = typeof u;
        if (c === "string")
          return u;
        if (c === "object") {
          if (u.literal)
            return JSON.stringify(u.literal);
          if (u instanceof RegExp)
            return "character matching " + u;
          if (u.type)
            return u.type + " token";
          if (u.test)
            return "token matching " + String(u.test);
          throw new Error("Unknown symbol type: " + u);
        }
      }
      function l(u) {
        var c = typeof u;
        if (c === "string")
          return u;
        if (c === "object") {
          if (u.literal)
            return JSON.stringify(u.literal);
          if (u instanceof RegExp)
            return u.toString();
          if (u.type)
            return "%" + u.type;
          if (u.test)
            return "<" + String(u.test) + ">";
          throw new Error("Unknown symbol type: " + u);
        }
      }
      return {
        Parser: s,
        Grammar: i,
        Rule: e
      };
    });
  })(CC)), CC.exports;
}
var Xv = {}, X8;
function pse() {
  if (X8) return Xv;
  X8 = 1, Object.defineProperty(Xv, "__esModule", { value: !0 });
  function t(i) {
    return i[0];
  }
  const e = (i) => [].concat(...i.map((o) => Array.isArray(o) ? e(o) : o));
  function r(i) {
    return i ? Array.isArray(i) ? e(i).join("") : i : "";
  }
  const n = {
    Lexer: void 0,
    ParserRules: [
      { name: "Reverse_path", symbols: ["Path"] },
      { name: "Reverse_path$string$1", symbols: [{ literal: "<" }, { literal: ">" }], postprocess: (i) => i.join("") },
      { name: "Reverse_path", symbols: ["Reverse_path$string$1"] },
      { name: "Forward_path$subexpression$1$subexpression$1", symbols: [{ literal: "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { literal: "@" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "Forward_path$subexpression$1", symbols: ["Forward_path$subexpression$1$subexpression$1", "Domain", { literal: ">" }] },
      { name: "Forward_path", symbols: ["Forward_path$subexpression$1"] },
      { name: "Forward_path$subexpression$2", symbols: [{ literal: "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { literal: ">" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "Forward_path", symbols: ["Forward_path$subexpression$2"] },
      { name: "Forward_path", symbols: ["Path"] },
      { name: "Path$ebnf$1$subexpression$1", symbols: ["A_d_l", { literal: ":" }] },
      { name: "Path$ebnf$1", symbols: ["Path$ebnf$1$subexpression$1"], postprocess: t },
      { name: "Path$ebnf$1", symbols: [], postprocess: () => null },
      { name: "Path", symbols: [{ literal: "<" }, "Path$ebnf$1", "Mailbox", { literal: ">" }] },
      { name: "A_d_l$ebnf$1", symbols: [] },
      { name: "A_d_l$ebnf$1$subexpression$1", symbols: [{ literal: "," }, "At_domain"] },
      { name: "A_d_l$ebnf$1", symbols: ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "A_d_l", symbols: ["At_domain", "A_d_l$ebnf$1"] },
      { name: "At_domain", symbols: [{ literal: "@" }, "Domain"] },
      { name: "Domain$ebnf$1", symbols: [] },
      { name: "Domain$ebnf$1$subexpression$1", symbols: [{ literal: "." }, "sub_domain"] },
      { name: "Domain$ebnf$1", symbols: ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Domain", symbols: ["sub_domain", "Domain$ebnf$1"] },
      { name: "sub_domain", symbols: ["U_label"] },
      { name: "Let_dig", symbols: ["ALPHA_DIGIT"], postprocess: t },
      { name: "Ldh_str$ebnf$1", symbols: [] },
      { name: "Ldh_str$ebnf$1", symbols: ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Ldh_str", symbols: ["Ldh_str$ebnf$1", "Let_dig"] },
      { name: "U_Let_dig", symbols: ["ALPHA_DIGIT_U"], postprocess: t },
      { name: "U_Ldh_str$ebnf$1", symbols: [] },
      { name: "U_Ldh_str$ebnf$1", symbols: ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "U_Ldh_str", symbols: ["U_Ldh_str$ebnf$1", "U_Let_dig"] },
      { name: "U_label$ebnf$1$subexpression$1", symbols: ["U_Ldh_str"] },
      { name: "U_label$ebnf$1", symbols: ["U_label$ebnf$1$subexpression$1"], postprocess: t },
      { name: "U_label$ebnf$1", symbols: [], postprocess: () => null },
      { name: "U_label", symbols: ["U_Let_dig", "U_label$ebnf$1"] },
      { name: "address_literal$subexpression$1", symbols: ["IPv4_address_literal"] },
      { name: "address_literal$subexpression$1", symbols: ["IPv6_address_literal"] },
      { name: "address_literal$subexpression$1", symbols: ["General_address_literal"] },
      { name: "address_literal", symbols: [{ literal: "[" }, "address_literal$subexpression$1", { literal: "]" }] },
      {
        name: "non_local_part",
        symbols: ["Domain"],
        postprocess: function(i) {
          return { DomainName: r(i[0]) };
        }
      },
      {
        name: "non_local_part",
        symbols: ["address_literal"],
        postprocess: function(i) {
          return { AddressLiteral: r(i[0]) };
        }
      },
      {
        name: "Mailbox",
        symbols: ["Local_part", { literal: "@" }, "non_local_part"],
        postprocess: function(i) {
          return { localPart: r(i[0]), domainPart: r(i[2]) };
        }
      },
      {
        name: "Local_part",
        symbols: ["Dot_string"],
        postprocess: function(i) {
          return { DotString: r(i[0]) };
        }
      },
      {
        name: "Local_part",
        symbols: ["Quoted_string"],
        postprocess: function(i) {
          return { QuotedString: r(i[0]) };
        }
      },
      { name: "Dot_string$ebnf$1", symbols: [] },
      { name: "Dot_string$ebnf$1$subexpression$1", symbols: [{ literal: "." }, "Atom"] },
      { name: "Dot_string$ebnf$1", symbols: ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Dot_string", symbols: ["Atom", "Dot_string$ebnf$1"] },
      { name: "Atom$ebnf$1", symbols: [/[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/] },
      { name: "Atom$ebnf$1", symbols: ["Atom$ebnf$1", /[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Atom", symbols: ["Atom$ebnf$1"] },
      { name: "Quoted_string$ebnf$1", symbols: [] },
      { name: "Quoted_string$ebnf$1", symbols: ["Quoted_string$ebnf$1", "QcontentSMTP"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Quoted_string", symbols: ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },
      { name: "QcontentSMTP", symbols: ["qtextSMTP"] },
      { name: "QcontentSMTP", symbols: ["quoted_pairSMTP"] },
      { name: "quoted_pairSMTP", symbols: [{ literal: "\\" }, /[\x20-\x7e]/] },
      { name: "qtextSMTP", symbols: [/[\x20-\x21\x23-\x5b\x5d-\x7e\u0080-\uFFFF]/], postprocess: t },
      { name: "IPv4_address_literal$macrocall$2", symbols: [{ literal: "." }, "Snum"] },
      { name: "IPv4_address_literal$macrocall$1", symbols: ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },
      { name: "IPv4_address_literal", symbols: ["Snum", "IPv4_address_literal$macrocall$1"] },
      { name: "IPv6_address_literal$subexpression$1", symbols: [/[iI]/, /[pP]/, /[vV]/, { literal: "6" }, { literal: ":" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "IPv6_address_literal", symbols: ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },
      { name: "General_address_literal$ebnf$1", symbols: ["dcontent"] },
      { name: "General_address_literal$ebnf$1", symbols: ["General_address_literal$ebnf$1", "dcontent"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "General_address_literal", symbols: ["Standardized_tag", { literal: ":" }, "General_address_literal$ebnf$1"] },
      { name: "Standardized_tag", symbols: ["Ldh_str"] },
      { name: "dcontent", symbols: [/[\x21-\x5a\x5e-\x7e]/], postprocess: t },
      { name: "Snum", symbols: ["DIGIT"] },
      { name: "Snum$subexpression$1", symbols: [/[1-9]/, "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$1"] },
      { name: "Snum$subexpression$2", symbols: [{ literal: "1" }, "DIGIT", "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$2"] },
      { name: "Snum$subexpression$3", symbols: [{ literal: "2" }, /[0-4]/, "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$3"] },
      { name: "Snum$subexpression$4", symbols: [{ literal: "2" }, { literal: "5" }, /[0-5]/] },
      { name: "Snum", symbols: ["Snum$subexpression$4"] },
      { name: "IPv6_addr", symbols: ["IPv6_full"] },
      { name: "IPv6_addr", symbols: ["IPv6_comp"] },
      { name: "IPv6_addr", symbols: ["IPv6v4_full"] },
      { name: "IPv6_addr", symbols: ["IPv6v4_comp"] },
      { name: "IPv6_hex", symbols: ["HEXDIG"] },
      { name: "IPv6_hex$subexpression$1", symbols: ["HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$1"] },
      { name: "IPv6_hex$subexpression$2", symbols: ["HEXDIG", "HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$2"] },
      { name: "IPv6_hex$subexpression$3", symbols: ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$3"] },
      { name: "IPv6_full$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_full$macrocall$1", symbols: ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },
      { name: "IPv6_full", symbols: ["IPv6_hex", "IPv6_full$macrocall$1"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", symbols: ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1", symbols: ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },
      { name: "IPv6_comp$ebnf$1", symbols: ["IPv6_comp$ebnf$1$subexpression$1"], postprocess: t },
      { name: "IPv6_comp$ebnf$1", symbols: [], postprocess: () => null },
      { name: "IPv6_comp$string$1", symbols: [{ literal: ":" }, { literal: ":" }], postprocess: (i) => i.join("") },
      { name: "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", symbols: ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },
      { name: "IPv6_comp$ebnf$2$subexpression$1", symbols: ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },
      { name: "IPv6_comp$ebnf$2", symbols: ["IPv6_comp$ebnf$2$subexpression$1"], postprocess: t },
      { name: "IPv6_comp$ebnf$2", symbols: [], postprocess: () => null },
      { name: "IPv6_comp", symbols: ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },
      { name: "IPv6v4_full$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_full$macrocall$1", symbols: ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },
      { name: "IPv6v4_full", symbols: ["IPv6_hex", "IPv6v4_full$macrocall$1", { literal: ":" }, "IPv4_address_literal"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", symbols: ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1", symbols: ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },
      { name: "IPv6v4_comp$ebnf$1", symbols: ["IPv6v4_comp$ebnf$1$subexpression$1"], postprocess: t },
      { name: "IPv6v4_comp$ebnf$1", symbols: [], postprocess: () => null },
      { name: "IPv6v4_comp$string$1", symbols: [{ literal: ":" }, { literal: ":" }], postprocess: (i) => i.join("") },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", symbols: ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1", symbols: ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { literal: ":" }] },
      { name: "IPv6v4_comp$ebnf$2", symbols: ["IPv6v4_comp$ebnf$2$subexpression$1"], postprocess: t },
      { name: "IPv6v4_comp$ebnf$2", symbols: [], postprocess: () => null },
      { name: "IPv6v4_comp", symbols: ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },
      { name: "DIGIT", symbols: [/[0-9]/], postprocess: t },
      { name: "ALPHA_DIGIT_U", symbols: [/[0-9A-Za-z\u0080-\uFFFF]/], postprocess: t },
      { name: "ALPHA_DIGIT", symbols: [/[0-9A-Za-z]/], postprocess: t },
      { name: "ALPHA_DIG_DASH", symbols: [/[-0-9A-Za-z]/], postprocess: t },
      { name: "ALPHA_DIG_DASH_U", symbols: [/[-0-9A-Za-z\u0080-\uFFFF]/], postprocess: t },
      { name: "HEXDIG", symbols: [/[0-9A-Fa-f]/], postprocess: t },
      { name: "DQUOTE", symbols: [{ literal: '"' }], postprocess: t }
    ],
    ParserStart: "Reverse_path"
  };
  return Xv.default = n, Xv;
}
var J8;
function mse() {
  if (J8) return _i;
  J8 = 1;
  var t = _i && _i.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  };
  Object.defineProperty(_i, "__esModule", { value: !0 }), _i.canonicalize = _i.canonicalize_quoted_string = _i.normalize = _i.normalize_dot_string = _i.parse = void 0;
  const e = dse(), r = t(pse());
  r.default.ParserStart = "Mailbox";
  const n = e.Grammar.fromCompiled(r.default);
  function i(u) {
    const c = new e.Parser(n);
    if (c.feed(u), c.results.length !== 1)
      throw new Error("address parsing failed: ambiguous grammar");
    return c.results[0];
  }
  _i.parse = i;
  function o(u) {
    return (function() {
      const c = u.indexOf("+");
      return c === -1 ? u : u.substr(0, c);
    })().replace(/\./g, "").toLowerCase();
  }
  _i.normalize_dot_string = o;
  function s(u) {
    var c, h;
    const d = i(u), p = (c = d.domainPart.AddressLiteral) !== null && c !== void 0 ? c : d.domainPart.DomainName.toLowerCase();
    return `${(h = d.localPart.QuotedString) !== null && h !== void 0 ? h : o(d.localPart.DotString)}@${p}`;
  }
  _i.normalize = s;
  function a(u) {
    return `"${u.substr(1).substr(0, u.length - 2).replace(/(?:\\(.))/g, "$1").replace(/(?:(["\\]))/g, "\\$1")}"`;
  }
  _i.canonicalize_quoted_string = a;
  function l(u) {
    var c;
    const h = i(u), d = (c = h.domainPart.AddressLiteral) !== null && c !== void 0 ? c : h.domainPart.DomainName.toLowerCase();
    return `${h.localPart.QuotedString ? a(h.localPart.QuotedString) : h.localPart.DotString}@${d}`;
  }
  return _i.canonicalize = l, _i;
}
var gse = mse();
const vse = new RegExp("^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$"), yse = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, bse = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, xse = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/, wse = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, kse = /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Cse = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], _se = /^(?:\/(?:[^~/]|~0|~1)*)*$/, Sse = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, Ase = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, Ese = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, mN = {
  date: (t, e, r, n) => {
    if (typeof r != "string" || r === "")
      return;
    const i = r.match(wse);
    if (!i)
      return t.errors.formatDateTimeError({ value: r, pointer: n, schema: e });
    const o = +i[1], s = +i[2], a = +i[3], l = o % 4 === 0 && (o % 100 !== 0 || o % 400 === 0);
    if (!(s >= 1 && s <= 12 && a >= 1 && a <= (s == 2 && l ? 29 : Cse[s])))
      return t.errors.formatDateError({ value: r, pointer: n, schema: e });
  },
  "date-time": (t, e, r, n) => {
    if (!(typeof r != "string" || r === ""))
      return r === "" || vse.test(r) ? new Date(r).toString() === "Invalid Date" ? t.errors.formatDateTimeError({ value: r, pointer: n, schema: e }) : void 0 : t.errors.formatDateTimeError({ value: r, pointer: n, schema: e });
  },
  email: (t, e, r, n) => {
    if (typeof r != "string" || r === "")
      return;
    if (r[0] === '"')
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    const [i, o, ...s] = r.split("@");
    if (!i || !o || s.length !== 0 || i.length > 64 || o.length > 253)
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    if (i[0] === "." || i.endsWith(".") || i.includes(".."))
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    if (!/^[a-z0-9.-]+$/i.test(o) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(i))
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    if (!o.split(".").every((a) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(a)))
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
  },
  /**
   * @draft 7
   * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531
   */
  "idn-email": (t, e, r, n) => {
    if (!(typeof r != "string" || r === ""))
      try {
        gse.parse(r);
        return;
      } catch {
        return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
      }
  },
  hostname: (t, e, r, n) => {
    if (typeof r == "string" && !(r === "" || xse.test(r)))
      return t.errors.formatHostnameError({ value: r, pointer: n, schema: e });
  },
  ipv4: (t, e, r, n) => {
    if (!(typeof r != "string" || r === "")) {
      if (r && r[0] === "0")
        return t.errors.formatIPV4LeadingZeroError({ value: r, pointer: n, schema: e });
      if (!(r.length <= 15 && yse.test(r)))
        return t.errors.formatIPV4Error({ value: r, pointer: n, schema: e });
    }
  },
  ipv6: (t, e, r, n) => {
    if (!(typeof r != "string" || r === "")) {
      if (r && r[0] === "0")
        return t.errors.formatIPV6LeadingZeroError({ value: r, pointer: n, schema: e });
      if (!(r.length <= 45 && bse.test(r)))
        return t.errors.formatIPV6Error({ value: r, pointer: n, schema: e });
    }
  },
  "json-pointer": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !_se.test(r))
      return t.errors.formatJsonPointerError({ value: r, pointer: n, schema: e });
  },
  "relative-json-pointer": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !Sse.test(r))
      return t.errors.formatJsonPointerError({ value: r, pointer: n, schema: e });
  },
  regex: (t, e, r, n) => {
    if (typeof r == "string" && /\\Z$/.test(r) === !1) {
      try {
        new RegExp(r);
        return;
      } catch {
      }
      return t.errors.formatRegExError({ value: r, pointer: n, schema: e });
    }
    if (!(typeof r == "object" || typeof r == "number" || Array.isArray(r)))
      return t.errors.formatRegExError({ value: r, pointer: n, schema: e });
  },
  // hh:mm:ss.sTZD
  // https://opis.io/json-schema/2.x/formats.html
  // regex https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html
  time: (t, e, r, n) => typeof r != "string" || r === "" || r.match(kse) ? void 0 : t.errors.formatDateTimeError({ value: r, pointer: n, schema: e }),
  uri: (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !K8.isUri(r))
      return t.errors.formatURIError({ value: r, pointer: n, schema: e });
  },
  "uri-reference": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !Ase.test(r))
      return t.errors.formatURIReferenceError({ value: r, pointer: n, schema: e });
  },
  "uri-template": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !Ese.test(r))
      return t.errors.formatURITemplateError({ value: r, pointer: n, schema: e });
  },
  url: (t, e, r, n) => {
    if (!(r === "" || K8.isWebUri(r)))
      return t.errors.formatURLError({ value: r, pointer: n, schema: e });
  }
}, gN = {};
function vN(t, e = gN) {
  const { pointer: r = "#", data: n, schema: i = t.rootSchema, withSchemaWarning: o = !1 } = e, s = gg.split(r), a = yN(t, t.resolveRef(i), s, "#", n);
  if (!(!o && a?.code === "schema-warning"))
    return a;
}
function yN(t, e, r, n, i = gN) {
  if (r.length === 0)
    return t.resolveRef(e);
  const o = r.shift();
  return e = t.step(o, e, i, n), gi(e) ? e : (i = i[o], yN(t, e, r, `${n}/${o}`, i));
}
function Dse(t) {
  switch (er(t)) {
    case "string":
    case "array":
      return t?.length === 0;
    case "null":
    case "undefined":
      return !0;
    case "object":
      return Object.keys(t).length === 0;
    default:
      return !1;
  }
}
const Y8 = ep.templateDefaultOptions;
let $l;
function K2(t, e) {
  const { $ref: r } = t;
  return r == null ? !0 : ($l[e] == null || $l[e][r] == null ? 0 : $l[e][r]) < ep.GET_TEMPLATE_RECURSION_LIMIT;
}
function Z8(t, e, r) {
  const { $ref: n } = e;
  return n == null ? e : ($l[r] = $l[r] || {}, $l[r][n] = $l[r][n] || 0, $l[r][n] += 1, t.resolveRef(e));
}
function Ose(t, e) {
  if (t === "string")
    return JSON.stringify(e);
  if (typeof e != "string")
    return null;
  try {
    if (e = JSON.parse(e), typeof e === t)
      return e;
  } catch {
  }
  return null;
}
function bN(t, e, r, n, i) {
  if (er(e) !== "object")
    return Object.assign({ pointer: n }, e);
  if (K2(e, n) === !1 && r == null)
    return !1;
  let o = T1(Z8(t, e, n));
  if (Array.isArray(e.anyOf) && e.anyOf.length > 0) {
    if (K2(e.anyOf[0], `${n}/anyOf/0`)) {
      const s = Z8(t, e.anyOf[0], `${n}/anyOf/0`);
      o = j4(o, s), o.pointer = e.anyOf[0].$ref || o.pointer;
    }
    delete o.anyOf;
  }
  if (Array.isArray(e.allOf) && e.allOf.map((s, a) => K2(s, `${n}/allOf/${a}`)).reduceRight((s, a) => s && a, !0)) {
    const s = [];
    let a = T1(r);
    for (let u = 0; u < e.allOf.length; u += 1)
      s.push(rN(t, e.allOf[u], a)), a = Ns(t, a, { type: e.type, ...s[u] }, `${n}/allOf/${u}`, i);
    const l = iN(t, { allOf: s });
    l && (o = Fi(o, l));
  }
  return o.pointer = o.pointer || e.$ref || n, o;
}
const e7 = (t) => t && typeof t == "object";
function Ns(t, e, r, n, i) {
  var o;
  if (r == null)
    throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(e)}`);
  if (n == null)
    throw new Error("Missing pointer");
  let s = bN(t, r, e, n, i);
  if (!e7(s))
    return;
  if (n = s.pointer, s?.const)
    return s.const;
  if (Array.isArray(s.oneOf))
    if (Dse(e)) {
      const u = s.oneOf[0].type || s.type || s.const && typeof s.const || er(e);
      s = { ...s.oneOf[0], type: u };
    } else {
      const u = z4(t, e, s);
      if (gi(u)) {
        if (e != null && i.removeInvalidData !== !0)
          return e;
        s = s.oneOf[0], e = void 0;
      } else
        u.type = (o = u.type) !== null && o !== void 0 ? o : s.type, s = u;
    }
  if (!e7(s) || s.type == null)
    return;
  if (e instanceof File)
    return e;
  const a = Array.isArray(s.type) ? Fse(s.type, e, s.default) : s.type, l = er(e);
  return e != null && l !== a && !(l === "number" && a === "integer") && (e = Ose(a, e)), t7[a] == null ? i.removeInvalidData ? void 0 : e : t7[a](t, s, e, n, i);
}
function Fse(t, e, r) {
  if (e == null) {
    if (r != null) {
      const i = er(r);
      if (t.includes(i))
        return i;
    }
    return t[0];
  }
  const n = er(e);
  return t.includes(n) ? n : t[0];
}
const t7 = {
  null: (t, e, r) => Zp(e, r, null),
  string: (t, e, r) => Zp(e, r, ""),
  number: (t, e, r) => Zp(e, r, 0),
  integer: (t, e, r) => Zp(e, r, 0),
  boolean: (t, e, r) => Zp(e, r, !1),
  object: (t, e, r, n, i) => {
    var o;
    const s = e.default === void 0 ? {} : e.default, a = {}, l = i.extendDefaults === !1 && e.default !== void 0 ? [] : (o = e.required) !== null && o !== void 0 ? o : [];
    e.properties && Object.keys(e.properties).forEach((h) => {
      const d = r == null || r[h] == null ? s[h] : r[h], p = l.includes(h);
      (d != null || p || i.addOptionalProps) && (a[h] = Ns(t, d, e.properties[h], `${n}/properties/${h}`, i));
    });
    let u = sN(t, e, a);
    if (u) {
      u = Fi(e, u), delete u.dependencies;
      const h = Ns(t, r, u, `${n}/dependencies`, i);
      Object.assign(a, h);
    }
    r && (i.removeInvalidData === !0 && (e.additionalProperties === !1 || er(e.additionalProperties) === "object") ? er(e.additionalProperties) === "object" && Object.keys(r).forEach((h) => {
      a[h] == null && t.isValid(r[h], e.additionalProperties) && (a[h] = r[h]);
    }) : Object.keys(r).forEach((h) => a[h] == null && (a[h] = r[h])));
    const c = Wb(t, e, a);
    if (c) {
      const h = Ns(t, a, { type: "object", ...c }, n, i);
      Object.assign(a, h);
    }
    return a;
  },
  // build array type of items, ignores additionalItems
  array: (t, e, r, n, i) => {
    var o, s;
    if (e.items == null)
      return r || [];
    const a = e.default === void 0 ? [] : e.default, l = r || a, u = i.extendDefaults === !1 && e.default !== void 0 ? 0 : e.minItems || 0;
    if (Array.isArray(e.items)) {
      for (let h = 0, d = Math.max(u ?? 0, (s = (o = e.items) === null || o === void 0 ? void 0 : o.length) !== null && s !== void 0 ? s : 0); h < d; h += 1)
        l[h] = Ns(t, l[h] == null ? a[h] : l[h], e.items[h], `${n}/items/${h}`, i);
      return l;
    }
    if (er(e.items) !== "object")
      return l;
    const c = bN(t, e.items, r, n, i);
    if (c === !1)
      return l;
    if (n = c.pointer || n, c.oneOf && l.length === 0) {
      const h = c.oneOf[0];
      for (let d = 0; d < u; d += 1)
        l[d] = Ns(t, l[d] == null ? a[d] : l[d], h, `${n}/oneOf/0`, i);
      return l;
    }
    if (c.oneOf && l.length > 0) {
      const h = Math.max(u, l.length);
      for (let d = 0; d < h; d += 1) {
        let p = l[d] == null ? a[d] : l[d], g = z4(t, p, c);
        g == null || gi(g) ? p != null && i.removeInvalidData !== !0 ? l[d] = p : (p = void 0, g = c.oneOf[0], l[d] = Ns(t, p, g, `${n}/oneOf/${d}`, i)) : l[d] = Ns(t, p, g, `${n}/oneOf/${d}`, i);
      }
      return l;
    }
    if (c.type) {
      for (let h = 0, d = Math.max(u, l.length); h < d; h += 1)
        l[h] = Ns(t, l[h] == null ? a[h] : l[h], c, `${n}/items`, i);
      return l;
    }
    return l;
  }
};
function Zp(t, e, r) {
  return e ?? (t.const ? t.const : t.default === void 0 && Array.isArray(t.enum) ? t.enum[0] : t.default === void 0 ? r : t.default);
}
const xN = (t, e, r = t.rootSchema, n) => ($l = {}, n ? Ns(t, e, r, "#", { ...Y8, ...n }) : Ns(t, e, r, "#", Y8));
function wN(t, e, r = t.rootSchema, n = "#") {
  return t.validate(e, r, n).length === 0;
}
function r7(t) {
  const e = [];
  let r = 0;
  const n = t.length;
  for (; r < n; ) {
    const i = t.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      const o = t.charCodeAt(r++);
      (o & 64512) == 56320 ? e.push(((i & 1023) << 10) + (o & 1023) + 65536) : (e.push(i), r--);
    } else
      e.push(i);
  }
  return e;
}
function n7(t) {
  const e = `${t}`, r = e.indexOf(".");
  return r === -1 ? 0 : e.length - (r + 1);
}
var i7, o7;
function Tse() {
  return o7 || (o7 = 1, i7 = function t(e, r) {
    if (e === r) return !0;
    if (e && r && typeof e == "object" && typeof r == "object") {
      if (e.constructor !== r.constructor) return !1;
      var n, i, o;
      if (Array.isArray(e)) {
        if (n = e.length, n != r.length) return !1;
        for (i = n; i-- !== 0; )
          if (!t(e[i], r[i])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === r.source && e.flags === r.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === r.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === r.toString();
      if (o = Object.keys(e), n = o.length, n !== Object.keys(r).length) return !1;
      for (i = n; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, o[i])) return !1;
      for (i = n; i-- !== 0; ) {
        var s = o[i];
        if (!t(e[s], r[s])) return !1;
      }
      return !0;
    }
    return e !== e && r !== r;
  }), i7;
}
var Mse = Tse();
const kN = /* @__PURE__ */ Lh(Mse), Pse = Object.prototype.hasOwnProperty, s7 = (t, e) => !(t[e] === void 0 || !Pse.call(t, e)), CN = {
  additionalProperties: (t, e, r, n) => {
    if (e.additionalProperties === !0 || e.additionalProperties == null || er(e.patternProperties) === "object" && e.additionalProperties === !1)
      return;
    const i = [];
    let o = Object.keys(r).filter((a) => ep.propertyBlacklist.includes(a) === !1);
    const s = Object.keys(e.properties || {});
    if (er(e.patternProperties) === "object") {
      const a = Object.keys(e.patternProperties).map((l) => new RegExp(l));
      o = o.filter((l) => {
        for (let u = 0; u < a.length; u += 1)
          if (a[u].test(l))
            return !1;
        return !0;
      });
    }
    for (let a = 0, l = o.length; a < l; a += 1) {
      const u = o[a];
      if (s.indexOf(u) === -1) {
        const c = Vu(e.additionalProperties);
        if (c && Array.isArray(e.additionalProperties.oneOf)) {
          const h = t.resolveOneOf(r[u], e.additionalProperties, `${n}/${u}`);
          gi(h) ? i.push(t.errors.additionalPropertiesError({
            pointer: n,
            schema: e.additionalProperties,
            value: r,
            property: o[a],
            properties: s,
            // pass all validation errors
            errors: h.data.errors
          })) : i.push(...t.validate(r[u], h, n));
        } else c ? i.push(...t.validate(r[u], e.additionalProperties, `${n}/${u}`)) : i.push(t.errors.noAdditionalPropertiesError({
          pointer: n,
          schema: e,
          value: r,
          property: o[a],
          properties: s
        }));
      }
    }
    return i;
  },
  allOf: boe,
  anyOf: koe,
  dependencies: woe,
  enum: (t, e, r, n) => {
    const i = er(r);
    if (i === "object" || i === "array") {
      const o = JSON.stringify(r);
      for (let s = 0; s < e.enum.length; s += 1)
        if (JSON.stringify(e.enum[s]) === o)
          return;
    } else if (e.enum.includes(r))
      return;
    return t.errors.enumError({ pointer: n, schema: e, value: r, values: e.enum });
  },
  format: (t, e, r, n) => {
    if (t.validateFormat[e.format])
      return t.validateFormat[e.format](t, e, r, n);
  },
  items: (t, e, r, n) => {
    if (e.items === !1)
      return Array.isArray(r) && r.length === 0 ? void 0 : t.errors.invalidDataError({ pointer: n, value: r, schema: e });
    const i = [];
    for (let o = 0; o < r.length; o += 1) {
      const s = r[o], a = t.step(o, e, r, n);
      if (gi(a))
        return [a];
      const l = t.validate(s, a, `${n}/${o}`);
      i.push(...l);
    }
    return i;
  },
  maximum: (t, e, r, n) => {
    if (!isNaN(e.maximum)) {
      if (e.maximum && e.maximum < r)
        return t.errors.maximumError({
          maximum: e.maximum,
          length: r,
          value: r,
          pointer: n,
          schema: e
        });
      if (e.maximum && e.exclusiveMaximum === !0 && e.maximum === r)
        return t.errors.maximumError({
          maximum: e.maximum,
          length: r,
          pointer: n,
          schema: e,
          value: r
        });
    }
  },
  maxItems: (t, e, r, n) => {
    if (!isNaN(e.maxItems) && e.maxItems < r.length)
      return t.errors.maxItemsError({
        maximum: e.maxItems,
        length: r.length,
        schema: e,
        value: r,
        pointer: n
      });
  },
  maxLength: (t, e, r, n) => {
    if (isNaN(e.maxLength))
      return;
    const i = r7(r).length;
    if (e.maxLength < i)
      return t.errors.maxLengthError({
        maxLength: e.maxLength,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  maxProperties: (t, e, r, n) => {
    const i = Object.keys(r).length;
    if (isNaN(e.maxProperties) === !1 && e.maxProperties < i)
      return t.errors.maxPropertiesError({
        maxProperties: e.maxProperties,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minLength: (t, e, r, n) => {
    if (isNaN(e.minLength))
      return;
    const i = r7(r).length;
    if (e.minLength > i)
      return e.minLength === 1 ? t.errors.minLengthOneError({
        minLength: e.minLength,
        length: i,
        pointer: n,
        schema: e,
        value: r
      }) : t.errors.minLengthError({
        minLength: e.minLength,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minimum: (t, e, r, n) => {
    if (!isNaN(e.minimum)) {
      if (e.minimum > r)
        return t.errors.minimumError({
          minimum: e.minimum,
          length: r,
          pointer: n,
          schema: e,
          value: r
        });
      if (e.exclusiveMinimum === !0 && e.minimum === r)
        return t.errors.minimumError({
          minimum: e.minimum,
          length: r,
          pointer: n,
          schema: e,
          value: r
        });
    }
  },
  minItems: (t, e, r, n) => {
    if (!isNaN(e.minItems) && e.minItems > r.length)
      return e.minItems === 1 ? t.errors.minItemsOneError({
        minItems: e.minItems,
        length: r.length,
        pointer: n,
        schema: e,
        value: r
      }) : t.errors.minItemsError({
        minItems: e.minItems,
        length: r.length,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minProperties: (t, e, r, n) => {
    if (isNaN(e.minProperties))
      return;
    const i = Object.keys(r).length;
    if (e.minProperties > i)
      return t.errors.minPropertiesError({
        minProperties: e.minProperties,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  multipleOf: (t, e, r, n) => {
    if (isNaN(e.multipleOf) || typeof r != "number")
      return;
    const i = n7(r), o = n7(e.multipleOf);
    if (i > o)
      return t.errors.multipleOfError({
        multipleOf: e.multipleOf,
        value: r,
        pointer: n,
        schema: e
      });
    const s = Math.pow(10, o), a = Math.round(r * s), l = Math.round(e.multipleOf * s);
    if (a % l / s !== 0)
      return t.errors.multipleOfError({
        multipleOf: e.multipleOf,
        value: r,
        pointer: n,
        schema: e
      });
  },
  not: (t, e, r, n) => {
    const i = [];
    return t.validate(r, e.not, n).length === 0 && i.push(t.errors.notError({ value: r, not: e.not, pointer: n, schema: e })), i;
  },
  oneOf: Pie,
  pattern: (t, e, r, n) => {
    if (new RegExp(e.pattern, "u").test(r) === !1)
      return t.errors.patternError({
        pattern: e.pattern,
        description: e.patternExample || e.pattern,
        received: r,
        schema: e,
        value: r,
        pointer: n
      });
  },
  patternProperties: (t, e, r, n) => {
    const i = e.properties || {}, o = e.patternProperties;
    if (er(o) !== "object")
      return;
    const s = [], a = Object.keys(r), l = Object.keys(o).map((u) => ({
      regex: new RegExp(u),
      patternSchema: o[u]
    }));
    return a.forEach((u) => {
      let c = !1;
      for (let h = 0, d = l.length; h < d; h += 1)
        if (l[h].regex.test(u)) {
          c = !0;
          const p = t.validate(r[u], l[h].patternSchema, `${n}/${u}`);
          p && p.length > 0 && s.push(...p);
        }
      i[u] || c === !1 && e.additionalProperties === !1 && s.push(t.errors.patternPropertiesError({
        key: u,
        pointer: n,
        schema: e,
        value: r,
        patterns: Object.keys(o).join(",")
      }));
    }), s;
  },
  properties: (t, e, r, n) => {
    const i = [], o = Object.keys(e.properties || {});
    for (let s = 0; s < o.length; s += 1) {
      const a = o[s];
      if (s7(r, a)) {
        const l = t.step(a, e, r, n), u = t.validate(r[a], l, `${n}/${a}`);
        i.push(...u);
      }
    }
    return i;
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword
  propertiesRequired: (t, e, r, n) => {
    const i = [], o = Object.keys(e.properties || {});
    for (let s = 0; s < o.length; s += 1) {
      const a = o[s];
      if (r[a] === void 0)
        i.push(t.errors.requiredPropertyError({ key: a, pointer: n, schema: e, value: r }));
      else {
        const l = t.step(a, e, r, n), u = t.validate(r[a], l, `${n}/${a}`);
        i.push(...u);
      }
    }
    return i;
  },
  required: (t, e, r, n) => {
    if (Array.isArray(e.required) !== !1)
      return e.required.map((i) => {
        if (!s7(r, i))
          return t.errors.requiredPropertyError({
            key: i,
            pointer: n,
            schema: e,
            value: r
          });
      });
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword
  requiredNotEmpty: (t, e, r, n) => {
    if (Array.isArray(e.required) !== !1)
      return e.required.map((i) => {
        if (r[i] == null || r[i] === "")
          return t.errors.valueNotEmptyError({
            property: i,
            pointer: `${n}/${i}`,
            schema: e,
            value: r
          });
      });
  },
  uniqueItems: (t, e, r, n) => {
    if ((Array.isArray(r) && e.uniqueItems) === !1)
      return;
    const i = [], o = [];
    return r.forEach((s, a) => {
      for (let l = a + 1; l < r.length; l += 1)
        kN(s, r[l]) && !i.includes(l) && (o.push(t.errors.uniqueItemsError({
          pointer: `${n}/${l}`,
          duplicatePointer: `${n}/${a}`,
          arrayPointer: n,
          value: JSON.stringify(s),
          schema: e
        })), i.push(l));
    }), o;
  }
};
function Da(t) {
  if (t === void 0)
    return;
  const e = {
    type: er(t)
  };
  return e.type === "object" && Vu(t) && (e.properties = {}, Object.keys(t).forEach((r) => e.properties[r] = Da(t[r]))), e.type === "array" && Array.isArray(t) && (t.length === 1 ? e.items = Da(t[0]) : e.items = t.map(Da)), e;
}
const Rse = {
  array: (t, e, r, n, i) => {
    const o = n?.[e], s = er(r.items);
    if (s === "object")
      return N8(t, r.items, o, `${i}/${e}`) || t.resolveRef(r.items);
    if (s === "array") {
      if (r.items[e] === !0)
        return Da(o);
      if (r.items[e] === !1)
        return t.errors.invalidDataError({
          key: e,
          value: o,
          pointer: i,
          schema: r
        });
      if (r.items[e])
        return t.resolveRef(r.items[e]);
      if (r.additionalItems === !1)
        return t.errors.additionalItemsError({
          key: e,
          value: o,
          pointer: i,
          schema: r
        });
      if (r.additionalItems === !0 || r.additionalItems === void 0)
        return Da(o);
      if (er(r.additionalItems) === "object")
        return r.additionalItems;
      throw new Error(`Invalid schema ${JSON.stringify(r, null, 2)} for ${JSON.stringify(n, null, 2)}`);
    }
    return r.additionalItems !== !1 && o ? Da(o) : new Error(`Invalid array schema for ${e} at ${i}`);
  },
  object: (t, e, r, n, i) => {
    var o;
    r = N8(t, r, n, i);
    const s = (o = r?.properties) === null || o === void 0 ? void 0 : o[e];
    if (s !== void 0) {
      if (s === !1)
        return t.errors.forbiddenPropertyError({
          property: e,
          value: n,
          pointer: i,
          schema: r
        });
      if (s === !0)
        return Da(n?.[e]);
      const u = t.resolveRef(s);
      if (gi(u))
        return u;
      if (u && Array.isArray(u.oneOf)) {
        const c = t.resolveOneOf(n[e], u, `${i}/${e}`);
        for (const h in u)
          h !== "oneOf" && c[h] === void 0 && (c[h] = u[h]);
        return c;
      }
      if (u)
        return u;
    }
    const { patternProperties: a } = r;
    if (er(a) === "object") {
      let u;
      const c = Object.keys(a);
      for (let h = 0, d = c.length; h < d; h += 1)
        if (u = new RegExp(c[h]), u.test(e))
          return a[c[h]];
    }
    const { additionalProperties: l } = r;
    return er(l) === "object" ? r.additionalProperties : n && (l === void 0 || l === !0) ? Da(n[e]) : t.errors.unknownPropertyError({
      property: e,
      value: n,
      pointer: `${i}`,
      schema: r
    });
  }
};
function _N(t, e, r, n, i = "#") {
  var o;
  const s = er(n);
  let a = (o = r.type) !== null && o !== void 0 ? o : s;
  if (Array.isArray(a)) {
    if (!a.includes(s))
      return t.errors.typeError({
        value: n,
        pointer: i,
        expected: r.type,
        received: s,
        schema: r
      });
    a = s;
  }
  const l = Rse[a];
  if (l) {
    const u = l(t, `${e}`, r, n, i);
    return u === void 0 ? t.errors.schemaWarning({
      pointer: i,
      value: n,
      schema: r,
      key: e
    }) : u;
  }
  return new Error(`Unsupported schema type ${r.type} for key ${e}`);
}
function SN(t, e, r = t.rootSchema) {
  var n;
  if (r.oneOf)
    return r.oneOf.map((o) => t.resolveRef(o));
  if (!((n = r.items) === null || n === void 0) && n.oneOf)
    return r.items.oneOf.map((o) => t.resolveRef(o));
  const i = t.step(e, r, {}, "#");
  return gi(i) ? i : [i];
}
const Nse = {
  array: (t, e, r, n) => t.typeKeywords.array.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  object: (t, e, r, n) => t.typeKeywords.object.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  string: (t, e, r, n) => t.typeKeywords.string.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  integer: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  number: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  boolean: (t, e, r, n) => t.typeKeywords.boolean.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  null: (t, e, r, n) => t.typeKeywords.null.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n))
};
function $se(t, e) {
  const r = er(t);
  return r === "number" && (e === "integer" || Array.isArray(e) && e.includes("integer")) ? Number.isInteger(t) || isNaN(t) ? "integer" : "number" : r;
}
function AN(t, e, r = t.rootSchema, n = "#") {
  if (r = t.resolveRef(r), er(r) === "boolean")
    return r ? [] : [t.errors.invalidDataError({ pointer: n, schema: r, value: e })];
  if (gi(r))
    return [r];
  if (r.const !== void 0)
    return kN(r.const, e) ? [] : [t.errors.constError({ pointer: n, schema: r, value: e, expected: r.const })];
  const i = $se(e, r.type), o = r.type || i;
  return i !== o && (!Array.isArray(o) || !o.includes(i)) ? [
    t.errors.typeError({
      pointer: n,
      schema: r,
      value: e,
      received: i,
      expected: o
    })
  ] : t.validateType[i] == null ? [t.errors.invalidTypeError({ pointer: n, schema: r, value: e, receivedType: i })] : pg(t.validateType[i](t, r, e, n)).filter(F1);
}
const Ise = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "enum",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],
    object: [
      "additionalProperties",
      "dependencies",
      "enum",
      "format",
      "minProperties",
      "maxProperties",
      "patternProperties",
      "properties",
      "required",
      "not",
      "oneOf",
      "allOf",
      "anyOf"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: CN,
  validateType: Nse,
  validateFormat: mN,
  errors: pN,
  addRemoteSchema: cN,
  compileSchema: use,
  createSchemaOf: Da,
  each: dN,
  eachSchema: Gb,
  getChildSchemaSelection: SN,
  getSchema: vN,
  getTemplate: xN,
  isValid: wN,
  resolveAllOf: nN,
  resolveAnyOf: lN,
  resolveOneOf: HR,
  resolveRef: oN,
  step: _N,
  validate: AN,
  templateDefaultOptions: ep.templateDefaultOptions
};
class EN extends uN {
  constructor(e, r = {}) {
    super(j4(Ise, r), e);
  }
}
const a7 = "__compiled", l7 = "__ref", Bse = "getRef", Lse = "getRoot", zse = /(#|\/)+$/g;
function jse(t, e, r = e, n = !1) {
  if (e === !0 || e === !1 || e === void 0 || e[a7] !== void 0)
    return e;
  const i = { ids: {}, remotes: t.remotes }, o = JSON.stringify(e), s = JSON.parse(o);
  if (Object.defineProperty(s, a7, { enumerable: !1, value: !0 }), Object.defineProperty(s, Bse, {
    enumerable: !1,
    value: Ol.bind(null, i, s)
  }), n === !1 && o.includes("$ref") === !1)
    return s;
  s !== r && Object.defineProperty(s, "$defs", {
    enumerable: !0,
    value: Object.assign({}, r.definitions, r.$defs, s.definitions, s.$defs)
  });
  const a = {}, l = () => s;
  return Gb(s, (u, c) => {
    var h;
    if (u.$id) {
      if (u.$id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(c)) {
        const y = c.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, ""), b = Hc.get(s, y);
        u.$id = (h = b.$id) !== null && h !== void 0 ? h : u.$id;
      }
      i.ids[u.$id.replace(zse, "")] = c;
    }
    c = `#${c}`.replace(/##+/, "#");
    const d = c.replace(/\/[^/]+$/, ""), p = c.replace(/\/[^/]+\/[^/]+$/, ""), g = a[d] || a[p], v = N1(g, u.$id);
    a[c] = v, i.ids[v] == null && (i.ids[v] = c), u.$ref && !u[l7] && (Object.defineProperty(u, l7, {
      enumerable: !1,
      value: N1(v, u.$ref)
    }), Object.defineProperty(u, Lse, { enumerable: !1, value: l }));
  }), s;
}
const qse = {
  ...CN,
  // @draft >= 6
  contains: (t, e, r, n) => {
    if (e.contains === !1)
      return t.errors.containsArrayError({ pointer: n, value: r, schema: e });
    if (e.contains === !0)
      return Array.isArray(r) && r.length === 0 ? t.errors.containsAnyError({ pointer: n, value: r, schema: e }) : void 0;
    if (er(e.contains) === "object") {
      for (let i = 0; i < r.length; i += 1)
        if (t.isValid(r[i], e.contains))
          return;
      return t.errors.containsError({ pointer: n, schema: e, value: r });
    }
  },
  exclusiveMaximum: (t, e, r, n) => {
    if (!isNaN(e.exclusiveMaximum) && e.exclusiveMaximum <= r)
      return t.errors.maximumError({
        maximum: e.exclusiveMaximum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  exclusiveMinimum: (t, e, r, n) => {
    if (!isNaN(e.exclusiveMinimum) && e.exclusiveMinimum >= r)
      return t.errors.minimumError({
        minimum: e.exclusiveMinimum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  // @feature if-then-else
  if: yoe,
  maximum: (t, e, r, n) => {
    if (!isNaN(e.maximum) && e.maximum && e.maximum < r)
      return t.errors.maximumError({
        maximum: e.maximum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minimum: (t, e, r, n) => {
    if (!isNaN(e.minimum) && e.minimum > r)
      return t.errors.minimumError({
        minimum: e.minimum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  patternProperties: (t, e, r, n) => {
    const i = e.properties || {}, o = e.patternProperties;
    if (er(o) !== "object")
      return;
    const s = [], a = Object.keys(r), l = Object.keys(o).map((u) => ({
      regex: new RegExp(u),
      patternSchema: o[u]
    }));
    return a.forEach((u) => {
      let c = !1;
      for (let h = 0, d = l.length; h < d; h += 1)
        if (l[h].regex.test(u)) {
          if (c = !0, l[h].patternSchema === !1) {
            s.push(t.errors.patternPropertiesError({
              key: u,
              pointer: n,
              patterns: Object.keys(o).join(","),
              schema: e,
              value: r
            }));
            return;
          }
          const p = t.validate(r[u], l[h].patternSchema, `${n}/${u}`);
          p && p.length > 0 && s.push(...p);
        }
      i[u] || c === !1 && e.additionalProperties === !1 && s.push(t.errors.patternPropertiesError({
        key: u,
        pointer: n,
        patterns: Object.keys(o).join(","),
        schema: e,
        value: r
      }));
    }), s;
  },
  // @draft >= 6
  propertyNames: (t, e, r, n) => {
    if (e.propertyNames === !1)
      return Object.keys(r).length === 0 ? void 0 : t.errors.invalidPropertyNameError({
        property: Object.keys(r),
        pointer: n,
        value: r,
        schema: e
      });
    if (e.propertyNames === !0 || er(e.propertyNames) !== "object")
      return;
    const i = [], o = Object.keys(r), s = { ...e.propertyNames, type: "string" };
    return o.forEach((a) => {
      const l = t.validate(a, s, `${n}/${a}`);
      l.length > 0 && i.push(t.errors.invalidPropertyNameError({
        property: a,
        pointer: n,
        validationError: l[0],
        value: r[a],
        schema: e
      }));
    }), i;
  }
}, Use = {
  array: (t, e, r, n) => t.typeKeywords.array.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  object: (t, e, r, n) => t.typeKeywords.object.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  string: (t, e, r, n) => t.typeKeywords.string.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  integer: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  number: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  boolean: (t, e, r, n) => t.typeKeywords.boolean.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  null: (t, e, r, n) => t.typeKeywords.null.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n))
}, DN = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: qse,
  validateType: Use,
  validateFormat: mN,
  errors: pN,
  addRemoteSchema: cN,
  compileSchema: jse,
  createSchemaOf: Da,
  each: dN,
  eachSchema: Gb,
  getChildSchemaSelection: SN,
  getSchema: vN,
  getTemplate: xN,
  isValid: wN,
  resolveAllOf: nN,
  resolveAnyOf: lN,
  resolveOneOf: HR,
  resolveRef: oN,
  step: _N,
  validate: AN,
  templateDefaultOptions: ep.templateDefaultOptions
};
class ON extends uN {
  constructor(e, r = {}) {
    super(j4(DN, r), e);
  }
}
({
  ...DN
});
function Ca(t, e, r = []) {
  const n = document.createElement(t);
  return Object.entries(e).forEach(([i, o]) => {
    if (i === "text") {
      n.innerText = o;
      return;
    }
    if (i === "inner") {
      n.innerHTML = o;
      return;
    }
    n.setAttribute(i, o);
  }), r.forEach((i) => n.appendChild(i)), n;
}
const u7 = {};
function Hse(t) {
  let e = u7[t];
  if (e)
    return e;
  e = u7[t] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    e.push(n);
  }
  for (let r = 0; r < t.length; r++) {
    const n = t.charCodeAt(r);
    e[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2);
  }
  return e;
}
function Dd(t, e) {
  typeof e != "string" && (e = Dd.defaultChars);
  const r = Hse(e);
  return t.replace(/(%[a-f0-9]{2})+/gi, function(n) {
    let i = "";
    for (let o = 0, s = n.length; o < s; o += 3) {
      const a = parseInt(n.slice(o + 1, o + 3), 16);
      if (a < 128) {
        i += r[a];
        continue;
      }
      if ((a & 224) === 192 && o + 3 < s) {
        const l = parseInt(n.slice(o + 4, o + 6), 16);
        if ((l & 192) === 128) {
          const u = a << 6 & 1984 | l & 63;
          u < 128 ? i += "ï¿½ï¿½" : i += String.fromCharCode(u), o += 3;
          continue;
        }
      }
      if ((a & 240) === 224 && o + 6 < s) {
        const l = parseInt(n.slice(o + 4, o + 6), 16), u = parseInt(n.slice(o + 7, o + 9), 16);
        if ((l & 192) === 128 && (u & 192) === 128) {
          const c = a << 12 & 61440 | l << 6 & 4032 | u & 63;
          c < 2048 || c >= 55296 && c <= 57343 ? i += "ï¿½ï¿½ï¿½" : i += String.fromCharCode(c), o += 6;
          continue;
        }
      }
      if ((a & 248) === 240 && o + 9 < s) {
        const l = parseInt(n.slice(o + 4, o + 6), 16), u = parseInt(n.slice(o + 7, o + 9), 16), c = parseInt(n.slice(o + 10, o + 12), 16);
        if ((l & 192) === 128 && (u & 192) === 128 && (c & 192) === 128) {
          let h = a << 18 & 1835008 | l << 12 & 258048 | u << 6 & 4032 | c & 63;
          h < 65536 || h > 1114111 ? i += "ï¿½ï¿½ï¿½ï¿½" : (h -= 65536, i += String.fromCharCode(55296 + (h >> 10), 56320 + (h & 1023))), o += 9;
          continue;
        }
      }
      i += "ï¿½";
    }
    return i;
  });
}
Dd.defaultChars = ";/?:@&=+$,#";
Dd.componentChars = "";
const c7 = {};
function Vse(t) {
  let e = c7[t];
  if (e)
    return e;
  e = c7[t] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    /^[0-9a-z]$/i.test(n) ? e.push(n) : e.push("%" + ("0" + r.toString(16).toUpperCase()).slice(-2));
  }
  for (let r = 0; r < t.length; r++)
    e[t.charCodeAt(r)] = t[r];
  return e;
}
function o0(t, e, r) {
  typeof e != "string" && (r = e, e = o0.defaultChars), typeof r > "u" && (r = !0);
  const n = Vse(e);
  let i = "";
  for (let o = 0, s = t.length; o < s; o++) {
    const a = t.charCodeAt(o);
    if (r && a === 37 && o + 2 < s && /^[0-9a-f]{2}$/i.test(t.slice(o + 1, o + 3))) {
      i += t.slice(o, o + 3), o += 2;
      continue;
    }
    if (a < 128) {
      i += n[a];
      continue;
    }
    if (a >= 55296 && a <= 57343) {
      if (a >= 55296 && a <= 56319 && o + 1 < s) {
        const l = t.charCodeAt(o + 1);
        if (l >= 56320 && l <= 57343) {
          i += encodeURIComponent(t[o] + t[o + 1]), o++;
          continue;
        }
      }
      i += "%EF%BF%BD";
      continue;
    }
    i += encodeURIComponent(t[o]);
  }
  return i;
}
o0.defaultChars = ";/?:@&=+$,-_.!~*'()#";
o0.componentChars = "-_.!~*'()";
function W4(t) {
  let e = "";
  return e += t.protocol || "", e += t.slashes ? "//" : "", e += t.auth ? t.auth + "@" : "", t.hostname && t.hostname.indexOf(":") !== -1 ? e += "[" + t.hostname + "]" : e += t.hostname || "", e += t.port ? ":" + t.port : "", e += t.pathname || "", e += t.search || "", e += t.hash || "", e;
}
function $1() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const Wse = /^([a-z0-9.+-]+:)/i, Gse = /:[0-9]*$/, Kse = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Qse = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Xse = ["{", "}", "|", "\\", "^", "`"].concat(Qse), Jse = ["'"].concat(Xse), h7 = ["%", "/", "?", ";", "#"].concat(Jse), f7 = ["/", "?", "#"], Yse = 255, d7 = /^[+a-z0-9A-Z_-]{0,63}$/, Zse = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, p7 = {
  javascript: !0,
  "javascript:": !0
}, m7 = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function G4(t, e) {
  if (t && t instanceof $1) return t;
  const r = new $1();
  return r.parse(t, e), r;
}
$1.prototype.parse = function(t, e) {
  let r, n, i, o = t;
  if (o = o.trim(), !e && t.split("#").length === 1) {
    const u = Kse.exec(o);
    if (u)
      return this.pathname = u[1], u[2] && (this.search = u[2]), this;
  }
  let s = Wse.exec(o);
  if (s && (s = s[0], r = s.toLowerCase(), this.protocol = s, o = o.substr(s.length)), (e || s || o.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = o.substr(0, 2) === "//", i && !(s && p7[s]) && (o = o.substr(2), this.slashes = !0)), !p7[s] && (i || s && !m7[s])) {
    let u = -1;
    for (let g = 0; g < f7.length; g++)
      n = o.indexOf(f7[g]), n !== -1 && (u === -1 || n < u) && (u = n);
    let c, h;
    u === -1 ? h = o.lastIndexOf("@") : h = o.lastIndexOf("@", u), h !== -1 && (c = o.slice(0, h), o = o.slice(h + 1), this.auth = c), u = -1;
    for (let g = 0; g < h7.length; g++)
      n = o.indexOf(h7[g]), n !== -1 && (u === -1 || n < u) && (u = n);
    u === -1 && (u = o.length), o[u - 1] === ":" && u--;
    const d = o.slice(0, u);
    o = o.slice(u), this.parseHost(d), this.hostname = this.hostname || "";
    const p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      const g = this.hostname.split(/\./);
      for (let v = 0, y = g.length; v < y; v++) {
        const b = g[v];
        if (b && !b.match(d7)) {
          let k = "";
          for (let C = 0, S = b.length; C < S; C++)
            b.charCodeAt(C) > 127 ? k += "x" : k += b[C];
          if (!k.match(d7)) {
            const C = g.slice(0, v), S = g.slice(v + 1), _ = b.match(Zse);
            _ && (C.push(_[1]), S.unshift(_[2])), S.length && (o = S.join(".") + o), this.hostname = C.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > Yse && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const a = o.indexOf("#");
  a !== -1 && (this.hash = o.substr(a), o = o.slice(0, a));
  const l = o.indexOf("?");
  return l !== -1 && (this.search = o.substr(l), o = o.slice(0, l)), o && (this.pathname = o), m7[r] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
$1.prototype.parseHost = function(t) {
  let e = Gse.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
const eae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Dd,
  encode: o0,
  format: W4,
  parse: G4
}, Symbol.toStringTag, { value: "Module" })), FN = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, TN = /[\0-\x1F\x7F-\x9F]/, tae = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, K4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, MN = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, PN = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, rae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any: FN,
  Cc: TN,
  Cf: tae,
  P: K4,
  S: MN,
  Z: PN
}, Symbol.toStringTag, { value: "Module" })), nae = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛžÞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿Žã€–ãŠºã˜¹ãž¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ð”„raveè€»Ã€äƒ€pha;äŽ‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ð”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ð’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ð€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;äŽ’r;ì€€ð”…pf;ì€€ð”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰ŽÜ€HOacdefhilorsuÅÅ‘Å–Æ€ÆžÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆŽÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;äŽ§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈžÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉŽ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ð’žpÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„Ž;ä”lÄ€;tËËžæˆ‡a;äŽ”r;ì€€ð”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ð…f;ì€€ð”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïžrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaÐ’ÐªÐ°ÑžÑ¿Í¼rrowÆ€;BUÐÐžÐ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ðº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥žectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ð’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓžÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ð”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ð”¼silon;äŽ•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;äŽ—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ð”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ð”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸äŽ“;äœreve;ä„žÆ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ð”Š;æ‹™pf;ì€€ð”¾eaterÌ€EFGLSTØµÙ„ÙŽÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ð’¢;æ‰«Ð€AacfiosuÚ…Ú‹Ú–Ú›ÚžÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äžirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜŽÜšÜžÜ¡Ü¨Ý„Ý¸Þ‹ÞÞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»ÃŽäƒŽ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´Ý‰\0Ý¢Ä€;eÝÝŽæˆ¬Ä€grÝ“Ý˜ral;æˆ«section;æ‹‚isibleÄ€CTÝ¬Ý²omma;æ£imes;æ¢Æ€gptÝ¿ÞƒÞˆon;ä„®f;ì€€ð•€a;äŽ™cr;æ„ilde;ä„¨Ç«Þš\0Þžcy;ä†lè€»ÃäƒÊ€cfosuÞ¬Þ·Þ¼ß‚ßÄ€iyÞ±Þµrc;ä„´;ä™r;ì€€ð”pf;ì€€ð•Ç£ß‡\0ßŒr;ì€€ð’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äŽšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ð”Žpf;ì€€ð•‚cr;ì€€ð’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;äŽ›g;æŸªlacetrf;æ„’r;æ†žÆ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢žæ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥ŽÄ€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ð”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§žà§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ð•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªÐ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªŽp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ð”nusPlus;æˆ“pf;ì€€ð•„cÃ²à©¶;äŽœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶žcy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ŽativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ð”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±žà²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰ŽÌ¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµŽsetÄ€;Eà´›à´žì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ð’©ildeè€»Ã‘äƒ‘;äŽÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·Žà·“rcè€»Ã”äƒ”;äžblac;ä…r;ì€€ð”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;äŽ©cron;äŽŸpf;ì€€ð•†enCurlyÄ€DQà¸Žà¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ð’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æžet;æŽ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ð”“i;äŽ¦;äŽ usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ð’«;äŽ¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ð””pf;æ„šcr;ì€€ð’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½Žà½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾Žement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;äŽ¡ghtÐ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€žæ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚žf;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„žá…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„Žá„“á„—æª¼ron;ä… dil;ä…žrc;ä…œ;ä¡r;ì€€ð”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ÐžeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;äŽ£allCircle;æˆ˜pf;ì€€ð•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†žsetÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ð’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡Žæ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰žá‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃžäƒžADE;æ„¢Ä€Hcá‰Žá‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;äŽ¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ð”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;äŽ˜Ä€cnáŠŽáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ð•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ð’¯rok;ä…¦à«¡á‹·áŒŽáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·áŽ…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äŽve;ä…¬Ä€iyáŒžáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ð”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æŽµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠŽÄ€gpá»á¿on;ä…²f;ì€€ð•ŒÐ€ADETadpsáŽ•áŽ®áŽ¸á„Ï¨á’á—á³rrowÆ€;BDá…áŽ áŽ¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRážá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;äŽ¥ing;ä…®cr;ì€€ð’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ð”™pf;ì€€ð•cr;ì€€ð’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ð”špf;ì€€ð•Žcr;ì€€ð’²È€fiosá“‹á“á“’á“˜r;ì€€ð”›;äŽžpf;ì€€ð•cr;ì€€ð’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ð”œpf;ì€€ð•cr;ì€€ð’´ml;ä…¸Ð€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;äŽ–r;æ„¨pf;æ„¤cr;ì€€ð’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ð”žraveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;äŽ±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜žá˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ð•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ð’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœžkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æŽ¶Ä€oyáœá;ä±quo;æ€žÊ€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;äŽ²;æ„¶een;æ‰¬r;ì€€ð”ŸgÎ€costuvwážážáž³áŸáŸ•áŸ›áŸžÆ€aiuáž”áž–ážšÃ°Ý rc;æ—¯pÂ»á±Æ€dptáž¤áž¨áž­ot;æ¨€lus;æ¨imes;æ¨‚É±áž¹\0\0áž¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡žá¡§á¡¬f;ì€€ð•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢Žá¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠžimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•ž;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ð’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ð” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«Žä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«žá«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ð•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ð’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹žc;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®žp;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯žá¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯Ž\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹Žedge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²žá²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;äŽ´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ð”¡arÄ€lrá²³á²µÂ»à£œÂ»á€žÊ€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒžop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ð••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶Žrn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ð’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ð©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½Žá½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸Žá¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ð”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ð•–Æ€alsá»„á»Žá»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäŽµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;äŽ·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾ž\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ð”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ð•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0âŽ;æ…š;æ…8;æ…žl;æ„wn;æŒ¢cr;ì€€ð’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†žÄ€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šäŽ³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ð”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„Žâ„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ð•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…Žâ…;æªŽ;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†ŽproÃ¸â‚žr;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆŽâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ð”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰žâ‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ð•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ð’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹Ž\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0âŽ†âŽªâŽ´cuteè€»Ã­äƒ­Æ€;iyÝ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ð”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ÞŽarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆžie;æ§doÃ´âŒ™Ê€;celpÝ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ð•ša;äŽ¹uestè€»Â¿ä‚¿Ä€ciâŽŠâŽr;ì€€ð’¾nÊ€;EdsvÓ´âŽ›âŽâŽ¡Ó³;æ‹¹ot;æ‹µÄ€;vâŽ¦âŽ§æ‹´;æ‹³Ä€;iÝ·âŽ®lde;ä„©Ç«âŽ¸\0âŽ¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ð”§ath;äˆ·pf;ì€€ð•›Ç£â¬\0â±r;ì€€ð’¿rcy;ä‘˜kcy;ä‘”Ð€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äŽº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ð”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ð•œcr;ì€€ð“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”Žâ”½â•šâ–€â™Žâ™žâ™¥â™¹â™½âššâš²â›˜ââ¨âž‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤ŽÄ€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;äŽ»gÆ€;dlà¢Žâ“â“ƒ;æ¦‘Ã¥à¢Ž;æª…uoè€»Â«ä‚«rÐ€;bfhlpstà¢™â“žâ“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—žrrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ð”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æŽ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›Žâ›æª‡Ä€;qâ›Žâš»im;æ‹¦Ð€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ð•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áŽÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼âž…âž‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âžƒ;æ¥­;æ€Žri;æŠ¿Ì€achiqtâž˜âžà©€âž¢âž®âž»quo;æ€¹r;ì€€ð“mÆ€;egà¦²âžªâž¬;æª;æªÄ€buâ”ªâž³oÄ€;rà¸Ÿâž¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â žÜ€Dacdefhilnopsuâ¡€â¡…â¢‚â¢Žâ¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡Žâ¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡žâ¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ð”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£žâ£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ð•žÄ€ctâ£¸â£½r;ì€€ð“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤äŽ¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡Ž;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦Žâ¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëžute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©Žar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ð”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«Žâ«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ð•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ð“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­äŽ½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²žâ²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§žÆ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·Ž\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªžâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ð”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;äŽ¿;æ¦¶pf;ì€€ð• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹ž\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astÐƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ÐƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ð”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜ŽÆ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„ŽÃ¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼Žä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ð•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»Žâ½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»ŽÆ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ð“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ð”®pf;ì€€ð•¢rime;æ—cr;ì€€ð“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„Žã„«ã…‡ã…¢ã…²ã†Žãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤žÃ«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼žÆ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦Ž;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈŽÈh;æ†³Æ€acgã…Žã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ð”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆžãˆŸæŽ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰Žr;æ¦†;ì€€ð•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ð“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§Žluhar;æ¥¨;æ„žàµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºãŽ¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âžºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãžã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ð”°È€acoyãŽ‚ãŽ†ãŽ‘ãŽ rp;æ™¯Ä€hyãŽ‹ãŽcy;ä‘‰;ä‘ˆrtÉ­ãŽ™\0\0ãŽœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmãŽ¨ãŽ´maÆ€;fvãŽ±ãŽ²ãŽ²äƒ;ä‚Ð€;deglnpráŠ«ã…ã‰ãŽã–ãžã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æªž;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ð•¤aÄ€drã‘Ð‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ð“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“Žã“•rÄ€;fã“”áž¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•žáˆ‰ã–‹ã–ŽÒ€;Edemnprsã”Žã”ã”‘ã”•ã”žã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”Žã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹Žã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ãž‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ð”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›äŽ¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠžÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ð•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãžÄ€ryã·ã»;ì€€ð“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioãž‹ãžŽxÃ´á·headÄ€lrãž—ãž eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã Žã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘žve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²áŽ­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ð”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ð•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡áŽ³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒŽng;ä…¯ri;æ—¹cr;ì€€ð“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Þ€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;háŽ·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ãŽ³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ð”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ð•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ð“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨žÂ»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ð”´pf;ì€€ð•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ð“Œà«£ážŽãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«Ž\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ð”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;äŽ¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptáž¤ãªµãª¾Ä€flãªºáž©;ì€€ð•©imÃ¥áž²Ä€Aaã«‡ã«ŠrÃ²ÏŽrÃ²à¨Ä€cqã«’áž¸r;ì€€ð“Ä€ptáŸ–ã«œrÃ©áŸ”Ð€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ð”¶cy;ä‘—pf;ì€€ð•ªcr;ì€€ð“ŽÄ€cmã¬¦ã¬©y;ä‘Žlè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;äŽ¶r;ì€€ð”·cy;ä¶grarr;æ‡pf;ì€€ð•«cr;ì€€ð“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((t) => t.charCodeAt(0))
), iae = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((t) => t.charCodeAt(0))
);
var Q2;
const oae = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), sae = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Q2 = String.fromCodePoint) !== null && Q2 !== void 0 ? Q2 : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function aae(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = oae.get(t)) !== null && e !== void 0 ? e : t;
}
var Bn;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(Bn || (Bn = {}));
const lae = 32;
var $u;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})($u || ($u = {}));
function _C(t) {
  return t >= Bn.ZERO && t <= Bn.NINE;
}
function uae(t) {
  return t >= Bn.UPPER_A && t <= Bn.UPPER_F || t >= Bn.LOWER_A && t <= Bn.LOWER_F;
}
function cae(t) {
  return t >= Bn.UPPER_A && t <= Bn.UPPER_Z || t >= Bn.LOWER_A && t <= Bn.LOWER_Z || _C(t);
}
function hae(t) {
  return t === Bn.EQUALS || cae(t);
}
var Mn;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(Mn || (Mn = {}));
var Fu;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(Fu || (Fu = {}));
class fae {
  constructor(e, r, n) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = n, this.state = Mn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Fu.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = Mn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case Mn.EntityStart:
        return e.charCodeAt(r) === Bn.NUM ? (this.state = Mn.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = Mn.NamedEntity, this.stateNamedEntity(e, r));
      case Mn.NumericStart:
        return this.stateNumericStart(e, r);
      case Mn.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case Mn.NumericHex:
        return this.stateNumericHex(e, r);
      case Mn.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | lae) === Bn.LOWER_X ? (this.state = Mn.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = Mn.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, n, i) {
    if (r !== n) {
      const o = n - r;
      this.result = this.result * Math.pow(i, o) + parseInt(e.substr(r, o), i), this.consumed += o;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (_C(i) || uae(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, n, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (_C(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, n, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var n;
    if (this.consumed <= r)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === Bn.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Fu.Strict)
      return 0;
    return this.emitCodePoint(aae(this.result), this.consumed), this.errors && (e !== Bn.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: n } = this;
    let i = n[this.treeIndex], o = (i & $u.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const s = e.charCodeAt(r);
      if (this.treeIndex = dae(n, i, this.treeIndex + Math.max(1, o), s), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Fu.Attribute && // We shouldn't have consumed any characters after the entity,
        (o === 0 || // And there should be no invalid characters.
        hae(s)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = n[this.treeIndex], o = (i & $u.VALUE_LENGTH) >> 14, o !== 0) {
        if (s === Bn.SEMI)
          return this.emitNamedEntityData(this.treeIndex, o, this.consumed + this.excess);
        this.decodeMode !== Fu.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: n } = this, i = (n[r] & $u.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, n) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(r === 1 ? i[e] & ~$u.VALUE_LENGTH : i[e + 1], n), r === 3 && this.emitCodePoint(i[e + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case Mn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Fu.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case Mn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Mn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Mn.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Mn.EntityStart:
        return 0;
    }
  }
}
function RN(t) {
  let e = "";
  const r = new fae(t, (n) => e += sae(n));
  return function(n, i) {
    let o = 0, s = 0;
    for (; (s = n.indexOf("&", s)) >= 0; ) {
      e += n.slice(o, s), r.startEntity(i);
      const l = r.write(
        n,
        // Skip the "&"
        s + 1
      );
      if (l < 0) {
        o = s + r.end();
        break;
      }
      o = s + l, s = l === 0 ? o + 1 : o;
    }
    const a = e + n.slice(o);
    return e = "", a;
  };
}
function dae(t, e, r, n) {
  const i = (e & $u.BRANCH_LENGTH) >> 7, o = e & $u.JUMP_TABLE;
  if (i === 0)
    return o !== 0 && n === o ? r : -1;
  if (o) {
    const l = n - o;
    return l < 0 || l >= i ? -1 : t[r + l] - 1;
  }
  let s = r, a = s + i - 1;
  for (; s <= a; ) {
    const l = s + a >>> 1, u = t[l];
    if (u < n)
      s = l + 1;
    else if (u > n)
      a = l - 1;
    else
      return t[l + i];
  }
  return -1;
}
const pae = RN(nae);
RN(iae);
function NN(t, e = Fu.Legacy) {
  return pae(t, e);
}
function mae(t) {
  return Object.prototype.toString.call(t);
}
function Q4(t) {
  return mae(t) === "[object String]";
}
const gae = Object.prototype.hasOwnProperty;
function vae(t, e) {
  return gae.call(t, e);
}
function Kb(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    if (e) {
      if (typeof e != "object")
        throw new TypeError(e + "must be object");
      Object.keys(e).forEach(function(r) {
        t[r] = e[r];
      });
    }
  }), t;
}
function $N(t, e, r) {
  return [].concat(t.slice(0, e), r, t.slice(e + 1));
}
function X4(t) {
  return !(t >= 55296 && t <= 57343 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534 || t >= 0 && t <= 8 || t === 11 || t >= 14 && t <= 31 || t >= 127 && t <= 159 || t > 1114111);
}
function I1(t) {
  if (t > 65535) {
    t -= 65536;
    const e = 55296 + (t >> 10), r = 56320 + (t & 1023);
    return String.fromCharCode(e, r);
  }
  return String.fromCharCode(t);
}
const IN = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, yae = /&([a-z#][a-z0-9]{1,31});/gi, bae = new RegExp(IN.source + "|" + yae.source, "gi"), xae = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function wae(t, e) {
  if (e.charCodeAt(0) === 35 && xae.test(e)) {
    const n = e[1].toLowerCase() === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10);
    return X4(n) ? I1(n) : t;
  }
  const r = NN(t);
  return r !== t ? r : t;
}
function kae(t) {
  return t.indexOf("\\") < 0 ? t : t.replace(IN, "$1");
}
function Od(t) {
  return t.indexOf("\\") < 0 && t.indexOf("&") < 0 ? t : t.replace(bae, function(e, r, n) {
    return r || wae(e, n);
  });
}
const Cae = /[&<>"]/, _ae = /[&<>"]/g, Sae = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function Aae(t) {
  return Sae[t];
}
function lc(t) {
  return Cae.test(t) ? t.replace(_ae, Aae) : t;
}
const Eae = /[.?*+^$[\]\\(){}|-]/g;
function Dae(t) {
  return t.replace(Eae, "\\$&");
}
function Pr(t) {
  switch (t) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function vg(t) {
  if (t >= 8192 && t <= 8202)
    return !0;
  switch (t) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function yg(t) {
  return K4.test(t) || MN.test(t);
}
function bg(t) {
  switch (t) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function Qb(t) {
  return t = t.trim().replace(/\s+/g, " "), "áºž".toLowerCase() === "á¹¾" && (t = t.replace(/áºž/g, "ÃŸ")), t.toLowerCase().toUpperCase();
}
const Oae = { mdurl: eae, ucmicro: rae }, Fae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: $N,
  assign: Kb,
  escapeHtml: lc,
  escapeRE: Dae,
  fromCodePoint: I1,
  has: vae,
  isMdAsciiPunct: bg,
  isPunctChar: yg,
  isSpace: Pr,
  isString: Q4,
  isValidEntityCode: X4,
  isWhiteSpace: vg,
  lib: Oae,
  normalizeReference: Qb,
  unescapeAll: Od,
  unescapeMd: kae
}, Symbol.toStringTag, { value: "Module" }));
function Tae(t, e, r) {
  let n, i, o, s;
  const a = t.posMax, l = t.pos;
  for (t.pos = e + 1, n = 1; t.pos < a; ) {
    if (o = t.src.charCodeAt(t.pos), o === 93 && (n--, n === 0)) {
      i = !0;
      break;
    }
    if (s = t.pos, t.md.inline.skipToken(t), o === 91) {
      if (s === t.pos - 1)
        n++;
      else if (r)
        return t.pos = l, -1;
    }
  }
  let u = -1;
  return i && (u = t.pos), t.pos = l, u;
}
function Mae(t, e, r) {
  let n, i = e;
  const o = {
    ok: !1,
    pos: 0,
    str: ""
  };
  if (t.charCodeAt(i) === 60) {
    for (i++; i < r; ) {
      if (n = t.charCodeAt(i), n === 10 || n === 60)
        return o;
      if (n === 62)
        return o.pos = i + 1, o.str = Od(t.slice(e + 1, i)), o.ok = !0, o;
      if (n === 92 && i + 1 < r) {
        i += 2;
        continue;
      }
      i++;
    }
    return o;
  }
  let s = 0;
  for (; i < r && (n = t.charCodeAt(i), !(n === 32 || n < 32 || n === 127)); ) {
    if (n === 92 && i + 1 < r) {
      if (t.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (n === 40 && (s++, s > 32))
      return o;
    if (n === 41) {
      if (s === 0)
        break;
      s--;
    }
    i++;
  }
  return e === i || s !== 0 || (o.str = Od(t.slice(e, i)), o.pos = i, o.ok = !0), o;
}
function Pae(t, e, r, n) {
  let i, o = e;
  const s = {
    // if `true`, this is a valid link title
    ok: !1,
    // if `true`, this link can be continued on the next line
    can_continue: !1,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (n)
    s.str = n.str, s.marker = n.marker;
  else {
    if (o >= r)
      return s;
    let a = t.charCodeAt(o);
    if (a !== 34 && a !== 39 && a !== 40)
      return s;
    e++, o++, a === 40 && (a = 41), s.marker = a;
  }
  for (; o < r; ) {
    if (i = t.charCodeAt(o), i === s.marker)
      return s.pos = o + 1, s.str += Od(t.slice(e, o)), s.ok = !0, s;
    if (i === 40 && s.marker === 41)
      return s;
    i === 92 && o + 1 < r && o++, o++;
  }
  return s.can_continue = !0, s.str += Od(t.slice(e, o)), s;
}
const Rae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination: Mae,
  parseLinkLabel: Tae,
  parseLinkTitle: Pae
}, Symbol.toStringTag, { value: "Module" })), al = {};
al.code_inline = function(t, e, r, n, i) {
  const o = t[e];
  return "<code" + i.renderAttrs(o) + ">" + lc(o.content) + "</code>";
};
al.code_block = function(t, e, r, n, i) {
  const o = t[e];
  return "<pre" + i.renderAttrs(o) + "><code>" + lc(t[e].content) + `</code></pre>
`;
};
al.fence = function(t, e, r, n, i) {
  const o = t[e], s = o.info ? Od(o.info).trim() : "";
  let a = "", l = "";
  if (s) {
    const c = s.split(/(\s+)/g);
    a = c[0], l = c.slice(2).join("");
  }
  let u;
  if (r.highlight ? u = r.highlight(o.content, a, l) || lc(o.content) : u = lc(o.content), u.indexOf("<pre") === 0)
    return u + `
`;
  if (s) {
    const c = o.attrIndex("class"), h = o.attrs ? o.attrs.slice() : [];
    c < 0 ? h.push(["class", r.langPrefix + a]) : (h[c] = h[c].slice(), h[c][1] += " " + r.langPrefix + a);
    const d = {
      attrs: h
    };
    return `<pre><code${i.renderAttrs(d)}>${u}</code></pre>
`;
  }
  return `<pre><code${i.renderAttrs(o)}>${u}</code></pre>
`;
};
al.image = function(t, e, r, n, i) {
  const o = t[e];
  return o.attrs[o.attrIndex("alt")][1] = i.renderInlineAsText(o.children, r, n), i.renderToken(t, e, r);
};
al.hardbreak = function(t, e, r) {
  return r.xhtmlOut ? `<br />
` : `<br>
`;
};
al.softbreak = function(t, e, r) {
  return r.breaks ? r.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
al.text = function(t, e) {
  return lc(t[e].content);
};
al.html_block = function(t, e) {
  return t[e].content;
};
al.html_inline = function(t, e) {
  return t[e].content;
};
function tp() {
  this.rules = Kb({}, al);
}
tp.prototype.renderAttrs = function(t) {
  let e, r, n;
  if (!t.attrs)
    return "";
  for (n = "", e = 0, r = t.attrs.length; e < r; e++)
    n += " " + lc(t.attrs[e][0]) + '="' + lc(t.attrs[e][1]) + '"';
  return n;
};
tp.prototype.renderToken = function(t, e, r) {
  const n = t[e];
  let i = "";
  if (n.hidden)
    return "";
  n.block && n.nesting !== -1 && e && t[e - 1].hidden && (i += `
`), i += (n.nesting === -1 ? "</" : "<") + n.tag, i += this.renderAttrs(n), n.nesting === 0 && r.xhtmlOut && (i += " /");
  let o = !1;
  if (n.block && (o = !0, n.nesting === 1 && e + 1 < t.length)) {
    const s = t[e + 1];
    (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === n.tag) && (o = !1);
  }
  return i += o ? `>
` : ">", i;
};
tp.prototype.renderInline = function(t, e, r) {
  let n = "";
  const i = this.rules;
  for (let o = 0, s = t.length; o < s; o++) {
    const a = t[o].type;
    typeof i[a] < "u" ? n += i[a](t, o, e, r, this) : n += this.renderToken(t, o, e);
  }
  return n;
};
tp.prototype.renderInlineAsText = function(t, e, r) {
  let n = "";
  for (let i = 0, o = t.length; i < o; i++)
    switch (t[i].type) {
      case "text":
        n += t[i].content;
        break;
      case "image":
        n += this.renderInlineAsText(t[i].children, e, r);
        break;
      case "html_inline":
      case "html_block":
        n += t[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        n += `
`;
        break;
    }
  return n;
};
tp.prototype.render = function(t, e, r) {
  let n = "";
  const i = this.rules;
  for (let o = 0, s = t.length; o < s; o++) {
    const a = t[o].type;
    a === "inline" ? n += this.renderInline(t[o].children, e, r) : typeof i[a] < "u" ? n += i[a](t, o, e, r, this) : n += this.renderToken(t, o, e, r);
  }
  return n;
};
function co() {
  this.__rules__ = [], this.__cache__ = null;
}
co.prototype.__find__ = function(t) {
  for (let e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t)
      return e;
  return -1;
};
co.prototype.__compile__ = function() {
  const t = this, e = [""];
  t.__rules__.forEach(function(r) {
    r.enabled && r.alt.forEach(function(n) {
      e.indexOf(n) < 0 && e.push(n);
    });
  }), t.__cache__ = {}, e.forEach(function(r) {
    t.__cache__[r] = [], t.__rules__.forEach(function(n) {
      n.enabled && (r && n.alt.indexOf(r) < 0 || t.__cache__[r].push(n.fn));
    });
  });
};
co.prototype.at = function(t, e, r) {
  const n = this.__find__(t), i = r || {};
  if (n === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__[n].fn = e, this.__rules__[n].alt = i.alt || [], this.__cache__ = null;
};
co.prototype.before = function(t, e, r, n) {
  const i = this.__find__(t), o = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i, 0, {
    name: e,
    enabled: !0,
    fn: r,
    alt: o.alt || []
  }), this.__cache__ = null;
};
co.prototype.after = function(t, e, r, n) {
  const i = this.__find__(t), o = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i + 1, 0, {
    name: e,
    enabled: !0,
    fn: r,
    alt: o.alt || []
  }), this.__cache__ = null;
};
co.prototype.push = function(t, e, r) {
  const n = r || {};
  this.__rules__.push({
    name: t,
    enabled: !0,
    fn: e,
    alt: n.alt || []
  }), this.__cache__ = null;
};
co.prototype.enable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const r = [];
  return t.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = !0, r.push(n);
  }, this), this.__cache__ = null, r;
};
co.prototype.enableOnly = function(t, e) {
  Array.isArray(t) || (t = [t]), this.__rules__.forEach(function(r) {
    r.enabled = !1;
  }), this.enable(t, e);
};
co.prototype.disable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const r = [];
  return t.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = !1, r.push(n);
  }, this), this.__cache__ = null, r;
};
co.prototype.getRules = function(t) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [];
};
function sa(t, e, r) {
  this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = r, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
sa.prototype.attrIndex = function(t) {
  if (!this.attrs)
    return -1;
  const e = this.attrs;
  for (let r = 0, n = e.length; r < n; r++)
    if (e[r][0] === t)
      return r;
  return -1;
};
sa.prototype.attrPush = function(t) {
  this.attrs ? this.attrs.push(t) : this.attrs = [t];
};
sa.prototype.attrSet = function(t, e) {
  const r = this.attrIndex(t), n = [t, e];
  r < 0 ? this.attrPush(n) : this.attrs[r] = n;
};
sa.prototype.attrGet = function(t) {
  const e = this.attrIndex(t);
  let r = null;
  return e >= 0 && (r = this.attrs[e][1]), r;
};
sa.prototype.attrJoin = function(t, e) {
  const r = this.attrIndex(t);
  r < 0 ? this.attrPush([t, e]) : this.attrs[r][1] = this.attrs[r][1] + " " + e;
};
function BN(t, e, r) {
  this.src = t, this.env = r, this.tokens = [], this.inlineMode = !1, this.md = e;
}
BN.prototype.Token = sa;
const Nae = /\r\n?|\n/g, $ae = /\0/g;
function Iae(t) {
  let e;
  e = t.src.replace(Nae, `
`), e = e.replace($ae, "ï¿½"), t.src = e;
}
function Bae(t) {
  let e;
  t.inlineMode ? (e = new t.Token("inline", "", 0), e.content = t.src, e.map = [0, 1], e.children = [], t.tokens.push(e)) : t.md.block.parse(t.src, t.md, t.env, t.tokens);
}
function Lae(t) {
  const e = t.tokens;
  for (let r = 0, n = e.length; r < n; r++) {
    const i = e[r];
    i.type === "inline" && t.md.inline.parse(i.content, t.md, t.env, i.children);
  }
}
function zae(t) {
  return /^<a[>\s]/i.test(t);
}
function jae(t) {
  return /^<\/a\s*>/i.test(t);
}
function qae(t) {
  const e = t.tokens;
  if (t.md.options.linkify)
    for (let r = 0, n = e.length; r < n; r++) {
      if (e[r].type !== "inline" || !t.md.linkify.pretest(e[r].content))
        continue;
      let i = e[r].children, o = 0;
      for (let s = i.length - 1; s >= 0; s--) {
        const a = i[s];
        if (a.type === "link_close") {
          for (s--; i[s].level !== a.level && i[s].type !== "link_open"; )
            s--;
          continue;
        }
        if (a.type === "html_inline" && (zae(a.content) && o > 0 && o--, jae(a.content) && o++), !(o > 0) && a.type === "text" && t.md.linkify.test(a.content)) {
          const l = a.content;
          let u = t.md.linkify.match(l);
          const c = [];
          let h = a.level, d = 0;
          u.length > 0 && u[0].index === 0 && s > 0 && i[s - 1].type === "text_special" && (u = u.slice(1));
          for (let p = 0; p < u.length; p++) {
            const g = u[p].url, v = t.md.normalizeLink(g);
            if (!t.md.validateLink(v))
              continue;
            let y = u[p].text;
            u[p].schema ? u[p].schema === "mailto:" && !/^mailto:/i.test(y) ? y = t.md.normalizeLinkText("mailto:" + y).replace(/^mailto:/, "") : y = t.md.normalizeLinkText(y) : y = t.md.normalizeLinkText("http://" + y).replace(/^http:\/\//, "");
            const b = u[p].index;
            if (b > d) {
              const _ = new t.Token("text", "", 0);
              _.content = l.slice(d, b), _.level = h, c.push(_);
            }
            const k = new t.Token("link_open", "a", 1);
            k.attrs = [["href", v]], k.level = h++, k.markup = "linkify", k.info = "auto", c.push(k);
            const C = new t.Token("text", "", 0);
            C.content = y, C.level = h, c.push(C);
            const S = new t.Token("link_close", "a", -1);
            S.level = --h, S.markup = "linkify", S.info = "auto", c.push(S), d = u[p].lastIndex;
          }
          if (d < l.length) {
            const p = new t.Token("text", "", 0);
            p.content = l.slice(d), p.level = h, c.push(p);
          }
          e[r].children = i = $N(i, s, c);
        }
      }
    }
}
const LN = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, Uae = /\((c|tm|r)\)/i, Hae = /\((c|tm|r)\)/ig, Vae = {
  c: "Â©",
  r: "Â®",
  tm: "â„¢"
};
function Wae(t, e) {
  return Vae[e.toLowerCase()];
}
function Gae(t) {
  let e = 0;
  for (let r = t.length - 1; r >= 0; r--) {
    const n = t[r];
    n.type === "text" && !e && (n.content = n.content.replace(Hae, Wae)), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function Kae(t) {
  let e = 0;
  for (let r = t.length - 1; r >= 0; r--) {
    const n = t[r];
    n.type === "text" && !e && LN.test(n.content) && (n.content = n.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“")), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function Qae(t) {
  let e;
  if (t.md.options.typographer)
    for (e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type === "inline" && (Uae.test(t.tokens[e].content) && Gae(t.tokens[e].children), LN.test(t.tokens[e].content) && Kae(t.tokens[e].children));
}
const Xae = /['"]/, g7 = /['"]/g, v7 = "â€™";
function Jv(t, e, r) {
  return t.slice(0, e) + r + t.slice(e + 1);
}
function Jae(t, e) {
  let r;
  const n = [];
  for (let i = 0; i < t.length; i++) {
    const o = t[i], s = t[i].level;
    for (r = n.length - 1; r >= 0 && !(n[r].level <= s); r--)
      ;
    if (n.length = r + 1, o.type !== "text")
      continue;
    let a = o.content, l = 0, u = a.length;
    e:
      for (; l < u; ) {
        g7.lastIndex = l;
        const c = g7.exec(a);
        if (!c)
          break;
        let h = !0, d = !0;
        l = c.index + 1;
        const p = c[0] === "'";
        let g = 32;
        if (c.index - 1 >= 0)
          g = a.charCodeAt(c.index - 1);
        else
          for (r = i - 1; r >= 0 && !(t[r].type === "softbreak" || t[r].type === "hardbreak"); r--)
            if (t[r].content) {
              g = t[r].content.charCodeAt(t[r].content.length - 1);
              break;
            }
        let v = 32;
        if (l < u)
          v = a.charCodeAt(l);
        else
          for (r = i + 1; r < t.length && !(t[r].type === "softbreak" || t[r].type === "hardbreak"); r++)
            if (t[r].content) {
              v = t[r].content.charCodeAt(0);
              break;
            }
        const y = bg(g) || yg(String.fromCharCode(g)), b = bg(v) || yg(String.fromCharCode(v)), k = vg(g), C = vg(v);
        if (C ? h = !1 : b && (k || y || (h = !1)), k ? d = !1 : y && (C || b || (d = !1)), v === 34 && c[0] === '"' && g >= 48 && g <= 57 && (d = h = !1), h && d && (h = y, d = b), !h && !d) {
          p && (o.content = Jv(o.content, c.index, v7));
          continue;
        }
        if (d)
          for (r = n.length - 1; r >= 0; r--) {
            let S = n[r];
            if (n[r].level < s)
              break;
            if (S.single === p && n[r].level === s) {
              S = n[r];
              let _, D;
              p ? (_ = e.md.options.quotes[2], D = e.md.options.quotes[3]) : (_ = e.md.options.quotes[0], D = e.md.options.quotes[1]), o.content = Jv(o.content, c.index, D), t[S.token].content = Jv(
                t[S.token].content,
                S.pos,
                _
              ), l += D.length - 1, S.token === i && (l += _.length - 1), a = o.content, u = a.length, n.length = r;
              continue e;
            }
          }
        h ? n.push({
          token: i,
          pos: c.index,
          single: p,
          level: s
        }) : d && p && (o.content = Jv(o.content, c.index, v7));
      }
  }
}
function Yae(t) {
  if (t.md.options.typographer)
    for (let e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type !== "inline" || !Xae.test(t.tokens[e].content) || Jae(t.tokens[e].children, t);
}
function Zae(t) {
  let e, r;
  const n = t.tokens, i = n.length;
  for (let o = 0; o < i; o++) {
    if (n[o].type !== "inline") continue;
    const s = n[o].children, a = s.length;
    for (e = 0; e < a; e++)
      s[e].type === "text_special" && (s[e].type = "text");
    for (e = r = 0; e < a; e++)
      s[e].type === "text" && e + 1 < a && s[e + 1].type === "text" ? s[e + 1].content = s[e].content + s[e + 1].content : (e !== r && (s[r] = s[e]), r++);
    e !== r && (s.length = r);
  }
}
const X2 = [
  ["normalize", Iae],
  ["block", Bae],
  ["inline", Lae],
  ["linkify", qae],
  ["replacements", Qae],
  ["smartquotes", Yae],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", Zae]
];
function J4() {
  this.ruler = new co();
  for (let t = 0; t < X2.length; t++)
    this.ruler.push(X2[t][0], X2[t][1]);
}
J4.prototype.process = function(t) {
  const e = this.ruler.getRules("");
  for (let r = 0, n = e.length; r < n; r++)
    e[r](t);
};
J4.prototype.State = BN;
function ll(t, e, r, n) {
  this.src = t, this.md = e, this.env = r, this.tokens = n, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const i = this.src;
  for (let o = 0, s = 0, a = 0, l = 0, u = i.length, c = !1; s < u; s++) {
    const h = i.charCodeAt(s);
    if (!c)
      if (Pr(h)) {
        a++, h === 9 ? l += 4 - l % 4 : l++;
        continue;
      } else
        c = !0;
    (h === 10 || s === u - 1) && (h !== 10 && s++, this.bMarks.push(o), this.eMarks.push(s), this.tShift.push(a), this.sCount.push(l), this.bsCount.push(0), c = !1, a = 0, l = 0, o = s + 1);
  }
  this.bMarks.push(i.length), this.eMarks.push(i.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
ll.prototype.push = function(t, e, r) {
  const n = new sa(t, e, r);
  return n.block = !0, r < 0 && this.level--, n.level = this.level, r > 0 && this.level++, this.tokens.push(n), n;
};
ll.prototype.isEmpty = function(t) {
  return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
};
ll.prototype.skipEmptyLines = function(t) {
  for (let e = this.lineMax; t < e && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
    ;
  return t;
};
ll.prototype.skipSpaces = function(t) {
  for (let e = this.src.length; t < e; t++) {
    const r = this.src.charCodeAt(t);
    if (!Pr(r))
      break;
  }
  return t;
};
ll.prototype.skipSpacesBack = function(t, e) {
  if (t <= e)
    return t;
  for (; t > e; )
    if (!Pr(this.src.charCodeAt(--t)))
      return t + 1;
  return t;
};
ll.prototype.skipChars = function(t, e) {
  for (let r = this.src.length; t < r && this.src.charCodeAt(t) === e; t++)
    ;
  return t;
};
ll.prototype.skipCharsBack = function(t, e, r) {
  if (t <= r)
    return t;
  for (; t > r; )
    if (e !== this.src.charCodeAt(--t))
      return t + 1;
  return t;
};
ll.prototype.getLines = function(t, e, r, n) {
  if (t >= e)
    return "";
  const i = new Array(e - t);
  for (let o = 0, s = t; s < e; s++, o++) {
    let a = 0;
    const l = this.bMarks[s];
    let u = l, c;
    for (s + 1 < e || n ? c = this.eMarks[s] + 1 : c = this.eMarks[s]; u < c && a < r; ) {
      const h = this.src.charCodeAt(u);
      if (Pr(h))
        h === 9 ? a += 4 - (a + this.bsCount[s]) % 4 : a++;
      else if (u - l < this.tShift[s])
        a++;
      else
        break;
      u++;
    }
    a > r ? i[o] = new Array(a - r + 1).join(" ") + this.src.slice(u, c) : i[o] = this.src.slice(u, c);
  }
  return i.join("");
};
ll.prototype.Token = sa;
const ele = 65536;
function J2(t, e) {
  const r = t.bMarks[e] + t.tShift[e], n = t.eMarks[e];
  return t.src.slice(r, n);
}
function y7(t) {
  const e = [], r = t.length;
  let n = 0, i = t.charCodeAt(n), o = !1, s = 0, a = "";
  for (; n < r; )
    i === 124 && (o ? (a += t.substring(s, n - 1), s = n) : (e.push(a + t.substring(s, n)), a = "", s = n + 1)), o = i === 92, n++, i = t.charCodeAt(n);
  return e.push(a + t.substring(s)), e;
}
function tle(t, e, r, n) {
  if (e + 2 > r)
    return !1;
  let i = e + 1;
  if (t.sCount[i] < t.blkIndent || t.sCount[i] - t.blkIndent >= 4)
    return !1;
  let o = t.bMarks[i] + t.tShift[i];
  if (o >= t.eMarks[i])
    return !1;
  const s = t.src.charCodeAt(o++);
  if (s !== 124 && s !== 45 && s !== 58 || o >= t.eMarks[i])
    return !1;
  const a = t.src.charCodeAt(o++);
  if (a !== 124 && a !== 45 && a !== 58 && !Pr(a) || s === 45 && Pr(a))
    return !1;
  for (; o < t.eMarks[i]; ) {
    const S = t.src.charCodeAt(o);
    if (S !== 124 && S !== 45 && S !== 58 && !Pr(S))
      return !1;
    o++;
  }
  let l = J2(t, e + 1), u = l.split("|");
  const c = [];
  for (let S = 0; S < u.length; S++) {
    const _ = u[S].trim();
    if (!_) {
      if (S === 0 || S === u.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(_))
      return !1;
    _.charCodeAt(_.length - 1) === 58 ? c.push(_.charCodeAt(0) === 58 ? "center" : "right") : _.charCodeAt(0) === 58 ? c.push("left") : c.push("");
  }
  if (l = J2(t, e).trim(), l.indexOf("|") === -1 || t.sCount[e] - t.blkIndent >= 4)
    return !1;
  u = y7(l), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop();
  const h = u.length;
  if (h === 0 || h !== c.length)
    return !1;
  if (n)
    return !0;
  const d = t.parentType;
  t.parentType = "table";
  const p = t.md.block.ruler.getRules("blockquote"), g = t.push("table_open", "table", 1), v = [e, 0];
  g.map = v;
  const y = t.push("thead_open", "thead", 1);
  y.map = [e, e + 1];
  const b = t.push("tr_open", "tr", 1);
  b.map = [e, e + 1];
  for (let S = 0; S < u.length; S++) {
    const _ = t.push("th_open", "th", 1);
    c[S] && (_.attrs = [["style", "text-align:" + c[S]]]);
    const D = t.push("inline", "", 0);
    D.content = u[S].trim(), D.children = [], t.push("th_close", "th", -1);
  }
  t.push("tr_close", "tr", -1), t.push("thead_close", "thead", -1);
  let k, C = 0;
  for (i = e + 2; i < r && !(t.sCount[i] < t.blkIndent); i++) {
    let S = !1;
    for (let D = 0, A = p.length; D < A; D++)
      if (p[D](t, i, r, !0)) {
        S = !0;
        break;
      }
    if (S || (l = J2(t, i).trim(), !l) || t.sCount[i] - t.blkIndent >= 4 || (u = y7(l), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), C += h - u.length, C > ele))
      break;
    if (i === e + 2) {
      const D = t.push("tbody_open", "tbody", 1);
      D.map = k = [e + 2, 0];
    }
    const _ = t.push("tr_open", "tr", 1);
    _.map = [i, i + 1];
    for (let D = 0; D < h; D++) {
      const A = t.push("td_open", "td", 1);
      c[D] && (A.attrs = [["style", "text-align:" + c[D]]]);
      const O = t.push("inline", "", 0);
      O.content = u[D] ? u[D].trim() : "", O.children = [], t.push("td_close", "td", -1);
    }
    t.push("tr_close", "tr", -1);
  }
  return k && (t.push("tbody_close", "tbody", -1), k[1] = i), t.push("table_close", "table", -1), v[1] = i, t.parentType = d, t.line = i, !0;
}
function rle(t, e, r) {
  if (t.sCount[e] - t.blkIndent < 4)
    return !1;
  let n = e + 1, i = n;
  for (; n < r; ) {
    if (t.isEmpty(n)) {
      n++;
      continue;
    }
    if (t.sCount[n] - t.blkIndent >= 4) {
      n++, i = n;
      continue;
    }
    break;
  }
  t.line = i;
  const o = t.push("code_block", "code", 0);
  return o.content = t.getLines(e, i, 4 + t.blkIndent, !1) + `
`, o.map = [e, t.line], !0;
}
function nle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || i + 3 > o)
    return !1;
  const s = t.src.charCodeAt(i);
  if (s !== 126 && s !== 96)
    return !1;
  let a = i;
  i = t.skipChars(i, s);
  let l = i - a;
  if (l < 3)
    return !1;
  const u = t.src.slice(a, i), c = t.src.slice(i, o);
  if (s === 96 && c.indexOf(String.fromCharCode(s)) >= 0)
    return !1;
  if (n)
    return !0;
  let h = e, d = !1;
  for (; h++, !(h >= r || (i = a = t.bMarks[h] + t.tShift[h], o = t.eMarks[h], i < o && t.sCount[h] < t.blkIndent)); )
    if (t.src.charCodeAt(i) === s && !(t.sCount[h] - t.blkIndent >= 4) && (i = t.skipChars(i, s), !(i - a < l) && (i = t.skipSpaces(i), !(i < o)))) {
      d = !0;
      break;
    }
  l = t.sCount[e], t.line = h + (d ? 1 : 0);
  const p = t.push("fence", "code", 0);
  return p.info = c, p.content = t.getLines(e + 1, h, l, !0), p.markup = u, p.map = [e, t.line], !0;
}
function ile(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  const s = t.lineMax;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 62)
    return !1;
  if (n)
    return !0;
  const a = [], l = [], u = [], c = [], h = t.md.block.ruler.getRules("blockquote"), d = t.parentType;
  t.parentType = "blockquote";
  let p = !1, g;
  for (g = e; g < r; g++) {
    const C = t.sCount[g] < t.blkIndent;
    if (i = t.bMarks[g] + t.tShift[g], o = t.eMarks[g], i >= o)
      break;
    if (t.src.charCodeAt(i++) === 62 && !C) {
      let _ = t.sCount[g] + 1, D, A;
      t.src.charCodeAt(i) === 32 ? (i++, _++, A = !1, D = !0) : t.src.charCodeAt(i) === 9 ? (D = !0, (t.bsCount[g] + _) % 4 === 3 ? (i++, _++, A = !1) : A = !0) : D = !1;
      let O = _;
      for (a.push(t.bMarks[g]), t.bMarks[g] = i; i < o; ) {
        const M = t.src.charCodeAt(i);
        if (Pr(M))
          M === 9 ? O += 4 - (O + t.bsCount[g] + (A ? 1 : 0)) % 4 : O++;
        else
          break;
        i++;
      }
      p = i >= o, l.push(t.bsCount[g]), t.bsCount[g] = t.sCount[g] + 1 + (D ? 1 : 0), u.push(t.sCount[g]), t.sCount[g] = O - _, c.push(t.tShift[g]), t.tShift[g] = i - t.bMarks[g];
      continue;
    }
    if (p)
      break;
    let S = !1;
    for (let _ = 0, D = h.length; _ < D; _++)
      if (h[_](t, g, r, !0)) {
        S = !0;
        break;
      }
    if (S) {
      t.lineMax = g, t.blkIndent !== 0 && (a.push(t.bMarks[g]), l.push(t.bsCount[g]), c.push(t.tShift[g]), u.push(t.sCount[g]), t.sCount[g] -= t.blkIndent);
      break;
    }
    a.push(t.bMarks[g]), l.push(t.bsCount[g]), c.push(t.tShift[g]), u.push(t.sCount[g]), t.sCount[g] = -1;
  }
  const v = t.blkIndent;
  t.blkIndent = 0;
  const y = t.push("blockquote_open", "blockquote", 1);
  y.markup = ">";
  const b = [e, 0];
  y.map = b, t.md.block.tokenize(t, e, g);
  const k = t.push("blockquote_close", "blockquote", -1);
  k.markup = ">", t.lineMax = s, t.parentType = d, b[1] = t.line;
  for (let C = 0; C < c.length; C++)
    t.bMarks[C + e] = a[C], t.tShift[C + e] = c[C], t.sCount[C + e] = u[C], t.bsCount[C + e] = l[C];
  return t.blkIndent = v, !0;
}
function ole(t, e, r, n) {
  const i = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let o = t.bMarks[e] + t.tShift[e];
  const s = t.src.charCodeAt(o++);
  if (s !== 42 && s !== 45 && s !== 95)
    return !1;
  let a = 1;
  for (; o < i; ) {
    const u = t.src.charCodeAt(o++);
    if (u !== s && !Pr(u))
      return !1;
    u === s && a++;
  }
  if (a < 3)
    return !1;
  if (n)
    return !0;
  t.line = e + 1;
  const l = t.push("hr", "hr", 0);
  return l.map = [e, t.line], l.markup = Array(a + 1).join(String.fromCharCode(s)), !0;
}
function b7(t, e) {
  const r = t.eMarks[e];
  let n = t.bMarks[e] + t.tShift[e];
  const i = t.src.charCodeAt(n++);
  if (i !== 42 && i !== 45 && i !== 43)
    return -1;
  if (n < r) {
    const o = t.src.charCodeAt(n);
    if (!Pr(o))
      return -1;
  }
  return n;
}
function x7(t, e) {
  const r = t.bMarks[e] + t.tShift[e], n = t.eMarks[e];
  let i = r;
  if (i + 1 >= n)
    return -1;
  let o = t.src.charCodeAt(i++);
  if (o < 48 || o > 57)
    return -1;
  for (; ; ) {
    if (i >= n)
      return -1;
    if (o = t.src.charCodeAt(i++), o >= 48 && o <= 57) {
      if (i - r >= 10)
        return -1;
      continue;
    }
    if (o === 41 || o === 46)
      break;
    return -1;
  }
  return i < n && (o = t.src.charCodeAt(i), !Pr(o)) ? -1 : i;
}
function sle(t, e) {
  const r = t.level + 2;
  for (let n = e + 2, i = t.tokens.length - 2; n < i; n++)
    t.tokens[n].level === r && t.tokens[n].type === "paragraph_open" && (t.tokens[n + 2].hidden = !0, t.tokens[n].hidden = !0, n += 2);
}
function ale(t, e, r, n) {
  let i, o, s, a, l = e, u = !0;
  if (t.sCount[l] - t.blkIndent >= 4 || t.listIndent >= 0 && t.sCount[l] - t.listIndent >= 4 && t.sCount[l] < t.blkIndent)
    return !1;
  let c = !1;
  n && t.parentType === "paragraph" && t.sCount[l] >= t.blkIndent && (c = !0);
  let h, d, p;
  if ((p = x7(t, l)) >= 0) {
    if (h = !0, s = t.bMarks[l] + t.tShift[l], d = Number(t.src.slice(s, p - 1)), c && d !== 1) return !1;
  } else if ((p = b7(t, l)) >= 0)
    h = !1;
  else
    return !1;
  if (c && t.skipSpaces(p) >= t.eMarks[l])
    return !1;
  if (n)
    return !0;
  const g = t.src.charCodeAt(p - 1), v = t.tokens.length;
  h ? (a = t.push("ordered_list_open", "ol", 1), d !== 1 && (a.attrs = [["start", d]])) : a = t.push("bullet_list_open", "ul", 1);
  const y = [l, 0];
  a.map = y, a.markup = String.fromCharCode(g);
  let b = !1;
  const k = t.md.block.ruler.getRules("list"), C = t.parentType;
  for (t.parentType = "list"; l < r; ) {
    o = p, i = t.eMarks[l];
    const S = t.sCount[l] + p - (t.bMarks[l] + t.tShift[l]);
    let _ = S;
    for (; o < i; ) {
      const $ = t.src.charCodeAt(o);
      if ($ === 9)
        _ += 4 - (_ + t.bsCount[l]) % 4;
      else if ($ === 32)
        _++;
      else
        break;
      o++;
    }
    const D = o;
    let A;
    D >= i ? A = 1 : A = _ - S, A > 4 && (A = 1);
    const O = S + A;
    a = t.push("list_item_open", "li", 1), a.markup = String.fromCharCode(g);
    const M = [l, 0];
    a.map = M, h && (a.info = t.src.slice(s, p - 1));
    const z = t.tight, R = t.tShift[l], N = t.sCount[l], I = t.listIndent;
    if (t.listIndent = t.blkIndent, t.blkIndent = O, t.tight = !0, t.tShift[l] = D - t.bMarks[l], t.sCount[l] = _, D >= i && t.isEmpty(l + 1) ? t.line = Math.min(t.line + 2, r) : t.md.block.tokenize(t, l, r, !0), (!t.tight || b) && (u = !1), b = t.line - l > 1 && t.isEmpty(t.line - 1), t.blkIndent = t.listIndent, t.listIndent = I, t.tShift[l] = R, t.sCount[l] = N, t.tight = z, a = t.push("list_item_close", "li", -1), a.markup = String.fromCharCode(g), l = t.line, M[1] = l, l >= r || t.sCount[l] < t.blkIndent || t.sCount[l] - t.blkIndent >= 4)
      break;
    let B = !1;
    for (let $ = 0, q = k.length; $ < q; $++)
      if (k[$](t, l, r, !0)) {
        B = !0;
        break;
      }
    if (B)
      break;
    if (h) {
      if (p = x7(t, l), p < 0)
        break;
      s = t.bMarks[l] + t.tShift[l];
    } else if (p = b7(t, l), p < 0)
      break;
    if (g !== t.src.charCodeAt(p - 1))
      break;
  }
  return h ? a = t.push("ordered_list_close", "ol", -1) : a = t.push("bullet_list_close", "ul", -1), a.markup = String.fromCharCode(g), y[1] = l, t.line = l, t.parentType = C, u && sle(t, v), !0;
}
function lle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e], s = e + 1;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 91)
    return !1;
  function a(k) {
    const C = t.lineMax;
    if (k >= C || t.isEmpty(k))
      return null;
    let S = !1;
    if (t.sCount[k] - t.blkIndent > 3 && (S = !0), t.sCount[k] < 0 && (S = !0), !S) {
      const A = t.md.block.ruler.getRules("reference"), O = t.parentType;
      t.parentType = "reference";
      let M = !1;
      for (let z = 0, R = A.length; z < R; z++)
        if (A[z](t, k, C, !0)) {
          M = !0;
          break;
        }
      if (t.parentType = O, M)
        return null;
    }
    const _ = t.bMarks[k] + t.tShift[k], D = t.eMarks[k];
    return t.src.slice(_, D + 1);
  }
  let l = t.src.slice(i, o + 1);
  o = l.length;
  let u = -1;
  for (i = 1; i < o; i++) {
    const k = l.charCodeAt(i);
    if (k === 91)
      return !1;
    if (k === 93) {
      u = i;
      break;
    } else if (k === 10) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    } else if (k === 92 && (i++, i < o && l.charCodeAt(i) === 10)) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    }
  }
  if (u < 0 || l.charCodeAt(u + 1) !== 58)
    return !1;
  for (i = u + 2; i < o; i++) {
    const k = l.charCodeAt(i);
    if (k === 10) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    } else if (!Pr(k)) break;
  }
  const c = t.md.helpers.parseLinkDestination(l, i, o);
  if (!c.ok)
    return !1;
  const h = t.md.normalizeLink(c.str);
  if (!t.md.validateLink(h))
    return !1;
  i = c.pos;
  const d = i, p = s, g = i;
  for (; i < o; i++) {
    const k = l.charCodeAt(i);
    if (k === 10) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    } else if (!Pr(k)) break;
  }
  let v = t.md.helpers.parseLinkTitle(l, i, o);
  for (; v.can_continue; ) {
    const k = a(s);
    if (k === null) break;
    l += k, i = o, o = l.length, s++, v = t.md.helpers.parseLinkTitle(l, i, o, v);
  }
  let y;
  for (i < o && g !== i && v.ok ? (y = v.str, i = v.pos) : (y = "", i = d, s = p); i < o; ) {
    const k = l.charCodeAt(i);
    if (!Pr(k))
      break;
    i++;
  }
  if (i < o && l.charCodeAt(i) !== 10 && y)
    for (y = "", i = d, s = p; i < o; ) {
      const k = l.charCodeAt(i);
      if (!Pr(k))
        break;
      i++;
    }
  if (i < o && l.charCodeAt(i) !== 10)
    return !1;
  const b = Qb(l.slice(1, u));
  return b ? (n || (typeof t.env.references > "u" && (t.env.references = {}), typeof t.env.references[b] > "u" && (t.env.references[b] = { title: y, href: h }), t.line = s), !0) : !1;
}
const ule = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], cle = "[a-zA-Z_:][a-zA-Z0-9:._-]*", hle = "[^\"'=<>`\\x00-\\x20]+", fle = "'[^']*'", dle = '"[^"]*"', ple = "(?:" + hle + "|" + fle + "|" + dle + ")", mle = "(?:\\s+" + cle + "(?:\\s*=\\s*" + ple + ")?)", zN = "<[A-Za-z][A-Za-z0-9\\-]*" + mle + "*\\s*\\/?>", jN = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", gle = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", vle = "<[?][\\s\\S]*?[?]>", yle = "<![A-Za-z][^>]*>", ble = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", xle = new RegExp("^(?:" + zN + "|" + jN + "|" + gle + "|" + vle + "|" + yle + "|" + ble + ")"), wle = new RegExp("^(?:" + zN + "|" + jN + ")"), yf = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + ule.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(wle.source + "\\s*$"), /^$/, !1]
];
function kle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || !t.md.options.html || t.src.charCodeAt(i) !== 60)
    return !1;
  let s = t.src.slice(i, o), a = 0;
  for (; a < yf.length && !yf[a][0].test(s); a++)
    ;
  if (a === yf.length)
    return !1;
  if (n)
    return yf[a][2];
  let l = e + 1;
  if (!yf[a][1].test(s)) {
    for (; l < r && !(t.sCount[l] < t.blkIndent); l++)
      if (i = t.bMarks[l] + t.tShift[l], o = t.eMarks[l], s = t.src.slice(i, o), yf[a][1].test(s)) {
        s.length !== 0 && l++;
        break;
      }
  }
  t.line = l;
  const u = t.push("html_block", "", 0);
  return u.map = [e, l], u.content = t.getLines(e, l, t.blkIndent, !0), !0;
}
function Cle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let s = t.src.charCodeAt(i);
  if (s !== 35 || i >= o)
    return !1;
  let a = 1;
  for (s = t.src.charCodeAt(++i); s === 35 && i < o && a <= 6; )
    a++, s = t.src.charCodeAt(++i);
  if (a > 6 || i < o && !Pr(s))
    return !1;
  if (n)
    return !0;
  o = t.skipSpacesBack(o, i);
  const l = t.skipCharsBack(o, 35, i);
  l > i && Pr(t.src.charCodeAt(l - 1)) && (o = l), t.line = e + 1;
  const u = t.push("heading_open", "h" + String(a), 1);
  u.markup = "########".slice(0, a), u.map = [e, t.line];
  const c = t.push("inline", "", 0);
  c.content = t.src.slice(i, o).trim(), c.map = [e, t.line], c.children = [];
  const h = t.push("heading_close", "h" + String(a), -1);
  return h.markup = "########".slice(0, a), !0;
}
function _le(t, e, r) {
  const n = t.md.block.ruler.getRules("paragraph");
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  const i = t.parentType;
  t.parentType = "paragraph";
  let o = 0, s, a = e + 1;
  for (; a < r && !t.isEmpty(a); a++) {
    if (t.sCount[a] - t.blkIndent > 3)
      continue;
    if (t.sCount[a] >= t.blkIndent) {
      let p = t.bMarks[a] + t.tShift[a];
      const g = t.eMarks[a];
      if (p < g && (s = t.src.charCodeAt(p), (s === 45 || s === 61) && (p = t.skipChars(p, s), p = t.skipSpaces(p), p >= g))) {
        o = s === 61 ? 1 : 2;
        break;
      }
    }
    if (t.sCount[a] < 0)
      continue;
    let d = !1;
    for (let p = 0, g = n.length; p < g; p++)
      if (n[p](t, a, r, !0)) {
        d = !0;
        break;
      }
    if (d)
      break;
  }
  if (!o)
    return !1;
  const l = t.getLines(e, a, t.blkIndent, !1).trim();
  t.line = a + 1;
  const u = t.push("heading_open", "h" + String(o), 1);
  u.markup = String.fromCharCode(s), u.map = [e, t.line];
  const c = t.push("inline", "", 0);
  c.content = l, c.map = [e, t.line - 1], c.children = [];
  const h = t.push("heading_close", "h" + String(o), -1);
  return h.markup = String.fromCharCode(s), t.parentType = i, !0;
}
function Sle(t, e, r) {
  const n = t.md.block.ruler.getRules("paragraph"), i = t.parentType;
  let o = e + 1;
  for (t.parentType = "paragraph"; o < r && !t.isEmpty(o); o++) {
    if (t.sCount[o] - t.blkIndent > 3 || t.sCount[o] < 0)
      continue;
    let u = !1;
    for (let c = 0, h = n.length; c < h; c++)
      if (n[c](t, o, r, !0)) {
        u = !0;
        break;
      }
    if (u)
      break;
  }
  const s = t.getLines(e, o, t.blkIndent, !1).trim();
  t.line = o;
  const a = t.push("paragraph_open", "p", 1);
  a.map = [e, t.line];
  const l = t.push("inline", "", 0);
  return l.content = s, l.map = [e, t.line], l.children = [], t.push("paragraph_close", "p", -1), t.parentType = i, !0;
}
const Yv = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", tle, ["paragraph", "reference"]],
  ["code", rle],
  ["fence", nle, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", ile, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", ole, ["paragraph", "reference", "blockquote", "list"]],
  ["list", ale, ["paragraph", "reference", "blockquote"]],
  ["reference", lle],
  ["html_block", kle, ["paragraph", "reference", "blockquote"]],
  ["heading", Cle, ["paragraph", "reference", "blockquote"]],
  ["lheading", _le],
  ["paragraph", Sle]
];
function Xb() {
  this.ruler = new co();
  for (let t = 0; t < Yv.length; t++)
    this.ruler.push(Yv[t][0], Yv[t][1], { alt: (Yv[t][2] || []).slice() });
}
Xb.prototype.tokenize = function(t, e, r) {
  const n = this.ruler.getRules(""), i = n.length, o = t.md.options.maxNesting;
  let s = e, a = !1;
  for (; s < r && (t.line = s = t.skipEmptyLines(s), !(s >= r || t.sCount[s] < t.blkIndent)); ) {
    if (t.level >= o) {
      t.line = r;
      break;
    }
    const l = t.line;
    let u = !1;
    for (let c = 0; c < i; c++)
      if (u = n[c](t, s, r, !1), u) {
        if (l >= t.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!u) throw new Error("none of the block rules matched");
    t.tight = !a, t.isEmpty(t.line - 1) && (a = !0), s = t.line, s < r && t.isEmpty(s) && (a = !0, s++, t.line = s);
  }
};
Xb.prototype.parse = function(t, e, r, n) {
  if (!t)
    return;
  const i = new this.State(t, e, r, n);
  this.tokenize(i, i.line, i.lineMax);
};
Xb.prototype.State = ll;
function s0(t, e, r, n) {
  this.src = t, this.env = r, this.md = e, this.tokens = n, this.tokens_meta = Array(n.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
s0.prototype.pushPending = function() {
  const t = new sa("text", "", 0);
  return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t;
};
s0.prototype.push = function(t, e, r) {
  this.pending && this.pushPending();
  const n = new sa(t, e, r);
  let i = null;
  return r < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), n.level = this.level, r > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(n), this.tokens_meta.push(i), n;
};
s0.prototype.scanDelims = function(t, e) {
  const r = this.posMax, n = this.src.charCodeAt(t), i = t > 0 ? this.src.charCodeAt(t - 1) : 32;
  let o = t;
  for (; o < r && this.src.charCodeAt(o) === n; )
    o++;
  const s = o - t, a = o < r ? this.src.charCodeAt(o) : 32, l = bg(i) || yg(String.fromCharCode(i)), u = bg(a) || yg(String.fromCharCode(a)), c = vg(i), h = vg(a), d = !h && (!u || c || l), p = !c && (!l || h || u);
  return { can_open: d && (e || !p || l), can_close: p && (e || !d || u), length: s };
};
s0.prototype.Token = sa;
function Ale(t) {
  switch (t) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function Ele(t, e) {
  let r = t.pos;
  for (; r < t.posMax && !Ale(t.src.charCodeAt(r)); )
    r++;
  return r === t.pos ? !1 : (e || (t.pending += t.src.slice(t.pos, r)), t.pos = r, !0);
}
const Dle = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function Ole(t, e) {
  if (!t.md.options.linkify || t.linkLevel > 0) return !1;
  const r = t.pos, n = t.posMax;
  if (r + 3 > n || t.src.charCodeAt(r) !== 58 || t.src.charCodeAt(r + 1) !== 47 || t.src.charCodeAt(r + 2) !== 47) return !1;
  const i = t.pending.match(Dle);
  if (!i) return !1;
  const o = i[1], s = t.md.linkify.matchAtStart(t.src.slice(r - o.length));
  if (!s) return !1;
  let a = s.url;
  if (a.length <= o.length) return !1;
  a = a.replace(/\*+$/, "");
  const l = t.md.normalizeLink(a);
  if (!t.md.validateLink(l)) return !1;
  if (!e) {
    t.pending = t.pending.slice(0, -o.length);
    const u = t.push("link_open", "a", 1);
    u.attrs = [["href", l]], u.markup = "linkify", u.info = "auto";
    const c = t.push("text", "", 0);
    c.content = t.md.normalizeLinkText(a);
    const h = t.push("link_close", "a", -1);
    h.markup = "linkify", h.info = "auto";
  }
  return t.pos += a.length - o.length, !0;
}
function Fle(t, e) {
  let r = t.pos;
  if (t.src.charCodeAt(r) !== 10)
    return !1;
  const n = t.pending.length - 1, i = t.posMax;
  if (!e)
    if (n >= 0 && t.pending.charCodeAt(n) === 32)
      if (n >= 1 && t.pending.charCodeAt(n - 1) === 32) {
        let o = n - 1;
        for (; o >= 1 && t.pending.charCodeAt(o - 1) === 32; ) o--;
        t.pending = t.pending.slice(0, o), t.push("hardbreak", "br", 0);
      } else
        t.pending = t.pending.slice(0, -1), t.push("softbreak", "br", 0);
    else
      t.push("softbreak", "br", 0);
  for (r++; r < i && Pr(t.src.charCodeAt(r)); )
    r++;
  return t.pos = r, !0;
}
const Y4 = [];
for (let t = 0; t < 256; t++)
  Y4.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t) {
  Y4[t.charCodeAt(0)] = 1;
});
function Tle(t, e) {
  let r = t.pos;
  const n = t.posMax;
  if (t.src.charCodeAt(r) !== 92 || (r++, r >= n)) return !1;
  let i = t.src.charCodeAt(r);
  if (i === 10) {
    for (e || t.push("hardbreak", "br", 0), r++; r < n && (i = t.src.charCodeAt(r), !!Pr(i)); )
      r++;
    return t.pos = r, !0;
  }
  let o = t.src[r];
  if (i >= 55296 && i <= 56319 && r + 1 < n) {
    const a = t.src.charCodeAt(r + 1);
    a >= 56320 && a <= 57343 && (o += t.src[r + 1], r++);
  }
  const s = "\\" + o;
  if (!e) {
    const a = t.push("text_special", "", 0);
    i < 256 && Y4[i] !== 0 ? a.content = o : a.content = s, a.markup = s, a.info = "escape";
  }
  return t.pos = r + 1, !0;
}
function Mle(t, e) {
  let r = t.pos;
  if (t.src.charCodeAt(r) !== 96)
    return !1;
  const n = r;
  r++;
  const i = t.posMax;
  for (; r < i && t.src.charCodeAt(r) === 96; )
    r++;
  const o = t.src.slice(n, r), s = o.length;
  if (t.backticksScanned && (t.backticks[s] || 0) <= n)
    return e || (t.pending += o), t.pos += s, !0;
  let a = r, l;
  for (; (l = t.src.indexOf("`", a)) !== -1; ) {
    for (a = l + 1; a < i && t.src.charCodeAt(a) === 96; )
      a++;
    const u = a - l;
    if (u === s) {
      if (!e) {
        const c = t.push("code_inline", "code", 0);
        c.markup = o, c.content = t.src.slice(r, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return t.pos = a, !0;
    }
    t.backticks[u] = l;
  }
  return t.backticksScanned = !0, e || (t.pending += o), t.pos += s, !0;
}
function Ple(t, e) {
  const r = t.pos, n = t.src.charCodeAt(r);
  if (e || n !== 126)
    return !1;
  const i = t.scanDelims(t.pos, !0);
  let o = i.length;
  const s = String.fromCharCode(n);
  if (o < 2)
    return !1;
  let a;
  o % 2 && (a = t.push("text", "", 0), a.content = s, o--);
  for (let l = 0; l < o; l += 2)
    a = t.push("text", "", 0), a.content = s + s, t.delimiters.push({
      marker: n,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: t.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return t.pos += i.length, !0;
}
function w7(t, e) {
  let r;
  const n = [], i = e.length;
  for (let o = 0; o < i; o++) {
    const s = e[o];
    if (s.marker !== 126 || s.end === -1)
      continue;
    const a = e[s.end];
    r = t.tokens[s.token], r.type = "s_open", r.tag = "s", r.nesting = 1, r.markup = "~~", r.content = "", r = t.tokens[a.token], r.type = "s_close", r.tag = "s", r.nesting = -1, r.markup = "~~", r.content = "", t.tokens[a.token - 1].type === "text" && t.tokens[a.token - 1].content === "~" && n.push(a.token - 1);
  }
  for (; n.length; ) {
    const o = n.pop();
    let s = o + 1;
    for (; s < t.tokens.length && t.tokens[s].type === "s_close"; )
      s++;
    s--, o !== s && (r = t.tokens[s], t.tokens[s] = t.tokens[o], t.tokens[o] = r);
  }
}
function Rle(t) {
  const e = t.tokens_meta, r = t.tokens_meta.length;
  w7(t, t.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && w7(t, e[n].delimiters);
}
const qN = {
  tokenize: Ple,
  postProcess: Rle
};
function Nle(t, e) {
  const r = t.pos, n = t.src.charCodeAt(r);
  if (e || n !== 95 && n !== 42)
    return !1;
  const i = t.scanDelims(t.pos, n === 42);
  for (let o = 0; o < i.length; o++) {
    const s = t.push("text", "", 0);
    s.content = String.fromCharCode(n), t.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: n,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: t.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  }
  return t.pos += i.length, !0;
}
function k7(t, e) {
  const r = e.length;
  for (let n = r - 1; n >= 0; n--) {
    const i = e[n];
    if (i.marker !== 95 && i.marker !== 42 || i.end === -1)
      continue;
    const o = e[i.end], s = n > 0 && e[n - 1].end === i.end + 1 && // check that first two markers match and adjacent
    e[n - 1].marker === i.marker && e[n - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[i.end + 1].token === o.token + 1, a = String.fromCharCode(i.marker), l = t.tokens[i.token];
    l.type = s ? "strong_open" : "em_open", l.tag = s ? "strong" : "em", l.nesting = 1, l.markup = s ? a + a : a, l.content = "";
    const u = t.tokens[o.token];
    u.type = s ? "strong_close" : "em_close", u.tag = s ? "strong" : "em", u.nesting = -1, u.markup = s ? a + a : a, u.content = "", s && (t.tokens[e[n - 1].token].content = "", t.tokens[e[i.end + 1].token].content = "", n--);
  }
}
function $le(t) {
  const e = t.tokens_meta, r = t.tokens_meta.length;
  k7(t, t.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && k7(t, e[n].delimiters);
}
const UN = {
  tokenize: Nle,
  postProcess: $le
};
function Ile(t, e) {
  let r, n, i, o, s = "", a = "", l = t.pos, u = !0;
  if (t.src.charCodeAt(t.pos) !== 91)
    return !1;
  const c = t.pos, h = t.posMax, d = t.pos + 1, p = t.md.helpers.parseLinkLabel(t, t.pos, !0);
  if (p < 0)
    return !1;
  let g = p + 1;
  if (g < h && t.src.charCodeAt(g) === 40) {
    for (u = !1, g++; g < h && (r = t.src.charCodeAt(g), !(!Pr(r) && r !== 10)); g++)
      ;
    if (g >= h)
      return !1;
    if (l = g, i = t.md.helpers.parseLinkDestination(t.src, g, t.posMax), i.ok) {
      for (s = t.md.normalizeLink(i.str), t.md.validateLink(s) ? g = i.pos : s = "", l = g; g < h && (r = t.src.charCodeAt(g), !(!Pr(r) && r !== 10)); g++)
        ;
      if (i = t.md.helpers.parseLinkTitle(t.src, g, t.posMax), g < h && l !== g && i.ok)
        for (a = i.str, g = i.pos; g < h && (r = t.src.charCodeAt(g), !(!Pr(r) && r !== 10)); g++)
          ;
    }
    (g >= h || t.src.charCodeAt(g) !== 41) && (u = !0), g++;
  }
  if (u) {
    if (typeof t.env.references > "u")
      return !1;
    if (g < h && t.src.charCodeAt(g) === 91 ? (l = g + 1, g = t.md.helpers.parseLinkLabel(t, g), g >= 0 ? n = t.src.slice(l, g++) : g = p + 1) : g = p + 1, n || (n = t.src.slice(d, p)), o = t.env.references[Qb(n)], !o)
      return t.pos = c, !1;
    s = o.href, a = o.title;
  }
  if (!e) {
    t.pos = d, t.posMax = p;
    const v = t.push("link_open", "a", 1), y = [["href", s]];
    v.attrs = y, a && y.push(["title", a]), t.linkLevel++, t.md.inline.tokenize(t), t.linkLevel--, t.push("link_close", "a", -1);
  }
  return t.pos = g, t.posMax = h, !0;
}
function Ble(t, e) {
  let r, n, i, o, s, a, l, u, c = "";
  const h = t.pos, d = t.posMax;
  if (t.src.charCodeAt(t.pos) !== 33 || t.src.charCodeAt(t.pos + 1) !== 91)
    return !1;
  const p = t.pos + 2, g = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1);
  if (g < 0)
    return !1;
  if (o = g + 1, o < d && t.src.charCodeAt(o) === 40) {
    for (o++; o < d && (r = t.src.charCodeAt(o), !(!Pr(r) && r !== 10)); o++)
      ;
    if (o >= d)
      return !1;
    for (u = o, a = t.md.helpers.parseLinkDestination(t.src, o, t.posMax), a.ok && (c = t.md.normalizeLink(a.str), t.md.validateLink(c) ? o = a.pos : c = ""), u = o; o < d && (r = t.src.charCodeAt(o), !(!Pr(r) && r !== 10)); o++)
      ;
    if (a = t.md.helpers.parseLinkTitle(t.src, o, t.posMax), o < d && u !== o && a.ok)
      for (l = a.str, o = a.pos; o < d && (r = t.src.charCodeAt(o), !(!Pr(r) && r !== 10)); o++)
        ;
    else
      l = "";
    if (o >= d || t.src.charCodeAt(o) !== 41)
      return t.pos = h, !1;
    o++;
  } else {
    if (typeof t.env.references > "u")
      return !1;
    if (o < d && t.src.charCodeAt(o) === 91 ? (u = o + 1, o = t.md.helpers.parseLinkLabel(t, o), o >= 0 ? i = t.src.slice(u, o++) : o = g + 1) : o = g + 1, i || (i = t.src.slice(p, g)), s = t.env.references[Qb(i)], !s)
      return t.pos = h, !1;
    c = s.href, l = s.title;
  }
  if (!e) {
    n = t.src.slice(p, g);
    const v = [];
    t.md.inline.parse(
      n,
      t.md,
      t.env,
      v
    );
    const y = t.push("image", "img", 0), b = [["src", c], ["alt", ""]];
    y.attrs = b, y.children = v, y.content = n, l && b.push(["title", l]);
  }
  return t.pos = o, t.posMax = d, !0;
}
const Lle = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, zle = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function jle(t, e) {
  let r = t.pos;
  if (t.src.charCodeAt(r) !== 60)
    return !1;
  const n = t.pos, i = t.posMax;
  for (; ; ) {
    if (++r >= i) return !1;
    const s = t.src.charCodeAt(r);
    if (s === 60) return !1;
    if (s === 62) break;
  }
  const o = t.src.slice(n + 1, r);
  if (zle.test(o)) {
    const s = t.md.normalizeLink(o);
    if (!t.md.validateLink(s))
      return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      a.attrs = [["href", s]], a.markup = "autolink", a.info = "auto";
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(o);
      const u = t.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return t.pos += o.length + 2, !0;
  }
  if (Lle.test(o)) {
    const s = t.md.normalizeLink("mailto:" + o);
    if (!t.md.validateLink(s))
      return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      a.attrs = [["href", s]], a.markup = "autolink", a.info = "auto";
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(o);
      const u = t.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return t.pos += o.length + 2, !0;
  }
  return !1;
}
function qle(t) {
  return /^<a[>\s]/i.test(t);
}
function Ule(t) {
  return /^<\/a\s*>/i.test(t);
}
function Hle(t) {
  const e = t | 32;
  return e >= 97 && e <= 122;
}
function Vle(t, e) {
  if (!t.md.options.html)
    return !1;
  const r = t.posMax, n = t.pos;
  if (t.src.charCodeAt(n) !== 60 || n + 2 >= r)
    return !1;
  const i = t.src.charCodeAt(n + 1);
  if (i !== 33 && i !== 63 && i !== 47 && !Hle(i))
    return !1;
  const o = t.src.slice(n).match(xle);
  if (!o)
    return !1;
  if (!e) {
    const s = t.push("html_inline", "", 0);
    s.content = o[0], qle(s.content) && t.linkLevel++, Ule(s.content) && t.linkLevel--;
  }
  return t.pos += o[0].length, !0;
}
const Wle = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, Gle = /^&([a-z][a-z0-9]{1,31});/i;
function Kle(t, e) {
  const r = t.pos, n = t.posMax;
  if (t.src.charCodeAt(r) !== 38 || r + 1 >= n) return !1;
  if (t.src.charCodeAt(r + 1) === 35) {
    const i = t.src.slice(r).match(Wle);
    if (i) {
      if (!e) {
        const o = i[1][0].toLowerCase() === "x" ? parseInt(i[1].slice(1), 16) : parseInt(i[1], 10), s = t.push("text_special", "", 0);
        s.content = X4(o) ? I1(o) : I1(65533), s.markup = i[0], s.info = "entity";
      }
      return t.pos += i[0].length, !0;
    }
  } else {
    const i = t.src.slice(r).match(Gle);
    if (i) {
      const o = NN(i[0]);
      if (o !== i[0]) {
        if (!e) {
          const s = t.push("text_special", "", 0);
          s.content = o, s.markup = i[0], s.info = "entity";
        }
        return t.pos += i[0].length, !0;
      }
    }
  }
  return !1;
}
function C7(t) {
  const e = {}, r = t.length;
  if (!r) return;
  let n = 0, i = -2;
  const o = [];
  for (let s = 0; s < r; s++) {
    const a = t[s];
    if (o.push(0), (t[n].marker !== a.marker || i !== a.token - 1) && (n = s), i = a.token, a.length = a.length || 0, !a.close) continue;
    e.hasOwnProperty(a.marker) || (e[a.marker] = [-1, -1, -1, -1, -1, -1]);
    const l = e[a.marker][(a.open ? 3 : 0) + a.length % 3];
    let u = n - o[n] - 1, c = u;
    for (; u > l; u -= o[u] + 1) {
      const h = t[u];
      if (h.marker === a.marker && h.open && h.end < 0) {
        let d = !1;
        if ((h.close || a.open) && (h.length + a.length) % 3 === 0 && (h.length % 3 !== 0 || a.length % 3 !== 0) && (d = !0), !d) {
          const p = u > 0 && !t[u - 1].open ? o[u - 1] + 1 : 0;
          o[s] = s - u + p, o[u] = p, a.open = !1, h.end = s, h.close = !1, c = -1, i = -2;
          break;
        }
      }
    }
    c !== -1 && (e[a.marker][(a.open ? 3 : 0) + (a.length || 0) % 3] = c);
  }
}
function Qle(t) {
  const e = t.tokens_meta, r = t.tokens_meta.length;
  C7(t.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && C7(e[n].delimiters);
}
function Xle(t) {
  let e, r, n = 0;
  const i = t.tokens, o = t.tokens.length;
  for (e = r = 0; e < o; e++)
    i[e].nesting < 0 && n--, i[e].level = n, i[e].nesting > 0 && n++, i[e].type === "text" && e + 1 < o && i[e + 1].type === "text" ? i[e + 1].content = i[e].content + i[e + 1].content : (e !== r && (i[r] = i[e]), r++);
  e !== r && (i.length = r);
}
const Y2 = [
  ["text", Ele],
  ["linkify", Ole],
  ["newline", Fle],
  ["escape", Tle],
  ["backticks", Mle],
  ["strikethrough", qN.tokenize],
  ["emphasis", UN.tokenize],
  ["link", Ile],
  ["image", Ble],
  ["autolink", jle],
  ["html_inline", Vle],
  ["entity", Kle]
], Z2 = [
  ["balance_pairs", Qle],
  ["strikethrough", qN.postProcess],
  ["emphasis", UN.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", Xle]
];
function a0() {
  this.ruler = new co();
  for (let t = 0; t < Y2.length; t++)
    this.ruler.push(Y2[t][0], Y2[t][1]);
  this.ruler2 = new co();
  for (let t = 0; t < Z2.length; t++)
    this.ruler2.push(Z2[t][0], Z2[t][1]);
}
a0.prototype.skipToken = function(t) {
  const e = t.pos, r = this.ruler.getRules(""), n = r.length, i = t.md.options.maxNesting, o = t.cache;
  if (typeof o[e] < "u") {
    t.pos = o[e];
    return;
  }
  let s = !1;
  if (t.level < i) {
    for (let a = 0; a < n; a++)
      if (t.level++, s = r[a](t, !0), t.level--, s) {
        if (e >= t.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    t.pos = t.posMax;
  s || t.pos++, o[e] = t.pos;
};
a0.prototype.tokenize = function(t) {
  const e = this.ruler.getRules(""), r = e.length, n = t.posMax, i = t.md.options.maxNesting;
  for (; t.pos < n; ) {
    const o = t.pos;
    let s = !1;
    if (t.level < i) {
      for (let a = 0; a < r; a++)
        if (s = e[a](t, !1), s) {
          if (o >= t.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (s) {
      if (t.pos >= n)
        break;
      continue;
    }
    t.pending += t.src[t.pos++];
  }
  t.pending && t.pushPending();
};
a0.prototype.parse = function(t, e, r, n) {
  const i = new this.State(t, e, r, n);
  this.tokenize(i);
  const o = this.ruler2.getRules(""), s = o.length;
  for (let a = 0; a < s; a++)
    o[a](i);
};
a0.prototype.State = s0;
function Jle(t) {
  const e = {};
  t = t || {}, e.src_Any = FN.source, e.src_Cc = TN.source, e.src_Z = PN.source, e.src_P = K4.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
  const r = "[><ï½œ]";
  return e.src_pseudo_letter = "(?:(?!" + r + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + r + "|" + e.src_ZPCc + ")(?!" + (t["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + r + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + r + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + e.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + e.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
}
function SC(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    e && Object.keys(e).forEach(function(r) {
      t[r] = e[r];
    });
  }), t;
}
function Jb(t) {
  return Object.prototype.toString.call(t);
}
function Yle(t) {
  return Jb(t) === "[object String]";
}
function Zle(t) {
  return Jb(t) === "[object Object]";
}
function eue(t) {
  return Jb(t) === "[object RegExp]";
}
function _7(t) {
  return Jb(t) === "[object Function]";
}
function tue(t) {
  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const HN = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function rue(t) {
  return Object.keys(t || {}).reduce(function(e, r) {
    return e || HN.hasOwnProperty(r);
  }, !1);
}
const nue = {
  "http:": {
    validate: function(t, e, r) {
      const n = t.slice(e);
      return r.re.http || (r.re.http = new RegExp(
        "^\\/\\/" + r.re.src_auth + r.re.src_host_port_strict + r.re.src_path,
        "i"
      )), r.re.http.test(n) ? n.match(r.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t, e, r) {
      const n = t.slice(e);
      return r.re.no_http || (r.re.no_http = new RegExp(
        "^" + r.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + r.re.src_domain + ")\\.)+" + r.re.src_domain_root + ")" + r.re.src_port + r.re.src_host_terminator + r.re.src_path,
        "i"
      )), r.re.no_http.test(n) ? e >= 3 && t[e - 3] === ":" || e >= 3 && t[e - 3] === "/" ? 0 : n.match(r.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t, e, r) {
      const n = t.slice(e);
      return r.re.mailto || (r.re.mailto = new RegExp(
        "^" + r.re.src_email_name + "@" + r.re.src_host_strict,
        "i"
      )), r.re.mailto.test(n) ? n.match(r.re.mailto)[0].length : 0;
    }
  }
}, iue = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", oue = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
function sue(t) {
  t.__index__ = -1, t.__text_cache__ = "";
}
function aue(t) {
  return function(e, r) {
    const n = e.slice(r);
    return t.test(n) ? n.match(t)[0].length : 0;
  };
}
function S7() {
  return function(t, e) {
    e.normalize(t);
  };
}
function B1(t) {
  const e = t.re = Jle(t.__opts__), r = t.__tlds__.slice();
  t.onCompile(), t.__tlds_replaced__ || r.push(iue), r.push(e.src_xn), e.src_tlds = r.join("|");
  function n(a) {
    return a.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(n(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(n(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(n(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(n(e.tpl_host_fuzzy_test), "i");
  const i = [];
  t.__compiled__ = {};
  function o(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(t.__schemas__).forEach(function(a) {
    const l = t.__schemas__[a];
    if (l === null)
      return;
    const u = { validate: null, link: null };
    if (t.__compiled__[a] = u, Zle(l)) {
      eue(l.validate) ? u.validate = aue(l.validate) : _7(l.validate) ? u.validate = l.validate : o(a, l), _7(l.normalize) ? u.normalize = l.normalize : l.normalize ? o(a, l) : u.normalize = S7();
      return;
    }
    if (Yle(l)) {
      i.push(a);
      return;
    }
    o(a, l);
  }), i.forEach(function(a) {
    t.__compiled__[t.__schemas__[a]] && (t.__compiled__[a].validate = t.__compiled__[t.__schemas__[a]].validate, t.__compiled__[a].normalize = t.__compiled__[t.__schemas__[a]].normalize);
  }), t.__compiled__[""] = { validate: null, normalize: S7() };
  const s = Object.keys(t.__compiled__).filter(function(a) {
    return a.length > 0 && t.__compiled__[a];
  }).map(tue).join("|");
  t.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + e.src_ZPCc + "))(" + s + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + e.src_ZPCc + "))(" + s + ")", "ig"), t.re.schema_at_start = RegExp("^" + t.re.schema_search.source, "i"), t.re.pretest = RegExp(
    "(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@",
    "i"
  ), sue(t);
}
function lue(t, e) {
  const r = t.__index__, n = t.__last_index__, i = t.__text_cache__.slice(r, n);
  this.schema = t.__schema__.toLowerCase(), this.index = r + e, this.lastIndex = n + e, this.raw = i, this.text = i, this.url = i;
}
function AC(t, e) {
  const r = new lue(t, e);
  return t.__compiled__[r.schema].normalize(r, t), r;
}
function Ko(t, e) {
  if (!(this instanceof Ko))
    return new Ko(t, e);
  e || rue(t) && (e = t, t = {}), this.__opts__ = SC({}, HN, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = SC({}, nue, t), this.__compiled__ = {}, this.__tlds__ = oue, this.__tlds_replaced__ = !1, this.re = {}, B1(this);
}
Ko.prototype.add = function(t, e) {
  return this.__schemas__[t] = e, B1(this), this;
};
Ko.prototype.set = function(t) {
  return this.__opts__ = SC(this.__opts__, t), this;
};
Ko.prototype.test = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length)
    return !1;
  let e, r, n, i, o, s, a, l, u;
  if (this.re.schema_test.test(t)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (e = a.exec(t)) !== null; )
      if (i = this.testSchemaAt(t, e[2], a.lastIndex), i) {
        this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + i;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = t.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = r.index + r[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = t.indexOf("@"), u >= 0 && (n = t.match(this.re.email_fuzzy)) !== null && (o = n.index + n[1].length, s = n.index + n[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = s))), this.__index__ >= 0;
};
Ko.prototype.pretest = function(t) {
  return this.re.pretest.test(t);
};
Ko.prototype.testSchemaAt = function(t, e, r) {
  return this.__compiled__[e.toLowerCase()] ? this.__compiled__[e.toLowerCase()].validate(t, r, this) : 0;
};
Ko.prototype.match = function(t) {
  const e = [];
  let r = 0;
  this.__index__ >= 0 && this.__text_cache__ === t && (e.push(AC(this, r)), r = this.__last_index__);
  let n = r ? t.slice(r) : t;
  for (; this.test(n); )
    e.push(AC(this, r)), n = n.slice(this.__last_index__), r += this.__last_index__;
  return e.length ? e : null;
};
Ko.prototype.matchAtStart = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return null;
  const e = this.re.schema_at_start.exec(t);
  if (!e) return null;
  const r = this.testSchemaAt(t, e[2], e[0].length);
  return r ? (this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + r, AC(this, 0)) : null;
};
Ko.prototype.tlds = function(t, e) {
  return t = Array.isArray(t) ? t : [t], e ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(r, n, i) {
    return r !== i[n - 1];
  }).reverse(), B1(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, B1(this), this);
};
Ko.prototype.normalize = function(t) {
  t.schema || (t.url = "http://" + t.url), t.schema === "mailto:" && !/^mailto:/i.test(t.url) && (t.url = "mailto:" + t.url);
};
Ko.prototype.onCompile = function() {
};
const Xf = 2147483647, $a = 36, Z4 = 1, xg = 26, uue = 38, cue = 700, VN = 72, WN = 128, GN = "-", hue = /^xn--/, fue = /[^\0-\x7F]/, due = /[\x2E\u3002\uFF0E\uFF61]/g, pue = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, ek = $a - Z4, Ia = Math.floor, tk = String.fromCharCode;
function Eu(t) {
  throw new RangeError(pue[t]);
}
function mue(t, e) {
  const r = [];
  let n = t.length;
  for (; n--; )
    r[n] = e(t[n]);
  return r;
}
function KN(t, e) {
  const r = t.split("@");
  let n = "";
  r.length > 1 && (n = r[0] + "@", t = r[1]), t = t.replace(due, ".");
  const i = t.split("."), o = mue(i, e).join(".");
  return n + o;
}
function QN(t) {
  const e = [];
  let r = 0;
  const n = t.length;
  for (; r < n; ) {
    const i = t.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      const o = t.charCodeAt(r++);
      (o & 64512) == 56320 ? e.push(((i & 1023) << 10) + (o & 1023) + 65536) : (e.push(i), r--);
    } else
      e.push(i);
  }
  return e;
}
const gue = (t) => String.fromCodePoint(...t), vue = function(t) {
  return t >= 48 && t < 58 ? 26 + (t - 48) : t >= 65 && t < 91 ? t - 65 : t >= 97 && t < 123 ? t - 97 : $a;
}, A7 = function(t, e) {
  return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
}, XN = function(t, e, r) {
  let n = 0;
  for (t = r ? Ia(t / cue) : t >> 1, t += Ia(t / e); t > ek * xg >> 1; n += $a)
    t = Ia(t / ek);
  return Ia(n + (ek + 1) * t / (t + uue));
}, JN = function(t) {
  const e = [], r = t.length;
  let n = 0, i = WN, o = VN, s = t.lastIndexOf(GN);
  s < 0 && (s = 0);
  for (let a = 0; a < s; ++a)
    t.charCodeAt(a) >= 128 && Eu("not-basic"), e.push(t.charCodeAt(a));
  for (let a = s > 0 ? s + 1 : 0; a < r; ) {
    const l = n;
    for (let c = 1, h = $a; ; h += $a) {
      a >= r && Eu("invalid-input");
      const d = vue(t.charCodeAt(a++));
      d >= $a && Eu("invalid-input"), d > Ia((Xf - n) / c) && Eu("overflow"), n += d * c;
      const p = h <= o ? Z4 : h >= o + xg ? xg : h - o;
      if (d < p)
        break;
      const g = $a - p;
      c > Ia(Xf / g) && Eu("overflow"), c *= g;
    }
    const u = e.length + 1;
    o = XN(n - l, u, l == 0), Ia(n / u) > Xf - i && Eu("overflow"), i += Ia(n / u), n %= u, e.splice(n++, 0, i);
  }
  return String.fromCodePoint(...e);
}, YN = function(t) {
  const e = [];
  t = QN(t);
  const r = t.length;
  let n = WN, i = 0, o = VN;
  for (const l of t)
    l < 128 && e.push(tk(l));
  const s = e.length;
  let a = s;
  for (s && e.push(GN); a < r; ) {
    let l = Xf;
    for (const c of t)
      c >= n && c < l && (l = c);
    const u = a + 1;
    l - n > Ia((Xf - i) / u) && Eu("overflow"), i += (l - n) * u, n = l;
    for (const c of t)
      if (c < n && ++i > Xf && Eu("overflow"), c === n) {
        let h = i;
        for (let d = $a; ; d += $a) {
          const p = d <= o ? Z4 : d >= o + xg ? xg : d - o;
          if (h < p)
            break;
          const g = h - p, v = $a - p;
          e.push(
            tk(A7(p + g % v, 0))
          ), h = Ia(g / v);
        }
        e.push(tk(A7(h, 0))), o = XN(i, u, a === s), i = 0, ++a;
      }
    ++i, ++n;
  }
  return e.join("");
}, yue = function(t) {
  return KN(t, function(e) {
    return hue.test(e) ? JN(e.slice(4).toLowerCase()) : e;
  });
}, bue = function(t) {
  return KN(t, function(e) {
    return fue.test(e) ? "xn--" + YN(e) : e;
  });
}, ZN = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: QN,
    encode: gue
  },
  decode: JN,
  encode: YN,
  toASCII: bue,
  toUnicode: yue
}, xue = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, wue = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, kue = {
  options: {
    // Enable HTML tags in source
    html: !0,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !0,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, Cue = {
  default: xue,
  zero: wue,
  commonmark: kue
}, _ue = /^(vbscript|javascript|file|data):/, Sue = /^data:image\/(gif|png|jpeg|webp);/;
function Aue(t) {
  const e = t.trim().toLowerCase();
  return _ue.test(e) ? Sue.test(e) : !0;
}
const e$ = ["http:", "https:", "mailto:"];
function Eue(t) {
  const e = G4(t, !0);
  if (e.hostname && (!e.protocol || e$.indexOf(e.protocol) >= 0))
    try {
      e.hostname = ZN.toASCII(e.hostname);
    } catch {
    }
  return o0(W4(e));
}
function Due(t) {
  const e = G4(t, !0);
  if (e.hostname && (!e.protocol || e$.indexOf(e.protocol) >= 0))
    try {
      e.hostname = ZN.toUnicode(e.hostname);
    } catch {
    }
  return Dd(W4(e), Dd.defaultChars + "%");
}
function ws(t, e) {
  if (!(this instanceof ws))
    return new ws(t, e);
  e || Q4(t) || (e = t || {}, t = "default"), this.inline = new a0(), this.block = new Xb(), this.core = new J4(), this.renderer = new tp(), this.linkify = new Ko(), this.validateLink = Aue, this.normalizeLink = Eue, this.normalizeLinkText = Due, this.utils = Fae, this.helpers = Kb({}, Rae), this.options = {}, this.configure(t), e && this.set(e);
}
ws.prototype.set = function(t) {
  return Kb(this.options, t), this;
};
ws.prototype.configure = function(t) {
  const e = this;
  if (Q4(t)) {
    const r = t;
    if (t = Cue[r], !t)
      throw new Error('Wrong `markdown-it` preset "' + r + '", check name');
  }
  if (!t)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t.options && e.set(t.options), t.components && Object.keys(t.components).forEach(function(r) {
    t.components[r].rules && e[r].ruler.enableOnly(t.components[r].rules), t.components[r].rules2 && e[r].ruler2.enableOnly(t.components[r].rules2);
  }), this;
};
ws.prototype.enable = function(t, e) {
  let r = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.enable(t, !0));
  }, this), r = r.concat(this.inline.ruler2.enable(t, !0));
  const n = t.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + n);
  return this;
};
ws.prototype.disable = function(t, e) {
  let r = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.disable(t, !0));
  }, this), r = r.concat(this.inline.ruler2.disable(t, !0));
  const n = t.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + n);
  return this;
};
ws.prototype.use = function(t) {
  const e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t.apply(t, e), this;
};
ws.prototype.parse = function(t, e) {
  if (typeof t != "string")
    throw new Error("Input data should be a String");
  const r = new this.core.State(t, this, e);
  return this.core.process(r), r.tokens;
};
ws.prototype.render = function(t, e) {
  return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e);
};
ws.prototype.parseInline = function(t, e) {
  const r = new this.core.State(t, this, e);
  return r.inlineMode = !0, this.core.process(r), r.tokens;
};
ws.prototype.renderInline = function(t, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e);
};
function Oue(t, e, r) {
  const {
    parseMetaString: n,
    trimEndingNewline: i = !0,
    defaultLanguage: o = "text",
    fallbackLanguage: s
  } = r, a = e.getLoadedLanguages();
  t.options.highlight = (l, u = "text", c) => {
    u === "" && (u = o), s && !a.includes(u) && (u = s);
    const h = n?.(c, l, u) || {}, d = {
      ...r,
      lang: u,
      meta: {
        ...r.meta,
        ...h,
        __raw: c
      }
    }, p = [];
    return p.push({
      name: "@shikijs/markdown-it:block-class",
      code(g) {
        g.properties.class = `language-${u}`;
      }
    }), i && l.endsWith(`
`) && (l = l.slice(0, -1)), e.codeToHtml(
      l,
      {
        ...d,
        transformers: [
          ...p,
          ...d.transformers || []
        ]
      }
    );
  };
}
function Fue(t, e) {
  return function(r) {
    Oue(r, t, e);
  };
}
let sh = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
}, eS = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function Tue() {
  return 2147483648;
}
function Mue() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const Pue = (t, e) => t + (e - t % e) % e;
async function Rue(t) {
  let e, r;
  const n = {};
  function i(p) {
    r = p, n.HEAPU8 = new Uint8Array(p), n.HEAPU32 = new Uint32Array(p);
  }
  function o(p, g, v) {
    n.HEAPU8.copyWithin(p, g, g + v);
  }
  function s(p) {
    try {
      return e.grow(p - r.byteLength + 65535 >>> 16), i(e.buffer), 1;
    } catch {
    }
  }
  function a(p) {
    const g = n.HEAPU8.length;
    p = p >>> 0;
    const v = Tue();
    if (p > v)
      return !1;
    for (let y = 1; y <= 4; y *= 2) {
      let b = g * (1 + 0.2 / y);
      b = Math.min(b, p + 100663296);
      const k = Math.min(v, Pue(Math.max(p, b), 65536));
      if (s(k))
        return !0;
    }
    return !1;
  }
  const l = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function u(p, g, v = 1024) {
    const y = g + v;
    let b = g;
    for (; p[b] && !(b >= y); )
      ++b;
    if (b - g > 16 && p.buffer && l)
      return l.decode(p.subarray(g, b));
    let k = "";
    for (; g < b; ) {
      let C = p[g++];
      if (!(C & 128)) {
        k += String.fromCharCode(C);
        continue;
      }
      const S = p[g++] & 63;
      if ((C & 224) === 192) {
        k += String.fromCharCode((C & 31) << 6 | S);
        continue;
      }
      const _ = p[g++] & 63;
      if ((C & 240) === 224 ? C = (C & 15) << 12 | S << 6 | _ : C = (C & 7) << 18 | S << 12 | _ << 6 | p[g++] & 63, C < 65536)
        k += String.fromCharCode(C);
      else {
        const D = C - 65536;
        k += String.fromCharCode(55296 | D >> 10, 56320 | D & 1023);
      }
    }
    return k;
  }
  function c(p, g) {
    return p ? u(n.HEAPU8, p, g) : "";
  }
  const h = {
    emscripten_get_now: Mue,
    emscripten_memcpy_big: o,
    emscripten_resize_heap: a,
    fd_write: () => 0
  };
  async function d() {
    const p = await t({
      env: h,
      wasi_snapshot_preview1: h
    });
    e = p.memory, i(e.buffer), Object.assign(n, p), n.UTF8ToString = c;
  }
  return await d(), n;
}
var Nue = Object.defineProperty, $ue = (t, e, r) => e in t ? Nue(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, An = (t, e, r) => ($ue(t, typeof e != "symbol" ? e + "" : e, r), r);
let Pn = null;
function Iue(t) {
  throw new eS(t.UTF8ToString(t.getLastOnigError()));
}
class Yb {
  constructor(e) {
    An(this, "utf16Length"), An(this, "utf8Length"), An(this, "utf16Value"), An(this, "utf8Value"), An(this, "utf16OffsetToUtf8"), An(this, "utf8OffsetToUtf16");
    const r = e.length, n = Yb._utf8ByteLength(e), i = n !== r, o = i ? new Uint32Array(r + 1) : null;
    i && (o[r] = n);
    const s = i ? new Uint32Array(n + 1) : null;
    i && (s[n] = r);
    const a = new Uint8Array(n);
    let l = 0;
    for (let u = 0; u < r; u++) {
      const c = e.charCodeAt(u);
      let h = c, d = !1;
      if (c >= 55296 && c <= 56319 && u + 1 < r) {
        const p = e.charCodeAt(u + 1);
        p >= 56320 && p <= 57343 && (h = (c - 55296 << 10) + 65536 | p - 56320, d = !0);
      }
      i && (o[u] = l, d && (o[u + 1] = l), h <= 127 ? s[l + 0] = u : h <= 2047 ? (s[l + 0] = u, s[l + 1] = u) : h <= 65535 ? (s[l + 0] = u, s[l + 1] = u, s[l + 2] = u) : (s[l + 0] = u, s[l + 1] = u, s[l + 2] = u, s[l + 3] = u)), h <= 127 ? a[l++] = h : h <= 2047 ? (a[l++] = 192 | (h & 1984) >>> 6, a[l++] = 128 | (h & 63) >>> 0) : h <= 65535 ? (a[l++] = 224 | (h & 61440) >>> 12, a[l++] = 128 | (h & 4032) >>> 6, a[l++] = 128 | (h & 63) >>> 0) : (a[l++] = 240 | (h & 1835008) >>> 18, a[l++] = 128 | (h & 258048) >>> 12, a[l++] = 128 | (h & 4032) >>> 6, a[l++] = 128 | (h & 63) >>> 0), d && u++;
    }
    this.utf16Length = r, this.utf8Length = n, this.utf16Value = e, this.utf8Value = a, this.utf16OffsetToUtf8 = o, this.utf8OffsetToUtf16 = s;
  }
  static _utf8ByteLength(e) {
    let r = 0;
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e.charCodeAt(n);
      let s = o, a = !1;
      if (o >= 55296 && o <= 56319 && n + 1 < i) {
        const l = e.charCodeAt(n + 1);
        l >= 56320 && l <= 57343 && (s = (o - 55296 << 10) + 65536 | l - 56320, a = !0);
      }
      s <= 127 ? r += 1 : s <= 2047 ? r += 2 : s <= 65535 ? r += 3 : r += 4, a && n++;
    }
    return r;
  }
  createString(e) {
    const r = e.omalloc(this.utf8Length);
    return e.HEAPU8.set(this.utf8Value, r), r;
  }
}
const va = class {
  constructor(t) {
    if (An(this, "id", ++va.LAST_ID), An(this, "_onigBinding"), An(this, "content"), An(this, "utf16Length"), An(this, "utf8Length"), An(this, "utf16OffsetToUtf8"), An(this, "utf8OffsetToUtf16"), An(this, "ptr"), !Pn)
      throw new eS("Must invoke loadWasm first.");
    this._onigBinding = Pn, this.content = t;
    const e = new Yb(t);
    this.utf16Length = e.utf16Length, this.utf8Length = e.utf8Length, this.utf16OffsetToUtf8 = e.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = e.utf8OffsetToUtf16, this.utf8Length < 1e4 && !va._sharedPtrInUse ? (va._sharedPtr || (va._sharedPtr = Pn.omalloc(1e4)), va._sharedPtrInUse = !0, Pn.HEAPU8.set(e.utf8Value, va._sharedPtr), this.ptr = va._sharedPtr) : this.ptr = e.createString(Pn);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === va._sharedPtr ? va._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
let l0 = va;
An(l0, "LAST_ID", 0);
An(l0, "_sharedPtr", 0);
An(l0, "_sharedPtrInUse", !1);
class Bue {
  constructor(e) {
    if (An(this, "_onigBinding"), An(this, "_ptr"), !Pn)
      throw new eS("Must invoke loadWasm first.");
    const r = [], n = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = new Yb(e[a]);
      r[a] = u.createString(Pn), n[a] = u.utf8Length;
    }
    const i = Pn.omalloc(4 * e.length);
    Pn.HEAPU32.set(r, i / 4);
    const o = Pn.omalloc(4 * e.length);
    Pn.HEAPU32.set(n, o / 4);
    const s = Pn.createOnigScanner(i, o, e.length);
    for (let a = 0, l = e.length; a < l; a++)
      Pn.ofree(r[a]);
    Pn.ofree(o), Pn.ofree(i), s === 0 && Iue(Pn), this._onigBinding = Pn, this._ptr = s;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(e, r, n) {
    let i = 0;
    if (typeof n == "number" && (i = n), typeof e == "string") {
      e = new l0(e);
      const o = this._findNextMatchSync(e, r, !1, i);
      return e.dispose(), o;
    }
    return this._findNextMatchSync(e, r, !1, i);
  }
  _findNextMatchSync(e, r, n, i) {
    const o = this._onigBinding, s = o.findNextOnigScannerMatch(this._ptr, e.id, e.ptr, e.utf8Length, e.convertUtf16OffsetToUtf8(r), i);
    if (s === 0)
      return null;
    const a = o.HEAPU32;
    let l = s / 4;
    const u = a[l++], c = a[l++], h = [];
    for (let d = 0; d < c; d++) {
      const p = e.convertUtf8OffsetToUtf16(a[l++]), g = e.convertUtf8OffsetToUtf16(a[l++]);
      h[d] = {
        start: p,
        end: g,
        length: g - p
      };
    }
    return {
      index: u,
      captureIndices: h
    };
  }
}
function Lue(t) {
  return typeof t.instantiator == "function";
}
function zue(t) {
  return typeof t.default == "function";
}
function jue(t) {
  return typeof t.data < "u";
}
function que(t) {
  return typeof Response < "u" && t instanceof Response;
}
function Uue(t) {
  return typeof ArrayBuffer < "u" && (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) || typeof Buffer < "u" && Buffer.isBuffer?.(t) || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer || typeof Uint32Array < "u" && t instanceof Uint32Array;
}
let Zv;
function Hue(t) {
  if (Zv)
    return Zv;
  async function e() {
    Pn = await Rue(async (r) => {
      let n = t;
      return n = await n, typeof n == "function" && (n = await n(r)), typeof n == "function" && (n = await n(r)), Lue(n) ? n = await n.instantiator(r) : zue(n) ? n = await n.default(r) : (jue(n) && (n = n.data), que(n) ? typeof WebAssembly.instantiateStreaming == "function" ? n = await Vue(n)(r) : n = await Wue(n)(r) : Uue(n) ? n = await rk(n)(r) : n instanceof WebAssembly.Module ? n = await rk(n)(r) : "default" in n && n.default instanceof WebAssembly.Module && (n = await rk(n.default)(r))), "instance" in n && (n = n.instance), "exports" in n && (n = n.exports), n;
    });
  }
  return Zv = e(), Zv;
}
function rk(t) {
  return (e) => WebAssembly.instantiate(t, e);
}
function Vue(t) {
  return (e) => WebAssembly.instantiateStreaming(t, e);
}
function Wue(t) {
  return async (e) => {
    const r = await t.arrayBuffer();
    return WebAssembly.instantiate(r, e);
  };
}
let Gue;
function Kue() {
  return Gue;
}
async function Que(t) {
  return t && await Hue(t), {
    createScanner(e) {
      return new Bue(e.map((r) => typeof r == "string" ? r : r.source));
    },
    createString(e) {
      return new l0(e);
    }
  };
}
function Xue(t) {
  return tS(t);
}
function tS(t) {
  return Array.isArray(t) ? Jue(t) : t instanceof RegExp ? t : typeof t == "object" ? Yue(t) : t;
}
function Jue(t) {
  let e = [];
  for (let r = 0, n = t.length; r < n; r++)
    e[r] = tS(t[r]);
  return e;
}
function Yue(t) {
  let e = {};
  for (let r in t)
    e[r] = tS(t[r]);
  return e;
}
function t$(t, ...e) {
  return e.forEach((r) => {
    for (let n in r)
      t[n] = r[n];
  }), t;
}
function r$(t) {
  const e = ~t.lastIndexOf("/") || ~t.lastIndexOf("\\");
  return e === 0 ? t : ~e === t.length - 1 ? r$(t.substring(0, t.length - 1)) : t.substr(~e + 1);
}
var nk = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, ey = class {
  static hasCaptures(t) {
    return t === null ? !1 : (nk.lastIndex = 0, nk.test(t));
  }
  static replaceCaptures(t, e, r) {
    return t.replace(nk, (n, i, o, s) => {
      let a = r[parseInt(i || o, 10)];
      if (a) {
        let l = e.substring(a.start, a.end);
        for (; l[0] === "."; )
          l = l.substring(1);
        switch (s) {
          case "downcase":
            return l.toLowerCase();
          case "upcase":
            return l.toUpperCase();
          default:
            return l;
        }
      } else
        return n;
    });
  }
};
function n$(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function i$(t, e) {
  if (t === null && e === null)
    return 0;
  if (!t)
    return -1;
  if (!e)
    return 1;
  let r = t.length, n = e.length;
  if (r === n) {
    for (let i = 0; i < r; i++) {
      let o = n$(t[i], e[i]);
      if (o !== 0)
        return o;
    }
    return 0;
  }
  return r - n;
}
function E7(t) {
  return !!(/^#[0-9a-f]{6}$/i.test(t) || /^#[0-9a-f]{8}$/i.test(t) || /^#[0-9a-f]{3}$/i.test(t) || /^#[0-9a-f]{4}$/i.test(t));
}
function o$(t) {
  return t.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var s$ = class {
  constructor(t) {
    this.fn = t;
  }
  cache = /* @__PURE__ */ new Map();
  get(t) {
    if (this.cache.has(t))
      return this.cache.get(t);
    const e = this.fn(t);
    return this.cache.set(t, e), e;
  }
}, L1 = class {
  constructor(t, e, r) {
    this._colorMap = t, this._defaults = e, this._root = r;
  }
  static createFromRawTheme(t, e) {
    return this.createFromParsedTheme(tce(t), e);
  }
  static createFromParsedTheme(t, e) {
    return nce(t, e);
  }
  _cachedMatchRoot = new s$(
    (t) => this._root.match(t)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(t) {
    if (t === null)
      return this._defaults;
    const e = t.scopeName, r = this._cachedMatchRoot.get(e).find(
      (n) => Zue(t.parent, n.parentScopes)
    );
    return r ? new a$(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, ik = class Uy {
  constructor(e, r) {
    this.parent = e, this.scopeName = r;
  }
  static push(e, r) {
    for (const n of r)
      e = new Uy(e, n);
    return e;
  }
  static from(...e) {
    let r = null;
    for (let n = 0; n < e.length; n++)
      r = new Uy(r, e[n]);
    return r;
  }
  push(e) {
    return new Uy(this, e);
  }
  getSegments() {
    let e = this;
    const r = [];
    for (; e; )
      r.push(e.scopeName), e = e.parent;
    return r.reverse(), r;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(e) {
    return this === e ? !0 : this.parent === null ? !1 : this.parent.extends(e);
  }
  getExtensionIfDefined(e) {
    const r = [];
    let n = this;
    for (; n && n !== e; )
      r.push(n.scopeName), n = n.parent;
    return n === e ? r.reverse() : void 0;
  }
};
function Zue(t, e) {
  if (e.length === 0)
    return !0;
  for (let r = 0; r < e.length; r++) {
    let n = e[r], i = !1;
    if (n === ">") {
      if (r === e.length - 1)
        return !1;
      n = e[++r], i = !0;
    }
    for (; t && !ece(t.scopeName, n); ) {
      if (i)
        return !1;
      t = t.parent;
    }
    if (!t)
      return !1;
    t = t.parent;
  }
  return !0;
}
function ece(t, e) {
  return e === t || t.startsWith(e) && t[e.length] === ".";
}
var a$ = class {
  constructor(t, e, r) {
    this.fontStyle = t, this.foregroundId = e, this.backgroundId = r;
  }
};
function tce(t) {
  if (!t)
    return [];
  if (!t.settings || !Array.isArray(t.settings))
    return [];
  let e = t.settings, r = [], n = 0;
  for (let i = 0, o = e.length; i < o; i++) {
    let s = e[i];
    if (!s.settings)
      continue;
    let a;
    if (typeof s.scope == "string") {
      let h = s.scope;
      h = h.replace(/^[,]+/, ""), h = h.replace(/[,]+$/, ""), a = h.split(",");
    } else Array.isArray(s.scope) ? a = s.scope : a = [""];
    let l = -1;
    if (typeof s.settings.fontStyle == "string") {
      l = 0;
      let h = s.settings.fontStyle.split(" ");
      for (let d = 0, p = h.length; d < p; d++)
        switch (h[d]) {
          case "italic":
            l = l | 1;
            break;
          case "bold":
            l = l | 2;
            break;
          case "underline":
            l = l | 4;
            break;
          case "strikethrough":
            l = l | 8;
            break;
        }
    }
    let u = null;
    typeof s.settings.foreground == "string" && E7(s.settings.foreground) && (u = s.settings.foreground);
    let c = null;
    typeof s.settings.background == "string" && E7(s.settings.background) && (c = s.settings.background);
    for (let h = 0, d = a.length; h < d; h++) {
      let p = a[h].trim().split(" "), g = p[p.length - 1], v = null;
      p.length > 1 && (v = p.slice(0, p.length - 1), v.reverse()), r[n++] = new rce(
        g,
        v,
        i,
        l,
        u,
        c
      );
    }
  }
  return r;
}
var rce = class {
  constructor(t, e, r, n, i, o) {
    this.scope = t, this.parentScopes = e, this.index = r, this.fontStyle = n, this.foreground = i, this.background = o;
  }
}, Bl = /* @__PURE__ */ ((t) => (t[t.NotSet = -1] = "NotSet", t[t.None = 0] = "None", t[t.Italic = 1] = "Italic", t[t.Bold = 2] = "Bold", t[t.Underline = 4] = "Underline", t[t.Strikethrough = 8] = "Strikethrough", t))(Bl || {});
function nce(t, e) {
  t.sort((l, u) => {
    let c = n$(l.scope, u.scope);
    return c !== 0 || (c = i$(l.parentScopes, u.parentScopes), c !== 0) ? c : l.index - u.index;
  });
  let r = 0, n = "#000000", i = "#ffffff";
  for (; t.length >= 1 && t[0].scope === ""; ) {
    let l = t.shift();
    l.fontStyle !== -1 && (r = l.fontStyle), l.foreground !== null && (n = l.foreground), l.background !== null && (i = l.background);
  }
  let o = new ice(e), s = new a$(r, o.getId(n), o.getId(i)), a = new sce(new EC(0, null, -1, 0, 0), []);
  for (let l = 0, u = t.length; l < u; l++) {
    let c = t[l];
    a.insert(0, c.scope, c.parentScopes, c.fontStyle, o.getId(c.foreground), o.getId(c.background));
  }
  return new L1(o, s, a);
}
var ice = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(t) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(t)) {
      this._isFrozen = !0;
      for (let e = 0, r = t.length; e < r; e++)
        this._color2id[t[e]] = e, this._id2color[e] = t[e];
    } else
      this._isFrozen = !1;
  }
  getId(t) {
    if (t === null)
      return 0;
    t = t.toUpperCase();
    let e = this._color2id[t];
    if (e)
      return e;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${t}`);
    return e = ++this._lastColorId, this._color2id[t] = e, this._id2color[e] = t, e;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, oce = Object.freeze([]), EC = class l$ {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(e, r, n, i, o) {
    this.scopeDepth = e, this.parentScopes = r || oce, this.fontStyle = n, this.foreground = i, this.background = o;
  }
  clone() {
    return new l$(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(e) {
    let r = [];
    for (let n = 0, i = e.length; n < i; n++)
      r[n] = e[n].clone();
    return r;
  }
  acceptOverwrite(e, r, n, i) {
    this.scopeDepth > e ? console.log("how did this happen?") : this.scopeDepth = e, r !== -1 && (this.fontStyle = r), n !== 0 && (this.foreground = n), i !== 0 && (this.background = i);
  }
}, sce = class DC {
  constructor(e, r = [], n = {}) {
    this._mainRule = e, this._children = n, this._rulesWithParentScopes = r;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(e, r) {
    if (e.scopeDepth !== r.scopeDepth)
      return r.scopeDepth - e.scopeDepth;
    let n = 0, i = 0;
    for (; e.parentScopes[n] === ">" && n++, r.parentScopes[i] === ">" && i++, !(n >= e.parentScopes.length || i >= r.parentScopes.length); ) {
      const o = r.parentScopes[i].length - e.parentScopes[n].length;
      if (o !== 0)
        return o;
      n++, i++;
    }
    return r.parentScopes.length - e.parentScopes.length;
  }
  match(e) {
    if (e !== "") {
      let n = e.indexOf("."), i, o;
      if (n === -1 ? (i = e, o = "") : (i = e.substring(0, n), o = e.substring(n + 1)), this._children.hasOwnProperty(i))
        return this._children[i].match(o);
    }
    const r = this._rulesWithParentScopes.concat(this._mainRule);
    return r.sort(DC._cmpBySpecificity), r;
  }
  insert(e, r, n, i, o, s) {
    if (r === "") {
      this._doInsertHere(e, n, i, o, s);
      return;
    }
    let a = r.indexOf("."), l, u;
    a === -1 ? (l = r, u = "") : (l = r.substring(0, a), u = r.substring(a + 1));
    let c;
    this._children.hasOwnProperty(l) ? c = this._children[l] : (c = new DC(this._mainRule.clone(), EC.cloneArr(this._rulesWithParentScopes)), this._children[l] = c), c.insert(e + 1, u, n, i, o, s);
  }
  _doInsertHere(e, r, n, i, o) {
    if (r === null) {
      this._mainRule.acceptOverwrite(e, n, i, o);
      return;
    }
    for (let s = 0, a = this._rulesWithParentScopes.length; s < a; s++) {
      let l = this._rulesWithParentScopes[s];
      if (i$(l.parentScopes, r) === 0) {
        l.acceptOverwrite(e, n, i, o);
        return;
      }
    }
    n === -1 && (n = this._mainRule.fontStyle), i === 0 && (i = this._mainRule.foreground), o === 0 && (o = this._mainRule.background), this._rulesWithParentScopes.push(new EC(e, r, n, i, o));
  }
}, Fd = class ss {
  static toBinaryStr(e) {
    return e.toString(2).padStart(32, "0");
  }
  static print(e) {
    const r = ss.getLanguageId(e), n = ss.getTokenType(e), i = ss.getFontStyle(e), o = ss.getForeground(e), s = ss.getBackground(e);
    console.log({
      languageId: r,
      tokenType: n,
      fontStyle: i,
      foreground: o,
      background: s
    });
  }
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(e, r, n, i, o, s, a) {
    let l = ss.getLanguageId(e), u = ss.getTokenType(e), c = ss.containsBalancedBrackets(e) ? 1 : 0, h = ss.getFontStyle(e), d = ss.getForeground(e), p = ss.getBackground(e);
    return r !== 0 && (l = r), n !== 8 && (u = n), i !== null && (c = i ? 1 : 0), o !== -1 && (h = o), s !== 0 && (d = s), a !== 0 && (p = a), (l << 0 | u << 8 | c << 10 | h << 11 | d << 15 | p << 24) >>> 0;
  }
};
function z1(t, e) {
  const r = [], n = ace(t);
  let i = n.next();
  for (; i !== null; ) {
    let l = 0;
    if (i.length === 2 && i.charAt(1) === ":") {
      switch (i.charAt(0)) {
        case "R":
          l = 1;
          break;
        case "L":
          l = -1;
          break;
        default:
          console.log(`Unknown priority ${i} in scope selector`);
      }
      i = n.next();
    }
    let u = s();
    if (r.push({ matcher: u, priority: l }), i !== ",")
      break;
    i = n.next();
  }
  return r;
  function o() {
    if (i === "-") {
      i = n.next();
      const l = o();
      return (u) => !!l && !l(u);
    }
    if (i === "(") {
      i = n.next();
      const l = a();
      return i === ")" && (i = n.next()), l;
    }
    if (D7(i)) {
      const l = [];
      do
        l.push(i), i = n.next();
      while (D7(i));
      return (u) => e(l, u);
    }
    return null;
  }
  function s() {
    const l = [];
    let u = o();
    for (; u; )
      l.push(u), u = o();
    return (c) => l.every((h) => h(c));
  }
  function a() {
    const l = [];
    let u = s();
    for (; u && (l.push(u), i === "|" || i === ","); ) {
      do
        i = n.next();
      while (i === "|" || i === ",");
      u = s();
    }
    return (c) => l.some((h) => h(c));
  }
}
function D7(t) {
  return !!t && !!t.match(/[\w\.:]+/);
}
function ace(t) {
  let e = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, r = e.exec(t);
  return {
    next: () => {
      if (!r)
        return null;
      const n = r[0];
      return r = e.exec(t), n;
    }
  };
}
function u$(t) {
  typeof t.dispose == "function" && t.dispose();
}
var wg = class {
  constructor(t) {
    this.scopeName = t;
  }
  toKey() {
    return this.scopeName;
  }
}, lce = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, uce = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(t) {
    const e = t.toKey();
    this._seenReferenceKeys.has(e) || (this._seenReferenceKeys.add(e), this._references.push(t));
  }
}, cce = class {
  constructor(t, e) {
    this.repo = t, this.initialScopeName = e, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new wg(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const t = this.Q;
    this.Q = [];
    const e = new uce();
    for (const r of t)
      hce(r, this.initialScopeName, this.repo, e);
    for (const r of e.references)
      if (r instanceof wg) {
        if (this.seenFullScopeRequests.has(r.scopeName))
          continue;
        this.seenFullScopeRequests.add(r.scopeName), this.Q.push(r);
      } else {
        if (this.seenFullScopeRequests.has(r.scopeName) || this.seenPartialScopeRequests.has(r.toKey()))
          continue;
        this.seenPartialScopeRequests.add(r.toKey()), this.Q.push(r);
      }
  }
};
function hce(t, e, r, n) {
  const i = r.lookup(t.scopeName);
  if (!i) {
    if (t.scopeName === e)
      throw new Error(`No grammar provided for <${e}>`);
    return;
  }
  const o = r.lookup(e);
  t instanceof wg ? Hy({ baseGrammar: o, selfGrammar: i }, n) : OC(
    t.ruleName,
    { baseGrammar: o, selfGrammar: i, repository: i.repository },
    n
  );
  const s = r.injections(t.scopeName);
  if (s)
    for (const a of s)
      n.add(new wg(a));
}
function OC(t, e, r) {
  if (e.repository && e.repository[t]) {
    const n = e.repository[t];
    j1([n], e, r);
  }
}
function Hy(t, e) {
  t.selfGrammar.patterns && Array.isArray(t.selfGrammar.patterns) && j1(
    t.selfGrammar.patterns,
    { ...t, repository: t.selfGrammar.repository },
    e
  ), t.selfGrammar.injections && j1(
    Object.values(t.selfGrammar.injections),
    { ...t, repository: t.selfGrammar.repository },
    e
  );
}
function j1(t, e, r) {
  for (const n of t) {
    if (r.visitedRule.has(n))
      continue;
    r.visitedRule.add(n);
    const i = n.repository ? t$({}, e.repository, n.repository) : e.repository;
    Array.isArray(n.patterns) && j1(n.patterns, { ...e, repository: i }, r);
    const o = n.include;
    if (!o)
      continue;
    const s = c$(o);
    switch (s.kind) {
      case 0:
        Hy({ ...e, selfGrammar: e.baseGrammar }, r);
        break;
      case 1:
        Hy(e, r);
        break;
      case 2:
        OC(s.ruleName, { ...e, repository: i }, r);
        break;
      case 3:
      case 4:
        const a = s.scopeName === e.selfGrammar.scopeName ? e.selfGrammar : s.scopeName === e.baseGrammar.scopeName ? e.baseGrammar : void 0;
        if (a) {
          const l = { baseGrammar: e.baseGrammar, selfGrammar: a, repository: i };
          s.kind === 4 ? OC(s.ruleName, l, r) : Hy(l, r);
        } else
          s.kind === 4 ? r.add(new lce(s.scopeName, s.ruleName)) : r.add(new wg(s.scopeName));
        break;
    }
  }
}
var fce = class {
  kind = 0;
}, dce = class {
  kind = 1;
}, pce = class {
  constructor(t) {
    this.ruleName = t;
  }
  kind = 2;
}, mce = class {
  constructor(t) {
    this.scopeName = t;
  }
  kind = 3;
}, gce = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  kind = 4;
};
function c$(t) {
  if (t === "$base")
    return new fce();
  if (t === "$self")
    return new dce();
  const e = t.indexOf("#");
  if (e === -1)
    return new mce(t);
  if (e === 0)
    return new pce(t.substring(1));
  {
    const r = t.substring(0, e), n = t.substring(e + 1);
    return new gce(r, n);
  }
}
var vce = /\\(\d+)/, O7 = /\\(\d+)/g, yce = -1, h$ = -2, u0 = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(t, e, r, n) {
    this.$location = t, this.id = e, this._name = r || null, this._nameIsCapturing = ey.hasCaptures(this._name), this._contentName = n || null, this._contentNameIsCapturing = ey.hasCaptures(this._contentName);
  }
  get debugName() {
    const t = this.$location ? `${r$(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${t}`;
  }
  getName(t, e) {
    return !this._nameIsCapturing || this._name === null || t === null || e === null ? this._name : ey.replaceCaptures(this._name, t, e);
  }
  getContentName(t, e) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : ey.replaceCaptures(this._contentName, t, e);
  }
}, bce = class extends u0 {
  retokenizeCapturedWithRuleId;
  constructor(t, e, r, n, i) {
    super(t, e, r, n), this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(t, e) {
    throw new Error("Not supported!");
  }
  compile(t, e) {
    throw new Error("Not supported!");
  }
  compileAG(t, e, r, n) {
    throw new Error("Not supported!");
  }
}, xce = class extends u0 {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(t, e, r, n, i) {
    super(t, e, r, null), this._match = new kg(n, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(t, e) {
    e.push(this._match);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Cg(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, F7 = class extends u0 {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, r, n, i) {
    super(t, e, r, n), this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(t, e) {
    for (const r of this.patterns)
      t.getRule(r).collectPatterns(t, e);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Cg(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, FC = class extends u0 {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, r, n, i, o, s, a, l, u) {
    super(t, e, r, n), this._begin = new kg(i, this.id), this.beginCaptures = o, this._end = new kg(s || "ï¿¿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = a, this.applyEndPatternLast = l || !1, this.patterns = u.patterns, this.hasMissingPatterns = u.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(t, e) {
    return this._end.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t, e).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t, e).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t, e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Cg();
      for (const r of this.patterns)
        t.getRule(r).collectPatterns(t, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, e) : this._cachedCompiledPatterns.setSource(0, e)), this._cachedCompiledPatterns;
  }
}, q1 = class extends u0 {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(t, e, r, n, i, o, s, a, l) {
    super(t, e, r, n), this._begin = new kg(i, this.id), this.beginCaptures = o, this.whileCaptures = a, this._while = new kg(s, h$), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = l.patterns, this.hasMissingPatterns = l.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(t, e) {
    return this._while.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Cg();
      for (const e of this.patterns)
        t.getRule(e).collectPatterns(t, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(t, e) {
    return this._getCachedCompiledWhilePatterns(t, e).compile(t);
  }
  compileWhileAG(t, e, r, n) {
    return this._getCachedCompiledWhilePatterns(t, e).compileAG(t, r, n);
  }
  _getCachedCompiledWhilePatterns(t, e) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new Cg(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, e || "ï¿¿"), this._cachedCompiledWhilePatterns;
  }
}, f$ = class Yn {
  static createCaptureRule(e, r, n, i, o) {
    return e.registerRule((s) => new bce(r, s, n, i, o));
  }
  static getCompiledRuleId(e, r, n) {
    return e.id || r.registerRule((i) => {
      if (e.id = i, e.match)
        return new xce(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.match,
          Yn._compileCaptures(e.captures, r, n)
        );
      if (typeof e.begin > "u") {
        e.repository && (n = t$({}, n, e.repository));
        let o = e.patterns;
        return typeof o > "u" && e.include && (o = [{ include: e.include }]), new F7(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.contentName,
          Yn._compilePatterns(o, r, n)
        );
      }
      return e.while ? new q1(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Yn._compileCaptures(e.beginCaptures || e.captures, r, n),
        e.while,
        Yn._compileCaptures(e.whileCaptures || e.captures, r, n),
        Yn._compilePatterns(e.patterns, r, n)
      ) : new FC(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Yn._compileCaptures(e.beginCaptures || e.captures, r, n),
        e.end,
        Yn._compileCaptures(e.endCaptures || e.captures, r, n),
        e.applyEndPatternLast,
        Yn._compilePatterns(e.patterns, r, n)
      );
    }), e.id;
  }
  static _compileCaptures(e, r, n) {
    let i = [];
    if (e) {
      let o = 0;
      for (const s in e) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        a > o && (o = a);
      }
      for (let s = 0; s <= o; s++)
        i[s] = null;
      for (const s in e) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        let l = 0;
        e[s].patterns && (l = Yn.getCompiledRuleId(e[s], r, n)), i[a] = Yn.createCaptureRule(r, e[s].$vscodeTextmateLocation, e[s].name, e[s].contentName, l);
      }
    }
    return i;
  }
  static _compilePatterns(e, r, n) {
    let i = [];
    if (e)
      for (let o = 0, s = e.length; o < s; o++) {
        const a = e[o];
        let l = -1;
        if (a.include) {
          const u = c$(a.include);
          switch (u.kind) {
            case 0:
            case 1:
              l = Yn.getCompiledRuleId(n[a.include], r, n);
              break;
            case 2:
              let c = n[u.ruleName];
              c && (l = Yn.getCompiledRuleId(c, r, n));
              break;
            case 3:
            case 4:
              const h = u.scopeName, d = u.kind === 4 ? u.ruleName : null, p = r.getExternalGrammar(h, n);
              if (p)
                if (d) {
                  let g = p.repository[d];
                  g && (l = Yn.getCompiledRuleId(g, r, p.repository));
                } else
                  l = Yn.getCompiledRuleId(p.repository.$self, r, p.repository);
              break;
          }
        } else
          l = Yn.getCompiledRuleId(a, r, n);
        if (l !== -1) {
          const u = r.getRule(l);
          let c = !1;
          if ((u instanceof F7 || u instanceof FC || u instanceof q1) && u.hasMissingPatterns && u.patterns.length === 0 && (c = !0), c)
            continue;
          i.push(l);
        }
      }
    return {
      patterns: i,
      hasMissingPatterns: (e ? e.length : 0) !== i.length
    };
  }
}, kg = class d$ {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(e, r) {
    if (e && typeof e == "string") {
      const n = e.length;
      let i = 0, o = [], s = !1;
      for (let a = 0; a < n; a++)
        if (e.charAt(a) === "\\" && a + 1 < n) {
          const l = e.charAt(a + 1);
          l === "z" ? (o.push(e.substring(i, a)), o.push("$(?!\\n)(?<!\\n)"), i = a + 2) : (l === "A" || l === "G") && (s = !0), a++;
        }
      this.hasAnchor = s, i === 0 ? this.source = e : (o.push(e.substring(i, n)), this.source = o.join(""));
    } else
      this.hasAnchor = !1, this.source = e;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = r, typeof this.source == "string" ? this.hasBackReferences = vce.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new d$(this.source, this.ruleId);
  }
  setSource(e) {
    this.source !== e && (this.source = e, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(e, r) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let n = r.map((i) => e.substring(i.start, i.end));
    return O7.lastIndex = 0, this.source.replace(O7, (i, o) => o$(n[parseInt(o, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let e = [], r = [], n = [], i = [], o, s, a, l;
    for (o = 0, s = this.source.length; o < s; o++)
      a = this.source.charAt(o), e[o] = a, r[o] = a, n[o] = a, i[o] = a, a === "\\" && o + 1 < s && (l = this.source.charAt(o + 1), l === "A" ? (e[o + 1] = "ï¿¿", r[o + 1] = "ï¿¿", n[o + 1] = "A", i[o + 1] = "A") : l === "G" ? (e[o + 1] = "ï¿¿", r[o + 1] = "G", n[o + 1] = "ï¿¿", i[o + 1] = "G") : (e[o + 1] = l, r[o + 1] = l, n[o + 1] = l, i[o + 1] = l), o++);
    return {
      A0_G0: e.join(""),
      A0_G1: r.join(""),
      A1_G0: n.join(""),
      A1_G1: i.join("")
    };
  }
  resolveAnchors(e, r) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : e ? r ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : r ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, Cg = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(t) {
    this._items.push(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  unshift(t) {
    this._items.unshift(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(t, e) {
    this._items[t].source !== e && (this._disposeCaches(), this._items[t].setSource(e));
  }
  compile(t) {
    if (!this._cached) {
      let e = this._items.map((r) => r.source);
      this._cached = new T7(t, e, this._items.map((r) => r.ruleId));
    }
    return this._cached;
  }
  compileAG(t, e, r) {
    return this._hasAnchors ? e ? r ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(t, e, r)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(t, e, r)), this._anchorCache.A1_G0) : r ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(t, e, r)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(t, e, r)), this._anchorCache.A0_G0) : this.compile(t);
  }
  _resolveAnchors(t, e, r) {
    let n = this._items.map((i) => i.resolveAnchors(e, r));
    return new T7(t, n, this._items.map((i) => i.ruleId));
  }
}, T7 = class {
  constructor(t, e, r) {
    this.regExps = e, this.rules = r, this.scanner = t.createOnigScanner(e);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const t = [];
    for (let e = 0, r = this.rules.length; e < r; e++)
      t.push("   - " + this.rules[e] + ": " + this.regExps[e]);
    return t.join(`
`);
  }
  findNextMatchSync(t, e, r) {
    const n = this.scanner.findNextMatchSync(t, e, r);
    return n ? {
      ruleId: this.rules[n.index],
      captureIndices: n.captureIndices
    } : null;
  }
}, ok = class {
  constructor(t, e) {
    this.languageId = t, this.tokenType = e;
  }
}, wce = class TC {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(e, r) {
    this._defaultAttributes = new ok(
      e,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new kce(Object.entries(r || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(e) {
    return e === null ? TC._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(e);
  }
  static _NULL_SCOPE_METADATA = new ok(0, 0);
  _getBasicScopeAttributes = new s$((e) => {
    const r = this._scopeToLanguage(e), n = this._toStandardTokenType(e);
    return new ok(r, n);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(e) {
    return this._embeddedLanguagesMatcher.match(e) || 0;
  }
  _toStandardTokenType(e) {
    const r = e.match(TC.STANDARD_TOKEN_TYPE_REGEXP);
    if (!r)
      return 8;
    switch (r[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, kce = class {
  values;
  scopesRegExp;
  constructor(t) {
    if (t.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(t);
      const e = t.map(
        ([r, n]) => o$(r)
      );
      e.sort(), e.reverse(), this.scopesRegExp = new RegExp(
        `^((${e.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(t) {
    if (!this.scopesRegExp)
      return;
    const e = t.match(this.scopesRegExp);
    if (e)
      return this.values.get(e[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var M7 = class {
  constructor(t, e) {
    this.stack = t, this.stoppedEarly = e;
  }
};
function p$(t, e, r, n, i, o, s, a) {
  const l = e.content.length;
  let u = !1, c = -1;
  if (s) {
    const p = Cce(
      t,
      e,
      r,
      n,
      i,
      o
    );
    i = p.stack, n = p.linePos, r = p.isFirstLine, c = p.anchorPosition;
  }
  const h = Date.now();
  for (; !u; ) {
    if (a !== 0 && Date.now() - h > a)
      return new M7(i, !0);
    d();
  }
  return new M7(i, !1);
  function d() {
    const p = _ce(
      t,
      e,
      r,
      n,
      i,
      c
    );
    if (!p) {
      o.produce(i, l), u = !0;
      return;
    }
    const g = p.captureIndices, v = p.matchedRuleId, y = g && g.length > 0 ? g[0].end > n : !1;
    if (v === yce) {
      const b = i.getRule(t);
      o.produce(i, g[0].start), i = i.withContentNameScopesList(i.nameScopesList), gm(
        t,
        e,
        r,
        i,
        o,
        b.endCaptures,
        g
      ), o.produce(i, g[0].end);
      const k = i;
      if (i = i.parent, c = k.getAnchorPos(), !y && k.getEnterPos() === n) {
        i = k, o.produce(i, l), u = !0;
        return;
      }
    } else {
      const b = t.getRule(v);
      o.produce(i, g[0].start);
      const k = i, C = b.getName(e.content, g), S = i.contentNameScopesList.pushAttributed(
        C,
        t
      );
      if (i = i.push(
        v,
        n,
        c,
        g[0].end === l,
        null,
        S,
        S
      ), b instanceof FC) {
        const _ = b;
        gm(
          t,
          e,
          r,
          i,
          o,
          _.beginCaptures,
          g
        ), o.produce(i, g[0].end), c = g[0].end;
        const D = _.getContentName(
          e.content,
          g
        ), A = S.pushAttributed(
          D,
          t
        );
        if (i = i.withContentNameScopesList(A), _.endHasBackReferences && (i = i.withEndRule(
          _.getEndWithResolvedBackReferences(
            e.content,
            g
          )
        )), !y && k.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, l), u = !0;
          return;
        }
      } else if (b instanceof q1) {
        const _ = b;
        gm(
          t,
          e,
          r,
          i,
          o,
          _.beginCaptures,
          g
        ), o.produce(i, g[0].end), c = g[0].end;
        const D = _.getContentName(
          e.content,
          g
        ), A = S.pushAttributed(
          D,
          t
        );
        if (i = i.withContentNameScopesList(A), _.whileHasBackReferences && (i = i.withEndRule(
          _.getWhileWithResolvedBackReferences(
            e.content,
            g
          )
        )), !y && k.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, l), u = !0;
          return;
        }
      } else if (gm(
        t,
        e,
        r,
        i,
        o,
        b.captures,
        g
      ), o.produce(i, g[0].end), i = i.pop(), !y) {
        i = i.safePop(), o.produce(i, l), u = !0;
        return;
      }
    }
    g[0].end > n && (n = g[0].end, r = !1);
  }
}
function Cce(t, e, r, n, i, o) {
  let s = i.beginRuleCapturedEOL ? 0 : -1;
  const a = [];
  for (let l = i; l; l = l.pop()) {
    const u = l.getRule(t);
    u instanceof q1 && a.push({
      rule: u,
      stack: l
    });
  }
  for (let l = a.pop(); l; l = a.pop()) {
    const { ruleScanner: u, findOptions: c } = Ece(l.rule, t, l.stack.endRule, r, n === s), h = u.findNextMatchSync(e, n, c);
    if (h) {
      if (h.ruleId !== h$) {
        i = l.stack.pop();
        break;
      }
      h.captureIndices && h.captureIndices.length && (o.produce(l.stack, h.captureIndices[0].start), gm(t, e, r, l.stack, o, l.rule.whileCaptures, h.captureIndices), o.produce(l.stack, h.captureIndices[0].end), s = h.captureIndices[0].end, h.captureIndices[0].end > n && (n = h.captureIndices[0].end, r = !1));
    } else {
      i = l.stack.pop();
      break;
    }
  }
  return { stack: i, linePos: n, anchorPosition: s, isFirstLine: r };
}
function _ce(t, e, r, n, i, o) {
  const s = Sce(t, e, r, n, i, o), a = t.getInjections();
  if (a.length === 0)
    return s;
  const l = Ace(a, t, e, r, n, i, o);
  if (!l)
    return s;
  if (!s)
    return l;
  const u = s.captureIndices[0].start, c = l.captureIndices[0].start;
  return c < u || l.priorityMatch && c === u ? l : s;
}
function Sce(t, e, r, n, i, o) {
  const s = i.getRule(t), { ruleScanner: a, findOptions: l } = m$(s, t, i.endRule, r, n === o), u = a.findNextMatchSync(e, n, l);
  return u ? {
    captureIndices: u.captureIndices,
    matchedRuleId: u.ruleId
  } : null;
}
function Ace(t, e, r, n, i, o, s) {
  let a = Number.MAX_VALUE, l = null, u, c = 0;
  const h = o.contentNameScopesList.getScopeNames();
  for (let d = 0, p = t.length; d < p; d++) {
    const g = t[d];
    if (!g.matcher(h))
      continue;
    const v = e.getRule(g.ruleId), { ruleScanner: y, findOptions: b } = m$(v, e, null, n, i === s), k = y.findNextMatchSync(r, i, b);
    if (!k)
      continue;
    const C = k.captureIndices[0].start;
    if (!(C >= a) && (a = C, l = k.captureIndices, u = k.ruleId, c = g.priority, a === i))
      break;
  }
  return l ? {
    priorityMatch: c === -1,
    captureIndices: l,
    matchedRuleId: u
  } : null;
}
function m$(t, e, r, n, i) {
  return {
    ruleScanner: t.compileAG(e, r, n, i),
    findOptions: 0
    /* None */
  };
}
function Ece(t, e, r, n, i) {
  return {
    ruleScanner: t.compileWhileAG(e, r, n, i),
    findOptions: 0
    /* None */
  };
}
function gm(t, e, r, n, i, o, s) {
  if (o.length === 0)
    return;
  const a = e.content, l = Math.min(o.length, s.length), u = [], c = s[0].end;
  for (let h = 0; h < l; h++) {
    const d = o[h];
    if (d === null)
      continue;
    const p = s[h];
    if (p.length === 0)
      continue;
    if (p.start > c)
      break;
    for (; u.length > 0 && u[u.length - 1].endPos <= p.start; )
      i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
    if (u.length > 0 ? i.produceFromScopes(u[u.length - 1].scopes, p.start) : i.produce(n, p.start), d.retokenizeCapturedWithRuleId) {
      const v = d.getName(a, s), y = n.contentNameScopesList.pushAttributed(v, t), b = d.getContentName(a, s), k = y.pushAttributed(b, t), C = n.push(d.retokenizeCapturedWithRuleId, p.start, -1, !1, null, y, k), S = t.createOnigString(a.substring(0, p.end));
      p$(
        t,
        S,
        r && p.start === 0,
        p.start,
        C,
        i,
        !1,
        /* no time limit */
        0
      ), u$(S);
      continue;
    }
    const g = d.getName(a, s);
    if (g !== null) {
      const v = (u.length > 0 ? u[u.length - 1].scopes : n.contentNameScopesList).pushAttributed(g, t);
      u.push(new Dce(v, p.end));
    }
  }
  for (; u.length > 0; )
    i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
}
var Dce = class {
  scopes;
  endPos;
  constructor(t, e) {
    this.scopes = t, this.endPos = e;
  }
};
function Oce(t, e, r, n, i, o, s, a) {
  return new Tce(
    t,
    e,
    r,
    n,
    i,
    o,
    s,
    a
  );
}
function P7(t, e, r, n, i) {
  const o = z1(e, U1), s = f$.getCompiledRuleId(r, n, i.repository);
  for (const a of o)
    t.push({
      debugSelector: e,
      matcher: a.matcher,
      ruleId: s,
      grammar: i,
      priority: a.priority
    });
}
function U1(t, e) {
  if (e.length < t.length)
    return !1;
  let r = 0;
  return t.every((n) => {
    for (let i = r; i < e.length; i++)
      if (Fce(e[i], n))
        return r = i + 1, !0;
    return !1;
  });
}
function Fce(t, e) {
  if (!t)
    return !1;
  if (t === e)
    return !0;
  const r = e.length;
  return t.length > r && t.substr(0, r) === e && t[r] === ".";
}
var Tce = class {
  constructor(t, e, r, n, i, o, s, a) {
    if (this._rootScopeName = t, this.balancedBracketSelectors = o, this._onigLib = a, this._basicScopeAttributesProvider = new wce(
      r,
      n
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = s, this._grammar = R7(e, null), this._injections = null, this._tokenTypeMatchers = [], i)
      for (const l of Object.keys(i)) {
        const u = z1(l, U1);
        for (const c of u)
          this._tokenTypeMatchers.push({
            matcher: c.matcher,
            type: i[l]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const t of this._ruleId2desc)
      t && t.dispose();
  }
  createOnigScanner(t) {
    return this._onigLib.createOnigScanner(t);
  }
  createOnigString(t) {
    return this._onigLib.createOnigString(t);
  }
  getMetadataForScope(t) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(t);
  }
  _collectInjections() {
    const t = {
      lookup: (i) => i === this._rootScopeName ? this._grammar : this.getExternalGrammar(i),
      injections: (i) => this._grammarRepository.injections(i)
    }, e = [], r = this._rootScopeName, n = t.lookup(r);
    if (n) {
      const i = n.injections;
      if (i)
        for (let s in i)
          P7(
            e,
            s,
            i[s],
            this,
            n
          );
      const o = this._grammarRepository.injections(r);
      o && o.forEach((s) => {
        const a = this.getExternalGrammar(s);
        if (a) {
          const l = a.injectionSelector;
          l && P7(
            e,
            l,
            a,
            this,
            a
          );
        }
      });
    }
    return e.sort((i, o) => i.priority - o.priority), e;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(t) {
    const e = ++this._lastRuleId, r = t(e);
    return this._ruleId2desc[e] = r, r;
  }
  getRule(t) {
    return this._ruleId2desc[t];
  }
  getExternalGrammar(t, e) {
    if (this._includedGrammars[t])
      return this._includedGrammars[t];
    if (this._grammarRepository) {
      const r = this._grammarRepository.lookup(t);
      if (r)
        return this._includedGrammars[t] = R7(
          r,
          e && e.$base
        ), this._includedGrammars[t];
    }
  }
  tokenizeLine(t, e, r = 0) {
    const n = this._tokenize(t, e, !1, r);
    return {
      tokens: n.lineTokens.getResult(n.ruleStack, n.lineLength),
      ruleStack: n.ruleStack,
      stoppedEarly: n.stoppedEarly
    };
  }
  tokenizeLine2(t, e, r = 0) {
    const n = this._tokenize(t, e, !0, r);
    return {
      tokens: n.lineTokens.getBinaryResult(n.ruleStack, n.lineLength),
      ruleStack: n.ruleStack,
      stoppedEarly: n.stoppedEarly
    };
  }
  _tokenize(t, e, r, n) {
    this._rootId === -1 && (this._rootId = f$.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let i;
    if (!e || e === MC.NULL) {
      i = !0;
      const u = this._basicScopeAttributesProvider.getDefaultAttributes(), c = this.themeProvider.getDefaults(), h = Fd.set(
        0,
        u.languageId,
        u.tokenType,
        null,
        c.fontStyle,
        c.foregroundId,
        c.backgroundId
      ), d = this.getRule(this._rootId).getName(
        null,
        null
      );
      let p;
      d ? p = Mm.createRootAndLookUpScopeName(
        d,
        h,
        this
      ) : p = Mm.createRoot(
        "unknown",
        h
      ), e = new MC(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        p,
        p
      );
    } else
      i = !1, e.reset();
    t = t + `
`;
    const o = this.createOnigString(t), s = o.content.length, a = new Pce(
      r,
      t,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), l = p$(
      this,
      o,
      i,
      0,
      e,
      a,
      !0,
      n
    );
    return u$(o), {
      lineLength: s,
      lineTokens: a,
      ruleStack: l.stack,
      stoppedEarly: l.stoppedEarly
    };
  }
};
function R7(t, e) {
  return t = Xue(t), t.repository = t.repository || {}, t.repository.$self = {
    $vscodeTextmateLocation: t.$vscodeTextmateLocation,
    patterns: t.patterns,
    name: t.scopeName
  }, t.repository.$base = e || t.repository.$self, t;
}
var Mm = class ya {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, r, n) {
    this.parent = e, this.scopePath = r, this.tokenAttributes = n;
  }
  static fromExtension(e, r) {
    let n = e, i = e?.scopePath ?? null;
    for (const o of r)
      i = ik.push(i, o.scopeNames), n = new ya(n, i, o.encodedTokenAttributes);
    return n;
  }
  static createRoot(e, r) {
    return new ya(null, new ik(null, e), r);
  }
  static createRootAndLookUpScopeName(e, r, n) {
    const i = n.getMetadataForScope(e), o = new ik(null, e), s = n.themeProvider.themeMatch(o), a = ya.mergeAttributes(
      r,
      i,
      s
    );
    return new ya(null, o, a);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(e) {
    return ya.equals(this, e);
  }
  static equals(e, r) {
    do {
      if (e === r || !e && !r)
        return !0;
      if (!e || !r || e.scopeName !== r.scopeName || e.tokenAttributes !== r.tokenAttributes)
        return !1;
      e = e.parent, r = r.parent;
    } while (!0);
  }
  static mergeAttributes(e, r, n) {
    let i = -1, o = 0, s = 0;
    return n !== null && (i = n.fontStyle, o = n.foregroundId, s = n.backgroundId), Fd.set(
      e,
      r.languageId,
      r.tokenType,
      null,
      i,
      o,
      s
    );
  }
  pushAttributed(e, r) {
    if (e === null)
      return this;
    if (e.indexOf(" ") === -1)
      return ya._pushAttributed(this, e, r);
    const n = e.split(/ /g);
    let i = this;
    for (const o of n)
      i = ya._pushAttributed(i, o, r);
    return i;
  }
  static _pushAttributed(e, r, n) {
    const i = n.getMetadataForScope(r), o = e.scopePath.push(r), s = n.themeProvider.themeMatch(o), a = ya.mergeAttributes(
      e.tokenAttributes,
      i,
      s
    );
    return new ya(e, o, a);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(e) {
    const r = [];
    let n = this;
    for (; n && n !== e; )
      r.push({
        encodedTokenAttributes: n.tokenAttributes,
        scopeNames: n.scopePath.getExtensionIfDefined(n.parent?.scopePath ?? null)
      }), n = n.parent;
    return n === e ? r.reverse() : void 0;
  }
}, MC = class $c {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, r, n, i, o, s, a, l) {
    this.parent = e, this.ruleId = r, this.beginRuleCapturedEOL = o, this.endRule = s, this.nameScopesList = a, this.contentNameScopesList = l, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = n, this._anchorPos = i;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new $c(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(e) {
    return e === null ? !1 : $c._equals(this, e);
  }
  static _equals(e, r) {
    return e === r ? !0 : this._structuralEquals(e, r) ? Mm.equals(e.contentNameScopesList, r.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(e, r) {
    do {
      if (e === r || !e && !r)
        return !0;
      if (!e || !r || e.depth !== r.depth || e.ruleId !== r.ruleId || e.endRule !== r.endRule)
        return !1;
      e = e.parent, r = r.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(e) {
    for (; e; )
      e._enterPos = -1, e._anchorPos = -1, e = e.parent;
  }
  reset() {
    $c._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(e, r, n, i, o, s, a) {
    return new $c(
      this,
      e,
      r,
      n,
      i,
      o,
      s,
      a
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(e) {
    return e.getRule(this.ruleId);
  }
  toString() {
    const e = [];
    return this._writeString(e, 0), "[" + e.join(",") + "]";
  }
  _writeString(e, r) {
    return this.parent && (r = this.parent._writeString(e, r)), e[r++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, r;
  }
  withContentNameScopesList(e) {
    return this.contentNameScopesList === e ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      e
    );
  }
  withEndRule(e) {
    return this.endRule === e ? this : new $c(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      e,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(e) {
    let r = this;
    for (; r && r._enterPos === e._enterPos; ) {
      if (r.ruleId === e.ruleId)
        return !0;
      r = r.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(e, r) {
    const n = Mm.fromExtension(e?.nameScopesList ?? null, r.nameScopesList);
    return new $c(
      e,
      r.ruleId,
      r.enterPos ?? -1,
      r.anchorPos ?? -1,
      r.beginRuleCapturedEOL,
      r.endRule,
      n,
      Mm.fromExtension(n, r.contentNameScopesList)
    );
  }
}, Mce = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(t, e) {
    this.balancedBracketScopes = t.flatMap(
      (r) => r === "*" ? (this.allowAny = !0, []) : z1(r, U1).map((n) => n.matcher)
    ), this.unbalancedBracketScopes = e.flatMap(
      (r) => z1(r, U1).map((n) => n.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(t) {
    for (const e of this.unbalancedBracketScopes)
      if (e(t))
        return !1;
    for (const e of this.balancedBracketScopes)
      if (e(t))
        return !0;
    return this.allowAny;
  }
}, Pce = class {
  constructor(t, e, r, n) {
    this.balancedBracketSelectors = n, this._emitBinaryTokens = t, this._tokenTypeOverrides = r, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(t, e) {
    this.produceFromScopes(t.contentNameScopesList, e);
  }
  produceFromScopes(t, e) {
    if (this._lastTokenEndIndex >= e)
      return;
    if (this._emitBinaryTokens) {
      let n = t?.tokenAttributes ?? 0, i = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const o = t?.getScopeNames() ?? [];
        for (const s of this._tokenTypeOverrides)
          s.matcher(o) && (n = Fd.set(
            n,
            0,
            s.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(o));
      }
      if (i && (n = Fd.set(
        n,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === n) {
        this._lastTokenEndIndex = e;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(n), this._lastTokenEndIndex = e;
      return;
    }
    const r = t?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: e,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: r
    }), this._lastTokenEndIndex = e;
  }
  getResult(t, e) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === e - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(t, e) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === e - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const r = new Uint32Array(this._binaryTokens.length);
    for (let n = 0, i = this._binaryTokens.length; n < i; n++)
      r[n] = this._binaryTokens[n];
    return r;
  }
}, Rce = class {
  constructor(t, e) {
    this._onigLib = e, this._theme = t;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const t of this._grammars.values())
      t.dispose();
  }
  setTheme(t) {
    this._theme = t;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(t, e) {
    this._rawGrammars.set(t.scopeName, t), e && this._injectionGrammars.set(t.scopeName, e);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(t) {
    return this._rawGrammars.get(t);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(t) {
    return this._injectionGrammars.get(t);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(t) {
    return this._theme.match(t);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(t, e, r, n, i) {
    if (!this._grammars.has(t)) {
      let o = this._rawGrammars.get(t);
      if (!o)
        return null;
      this._grammars.set(t, Oce(
        t,
        o,
        e,
        r,
        n,
        i,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(t);
  }
}, Nce = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(t) {
    this._options = t, this._syncRegistry = new Rce(
      L1.createFromRawTheme(t.theme, t.colorMap),
      t.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(t, e) {
    this._syncRegistry.setTheme(L1.createFromRawTheme(t, e));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(t, e, r) {
    return this.loadGrammarWithConfiguration(t, e, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(t, e, r) {
    return this._loadGrammar(
      t,
      e,
      r.embeddedLanguages,
      r.tokenTypes,
      new Mce(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(t) {
    return this._loadGrammar(t, 0, null, null, null);
  }
  _loadGrammar(t, e, r, n, i) {
    const o = new cce(this._syncRegistry, t);
    for (; o.Q.length > 0; )
      o.Q.map((s) => this._loadSingleGrammar(s.scopeName)), o.processQueue();
    return this._grammarForScopeName(
      t,
      e,
      r,
      n,
      i
    );
  }
  _loadSingleGrammar(t) {
    this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0));
  }
  _doLoadSingleGrammar(t) {
    const e = this._options.loadGrammar(t);
    if (e) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0;
      this._syncRegistry.addGrammar(e, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(t, e = [], r = 0, n = null) {
    return this._syncRegistry.addGrammar(t, e), this._grammarForScopeName(t.scopeName, r, n);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(t, e = 0, r = null, n = null, i = null) {
    return this._syncRegistry.grammarForScopeName(
      t,
      e,
      r,
      n,
      i
    );
  }
}, PC = MC.NULL;
const $ce = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
let c0 = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, e, r) {
    this.normal = e, this.property = t, r && (this.space = r);
  }
};
c0.prototype.normal = {};
c0.prototype.property = {};
c0.prototype.space = void 0;
function g$(t, e) {
  const r = {}, n = {};
  for (const i of t)
    Object.assign(r, i.property), Object.assign(n, i.normal);
  return new c0(r, n, e);
}
function RC(t) {
  return t.toLowerCase();
}
class go {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, r) {
    this.attribute = r, this.property = e;
  }
}
go.prototype.attribute = "";
go.prototype.booleanish = !1;
go.prototype.boolean = !1;
go.prototype.commaOrSpaceSeparated = !1;
go.prototype.commaSeparated = !1;
go.prototype.defined = !1;
go.prototype.mustUseProperty = !1;
go.prototype.number = !1;
go.prototype.overloadedBoolean = !1;
go.prototype.property = "";
go.prototype.spaceSeparated = !1;
go.prototype.space = void 0;
let Ice = 0;
const Et = zh(), mn = zh(), NC = zh(), Ee = zh(), Tr = zh(), Jf = zh(), Eo = zh();
function zh() {
  return 2 ** ++Ice;
}
const $C = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Et,
  booleanish: mn,
  commaOrSpaceSeparated: Eo,
  commaSeparated: Jf,
  number: Ee,
  overloadedBoolean: NC,
  spaceSeparated: Tr
}, Symbol.toStringTag, { value: "Module" })), sk = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys($C)
);
class rS extends go {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, r, n, i) {
    let o = -1;
    if (super(e, r), N7(this, "space", i), typeof n == "number")
      for (; ++o < sk.length; ) {
        const s = sk[o];
        N7(this, sk[o], (n & $C[s]) === $C[s]);
      }
  }
}
rS.prototype.defined = !0;
function N7(t, e, r) {
  r && (t[e] = r);
}
function rp(t) {
  const e = {}, r = {};
  for (const [n, i] of Object.entries(t.properties)) {
    const o = new rS(
      n,
      t.transform(t.attributes || {}, n),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(n) && (o.mustUseProperty = !0), e[n] = o, r[RC(n)] = n, r[RC(o.attribute)] = n;
  }
  return new c0(e, r, t.space);
}
const v$ = rp({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: mn,
    ariaAutoComplete: null,
    ariaBusy: mn,
    ariaChecked: mn,
    ariaColCount: Ee,
    ariaColIndex: Ee,
    ariaColSpan: Ee,
    ariaControls: Tr,
    ariaCurrent: null,
    ariaDescribedBy: Tr,
    ariaDetails: null,
    ariaDisabled: mn,
    ariaDropEffect: Tr,
    ariaErrorMessage: null,
    ariaExpanded: mn,
    ariaFlowTo: Tr,
    ariaGrabbed: mn,
    ariaHasPopup: null,
    ariaHidden: mn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Tr,
    ariaLevel: Ee,
    ariaLive: null,
    ariaModal: mn,
    ariaMultiLine: mn,
    ariaMultiSelectable: mn,
    ariaOrientation: null,
    ariaOwns: Tr,
    ariaPlaceholder: null,
    ariaPosInSet: Ee,
    ariaPressed: mn,
    ariaReadOnly: mn,
    ariaRelevant: null,
    ariaRequired: mn,
    ariaRoleDescription: Tr,
    ariaRowCount: Ee,
    ariaRowIndex: Ee,
    ariaRowSpan: Ee,
    ariaSelected: mn,
    ariaSetSize: Ee,
    ariaSort: null,
    ariaValueMax: Ee,
    ariaValueMin: Ee,
    ariaValueNow: Ee,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function y$(t, e) {
  return e in t ? t[e] : e;
}
function b$(t, e) {
  return y$(t, e.toLowerCase());
}
const Bce = rp({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Jf,
    acceptCharset: Tr,
    accessKey: Tr,
    action: null,
    allow: null,
    allowFullScreen: Et,
    allowPaymentRequest: Et,
    allowUserMedia: Et,
    alt: null,
    as: null,
    async: Et,
    autoCapitalize: null,
    autoComplete: Tr,
    autoFocus: Et,
    autoPlay: Et,
    blocking: Tr,
    capture: null,
    charSet: null,
    checked: Et,
    cite: null,
    className: Tr,
    cols: Ee,
    colSpan: null,
    content: null,
    contentEditable: mn,
    controls: Et,
    controlsList: Tr,
    coords: Ee | Jf,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Et,
    defer: Et,
    dir: null,
    dirName: null,
    disabled: Et,
    download: NC,
    draggable: mn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Et,
    formTarget: null,
    headers: Tr,
    height: Ee,
    hidden: NC,
    high: Ee,
    href: null,
    hrefLang: null,
    htmlFor: Tr,
    httpEquiv: Tr,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Et,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Et,
    itemId: null,
    itemProp: Tr,
    itemRef: Tr,
    itemScope: Et,
    itemType: Tr,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Et,
    low: Ee,
    manifest: null,
    max: null,
    maxLength: Ee,
    media: null,
    method: null,
    min: null,
    minLength: Ee,
    multiple: Et,
    muted: Et,
    name: null,
    nonce: null,
    noModule: Et,
    noValidate: Et,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Et,
    optimum: Ee,
    pattern: null,
    ping: Tr,
    placeholder: null,
    playsInline: Et,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Et,
    referrerPolicy: null,
    rel: Tr,
    required: Et,
    reversed: Et,
    rows: Ee,
    rowSpan: Ee,
    sandbox: Tr,
    scope: null,
    scoped: Et,
    seamless: Et,
    selected: Et,
    shadowRootClonable: Et,
    shadowRootDelegatesFocus: Et,
    shadowRootMode: null,
    shape: null,
    size: Ee,
    sizes: null,
    slot: null,
    span: Ee,
    spellCheck: mn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Ee,
    step: null,
    style: null,
    tabIndex: Ee,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Et,
    useMap: null,
    value: mn,
    width: Ee,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Tr,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Ee,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Ee,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Et,
    // Lists. Use CSS to reduce space between items instead
    declare: Et,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Ee,
    // `<img>` and `<object>`
    leftMargin: Ee,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Ee,
    // `<body>`
    marginWidth: Ee,
    // `<body>`
    noResize: Et,
    // `<frame>`
    noHref: Et,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Et,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Et,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Ee,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: mn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Ee,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Ee,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Et,
    disableRemotePlayback: Et,
    prefix: null,
    property: null,
    results: Ee,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: b$
}), Lce = rp({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Eo,
    accentHeight: Ee,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Ee,
    amplitude: Ee,
    arabicForm: null,
    ascent: Ee,
    attributeName: null,
    attributeType: null,
    azimuth: Ee,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Ee,
    by: null,
    calcMode: null,
    capHeight: Ee,
    className: Tr,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Ee,
    diffuseConstant: Ee,
    direction: null,
    display: null,
    dur: null,
    divisor: Ee,
    dominantBaseline: null,
    download: Et,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Ee,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Ee,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Ee,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Jf,
    g2: Jf,
    glyphName: Jf,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Ee,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Ee,
    horizOriginX: Ee,
    horizOriginY: Ee,
    id: null,
    ideographic: Ee,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Ee,
    k: Ee,
    k1: Ee,
    k2: Ee,
    k3: Ee,
    k4: Ee,
    kernelMatrix: Eo,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Ee,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Ee,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Ee,
    overlineThickness: Ee,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Ee,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Tr,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Ee,
    pointsAtY: Ee,
    pointsAtZ: Ee,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Eo,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Eo,
    rev: Eo,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Eo,
    requiredFeatures: Eo,
    requiredFonts: Eo,
    requiredFormats: Eo,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Ee,
    specularExponent: Ee,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Ee,
    strikethroughThickness: Ee,
    string: null,
    stroke: null,
    strokeDashArray: Eo,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Ee,
    strokeOpacity: Ee,
    strokeWidth: null,
    style: null,
    surfaceScale: Ee,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Eo,
    tabIndex: Ee,
    tableValues: null,
    target: null,
    targetX: Ee,
    targetY: Ee,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Eo,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Ee,
    underlineThickness: Ee,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Ee,
    values: null,
    vAlphabetic: Ee,
    vMathematical: Ee,
    vectorEffect: null,
    vHanging: Ee,
    vIdeographic: Ee,
    version: null,
    vertAdvY: Ee,
    vertOriginX: Ee,
    vertOriginY: Ee,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Ee,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: y$
}), x$ = rp({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), w$ = rp({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: b$
}), k$ = rp({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), zce = /[A-Z]/g, $7 = /-[a-z]/g, jce = /^data[-\w.:]+$/i;
function qce(t, e) {
  const r = RC(e);
  let n = e, i = go;
  if (r in t.normal)
    return t.property[t.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && jce.test(e)) {
    if (e.charAt(4) === "-") {
      const o = e.slice(5).replace($7, Hce);
      n = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = e.slice(4);
      if (!$7.test(o)) {
        let s = o.replace(zce, Uce);
        s.charAt(0) !== "-" && (s = "-" + s), e = "data" + s;
      }
    }
    i = rS;
  }
  return new i(n, e);
}
function Uce(t) {
  return "-" + t.toLowerCase();
}
function Hce(t) {
  return t.charAt(1).toUpperCase();
}
const Vce = g$([v$, Bce, x$, w$, k$], "html"), C$ = g$([v$, Lce, x$, w$, k$], "svg"), I7 = {}.hasOwnProperty;
function Wce(t, e) {
  const r = e || {};
  function n(i, ...o) {
    let s = n.invalid;
    const a = n.handlers;
    if (i && I7.call(i, t)) {
      const l = String(i[t]);
      s = I7.call(a, l) ? a[l] : n.unknown;
    }
    if (s)
      return s.call(this, i, ...o);
  }
  return n.handlers = r.handlers || {}, n.invalid = r.invalid, n.unknown = r.unknown, n;
}
const Gce = /["&'<>`]/g, Kce = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Qce = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), Xce = /[|\\{}()[\]^$+*?.]/g, B7 = /* @__PURE__ */ new WeakMap();
function Jce(t, e) {
  if (t = t.replace(
    e.subset ? Yce(e.subset) : Gce,
    n
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(Kce, r).replace(Qce, n);
  function r(i, o, s) {
    return e.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      s.charCodeAt(o + 2),
      e
    );
  }
  function n(i, o, s) {
    return e.format(
      i.charCodeAt(0),
      s.charCodeAt(o + 1),
      e
    );
  }
}
function Yce(t) {
  let e = B7.get(t);
  return e || (e = Zce(t), B7.set(t, e)), e;
}
function Zce(t) {
  const e = [];
  let r = -1;
  for (; ++r < t.length; )
    e.push(t[r].replace(Xce, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
const ehe = /[\dA-Fa-f]/;
function the(t, e, r) {
  const n = "&#x" + t.toString(16).toUpperCase();
  return r && e && !ehe.test(String.fromCharCode(e)) ? n : n + ";";
}
const rhe = /\d/;
function nhe(t, e, r) {
  const n = "&#" + String(t);
  return r && e && !rhe.test(String.fromCharCode(e)) ? n : n + ";";
}
const ihe = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], ak = {
  nbsp: "Â ",
  iexcl: "Â¡",
  cent: "Â¢",
  pound: "Â£",
  curren: "Â¤",
  yen: "Â¥",
  brvbar: "Â¦",
  sect: "Â§",
  uml: "Â¨",
  copy: "Â©",
  ordf: "Âª",
  laquo: "Â«",
  not: "Â¬",
  shy: "Â­",
  reg: "Â®",
  macr: "Â¯",
  deg: "Â°",
  plusmn: "Â±",
  sup2: "Â²",
  sup3: "Â³",
  acute: "Â´",
  micro: "Âµ",
  para: "Â¶",
  middot: "Â·",
  cedil: "Â¸",
  sup1: "Â¹",
  ordm: "Âº",
  raquo: "Â»",
  frac14: "Â¼",
  frac12: "Â½",
  frac34: "Â¾",
  iquest: "Â¿",
  Agrave: "Ã€",
  Aacute: "Ã",
  Acirc: "Ã‚",
  Atilde: "Ãƒ",
  Auml: "Ã„",
  Aring: "Ã…",
  AElig: "Ã†",
  Ccedil: "Ã‡",
  Egrave: "Ãˆ",
  Eacute: "Ã‰",
  Ecirc: "ÃŠ",
  Euml: "Ã‹",
  Igrave: "ÃŒ",
  Iacute: "Ã",
  Icirc: "ÃŽ",
  Iuml: "Ã",
  ETH: "Ã",
  Ntilde: "Ã‘",
  Ograve: "Ã’",
  Oacute: "Ã“",
  Ocirc: "Ã”",
  Otilde: "Ã•",
  Ouml: "Ã–",
  times: "Ã—",
  Oslash: "Ã˜",
  Ugrave: "Ã™",
  Uacute: "Ãš",
  Ucirc: "Ã›",
  Uuml: "Ãœ",
  Yacute: "Ã",
  THORN: "Ãž",
  szlig: "ÃŸ",
  agrave: "Ã ",
  aacute: "Ã¡",
  acirc: "Ã¢",
  atilde: "Ã£",
  auml: "Ã¤",
  aring: "Ã¥",
  aelig: "Ã¦",
  ccedil: "Ã§",
  egrave: "Ã¨",
  eacute: "Ã©",
  ecirc: "Ãª",
  euml: "Ã«",
  igrave: "Ã¬",
  iacute: "Ã­",
  icirc: "Ã®",
  iuml: "Ã¯",
  eth: "Ã°",
  ntilde: "Ã±",
  ograve: "Ã²",
  oacute: "Ã³",
  ocirc: "Ã´",
  otilde: "Ãµ",
  ouml: "Ã¶",
  divide: "Ã·",
  oslash: "Ã¸",
  ugrave: "Ã¹",
  uacute: "Ãº",
  ucirc: "Ã»",
  uuml: "Ã¼",
  yacute: "Ã½",
  thorn: "Ã¾",
  yuml: "Ã¿",
  fnof: "Æ’",
  Alpha: "Î‘",
  Beta: "Î’",
  Gamma: "Î“",
  Delta: "Î”",
  Epsilon: "Î•",
  Zeta: "Î–",
  Eta: "Î—",
  Theta: "Î˜",
  Iota: "Î™",
  Kappa: "Îš",
  Lambda: "Î›",
  Mu: "Îœ",
  Nu: "Î",
  Xi: "Îž",
  Omicron: "ÎŸ",
  Pi: "Î ",
  Rho: "Î¡",
  Sigma: "Î£",
  Tau: "Î¤",
  Upsilon: "Î¥",
  Phi: "Î¦",
  Chi: "Î§",
  Psi: "Î¨",
  Omega: "Î©",
  alpha: "Î±",
  beta: "Î²",
  gamma: "Î³",
  delta: "Î´",
  epsilon: "Îµ",
  zeta: "Î¶",
  eta: "Î·",
  theta: "Î¸",
  iota: "Î¹",
  kappa: "Îº",
  lambda: "Î»",
  mu: "Î¼",
  nu: "Î½",
  xi: "Î¾",
  omicron: "Î¿",
  pi: "Ï€",
  rho: "Ï",
  sigmaf: "Ï‚",
  sigma: "Ïƒ",
  tau: "Ï„",
  upsilon: "Ï…",
  phi: "Ï†",
  chi: "Ï‡",
  psi: "Ïˆ",
  omega: "Ï‰",
  thetasym: "Ï‘",
  upsih: "Ï’",
  piv: "Ï–",
  bull: "â€¢",
  hellip: "â€¦",
  prime: "â€²",
  Prime: "â€³",
  oline: "â€¾",
  frasl: "â„",
  weierp: "â„˜",
  image: "â„‘",
  real: "â„œ",
  trade: "â„¢",
  alefsym: "â„µ",
  larr: "â†",
  uarr: "â†‘",
  rarr: "â†’",
  darr: "â†“",
  harr: "â†”",
  crarr: "â†µ",
  lArr: "â‡",
  uArr: "â‡‘",
  rArr: "â‡’",
  dArr: "â‡“",
  hArr: "â‡”",
  forall: "âˆ€",
  part: "âˆ‚",
  exist: "âˆƒ",
  empty: "âˆ…",
  nabla: "âˆ‡",
  isin: "âˆˆ",
  notin: "âˆ‰",
  ni: "âˆ‹",
  prod: "âˆ",
  sum: "âˆ‘",
  minus: "âˆ’",
  lowast: "âˆ—",
  radic: "âˆš",
  prop: "âˆ",
  infin: "âˆž",
  ang: "âˆ ",
  and: "âˆ§",
  or: "âˆ¨",
  cap: "âˆ©",
  cup: "âˆª",
  int: "âˆ«",
  there4: "âˆ´",
  sim: "âˆ¼",
  cong: "â‰…",
  asymp: "â‰ˆ",
  ne: "â‰ ",
  equiv: "â‰¡",
  le: "â‰¤",
  ge: "â‰¥",
  sub: "âŠ‚",
  sup: "âŠƒ",
  nsub: "âŠ„",
  sube: "âŠ†",
  supe: "âŠ‡",
  oplus: "âŠ•",
  otimes: "âŠ—",
  perp: "âŠ¥",
  sdot: "â‹…",
  lceil: "âŒˆ",
  rceil: "âŒ‰",
  lfloor: "âŒŠ",
  rfloor: "âŒ‹",
  lang: "âŒ©",
  rang: "âŒª",
  loz: "â—Š",
  spades: "â™ ",
  clubs: "â™£",
  hearts: "â™¥",
  diams: "â™¦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Å’",
  oelig: "Å“",
  Scaron: "Å ",
  scaron: "Å¡",
  Yuml: "Å¸",
  circ: "Ë†",
  tilde: "Ëœ",
  ensp: "â€‚",
  emsp: "â€ƒ",
  thinsp: "â€‰",
  zwnj: "â€Œ",
  zwj: "â€",
  lrm: "â€Ž",
  rlm: "â€",
  ndash: "â€“",
  mdash: "â€”",
  lsquo: "â€˜",
  rsquo: "â€™",
  sbquo: "â€š",
  ldquo: "â€œ",
  rdquo: "â€",
  bdquo: "â€ž",
  dagger: "â€ ",
  Dagger: "â€¡",
  permil: "â€°",
  lsaquo: "â€¹",
  rsaquo: "â€º",
  euro: "â‚¬"
}, ohe = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], _$ = {}.hasOwnProperty, IC = {};
let ty;
for (ty in ak)
  _$.call(ak, ty) && (IC[ak[ty]] = ty);
const she = /[^\dA-Za-z]/;
function ahe(t, e, r, n) {
  const i = String.fromCharCode(t);
  if (_$.call(IC, i)) {
    const o = IC[i], s = "&" + o;
    return r && ihe.includes(o) && !ohe.includes(o) && (!n || e && e !== 61 && she.test(String.fromCharCode(e))) ? s : s + ";";
  }
  return "";
}
function lhe(t, e, r) {
  let n = the(t, e, r.omitOptionalSemicolons), i;
  if ((r.useNamedReferences || r.useShortestReferences) && (i = ahe(
    t,
    e,
    r.omitOptionalSemicolons,
    r.attribute
  )), (r.useShortestReferences || !i) && r.useShortestReferences) {
    const o = nhe(t, e, r.omitOptionalSemicolons);
    o.length < n.length && (n = o);
  }
  return i && (!r.useShortestReferences || i.length < n.length) ? i : n;
}
function Yf(t, e) {
  return Jce(t, Object.assign({ format: lhe }, e));
}
const uhe = /^>|^->|<!--|-->|--!>|<!-$/g, che = [">"], hhe = ["<", ">"];
function fhe(t, e, r, n) {
  return n.settings.bogusComments ? "<?" + Yf(
    t.value,
    Object.assign({}, n.settings.characterReferences, {
      subset: che
    })
  ) + ">" : "<!--" + t.value.replace(uhe, i) + "-->";
  function i(o) {
    return Yf(
      o,
      Object.assign({}, n.settings.characterReferences, {
        subset: hhe
      })
    );
  }
}
function dhe(t, e, r, n) {
  return "<!" + (n.settings.upperDoctype ? "DOCTYPE" : "doctype") + (n.settings.tightDoctype ? "" : " ") + "html>";
}
function L7(t, e) {
  const r = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let n = 0, i = r.indexOf(e);
  for (; i !== -1; )
    n++, i = r.indexOf(e, i + e.length);
  return n;
}
function phe(t, e) {
  const r = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (r.padRight ? " " : "") + "," + (r.padLeft === !1 ? "" : " ")
  ).trim();
}
function mhe(t) {
  return t.join(" ").trim();
}
const ghe = /[ \t\n\f\r]/g;
function nS(t) {
  return typeof t == "object" ? t.type === "text" ? z7(t.value) : !1 : z7(t);
}
function z7(t) {
  return t.replace(ghe, "") === "";
}
const On = A$(1), S$ = A$(-1), vhe = [];
function A$(t) {
  return e;
  function e(r, n, i) {
    const o = r ? r.children : vhe;
    let s = (n || 0) + t, a = o[s];
    if (!i)
      for (; a && nS(a); )
        s += t, a = o[s];
    return a;
  }
}
const yhe = {}.hasOwnProperty;
function E$(t) {
  return e;
  function e(r, n, i) {
    return yhe.call(t, r.tagName) && t[r.tagName](r, n, i);
  }
}
const iS = E$({
  body: xhe,
  caption: lk,
  colgroup: lk,
  dd: _he,
  dt: Che,
  head: lk,
  html: bhe,
  li: khe,
  optgroup: She,
  option: Ahe,
  p: whe,
  rp: j7,
  rt: j7,
  tbody: Dhe,
  td: q7,
  tfoot: Ohe,
  th: q7,
  thead: Ehe,
  tr: Fhe
});
function lk(t, e, r) {
  const n = On(r, e, !0);
  return !n || n.type !== "comment" && !(n.type === "text" && nS(n.value.charAt(0)));
}
function bhe(t, e, r) {
  const n = On(r, e);
  return !n || n.type !== "comment";
}
function xhe(t, e, r) {
  const n = On(r, e);
  return !n || n.type !== "comment";
}
function whe(t, e, r) {
  const n = On(r, e);
  return n ? n.type === "element" && (n.tagName === "address" || n.tagName === "article" || n.tagName === "aside" || n.tagName === "blockquote" || n.tagName === "details" || n.tagName === "div" || n.tagName === "dl" || n.tagName === "fieldset" || n.tagName === "figcaption" || n.tagName === "figure" || n.tagName === "footer" || n.tagName === "form" || n.tagName === "h1" || n.tagName === "h2" || n.tagName === "h3" || n.tagName === "h4" || n.tagName === "h5" || n.tagName === "h6" || n.tagName === "header" || n.tagName === "hgroup" || n.tagName === "hr" || n.tagName === "main" || n.tagName === "menu" || n.tagName === "nav" || n.tagName === "ol" || n.tagName === "p" || n.tagName === "pre" || n.tagName === "section" || n.tagName === "table" || n.tagName === "ul") : !r || // Confusing parent.
  !(r.type === "element" && (r.tagName === "a" || r.tagName === "audio" || r.tagName === "del" || r.tagName === "ins" || r.tagName === "map" || r.tagName === "noscript" || r.tagName === "video"));
}
function khe(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && n.tagName === "li";
}
function Che(t, e, r) {
  const n = On(r, e);
  return !!(n && n.type === "element" && (n.tagName === "dt" || n.tagName === "dd"));
}
function _he(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && (n.tagName === "dt" || n.tagName === "dd");
}
function j7(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && (n.tagName === "rp" || n.tagName === "rt");
}
function She(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && n.tagName === "optgroup";
}
function Ahe(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && (n.tagName === "option" || n.tagName === "optgroup");
}
function Ehe(t, e, r) {
  const n = On(r, e);
  return !!(n && n.type === "element" && (n.tagName === "tbody" || n.tagName === "tfoot"));
}
function Dhe(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && (n.tagName === "tbody" || n.tagName === "tfoot");
}
function Ohe(t, e, r) {
  return !On(r, e);
}
function Fhe(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && n.tagName === "tr";
}
function q7(t, e, r) {
  const n = On(r, e);
  return !n || n.type === "element" && (n.tagName === "td" || n.tagName === "th");
}
const The = E$({
  body: Rhe,
  colgroup: Nhe,
  head: Phe,
  html: Mhe,
  tbody: $he
});
function Mhe(t) {
  const e = On(t, -1);
  return !e || e.type !== "comment";
}
function Phe(t) {
  const e = /* @__PURE__ */ new Set();
  for (const n of t.children)
    if (n.type === "element" && (n.tagName === "base" || n.tagName === "title")) {
      if (e.has(n.tagName)) return !1;
      e.add(n.tagName);
    }
  const r = t.children[0];
  return !r || r.type === "element";
}
function Rhe(t) {
  const e = On(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && nS(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function Nhe(t, e, r) {
  const n = S$(r, e), i = On(t, -1, !0);
  return r && n && n.type === "element" && n.tagName === "colgroup" && iS(n, r.children.indexOf(n), r) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function $he(t, e, r) {
  const n = S$(r, e), i = On(t, -1);
  return r && n && n.type === "element" && (n.tagName === "thead" || n.tagName === "tbody") && iS(n, r.children.indexOf(n), r) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const ry = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Ihe(t, e, r, n) {
  const i = n.schema, o = i.space === "svg" ? !1 : n.settings.omitOptionalTags;
  let s = i.space === "svg" ? n.settings.closeEmptyElements : n.settings.voids.includes(t.tagName.toLowerCase());
  const a = [];
  let l;
  i.space === "html" && t.tagName === "svg" && (n.schema = C$);
  const u = Bhe(n, t.properties), c = n.all(
    i.space === "html" && t.tagName === "template" ? t.content : t
  );
  return n.schema = i, c && (s = !1), (u || !o || !The(t, e, r)) && (a.push("<", t.tagName, u ? " " + u : ""), s && (i.space === "svg" || n.settings.closeSelfClosing) && (l = u.charAt(u.length - 1), (!n.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(c), !s && (!o || !iS(t, e, r)) && a.push("</" + t.tagName + ">"), a.join("");
}
function Bhe(t, e) {
  const r = [];
  let n = -1, i;
  if (e) {
    for (i in e)
      if (e[i] !== null && e[i] !== void 0) {
        const o = Lhe(t, i, e[i]);
        o && r.push(o);
      }
  }
  for (; ++n < r.length; ) {
    const o = t.settings.tightAttributes ? r[n].charAt(r[n].length - 1) : void 0;
    n !== r.length - 1 && o !== '"' && o !== "'" && (r[n] += " ");
  }
  return r.join("");
}
function Lhe(t, e, r) {
  const n = qce(t.schema, e), i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, o = t.settings.allowDangerousCharacters ? 0 : 1;
  let s = t.quote, a;
  if (n.overloadedBoolean && (r === n.attribute || r === "") ? r = !0 : (n.boolean || n.overloadedBoolean) && (typeof r != "string" || r === n.attribute || r === "") && (r = !!r), r == null || r === !1 || typeof r == "number" && Number.isNaN(r))
    return "";
  const l = Yf(
    n.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: ry.name[i][o]
    })
  );
  return r === !0 || (r = Array.isArray(r) ? (n.commaSeparated ? phe : mhe)(r, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(r), t.settings.collapseEmptyAttributes && !r) ? l : (t.settings.preferUnquoted && (a = Yf(
    r,
    Object.assign({}, t.settings.characterReferences, {
      attribute: !0,
      subset: ry.unquoted[i][o]
    })
  )), a !== r && (t.settings.quoteSmart && L7(r, s) > L7(r, t.alternative) && (s = t.alternative), a = s + Yf(
    r,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (s === "'" ? ry.single : ry.double)[i][o],
      attribute: !0
    })
  ) + s), l + (a && "=" + a));
}
const zhe = ["<", "&"];
function D$(t, e, r, n) {
  return r && r.type === "element" && (r.tagName === "script" || r.tagName === "style") ? t.value : Yf(
    t.value,
    Object.assign({}, n.settings.characterReferences, {
      subset: zhe
    })
  );
}
function jhe(t, e, r, n) {
  return n.settings.allowDangerousHtml ? t.value : D$(t, e, r, n);
}
function qhe(t, e, r, n) {
  return n.all(t);
}
const Uhe = Wce("type", {
  invalid: Hhe,
  unknown: Vhe,
  handlers: { comment: fhe, doctype: dhe, element: Ihe, raw: jhe, root: qhe, text: D$ }
});
function Hhe(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function Vhe(t) {
  const e = (
    /** @type {Nodes} */
    t
  );
  throw new Error("Cannot compile unknown node `" + e.type + "`");
}
const Whe = {}, Ghe = {}, Khe = [];
function Qhe(t, e) {
  const r = Whe, n = r.quote || '"', i = n === '"' ? "'" : '"';
  if (n !== '"' && n !== "'")
    throw new Error("Invalid quote `" + n + "`, expected `'` or `\"`");
  return {
    one: Xhe,
    all: Jhe,
    settings: {
      omitOptionalTags: r.omitOptionalTags || !1,
      allowParseErrors: r.allowParseErrors || !1,
      allowDangerousCharacters: r.allowDangerousCharacters || !1,
      quoteSmart: r.quoteSmart || !1,
      preferUnquoted: r.preferUnquoted || !1,
      tightAttributes: r.tightAttributes || !1,
      upperDoctype: r.upperDoctype || !1,
      tightDoctype: r.tightDoctype || !1,
      bogusComments: r.bogusComments || !1,
      tightCommaSeparatedLists: r.tightCommaSeparatedLists || !1,
      tightSelfClosing: r.tightSelfClosing || !1,
      collapseEmptyAttributes: r.collapseEmptyAttributes || !1,
      allowDangerousHtml: r.allowDangerousHtml || !1,
      voids: r.voids || $ce,
      characterReferences: r.characterReferences || Ghe,
      closeSelfClosing: r.closeSelfClosing || !1,
      closeEmptyElements: r.closeEmptyElements || !1
    },
    schema: r.space === "svg" ? C$ : Vce,
    quote: n,
    alternative: i
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function Xhe(t, e, r) {
  return Uhe(t, e, r, this);
}
function Jhe(t) {
  const e = [], r = t && t.children || Khe;
  let n = -1;
  for (; ++n < r.length; )
    e[n] = this.one(r[n], n, t);
  return e.join("");
}
function Yhe(t) {
  return Array.isArray(t) ? t : [t];
}
function Zb(t, e = !1) {
  const r = t.split(/(\r?\n)/g);
  let n = 0;
  const i = [];
  for (let o = 0; o < r.length; o += 2) {
    const s = e ? r[o] + (r[o + 1] || "") : r[o];
    i.push([s, n]), n += r[o].length, n += r[o + 1]?.length || 0;
  }
  return i;
}
function oS(t) {
  return !t || ["plaintext", "txt", "text", "plain"].includes(t);
}
function Zhe(t) {
  return t === "ansi" || oS(t);
}
function sS(t) {
  return t === "none";
}
function efe(t) {
  return sS(t);
}
function O$(t, e) {
  if (!e)
    return t;
  t.properties ||= {}, t.properties.class ||= [], typeof t.properties.class == "string" && (t.properties.class = t.properties.class.split(/\s+/g)), Array.isArray(t.properties.class) || (t.properties.class = []);
  const r = Array.isArray(e) ? e : e.split(/\s+/g);
  for (const n of r)
    n && !t.properties.class.includes(n) && t.properties.class.push(n);
  return t;
}
function tfe(t, e) {
  let r = 0;
  const n = [];
  for (const i of e)
    i > r && n.push({
      ...t,
      content: t.content.slice(r, i),
      offset: t.offset + r
    }), r = i;
  return r < t.content.length && n.push({
    ...t,
    content: t.content.slice(r),
    offset: t.offset + r
  }), n;
}
function rfe(t, e) {
  const r = Array.from(e instanceof Set ? e : new Set(e)).sort((n, i) => n - i);
  return r.length ? t.map((n) => n.flatMap((i) => {
    const o = r.filter((s) => i.offset < s && s < i.offset + i.content.length).map((s) => s - i.offset).sort((s, a) => s - a);
    return o.length ? tfe(i, o) : i;
  })) : t;
}
async function F$(t) {
  return Promise.resolve(typeof t == "function" ? t() : t).then((e) => e.default || e);
}
function H1(t, e) {
  const r = typeof t == "string" ? {} : { ...t.colorReplacements }, n = typeof t == "string" ? t : t.name;
  for (const [i, o] of Object.entries(e?.colorReplacements || {}))
    typeof o == "string" ? r[i] = o : i === n && Object.assign(r, o);
  return r;
}
function Vc(t, e) {
  return t && (e?.[t?.toLowerCase()] || t);
}
function T$(t) {
  const e = {};
  return t.color && (e.color = t.color), t.bgColor && (e["background-color"] = t.bgColor), t.fontStyle && (t.fontStyle & Bl.Italic && (e["font-style"] = "italic"), t.fontStyle & Bl.Bold && (e["font-weight"] = "bold"), t.fontStyle & Bl.Underline && (e["text-decoration"] = "underline")), e;
}
function nfe(t) {
  return typeof t == "string" ? t : Object.entries(t).map(([e, r]) => `${e}:${r}`).join(";");
}
function ife(t) {
  const e = Zb(t, !0).map(([i]) => i);
  function r(i) {
    if (i === t.length)
      return {
        line: e.length - 1,
        character: e[e.length - 1].length
      };
    let o = i, s = 0;
    for (const a of e) {
      if (o < a.length)
        break;
      o -= a.length, s++;
    }
    return { line: s, character: o };
  }
  function n(i, o) {
    let s = 0;
    for (let a = 0; a < i; a++)
      s += e[a].length;
    return s += o, s;
  }
  return {
    lines: e,
    indexToPos: r,
    posToIndex: n
  };
}
class Ti extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
}
const M$ = /* @__PURE__ */ new WeakMap();
function ex(t, e) {
  M$.set(t, e);
}
function _g(t) {
  return M$.get(t);
}
class np {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(e, r) {
    return new np(
      Object.fromEntries(Yhe(r).map((n) => [n, PC])),
      e
    );
  }
  constructor(...e) {
    if (e.length === 2) {
      const [r, n] = e;
      this.lang = n, this._stacks = r;
    } else {
      const [r, n, i] = e;
      this.lang = n, this._stacks = { [i]: r };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(e = this.theme) {
    return this._stacks[e];
  }
  /**
   * @deprecated use `getScopes` instead
   */
  get scopes() {
    return U7(this._stacks[this.theme]);
  }
  getScopes(e = this.theme) {
    return U7(this._stacks[e]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.scopes
    };
  }
}
function U7(t) {
  const e = [], r = /* @__PURE__ */ new Set();
  function n(i) {
    if (r.has(i))
      return;
    r.add(i);
    const o = i?.nameScopesList?.scopeName;
    o && e.push(o), i.parent && n(i.parent);
  }
  return n(t), e;
}
function ofe(t, e) {
  if (!(t instanceof np))
    throw new Ti("Invalid grammar state");
  return t.getInternalStack(e);
}
function sfe() {
  const t = /* @__PURE__ */ new WeakMap();
  function e(r) {
    if (!t.has(r.meta)) {
      let n = function(s) {
        if (typeof s == "number") {
          if (s < 0 || s > r.source.length)
            throw new Ti(`Invalid decoration offset: ${s}. Code length: ${r.source.length}`);
          return {
            ...i.indexToPos(s),
            offset: s
          };
        } else {
          const a = i.lines[s.line];
          if (a === void 0)
            throw new Ti(`Invalid decoration position ${JSON.stringify(s)}. Lines length: ${i.lines.length}`);
          if (s.character < 0 || s.character > a.length)
            throw new Ti(`Invalid decoration position ${JSON.stringify(s)}. Line ${s.line} length: ${a.length}`);
          return {
            ...s,
            offset: i.posToIndex(s.line, s.character)
          };
        }
      };
      const i = ife(r.source), o = (r.options.decorations || []).map((s) => ({
        ...s,
        start: n(s.start),
        end: n(s.end)
      }));
      afe(o), t.set(r.meta, {
        decorations: o,
        converter: i,
        source: r.source
      });
    }
    return t.get(r.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(r) {
      if (!this.options.decorations?.length)
        return;
      const n = e(this).decorations.flatMap((i) => [i.start.offset, i.end.offset]);
      return rfe(r, n);
    },
    code(r) {
      if (!this.options.decorations?.length)
        return;
      const n = e(this), i = Array.from(r.children).filter((c) => c.type === "element" && c.tagName === "span");
      if (i.length !== n.converter.lines.length)
        throw new Ti(`Number of lines in code element (${i.length}) does not match the number of lines in the source (${n.converter.lines.length}). Failed to apply decorations.`);
      function o(c, h, d, p) {
        const g = i[c];
        let v = "", y = -1, b = -1;
        if (h === 0 && (y = 0), d === 0 && (b = 0), d === Number.POSITIVE_INFINITY && (b = g.children.length), y === -1 || b === -1)
          for (let C = 0; C < g.children.length; C++)
            v += P$(g.children[C]), y === -1 && v.length === h && (y = C + 1), b === -1 && v.length === d && (b = C + 1);
        if (y === -1)
          throw new Ti(`Failed to find start index for decoration ${JSON.stringify(p.start)}`);
        if (b === -1)
          throw new Ti(`Failed to find end index for decoration ${JSON.stringify(p.end)}`);
        const k = g.children.slice(y, b);
        if (!p.alwaysWrap && k.length === g.children.length)
          a(g, p, "line");
        else if (!p.alwaysWrap && k.length === 1 && k[0].type === "element")
          a(k[0], p, "token");
        else {
          const C = {
            type: "element",
            tagName: "span",
            properties: {},
            children: k
          };
          a(C, p, "wrapper"), g.children.splice(y, k.length, C);
        }
      }
      function s(c, h) {
        i[c] = a(i[c], h, "line");
      }
      function a(c, h, d) {
        const p = h.properties || {}, g = h.transform || ((v) => v);
        return c.tagName = h.tagName || "span", c.properties = {
          ...c.properties,
          ...p,
          class: c.properties.class
        }, h.properties?.class && O$(c, h.properties.class), c = g(c, d) || c, c;
      }
      const l = [], u = n.decorations.sort((c, h) => h.start.offset - c.start.offset);
      for (const c of u) {
        const { start: h, end: d } = c;
        if (h.line === d.line)
          o(h.line, h.character, d.character, c);
        else if (h.line < d.line) {
          o(h.line, h.character, Number.POSITIVE_INFINITY, c);
          for (let p = h.line + 1; p < d.line; p++)
            l.unshift(() => s(p, c));
          o(d.line, 0, d.character, c);
        }
      }
      l.forEach((c) => c());
    }
  };
}
function afe(t) {
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (r.start.offset > r.end.offset)
      throw new Ti(`Invalid decoration range: ${JSON.stringify(r.start)} - ${JSON.stringify(r.end)}`);
    for (let n = e + 1; n < t.length; n++) {
      const i = t[n], o = r.start.offset < i.start.offset && i.start.offset < r.end.offset, s = r.start.offset < i.end.offset && i.end.offset < r.end.offset, a = i.start.offset < r.start.offset && r.start.offset < i.end.offset, l = i.start.offset < r.end.offset && r.end.offset < i.end.offset;
      if (o || s || a || l) {
        if (s && s || a && l)
          continue;
        throw new Ti(`Decorations ${JSON.stringify(r.start)} and ${JSON.stringify(i.start)} intersect.`);
      }
    }
  }
}
function P$(t) {
  return t.type === "text" ? t.value : t.type === "element" ? t.children.map(P$).join("") : "";
}
const lfe = [
  /* @__PURE__ */ sfe()
];
function V1(t) {
  return [
    ...t.transformers || [],
    ...lfe
  ];
}
var Wc = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], uk = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function ufe(t, e) {
  const r = t.indexOf("\x1B[", e);
  if (r !== -1) {
    const n = t.indexOf("m", r);
    return {
      sequence: t.substring(r + 2, n).split(";"),
      startPosition: r,
      position: n + 1
    };
  }
  return {
    position: t.length
  };
}
function H7(t, e) {
  let r = 1;
  const n = t[e + r++];
  let i;
  if (n === "2") {
    const o = [
      t[e + r++],
      t[e + r++],
      t[e + r]
    ].map((s) => Number.parseInt(s));
    o.length === 3 && !o.some((s) => Number.isNaN(s)) && (i = {
      type: "rgb",
      rgb: o
    });
  } else if (n === "5") {
    const o = Number.parseInt(t[e + r]);
    Number.isNaN(o) || (i = { type: "table", index: Number(o) });
  }
  return [r, i];
}
function cfe(t) {
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const n = t[r], i = Number.parseInt(n);
    if (!Number.isNaN(i))
      if (i === 0)
        e.push({ type: "resetAll" });
      else if (i <= 9)
        uk[i] && e.push({
          type: "setDecoration",
          value: uk[i]
        });
      else if (i <= 29) {
        const o = uk[i - 20];
        o && e.push({
          type: "resetDecoration",
          value: o
        });
      } else if (i <= 37)
        e.push({
          type: "setForegroundColor",
          value: { type: "named", name: Wc[i - 30] }
        });
      else if (i === 38) {
        const [o, s] = H7(t, r);
        s && e.push({
          type: "setForegroundColor",
          value: s
        }), r += o;
      } else if (i === 39)
        e.push({
          type: "resetForegroundColor"
        });
      else if (i <= 47)
        e.push({
          type: "setBackgroundColor",
          value: { type: "named", name: Wc[i - 40] }
        });
      else if (i === 48) {
        const [o, s] = H7(t, r);
        s && e.push({
          type: "setBackgroundColor",
          value: s
        }), r += o;
      } else i === 49 ? e.push({
        type: "resetBackgroundColor"
      }) : i >= 90 && i <= 97 ? e.push({
        type: "setForegroundColor",
        value: { type: "named", name: Wc[i - 90 + 8] }
      }) : i >= 100 && i <= 107 && e.push({
        type: "setBackgroundColor",
        value: { type: "named", name: Wc[i - 100 + 8] }
      });
  }
  return e;
}
function hfe() {
  let t = null, e = null, r = /* @__PURE__ */ new Set();
  return {
    parse(n) {
      const i = [];
      let o = 0;
      do {
        const s = ufe(n, o), a = s.sequence ? n.substring(o, s.startPosition) : n.substring(o);
        if (a.length > 0 && i.push({
          value: a,
          foreground: t,
          background: e,
          decorations: new Set(r)
        }), s.sequence) {
          const l = cfe(s.sequence);
          for (const u of l)
            u.type === "resetAll" ? (t = null, e = null, r.clear()) : u.type === "resetForegroundColor" ? t = null : u.type === "resetBackgroundColor" ? e = null : u.type === "resetDecoration" && r.delete(u.value);
          for (const u of l)
            u.type === "setForegroundColor" ? t = u.value : u.type === "setBackgroundColor" ? e = u.value : u.type === "setDecoration" && r.add(u.value);
        }
        o = s.position;
      } while (o < n.length);
      return i;
    }
  };
}
var ffe = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function dfe(t = ffe) {
  function e(a) {
    return t[a];
  }
  function r(a) {
    return `#${a.map((l) => Math.max(0, Math.min(l, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let n;
  function i() {
    if (n)
      return n;
    n = [];
    for (let u = 0; u < Wc.length; u++)
      n.push(e(Wc[u]));
    let a = [0, 95, 135, 175, 215, 255];
    for (let u = 0; u < 6; u++)
      for (let c = 0; c < 6; c++)
        for (let h = 0; h < 6; h++)
          n.push(r([a[u], a[c], a[h]]));
    let l = 8;
    for (let u = 0; u < 24; u++, l += 10)
      n.push(r([l, l, l]));
    return n;
  }
  function o(a) {
    return i()[a];
  }
  function s(a) {
    switch (a.type) {
      case "named":
        return e(a.name);
      case "rgb":
        return r(a.rgb);
      case "table":
        return o(a.index);
    }
  }
  return {
    value: s
  };
}
function pfe(t, e, r) {
  const n = H1(t, r), i = Zb(e), o = dfe(
    Object.fromEntries(
      Wc.map((a) => [
        a,
        t.colors?.[`terminal.ansi${a[0].toUpperCase()}${a.substring(1)}`]
      ])
    )
  ), s = hfe();
  return i.map(
    (a) => s.parse(a[0]).map((l) => {
      let u, c;
      l.decorations.has("reverse") ? (u = l.background ? o.value(l.background) : t.bg, c = l.foreground ? o.value(l.foreground) : t.fg) : (u = l.foreground ? o.value(l.foreground) : t.fg, c = l.background ? o.value(l.background) : void 0), u = Vc(u, n), c = Vc(c, n), l.decorations.has("dim") && (u = mfe(u));
      let h = Bl.None;
      return l.decorations.has("bold") && (h |= Bl.Bold), l.decorations.has("italic") && (h |= Bl.Italic), l.decorations.has("underline") && (h |= Bl.Underline), {
        content: l.value,
        offset: a[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: u,
        bgColor: c,
        fontStyle: h
      };
    })
  );
}
function mfe(t) {
  const e = t.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (e)
    if (e[3]) {
      const n = Math.round(Number.parseInt(e[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${e[1]}${e[2]}${n}`;
    } else return e[2] ? `#${e[1]}${e[2]}80` : `#${Array.from(e[1]).map((n) => `${n}${n}`).join("")}80`;
  const r = t.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return r ? `var(${r[1]}-dim)` : t;
}
function aS(t, e, r = {}) {
  const {
    lang: n = "text",
    theme: i = t.getLoadedThemes()[0]
  } = r;
  if (oS(n) || sS(i))
    return Zb(e).map((l) => [{ content: l[0], offset: l[1] }]);
  const { theme: o, colorMap: s } = t.setTheme(i);
  if (n === "ansi")
    return pfe(o, e, r);
  const a = t.getLanguage(n);
  if (r.grammarState) {
    if (r.grammarState.lang !== a.name)
      throw new sh(`Grammar state language "${r.grammarState.lang}" does not match highlight language "${a.name}"`);
    if (!r.grammarState.themes.includes(o.name))
      throw new sh(`Grammar state themes "${r.grammarState.themes}" do not contain highlight theme "${o.name}"`);
  }
  return vfe(e, a, o, s, r);
}
function gfe(...t) {
  if (t.length === 2)
    return _g(t[1]);
  const [e, r, n = {}] = t, {
    lang: i = "text",
    theme: o = e.getLoadedThemes()[0]
  } = n;
  if (oS(i) || sS(o))
    throw new sh("Plain language does not have grammar state");
  if (i === "ansi")
    throw new sh("ANSI language does not have grammar state");
  const { theme: s, colorMap: a } = e.setTheme(o), l = e.getLanguage(i);
  return new np(
    W1(r, l, s, a, n).stateStack,
    l.name,
    s.name
  );
}
function vfe(t, e, r, n, i) {
  const o = W1(t, e, r, n, i), s = new np(
    W1(t, e, r, n, i).stateStack,
    e.name,
    r.name
  );
  return ex(o.tokens, s), o.tokens;
}
function W1(t, e, r, n, i) {
  const o = H1(r, i), {
    tokenizeMaxLineLength: s = 0,
    tokenizeTimeLimit: a = 500
  } = i, l = Zb(t);
  let u = i.grammarState ? ofe(i.grammarState, r.name) ?? PC : i.grammarContextCode != null ? W1(
    i.grammarContextCode,
    e,
    r,
    n,
    {
      ...i,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : PC, c = [];
  const h = [];
  for (let d = 0, p = l.length; d < p; d++) {
    const [g, v] = l[d];
    if (g === "") {
      c = [], h.push([]);
      continue;
    }
    if (s > 0 && g.length >= s) {
      c = [], h.push([{
        content: g,
        offset: v,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let y, b, k;
    i.includeExplanation && (y = e.tokenizeLine(g, u), b = y.tokens, k = 0);
    const C = e.tokenizeLine2(g, u, a), S = C.tokens.length / 2;
    for (let _ = 0; _ < S; _++) {
      const D = C.tokens[2 * _], A = _ + 1 < S ? C.tokens[2 * _ + 2] : g.length;
      if (D === A)
        continue;
      const O = C.tokens[2 * _ + 1], M = Vc(
        n[Fd.getForeground(O)],
        o
      ), z = Fd.getFontStyle(O), R = {
        content: g.substring(D, A),
        offset: v + D,
        color: M,
        fontStyle: z
      };
      if (i.includeExplanation) {
        const N = [];
        if (i.includeExplanation !== "scopeName")
          for (const B of r.settings) {
            let $;
            switch (typeof B.scope) {
              case "string":
                $ = B.scope.split(/,/).map((q) => q.trim());
                break;
              case "object":
                $ = B.scope;
                break;
              default:
                continue;
            }
            N.push({
              settings: B,
              selectors: $.map((q) => q.split(/ /))
            });
          }
        R.explanation = [];
        let I = 0;
        for (; D + I < A; ) {
          const B = b[k], $ = g.substring(
            B.startIndex,
            B.endIndex
          );
          I += $.length, R.explanation.push({
            content: $,
            scopes: i.includeExplanation === "scopeName" ? yfe(
              B.scopes
            ) : bfe(
              N,
              B.scopes
            )
          }), k += 1;
        }
      }
      c.push(R);
    }
    h.push(c), c = [], u = C.ruleStack;
  }
  return {
    tokens: h,
    stateStack: u
  };
}
function yfe(t) {
  return t.map((e) => ({ scopeName: e }));
}
function bfe(t, e) {
  const r = [];
  for (let n = 0, i = e.length; n < i; n++) {
    const o = e[n];
    r[n] = {
      scopeName: o,
      themeMatches: wfe(t, o, e.slice(0, n))
    };
  }
  return r;
}
function V7(t, e) {
  return t === e || e.substring(0, t.length) === t && e[t.length] === ".";
}
function xfe(t, e, r) {
  if (!V7(t[t.length - 1], e))
    return !1;
  let n = t.length - 2, i = r.length - 1;
  for (; n >= 0 && i >= 0; )
    V7(t[n], r[i]) && (n -= 1), i -= 1;
  return n === -1;
}
function wfe(t, e, r) {
  const n = [];
  for (const { selectors: i, settings: o } of t)
    for (const s of i)
      if (xfe(s, e, r)) {
        n.push(o);
        break;
      }
  return n;
}
function R$(t, e, r) {
  const n = Object.entries(r.themes).filter((l) => l[1]).map((l) => ({ color: l[0], theme: l[1] })), i = n.map((l) => {
    const u = aS(t, e, {
      ...r,
      theme: l.theme
    }), c = _g(u), h = typeof l.theme == "string" ? l.theme : l.theme.name;
    return {
      tokens: u,
      state: c,
      theme: h
    };
  }), o = kfe(
    ...i.map((l) => l.tokens)
  ), s = o[0].map(
    (l, u) => l.map((c, h) => {
      const d = {
        content: c.content,
        variants: {},
        offset: c.offset
      };
      return "includeExplanation" in r && r.includeExplanation && (d.explanation = c.explanation), o.forEach((p, g) => {
        const {
          content: v,
          explanation: y,
          offset: b,
          ...k
        } = p[u][h];
        d.variants[n[g].color] = k;
      }), d;
    })
  ), a = i[0].state ? new np(
    Object.fromEntries(i.map((l) => [l.theme, l.state?.getInternalStack(l.theme)])),
    i[0].state.lang
  ) : void 0;
  return a && ex(s, a), s;
}
function kfe(...t) {
  const e = t.map(() => []), r = t.length;
  for (let n = 0; n < t[0].length; n++) {
    const i = t.map((l) => l[n]), o = e.map(() => []);
    e.forEach((l, u) => l.push(o[u]));
    const s = i.map(() => 0), a = i.map((l) => l[0]);
    for (; a.every((l) => l); ) {
      const l = Math.min(...a.map((u) => u.content.length));
      for (let u = 0; u < r; u++) {
        const c = a[u];
        c.content.length === l ? (o[u].push(c), s[u] += 1, a[u] = i[u][s[u]]) : (o[u].push({
          ...c,
          content: c.content.slice(0, l)
        }), a[u] = {
          ...c,
          content: c.content.slice(l),
          offset: c.offset + l
        });
      }
    }
  }
  return e;
}
function G1(t, e, r) {
  let n, i, o, s, a, l;
  if ("themes" in r) {
    const {
      defaultColor: u = "light",
      cssVariablePrefix: c = "--shiki-"
    } = r, h = Object.entries(r.themes).filter((y) => y[1]).map((y) => ({ color: y[0], theme: y[1] })).sort((y, b) => y.color === u ? -1 : b.color === u ? 1 : 0);
    if (h.length === 0)
      throw new sh("`themes` option must not be empty");
    const d = R$(
      t,
      e,
      r
    );
    if (l = _g(d), u && !h.find((y) => y.color === u))
      throw new sh(`\`themes\` option must contain the defaultColor key \`${u}\``);
    const p = h.map((y) => t.getTheme(y.theme)), g = h.map((y) => y.color);
    o = d.map((y) => y.map((b) => Cfe(b, g, c, u))), l && ex(o, l);
    const v = h.map((y) => H1(y.theme, r));
    i = h.map((y, b) => (b === 0 && u ? "" : `${c + y.color}:`) + (Vc(p[b].fg, v[b]) || "inherit")).join(";"), n = h.map((y, b) => (b === 0 && u ? "" : `${c + y.color}-bg:`) + (Vc(p[b].bg, v[b]) || "inherit")).join(";"), s = `shiki-themes ${p.map((y) => y.name).join(" ")}`, a = u ? void 0 : [i, n].join(";");
  } else if ("theme" in r) {
    const u = H1(r.theme, r);
    o = aS(
      t,
      e,
      r
    );
    const c = t.getTheme(r.theme);
    n = Vc(c.bg, u), i = Vc(c.fg, u), s = c.name, l = _g(o);
  } else
    throw new sh("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: o,
    fg: i,
    bg: n,
    themeName: s,
    rootStyle: a,
    grammarState: l
  };
}
function Cfe(t, e, r, n) {
  const i = {
    content: t.content,
    explanation: t.explanation,
    offset: t.offset
  }, o = e.map((l) => T$(t.variants[l])), s = new Set(o.flatMap((l) => Object.keys(l))), a = {};
  return o.forEach((l, u) => {
    for (const c of s) {
      const h = l[c] || "inherit";
      if (u === 0 && n)
        a[c] = h;
      else {
        const d = c === "color" ? "" : c === "background-color" ? "-bg" : `-${c}`, p = r + e[u] + (c === "color" ? "" : d);
        a[p] = h;
      }
    }
  }), i.htmlStyle = a, i;
}
function K1(t, e, r, n = {
  meta: {},
  options: r,
  codeToHast: (i, o) => K1(t, i, o),
  codeToTokens: (i, o) => G1(t, i, o)
}) {
  let i = e;
  for (const p of V1(r))
    i = p.preprocess?.call(n, i, r) || i;
  let {
    tokens: o,
    fg: s,
    bg: a,
    themeName: l,
    rootStyle: u,
    grammarState: c
  } = G1(t, i, r);
  const {
    mergeWhitespaces: h = !0
  } = r;
  h === !0 ? o = Sfe(o) : h === "never" && (o = Afe(o));
  const d = {
    ...n,
    get source() {
      return i;
    }
  };
  for (const p of V1(r))
    o = p.tokens?.call(d, o) || o;
  return _fe(
    o,
    {
      ...r,
      fg: s,
      bg: a,
      themeName: l,
      rootStyle: u
    },
    d,
    c
  );
}
function _fe(t, e, r, n = _g(t)) {
  const i = V1(e), o = [], s = {
    type: "root",
    children: []
  }, {
    structure: a = "classic",
    tabindex: l = "0"
  } = e;
  let u = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${e.themeName || ""}`,
      style: e.rootStyle || `background-color:${e.bg};color:${e.fg}`,
      ...l !== !1 && l != null ? {
        tabindex: l.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(e.meta || {})
        ).filter(([g]) => !g.startsWith("_"))
      )
    },
    children: []
  }, c = {
    type: "element",
    tagName: "code",
    properties: {},
    children: o
  };
  const h = [], d = {
    ...r,
    structure: a,
    addClassToHast: O$,
    get source() {
      return r.source;
    },
    get tokens() {
      return t;
    },
    get options() {
      return e;
    },
    get root() {
      return s;
    },
    get pre() {
      return u;
    },
    get code() {
      return c;
    },
    get lines() {
      return h;
    }
  };
  if (t.forEach((g, v) => {
    v && (a === "inline" ? s.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : a === "classic" && o.push({ type: "text", value: `
` }));
    let y = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, b = 0;
    for (const k of g) {
      let C = {
        type: "element",
        tagName: "span",
        properties: {
          ...k.htmlAttrs
        },
        children: [{ type: "text", value: k.content }]
      };
      k.htmlStyle;
      const S = nfe(k.htmlStyle || T$(k));
      S && (C.properties.style = S);
      for (const _ of i)
        C = _?.span?.call(d, C, v + 1, b, y, k) || C;
      a === "inline" ? s.children.push(C) : a === "classic" && y.children.push(C), b += k.content.length;
    }
    if (a === "classic") {
      for (const k of i)
        y = k?.line?.call(d, y, v + 1) || y;
      h.push(y), o.push(y);
    }
  }), a === "classic") {
    for (const g of i)
      c = g?.code?.call(d, c) || c;
    u.children.push(c);
    for (const g of i)
      u = g?.pre?.call(d, u) || u;
    s.children.push(u);
  }
  let p = s;
  for (const g of i)
    p = g?.root?.call(d, p) || p;
  return n && ex(p, n), p;
}
function Sfe(t) {
  return t.map((e) => {
    const r = [];
    let n = "", i = 0;
    return e.forEach((o, s) => {
      const a = !(o.fontStyle && o.fontStyle & Bl.Underline);
      a && o.content.match(/^\s+$/) && e[s + 1] ? (i || (i = o.offset), n += o.content) : n ? (a ? r.push({
        ...o,
        offset: i,
        content: n + o.content
      }) : r.push(
        {
          content: n,
          offset: i
        },
        o
      ), i = 0, n = "") : r.push(o);
    }), r;
  });
}
function Afe(t) {
  return t.map((e) => e.flatMap((r) => {
    if (r.content.match(/^\s+$/))
      return r;
    const n = r.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!n)
      return r;
    const [, i, o, s] = n;
    if (!i && !s)
      return r;
    const a = [{
      ...r,
      offset: r.offset + i.length,
      content: o
    }];
    return i && a.unshift({
      content: i,
      offset: r.offset
    }), s && a.push({
      content: s,
      offset: r.offset + i.length + o.length
    }), a;
  }));
}
function Efe(t, e, r) {
  const n = {
    meta: {},
    options: r,
    codeToHast: (o, s) => K1(t, o, s),
    codeToTokens: (o, s) => G1(t, o, s)
  };
  let i = Qhe(K1(t, e, r, n));
  for (const o of V1(r))
    i = o.postprocess?.call(n, i, r) || i;
  return i;
}
const W7 = { light: "#333333", dark: "#bbbbbb" }, G7 = { light: "#fffffe", dark: "#1e1e1e" }, K7 = "__shiki_resolved";
function lS(t) {
  if (t?.[K7])
    return t;
  const e = {
    ...t
  };
  e.tokenColors && !e.settings && (e.settings = e.tokenColors, delete e.tokenColors), e.type ||= "dark", e.colorReplacements = { ...e.colorReplacements }, e.settings ||= [];
  let { bg: r, fg: n } = e;
  if (!r || !n) {
    const a = e.settings ? e.settings.find((l) => !l.name && !l.scope) : void 0;
    a?.settings?.foreground && (n = a.settings.foreground), a?.settings?.background && (r = a.settings.background), !n && e?.colors?.["editor.foreground"] && (n = e.colors["editor.foreground"]), !r && e?.colors?.["editor.background"] && (r = e.colors["editor.background"]), n || (n = e.type === "light" ? W7.light : W7.dark), r || (r = e.type === "light" ? G7.light : G7.dark), e.fg = n, e.bg = r;
  }
  e.settings[0] && e.settings[0].settings && !e.settings[0].scope || e.settings.unshift({
    settings: {
      foreground: e.fg,
      background: e.bg
    }
  });
  let i = 0;
  const o = /* @__PURE__ */ new Map();
  function s(a) {
    if (o.has(a))
      return o.get(a);
    i += 1;
    const l = `#${i.toString(16).padStart(8, "0").toLowerCase()}`;
    return e.colorReplacements?.[`#${l}`] ? s(a) : (o.set(a, l), l);
  }
  e.settings = e.settings.map((a) => {
    const l = a.settings?.foreground && !a.settings.foreground.startsWith("#"), u = a.settings?.background && !a.settings.background.startsWith("#");
    if (!l && !u)
      return a;
    const c = {
      ...a,
      settings: {
        ...a.settings
      }
    };
    if (l) {
      const h = s(a.settings.foreground);
      e.colorReplacements[h] = a.settings.foreground, c.settings.foreground = h;
    }
    if (u) {
      const h = s(a.settings.background);
      e.colorReplacements[h] = a.settings.background, c.settings.background = h;
    }
    return c;
  });
  for (const a of Object.keys(e.colors || {}))
    if ((a === "editor.foreground" || a === "editor.background" || a.startsWith("terminal.ansi")) && !e.colors[a]?.startsWith("#")) {
      const l = s(e.colors[a]);
      e.colorReplacements[l] = e.colors[a], e.colors[a] = l;
    }
  return Object.defineProperty(e, K7, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), e;
}
async function N$(t) {
  return Array.from(new Set((await Promise.all(
    t.filter((e) => !Zhe(e)).map(async (e) => await F$(e).then((r) => Array.isArray(r) ? r : [r]))
  )).flat()));
}
async function $$(t) {
  return (await Promise.all(
    t.map(
      async (e) => efe(e) ? null : lS(await F$(e))
    )
  )).filter((e) => !!e);
}
class Dfe extends Nce {
  constructor(e, r, n, i = {}) {
    super(e), this._resolver = e, this._themes = r, this._langs = n, this._alias = i, this._themes.map((o) => this.loadTheme(o)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(e) {
    return typeof e == "string" ? this._resolvedThemes.get(e) : this.loadTheme(e);
  }
  loadTheme(e) {
    const r = lS(e);
    return r.name && (this._resolvedThemes.set(r.name, r), this._loadedThemesCache = null), r;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(e) {
    let r = this._textmateThemeCache.get(e);
    r || (r = L1.createFromRawTheme(e), this._textmateThemeCache.set(e, r)), this._syncRegistry.setTheme(r);
  }
  getGrammar(e) {
    if (this._alias[e]) {
      const r = /* @__PURE__ */ new Set([e]);
      for (; this._alias[e]; ) {
        if (e = this._alias[e], r.has(e))
          throw new Ti(`Circular alias \`${Array.from(r).join(" -> ")} -> ${e}\``);
        r.add(e);
      }
    }
    return this._resolvedGrammars.get(e);
  }
  loadLanguage(e) {
    if (this.getGrammar(e.name))
      return;
    const r = new Set(
      [...this._langMap.values()].filter((o) => o.embeddedLangsLazy?.includes(e.name))
    );
    this._resolver.addLanguage(e);
    const n = {
      balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(e.scopeName, e);
    const i = this.loadGrammarWithConfiguration(e.scopeName, 1, n);
    if (i.name = e.name, this._resolvedGrammars.set(e.name, i), e.aliases && e.aliases.forEach((o) => {
      this._alias[o] = e.name;
    }), this._loadedLanguagesCache = null, r.size)
      for (const o of r)
        this._resolvedGrammars.delete(o.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(o.scopeName), this._syncRegistry?._grammars?.delete(o.scopeName), this.loadLanguage(this._langMap.get(o.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(e) {
    for (const i of e)
      this.resolveEmbeddedLanguages(i);
    const r = Array.from(this._langGraph.entries()), n = r.filter(([i, o]) => !o);
    if (n.length) {
      const i = r.filter(([o, s]) => s && s.embeddedLangs?.some((a) => n.map(([l]) => l).includes(a))).filter((o) => !n.includes(o));
      throw new Ti(`Missing languages ${n.map(([o]) => `\`${o}\``).join(", ")}, required by ${i.map(([o]) => `\`${o}\``).join(", ")}`);
    }
    for (const [i, o] of r)
      this._resolver.addLanguage(o);
    for (const [i, o] of r)
      this.loadLanguage(o);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(e) {
    if (this._langMap.set(e.name, e), this._langGraph.set(e.name, e), e.embeddedLangs)
      for (const r of e.embeddedLangs)
        this._langGraph.set(r, this._langMap.get(r));
  }
}
class Ofe {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(e, r) {
    this._onigLib = {
      createOnigScanner: (n) => e.createScanner(n),
      createOnigString: (n) => e.createString(n)
    }, r.forEach((n) => this.addLanguage(n));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(e) {
    return this._langs.get(e);
  }
  loadGrammar(e) {
    return this._scopeToLang.get(e);
  }
  addLanguage(e) {
    this._langs.set(e.name, e), e.aliases && e.aliases.forEach((r) => {
      this._langs.set(r, e);
    }), this._scopeToLang.set(e.scopeName, e), e.injectTo && e.injectTo.forEach((r) => {
      this._injections.get(r) || this._injections.set(r, []), this._injections.get(r).push(e.scopeName);
    });
  }
  getInjections(e) {
    const r = e.split(".");
    let n = [];
    for (let i = 1; i <= r.length; i++) {
      const o = r.slice(0, i).join(".");
      n = [...n, ...this._injections.get(o) || []];
    }
    return n;
  }
}
let em = 0;
function Ffe(t) {
  em += 1, t.warnings !== !1 && em >= 10 && em % 10 === 0 && console.warn(`[Shiki] ${em} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let e = !1;
  if (!t.engine)
    throw new Ti("`engine` option is required for synchronous mode");
  const r = (t.langs || []).flat(1), n = (t.themes || []).flat(1).map(lS), i = new Ofe(t.engine, r), o = new Dfe(i, n, r, t.langAlias);
  let s;
  function a(k) {
    y();
    const C = o.getGrammar(typeof k == "string" ? k : k.name);
    if (!C)
      throw new Ti(`Language \`${k}\` not found, you may need to load it first`);
    return C;
  }
  function l(k) {
    if (k === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    y();
    const C = o.getTheme(k);
    if (!C)
      throw new Ti(`Theme \`${k}\` not found, you may need to load it first`);
    return C;
  }
  function u(k) {
    y();
    const C = l(k);
    s !== k && (o.setTheme(C), s = k);
    const S = o.getColorMap();
    return {
      theme: C,
      colorMap: S
    };
  }
  function c() {
    return y(), o.getLoadedThemes();
  }
  function h() {
    return y(), o.getLoadedLanguages();
  }
  function d(...k) {
    y(), o.loadLanguages(k.flat(1));
  }
  async function p(...k) {
    return d(await N$(k));
  }
  function g(...k) {
    y();
    for (const C of k.flat(1))
      o.loadTheme(C);
  }
  async function v(...k) {
    return y(), g(await $$(k));
  }
  function y() {
    if (e)
      throw new Ti("Shiki instance has been disposed");
  }
  function b() {
    e || (e = !0, o.dispose(), em -= 1);
  }
  return {
    setTheme: u,
    getTheme: l,
    getLanguage: a,
    getLoadedThemes: c,
    getLoadedLanguages: h,
    loadLanguage: p,
    loadLanguageSync: d,
    loadTheme: v,
    loadThemeSync: g,
    dispose: b,
    [Symbol.dispose]: b
  };
}
async function Tfe(t = {}) {
  t.loadWasm;
  const [
    e,
    r,
    n
  ] = await Promise.all([
    $$(t.themes || []),
    N$(t.langs || []),
    t.engine || Que(t.loadWasm || Kue())
  ]);
  return Ffe({
    ...t,
    themes: e,
    langs: r,
    engine: n
  });
}
async function Mfe(t = {}) {
  const e = await Tfe(t);
  return {
    getLastGrammarState: (...r) => gfe(e, ...r),
    codeToTokensBase: (r, n) => aS(e, r, n),
    codeToTokensWithThemes: (r, n) => R$(e, r, n),
    codeToTokens: (r, n) => G1(e, r, n),
    codeToHast: (r, n) => K1(e, r, n),
    codeToHtml: (r, n) => Efe(e, r, n),
    ...e,
    getInternalContext: () => e
  };
}
const BC = ws({
  linkify: !0,
  typographer: !0
});
(async () => {
  const t = await Mfe({
    themes: [
      import("./chunk-CcmG315c.js"),
      import("./chunk-Cym-eLtO.js")
    ],
    langs: [import("./chunk-fa8UlHZE.js")]
  });
  BC.use(Fue(t, {
    themes: {
      light: "vitesse-light",
      dark: "vitesse-dark"
    }
  }));
})();
function Zf(t, e = !0) {
  return e ? BC.renderInline(t) : BC.render(t);
}
const Pfe = m4({
  String: oe.string,
  Number: oe.number,
  "True False": oe.bool,
  PropertyName: oe.propertyName,
  Null: oe.null,
  ", :": oe.separator,
  "[ ]": oe.squareBracket,
  "{ }": oe.brace
}), Rfe = ug.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "âš  JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [Pfe],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), Nfe = () => (t) => {
  try {
    JSON.parse(t.state.doc.toString());
  } catch (e) {
    if (!(e instanceof SyntaxError))
      throw e;
    const r = $fe(e, t.state.doc);
    return [{
      from: r,
      message: e.message,
      severity: "error",
      to: r
    }];
  }
  return [];
};
function $fe(t, e) {
  let r;
  return (r = t.message.match(/at position (\d+)/)) ? Math.min(+r[1], e.length) : (r = t.message.match(/at line (\d+) column (\d+)/)) ? Math.min(e.line(+r[1]).from + +r[2] - 1, e.length) : 0;
}
const I$ = /* @__PURE__ */ ig.define({
  name: "json",
  parser: /* @__PURE__ */ Rfe.configure({
    props: [
      /* @__PURE__ */ v4.add({
        Object: /* @__PURE__ */ rC({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ rC({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ bP.add({
        "Object Array": qZ
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function Ife() {
  return new vP(I$);
}
var Q7 = {}, X7;
function Bfe() {
  return X7 || (X7 = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.parse = t.enableErrorLogging = t.disableErrorLogging = t.setErrorLogger = void 0;
    let e = console.error;
    function r(A) {
      e = A;
    }
    t.setErrorLogger = r;
    function n() {
      e = () => {
      };
    }
    t.disableErrorLogging = n;
    function i() {
      e = console.error;
    }
    t.enableErrorLogging = i;
    function o(A) {
      if (A !== void 0) {
        if (A === null)
          return null;
        if (A === "")
          return "";
        A = A.replace(/\\+$/, (O) => O.length % 2 === 0 ? O : O.slice(0, -1));
        try {
          return JSON.parse(A);
        } catch (O) {
          const [M, z] = A.trimLeft()[0] === ":" ? s(A, O) : s(A, O, b);
          if (o.lastParseReminding = z, o.onExtraToken && z.length > 0) {
            const R = z.trimRight();
            o.lastParseReminding = R, R.length > 0 && o.onExtraToken(A, M, R);
          }
          return M;
        }
      }
    }
    t.parse = o, (function(A) {
      A.onExtraToken = (O, M, z) => {
        e("parsed json with extra tokens:", {
          text: O,
          data: M,
          reminding: z
        });
      };
    })(o = t.parse || (t.parse = {}));
    function s(A, O, M) {
      const z = l[A[0]] || M;
      if (!z)
        throw e(`no parser registered for ${JSON.stringify(A[0])}:`, { s: A }), O;
      return z(A, O);
    }
    function a(A, O, M) {
      return A[0] === '"' ? g(A) : A[0] === "'" ? y(A) : b(A, O, M);
    }
    const l = {};
    function u(A) {
      return A.trimLeft();
    }
    l[" "] = c, l["\r"] = c, l[`
`] = c, l["	"] = c;
    function c(A, O) {
      return A = u(A), s(A, O);
    }
    l["["] = h;
    function h(A, O) {
      A = A.substr(1);
      const M = [];
      for (A = u(A); A.length > 0; ) {
        if (A[0] === "]") {
          A = A.substr(1);
          break;
        }
        const z = s(A, O, (R, N) => b(R, N, [",", "]"]));
        M.push(z[0]), A = z[1], A = u(A), A[0] === "," && (A = A.substring(1), A = u(A));
      }
      return [M, A];
    }
    for (const A of "0123456789.-".slice())
      l[A] = d;
    function d(A) {
      for (let O = 0; O < A.length; O++) {
        const M = A[O];
        if (l[M] === d)
          continue;
        const z = A.substring(0, O);
        return A = A.substring(O), [p(z), A];
      }
      return [p(A), ""];
    }
    function p(A) {
      if (A === "-")
        return -0;
      const O = +A;
      return Number.isNaN(O) ? A : O;
    }
    l['"'] = g;
    function g(A) {
      for (let O = 1; O < A.length; O++) {
        const M = A[O];
        if (M === "\\") {
          O++;
          continue;
        }
        if (M === '"') {
          const z = v(A.substring(0, O + 1));
          return A = A.substring(O + 1), [JSON.parse(z), A];
        }
      }
      return [JSON.parse(v(A) + '"'), ""];
    }
    function v(A) {
      return A.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    }
    l["'"] = y;
    function y(A) {
      for (let O = 1; O < A.length; O++) {
        const M = A[O];
        if (M === "\\") {
          O++;
          continue;
        }
        if (M === "'") {
          const z = v(A.substring(0, O + 1));
          return A = A.substring(O + 1), [JSON.parse('"' + z.slice(1, -1) + '"'), A];
        }
      }
      return [JSON.parse('"' + v(A.slice(1)) + '"'), ""];
    }
    function b(A, O, M = [" "]) {
      const z = Math.min(...M.map((I) => {
        const B = A.indexOf(I);
        return B === -1 ? A.length : B;
      })), R = A.substring(0, z).trim(), N = A.substring(z);
      return [R, N];
    }
    l["{"] = k;
    function k(A, O) {
      A = A.substr(1);
      const M = {};
      for (A = u(A); A.length > 0; ) {
        if (A[0] === "}") {
          A = A.substr(1);
          break;
        }
        const z = a(A, O, [":", "}"]), R = z[0];
        if (A = z[1], A = u(A), A[0] !== ":") {
          M[R] = void 0;
          break;
        }
        if (A = A.substr(1), A = u(A), A.length === 0) {
          M[R] = void 0;
          break;
        }
        const N = s(A, O);
        M[R] = N[0], A = N[1], A = u(A), A[0] === "," && (A = A.substr(1), A = u(A));
      }
      return [M, A];
    }
    l.t = C;
    function C(A, O) {
      return D(A, "true", !0, O);
    }
    l.f = S;
    function S(A, O) {
      return D(A, "false", !1, O);
    }
    l.n = _;
    function _(A, O) {
      return D(A, "null", null, O);
    }
    function D(A, O, M, z) {
      for (let R = O.length; R >= 1; R--)
        if (A.startsWith(O.slice(0, R)))
          return [M, A.slice(R)];
      {
        const R = JSON.stringify(A.slice(0, O.length));
        throw e(`unknown token starting with ${R}:`, { s: A }), z;
      }
    }
  })(Q7)), Q7;
}
var B$ = Bfe();
function Lfe(t) {
  let e = null;
  try {
    e = JSON.parse(t.doc.toString());
  } catch {
    try {
      e = B$.parse(t.doc.toString());
    } catch {
    }
  }
  const r = B4(t, qr.JSON);
  return { data: e, pointers: r };
}
var zfe = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, jfe = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, qfe = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, ck = {
  Space_Separator: zfe,
  ID_Start: jfe,
  ID_Continue: qfe
}, hn = {
  isSpaceSeparator(t) {
    return typeof t == "string" && ck.Space_Separator.test(t);
  },
  isIdStartChar(t) {
    return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t === "$" || t === "_" || ck.ID_Start.test(t));
  },
  isIdContinueChar(t) {
    return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t >= "0" && t <= "9" || t === "$" || t === "_" || t === "â€Œ" || t === "â€" || ck.ID_Continue.test(t));
  },
  isDigit(t) {
    return typeof t == "string" && /[0-9]/.test(t);
  },
  isHexDigit(t) {
    return typeof t == "string" && /[0-9A-Fa-f]/.test(t);
  }
};
let LC, Mi, Il, Q1, uc, Ws, Rn, uS, Pm;
var Ufe = function(t, e) {
  LC = String(t), Mi = "start", Il = [], Q1 = 0, uc = 1, Ws = 0, Rn = void 0, uS = void 0, Pm = void 0;
  do
    Rn = Hfe(), Gfe[Mi]();
  while (Rn.type !== "eof");
  return typeof e == "function" ? zC({ "": Pm }, "", e) : Pm;
};
function zC(t, e, r) {
  const n = t[e];
  if (n != null && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0; i < n.length; i++) {
        const o = String(i), s = zC(n, o, r);
        s === void 0 ? delete n[o] : Object.defineProperty(n, o, {
          value: s,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const i in n) {
        const o = zC(n, i, r);
        o === void 0 ? delete n[i] : Object.defineProperty(n, i, {
          value: o,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return r.call(t, e, n);
}
let Ft, xt, vm, Al, Lt;
function Hfe() {
  for (Ft = "default", xt = "", vm = !1, Al = 1; ; ) {
    Lt = Vl();
    const t = L$[Ft]();
    if (t)
      return t;
  }
}
function Vl() {
  if (LC[Q1])
    return String.fromCodePoint(LC.codePointAt(Q1));
}
function ye() {
  const t = Vl();
  return t === `
` ? (uc++, Ws = 0) : t ? Ws += t.length : Ws++, t && (Q1 += t.length), t;
}
const L$ = {
  default() {
    switch (Lt) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "Â ":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        ye();
        return;
      case "/":
        ye(), Ft = "comment";
        return;
      case void 0:
        return ye(), Nr("eof");
    }
    if (hn.isSpaceSeparator(Lt)) {
      ye();
      return;
    }
    return L$[Mi]();
  },
  comment() {
    switch (Lt) {
      case "*":
        ye(), Ft = "multiLineComment";
        return;
      case "/":
        ye(), Ft = "singleLineComment";
        return;
    }
    throw zr(ye());
  },
  multiLineComment() {
    switch (Lt) {
      case "*":
        ye(), Ft = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw zr(ye());
    }
    ye();
  },
  multiLineCommentAsterisk() {
    switch (Lt) {
      case "*":
        ye();
        return;
      case "/":
        ye(), Ft = "default";
        return;
      case void 0:
        throw zr(ye());
    }
    ye(), Ft = "multiLineComment";
  },
  singleLineComment() {
    switch (Lt) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        ye(), Ft = "default";
        return;
      case void 0:
        return ye(), Nr("eof");
    }
    ye();
  },
  value() {
    switch (Lt) {
      case "{":
      case "[":
        return Nr("punctuator", ye());
      case "n":
        return ye(), Mc("ull"), Nr("null", null);
      case "t":
        return ye(), Mc("rue"), Nr("boolean", !0);
      case "f":
        return ye(), Mc("alse"), Nr("boolean", !1);
      case "-":
      case "+":
        ye() === "-" && (Al = -1), Ft = "sign";
        return;
      case ".":
        xt = ye(), Ft = "decimalPointLeading";
        return;
      case "0":
        xt = ye(), Ft = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        xt = ye(), Ft = "decimalInteger";
        return;
      case "I":
        return ye(), Mc("nfinity"), Nr("numeric", 1 / 0);
      case "N":
        return ye(), Mc("aN"), Nr("numeric", NaN);
      case '"':
      case "'":
        vm = ye() === '"', xt = "", Ft = "string";
        return;
    }
    throw zr(ye());
  },
  identifierNameStartEscape() {
    if (Lt !== "u")
      throw zr(ye());
    ye();
    const t = jC();
    switch (t) {
      case "$":
      case "_":
        break;
      default:
        if (!hn.isIdStartChar(t))
          throw J7();
        break;
    }
    xt += t, Ft = "identifierName";
  },
  identifierName() {
    switch (Lt) {
      case "$":
      case "_":
      case "â€Œ":
      case "â€":
        xt += ye();
        return;
      case "\\":
        ye(), Ft = "identifierNameEscape";
        return;
    }
    if (hn.isIdContinueChar(Lt)) {
      xt += ye();
      return;
    }
    return Nr("identifier", xt);
  },
  identifierNameEscape() {
    if (Lt !== "u")
      throw zr(ye());
    ye();
    const t = jC();
    switch (t) {
      case "$":
      case "_":
      case "â€Œ":
      case "â€":
        break;
      default:
        if (!hn.isIdContinueChar(t))
          throw J7();
        break;
    }
    xt += t, Ft = "identifierName";
  },
  sign() {
    switch (Lt) {
      case ".":
        xt = ye(), Ft = "decimalPointLeading";
        return;
      case "0":
        xt = ye(), Ft = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        xt = ye(), Ft = "decimalInteger";
        return;
      case "I":
        return ye(), Mc("nfinity"), Nr("numeric", Al * (1 / 0));
      case "N":
        return ye(), Mc("aN"), Nr("numeric", NaN);
    }
    throw zr(ye());
  },
  zero() {
    switch (Lt) {
      case ".":
        xt += ye(), Ft = "decimalPoint";
        return;
      case "e":
      case "E":
        xt += ye(), Ft = "decimalExponent";
        return;
      case "x":
      case "X":
        xt += ye(), Ft = "hexadecimal";
        return;
    }
    return Nr("numeric", Al * 0);
  },
  decimalInteger() {
    switch (Lt) {
      case ".":
        xt += ye(), Ft = "decimalPoint";
        return;
      case "e":
      case "E":
        xt += ye(), Ft = "decimalExponent";
        return;
    }
    if (hn.isDigit(Lt)) {
      xt += ye();
      return;
    }
    return Nr("numeric", Al * Number(xt));
  },
  decimalPointLeading() {
    if (hn.isDigit(Lt)) {
      xt += ye(), Ft = "decimalFraction";
      return;
    }
    throw zr(ye());
  },
  decimalPoint() {
    switch (Lt) {
      case "e":
      case "E":
        xt += ye(), Ft = "decimalExponent";
        return;
    }
    if (hn.isDigit(Lt)) {
      xt += ye(), Ft = "decimalFraction";
      return;
    }
    return Nr("numeric", Al * Number(xt));
  },
  decimalFraction() {
    switch (Lt) {
      case "e":
      case "E":
        xt += ye(), Ft = "decimalExponent";
        return;
    }
    if (hn.isDigit(Lt)) {
      xt += ye();
      return;
    }
    return Nr("numeric", Al * Number(xt));
  },
  decimalExponent() {
    switch (Lt) {
      case "+":
      case "-":
        xt += ye(), Ft = "decimalExponentSign";
        return;
    }
    if (hn.isDigit(Lt)) {
      xt += ye(), Ft = "decimalExponentInteger";
      return;
    }
    throw zr(ye());
  },
  decimalExponentSign() {
    if (hn.isDigit(Lt)) {
      xt += ye(), Ft = "decimalExponentInteger";
      return;
    }
    throw zr(ye());
  },
  decimalExponentInteger() {
    if (hn.isDigit(Lt)) {
      xt += ye();
      return;
    }
    return Nr("numeric", Al * Number(xt));
  },
  hexadecimal() {
    if (hn.isHexDigit(Lt)) {
      xt += ye(), Ft = "hexadecimalInteger";
      return;
    }
    throw zr(ye());
  },
  hexadecimalInteger() {
    if (hn.isHexDigit(Lt)) {
      xt += ye();
      return;
    }
    return Nr("numeric", Al * Number(xt));
  },
  string() {
    switch (Lt) {
      case "\\":
        ye(), xt += Vfe();
        return;
      case '"':
        if (vm)
          return ye(), Nr("string", xt);
        xt += ye();
        return;
      case "'":
        if (!vm)
          return ye(), Nr("string", xt);
        xt += ye();
        return;
      case `
`:
      case "\r":
        throw zr(ye());
      case "\u2028":
      case "\u2029":
        Kfe(Lt);
        break;
      case void 0:
        throw zr(ye());
    }
    xt += ye();
  },
  start() {
    switch (Lt) {
      case "{":
      case "[":
        return Nr("punctuator", ye());
    }
    Ft = "value";
  },
  beforePropertyName() {
    switch (Lt) {
      case "$":
      case "_":
        xt = ye(), Ft = "identifierName";
        return;
      case "\\":
        ye(), Ft = "identifierNameStartEscape";
        return;
      case "}":
        return Nr("punctuator", ye());
      case '"':
      case "'":
        vm = ye() === '"', Ft = "string";
        return;
    }
    if (hn.isIdStartChar(Lt)) {
      xt += ye(), Ft = "identifierName";
      return;
    }
    throw zr(ye());
  },
  afterPropertyName() {
    if (Lt === ":")
      return Nr("punctuator", ye());
    throw zr(ye());
  },
  beforePropertyValue() {
    Ft = "value";
  },
  afterPropertyValue() {
    switch (Lt) {
      case ",":
      case "}":
        return Nr("punctuator", ye());
    }
    throw zr(ye());
  },
  beforeArrayValue() {
    if (Lt === "]")
      return Nr("punctuator", ye());
    Ft = "value";
  },
  afterArrayValue() {
    switch (Lt) {
      case ",":
      case "]":
        return Nr("punctuator", ye());
    }
    throw zr(ye());
  },
  end() {
    throw zr(ye());
  }
};
function Nr(t, e) {
  return {
    type: t,
    value: e,
    line: uc,
    column: Ws
  };
}
function Mc(t) {
  for (const e of t) {
    if (Vl() !== e)
      throw zr(ye());
    ye();
  }
}
function Vfe() {
  switch (Vl()) {
    case "b":
      return ye(), "\b";
    case "f":
      return ye(), "\f";
    case "n":
      return ye(), `
`;
    case "r":
      return ye(), "\r";
    case "t":
      return ye(), "	";
    case "v":
      return ye(), "\v";
    case "0":
      if (ye(), hn.isDigit(Vl()))
        throw zr(ye());
      return "\0";
    case "x":
      return ye(), Wfe();
    case "u":
      return ye(), jC();
    case `
`:
    case "\u2028":
    case "\u2029":
      return ye(), "";
    case "\r":
      return ye(), Vl() === `
` && ye(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw zr(ye());
    case void 0:
      throw zr(ye());
  }
  return ye();
}
function Wfe() {
  let t = "", e = Vl();
  if (!hn.isHexDigit(e) || (t += ye(), e = Vl(), !hn.isHexDigit(e)))
    throw zr(ye());
  return t += ye(), String.fromCodePoint(parseInt(t, 16));
}
function jC() {
  let t = "", e = 4;
  for (; e-- > 0; ) {
    const r = Vl();
    if (!hn.isHexDigit(r))
      throw zr(ye());
    t += ye();
  }
  return String.fromCodePoint(parseInt(t, 16));
}
const Gfe = {
  start() {
    if (Rn.type === "eof")
      throw Pc();
    hk();
  },
  beforePropertyName() {
    switch (Rn.type) {
      case "identifier":
      case "string":
        uS = Rn.value, Mi = "afterPropertyName";
        return;
      case "punctuator":
        ny();
        return;
      case "eof":
        throw Pc();
    }
  },
  afterPropertyName() {
    if (Rn.type === "eof")
      throw Pc();
    Mi = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (Rn.type === "eof")
      throw Pc();
    hk();
  },
  beforeArrayValue() {
    if (Rn.type === "eof")
      throw Pc();
    if (Rn.type === "punctuator" && Rn.value === "]") {
      ny();
      return;
    }
    hk();
  },
  afterPropertyValue() {
    if (Rn.type === "eof")
      throw Pc();
    switch (Rn.value) {
      case ",":
        Mi = "beforePropertyName";
        return;
      case "}":
        ny();
    }
  },
  afterArrayValue() {
    if (Rn.type === "eof")
      throw Pc();
    switch (Rn.value) {
      case ",":
        Mi = "beforeArrayValue";
        return;
      case "]":
        ny();
    }
  },
  end() {
  }
};
function hk() {
  let t;
  switch (Rn.type) {
    case "punctuator":
      switch (Rn.value) {
        case "{":
          t = {};
          break;
        case "[":
          t = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      t = Rn.value;
      break;
  }
  if (Pm === void 0)
    Pm = t;
  else {
    const e = Il[Il.length - 1];
    Array.isArray(e) ? e.push(t) : Object.defineProperty(e, uS, {
      value: t,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (t !== null && typeof t == "object")
    Il.push(t), Array.isArray(t) ? Mi = "beforeArrayValue" : Mi = "beforePropertyName";
  else {
    const e = Il[Il.length - 1];
    e == null ? Mi = "end" : Array.isArray(e) ? Mi = "afterArrayValue" : Mi = "afterPropertyValue";
  }
}
function ny() {
  Il.pop();
  const t = Il[Il.length - 1];
  t == null ? Mi = "end" : Array.isArray(t) ? Mi = "afterArrayValue" : Mi = "afterPropertyValue";
}
function zr(t) {
  return cS(t === void 0 ? `JSON5: invalid end of input at ${uc}:${Ws}` : `JSON5: invalid character '${z$(t)}' at ${uc}:${Ws}`);
}
function Pc() {
  return cS(`JSON5: invalid end of input at ${uc}:${Ws}`);
}
function J7() {
  return Ws -= 5, cS(`JSON5: invalid identifier character at ${uc}:${Ws}`);
}
function Kfe(t) {
  console.warn(`JSON5: '${z$(t)}' in strings is not valid ECMAScript; consider escaping`);
}
function z$(t) {
  const e = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (e[t])
    return e[t];
  if (t < " ") {
    const r = t.charCodeAt(0).toString(16);
    return "\\x" + ("00" + r).substring(r.length);
  }
  return t;
}
function cS(t) {
  const e = new SyntaxError(t);
  return e.lineNumber = uc, e.columnNumber = Ws, e;
}
var Qfe = function(t, e, r) {
  const n = [];
  let i = "", o, s, a = "", l;
  if (e != null && typeof e == "object" && !Array.isArray(e) && (r = e.space, l = e.quote, e = e.replacer), typeof e == "function")
    s = e;
  else if (Array.isArray(e)) {
    o = [];
    for (const g of e) {
      let v;
      typeof g == "string" ? v = g : (typeof g == "number" || g instanceof String || g instanceof Number) && (v = String(g)), v !== void 0 && o.indexOf(v) < 0 && o.push(v);
    }
  }
  return r instanceof Number ? r = Number(r) : r instanceof String && (r = String(r)), typeof r == "number" ? r > 0 && (r = Math.min(10, Math.floor(r)), a = "          ".substr(0, r)) : typeof r == "string" && (a = r.substr(0, 10)), u("", { "": t });
  function u(g, v) {
    let y = v[g];
    switch (y != null && (typeof y.toJSON5 == "function" ? y = y.toJSON5(g) : typeof y.toJSON == "function" && (y = y.toJSON(g))), s && (y = s.call(v, g, y)), y instanceof Number ? y = Number(y) : y instanceof String ? y = String(y) : y instanceof Boolean && (y = y.valueOf()), y) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof y == "string")
      return c(y);
    if (typeof y == "number")
      return String(y);
    if (typeof y == "object")
      return Array.isArray(y) ? p(y) : h(y);
  }
  function c(g) {
    const v = {
      "'": 0.1,
      '"': 0.2
    }, y = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let b = "";
    for (let C = 0; C < g.length; C++) {
      const S = g[C];
      switch (S) {
        case "'":
        case '"':
          v[S]++, b += S;
          continue;
        case "\0":
          if (hn.isDigit(g[C + 1])) {
            b += "\\x00";
            continue;
          }
      }
      if (y[S]) {
        b += y[S];
        continue;
      }
      if (S < " ") {
        let _ = S.charCodeAt(0).toString(16);
        b += "\\x" + ("00" + _).substring(_.length);
        continue;
      }
      b += S;
    }
    const k = l || Object.keys(v).reduce((C, S) => v[C] < v[S] ? C : S);
    return b = b.replace(new RegExp(k, "g"), y[k]), k + b + k;
  }
  function h(g) {
    if (n.indexOf(g) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    n.push(g);
    let v = i;
    i = i + a;
    let y = o || Object.keys(g), b = [];
    for (const C of y) {
      const S = u(C, g);
      if (S !== void 0) {
        let _ = d(C) + ":";
        a !== "" && (_ += " "), _ += S, b.push(_);
      }
    }
    let k;
    if (b.length === 0)
      k = "{}";
    else {
      let C;
      if (a === "")
        C = b.join(","), k = "{" + C + "}";
      else {
        let S = `,
` + i;
        C = b.join(S), k = `{
` + i + C + `,
` + v + "}";
      }
    }
    return n.pop(), i = v, k;
  }
  function d(g) {
    if (g.length === 0)
      return c(g);
    const v = String.fromCodePoint(g.codePointAt(0));
    if (!hn.isIdStartChar(v))
      return c(g);
    for (let y = v.length; y < g.length; y++)
      if (!hn.isIdContinueChar(String.fromCodePoint(g.codePointAt(y))))
        return c(g);
    return g;
  }
  function p(g) {
    if (n.indexOf(g) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    n.push(g);
    let v = i;
    i = i + a;
    let y = [];
    for (let k = 0; k < g.length; k++) {
      const C = u(String(k), g);
      y.push(C !== void 0 ? C : "null");
    }
    let b;
    if (y.length === 0)
      b = "[]";
    else if (a === "")
      b = "[" + y.join(",") + "]";
    else {
      let k = `,
` + i, C = y.join(k);
      b = `[
` + i + C + `,
` + v + "]";
    }
    return n.pop(), i = v, b;
  }
};
const Xfe = {
  parse: Ufe,
  stringify: Qfe
};
var Jfe = Xfe;
function Yfe(t) {
  const e = t.doc.toString();
  let r = null;
  try {
    r = Jfe.parse(e);
  } catch {
    try {
      r = B$.parse(e);
    } catch {
    }
  }
  const n = B4(t, qr.JSON5);
  return { data: r, pointers: n };
}
const hS = Symbol.for("yaml.alias"), qC = Symbol.for("yaml.document"), Gu = Symbol.for("yaml.map"), j$ = Symbol.for("yaml.pair"), Ja = Symbol.for("yaml.scalar"), ip = Symbol.for("yaml.seq"), ks = Symbol.for("yaml.node.type"), gc = (t) => !!t && typeof t == "object" && t[ks] === hS, jh = (t) => !!t && typeof t == "object" && t[ks] === qC, op = (t) => !!t && typeof t == "object" && t[ks] === Gu, Vr = (t) => !!t && typeof t == "object" && t[ks] === j$, Or = (t) => !!t && typeof t == "object" && t[ks] === Ja, sp = (t) => !!t && typeof t == "object" && t[ks] === ip;
function Qr(t) {
  if (t && typeof t == "object")
    switch (t[ks]) {
      case Gu:
      case ip:
        return !0;
    }
  return !1;
}
function Xr(t) {
  if (t && typeof t == "object")
    switch (t[ks]) {
      case hS:
      case Gu:
      case Ja:
      case ip:
        return !0;
    }
  return !1;
}
const q$ = (t) => (Or(t) || Qr(t)) && !!t.anchor, Zi = Symbol("break visit"), U$ = Symbol("skip children"), Ua = Symbol("remove node");
function qh(t, e) {
  const r = H$(e);
  jh(t) ? Rf(null, t.contents, r, Object.freeze([t])) === Ua && (t.contents = null) : Rf(null, t, r, Object.freeze([]));
}
qh.BREAK = Zi;
qh.SKIP = U$;
qh.REMOVE = Ua;
function Rf(t, e, r, n) {
  const i = V$(t, e, r, n);
  if (Xr(i) || Vr(i))
    return W$(t, n, i), Rf(t, i, r, n);
  if (typeof i != "symbol") {
    if (Qr(e)) {
      n = Object.freeze(n.concat(e));
      for (let o = 0; o < e.items.length; ++o) {
        const s = Rf(o, e.items[o], r, n);
        if (typeof s == "number")
          o = s - 1;
        else {
          if (s === Zi)
            return Zi;
          s === Ua && (e.items.splice(o, 1), o -= 1);
        }
      }
    } else if (Vr(e)) {
      n = Object.freeze(n.concat(e));
      const o = Rf("key", e.key, r, n);
      if (o === Zi)
        return Zi;
      o === Ua && (e.key = null);
      const s = Rf("value", e.value, r, n);
      if (s === Zi)
        return Zi;
      s === Ua && (e.value = null);
    }
  }
  return i;
}
async function tx(t, e) {
  const r = H$(e);
  jh(t) ? await Nf(null, t.contents, r, Object.freeze([t])) === Ua && (t.contents = null) : await Nf(null, t, r, Object.freeze([]));
}
tx.BREAK = Zi;
tx.SKIP = U$;
tx.REMOVE = Ua;
async function Nf(t, e, r, n) {
  const i = await V$(t, e, r, n);
  if (Xr(i) || Vr(i))
    return W$(t, n, i), Nf(t, i, r, n);
  if (typeof i != "symbol") {
    if (Qr(e)) {
      n = Object.freeze(n.concat(e));
      for (let o = 0; o < e.items.length; ++o) {
        const s = await Nf(o, e.items[o], r, n);
        if (typeof s == "number")
          o = s - 1;
        else {
          if (s === Zi)
            return Zi;
          s === Ua && (e.items.splice(o, 1), o -= 1);
        }
      }
    } else if (Vr(e)) {
      n = Object.freeze(n.concat(e));
      const o = await Nf("key", e.key, r, n);
      if (o === Zi)
        return Zi;
      o === Ua && (e.key = null);
      const s = await Nf("value", e.value, r, n);
      if (s === Zi)
        return Zi;
      s === Ua && (e.value = null);
    }
  }
  return i;
}
function H$(t) {
  return typeof t == "object" && (t.Collection || t.Node || t.Value) ? Object.assign({
    Alias: t.Node,
    Map: t.Node,
    Scalar: t.Node,
    Seq: t.Node
  }, t.Value && {
    Map: t.Value,
    Scalar: t.Value,
    Seq: t.Value
  }, t.Collection && {
    Map: t.Collection,
    Seq: t.Collection
  }, t) : t;
}
function V$(t, e, r, n) {
  if (typeof r == "function")
    return r(t, e, n);
  if (op(e))
    return r.Map?.(t, e, n);
  if (sp(e))
    return r.Seq?.(t, e, n);
  if (Vr(e))
    return r.Pair?.(t, e, n);
  if (Or(e))
    return r.Scalar?.(t, e, n);
  if (gc(e))
    return r.Alias?.(t, e, n);
}
function W$(t, e, r) {
  const n = e[e.length - 1];
  if (Qr(n))
    n.items[t] = r;
  else if (Vr(n))
    t === "key" ? n.key = r : n.value = r;
  else if (jh(n))
    n.contents = r;
  else {
    const i = gc(n) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
const Zfe = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, ede = (t) => t.replace(/[!,[\]{}]/g, (e) => Zfe[e]);
class Ai {
  constructor(e, r) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Ai.defaultYaml, e), this.tags = Object.assign({}, Ai.defaultTags, r);
  }
  clone() {
    const e = new Ai(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new Ai(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Ai.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Ai.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, r) {
    this.atNextDocument && (this.yaml = { explicit: Ai.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Ai.defaultTags), this.atNextDocument = !1);
    const n = e.trim().split(/[ \t]+/), i = n.shift();
    switch (i) {
      case "%TAG": {
        if (n.length !== 2 && (r(0, "%TAG directive should contain exactly two parts"), n.length < 2))
          return !1;
        const [o, s] = n;
        return this.tags[o] = s, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, n.length !== 1)
          return r(0, "%YAML directive should contain exactly one part"), !1;
        const [o] = n;
        if (o === "1.1" || o === "1.2")
          return this.yaml.version = o, !0;
        {
          const s = /^\d+\.\d+$/.test(o);
          return r(6, `Unsupported YAML version ${o}`, s), !1;
        }
      }
      default:
        return r(0, `Unknown directive ${i}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, r) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return r(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const s = e.slice(2, -1);
      return s === "!" || s === "!!" ? (r(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && r("Verbatim tags must end with a >"), s);
    }
    const [, n, i] = e.match(/^(.*!)([^!]*)$/s);
    i || r(`The ${e} tag has no suffix`);
    const o = this.tags[n];
    if (o)
      try {
        return o + decodeURIComponent(i);
      } catch (s) {
        return r(String(s)), null;
      }
    return n === "!" ? e : (r(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [r, n] of Object.entries(this.tags))
      if (e.startsWith(n))
        return r + ede(e.substring(n.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const r = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags);
    let i;
    if (e && n.length > 0 && Xr(e.contents)) {
      const o = {};
      qh(e.contents, (s, a) => {
        Xr(a) && a.tag && (o[a.tag] = !0);
      }), i = Object.keys(o);
    } else
      i = [];
    for (const [o, s] of n)
      o === "!!" && s === "tag:yaml.org,2002:" || (!e || i.some((a) => a.startsWith(s))) && r.push(`%TAG ${o} ${s}`);
    return r.join(`
`);
  }
}
Ai.defaultYaml = { explicit: !1, version: "1.2" };
Ai.defaultTags = { "!!": "tag:yaml.org,2002:" };
function G$(t) {
  if (/[\x00-\x19\s,[\]{}]/.test(t)) {
    const e = `Anchor must not contain whitespace or control characters: ${JSON.stringify(t)}`;
    throw new Error(e);
  }
  return !0;
}
function K$(t) {
  const e = /* @__PURE__ */ new Set();
  return qh(t, {
    Value(r, n) {
      n.anchor && e.add(n.anchor);
    }
  }), e;
}
function Q$(t, e) {
  for (let r = 1; ; ++r) {
    const n = `${t}${r}`;
    if (!e.has(n))
      return n;
  }
}
function tde(t, e) {
  const r = [], n = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (o) => {
      r.push(o), i ?? (i = K$(t));
      const s = Q$(e, i);
      return i.add(s), s;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const o of r) {
        const s = n.get(o);
        if (typeof s == "object" && s.anchor && (Or(s.node) || Qr(s.node)))
          s.node.anchor = s.anchor;
        else {
          const a = new Error("Failed to resolve repeated object (this should not happen)");
          throw a.source = o, a;
        }
      }
    },
    sourceObjects: n
  };
}
function $f(t, e, r, n) {
  if (n && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0, o = n.length; i < o; ++i) {
        const s = n[i], a = $f(t, n, String(i), s);
        a === void 0 ? delete n[i] : a !== s && (n[i] = a);
      }
    else if (n instanceof Map)
      for (const i of Array.from(n.keys())) {
        const o = n.get(i), s = $f(t, n, i, o);
        s === void 0 ? n.delete(i) : s !== o && n.set(i, s);
      }
    else if (n instanceof Set)
      for (const i of Array.from(n)) {
        const o = $f(t, n, i, i);
        o === void 0 ? n.delete(i) : o !== i && (n.delete(i), n.add(o));
      }
    else
      for (const [i, o] of Object.entries(n)) {
        const s = $f(t, n, i, o);
        s === void 0 ? delete n[i] : s !== o && (n[i] = s);
      }
  return t.call(e, r, n);
}
function ys(t, e, r) {
  if (Array.isArray(t))
    return t.map((n, i) => ys(n, String(i), r));
  if (t && typeof t.toJSON == "function") {
    if (!r || !q$(t))
      return t.toJSON(e, r);
    const n = { aliasCount: 0, count: 1, res: void 0 };
    r.anchors.set(t, n), r.onCreate = (o) => {
      n.res = o, delete r.onCreate;
    };
    const i = t.toJSON(e, r);
    return r.onCreate && r.onCreate(i), i;
  }
  return typeof t == "bigint" && !r?.keep ? Number(t) : t;
}
class fS {
  constructor(e) {
    Object.defineProperty(this, ks, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: r, maxAliasCount: n, onAnchor: i, reviver: o } = {}) {
    if (!jh(e))
      throw new TypeError("A document argument is required");
    const s = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: r === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof n == "number" ? n : 100
    }, a = ys(this, "", s);
    if (typeof i == "function")
      for (const { count: l, res: u } of s.anchors.values())
        i(u, l);
    return typeof o == "function" ? $f(o, { "": a }, "", a) : a;
  }
}
class rx extends fS {
  constructor(e) {
    super(hS), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e, r) {
    let n;
    r?.aliasResolveCache ? n = r.aliasResolveCache : (n = [], qh(e, {
      Node: (o, s) => {
        (gc(s) || q$(s)) && n.push(s);
      }
    }), r && (r.aliasResolveCache = n));
    let i;
    for (const o of n) {
      if (o === this)
        break;
      o.anchor === this.source && (i = o);
    }
    return i;
  }
  toJSON(e, r) {
    if (!r)
      return { source: this.source };
    const { anchors: n, doc: i, maxAliasCount: o } = r, s = this.resolve(i, r);
    if (!s) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let a = n.get(s);
    if (a || (ys(s, null, r), a = n.get(s)), !a || a.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (o >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = Vy(i, s, n)), a.count * a.aliasCount > o)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return a.res;
  }
  toString(e, r, n) {
    const i = `*${this.source}`;
    if (e) {
      if (G$(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const o = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(o);
      }
      if (e.implicitKey)
        return `${i} `;
    }
    return i;
  }
}
function Vy(t, e, r) {
  if (gc(e)) {
    const n = e.resolve(t), i = r && n && r.get(n);
    return i ? i.count * i.aliasCount : 0;
  } else if (Qr(e)) {
    let n = 0;
    for (const i of e.items) {
      const o = Vy(t, i, r);
      o > n && (n = o);
    }
    return n;
  } else if (Vr(e)) {
    const n = Vy(t, e.key, r), i = Vy(t, e.value, r);
    return Math.max(n, i);
  }
  return 1;
}
const X$ = (t) => !t || typeof t != "function" && typeof t != "object";
class yt extends fS {
  constructor(e) {
    super(Ja), this.value = e;
  }
  toJSON(e, r) {
    return r?.keep ? this.value : ys(this.value, e, r);
  }
  toString() {
    return String(this.value);
  }
}
yt.BLOCK_FOLDED = "BLOCK_FOLDED";
yt.BLOCK_LITERAL = "BLOCK_LITERAL";
yt.PLAIN = "PLAIN";
yt.QUOTE_DOUBLE = "QUOTE_DOUBLE";
yt.QUOTE_SINGLE = "QUOTE_SINGLE";
const rde = "tag:yaml.org,2002:";
function nde(t, e, r) {
  if (e) {
    const n = r.filter((o) => o.tag === e), i = n.find((o) => !o.format) ?? n[0];
    if (!i)
      throw new Error(`Tag ${e} not found`);
    return i;
  }
  return r.find((n) => n.identify?.(t) && !n.format);
}
function Sg(t, e, r) {
  if (jh(t) && (t = t.contents), Xr(t))
    return t;
  if (Vr(t)) {
    const h = r.schema[Gu].createNode?.(r.schema, null, r);
    return h.items.push(t), h;
  }
  (t instanceof String || t instanceof Number || t instanceof Boolean || typeof BigInt < "u" && t instanceof BigInt) && (t = t.valueOf());
  const { aliasDuplicateObjects: n, onAnchor: i, onTagObj: o, schema: s, sourceObjects: a } = r;
  let l;
  if (n && t && typeof t == "object") {
    if (l = a.get(t), l)
      return l.anchor ?? (l.anchor = i(t)), new rx(l.anchor);
    l = { anchor: null, node: null }, a.set(t, l);
  }
  e?.startsWith("!!") && (e = rde + e.slice(2));
  let u = nde(t, e, s.tags);
  if (!u) {
    if (t && typeof t.toJSON == "function" && (t = t.toJSON()), !t || typeof t != "object") {
      const h = new yt(t);
      return l && (l.node = h), h;
    }
    u = t instanceof Map ? s[Gu] : Symbol.iterator in Object(t) ? s[ip] : s[Gu];
  }
  o && (o(u), delete r.onTagObj);
  const c = u?.createNode ? u.createNode(r.schema, t, r) : typeof u?.nodeClass?.from == "function" ? u.nodeClass.from(r.schema, t, r) : new yt(t);
  return e ? c.tag = e : u.default || (c.tag = u.tag), l && (l.node = c), c;
}
function X1(t, e, r) {
  let n = r;
  for (let i = e.length - 1; i >= 0; --i) {
    const o = e[i];
    if (typeof o == "number" && Number.isInteger(o) && o >= 0) {
      const s = [];
      s[o] = n, n = s;
    } else
      n = /* @__PURE__ */ new Map([[o, n]]);
  }
  return Sg(n, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: t,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const ym = (t) => t == null || typeof t == "object" && !!t[Symbol.iterator]().next().done;
class J$ extends fS {
  constructor(e, r) {
    super(e), Object.defineProperty(this, "schema", {
      value: r,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const r = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (r.schema = e), r.items = r.items.map((n) => Xr(n) || Vr(n) ? n.clone(e) : n), this.range && (r.range = this.range.slice()), r;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, r) {
    if (ym(e))
      this.add(r);
    else {
      const [n, ...i] = e, o = this.get(n, !0);
      if (Qr(o))
        o.addIn(i, r);
      else if (o === void 0 && this.schema)
        this.set(n, X1(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.delete(r);
    const i = this.get(r, !0);
    if (Qr(i))
      return i.deleteIn(n);
    throw new Error(`Expected YAML collection at ${r}. Remaining path: ${n}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    const [n, ...i] = e, o = this.get(n, !0);
    return i.length === 0 ? !r && Or(o) ? o.value : o : Qr(o) ? o.getIn(i, r) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((r) => {
      if (!Vr(r))
        return !1;
      const n = r.value;
      return n == null || e && Or(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.has(r);
    const i = this.get(r, !0);
    return Qr(i) ? i.hasIn(n) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    const [n, ...i] = e;
    if (i.length === 0)
      this.set(n, r);
    else {
      const o = this.get(n, !0);
      if (Qr(o))
        o.setIn(i, r);
      else if (o === void 0 && this.schema)
        this.set(n, X1(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
}
const ide = (t) => t.replace(/^(?!$)(?: $)?/gm, "#");
function Ll(t, e) {
  return /^\n+$/.test(t) ? t.substring(1) : e ? t.replace(/^(?! *$)/gm, e) : t;
}
const Gc = (t, e, r) => t.endsWith(`
`) ? Ll(r, e) : r.includes(`
`) ? `
` + Ll(r, e) : (t.endsWith(" ") ? "" : " ") + r, Y$ = "flow", UC = "block", Wy = "quoted";
function nx(t, e, r = "flow", { indentAtStart: n, lineWidth: i = 80, minContentWidth: o = 20, onFold: s, onOverflow: a } = {}) {
  if (!i || i < 0)
    return t;
  i < o && (o = 0);
  const l = Math.max(1 + o, 1 + i - e.length);
  if (t.length <= l)
    return t;
  const u = [], c = {};
  let h = i - e.length;
  typeof n == "number" && (n > i - Math.max(2, o) ? u.push(0) : h = i - n);
  let d, p, g = !1, v = -1, y = -1, b = -1;
  r === UC && (v = Y7(t, v, e.length), v !== -1 && (h = v + l));
  for (let C; C = t[v += 1]; ) {
    if (r === Wy && C === "\\") {
      switch (y = v, t[v + 1]) {
        case "x":
          v += 3;
          break;
        case "u":
          v += 5;
          break;
        case "U":
          v += 9;
          break;
        default:
          v += 1;
      }
      b = v;
    }
    if (C === `
`)
      r === UC && (v = Y7(t, v, e.length)), h = v + e.length + l, d = void 0;
    else {
      if (C === " " && p && p !== " " && p !== `
` && p !== "	") {
        const S = t[v + 1];
        S && S !== " " && S !== `
` && S !== "	" && (d = v);
      }
      if (v >= h)
        if (d)
          u.push(d), h = d + l, d = void 0;
        else if (r === Wy) {
          for (; p === " " || p === "	"; )
            p = C, C = t[v += 1], g = !0;
          const S = v > b + 1 ? v - 2 : y - 1;
          if (c[S])
            return t;
          u.push(S), c[S] = !0, h = S + l, d = void 0;
        } else
          g = !0;
    }
    p = C;
  }
  if (g && a && a(), u.length === 0)
    return t;
  s && s();
  let k = t.slice(0, u[0]);
  for (let C = 0; C < u.length; ++C) {
    const S = u[C], _ = u[C + 1] || t.length;
    S === 0 ? k = `
${e}${t.slice(0, _)}` : (r === Wy && c[S] && (k += `${t[S]}\\`), k += `
${e}${t.slice(S + 1, _)}`);
  }
  return k;
}
function Y7(t, e, r) {
  let n = e, i = e + 1, o = t[i];
  for (; o === " " || o === "	"; )
    if (e < i + r)
      o = t[++e];
    else {
      do
        o = t[++e];
      while (o && o !== `
`);
      n = e, i = e + 1, o = t[i];
    }
  return n;
}
const ix = (t, e) => ({
  indentAtStart: e ? t.indent.length : t.indentAtStart,
  lineWidth: t.options.lineWidth,
  minContentWidth: t.options.minContentWidth
}), ox = (t) => /^(%|---|\.\.\.)/m.test(t);
function ode(t, e, r) {
  if (!e || e < 0)
    return !1;
  const n = e - r, i = t.length;
  if (i <= n)
    return !1;
  for (let o = 0, s = 0; o < i; ++o)
    if (t[o] === `
`) {
      if (o - s > n)
        return !0;
      if (s = o + 1, i - s <= n)
        return !1;
    }
  return !0;
}
function Rm(t, e) {
  const r = JSON.stringify(t);
  if (e.options.doubleQuotedAsJSON)
    return r;
  const { implicitKey: n } = e, i = e.options.doubleQuotedMinMultiLineLength, o = e.indent || (ox(t) ? "  " : "");
  let s = "", a = 0;
  for (let l = 0, u = r[l]; u; u = r[++l])
    if (u === " " && r[l + 1] === "\\" && r[l + 2] === "n" && (s += r.slice(a, l) + "\\ ", l += 1, a = l, u = "\\"), u === "\\")
      switch (r[l + 1]) {
        case "u":
          {
            s += r.slice(a, l);
            const c = r.substr(l + 2, 4);
            switch (c) {
              case "0000":
                s += "\\0";
                break;
              case "0007":
                s += "\\a";
                break;
              case "000b":
                s += "\\v";
                break;
              case "001b":
                s += "\\e";
                break;
              case "0085":
                s += "\\N";
                break;
              case "00a0":
                s += "\\_";
                break;
              case "2028":
                s += "\\L";
                break;
              case "2029":
                s += "\\P";
                break;
              default:
                c.substr(0, 2) === "00" ? s += "\\x" + c.substr(2) : s += r.substr(l, 6);
            }
            l += 5, a = l + 1;
          }
          break;
        case "n":
          if (n || r[l + 2] === '"' || r.length < i)
            l += 1;
          else {
            for (s += r.slice(a, l) + `

`; r[l + 2] === "\\" && r[l + 3] === "n" && r[l + 4] !== '"'; )
              s += `
`, l += 2;
            s += o, r[l + 2] === " " && (s += "\\"), l += 1, a = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return s = a ? s + r.slice(a) : r, n ? s : nx(s, o, Wy, ix(e, !1));
}
function HC(t, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && t.includes(`
`) || /[ \t]\n|\n[ \t]/.test(t))
    return Rm(t, e);
  const r = e.indent || (ox(t) ? "  " : ""), n = "'" + t.replace(/'/g, "''").replace(/\n+/g, `$&
${r}`) + "'";
  return e.implicitKey ? n : nx(n, r, Y$, ix(e, !1));
}
function If(t, e) {
  const { singleQuote: r } = e.options;
  let n;
  if (r === !1)
    n = Rm;
  else {
    const i = t.includes('"'), o = t.includes("'");
    i && !o ? n = HC : o && !i ? n = Rm : n = r ? HC : Rm;
  }
  return n(t, e);
}
let VC;
try {
  VC = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  VC = /\n+(?!\n|$)/g;
}
function Gy({ comment: t, type: e, value: r }, n, i, o) {
  const { blockQuote: s, commentString: a, lineWidth: l } = n.options;
  if (!s || /\n[\t ]+$/.test(r))
    return If(r, n);
  const u = n.indent || (n.forceBlockIndent || ox(r) ? "  " : ""), c = s === "literal" ? !0 : s === "folded" || e === yt.BLOCK_FOLDED ? !1 : e === yt.BLOCK_LITERAL ? !0 : !ode(r, l, u.length);
  if (!r)
    return c ? `|
` : `>
`;
  let h, d;
  for (d = r.length; d > 0; --d) {
    const S = r[d - 1];
    if (S !== `
` && S !== "	" && S !== " ")
      break;
  }
  let p = r.substring(d);
  const g = p.indexOf(`
`);
  g === -1 ? h = "-" : r === p || g !== p.length - 1 ? (h = "+", o && o()) : h = "", p && (r = r.slice(0, -p.length), p[p.length - 1] === `
` && (p = p.slice(0, -1)), p = p.replace(VC, `$&${u}`));
  let v = !1, y, b = -1;
  for (y = 0; y < r.length; ++y) {
    const S = r[y];
    if (S === " ")
      v = !0;
    else if (S === `
`)
      b = y;
    else
      break;
  }
  let k = r.substring(0, b < y ? b + 1 : y);
  k && (r = r.substring(k.length), k = k.replace(/\n+/g, `$&${u}`));
  let C = (v ? u ? "2" : "1" : "") + h;
  if (t && (C += " " + a(t.replace(/ ?[\r\n]+/g, " ")), i && i()), !c) {
    const S = r.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${u}`);
    let _ = !1;
    const D = ix(n, !0);
    s !== "folded" && e !== yt.BLOCK_FOLDED && (D.onOverflow = () => {
      _ = !0;
    });
    const A = nx(`${k}${S}${p}`, u, UC, D);
    if (!_)
      return `>${C}
${u}${A}`;
  }
  return r = r.replace(/\n+/g, `$&${u}`), `|${C}
${u}${k}${r}${p}`;
}
function sde(t, e, r, n) {
  const { type: i, value: o } = t, { actualString: s, implicitKey: a, indent: l, indentStep: u, inFlow: c } = e;
  if (a && o.includes(`
`) || c && /[[\]{},]/.test(o))
    return If(o, e);
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
    return a || c || !o.includes(`
`) ? If(o, e) : Gy(t, e, r, n);
  if (!a && !c && i !== yt.PLAIN && o.includes(`
`))
    return Gy(t, e, r, n);
  if (ox(o)) {
    if (l === "")
      return e.forceBlockIndent = !0, Gy(t, e, r, n);
    if (a && l === u)
      return If(o, e);
  }
  const h = o.replace(/\n+/g, `$&
${l}`);
  if (s) {
    const d = (v) => v.default && v.tag !== "tag:yaml.org,2002:str" && v.test?.test(h), { compat: p, tags: g } = e.doc.schema;
    if (g.some(d) || p?.some(d))
      return If(o, e);
  }
  return a ? h : nx(h, l, Y$, ix(e, !1));
}
function h0(t, e, r, n) {
  const { implicitKey: i, inFlow: o } = e, s = typeof t.value == "string" ? t : Object.assign({}, t, { value: String(t.value) });
  let { type: a } = t;
  a !== yt.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(s.value) && (a = yt.QUOTE_DOUBLE);
  const l = (c) => {
    switch (c) {
      case yt.BLOCK_FOLDED:
      case yt.BLOCK_LITERAL:
        return i || o ? If(s.value, e) : Gy(s, e, r, n);
      case yt.QUOTE_DOUBLE:
        return Rm(s.value, e);
      case yt.QUOTE_SINGLE:
        return HC(s.value, e);
      case yt.PLAIN:
        return sde(s, e, r, n);
      default:
        return null;
    }
  };
  let u = l(a);
  if (u === null) {
    const { defaultKeyType: c, defaultStringType: h } = e.options, d = i && c || h;
    if (u = l(d), u === null)
      throw new Error(`Unsupported default string type ${d}`);
  }
  return u;
}
function Z$(t, e) {
  const r = Object.assign({
    blockQuote: !0,
    commentString: ide,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, t.schema.toStringOptions, e);
  let n;
  switch (r.collectionStyle) {
    case "block":
      n = !1;
      break;
    case "flow":
      n = !0;
      break;
    default:
      n = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: t,
    flowCollectionPadding: r.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof r.indent == "number" ? " ".repeat(r.indent) : "  ",
    inFlow: n,
    options: r
  };
}
function ade(t, e) {
  if (e.tag) {
    const i = t.filter((o) => o.tag === e.tag);
    if (i.length > 0)
      return i.find((o) => o.format === e.format) ?? i[0];
  }
  let r, n;
  if (Or(e)) {
    n = e.value;
    let i = t.filter((o) => o.identify?.(n));
    if (i.length > 1) {
      const o = i.filter((s) => s.test);
      o.length > 0 && (i = o);
    }
    r = i.find((o) => o.format === e.format) ?? i.find((o) => !o.format);
  } else
    n = e, r = t.find((i) => i.nodeClass && n instanceof i.nodeClass);
  if (!r) {
    const i = n?.constructor?.name ?? (n === null ? "null" : typeof n);
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return r;
}
function lde(t, e, { anchors: r, doc: n }) {
  if (!n.directives)
    return "";
  const i = [], o = (Or(t) || Qr(t)) && t.anchor;
  o && G$(o) && (r.add(o), i.push(`&${o}`));
  const s = t.tag ?? (e.default ? null : e.tag);
  return s && i.push(n.directives.tagString(s)), i.join(" ");
}
function Td(t, e, r, n) {
  if (Vr(t))
    return t.toString(e, r, n);
  if (gc(t)) {
    if (e.doc.directives)
      return t.toString(e);
    if (e.resolvedAliases?.has(t))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(t) : e.resolvedAliases = /* @__PURE__ */ new Set([t]), t = t.resolve(e.doc);
  }
  let i;
  const o = Xr(t) ? t : e.doc.createNode(t, { onTagObj: (l) => i = l });
  i ?? (i = ade(e.doc.schema.tags, o));
  const s = lde(o, i, e);
  s.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + s.length + 1);
  const a = typeof i.stringify == "function" ? i.stringify(o, e, r, n) : Or(o) ? h0(o, e, r, n) : o.toString(e, r, n);
  return s ? Or(o) || a[0] === "{" || a[0] === "[" ? `${s} ${a}` : `${s}
${e.indent}${a}` : a;
}
function ude({ key: t, value: e }, r, n, i) {
  const { allNullValues: o, doc: s, indent: a, indentStep: l, options: { commentString: u, indentSeq: c, simpleKeys: h } } = r;
  let d = Xr(t) && t.comment || null;
  if (h) {
    if (d)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (Qr(t) || !Xr(t) && typeof t == "object") {
      const A = "With simple keys, collection cannot be used as a key value";
      throw new Error(A);
    }
  }
  let p = !h && (!t || d && e == null && !r.inFlow || Qr(t) || (Or(t) ? t.type === yt.BLOCK_FOLDED || t.type === yt.BLOCK_LITERAL : typeof t == "object"));
  r = Object.assign({}, r, {
    allNullValues: !1,
    implicitKey: !p && (h || !o),
    indent: a + l
  });
  let g = !1, v = !1, y = Td(t, r, () => g = !0, () => v = !0);
  if (!p && !r.inFlow && y.length > 1024) {
    if (h)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    p = !0;
  }
  if (r.inFlow) {
    if (o || e == null)
      return g && n && n(), y === "" ? "?" : p ? `? ${y}` : y;
  } else if (o && !h || e == null && p)
    return y = `? ${y}`, d && !g ? y += Gc(y, r.indent, u(d)) : v && i && i(), y;
  g && (d = null), p ? (d && (y += Gc(y, r.indent, u(d))), y = `? ${y}
${a}:`) : (y = `${y}:`, d && (y += Gc(y, r.indent, u(d))));
  let b, k, C;
  Xr(e) ? (b = !!e.spaceBefore, k = e.commentBefore, C = e.comment) : (b = !1, k = null, C = null, e && typeof e == "object" && (e = s.createNode(e))), r.implicitKey = !1, !p && !d && Or(e) && (r.indentAtStart = y.length + 1), v = !1, !c && l.length >= 2 && !r.inFlow && !p && sp(e) && !e.flow && !e.tag && !e.anchor && (r.indent = r.indent.substring(2));
  let S = !1;
  const _ = Td(e, r, () => S = !0, () => v = !0);
  let D = " ";
  if (d || b || k) {
    if (D = b ? `
` : "", k) {
      const A = u(k);
      D += `
${Ll(A, r.indent)}`;
    }
    _ === "" && !r.inFlow ? D === `
` && (D = `

`) : D += `
${r.indent}`;
  } else if (!p && Qr(e)) {
    const A = _[0], O = _.indexOf(`
`), M = O !== -1, z = r.inFlow ?? e.flow ?? e.items.length === 0;
    if (M || !z) {
      let R = !1;
      if (M && (A === "&" || A === "!")) {
        let N = _.indexOf(" ");
        A === "&" && N !== -1 && N < O && _[N + 1] === "!" && (N = _.indexOf(" ", N + 1)), (N === -1 || O < N) && (R = !0);
      }
      R || (D = `
${r.indent}`);
    }
  } else (_ === "" || _[0] === `
`) && (D = "");
  return y += D + _, r.inFlow ? S && n && n() : C && !S ? y += Gc(y, r.indent, u(C)) : v && i && i(), y;
}
function eI(t, e) {
  (t === "debug" || t === "warn") && console.warn(e);
}
const iy = "<<", Wl = {
  identify: (t) => t === iy || typeof t == "symbol" && t.description === iy,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new yt(Symbol(iy)), {
    addToJSMap: tI
  }),
  stringify: () => iy
}, cde = (t, e) => (Wl.identify(e) || Or(e) && (!e.type || e.type === yt.PLAIN) && Wl.identify(e.value)) && t?.doc.schema.tags.some((r) => r.tag === Wl.tag && r.default);
function tI(t, e, r) {
  if (r = t && gc(r) ? r.resolve(t.doc) : r, sp(r))
    for (const n of r.items)
      fk(t, e, n);
  else if (Array.isArray(r))
    for (const n of r)
      fk(t, e, n);
  else
    fk(t, e, r);
}
function fk(t, e, r) {
  const n = t && gc(r) ? r.resolve(t.doc) : r;
  if (!op(n))
    throw new Error("Merge sources must be maps or map aliases");
  const i = n.toJSON(null, t, Map);
  for (const [o, s] of i)
    e instanceof Map ? e.has(o) || e.set(o, s) : e instanceof Set ? e.add(o) : Object.prototype.hasOwnProperty.call(e, o) || Object.defineProperty(e, o, {
      value: s,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function rI(t, e, { key: r, value: n }) {
  if (Xr(r) && r.addToJSMap)
    r.addToJSMap(t, e, n);
  else if (cde(t, r))
    tI(t, e, n);
  else {
    const i = ys(r, "", t);
    if (e instanceof Map)
      e.set(i, ys(n, i, t));
    else if (e instanceof Set)
      e.add(i);
    else {
      const o = hde(r, i, t), s = ys(n, o, t);
      o in e ? Object.defineProperty(e, o, {
        value: s,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[o] = s;
    }
  }
  return e;
}
function hde(t, e, r) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (Xr(t) && r?.doc) {
    const n = Z$(r.doc, {});
    n.anchors = /* @__PURE__ */ new Set();
    for (const o of r.anchors.keys())
      n.anchors.add(o.anchor);
    n.inFlow = !0, n.inStringifyKey = !0;
    const i = t.toString(n);
    if (!r.mapKeyWarned) {
      let o = JSON.stringify(i);
      o.length > 40 && (o = o.substring(0, 36) + '..."'), eI(r.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${o}. Set mapAsMap: true to use object keys.`), r.mapKeyWarned = !0;
    }
    return i;
  }
  return JSON.stringify(e);
}
function dS(t, e, r) {
  const n = Sg(t, void 0, r), i = Sg(e, void 0, r);
  return new hi(n, i);
}
class hi {
  constructor(e, r = null) {
    Object.defineProperty(this, ks, { value: j$ }), this.key = e, this.value = r;
  }
  clone(e) {
    let { key: r, value: n } = this;
    return Xr(r) && (r = r.clone(e)), Xr(n) && (n = n.clone(e)), new hi(r, n);
  }
  toJSON(e, r) {
    const n = r?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return rI(r, n, this);
  }
  toString(e, r, n) {
    return e?.doc ? ude(this, e, r, n) : JSON.stringify(this);
  }
}
function nI(t, e, r) {
  return (e.inFlow ?? t.flow ? dde : fde)(t, e, r);
}
function fde({ comment: t, items: e }, r, { blockItemPrefix: n, flowChars: i, itemIndent: o, onChompKeep: s, onComment: a }) {
  const { indent: l, options: { commentString: u } } = r, c = Object.assign({}, r, { indent: o, type: null });
  let h = !1;
  const d = [];
  for (let g = 0; g < e.length; ++g) {
    const v = e[g];
    let y = null;
    if (Xr(v))
      !h && v.spaceBefore && d.push(""), J1(r, d, v.commentBefore, h), v.comment && (y = v.comment);
    else if (Vr(v)) {
      const k = Xr(v.key) ? v.key : null;
      k && (!h && k.spaceBefore && d.push(""), J1(r, d, k.commentBefore, h));
    }
    h = !1;
    let b = Td(v, c, () => y = null, () => h = !0);
    y && (b += Gc(b, o, u(y))), h && y && (h = !1), d.push(n + b);
  }
  let p;
  if (d.length === 0)
    p = i.start + i.end;
  else {
    p = d[0];
    for (let g = 1; g < d.length; ++g) {
      const v = d[g];
      p += v ? `
${l}${v}` : `
`;
    }
  }
  return t ? (p += `
` + Ll(u(t), l), a && a()) : h && s && s(), p;
}
function dde({ items: t }, e, { flowChars: r, itemIndent: n }) {
  const { indent: i, indentStep: o, flowCollectionPadding: s, options: { commentString: a } } = e;
  n += o;
  const l = Object.assign({}, e, {
    indent: n,
    inFlow: !0,
    type: null
  });
  let u = !1, c = 0;
  const h = [];
  for (let g = 0; g < t.length; ++g) {
    const v = t[g];
    let y = null;
    if (Xr(v))
      v.spaceBefore && h.push(""), J1(e, h, v.commentBefore, !1), v.comment && (y = v.comment);
    else if (Vr(v)) {
      const k = Xr(v.key) ? v.key : null;
      k && (k.spaceBefore && h.push(""), J1(e, h, k.commentBefore, !1), k.comment && (u = !0));
      const C = Xr(v.value) ? v.value : null;
      C ? (C.comment && (y = C.comment), C.commentBefore && (u = !0)) : v.value == null && k?.comment && (y = k.comment);
    }
    y && (u = !0);
    let b = Td(v, l, () => y = null);
    g < t.length - 1 && (b += ","), y && (b += Gc(b, n, a(y))), !u && (h.length > c || b.includes(`
`)) && (u = !0), h.push(b), c = h.length;
  }
  const { start: d, end: p } = r;
  if (h.length === 0)
    return d + p;
  if (!u) {
    const g = h.reduce((v, y) => v + y.length + 2, 2);
    u = e.options.lineWidth > 0 && g > e.options.lineWidth;
  }
  if (u) {
    let g = d;
    for (const v of h)
      g += v ? `
${o}${i}${v}` : `
`;
    return `${g}
${i}${p}`;
  } else
    return `${d}${s}${h.join(" ")}${s}${p}`;
}
function J1({ indent: t, options: { commentString: e } }, r, n, i) {
  if (n && i && (n = n.replace(/^\n+/, "")), n) {
    const o = Ll(e(n), t);
    r.push(o.trimStart());
  }
}
function Kc(t, e) {
  const r = Or(e) ? e.value : e;
  for (const n of t)
    if (Vr(n) && (n.key === e || n.key === r || Or(n.key) && n.key.value === r))
      return n;
}
class $o extends J$ {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(Gu, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, r, n) {
    const { keepUndefined: i, replacer: o } = n, s = new this(e), a = (l, u) => {
      if (typeof o == "function")
        u = o.call(r, l, u);
      else if (Array.isArray(o) && !o.includes(l))
        return;
      (u !== void 0 || i) && s.items.push(dS(l, u, n));
    };
    if (r instanceof Map)
      for (const [l, u] of r)
        a(l, u);
    else if (r && typeof r == "object")
      for (const l of Object.keys(r))
        a(l, r[l]);
    return typeof e.sortMapEntries == "function" && s.items.sort(e.sortMapEntries), s;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, r) {
    let n;
    Vr(e) ? n = e : !e || typeof e != "object" || !("key" in e) ? n = new hi(e, e?.value) : n = new hi(e.key, e.value);
    const i = Kc(this.items, n.key), o = this.schema?.sortMapEntries;
    if (i) {
      if (!r)
        throw new Error(`Key ${n.key} already set`);
      Or(i.value) && X$(n.value) ? i.value.value = n.value : i.value = n.value;
    } else if (o) {
      const s = this.items.findIndex((a) => o(n, a) < 0);
      s === -1 ? this.items.push(n) : this.items.splice(s, 0, n);
    } else
      this.items.push(n);
  }
  delete(e) {
    const r = Kc(this.items, e);
    return r ? this.items.splice(this.items.indexOf(r), 1).length > 0 : !1;
  }
  get(e, r) {
    const n = Kc(this.items, e)?.value;
    return (!r && Or(n) ? n.value : n) ?? void 0;
  }
  has(e) {
    return !!Kc(this.items, e);
  }
  set(e, r) {
    this.add(new hi(e, r), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, r, n) {
    const i = n ? new n() : r?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    r?.onCreate && r.onCreate(i);
    for (const o of this.items)
      rI(r, i, o);
    return i;
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!Vr(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), nI(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: n,
      onComment: r
    });
  }
}
const ap = {
  collection: "map",
  default: !0,
  nodeClass: $o,
  tag: "tag:yaml.org,2002:map",
  resolve(t, e) {
    return op(t) || e("Expected a mapping for this tag"), t;
  },
  createNode: (t, e, r) => $o.from(t, e, r)
};
class cc extends J$ {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(ip, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const r = oy(e);
    return typeof r != "number" ? !1 : this.items.splice(r, 1).length > 0;
  }
  get(e, r) {
    const n = oy(e);
    if (typeof n != "number")
      return;
    const i = this.items[n];
    return !r && Or(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const r = oy(e);
    return typeof r == "number" && r < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, r) {
    const n = oy(e);
    if (typeof n != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const i = this.items[n];
    Or(i) && X$(r) ? i.value = r : this.items[n] = r;
  }
  toJSON(e, r) {
    const n = [];
    r?.onCreate && r.onCreate(n);
    let i = 0;
    for (const o of this.items)
      n.push(ys(o, String(i++), r));
    return n;
  }
  toString(e, r, n) {
    return e ? nI(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: n,
      onComment: r
    }) : JSON.stringify(this);
  }
  static from(e, r, n) {
    const { replacer: i } = n, o = new this(e);
    if (r && Symbol.iterator in Object(r)) {
      let s = 0;
      for (let a of r) {
        if (typeof i == "function") {
          const l = r instanceof Set ? a : String(s++);
          a = i.call(r, l, a);
        }
        o.items.push(Sg(a, void 0, n));
      }
    }
    return o;
  }
}
function oy(t) {
  let e = Or(t) ? t.value : t;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
const lp = {
  collection: "seq",
  default: !0,
  nodeClass: cc,
  tag: "tag:yaml.org,2002:seq",
  resolve(t, e) {
    return sp(t) || e("Expected a sequence for this tag"), t;
  },
  createNode: (t, e, r) => cc.from(t, e, r)
}, sx = {
  identify: (t) => typeof t == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (t) => t,
  stringify(t, e, r, n) {
    return e = Object.assign({ actualString: !0 }, e), h0(t, e, r, n);
  }
}, ax = {
  identify: (t) => t == null,
  createNode: () => new yt(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new yt(null),
  stringify: ({ source: t }, e) => typeof t == "string" && ax.test.test(t) ? t : e.options.nullStr
}, pS = {
  identify: (t) => typeof t == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (t) => new yt(t[0] === "t" || t[0] === "T"),
  stringify({ source: t, value: e }, r) {
    if (t && pS.test.test(t)) {
      const n = t[0] === "t" || t[0] === "T";
      if (e === n)
        return t;
    }
    return e ? r.options.trueStr : r.options.falseStr;
  }
};
function aa({ format: t, minFractionDigits: e, tag: r, value: n }) {
  if (typeof n == "bigint")
    return String(n);
  const i = typeof n == "number" ? n : Number(n);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let o = JSON.stringify(n);
  if (!t && e && (!r || r === "tag:yaml.org,2002:float") && /^\d/.test(o)) {
    let s = o.indexOf(".");
    s < 0 && (s = o.length, o += ".");
    let a = e - (o.length - s - 1);
    for (; a-- > 0; )
      o += "0";
  }
  return o;
}
const iI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: aa
}, oI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : aa(t);
  }
}, sI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(t) {
    const e = new yt(parseFloat(t)), r = t.indexOf(".");
    return r !== -1 && t[t.length - 1] === "0" && (e.minFractionDigits = t.length - r - 1), e;
  },
  stringify: aa
}, lx = (t) => typeof t == "bigint" || Number.isInteger(t), mS = (t, e, r, { intAsBigInt: n }) => n ? BigInt(t) : parseInt(t.substring(e), r);
function aI(t, e, r) {
  const { value: n } = t;
  return lx(n) && n >= 0 ? r + n.toString(e) : aa(t);
}
const lI = {
  identify: (t) => lx(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (t, e, r) => mS(t, 2, 8, r),
  stringify: (t) => aI(t, 8, "0o")
}, uI = {
  identify: lx,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (t, e, r) => mS(t, 0, 10, r),
  stringify: aa
}, cI = {
  identify: (t) => lx(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (t, e, r) => mS(t, 2, 16, r),
  stringify: (t) => aI(t, 16, "0x")
}, pde = [
  ap,
  lp,
  sx,
  ax,
  pS,
  lI,
  uI,
  cI,
  iI,
  oI,
  sI
];
function Z7(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}
const sy = ({ value: t }) => JSON.stringify(t), mde = [
  {
    identify: (t) => typeof t == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (t) => t,
    stringify: sy
  },
  {
    identify: (t) => t == null,
    createNode: () => new yt(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: sy
  },
  {
    identify: (t) => typeof t == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (t) => t === "true",
    stringify: sy
  },
  {
    identify: Z7,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (t, e, { intAsBigInt: r }) => r ? BigInt(t) : parseInt(t, 10),
    stringify: ({ value: t }) => Z7(t) ? t.toString() : JSON.stringify(t)
  },
  {
    identify: (t) => typeof t == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (t) => parseFloat(t),
    stringify: sy
  }
], gde = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(t, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(t)}`), t;
  }
}, vde = [ap, lp].concat(mde, gde), gS = {
  identify: (t) => t instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(t, e) {
    if (typeof atob == "function") {
      const r = atob(t.replace(/[\n\r]/g, "")), n = new Uint8Array(r.length);
      for (let i = 0; i < r.length; ++i)
        n[i] = r.charCodeAt(i);
      return n;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), t;
  },
  stringify({ comment: t, type: e, value: r }, n, i, o) {
    if (!r)
      return "";
    const s = r;
    let a;
    if (typeof btoa == "function") {
      let l = "";
      for (let u = 0; u < s.length; ++u)
        l += String.fromCharCode(s[u]);
      a = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e ?? (e = yt.BLOCK_LITERAL), e !== yt.QUOTE_DOUBLE) {
      const l = Math.max(n.options.lineWidth - n.indent.length, n.options.minContentWidth), u = Math.ceil(a.length / l), c = new Array(u);
      for (let h = 0, d = 0; h < u; ++h, d += l)
        c[h] = a.substr(d, l);
      a = c.join(e === yt.BLOCK_LITERAL ? `
` : " ");
    }
    return h0({ comment: t, type: e, value: a }, n, i, o);
  }
};
function hI(t, e) {
  if (sp(t))
    for (let r = 0; r < t.items.length; ++r) {
      let n = t.items[r];
      if (!Vr(n)) {
        if (op(n)) {
          n.items.length > 1 && e("Each pair must have its own sequence indicator");
          const i = n.items[0] || new hi(new yt(null));
          if (n.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${n.commentBefore}
${i.key.commentBefore}` : n.commentBefore), n.comment) {
            const o = i.value ?? i.key;
            o.comment = o.comment ? `${n.comment}
${o.comment}` : n.comment;
          }
          n = i;
        }
        t.items[r] = Vr(n) ? n : new hi(n);
      }
    }
  else
    e("Expected a sequence for this tag");
  return t;
}
function fI(t, e, r) {
  const { replacer: n } = r, i = new cc(t);
  i.tag = "tag:yaml.org,2002:pairs";
  let o = 0;
  if (e && Symbol.iterator in Object(e))
    for (let s of e) {
      typeof n == "function" && (s = n.call(e, String(o++), s));
      let a, l;
      if (Array.isArray(s))
        if (s.length === 2)
          a = s[0], l = s[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${s}`);
      else if (s && s instanceof Object) {
        const u = Object.keys(s);
        if (u.length === 1)
          a = u[0], l = s[a];
        else
          throw new TypeError(`Expected tuple with one key, not ${u.length} keys`);
      } else
        a = s;
      i.items.push(dS(a, l, r));
    }
  return i;
}
const vS = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: hI,
  createNode: fI
};
class ed extends cc {
  constructor() {
    super(), this.add = $o.prototype.add.bind(this), this.delete = $o.prototype.delete.bind(this), this.get = $o.prototype.get.bind(this), this.has = $o.prototype.has.bind(this), this.set = $o.prototype.set.bind(this), this.tag = ed.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, r) {
    if (!r)
      return super.toJSON(e);
    const n = /* @__PURE__ */ new Map();
    r?.onCreate && r.onCreate(n);
    for (const i of this.items) {
      let o, s;
      if (Vr(i) ? (o = ys(i.key, "", r), s = ys(i.value, o, r)) : o = ys(i, "", r), n.has(o))
        throw new Error("Ordered maps must not include duplicate keys");
      n.set(o, s);
    }
    return n;
  }
  static from(e, r, n) {
    const i = fI(e, r, n), o = new this();
    return o.items = i.items, o;
  }
}
ed.tag = "tag:yaml.org,2002:omap";
const yS = {
  collection: "seq",
  identify: (t) => t instanceof Map,
  nodeClass: ed,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(t, e) {
    const r = hI(t, e), n = [];
    for (const { key: i } of r.items)
      Or(i) && (n.includes(i.value) ? e(`Ordered maps must not include duplicate keys: ${i.value}`) : n.push(i.value));
    return Object.assign(new ed(), r);
  },
  createNode: (t, e, r) => ed.from(t, e, r)
};
function dI({ value: t, source: e }, r) {
  return e && (t ? pI : mI).test.test(e) ? e : t ? r.options.trueStr : r.options.falseStr;
}
const pI = {
  identify: (t) => t === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new yt(!0),
  stringify: dI
}, mI = {
  identify: (t) => t === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new yt(!1),
  stringify: dI
}, yde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: aa
}, bde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t.replace(/_/g, "")),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : aa(t);
  }
}, xde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(t) {
    const e = new yt(parseFloat(t.replace(/_/g, ""))), r = t.indexOf(".");
    if (r !== -1) {
      const n = t.substring(r + 1).replace(/_/g, "");
      n[n.length - 1] === "0" && (e.minFractionDigits = n.length);
    }
    return e;
  },
  stringify: aa
}, f0 = (t) => typeof t == "bigint" || Number.isInteger(t);
function ux(t, e, r, { intAsBigInt: n }) {
  const i = t[0];
  if ((i === "-" || i === "+") && (e += 1), t = t.substring(e).replace(/_/g, ""), n) {
    switch (r) {
      case 2:
        t = `0b${t}`;
        break;
      case 8:
        t = `0o${t}`;
        break;
      case 16:
        t = `0x${t}`;
        break;
    }
    const s = BigInt(t);
    return i === "-" ? BigInt(-1) * s : s;
  }
  const o = parseInt(t, r);
  return i === "-" ? -1 * o : o;
}
function bS(t, e, r) {
  const { value: n } = t;
  if (f0(n)) {
    const i = n.toString(e);
    return n < 0 ? "-" + r + i.substr(1) : r + i;
  }
  return aa(t);
}
const wde = {
  identify: f0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (t, e, r) => ux(t, 2, 2, r),
  stringify: (t) => bS(t, 2, "0b")
}, kde = {
  identify: f0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (t, e, r) => ux(t, 1, 8, r),
  stringify: (t) => bS(t, 8, "0")
}, Cde = {
  identify: f0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (t, e, r) => ux(t, 0, 10, r),
  stringify: aa
}, _de = {
  identify: f0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (t, e, r) => ux(t, 2, 16, r),
  stringify: (t) => bS(t, 16, "0x")
};
class td extends $o {
  constructor(e) {
    super(e), this.tag = td.tag;
  }
  add(e) {
    let r;
    Vr(e) ? r = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? r = new hi(e.key, null) : r = new hi(e, null), Kc(this.items, r.key) || this.items.push(r);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, r) {
    const n = Kc(this.items, e);
    return !r && Vr(n) ? Or(n.key) ? n.key.value : n.key : n;
  }
  set(e, r) {
    if (typeof r != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof r}`);
    const n = Kc(this.items, e);
    n && !r ? this.items.splice(this.items.indexOf(n), 1) : !n && r && this.items.push(new hi(e));
  }
  toJSON(e, r) {
    return super.toJSON(e, r, Set);
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), r, n);
    throw new Error("Set items must all have null values");
  }
  static from(e, r, n) {
    const { replacer: i } = n, o = new this(e);
    if (r && Symbol.iterator in Object(r))
      for (let s of r)
        typeof i == "function" && (s = i.call(r, s, s)), o.items.push(dS(s, null, n));
    return o;
  }
}
td.tag = "tag:yaml.org,2002:set";
const xS = {
  collection: "map",
  identify: (t) => t instanceof Set,
  nodeClass: td,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (t, e, r) => td.from(t, e, r),
  resolve(t, e) {
    if (op(t)) {
      if (t.hasAllNullValues(!0))
        return Object.assign(new td(), t);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return t;
  }
};
function wS(t, e) {
  const r = t[0], n = r === "-" || r === "+" ? t.substring(1) : t, i = (s) => e ? BigInt(s) : Number(s), o = n.replace(/_/g, "").split(":").reduce((s, a) => s * i(60) + i(a), i(0));
  return r === "-" ? i(-1) * o : o;
}
function gI(t) {
  let { value: e } = t, r = (s) => s;
  if (typeof e == "bigint")
    r = (s) => BigInt(s);
  else if (isNaN(e) || !isFinite(e))
    return aa(t);
  let n = "";
  e < 0 && (n = "-", e *= r(-1));
  const i = r(60), o = [e % i];
  return e < 60 ? o.unshift(0) : (e = (e - o[0]) / i, o.unshift(e % i), e >= 60 && (e = (e - o[0]) / i, o.unshift(e))), n + o.map((s) => String(s).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const vI = {
  identify: (t) => typeof t == "bigint" || Number.isInteger(t),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (t, e, { intAsBigInt: r }) => wS(t, r),
  stringify: gI
}, yI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (t) => wS(t, !1),
  stringify: gI
}, cx = {
  identify: (t) => t instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(t) {
    const e = t.match(cx.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, r, n, i, o, s, a] = e.map(Number), l = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let u = Date.UTC(r, n - 1, i, o || 0, s || 0, a || 0, l);
    const c = e[8];
    if (c && c !== "Z") {
      let h = wS(c, !1);
      Math.abs(h) < 30 && (h *= 60), u -= 6e4 * h;
    }
    return new Date(u);
  },
  stringify: ({ value: t }) => t?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
}, e9 = [
  ap,
  lp,
  sx,
  ax,
  pI,
  mI,
  wde,
  kde,
  Cde,
  _de,
  yde,
  bde,
  xde,
  gS,
  Wl,
  yS,
  vS,
  xS,
  vI,
  yI,
  cx
], t9 = /* @__PURE__ */ new Map([
  ["core", pde],
  ["failsafe", [ap, lp, sx]],
  ["json", vde],
  ["yaml11", e9],
  ["yaml-1.1", e9]
]), r9 = {
  binary: gS,
  bool: pS,
  float: sI,
  floatExp: oI,
  floatNaN: iI,
  floatTime: yI,
  int: uI,
  intHex: cI,
  intOct: lI,
  intTime: vI,
  map: ap,
  merge: Wl,
  null: ax,
  omap: yS,
  pairs: vS,
  seq: lp,
  set: xS,
  timestamp: cx
}, Sde = {
  "tag:yaml.org,2002:binary": gS,
  "tag:yaml.org,2002:merge": Wl,
  "tag:yaml.org,2002:omap": yS,
  "tag:yaml.org,2002:pairs": vS,
  "tag:yaml.org,2002:set": xS,
  "tag:yaml.org,2002:timestamp": cx
};
function dk(t, e, r) {
  const n = t9.get(e);
  if (n && !t)
    return r && !n.includes(Wl) ? n.concat(Wl) : n.slice();
  let i = n;
  if (!i)
    if (Array.isArray(t))
      i = [];
    else {
      const o = Array.from(t9.keys()).filter((s) => s !== "yaml11").map((s) => JSON.stringify(s)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${o} or define customTags array`);
    }
  if (Array.isArray(t))
    for (const o of t)
      i = i.concat(o);
  else typeof t == "function" && (i = t(i.slice()));
  return r && (i = i.concat(Wl)), i.reduce((o, s) => {
    const a = typeof s == "string" ? r9[s] : s;
    if (!a) {
      const l = JSON.stringify(s), u = Object.keys(r9).map((c) => JSON.stringify(c)).join(", ");
      throw new Error(`Unknown custom tag ${l}; use one of ${u}`);
    }
    return o.includes(a) || o.push(a), o;
  }, []);
}
const Ade = (t, e) => t.key < e.key ? -1 : t.key > e.key ? 1 : 0;
class hx {
  constructor({ compat: e, customTags: r, merge: n, resolveKnownTags: i, schema: o, sortMapEntries: s, toStringDefaults: a }) {
    this.compat = Array.isArray(e) ? dk(e, "compat") : e ? dk(null, e) : null, this.name = typeof o == "string" && o || "core", this.knownTags = i ? Sde : {}, this.tags = dk(r, this.name, n), this.toStringOptions = a ?? null, Object.defineProperty(this, Gu, { value: ap }), Object.defineProperty(this, Ja, { value: sx }), Object.defineProperty(this, ip, { value: lp }), this.sortMapEntries = typeof s == "function" ? s : s === !0 ? Ade : null;
  }
  clone() {
    const e = Object.create(hx.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
}
function Ede(t, e) {
  const r = [];
  let n = e.directives === !0;
  if (e.directives !== !1 && t.directives) {
    const l = t.directives.toString(t);
    l ? (r.push(l), n = !0) : t.directives.docStart && (n = !0);
  }
  n && r.push("---");
  const i = Z$(t, e), { commentString: o } = i.options;
  if (t.commentBefore) {
    r.length !== 1 && r.unshift("");
    const l = o(t.commentBefore);
    r.unshift(Ll(l, ""));
  }
  let s = !1, a = null;
  if (t.contents) {
    if (Xr(t.contents)) {
      if (t.contents.spaceBefore && n && r.push(""), t.contents.commentBefore) {
        const c = o(t.contents.commentBefore);
        r.push(Ll(c, ""));
      }
      i.forceBlockIndent = !!t.comment, a = t.contents.comment;
    }
    const l = a ? void 0 : () => s = !0;
    let u = Td(t.contents, i, () => a = null, l);
    a && (u += Gc(u, "", o(a))), (u[0] === "|" || u[0] === ">") && r[r.length - 1] === "---" ? r[r.length - 1] = `--- ${u}` : r.push(u);
  } else
    r.push(Td(t.contents, i));
  if (t.directives?.docEnd)
    if (t.comment) {
      const l = o(t.comment);
      l.includes(`
`) ? (r.push("..."), r.push(Ll(l, ""))) : r.push(`... ${l}`);
    } else
      r.push("...");
  else {
    let l = t.comment;
    l && s && (l = l.replace(/^\n+/, "")), l && ((!s || a) && r[r.length - 1] !== "" && r.push(""), r.push(Ll(o(l), "")));
  }
  return r.join(`
`) + `
`;
}
class up {
  constructor(e, r, n) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, ks, { value: qC });
    let i = null;
    typeof r == "function" || Array.isArray(r) ? i = r : n === void 0 && r && (n = r, r = void 0);
    const o = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      stringKeys: !1,
      uniqueKeys: !0,
      version: "1.2"
    }, n);
    this.options = o;
    let { version: s } = o;
    n?._directives ? (this.directives = n._directives.atDocument(), this.directives.yaml.explicit && (s = this.directives.yaml.version)) : this.directives = new Ai({ version: s }), this.setSchema(s, n), this.contents = e === void 0 ? null : this.createNode(e, i, n);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(up.prototype, {
      [ks]: { value: qC }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = Xr(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    bf(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, r) {
    bf(this.contents) && this.contents.addIn(e, r);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, r) {
    if (!e.anchor) {
      const n = K$(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !r || n.has(r) ? Q$(r || "a", n) : r;
    }
    return new rx(e.anchor);
  }
  createNode(e, r, n) {
    let i;
    if (typeof r == "function")
      e = r.call({ "": e }, "", e), i = r;
    else if (Array.isArray(r)) {
      const y = (k) => typeof k == "number" || k instanceof String || k instanceof Number, b = r.filter(y).map(String);
      b.length > 0 && (r = r.concat(b)), i = r;
    } else n === void 0 && r && (n = r, r = void 0);
    const { aliasDuplicateObjects: o, anchorPrefix: s, flow: a, keepUndefined: l, onTagObj: u, tag: c } = n ?? {}, { onAnchor: h, setAnchors: d, sourceObjects: p } = tde(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      s || "a"
    ), g = {
      aliasDuplicateObjects: o ?? !0,
      keepUndefined: l ?? !1,
      onAnchor: h,
      onTagObj: u,
      replacer: i,
      schema: this.schema,
      sourceObjects: p
    }, v = Sg(e, c, g);
    return a && Qr(v) && (v.flow = !0), d(), v;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, r, n = {}) {
    const i = this.createNode(e, null, n), o = this.createNode(r, null, n);
    return new hi(i, o);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return bf(this.contents) ? this.contents.delete(e) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return ym(e) ? this.contents == null ? !1 : (this.contents = null, !0) : bf(this.contents) ? this.contents.deleteIn(e) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, r) {
    return Qr(this.contents) ? this.contents.get(e, r) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    return ym(e) ? !r && Or(this.contents) ? this.contents.value : this.contents : Qr(this.contents) ? this.contents.getIn(e, r) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return Qr(this.contents) ? this.contents.has(e) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return ym(e) ? this.contents !== void 0 : Qr(this.contents) ? this.contents.hasIn(e) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, r) {
    this.contents == null ? this.contents = X1(this.schema, [e], r) : bf(this.contents) && this.contents.set(e, r);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    ym(e) ? this.contents = r : this.contents == null ? this.contents = X1(this.schema, Array.from(e), r) : bf(this.contents) && this.contents.setIn(e, r);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, r = {}) {
    typeof e == "number" && (e = String(e));
    let n;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Ai({ version: "1.1" }), n = { resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Ai({ version: e }), n = { resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, n = null;
        break;
      default: {
        const i = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (r.schema instanceof Object)
      this.schema = r.schema;
    else if (n)
      this.schema = new hx(Object.assign(n, r));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: r, mapAsMap: n, maxAliasCount: i, onAnchor: o, reviver: s } = {}) {
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: n === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof i == "number" ? i : 100
    }, l = ys(this.contents, r ?? "", a);
    if (typeof o == "function")
      for (const { count: u, res: c } of a.anchors.values())
        o(c, u);
    return typeof s == "function" ? $f(s, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, r) {
    return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: r });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const r = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${r}`);
    }
    return Ede(this, e);
  }
}
function bf(t) {
  if (Qr(t))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class kS extends Error {
  constructor(e, r, n, i) {
    super(), this.name = e, this.code = n, this.message = i, this.pos = r;
  }
}
class Qc extends kS {
  constructor(e, r, n) {
    super("YAMLParseError", e, r, n);
  }
}
class bI extends kS {
  constructor(e, r, n) {
    super("YAMLWarning", e, r, n);
  }
}
const Y1 = (t, e) => (r) => {
  if (r.pos[0] === -1)
    return;
  r.linePos = r.pos.map((a) => e.linePos(a));
  const { line: n, col: i } = r.linePos[0];
  r.message += ` at line ${n}, column ${i}`;
  let o = i - 1, s = t.substring(e.lineStarts[n - 1], e.lineStarts[n]).replace(/[\n\r]+$/, "");
  if (o >= 60 && s.length > 80) {
    const a = Math.min(o - 39, s.length - 79);
    s = "â€¦" + s.substring(a), o -= a - 1;
  }
  if (s.length > 80 && (s = s.substring(0, 79) + "â€¦"), n > 1 && /^ *$/.test(s.substring(0, o))) {
    let a = t.substring(e.lineStarts[n - 2], e.lineStarts[n - 1]);
    a.length > 80 && (a = a.substring(0, 79) + `â€¦
`), s = a + s;
  }
  if (/[^ ]/.test(s)) {
    let a = 1;
    const l = r.linePos[1];
    l && l.line === n && l.col > i && (a = Math.max(1, Math.min(l.col - i, 80 - o)));
    const u = " ".repeat(o) + "^".repeat(a);
    r.message += `:

${s}
${u}
`;
  }
};
function Md(t, { flow: e, indicator: r, next: n, offset: i, onError: o, parentIndent: s, startOnNewline: a }) {
  let l = !1, u = a, c = a, h = "", d = "", p = !1, g = !1, v = null, y = null, b = null, k = null, C = null, S = null, _ = null;
  for (const O of t)
    switch (g && (O.type !== "space" && O.type !== "newline" && O.type !== "comma" && o(O.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), g = !1), v && (u && O.type !== "comment" && O.type !== "newline" && o(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), v = null), O.type) {
      case "space":
        !e && (r !== "doc-start" || n?.type !== "flow-collection") && O.source.includes("	") && (v = O), c = !0;
        break;
      case "comment": {
        c || o(O, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const M = O.source.substring(1) || " ";
        h ? h += d + M : h = M, d = "", u = !1;
        break;
      }
      case "newline":
        u ? h ? h += O.source : (!S || r !== "seq-item-ind") && (l = !0) : d += O.source, u = !0, p = !0, (y || b) && (k = O), c = !0;
        break;
      case "anchor":
        y && o(O, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), O.source.endsWith(":") && o(O.offset + O.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), y = O, _ ?? (_ = O.offset), u = !1, c = !1, g = !0;
        break;
      case "tag": {
        b && o(O, "MULTIPLE_TAGS", "A node can have at most one tag"), b = O, _ ?? (_ = O.offset), u = !1, c = !1, g = !0;
        break;
      }
      case r:
        (y || b) && o(O, "BAD_PROP_ORDER", `Anchors and tags must be after the ${O.source} indicator`), S && o(O, "UNEXPECTED_TOKEN", `Unexpected ${O.source} in ${e ?? "collection"}`), S = O, u = r === "seq-item-ind" || r === "explicit-key-ind", c = !1;
        break;
      case "comma":
        if (e) {
          C && o(O, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), C = O, u = !1, c = !1;
          break;
        }
      // else fallthrough
      default:
        o(O, "UNEXPECTED_TOKEN", `Unexpected ${O.type} token`), u = !1, c = !1;
    }
  const D = t[t.length - 1], A = D ? D.offset + D.source.length : i;
  return g && n && n.type !== "space" && n.type !== "newline" && n.type !== "comma" && (n.type !== "scalar" || n.source !== "") && o(n.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), v && (u && v.indent <= s || n?.type === "block-map" || n?.type === "block-seq") && o(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: C,
    found: S,
    spaceBefore: l,
    comment: h,
    hasNewline: p,
    anchor: y,
    tag: b,
    newlineAfterProp: k,
    end: A,
    start: _ ?? A
  };
}
function Ag(t) {
  if (!t)
    return null;
  switch (t.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (t.source.includes(`
`))
        return !0;
      if (t.end) {
        for (const e of t.end)
          if (e.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const e of t.items) {
        for (const r of e.start)
          if (r.type === "newline")
            return !0;
        if (e.sep) {
          for (const r of e.sep)
            if (r.type === "newline")
              return !0;
        }
        if (Ag(e.key) || Ag(e.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function WC(t, e, r) {
  if (e?.type === "flow-collection") {
    const n = e.end[0];
    n.indent === t && (n.source === "]" || n.source === "}") && Ag(e) && r(n, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function xI(t, e, r) {
  const { uniqueKeys: n } = t.options;
  if (n === !1)
    return !1;
  const i = typeof n == "function" ? n : (o, s) => o === s || Or(o) && Or(s) && o.value === s.value;
  return e.some((o) => i(o.key, r));
}
const n9 = "All mapping items must start at the same column";
function Dde({ composeNode: t, composeEmptyNode: e }, r, n, i, o) {
  const s = o?.nodeClass ?? $o, a = new s(r.schema);
  r.atRoot && (r.atRoot = !1);
  let l = n.offset, u = null;
  for (const c of n.items) {
    const { start: h, key: d, sep: p, value: g } = c, v = Md(h, {
      indicator: "explicit-key-ind",
      next: d ?? p?.[0],
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !0
    }), y = !v.found;
    if (y) {
      if (d && (d.type === "block-seq" ? i(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in d && d.indent !== n.indent && i(l, "BAD_INDENT", n9)), !v.anchor && !v.tag && !p) {
        u = v.end, v.comment && (a.comment ? a.comment += `
` + v.comment : a.comment = v.comment);
        continue;
      }
      (v.newlineAfterProp || Ag(d)) && i(d ?? h[h.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else v.found?.indent !== n.indent && i(l, "BAD_INDENT", n9);
    r.atKey = !0;
    const b = v.end, k = d ? t(r, d, v, i) : e(r, b, h, null, v, i);
    r.schema.compat && WC(n.indent, d, i), r.atKey = !1, xI(r, a.items, k) && i(b, "DUPLICATE_KEY", "Map keys must be unique");
    const C = Md(p ?? [], {
      indicator: "map-value-ind",
      next: g,
      offset: k.range[2],
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !d || d.type === "block-scalar"
    });
    if (l = C.end, C.found) {
      y && (g?.type === "block-map" && !C.hasNewline && i(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), r.options.strict && v.start < C.found.offset - 1024 && i(k.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const S = g ? t(r, g, C, i) : e(r, l, p, null, C, i);
      r.schema.compat && WC(n.indent, g, i), l = S.range[2];
      const _ = new hi(k, S);
      r.options.keepSourceTokens && (_.srcToken = c), a.items.push(_);
    } else {
      y && i(k.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), C.comment && (k.comment ? k.comment += `
` + C.comment : k.comment = C.comment);
      const S = new hi(k);
      r.options.keepSourceTokens && (S.srcToken = c), a.items.push(S);
    }
  }
  return u && u < l && i(u, "IMPOSSIBLE", "Map comment with trailing content"), a.range = [n.offset, l, u ?? l], a;
}
function Ode({ composeNode: t, composeEmptyNode: e }, r, n, i, o) {
  const s = o?.nodeClass ?? cc, a = new s(r.schema);
  r.atRoot && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let l = n.offset, u = null;
  for (const { start: c, value: h } of n.items) {
    const d = Md(c, {
      indicator: "seq-item-ind",
      next: h,
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !0
    });
    if (!d.found)
      if (d.anchor || d.tag || h)
        h && h.type === "block-seq" ? i(d.end, "BAD_INDENT", "All sequence items must start at the same column") : i(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        u = d.end, d.comment && (a.comment = d.comment);
        continue;
      }
    const p = h ? t(r, h, d, i) : e(r, d.end, c, null, d, i);
    r.schema.compat && WC(n.indent, h, i), l = p.range[2], a.items.push(p);
  }
  return a.range = [n.offset, l, u ?? l], a;
}
function d0(t, e, r, n) {
  let i = "";
  if (t) {
    let o = !1, s = "";
    for (const a of t) {
      const { source: l, type: u } = a;
      switch (u) {
        case "space":
          o = !0;
          break;
        case "comment": {
          r && !o && n(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const c = l.substring(1) || " ";
          i ? i += s + c : i = c, s = "";
          break;
        }
        case "newline":
          i && (s += l), o = !0;
          break;
        default:
          n(a, "UNEXPECTED_TOKEN", `Unexpected ${u} at node end`);
      }
      e += l.length;
    }
  }
  return { comment: i, offset: e };
}
const pk = "Block collections are not allowed within flow collections", mk = (t) => t && (t.type === "block-map" || t.type === "block-seq");
function Fde({ composeNode: t, composeEmptyNode: e }, r, n, i, o) {
  const s = n.start.source === "{", a = s ? "flow map" : "flow sequence", l = o?.nodeClass ?? (s ? $o : cc), u = new l(r.schema);
  u.flow = !0;
  const c = r.atRoot;
  c && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let h = n.offset + n.start.source.length;
  for (let y = 0; y < n.items.length; ++y) {
    const b = n.items[y], { start: k, key: C, sep: S, value: _ } = b, D = Md(k, {
      flow: a,
      indicator: "explicit-key-ind",
      next: C ?? S?.[0],
      offset: h,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !1
    });
    if (!D.found) {
      if (!D.anchor && !D.tag && !S && !_) {
        y === 0 && D.comma ? i(D.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`) : y < n.items.length - 1 && i(D.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${a}`), D.comment && (u.comment ? u.comment += `
` + D.comment : u.comment = D.comment), h = D.end;
        continue;
      }
      !s && r.options.strict && Ag(C) && i(
        C,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (y === 0)
      D.comma && i(D.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`);
    else if (D.comma || i(D.start, "MISSING_CHAR", `Missing , between ${a} items`), D.comment) {
      let A = "";
      e: for (const O of k)
        switch (O.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            A = O.source.substring(1);
            break e;
          default:
            break e;
        }
      if (A) {
        let O = u.items[u.items.length - 1];
        Vr(O) && (O = O.value ?? O.key), O.comment ? O.comment += `
` + A : O.comment = A, D.comment = D.comment.substring(A.length + 1);
      }
    }
    if (!s && !S && !D.found) {
      const A = _ ? t(r, _, D, i) : e(r, D.end, S, null, D, i);
      u.items.push(A), h = A.range[2], mk(_) && i(A.range, "BLOCK_IN_FLOW", pk);
    } else {
      r.atKey = !0;
      const A = D.end, O = C ? t(r, C, D, i) : e(r, A, k, null, D, i);
      mk(C) && i(O.range, "BLOCK_IN_FLOW", pk), r.atKey = !1;
      const M = Md(S ?? [], {
        flow: a,
        indicator: "map-value-ind",
        next: _,
        offset: O.range[2],
        onError: i,
        parentIndent: n.indent,
        startOnNewline: !1
      });
      if (M.found) {
        if (!s && !D.found && r.options.strict) {
          if (S)
            for (const N of S) {
              if (N === M.found)
                break;
              if (N.type === "newline") {
                i(N, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          D.start < M.found.offset - 1024 && i(M.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else _ && ("source" in _ && _.source && _.source[0] === ":" ? i(_, "MISSING_CHAR", `Missing space after : in ${a}`) : i(M.start, "MISSING_CHAR", `Missing , or : between ${a} items`));
      const z = _ ? t(r, _, M, i) : M.found ? e(r, M.end, S, null, M, i) : null;
      z ? mk(_) && i(z.range, "BLOCK_IN_FLOW", pk) : M.comment && (O.comment ? O.comment += `
` + M.comment : O.comment = M.comment);
      const R = new hi(O, z);
      if (r.options.keepSourceTokens && (R.srcToken = b), s) {
        const N = u;
        xI(r, N.items, O) && i(A, "DUPLICATE_KEY", "Map keys must be unique"), N.items.push(R);
      } else {
        const N = new $o(r.schema);
        N.flow = !0, N.items.push(R);
        const I = (z ?? O).range;
        N.range = [O.range[0], I[1], I[2]], u.items.push(N);
      }
      h = z ? z.range[2] : M.end;
    }
  }
  const d = s ? "}" : "]", [p, ...g] = n.end;
  let v = h;
  if (p && p.source === d)
    v = p.offset + p.source.length;
  else {
    const y = a[0].toUpperCase() + a.substring(1), b = c ? `${y} must end with a ${d}` : `${y} in block collection must be sufficiently indented and end with a ${d}`;
    i(h, c ? "MISSING_CHAR" : "BAD_INDENT", b), p && p.source.length !== 1 && g.unshift(p);
  }
  if (g.length > 0) {
    const y = d0(g, v, r.options.strict, i);
    y.comment && (u.comment ? u.comment += `
` + y.comment : u.comment = y.comment), u.range = [n.offset, v, y.offset];
  } else
    u.range = [n.offset, v, v];
  return u;
}
function gk(t, e, r, n, i, o) {
  const s = r.type === "block-map" ? Dde(t, e, r, n, o) : r.type === "block-seq" ? Ode(t, e, r, n, o) : Fde(t, e, r, n, o), a = s.constructor;
  return i === "!" || i === a.tagName ? (s.tag = a.tagName, s) : (i && (s.tag = i), s);
}
function Tde(t, e, r, n, i) {
  const o = n.tag, s = o ? e.directives.tagName(o.source, (d) => i(o, "TAG_RESOLVE_FAILED", d)) : null;
  if (r.type === "block-seq") {
    const { anchor: d, newlineAfterProp: p } = n, g = d && o ? d.offset > o.offset ? d : o : d ?? o;
    g && (!p || p.offset < g.offset) && i(g, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const a = r.type === "block-map" ? "map" : r.type === "block-seq" ? "seq" : r.start.source === "{" ? "map" : "seq";
  if (!o || !s || s === "!" || s === $o.tagName && a === "map" || s === cc.tagName && a === "seq")
    return gk(t, e, r, i, s);
  let l = e.schema.tags.find((d) => d.tag === s && d.collection === a);
  if (!l) {
    const d = e.schema.knownTags[s];
    if (d && d.collection === a)
      e.schema.tags.push(Object.assign({}, d, { default: !1 })), l = d;
    else
      return d ? i(o, "BAD_COLLECTION_TYPE", `${d.tag} used for ${a} collection, but expects ${d.collection ?? "scalar"}`, !0) : i(o, "TAG_RESOLVE_FAILED", `Unresolved tag: ${s}`, !0), gk(t, e, r, i, s);
  }
  const u = gk(t, e, r, i, s, l), c = l.resolve?.(u, (d) => i(o, "TAG_RESOLVE_FAILED", d), e.options) ?? u, h = Xr(c) ? c : new yt(c);
  return h.range = u.range, h.tag = s, l?.format && (h.format = l.format), h;
}
function wI(t, e, r) {
  const n = e.offset, i = Mde(e, t.options.strict, r);
  if (!i)
    return { value: "", type: null, comment: "", range: [n, n, n] };
  const o = i.mode === ">" ? yt.BLOCK_FOLDED : yt.BLOCK_LITERAL, s = e.source ? Pde(e.source) : [];
  let a = s.length;
  for (let v = s.length - 1; v >= 0; --v) {
    const y = s[v][1];
    if (y === "" || y === "\r")
      a = v;
    else
      break;
  }
  if (a === 0) {
    const v = i.chomp === "+" && s.length > 0 ? `
`.repeat(Math.max(1, s.length - 1)) : "";
    let y = n + i.length;
    return e.source && (y += e.source.length), { value: v, type: o, comment: i.comment, range: [n, y, y] };
  }
  let l = e.indent + i.indent, u = e.offset + i.length, c = 0;
  for (let v = 0; v < a; ++v) {
    const [y, b] = s[v];
    if (b === "" || b === "\r")
      i.indent === 0 && y.length > l && (l = y.length);
    else {
      y.length < l && r(u + y.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (l = y.length), c = v, l === 0 && !t.atRoot && r(u, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    u += y.length + b.length + 1;
  }
  for (let v = s.length - 1; v >= a; --v)
    s[v][0].length > l && (a = v + 1);
  let h = "", d = "", p = !1;
  for (let v = 0; v < c; ++v)
    h += s[v][0].slice(l) + `
`;
  for (let v = c; v < a; ++v) {
    let [y, b] = s[v];
    u += y.length + b.length + 1;
    const k = b[b.length - 1] === "\r";
    if (k && (b = b.slice(0, -1)), b && y.length < l) {
      const C = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      r(u - b.length - (k ? 2 : 1), "BAD_INDENT", C), y = "";
    }
    o === yt.BLOCK_LITERAL ? (h += d + y.slice(l) + b, d = `
`) : y.length > l || b[0] === "	" ? (d === " " ? d = `
` : !p && d === `
` && (d = `

`), h += d + y.slice(l) + b, d = `
`, p = !0) : b === "" ? d === `
` ? h += `
` : d = `
` : (h += d + b, d = " ", p = !1);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let v = a; v < s.length; ++v)
        h += `
` + s[v][0].slice(l);
      h[h.length - 1] !== `
` && (h += `
`);
      break;
    default:
      h += `
`;
  }
  const g = n + i.length + e.source.length;
  return { value: h, type: o, comment: i.comment, range: [n, g, g] };
}
function Mde({ offset: t, props: e }, r, n) {
  if (e[0].type !== "block-scalar-header")
    return n(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = e[0], o = i[0];
  let s = 0, a = "", l = -1;
  for (let d = 1; d < i.length; ++d) {
    const p = i[d];
    if (!a && (p === "-" || p === "+"))
      a = p;
    else {
      const g = Number(p);
      !s && g ? s = g : l === -1 && (l = t + d);
    }
  }
  l !== -1 && n(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let u = !1, c = "", h = i.length;
  for (let d = 1; d < e.length; ++d) {
    const p = e[d];
    switch (p.type) {
      case "space":
        u = !0;
      // fallthrough
      case "newline":
        h += p.source.length;
        break;
      case "comment":
        r && !u && n(p, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), h += p.source.length, c = p.source.substring(1);
        break;
      case "error":
        n(p, "UNEXPECTED_TOKEN", p.message), h += p.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const g = `Unexpected token in block scalar header: ${p.type}`;
        n(p, "UNEXPECTED_TOKEN", g);
        const v = p.source;
        v && typeof v == "string" && (h += v.length);
      }
    }
  }
  return { mode: o, indent: s, chomp: a, comment: c, length: h };
}
function Pde(t) {
  const e = t.split(/\n( *)/), r = e[0], n = r.match(/^( *)/), i = [n?.[1] ? [n[1], r.slice(n[1].length)] : ["", r]];
  for (let o = 1; o < e.length; o += 2)
    i.push([e[o], e[o + 1]]);
  return i;
}
function kI(t, e, r) {
  const { offset: n, type: i, source: o, end: s } = t;
  let a, l;
  const u = (d, p, g) => r(n + d, p, g);
  switch (i) {
    case "scalar":
      a = yt.PLAIN, l = Rde(o, u);
      break;
    case "single-quoted-scalar":
      a = yt.QUOTE_SINGLE, l = Nde(o, u);
      break;
    case "double-quoted-scalar":
      a = yt.QUOTE_DOUBLE, l = $de(o, u);
      break;
    /* istanbul ignore next should not happen */
    default:
      return r(t, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [n, n + o.length, n + o.length]
      };
  }
  const c = n + o.length, h = d0(s, c, e, r);
  return {
    value: l,
    type: a,
    comment: h.comment,
    range: [n, c, h.offset]
  };
}
function Rde(t, e) {
  let r = "";
  switch (t[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      r = "a tab character";
      break;
    case ",":
      r = "flow indicator character ,";
      break;
    case "%":
      r = "directive indicator character %";
      break;
    case "|":
    case ">": {
      r = `block scalar indicator ${t[0]}`;
      break;
    }
    case "@":
    case "`": {
      r = `reserved character ${t[0]}`;
      break;
    }
  }
  return r && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${r}`), CI(t);
}
function Nde(t, e) {
  return (t[t.length - 1] !== "'" || t.length === 1) && e(t.length, "MISSING_CHAR", "Missing closing 'quote"), CI(t.slice(1, -1)).replace(/''/g, "'");
}
function CI(t) {
  let e, r;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), r = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, r = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let n = e.exec(t);
  if (!n)
    return t;
  let i = n[1], o = " ", s = e.lastIndex;
  for (r.lastIndex = s; n = r.exec(t); )
    n[1] === "" ? o === `
` ? i += o : o = `
` : (i += o + n[1], o = " "), s = r.lastIndex;
  const a = /[ \t]*(.*)/sy;
  return a.lastIndex = s, n = a.exec(t), i + o + (n?.[1] ?? "");
}
function $de(t, e) {
  let r = "";
  for (let n = 1; n < t.length - 1; ++n) {
    const i = t[n];
    if (!(i === "\r" && t[n + 1] === `
`))
      if (i === `
`) {
        const { fold: o, offset: s } = Ide(t, n);
        r += o, n = s;
      } else if (i === "\\") {
        let o = t[++n];
        const s = Bde[o];
        if (s)
          r += s;
        else if (o === `
`)
          for (o = t[n + 1]; o === " " || o === "	"; )
            o = t[++n + 1];
        else if (o === "\r" && t[n + 1] === `
`)
          for (o = t[++n + 1]; o === " " || o === "	"; )
            o = t[++n + 1];
        else if (o === "x" || o === "u" || o === "U") {
          const a = { x: 2, u: 4, U: 8 }[o];
          r += Lde(t, n + 1, a, e), n += a;
        } else {
          const a = t.substr(n - 1, 2);
          e(n - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), r += a;
        }
      } else if (i === " " || i === "	") {
        const o = n;
        let s = t[n + 1];
        for (; s === " " || s === "	"; )
          s = t[++n + 1];
        s !== `
` && !(s === "\r" && t[n + 2] === `
`) && (r += n > o ? t.slice(o, n + 1) : i);
      } else
        r += i;
  }
  return (t[t.length - 1] !== '"' || t.length === 1) && e(t.length, "MISSING_CHAR", 'Missing closing "quote'), r;
}
function Ide(t, e) {
  let r = "", n = t[e + 1];
  for (; (n === " " || n === "	" || n === `
` || n === "\r") && !(n === "\r" && t[e + 2] !== `
`); )
    n === `
` && (r += `
`), e += 1, n = t[e + 1];
  return r || (r = " "), { fold: r, offset: e };
}
const Bde = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "Â…",
  // Unicode next line
  _: "Â ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function Lde(t, e, r, n) {
  const i = t.substr(e, r), o = i.length === r && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(o)) {
    const s = t.substr(e - 2, r + 2);
    return n(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${s}`), s;
  }
  return String.fromCodePoint(o);
}
function _I(t, e, r, n) {
  const { value: i, type: o, comment: s, range: a } = e.type === "block-scalar" ? wI(t, e, n) : kI(e, t.options.strict, n), l = r ? t.directives.tagName(r.source, (h) => n(r, "TAG_RESOLVE_FAILED", h)) : null;
  let u;
  t.options.stringKeys && t.atKey ? u = t.schema[Ja] : l ? u = zde(t.schema, i, l, r, n) : e.type === "scalar" ? u = jde(t, i, e, n) : u = t.schema[Ja];
  let c;
  try {
    const h = u.resolve(i, (d) => n(r ?? e, "TAG_RESOLVE_FAILED", d), t.options);
    c = Or(h) ? h : new yt(h);
  } catch (h) {
    const d = h instanceof Error ? h.message : String(h);
    n(r ?? e, "TAG_RESOLVE_FAILED", d), c = new yt(i);
  }
  return c.range = a, c.source = i, o && (c.type = o), l && (c.tag = l), u.format && (c.format = u.format), s && (c.comment = s), c;
}
function zde(t, e, r, n, i) {
  if (r === "!")
    return t[Ja];
  const o = [];
  for (const a of t.tags)
    if (!a.collection && a.tag === r)
      if (a.default && a.test)
        o.push(a);
      else
        return a;
  for (const a of o)
    if (a.test?.test(e))
      return a;
  const s = t.knownTags[r];
  return s && !s.collection ? (t.tags.push(Object.assign({}, s, { default: !1, test: void 0 })), s) : (i(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${r}`, r !== "tag:yaml.org,2002:str"), t[Ja]);
}
function jde({ atKey: t, directives: e, schema: r }, n, i, o) {
  const s = r.tags.find((a) => (a.default === !0 || t && a.default === "key") && a.test?.test(n)) || r[Ja];
  if (r.compat) {
    const a = r.compat.find((l) => l.default && l.test?.test(n)) ?? r[Ja];
    if (s.tag !== a.tag) {
      const l = e.tagString(s.tag), u = e.tagString(a.tag), c = `Value may be parsed as either ${l} or ${u}`;
      o(i, "TAG_RESOLVE_FAILED", c, !0);
    }
  }
  return s;
}
function qde(t, e, r) {
  if (e) {
    r ?? (r = e.length);
    for (let n = r - 1; n >= 0; --n) {
      let i = e[n];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          t -= i.source.length;
          continue;
      }
      for (i = e[++n]; i?.type === "space"; )
        t += i.source.length, i = e[++n];
      break;
    }
  }
  return t;
}
const Ude = { composeNode: SI, composeEmptyNode: CS };
function SI(t, e, r, n) {
  const i = t.atKey, { spaceBefore: o, comment: s, anchor: a, tag: l } = r;
  let u, c = !0;
  switch (e.type) {
    case "alias":
      u = Hde(t, e, n), (a || l) && n(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      u = _I(t, e, l, n), a && (u.anchor = a.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      u = Tde(Ude, t, e, r, n), a && (u.anchor = a.source.substring(1));
      break;
    default: {
      const h = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      n(e, "UNEXPECTED_TOKEN", h), u = CS(t, e.offset, void 0, null, r, n), c = !1;
    }
  }
  return a && u.anchor === "" && n(a, "BAD_ALIAS", "Anchor cannot be an empty string"), i && t.options.stringKeys && (!Or(u) || typeof u.value != "string" || u.tag && u.tag !== "tag:yaml.org,2002:str") && n(l ?? e, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), o && (u.spaceBefore = !0), s && (e.type === "scalar" && e.source === "" ? u.comment = s : u.commentBefore = s), t.options.keepSourceTokens && c && (u.srcToken = e), u;
}
function CS(t, e, r, n, { spaceBefore: i, comment: o, anchor: s, tag: a, end: l }, u) {
  const c = {
    type: "scalar",
    offset: qde(e, r, n),
    indent: -1,
    source: ""
  }, h = _I(t, c, a, u);
  return s && (h.anchor = s.source.substring(1), h.anchor === "" && u(s, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (h.spaceBefore = !0), o && (h.comment = o, h.range[2] = l), h;
}
function Hde({ options: t }, { offset: e, source: r, end: n }, i) {
  const o = new rx(r.substring(1));
  o.source === "" && i(e, "BAD_ALIAS", "Alias cannot be an empty string"), o.source.endsWith(":") && i(e + r.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const s = e + r.length, a = d0(n, s, t.strict, i);
  return o.range = [e, s, a.offset], a.comment && (o.comment = a.comment), o;
}
function Vde(t, e, { offset: r, start: n, value: i, end: o }, s) {
  const a = Object.assign({ _directives: e }, t), l = new up(void 0, a), u = {
    atKey: !1,
    atRoot: !0,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, c = Md(n, {
    indicator: "doc-start",
    next: i ?? o?.[0],
    offset: r,
    onError: s,
    parentIndent: 0,
    startOnNewline: !0
  });
  c.found && (l.directives.docStart = !0, i && (i.type === "block-map" || i.type === "block-seq") && !c.hasNewline && s(c.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = i ? SI(u, i, c, s) : CS(u, c.end, n, null, c, s);
  const h = l.contents.range[2], d = d0(o, h, !1, s);
  return d.comment && (l.comment = d.comment), l.range = [r, h, d.offset], l;
}
function tm(t) {
  if (typeof t == "number")
    return [t, t + 1];
  if (Array.isArray(t))
    return t.length === 2 ? t : [t[0], t[1]];
  const { offset: e, source: r } = t;
  return [e, e + (typeof r == "string" ? r.length : 1)];
}
function i9(t) {
  let e = "", r = !1, n = !1;
  for (let i = 0; i < t.length; ++i) {
    const o = t[i];
    switch (o[0]) {
      case "#":
        e += (e === "" ? "" : n ? `

` : `
`) + (o.substring(1) || " "), r = !0, n = !1;
        break;
      case "%":
        t[i + 1]?.[0] !== "#" && (i += 1), r = !1;
        break;
      default:
        r || (n = !0), r = !1;
    }
  }
  return { comment: e, afterEmptyLine: n };
}
class _S {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (r, n, i, o) => {
      const s = tm(r);
      o ? this.warnings.push(new bI(s, n, i)) : this.errors.push(new Qc(s, n, i));
    }, this.directives = new Ai({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, r) {
    const { comment: n, afterEmptyLine: i } = i9(this.prelude);
    if (n) {
      const o = e.contents;
      if (r)
        e.comment = e.comment ? `${e.comment}
${n}` : n;
      else if (i || e.directives.docStart || !o)
        e.commentBefore = n;
      else if (Qr(o) && !o.flow && o.items.length > 0) {
        let s = o.items[0];
        Vr(s) && (s = s.key);
        const a = s.commentBefore;
        s.commentBefore = a ? `${n}
${a}` : n;
      } else {
        const s = o.commentBefore;
        o.commentBefore = s ? `${n}
${s}` : n;
      }
    }
    r ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: i9(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, r = !1, n = -1) {
    for (const i of e)
      yield* this.next(i);
    yield* this.end(r, n);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (r, n, i) => {
          const o = tm(e);
          o[0] += r, this.onError(o, "BAD_DIRECTIVE", n, i);
        }), this.prelude.push(e.source), this.atDirectives = !0;
        break;
      case "document": {
        const r = Vde(this.options, this.directives, e, this.onError);
        this.atDirectives && !r.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(r, !1), this.doc && (yield this.doc), this.doc = r, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const r = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, n = new Qc(tm(e), "UNEXPECTED_TOKEN", r);
        this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const n = "Unexpected doc-end without preceding document";
          this.errors.push(new Qc(tm(e), "UNEXPECTED_TOKEN", n));
          break;
        }
        this.doc.directives.docEnd = !0;
        const r = d0(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), r.comment) {
          const n = this.doc.comment;
          this.doc.comment = n ? `${n}
${r.comment}` : r.comment;
        }
        this.doc.range[2] = r.offset;
        break;
      }
      default:
        this.errors.push(new Qc(tm(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = !1, r = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (e) {
      const n = Object.assign({ _directives: this.directives }, this.options), i = new up(void 0, n);
      this.atDirectives && this.onError(r, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, r, r], this.decorate(i, !1), yield i;
    }
  }
}
function Wde(t, e = !0, r) {
  if (t) {
    const n = (i, o, s) => {
      const a = typeof i == "number" ? i : Array.isArray(i) ? i[0] : i.offset;
      if (r)
        r(a, o, s);
      else
        throw new Qc([a, a + 1], o, s);
    };
    switch (t.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return kI(t, e, n);
      case "block-scalar":
        return wI({ options: { strict: e } }, t, n);
    }
  }
  return null;
}
function Gde(t, e) {
  const { implicitKey: r = !1, indent: n, inFlow: i = !1, offset: o = -1, type: s = "PLAIN" } = e, a = h0({ type: s, value: t }, {
    implicitKey: r,
    indent: n > 0 ? " ".repeat(n) : "",
    inFlow: i,
    options: { blockQuote: !0, lineWidth: -1 }
  }), l = e.end ?? [
    { type: "newline", offset: -1, indent: n, source: `
` }
  ];
  switch (a[0]) {
    case "|":
    case ">": {
      const u = a.indexOf(`
`), c = a.substring(0, u), h = a.substring(u + 1) + `
`, d = [
        { type: "block-scalar-header", offset: o, indent: n, source: c }
      ];
      return AI(d, l) || d.push({ type: "newline", offset: -1, indent: n, source: `
` }), { type: "block-scalar", offset: o, indent: n, props: d, source: h };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: o, indent: n, source: a, end: l };
    case "'":
      return { type: "single-quoted-scalar", offset: o, indent: n, source: a, end: l };
    default:
      return { type: "scalar", offset: o, indent: n, source: a, end: l };
  }
}
function Kde(t, e, r = {}) {
  let { afterKey: n = !1, implicitKey: i = !1, inFlow: o = !1, type: s } = r, a = "indent" in t ? t.indent : null;
  if (n && typeof a == "number" && (a += 2), !s)
    switch (t.type) {
      case "single-quoted-scalar":
        s = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        s = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const u = t.props[0];
        if (u.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        s = u.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        s = "PLAIN";
    }
  const l = h0({ type: s, value: e }, {
    implicitKey: i || a === null,
    indent: a !== null && a > 0 ? " ".repeat(a) : "",
    inFlow: o,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (l[0]) {
    case "|":
    case ">":
      Qde(t, l);
      break;
    case '"':
      vk(t, l, "double-quoted-scalar");
      break;
    case "'":
      vk(t, l, "single-quoted-scalar");
      break;
    default:
      vk(t, l, "scalar");
  }
}
function Qde(t, e) {
  const r = e.indexOf(`
`), n = e.substring(0, r), i = e.substring(r + 1) + `
`;
  if (t.type === "block-scalar") {
    const o = t.props[0];
    if (o.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    o.source = n, t.source = i;
  } else {
    const { offset: o } = t, s = "indent" in t ? t.indent : -1, a = [
      { type: "block-scalar-header", offset: o, indent: s, source: n }
    ];
    AI(a, "end" in t ? t.end : void 0) || a.push({ type: "newline", offset: -1, indent: s, source: `
` });
    for (const l of Object.keys(t))
      l !== "type" && l !== "offset" && delete t[l];
    Object.assign(t, { type: "block-scalar", indent: s, props: a, source: i });
  }
}
function AI(t, e) {
  if (e)
    for (const r of e)
      switch (r.type) {
        case "space":
        case "comment":
          t.push(r);
          break;
        case "newline":
          return t.push(r), !0;
      }
  return !1;
}
function vk(t, e, r) {
  switch (t.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      t.type = r, t.source = e;
      break;
    case "block-scalar": {
      const n = t.props.slice(1);
      let i = e.length;
      t.props[0].type === "block-scalar-header" && (i -= t.props[0].source.length);
      for (const o of n)
        o.offset += i;
      delete t.props, Object.assign(t, { type: r, source: e, end: n });
      break;
    }
    case "block-map":
    case "block-seq": {
      const n = { type: "newline", offset: t.offset + e.length, indent: t.indent, source: `
` };
      delete t.items, Object.assign(t, { type: r, source: e, end: [n] });
      break;
    }
    default: {
      const n = "indent" in t ? t.indent : -1, i = "end" in t && Array.isArray(t.end) ? t.end.filter((o) => o.type === "space" || o.type === "comment" || o.type === "newline") : [];
      for (const o of Object.keys(t))
        o !== "type" && o !== "offset" && delete t[o];
      Object.assign(t, { type: r, indent: n, source: e, end: i });
    }
  }
}
const Xde = (t) => "type" in t ? Z1(t) : Ky(t);
function Z1(t) {
  switch (t.type) {
    case "block-scalar": {
      let e = "";
      for (const r of t.props)
        e += Z1(r);
      return e + t.source;
    }
    case "block-map":
    case "block-seq": {
      let e = "";
      for (const r of t.items)
        e += Ky(r);
      return e;
    }
    case "flow-collection": {
      let e = t.start.source;
      for (const r of t.items)
        e += Ky(r);
      for (const r of t.end)
        e += r.source;
      return e;
    }
    case "document": {
      let e = Ky(t);
      if (t.end)
        for (const r of t.end)
          e += r.source;
      return e;
    }
    default: {
      let e = t.source;
      if ("end" in t && t.end)
        for (const r of t.end)
          e += r.source;
      return e;
    }
  }
}
function Ky({ start: t, key: e, sep: r, value: n }) {
  let i = "";
  for (const o of t)
    i += o.source;
  if (e && (i += Z1(e)), r)
    for (const o of r)
      i += o.source;
  return n && (i += Z1(n)), i;
}
const GC = Symbol("break visit"), Jde = Symbol("skip children"), EI = Symbol("remove item");
function _h(t, e) {
  "type" in t && t.type === "document" && (t = { start: t.start, value: t.value }), DI(Object.freeze([]), t, e);
}
_h.BREAK = GC;
_h.SKIP = Jde;
_h.REMOVE = EI;
_h.itemAtPath = (t, e) => {
  let r = t;
  for (const [n, i] of e) {
    const o = r?.[n];
    if (o && "items" in o)
      r = o.items[i];
    else
      return;
  }
  return r;
};
_h.parentCollection = (t, e) => {
  const r = _h.itemAtPath(t, e.slice(0, -1)), n = e[e.length - 1][0], i = r?.[n];
  if (i && "items" in i)
    return i;
  throw new Error("Parent collection not found");
};
function DI(t, e, r) {
  let n = r(e, t);
  if (typeof n == "symbol")
    return n;
  for (const i of ["key", "value"]) {
    const o = e[i];
    if (o && "items" in o) {
      for (let s = 0; s < o.items.length; ++s) {
        const a = DI(Object.freeze(t.concat([[i, s]])), o.items[s], r);
        if (typeof a == "number")
          s = a - 1;
        else {
          if (a === GC)
            return GC;
          a === EI && (o.items.splice(s, 1), s -= 1);
        }
      }
      typeof n == "function" && i === "key" && (n = n(e, t));
    }
  }
  return typeof n == "function" ? n(e, t) : n;
}
const fx = "\uFEFF", dx = "", px = "", Eg = "", Yde = (t) => !!t && "items" in t, Zde = (t) => !!t && (t.type === "scalar" || t.type === "single-quoted-scalar" || t.type === "double-quoted-scalar" || t.type === "block-scalar");
function epe(t) {
  switch (t) {
    case fx:
      return "<BOM>";
    case dx:
      return "<DOC>";
    case px:
      return "<FLOW_END>";
    case Eg:
      return "<SCALAR>";
    default:
      return JSON.stringify(t);
  }
}
function OI(t) {
  switch (t) {
    case fx:
      return "byte-order-mark";
    case dx:
      return "doc-mode";
    case px:
      return "flow-error-end";
    case Eg:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (t[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const tpe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: fx,
  DOCUMENT: dx,
  FLOW_END: px,
  SCALAR: Eg,
  createScalarToken: Gde,
  isCollection: Yde,
  isScalar: Zde,
  prettyToken: epe,
  resolveAsScalar: Wde,
  setScalarValue: Kde,
  stringify: Xde,
  tokenType: OI,
  visit: _h
}, Symbol.toStringTag, { value: "Module" }));
function Ps(t) {
  switch (t) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const o9 = new Set("0123456789ABCDEFabcdef"), rpe = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), ay = new Set(",[]{}"), npe = new Set(` ,[]{}
\r	`), yk = (t) => !t || npe.has(t);
class FI {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, r = !1) {
    if (e) {
      if (typeof e != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null;
    }
    this.atEnd = !r;
    let n = this.next ?? "stream";
    for (; n && (r || this.hasChars(1)); )
      n = yield* this.parseNext(n);
  }
  atLineEnd() {
    let e = this.pos, r = this.buffer[e];
    for (; r === " " || r === "	"; )
      r = this.buffer[++e];
    return !r || r === "#" || r === `
` ? !0 : r === "\r" ? this.buffer[e + 1] === `
` : !1;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let r = this.buffer[e];
    if (this.indentNext > 0) {
      let n = 0;
      for (; r === " "; )
        r = this.buffer[++n + e];
      if (r === "\r") {
        const i = this.buffer[n + e + 1];
        if (i === `
` || !i && !this.atEnd)
          return e + n + 1;
      }
      return r === `
` || n >= this.indentNext || !r && !this.atEnd ? e + n : -1;
    }
    if (r === "-" || r === ".") {
      const n = this.buffer.substr(e, 3);
      if ((n === "---" || n === "...") && Ps(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === fx && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let r = e.length, n = e.indexOf("#");
      for (; n !== -1; ) {
        const o = e[n - 1];
        if (o === " " || o === "	") {
          r = n - 1;
          break;
        } else
          n = e.indexOf("#", n + 1);
      }
      for (; ; ) {
        const o = e[r - 1];
        if (o === " " || o === "	")
          r -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(r)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(e.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const r = yield* this.pushSpaces(!0);
      return yield* this.pushCount(e.length - r), yield* this.pushNewline(), "stream";
    }
    return yield dx, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const r = this.peek(3);
      if ((r === "---" || r === "...") && Ps(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, r === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !Ps(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, r] = this.peek(2);
    if (!r && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && Ps(r)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let r = yield* this.pushIndicators();
    switch (e[r]) {
      case "#":
        yield* this.pushCount(e.length - r);
      // fallthrough
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(yk), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return r += yield* this.parseBlockScalarHeader(), r += yield* this.pushSpaces(!0), yield* this.pushCount(e.length - r), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, r, n = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (r = yield* this.pushSpaces(!1), this.indentValue = n = r) : r = 0, r += yield* this.pushSpaces(!0);
    while (e + r > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((n !== -1 && n < this.indentNext && i[0] !== "#" || n === 0 && (i.startsWith("---") || i.startsWith("...")) && Ps(i[3])) && !(n === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield px, yield* this.parseLineStart();
    let o = 0;
    for (; i[o] === ","; )
      o += yield* this.pushCount(1), o += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (o += yield* this.pushIndicators(), i[o]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - o), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(yk), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const s = this.charAt(1);
        if (this.flowKey || Ps(s) || s === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      // fallthrough
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let r = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; r !== -1 && this.buffer[r + 1] === "'"; )
        r = this.buffer.indexOf("'", r + 2);
    else
      for (; r !== -1; ) {
        let o = 0;
        for (; this.buffer[r - 1 - o] === "\\"; )
          o += 1;
        if (o % 2 === 0)
          break;
        r = this.buffer.indexOf('"', r + 1);
      }
    const n = this.buffer.substring(0, r);
    let i = n.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const o = this.continueScalar(i + 1);
        if (o === -1)
          break;
        i = n.indexOf(`
`, o);
      }
      i !== -1 && (r = i - (n[i - 1] === "\r" ? 2 : 1));
    }
    if (r === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      r = this.buffer.length;
    }
    return yield* this.pushToIndex(r + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let e = this.pos;
    for (; ; ) {
      const r = this.buffer[++e];
      if (r === "+")
        this.blockScalarKeep = !0;
      else if (r > "0" && r <= "9")
        this.blockScalarIndent = Number(r) - 1;
      else if (r !== "-")
        break;
    }
    return yield* this.pushUntil((r) => Ps(r) || r === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, r = 0, n;
    e: for (let o = this.pos; n = this.buffer[o]; ++o)
      switch (n) {
        case " ":
          r += 1;
          break;
        case `
`:
          e = o, r = 0;
          break;
        case "\r": {
          const s = this.buffer[o + 1];
          if (!s && !this.atEnd)
            return this.setNext("block-scalar");
          if (s === `
`)
            break;
        }
        // fallthrough
        default:
          break e;
      }
    if (!n && !this.atEnd)
      return this.setNext("block-scalar");
    if (r >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = r : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const o = this.continueScalar(e + 1);
        if (o === -1)
          break;
        e = this.buffer.indexOf(`
`, o);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    let i = e + 1;
    for (n = this.buffer[i]; n === " "; )
      n = this.buffer[++i];
    if (n === "	") {
      for (; n === "	" || n === " " || n === "\r" || n === `
`; )
        n = this.buffer[++i];
      e = i - 1;
    } else if (!this.blockScalarKeep)
      do {
        let o = e - 1, s = this.buffer[o];
        s === "\r" && (s = this.buffer[--o]);
        const a = o;
        for (; s === " "; )
          s = this.buffer[--o];
        if (s === `
` && o >= this.pos && o + 1 + r > a)
          e = o;
        else
          break;
      } while (!0);
    return yield Eg, yield* this.pushToIndex(e + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let r = this.pos - 1, n = this.pos - 1, i;
    for (; i = this.buffer[++n]; )
      if (i === ":") {
        const o = this.buffer[n + 1];
        if (Ps(o) || e && ay.has(o))
          break;
        r = n;
      } else if (Ps(i)) {
        let o = this.buffer[n + 1];
        if (i === "\r" && (o === `
` ? (n += 1, i = `
`, o = this.buffer[n + 1]) : r = n), o === "#" || e && ay.has(o))
          break;
        if (i === `
`) {
          const s = this.continueScalar(n + 1);
          if (s === -1)
            break;
          n = Math.max(n, s - 2);
        }
      } else {
        if (e && ay.has(i))
          break;
        r = n;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield Eg, yield* this.pushToIndex(r + 1, !0), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, r) {
    const n = this.buffer.slice(this.pos, e);
    return n ? (yield n, this.pos += n.length, n.length) : (r && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(yk)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const e = this.flowLevel > 0, r = this.charAt(1);
        if (Ps(r) || e && ay.has(r))
          return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, r = this.buffer[e];
      for (; !Ps(r) && r !== ">"; )
        r = this.buffer[++e];
      return yield* this.pushToIndex(r === ">" ? e + 1 : e, !1);
    } else {
      let e = this.pos + 1, r = this.buffer[e];
      for (; r; )
        if (rpe.has(r))
          r = this.buffer[++e];
        else if (r === "%" && o9.has(this.buffer[e + 1]) && o9.has(this.buffer[e + 2]))
          r = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, !1);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let r = this.pos - 1, n;
    do
      n = this.buffer[++r];
    while (n === " " || e && n === "	");
    const i = r - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = r), i;
  }
  *pushUntil(e) {
    let r = this.pos, n = this.buffer[r];
    for (; !e(n); )
      n = this.buffer[++r];
    return yield* this.pushToIndex(r, !1);
  }
}
class TI {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let r = 0, n = this.lineStarts.length;
      for (; r < n; ) {
        const o = r + n >> 1;
        this.lineStarts[o] < e ? r = o + 1 : n = o;
      }
      if (this.lineStarts[r] === e)
        return { line: r + 1, col: 1 };
      if (r === 0)
        return { line: 0, col: e };
      const i = this.lineStarts[r - 1];
      return { line: r, col: e - i + 1 };
    };
  }
}
function Du(t, e) {
  for (let r = 0; r < t.length; ++r)
    if (t[r].type === e)
      return !0;
  return !1;
}
function s9(t) {
  for (let e = 0; e < t.length; ++e)
    switch (t[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function MI(t) {
  switch (t?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function ly(t) {
  switch (t.type) {
    case "document":
      return t.start;
    case "block-map": {
      const e = t.items[t.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return t.items[t.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function xf(t) {
  if (t.length === 0)
    return [];
  let e = t.length;
  e: for (; --e >= 0; )
    switch (t[e].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; t[++e]?.type === "space"; )
    ;
  return t.splice(e, t.length);
}
function a9(t) {
  if (t.start.type === "flow-seq-start")
    for (const e of t.items)
      e.sep && !e.value && !Du(e.start, "explicit-key-ind") && !Du(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, MI(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
class SS {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new FI(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, r = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const n of this.lexer.lex(e, r))
      yield* this.next(n);
    r || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += e.length;
      return;
    }
    const r = OI(e);
    if (r)
      if (r === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = r, yield* this.step(), r) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += e.length;
      }
    else {
      const n = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: n, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const r = e ?? this.stack.pop();
    if (!r)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield r;
    else {
      const n = this.peek(1);
      switch (r.type === "block-scalar" ? r.indent = "indent" in n ? n.indent : 0 : r.type === "flow-collection" && n.type === "document" && (r.indent = 0), r.type === "flow-collection" && a9(r), n.type) {
        case "document":
          n.value = r;
          break;
        case "block-scalar":
          n.props.push(r);
          break;
        case "block-map": {
          const i = n.items[n.items.length - 1];
          if (i.value) {
            n.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (i.sep)
            i.value = r;
          else {
            Object.assign(i, { key: r, sep: [] }), this.onKeyLine = !i.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const i = n.items[n.items.length - 1];
          i.value ? n.items.push({ start: [], value: r }) : i.value = r;
          break;
        }
        case "flow-collection": {
          const i = n.items[n.items.length - 1];
          !i || i.value ? n.items.push({ start: [], key: r, sep: [] }) : i.sep ? i.value = r : Object.assign(i, { key: r, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop(), yield* this.pop(r);
      }
      if ((n.type === "document" || n.type === "block-map" || n.type === "block-seq") && (r.type === "block-map" || r.type === "block-seq")) {
        const i = r.items[r.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && s9(i.start) === -1 && (r.indent === 0 || i.start.every((o) => o.type !== "comment" || o.indent < r.indent)) && (n.type === "document" ? n.end = i.start : n.items.push({ start: i.start }), r.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        s9(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const r = this.startBlockValue(e);
    r ? this.stack.push(r) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const r = ly(this.peek(2)), n = xf(r);
      let i;
      e.end ? (i = e.end, i.push(this.sourceToken), delete e.end) : i = [this.sourceToken];
      const o = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: n, key: e, sep: i }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = o;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let r = this.source.indexOf(`
`) + 1;
          for (; r !== 0; )
            this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          (Array.isArray(n) ? n[n.length - 1] : void 0)?.type === "comment" ? n?.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else if (r.sep)
          r.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = e.items[e.items.length - 2]?.value?.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const n = !this.onKeyLine && this.indent === e.indent, i = n && (r.sep || r.explicitKey) && this.type !== "seq-item-ind";
      let o = [];
      if (i && r.sep && !r.value) {
        const s = [];
        for (let a = 0; a < r.sep.length; ++a) {
          const l = r.sep[a];
          switch (l.type) {
            case "newline":
              s.push(a);
              break;
            case "space":
              break;
            case "comment":
              l.indent > e.indent && (s.length = 0);
              break;
            default:
              s.length = 0;
          }
        }
        s.length >= 2 && (o = r.sep.splice(s[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || r.value ? (o.push(this.sourceToken), e.items.push({ start: o }), this.onKeyLine = !0) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !r.sep && !r.explicitKey ? (r.start.push(this.sourceToken), r.explicitKey = !0) : i || r.value ? (o.push(this.sourceToken), e.items.push({ start: o, explicitKey: !0 })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: !0 }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (r.explicitKey)
            if (r.sep)
              if (r.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Du(r.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: null, sep: [this.sourceToken] }]
                });
              else if (MI(r.key) && !Du(r.sep, "newline")) {
                const s = xf(r.start), a = r.key, l = r.sep;
                l.push(this.sourceToken), delete r.key, delete r.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: a, sep: l }]
                });
              } else o.length > 0 ? r.sep = r.sep.concat(o, this.sourceToken) : r.sep.push(this.sourceToken);
            else if (Du(r.start, "newline"))
              Object.assign(r, { key: null, sep: [this.sourceToken] });
            else {
              const s = xf(r.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: s, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            r.sep ? r.value || i ? e.items.push({ start: o, key: null, sep: [this.sourceToken] }) : Du(r.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const s = this.flowScalar(this.type);
          i || r.value ? (e.items.push({ start: o, key: s, sep: [] }), this.onKeyLine = !0) : r.sep ? this.stack.push(s) : (Object.assign(r, { key: s, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const s = this.startBlockValue(e);
          if (s) {
            if (s.type === "block-seq") {
              if (!r.explicitKey && r.sep && !Du(r.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else n && e.items.push({ start: o });
            this.stack.push(s);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          (Array.isArray(n) ? n[n.length - 1] : void 0)?.type === "comment" ? n?.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = e.items[e.items.length - 2]?.value?.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (r.value || this.indent <= e.indent)
          break;
        r.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        r.value || Du(r.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const n = this.startBlockValue(e);
      if (n) {
        this.stack.push(n);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const r = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let n;
      do
        yield* this.pop(), n = this.peek(1);
      while (n && n.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !r || r.sep ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !r || r.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !r || r.value ? e.items.push({ start: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !r || r.value ? e.items.push({ start: [], key: i, sep: [] }) : r.sep ? this.stack.push(i) : Object.assign(r, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const n = this.startBlockValue(e);
      n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
    } else {
      const n = this.peek(2);
      if (n.type === "block-map" && (this.type === "map-value-ind" && n.indent === e.indent || this.type === "newline" && !n.items[n.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && n.type !== "flow-collection") {
        const i = ly(n), o = xf(i);
        a9(e);
        const s = e.end.splice(1, e.end.length);
        s.push(this.sourceToken);
        const a = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: o, key: e, sep: s }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = a;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let r = this.source.indexOf(`
`) + 1;
      for (; r !== 0; )
        this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const r = ly(e), n = xf(r);
        return n.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, explicitKey: !0 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const r = ly(e), n = xf(r);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, r) {
    return this.type !== "comment" || this.indent <= r ? !1 : e.every((n) => n.type === "newline" || n.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      // fallthrough
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function PI(t) {
  const e = t.prettyErrors !== !1;
  return { lineCounter: t.lineCounter || e && new TI() || null, prettyErrors: e };
}
function ipe(t, e = {}) {
  const { lineCounter: r, prettyErrors: n } = PI(e), i = new SS(r?.addNewLine), o = new _S(e), s = Array.from(o.compose(i.parse(t)));
  if (n && r)
    for (const a of s)
      a.errors.forEach(Y1(t, r)), a.warnings.forEach(Y1(t, r));
  return s.length > 0 ? s : Object.assign([], { empty: !0 }, o.streamInfo());
}
function RI(t, e = {}) {
  const { lineCounter: r, prettyErrors: n } = PI(e), i = new SS(r?.addNewLine), o = new _S(e);
  let s = null;
  for (const a of o.compose(i.parse(t), !0, t.length))
    if (!s)
      s = a;
    else if (s.options.logLevel !== "silent") {
      s.errors.push(new Qc(a.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return n && r && (s.errors.forEach(Y1(t, r)), s.warnings.forEach(Y1(t, r))), s;
}
function ope(t, e, r) {
  let n;
  typeof e == "function" ? n = e : r === void 0 && e && typeof e == "object" && (r = e);
  const i = RI(t, r);
  if (!i)
    return null;
  if (i.warnings.forEach((o) => eI(i.options.logLevel, o)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: n }, r));
}
function spe(t, e, r) {
  let n = null;
  if (typeof e == "function" || Array.isArray(e) ? n = e : r === void 0 && e && (r = e), typeof r == "string" && (r = r.length), typeof r == "number") {
    const i = Math.round(r);
    r = i < 1 ? void 0 : i > 8 ? { indent: 8 } : { indent: i };
  }
  if (t === void 0) {
    const { keepUndefined: i } = r ?? e ?? {};
    if (!i)
      return;
  }
  return jh(t) && !n ? t.toString(r) : new up(t, n, r).toString(r);
}
const ape = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: rx,
  CST: tpe,
  Composer: _S,
  Document: up,
  Lexer: FI,
  LineCounter: TI,
  Pair: hi,
  Parser: SS,
  Scalar: yt,
  Schema: hx,
  YAMLError: kS,
  YAMLMap: $o,
  YAMLParseError: Qc,
  YAMLSeq: cc,
  YAMLWarning: bI,
  isAlias: gc,
  isCollection: Qr,
  isDocument: jh,
  isMap: op,
  isNode: Xr,
  isPair: Vr,
  isScalar: Or,
  isSeq: sp,
  parse: ope,
  parseAllDocuments: ipe,
  parseDocument: RI,
  stringify: spe,
  visit: qh,
  visitAsync: tx
}, Symbol.toStringTag, { value: "Module" }));
function lpe(t) {
  let e = null;
  try {
    e = ape.parse(t.doc.toString());
  } catch {
  }
  const r = B4(t, qr.YAML);
  return { data: e, pointers: r };
}
const NI = (t) => {
  switch (t) {
    case qr.JSON:
      return Lfe;
    case qr.JSON5:
      return Yfe;
    case qr.YAML:
      return lpe;
  }
};
function upe(t) {
  return Object.entries(t);
}
function bm(t, e) {
  if (typeof t == "string" || typeof t != "object" || t === null)
    return t;
  if (Array.isArray(t))
    return t.map((i) => bm(i, e));
  if (t instanceof Map) {
    const i = /* @__PURE__ */ new Map();
    for (const [o, s] of t) {
      const a = o, l = bm(s, e);
      i.set(a, l);
    }
    return i;
  }
  if (t instanceof Set) {
    const i = /* @__PURE__ */ new Set();
    for (const o of t) {
      const s = bm(o, e);
      i.add(s);
    }
    return i;
  }
  const r = {};
  function n(i, o, s, a) {
    s === i && a === o ? r[s] = bm(o, e) : r[s] = a;
  }
  for (const [i, o] of upe(t)) {
    const s = e(i, o);
    if (s.length === 2 && typeof s[0] == "string")
      n(i, o, s[0], s[1]);
    else
      for (const [a, l] of s)
        n(i, o, a, l);
  }
  return r;
}
var cpe = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
};
class hpe {
  constructor() {
    this.completions = /* @__PURE__ */ new Map(), this.reservedKeys = /* @__PURE__ */ new Set();
  }
  reserve(e) {
    this.reservedKeys.add(e);
  }
  add(e) {
    this.reservedKeys.has(e.label) || this.completions.set(e.label, e);
  }
}
function Nm(t) {
  return !(!t || gi(t) || t.name === "UnknownPropertyError" || t.type === "undefined");
}
class fpe {
  // private lastKnownValidData: object | null = null;
  constructor(e) {
    var r, n, i;
    this.opts = e, this.originalSchema = null, this.schema = null, this.laxSchema = null, this.mode = qr.JSON, this.mode = (r = e.mode) !== null && r !== void 0 ? r : qr.JSON, this.parser = (i = (n = this.opts) === null || n === void 0 ? void 0 : n.jsonParser) !== null && i !== void 0 ? i : NI(this.mode);
  }
  doComplete(e) {
    var r;
    const n = L4(e.state);
    if (this.originalSchema !== n && (this.schema = (r = Ic(n, n)) !== null && r !== void 0 ? r : n, this.laxSchema = ppe(this.schema)), !this.schema || !this.laxSchema)
      return [];
    Gr.log("xxx", "trying with original schema");
    const i = this.doCompleteForSchema(e, this.schema);
    return i.options.length !== 0 ? i : (Gr.log("xxx", "no completions with original schema, trying with lax schema"), this.doCompleteForSchema(e, this.laxSchema));
  }
  doCompleteForSchema(e, r) {
    var n, i;
    const o = {
      from: e.pos,
      to: e.pos,
      options: [],
      filter: !1
      // will be handled manually
    }, s = e.state.doc.sliceString(0);
    let a = H2(e.state, e.pos), l = e.state.sliceDoc(a.from, e.pos).replace(/^(["'])/, "");
    if (Gr.log("xxx", "node", a, "prefix", l, "ctx", e), !(jy(a, this.mode) || Wv(a, this.mode)) && !e.explicit)
      return Gr.log("xxx", "no completions for non-word/primitive", a), o;
    const u = Ef(e.state.doc, a), c = Ef(e.state.doc, a, !1);
    if (a && (jy(a, this.mode) || Wv(a, this.mode)))
      o.from = a.from, o.to = a.to;
    else {
      const g = e.matchBefore(/[A-Za-z0-9._]*/), v = e.pos - u.length;
      Gr.log("xxx", "overwriteStart after", v, "ctx.pos", e.pos, "word", g, "currentWord", u, "=>", s[v - 1], "..", s[v], "..", s), o.from = a.name === wt.INVALID ? (n = g?.from) !== null && n !== void 0 ? n : e.pos : v, o.to = e.pos;
    }
    const h = new hpe();
    let d = !0;
    const p = M8(a, wt.PROPERTY_NAME, this.mode);
    if (p && (Gr.log("xxx", "closestPropertyNameNode", p, "node", a), a = p), Wv(a, this.mode)) {
      Gr.log("xxx", "isPropertyNameNode", a);
      const g = a.parent;
      if (g) {
        const v = T8(g, this.mode);
        d = !v || v.name === wt.INVALID && v.from - v.to === 0 || // TODO: Verify this doesn't break anything else
        (v.parent ? n0(v.parent).length <= 1 : !1), Gr.log("xxx", "addValue", d, T8(g, this.mode), a), a = (i = M8(g, wt.OBJECT, this.mode)) !== null && i !== void 0 ? i : null;
      }
    }
    if (Gr.log("xxx", a, u, e, "node at pos", H2(e.state, e.pos)), a && [wt.OBJECT, wt.JSON_TEXT].includes(dn(a.name, this.mode)) && (Wv(H2(e.state, e.pos), this.mode) || p)) {
      if (a.from === e.pos)
        return Gr.log("xxx", "no completions for just before opening brace"), o;
      this.getPropertyCompletions(r, e, a, h, d, c);
    } else {
      const g = {}, v = this.getValueCompletions(r, e, g, h);
      Gr.log("xxx", "getValueCompletions res", v);
    }
    return o.options = Array.from(h.completions.values()).filter((g) => zy(g.label).startsWith(l)), Gr.log("xxx", "result", o, "prefix", l, "collector.completions", h.completions, "reservedKeys", h.reservedKeys), o;
  }
  applySnippetCompletion(e) {
    return jee(typeof e.apply != "string" ? e.label : e.apply, e);
  }
  getPropertyCompletions(e, r, n, i, o, s) {
    const a = bie(n, wt.PROPERTY, this.mode);
    Gr.log("xxx", "getPropertyCompletions", n, r, a), a.forEach((u) => {
      const c = Ef(r.state.doc, yC(u, wt.PROPERTY_NAME, this.mode));
      i.reserve(zy(c));
    });
    const l = this.getSchemas(e, r);
    Gr.log("xxx", "propertyCompletion schemas", l), l.forEach((u) => {
      if (typeof u != "object")
        return;
      const c = u.properties;
      c && Object.entries(c).forEach(([d, p]) => {
        var g, v;
        if (typeof p == "object") {
          const y = (g = p.description) !== null && g !== void 0 ? g : "", b = (v = p.type) !== null && v !== void 0 ? v : "", k = Array.isArray(b) ? b.toString() : b, C = {
            // label is the unquoted key which will be displayed.
            label: d,
            apply: this.getInsertTextForProperty(d, o, s, e, p),
            type: "property",
            detail: k,
            info: () => Ca("div", {
              inner: Zf(y)
            })
          };
          i.add(this.applySnippetCompletion(C));
        }
      });
      const h = u.propertyNames;
      if (typeof h == "object" && (h.enum && h.enum.forEach((d) => {
        const p = d?.toString();
        if (p) {
          const g = {
            label: p,
            apply: this.getInsertTextForProperty(p, o, s, e),
            type: "property"
          };
          i.add(this.applySnippetCompletion(g));
        }
      }), h.const)) {
        const d = h.const.toString(), p = {
          label: d,
          apply: this.getInsertTextForProperty(d, o, s, e),
          type: "property"
        };
        i.add(this.applySnippetCompletion(p));
      }
    });
  }
  // apply is the quoted key which will be applied.
  // Normally the label needs to match the token
  // prefix i.e. if the token begins with `"to`, then the
  // label needs to have the quotes as well for it to match.
  // However we are manually filtering the results so we can
  // just use the unquoted key as the label, which is nicer
  // and gives us more control.
  // If no property value is present, then we add the colon as well.
  // Use snippetCompletion to handle insert value + position cursor e.g. "key": "#{}"
  // doc: https://codemirror.net/docs/ref/#autocomplete.snippetCompletion
  // idea: https://discuss.codemirror.net/t/autocomplete-cursor-position-in-apply-function/4088/3
  getInsertTextForProperty(e, r, n, i, o) {
    o = o && Ic(o, i);
    let s = this.getInsertTextForPropertyName(e, n);
    if (!r)
      return s;
    s += ": ";
    let a, l = 0;
    if (typeof o == "object") {
      if (typeof o.default < "u")
        a || (a = this.getInsertTextForGuessedValue(o.default, "")), l++;
      else if (o.enum && (!a && o.enum.length === 1 && (a = this.getInsertTextForGuessedValue(o.enum[0], "")), l += o.enum.length), typeof o.const < "u" && (a || (a = this.getInsertTextForGuessedValue(o.const, "")), l++), Array.isArray(o.examples) && o.examples.length && (a || (a = this.getInsertTextForGuessedValue(o.examples[0], "")), l += o.examples.length), a === void 0 && l === 0) {
        let u = Array.isArray(o.type) ? o.type[0] : o.type;
        switch (u || (o.properties ? u = "object" : o.items && (u = "array")), u) {
          case "boolean":
            a = "#{}";
            break;
          case "string":
            a = this.getInsertTextForString("");
            break;
          case "object":
            switch (this.mode) {
              case qr.JSON5:
                a = "{#{}}";
                break;
              case qr.YAML:
                a = "#{}";
                break;
              default:
                a = "{#{}}";
                break;
            }
            break;
          case "array":
            a = "[#{}]";
            break;
          case "number":
          case "integer":
            a = "#{0}";
            break;
          case "null":
            a = "#{null}";
            break;
          default:
            a = "#{}";
            break;
        }
      }
    }
    return (!a || l > 1) && (Gr.log("xxx", "value", a, "nValueProposals", l, o), a = "#{}"), s + a;
  }
  getInsertTextForPropertyName(e, r) {
    switch (this.mode) {
      case qr.JSON5:
      case qr.YAML:
        return r.startsWith('"') ? `"${e}"` : r.startsWith("'") ? `'${e}'` : e;
      default:
        return `"${e}"`;
    }
  }
  getInsertTextForString(e, r = "#") {
    switch (this.mode) {
      case qr.JSON5:
        return `'${r}{${e}}'`;
      case qr.YAML:
        return `${r}{${e}}`;
      default:
        return `"${r}{${e}}"`;
    }
  }
  // TODO: Is this actually working?
  getInsertTextForGuessedValue(e, r = "") {
    switch (typeof e) {
      case "object":
        return e === null ? "${null}" + r : this.getInsertTextForValue(e, r);
      case "string": {
        let n = JSON.stringify(e);
        return n = n.substr(1, n.length - 2), n = this.getInsertTextForPlainText(n), this.getInsertTextForString(n, "$") + r;
      }
      case "number":
      case "boolean":
        return "${" + JSON.stringify(e) + "}" + r;
    }
    return this.getInsertTextForValue(e, r);
  }
  getInsertTextForPlainText(e) {
    return e.replace(/[\\$}]/g, "\\$&");
  }
  getInsertTextForValue(e, r) {
    const n = JSON.stringify(e, null, "	");
    return n === "{}" ? "{#{}}" + r : n === "[]" ? "[#{}]" + r : this.getInsertTextForPlainText(n + r);
  }
  getValueCompletions(e, r, n, i) {
    let o = Dn(r.state).resolveInner(r.pos, -1), s = null, a;
    if (Gr.log("xxx", "getValueCompletions", o, r), o && jy(o, this.mode) && (s = o, o = o.parent), !o) {
      this.addSchemaValueCompletions(e, n, i);
      return;
    }
    if (dn(o.name, this.mode) === wt.PROPERTY) {
      const l = yC(o, wt.PROPERTY_NAME, this.mode);
      l && (a = Ef(r.state.doc, l), o = o.parent);
    }
    if (Gr.log("xxx", "node", o, "parentKey", a), o && (a !== void 0 || dn(o.name, this.mode) === wt.ARRAY)) {
      const l = this.getSchemas(e, r);
      for (const u of l) {
        if (typeof u != "object")
          return;
        if (dn(o.name, this.mode) === wt.ARRAY && u.items) {
          let c = i;
          if (u.uniqueItems && (c = Object.assign(Object.assign({}, c), {
            add(h) {
              c.completions.has(h.label) || i.add(h);
            },
            reserve(h) {
              i.reserve(h);
            }
          })), Array.isArray(u.items)) {
            let h = 0;
            if (s) {
              const p = UR(o, s, this.mode);
              p >= 0 && (h = p);
            }
            const d = u.items[h];
            d && this.addSchemaValueCompletions(d, n, c);
          } else
            this.addSchemaValueCompletions(u.items, n, c);
        }
        if ((u.type == null || u.type !== "object") && this.addSchemaValueCompletions(u, n, i), a !== void 0) {
          let c = !1;
          if (u.properties) {
            const h = u.properties[a];
            h && (c = !0, this.addSchemaValueCompletions(h, n, i));
          }
          if (u.patternProperties && !c) {
            for (const h of Object.keys(u.patternProperties))
              if (this.extendedRegExp(h)?.test(a)) {
                c = !0;
                const p = u.patternProperties[h];
                p && this.addSchemaValueCompletions(p, n, i);
              }
          }
          if (u.additionalProperties && !c) {
            const h = u.additionalProperties;
            this.addSchemaValueCompletions(h, n, i);
          }
        }
        n.boolean && (this.addBooleanValueCompletion(!0, i), this.addBooleanValueCompletion(!1, i)), n.null && this.addNullValueCompletion(i);
      }
    }
    return {
      valuePrefix: s ? Ef(r.state.doc, s, !0, !1) : ""
    };
  }
  addSchemaValueCompletions(e, r, n) {
    typeof e == "object" && (this.addEnumValueCompletions(e, n), this.addDefaultValueCompletions(e, n), this.collectTypes(e, r), Array.isArray(e.allOf) && e.allOf.forEach((i) => this.addSchemaValueCompletions(i, r, n)), Array.isArray(e.anyOf) && e.anyOf.forEach((i) => this.addSchemaValueCompletions(i, r, n)), Array.isArray(e.oneOf) && e.oneOf.forEach((i) => this.addSchemaValueCompletions(i, r, n)));
  }
  addDefaultValueCompletions(e, r, n = 0) {
    let i = !1;
    if (typeof e.default < "u") {
      let o = e.type, s = e.default;
      for (let l = n; l > 0; l--)
        s = [s], o = "array";
      const a = Object.assign(Object.assign({ type: o?.toString() }, this.getAppliedValue(s)), { detail: "Default value" });
      r.add(a), i = !0;
    }
    Array.isArray(e.examples) && e.examples.forEach((o) => {
      let s = e.type, a = o;
      for (let l = n; l > 0; l--)
        a = [a], s = "array";
      r.add(Object.assign({ type: s?.toString() }, this.getAppliedValue(a))), i = !0;
    }), !i && typeof e.items == "object" && !Array.isArray(e.items) && n < 5 && this.addDefaultValueCompletions(e.items, r, n + 1);
  }
  addEnumValueCompletions(e, r) {
    var n, i;
    if (typeof e.const < "u" && r.add(Object.assign(Object.assign({ type: (n = e.type) === null || n === void 0 ? void 0 : n.toString() }, this.getAppliedValue(e.const)), { info: e.description })), Array.isArray(e.enum))
      for (let o = 0, s = e.enum.length; o < s; o++) {
        const a = e.enum[o];
        r.add(Object.assign(Object.assign({ type: (i = e.type) === null || i === void 0 ? void 0 : i.toString() }, this.getAppliedValue(a)), { info: e.description }));
      }
  }
  addBooleanValueCompletion(e, r) {
    r.add({
      type: "boolean",
      label: e ? "true" : "false"
    });
  }
  addNullValueCompletion(e) {
    e.add({
      type: "null",
      label: "null"
    });
  }
  collectTypes(e, r) {
    if (Array.isArray(e.enum) || typeof e.const < "u")
      return;
    const n = e.type;
    Array.isArray(n) ? n.forEach((i) => r[i] = !0) : n && (r[n] = !0);
  }
  getSchemas(e, r) {
    var n, i, o;
    const { data: s } = this.parser(r.state), a = new ON(e);
    let l = jR(r.state, r.pos, -1, this.mode);
    if (l === "" && (l = void 0), l != null && l.endsWith("/")) {
      l = l.substring(0, l.length - 1);
      const g = l9(e, s, l);
      if (g != null)
        return [g];
    }
    let u = l?.replace(/\/[^/]*$/, "");
    u === "" && (u = void 0);
    const c = l9(e, s, u), h = l?.split("/").pop(), d = h == null || h in ((n = c?.properties) !== null && n !== void 0 ? n : {});
    let p = a.getSchema({
      pointer: l,
      data: s ?? void 0
    });
    return !d && p?.type === "null" && this.mode === "yaml" && (p = void 0), Gr.log("xxxx", "draft.getSchema", p, "data", s, "pointer", l, "pointerPointsToKnownProperty", d), gi(p) && (p = (i = p.data) === null || i === void 0 ? void 0 : i.schema), !Nm(p) && c ? [c] : (Nm(p) || (p = a.getSchema({ pointer: u }), l = u), Gr.log("xxx", "pointer..", JSON.stringify(l)), !Nm(p) && (!l || l === "/") && (p = (o = Ic(e, e)) !== null && o !== void 0 ? o : e), Gr.log("xxx", "subSchema..", p), p ? Array.isArray(p.allOf) ? [
      p,
      ...p.allOf.map((g) => Ic(g, e))
    ] : Array.isArray(p.oneOf) ? [
      p,
      ...p.oneOf.map((g) => Ic(g, e))
    ] : Array.isArray(p.anyOf) ? [
      p,
      ...p.anyOf.map((g) => Ic(g, e))
    ] : [p] : []);
  }
  getAppliedValue(e) {
    const r = zy(JSON.stringify(e));
    switch (this.mode) {
      case qr.JSON5:
        return {
          label: r,
          apply: vie(JSON.stringify(e))
        };
      case qr.YAML:
        return {
          label: r,
          apply: r
        };
      default:
        return {
          label: r,
          apply: JSON.stringify(e)
        };
    }
  }
  getValueFromLabel(e) {
    return JSON.parse(e);
  }
  extendedRegExp(e) {
    let r = "";
    e.startsWith("(?i)") && (e = e.substring(4), r = "i");
    try {
      return new RegExp(e, r + "u");
    } catch {
      try {
        return new RegExp(e, r);
      } catch {
        return;
      }
    }
  }
}
function dpe(t = {}) {
  const e = new fpe(t);
  return function(r) {
    return e.doComplete(r);
  };
}
function ppe(t) {
  return bm(t, (e, r) => e === "additionalProperties" && r === !1 ? [] : e === "required" && Array.isArray(r) ? [] : e === "unevaluatedProperties" && r === !1 ? [] : e === "unevaluatedItems" && r === !1 ? [] : [e, r]);
}
function l9(t, e, r) {
  const n = new ON(t), i = n.getSchema({
    pointer: r,
    data: e ?? void 0
  });
  if (!Nm(i))
    return;
  const o = $I(n, i), s = {};
  for (let d of o) {
    let p = gpe(r, d);
    const g = n.getSchema({
      // TODO [performance] use subSchema and only check it's sub-properties
      pointer: p,
      data: e ?? void 0
      // pointer: `/${possibleDirectPropertyName}`,
      // schema: subSchema
    });
    Nm(g) && Object.assign(s, {
      [d]: g
    });
  }
  if (o.length === 0 || Object.keys(s).length === 0)
    return;
  const a = i, { allOf: l, anyOf: u, oneOf: c } = a, h = cpe(a, ["allOf", "anyOf", "oneOf"]);
  return Object.assign(Object.assign({}, h), { properties: s });
}
function $I(t, e) {
  if (e = Ic(e, t.rootSchema), typeof e != "object" || e == null)
    return [];
  const r = [];
  function n(i) {
    const o = $I(t, i);
    r.push(...o);
  }
  if (typeof e.properties == "object" && e.properties != null && r.push(...Object.keys(e.properties)), typeof e.then == "object" && e.then != null && n(e.then), Array.isArray(e.allOf))
    for (const i of e.allOf)
      n(i);
  if (Array.isArray(e.anyOf))
    for (const i of e.anyOf)
      n(i);
  if (Array.isArray(e.oneOf))
    for (const i of e.oneOf)
      n(i);
  return r;
}
function Ic(t, e) {
  if (typeof t == "object" && t.$ref) {
    const r = mpe(e, t.$ref);
    if (typeof r == "object") {
      const n = Object.assign(Object.assign({}, t), r);
      return Reflect.deleteProperty(n, "$ref"), n;
    }
  }
  return t;
}
function mpe(t, e) {
  const r = e.split("/");
  let n = t;
  return r.forEach((i) => {
    if (i) {
      if (i === "#") {
        n = t;
        return;
      }
      typeof n == "object" && (n = n[i]);
    }
  }), n;
}
function gpe(t, e) {
  return t === void 0 ? `/${e}` : `${t}/${e}`;
}
const Dg = (t, e) => {
  const r = t.length > 2;
  let n = t.map((i, o) => {
    const s = "`" + (e ? e(i) : i) + "`";
    return o === t.length - 1 ? "or " + s : s;
  });
  return r ? n.join(", ") : n.join(" ");
}, vpe = (t) => {
  var e, r, n;
  return !((e = t?.data) === null || e === void 0) && e.pointer && ((r = t?.data) === null || r === void 0 ? void 0 : r.pointer) !== "#" ? t.data.pointer.slice(1) : !((n = t?.data) === null || n === void 0) && n.property ? `/${t.data.property}` : "";
}, ype = (t) => t.startState.field(O1) !== t.state.field(O1);
function bpe(t) {
  const e = new wpe(t);
  return (r) => e.doValidation(r);
}
const xpe = [
  "NoAdditionalPropertiesError",
  "RequiredPropertyError",
  "InvalidPropertyNameError",
  "ForbiddenPropertyError",
  "UndefinedValueError"
];
class wpe {
  constructor(e) {
    var r, n, i, o;
    this.options = e, this.schema = null, this.mode = qr.JSON, this.rewriteError = (s) => {
      var a, l, u, c, h;
      const d = s?.data, p = d?.errors;
      return s.code === "one-of-error" && p?.length ? `Expected one of ${Dg(p, (g) => g.data.expected)}` : s.code === "type-error" ? `Expected \`${!((a = s?.data) === null || a === void 0) && a.expected && Array.isArray((l = s?.data) === null || l === void 0 ? void 0 : l.expected) ? Dg((u = s?.data) === null || u === void 0 ? void 0 : u.expected) : (c = s?.data) === null || c === void 0 ? void 0 : c.expected}\` but received \`${(h = s?.data) === null || h === void 0 ? void 0 : h.received}\`` : s.message.replaceAll("in `#` ", "").replaceAll("at `#`", "").replaceAll("/", ".").replaceAll("#.", "");
    }, this.mode = (n = (r = this.options) === null || r === void 0 ? void 0 : r.mode) !== null && n !== void 0 ? n : qr.JSON, this.parser = (o = (i = this.options) === null || i === void 0 ? void 0 : i.jsonParser) !== null && o !== void 0 ? o : NI(this.mode);
  }
  get schemaTitle() {
    var e, r, n;
    return (n = (r = (e = this.schema) === null || e === void 0 ? void 0 : e.getSchema()) === null || r === void 0 ? void 0 : r.title) !== null && n !== void 0 ? n : "json-schema";
  }
  // validate using view as the linter extension signature requires
  doValidation(e) {
    const r = L4(e.state);
    if (!r)
      return [];
    if (this.schema = new EN(r), !this.schema)
      return [];
    if (!e.state.doc.toString()?.length)
      return [];
    const i = this.parser(e.state);
    if (i.data == null)
      return [];
    let o = [];
    try {
      o = this.schema.validate(i.data);
    } catch {
    }
    return Gr.log("xxx", "validation errors", o, i.data), o.length ? o.reduce((s, a) => {
      const l = () => {
        const h = this.rewriteError(a);
        s.push({
          from: 0,
          to: 0,
          message: h,
          severity: "error",
          source: this.schemaTitle,
          renderMessage: () => {
            const d = Ca("div", {});
            return d.innerHTML = Zf(h), d;
          }
        });
      }, u = vpe(a), c = i.pointers.get(u);
      if (a.name === "MaxPropertiesError" || a.name === "MinPropertiesError" || u === "")
        l();
      else if (c) {
        const h = xpe.includes(a.name), d = this.rewriteError(a), p = h ? c.keyFrom : c.valueFrom, g = h ? c.keyTo : c.valueTo;
        g !== void 0 && p !== void 0 && s.push({
          from: p,
          to: g,
          message: d,
          renderMessage: () => {
            const v = Ca("div", {});
            return v.innerHTML = Zf(d), v;
          },
          severity: "error",
          source: this.schemaTitle
        });
      } else
        l();
      return s;
    }, []) : [];
  }
}
function kpe(t) {
  const e = new _pe(t);
  return async function(r, n, i) {
    return e.doHover(r, n, i);
  };
}
function Cpe(t) {
  if (t.type)
    return t.$ref ? `${t.$ref} (${t.type})` : t.type;
  if (t.$ref)
    return `${t.$ref}`;
}
function bk(t, e, r) {
  return `${e}: ${Dg(t[e].map((n) => {
    try {
      const { data: i } = r.resolveRef({ data: n, pointer: n.$ref });
      return Cpe(i || n);
    } catch {
      return n.type;
    }
  }))}`;
}
class _pe {
  constructor(e) {
    var r, n;
    this.opts = e, this.schema = null, this.mode = qr.JSON, this.opts = Object.assign({ parser: JSON.parse }, this.opts), this.mode = (n = (r = this.opts) === null || r === void 0 ? void 0 : r.mode) !== null && n !== void 0 ? n : qr.JSON;
  }
  getDataForCursor(e, r, n) {
    const i = L4(e.state);
    if (!i)
      return null;
    this.schema = new EN(i);
    const o = jR(e.state, r, n, this.mode);
    let s;
    try {
      s = this.opts.parser(e.state.doc.toString());
    } catch {
    }
    if (!o)
      return null;
    let a = this.schema.getSchema({
      pointer: o,
      data: s,
      withSchemaWarning: !0
    });
    return gi(a) && (a?.data.schema.$ref ? a = this.schema.resolveRef(a) : a = a?.data.schema), { schema: a, pointer: o };
  }
  formatMessage(e) {
    const { message: r, typeInfo: n } = e;
    return r ? Ca("div", { class: "cm6-json-schema-hover" }, [
      Ca("div", {
        class: "cm6-json-schema-hover--description",
        inner: Zf(r, !1)
      }),
      Ca("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
        Ca("div", {
          class: "cm6-json-schema-hover--code",
          inner: Zf(n, !1)
        })
      ])
    ]) : Ca("div", { class: "cm6-json-schema-hover" }, [
      Ca("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
        Ca("code", {
          class: "cm6-json-schema-hover--code",
          inner: Zf(n, !1)
        })
      ])
    ]);
  }
  getHoverTexts(e, r) {
    let n = "", i = null;
    const { schema: o } = e;
    return o.oneOf && (n = bk(o, "oneOf", r)), o.anyOf && (n = bk(o, "anyOf", r)), o.allOf && (n = bk(o, "allOf", r)), o.type && (n = Array.isArray(o.type) ? Dg(o.type) : o.type), o.$ref && (n = ` Reference: ${o.$ref}`), o.enum && (n = `\`enum\`: ${Dg(o.enum)}`), o.format && (n += `\`format\`: ${o.format}`), o.pattern && (n += `\`pattern\`: ${o.pattern}`), o.description && (i = o.description), { message: i, typeInfo: n };
  }
  // return hover state for the current json schema property
  async doHover(e, r, n) {
    var i, o, s, a;
    const l = r, u = r;
    try {
      const c = this.getDataForCursor(e, r, n);
      if (Gr.log("cursorData", c), !c?.schema)
        return null;
      const h = ((o = (i = this.opts) === null || i === void 0 ? void 0 : i.getHoverTexts) !== null && o !== void 0 ? o : this.getHoverTexts)(c, this.schema), d = ((a = (s = this.opts) === null || s === void 0 ? void 0 : s.formatHover) !== null && a !== void 0 ? a : this.formatMessage)(h);
      return {
        pos: l,
        end: u,
        arrow: !0,
        // to mimic similar modes for other editors
        // otherwise, it gets into a z-index battle with completion/etc
        above: !0,
        create: (p) => ({
          dom: d
        })
      };
    } catch (c) {
      return Gr.log(c), null;
    }
  }
}
function Spe(t) {
  return [
    Ife(),
    b8(Nfe()),
    b8(bpe(), {
      needsRefresh: ype
    }),
    I$.data.of({
      autocomplete: dpe()
    }),
    oP(kpe()),
    kie(t)
  ];
}
function Ape() {
  return [
    uZ(),
    fZ(),
    FY(),
    hte(),
    bY(),
    _Y(),
    nr.allowMultipleSelections.of(!0),
    jZ(),
    wP(VZ, { fallback: !0 }),
    YZ(),
    Uee(),
    ete(),
    qY(),
    VY(),
    $Y(),
    Mne(),
    Be.domEventHandlers({
      keydown(t) {
        t.stopPropagation();
      }
    }),
    $b.of([
      ...Gee,
      ...pre,
      ...Jne,
      ...xte,
      ...$P,
      ...bne,
      { key: "Tab", preventDefault: !0, run: hre },
      { key: "Shift-Tab", preventDefault: !0, run: mR }
    ])
  ];
}
function Epe(t, e) {
  const r = Be.theme({
    "&.cm-editor": { height: "100%" },
    ".cm-scroller": { overflow: "auto" },
    "&.cm-focused": { outline: "none" },
    ".cm-tooltip": {
      boxShadow: e.colorScheme == "light" ? "0 2px 5px rgba(0,0,0,0.2)" : "0 2px 5px rgba(0,0,0,1)"
    },
    ".cm6-json-schema-hover": { padding: "6px" }
  }), n = Be.updateListener.of((s) => {
    if (s.docChanged && e.onChange) {
      const a = s.state.doc.toString();
      e.onChange(a);
    }
  }), i = [];
  if (e.language == "json" && i.push(Spe(e.json?.schema ?? {})), e.language == "sql") {
    let s = e.sql?.table, a = e.sql?.columns;
    i.push(cne({
      dialect: hne,
      upperCaseKeywords: !0,
      schema: s != null ? {
        [s]: a?.map((l) => ({ label: l.name, detail: l.type, type: "property" })) ?? []
      } : void 0,
      defaultTable: s
    }));
  }
  const o = new Be({
    doc: e.initialText,
    parent: t,
    extensions: [
      // Basic setup
      ...Ape(),
      // Tooltip parent element
      WY({ parent: t.parentElement }),
      // Langauge
      ...i,
      // Theme and styling
      ...e.colorScheme == "dark" ? [hie] : [],
      r,
      // Change
      n
    ]
  });
  return {
    set: (s) => {
      o.dispatch({
        changes: { from: 0, to: o.state.doc.length, insert: s }
      });
    },
    destroy: () => {
      o.destroy();
    }
  };
}
var Dpe = /* @__PURE__ */ me('<div><div class="rounded-md overflow-hidden border border-slate-200 dark:border-slate-600 w-full h-full"></div></div>');
function AS(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]), n;
  Vs(() => {
    let s = Go(() => e.value) ?? "", a = Epe(n, {
      language: e.language ?? "plain",
      colorScheme: e.colorScheme ?? "light",
      initialText: Go(() => e.value) ?? "",
      json: e.json,
      sql: e.sql,
      onChange: (l) => {
        s = l, e.onChange?.(l);
      }
    });
    return mt(() => {
      e.value != null && e.value != s && (s = r.value, a.set(s));
    }), () => {
      a.destroy();
    };
  });
  var i = Dpe(), o = Y(i);
  Qs(o, (s) => n = s, () => n), J(i), Ae(() => Yr(i, 1, Tb(e.class ?? ""))), X(t, i), it();
}
var Ope = /* @__PURE__ */ me('<div class="w-full h-full flex flex-col gap-2"><!> <div class="flex-none flex gap-2 items-center"><button>Confirm</button> <div class="flex-1 w-0 overflow-hidden text-nowrap text-ellipsis"> </div></div></div>');
function Fpe(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(void 0), n = /* @__PURE__ */ K(() => x(r)?.spec !== void 0);
  function i(p) {
    try {
      return { spec: JSON.parse(p) };
    } catch (g) {
      return { message: g.message?.toString() };
    }
  }
  function o() {
    x(r) && x(r).spec != null && e.onSpecChange?.(x(r).spec);
  }
  var s = Ope(), a = Y(s);
  {
    let p = /* @__PURE__ */ K(() => JSON.stringify(e.spec, null, 2));
    AS(a, {
      class: "w-full flex-1 min-h-0",
      get colorScheme() {
        return e.colorScheme;
      },
      language: "json",
      get value() {
        return x(p);
      },
      onChange: (g) => {
        ue(r, i(g), !0);
      }
    });
  }
  var l = ae(a, 2), u = Y(l);
  let c;
  u.__click = o;
  var h = ae(u, 2), d = Y(h, !0);
  J(h), J(l), J(s), Ae(() => {
    c = Yr(u, 1, "flex-none px-2 h-8 w-24 rounded-md text-white text-sm", null, c, {
      "bg-blue-500": x(n),
      "bg-gray-300": !x(n),
      "dark:text-gray-500": !x(n),
      "dark:bg-gray-700": !x(n)
    }), u.disabled = !x(n), te(h, "title", x(r)?.message ?? ""), ut(d, x(r)?.message ?? "");
  }), X(t, s), it();
}
nn(["click"]);
var Tpe = /* @__PURE__ */ me('<span class="mx-1"> </span>'), Mpe = /* @__PURE__ */ me("<button><!> <!></button>");
function uy(t, e) {
  nt(e, !0);
  let r = ct(e, "label", 3, null), n = ct(e, "icon", 3, null), i = ct(e, "title", 3, ""), o = ct(e, "order", 3, null);
  var s = Mpe();
  s.__click = () => {
    e.onClick?.();
  };
  let a;
  var l = Y(s);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(n);
      var g = kr(), v = Ve(g);
      Qd(v, () => x(p), (y, b) => {
        b(y, { class: "w-4 h-4" });
      }), X(d, g);
    };
    Oe(l, (d) => {
      n() != null && d(u);
    });
  }
  var c = ae(l, 2);
  {
    var h = (d) => {
      var p = Tpe(), g = Y(p, !0);
      J(p), Ae(() => ut(g, r())), X(d, p);
    };
    Oe(c, (d) => {
      r() != null && r() != "" && d(h);
    });
  }
  J(s), Ae(() => {
    Yr(s, 1, `rounded-md flex select-none items-center px-1 py-1 text-slate-500 bg-slate-100 dark:text-slate-400 dark:bg-slate-800 focus-visible:outline-2 outline-blue-600 -outline-offset-1 ${e.class ?? "" ?? ""}`), te(s, "title", i()), a = ft(s, "", a, { order: o() });
  }), X(t, s), it();
}
nn(["click"]);
var Ppe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M3.2 5.74a.75.75 0 0 1 1.06-.04L8 9.227L11.74 5.7a.75.75 0 1 1 1.02 1.1l-4.25 4a.75.75 0 0 1-1.02 0l-4.25-4a.75.75 0 0 1-.04-1.06"></path></svg>');
function u9(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Ppe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Rpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M3.2 10.26a.75.75 0 0 0 1.06.04L8 6.773l3.74 3.527a.75.75 0 1 0 1.02-1.1l-4.25-4a.75.75 0 0 0-1.02 0l-4.25 4a.75.75 0 0 0-.04 1.06"></path></svg>');
function c9(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Rpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Npe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M2.75 2a.75.75 0 0 1 .75.75v12.5c0 .69.56 1.25 1.25 1.25h12.5a.75.75 0 0 1 0 1.5H4.75A2.75 2.75 0 0 1 2 15.25V2.75A.75.75 0 0 1 2.75 2M10 7.5a2.5 2.5 0 1 1-5 0a2.5 2.5 0 0 1 5 0m4.5.5a2.5 2.5 0 1 0 0-5a2.5 2.5 0 0 0 0 5m.5 4.5a2.5 2.5 0 1 1-5 0a2.5 2.5 0 0 1 5 0"></path></svg>');
function $pe(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Npe();
  Qo(n, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Ipe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="m2.397 2.554l.073-.084a.75.75 0 0 1 .976-.073l.084.073L8 6.939l4.47-4.47a.75.75 0 1 1 1.06 1.061L9.061 8l4.47 4.47a.75.75 0 0 1 .072.976l-.073.084a.75.75 0 0 1-.976.073l-.084-.073L8 9.061l-4.47 4.47a.75.75 0 0 1-1.06-1.061L6.939 8l-4.47-4.47a.75.75 0 0 1-.072-.976l.073-.084z"></path></svg>');
function mx(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Ipe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Bpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M9 1H6a2 2 0 0 0-2 2v2.205a5.5 5.5 0 0 1 4.666 9.791H12a2 2 0 0 0 2-2V6.001h-3.5A1.5 1.5 0 0 1 9 4.5zm4.997 4h-3.498a.5.5 0 0 1-.5-.5V1h.01zM10 10.5a4.5 4.5 0 1 1-9 0a4.5 4.5 0 0 1 9 0m-4.854 2.353l.003.003a.5.5 0 0 0 .348.144h.006a.5.5 0 0 0 .35-.146l2-2a.5.5 0 0 0-.707-.708L6 11.293V8.5a.5.5 0 0 0-1 0v2.793l-1.146-1.147a.5.5 0 0 0-.708.708z"></path></svg>');
function h9(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Bpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Lpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M10.529 1.764a2.621 2.621 0 1 1 3.707 3.707l-.779.779L9.75 2.543zM9.043 3.25L2.657 9.636a2.96 2.96 0 0 0-.772 1.354l-.87 3.386a.5.5 0 0 0 .61.608l3.385-.869a2.95 2.95 0 0 0 1.354-.772l6.386-6.386z"></path></svg>');
function II(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Lpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var zpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M2 6a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3zm3-2a2 2 0 0 0-2 2v5h14V6a2 2 0 0 0-2-2z"></path></svg>');
function jpe(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = zpe();
  Qo(n, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var qpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M15 3a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3zM5 4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h6.5V4z"></path></svg>');
function Upe(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = qpe();
  Qo(n, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Hpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M10.823 11.883a5.5 5.5 0 1 1 1.06-1.06l2.897 2.897a.75.75 0 1 1-1.06 1.06zM11.5 7.5a4 4 0 1 0-8 0a4 4 0 0 0 8 0"></path></svg>');
function Vpe(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Hpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Wpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M2.267 6.153A6 6 0 0 1 3.53 3.98a.36.36 0 0 1 .382-.095l1.36.484a.71.71 0 0 0 .935-.538l.26-1.416a.35.35 0 0 1 .274-.282a6.1 6.1 0 0 1 2.52 0c.14.03.248.141.274.282l.26 1.416a.708.708 0 0 0 .935.538l1.36-.484a.36.36 0 0 1 .382.095a6 6 0 0 1 1.262 2.173a.35.35 0 0 1-.108.378l-1.102.931a.703.703 0 0 0 0 1.076l1.102.931c.11.093.152.242.108.378a6 6 0 0 1-1.262 2.173a.36.36 0 0 1-.382.095l-1.36-.484a.71.71 0 0 0-.935.538l-.26 1.416a.35.35 0 0 1-.275.282a6.1 6.1 0 0 1-2.519 0a.35.35 0 0 1-.275-.282l-.259-1.416a.708.708 0 0 0-.935-.538l-1.36.484a.36.36 0 0 1-.382-.095a6 6 0 0 1-1.262-2.173a.35.35 0 0 1 .108-.378l1.102-.931a.704.704 0 0 0 0-1.076l-1.102-.931a.35.35 0 0 1-.108-.378M6.25 8a1.75 1.75 0 1 0 3.5 0a1.75 1.75 0 0 0-3.5 0"></path></svg>');
function BI(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Wpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Gpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M7.456 2a6 6 0 1 1-5.406 8.605a.5.5 0 0 1 .36-.71c1.276-.231 3.278-.937 4.078-3.07c.563-1.5.512-3.015.283-4.23a.5.5 0 0 1 .475-.591Q7.35 2 7.456 2"></path></svg>');
function Kpe(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Gpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Qpe = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M8 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 8 1m0 10a3 3 0 1 0 0-6a3 3 0 0 0 0 6m6.5-2.5a.5.5 0 0 0 0-1h-1a.5.5 0 0 0 0 1zM8 13a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 8 13M2.5 8.5a.5.5 0 0 0 0-1h-1a.5.5 0 0 0 0 1zm.646-5.354a.5.5 0 0 1 .708 0l1 1a.5.5 0 1 1-.708.708l-1-1a.5.5 0 0 1 0-.708m.708 9.708a.5.5 0 1 1-.708-.707l1-1a.5.5 0 0 1 .708.707zm9-9.708a.5.5 0 0 0-.708 0l-1 1a.5.5 0 0 0 .708.708l1-1a.5.5 0 0 0 0-.708m-.708 9.708a.5.5 0 0 0 .708-.707l-1-1a.5.5 0 0 0-.708.707z"></path></svg>');
function Xpe(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Qpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
var Jpe = /* @__PURE__ */ me('<div class="text-sm pr-0.5"><!></div>'), Ype = /* @__PURE__ */ me('<div class="text-sm pr-0.5"><!></div>'), Zpe = /* @__PURE__ */ me('<div class="h-64"><div class="w-full h-64 p-2"><!></div></div>'), eme = /* @__PURE__ */ me('<div class="px-2 pt-2 flex items-center"><button class="font-mono font-medium py-0.5 text-left flex flex-1 mr-2 overflow-hidden items-center"><!> <div class="flex-1 whitespace-nowrap overflow-hidden text-ellipsis"> </div></button> <div class="flex-none flex gap-1 sm:opacity-0 group-hover:opacity-100 pr-0.5"><!> <!> <!> <!></div></div> <div><div class="overflow-hidden"><!> <!></div></div>', 1);
function f9(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(!1);
  var n = eme(), i = Ve(n), o = Y(i);
  o.__click = () => e.onIsVisibleChange?.(!e.isVisible);
  var s = Y(o);
  {
    var a = (z) => {
      var R = Jpe(), N = Y(R);
      c9(N, {}), J(R), X(z, R);
    }, l = (z) => {
      var R = Ype(), N = Y(R);
      u9(N, {}), J(R), X(z, R);
    };
    Oe(s, (z) => {
      e.isVisible ? z(a) : z(l, !1);
    });
  }
  var u = ae(s, 2), c = Y(u, !0);
  J(u), J(o);
  var h = ae(o, 2), d = Y(h);
  {
    var p = (z) => {
      uy(z, {
        get icon() {
          return II;
        },
        title: "Edit spec",
        onClick: () => ue(r, !x(r))
      });
    };
    Oe(d, (z) => {
      e.onSpecChange && z(p);
    });
  }
  var g = ae(d, 2);
  {
    var v = (z) => {
      uy(z, {
        get icon() {
          return c9;
        },
        title: "Move up",
        get onClick() {
          return e.onUp;
        }
      });
    };
    Oe(g, (z) => {
      e.onUp && z(v);
    });
  }
  var y = ae(g, 2);
  {
    var b = (z) => {
      uy(z, {
        get icon() {
          return u9;
        },
        title: "Move down",
        get onClick() {
          return e.onDown;
        }
      });
    };
    Oe(y, (z) => {
      e.onDown && z(b);
    });
  }
  var k = ae(y, 2);
  {
    var C = (z) => {
      uy(z, {
        get icon() {
          return mx;
        },
        title: "Close",
        onClick: () => e.onRemove()
      });
    };
    Oe(k, (z) => {
      e.onRemove && z(C);
    });
  }
  J(h), J(i);
  var S = ae(i, 2);
  let _;
  var D = Y(S), A = Y(D);
  Xl(A, () => e.chartView, () => ({ id: e.id, width: "container" }));
  var O = ae(A, 2);
  {
    var M = (z) => {
      var R = Zpe(), N = Y(R), I = Y(N);
      Fpe(I, {
        get spec() {
          return e.spec;
        },
        get colorScheme() {
          return e.colorScheme;
        },
        onSpecChange: (B) => {
          e.onSpecChange(B), ue(r, !1);
        }
      }), J(N), J(R), cm(3, R, () => hm), X(z, R);
    };
    Oe(O, (z) => {
      x(r) && e.onSpecChange && z(M);
    });
  }
  J(D), J(S), Ae(() => {
    ut(c, e.spec.title), _ = ft(S, "", _, {
      display: "grid",
      "grid-template-rows": e.isVisible ? "1fr" : "0fr",
      transition: "grid-template-rows 300ms ease-in-out"
    });
  }), X(t, n), it();
}
nn(["click"]);
function tme(t) {
  switch (t.type) {
    case "embedding":
      return "embedding";
    case "table":
      return "table";
    default:
      return "chart";
  }
}
function LI(t) {
  let e = { embedding: [], table: [], chart: [] };
  for (let r in t) {
    let n = tme(t[r]);
    n != null && e[n].push(r);
  }
  return e;
}
var rme = /* @__PURE__ */ me('<div class="flex-1 overflow-hidden rounded-md"><!></div>'), nme = /* @__PURE__ */ me('<div class="flex flex-row gap-2 flex-1 overflow-hidden"></div>'), ime = /* @__PURE__ */ me('<div class="flex-1 h-full overflow-hidden rounded-md"><!></div>'), ome = /* @__PURE__ */ me("<div></div>"), sme = /* @__PURE__ */ me('<div class="flex-1 flex flex-col overflow-hidden"><!> <!> <!></div>'), ame = /* @__PURE__ */ me('<div class="bg-white dark:bg-black rounded-md flex flex-col gap-2 group"><!></div>'), lme = /* @__PURE__ */ me('<div class="h-full overflow-x-hidden overflow-y-scroll"><div class="flex flex-row flex-wrap gap-2"><button class="bg-white dark:bg-black rounded-md flex flex-col justify-center items-center gap-2 p-2 w-full text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-slate-100">+ Add</button> <!></div></div>'), ume = /* @__PURE__ */ me("<!> <!> <!>", 1), cme = /* @__PURE__ */ me('<div class="bg-white dark:bg-black rounded-md flex flex-col gap-2 group"><!></div>'), hme = /* @__PURE__ */ me('<div class="w-full h-full overflow-y-scroll flex flex-col gap-2"><button class="bg-white dark:bg-black rounded-md flex flex-col justify-center items-center gap-2 p-2 w-full text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-slate-100">+ Add</button> <!></div>'), fme = /* @__PURE__ */ me('<div class="w-full h-full flex flex-row"><!></div>');
function dme(t, e) {
  nt(e, !0);
  const r = () => mi(o, "$colorScheme", n), [n, i] = Xo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ De(100), a = /* @__PURE__ */ De(100), l = /* @__PURE__ */ De(300), u = /* @__PURE__ */ De(400), c = /* @__PURE__ */ K(rD(() => LI(e.charts))), h = /* @__PURE__ */ K(() => x(s) < 500), d = /* @__PURE__ */ K(() => x(c).embedding.length > 0 && (e.state.showEmbedding ?? !0)), p = /* @__PURE__ */ K(() => x(c).table.length > 0 && (e.state.showTable ?? !0)), g = /* @__PURE__ */ K(() => e.state.showCharts ?? !0);
  function v(A, O) {
    let M = Math.round((A + 7) / (O + 7)), z, R;
    for (let N = Math.max(1, M - 1); N <= Math.max(1, M + 1); N++) {
      let I = (A - 7 * (N - 1)) / N, B = Math.abs(I - O);
      (z == null || B < z) && (z = B, R = I);
    }
    return Math.floor((R ?? 400) * 2) / 2;
  }
  let y = /* @__PURE__ */ K(rD(() => {
    let A = e.state.chartsOrder ?? [], O = x(c).chart.slice();
    return O.sort((M, z) => {
      let R = A.indexOf(M), N = A.indexOf(z);
      return R == -1 && (R = O.length), N == -1 && (N = O.length), R - N;
    }), O;
  }));
  function b(A, O) {
    let M = [...x(y)], z = M.indexOf(A);
    if (z == -1)
      return;
    let R = z + O;
    R < 0 || R >= M.length || ([M[z], M[R]] = [M[R], M[z]], e.onStateChange({ chartsOrder: M }));
  }
  function k(A) {
    e.onChartsChange({ [A]: void 0 }), e.onChartStatesChange({ [A]: void 0 });
  }
  var C = fme(), S = Y(C);
  {
    var _ = (A) => {
      var O = ume(), M = Ve(O);
      {
        var z = ($) => {
          var q = sme(), U = Y(q);
          {
            var H = (ne) => {
              var ce = nme();
              Nt(ce, 20, () => x(c).embedding, (Ce) => Ce, (Ce, Pe) => {
                var Me = rme(), _e = Y(Me);
                Xl(_e, () => e.chartView, () => ({ id: Pe, width: "container", height: "container" })), J(Me), X(Ce, Me);
              }), J(ce), X(ne, ce);
            };
            Oe(U, (ne) => {
              x(d) && ne(H);
            });
          }
          var G = ae(U, 2);
          {
            var re = (ne) => {
              {
                let ce = /* @__PURE__ */ K(() => x(a) - 100);
                CD(ne, {
                  class: "h-2 flex-none",
                  axis: "y",
                  min: 100,
                  get max() {
                    return x(ce);
                  },
                  scaler: -1,
                  get value() {
                    return x(l);
                  },
                  onChange: (Ce) => ue(l, Ce, !0)
                });
              }
            };
            Oe(G, (ne) => {
              x(d) && x(p) && ne(re);
            });
          }
          var ie = ae(G, 2);
          {
            var se = (ne) => {
              var ce = ome();
              let Ce;
              Nt(ce, 20, () => x(c).table, (Pe) => Pe, (Pe, Me) => {
                var _e = ime(), he = Y(_e);
                Xl(he, () => e.chartView, () => ({ id: Me, width: "container", height: "container" })), J(_e), X(Pe, _e);
              }), J(ce), Ae(() => {
                Yr(ce, 1, Tb(x(d) ? "flex-none" : "flex-1")), Ce = ft(ce, "", Ce, {
                  height: x(d) ? `${x(l)}px` : null
                });
              }), cm(3, ce, () => hm), X(ne, ce);
            };
            Oe(ie, (ne) => {
              x(p) && ne(se);
            });
          }
          J(q), X($, q);
        };
        Oe(M, ($) => {
          (x(d) || x(p)) && $(z);
        });
      }
      var R = ae(M, 2);
      {
        var N = ($) => {
          {
            let q = /* @__PURE__ */ K(() => x(s) - 100);
            CD($, {
              class: "w-2 flex-none",
              axis: "x",
              min: 100,
              get max() {
                return x(q);
              },
              scaler: -1,
              get value() {
                return x(u);
              },
              onChange: (U) => ue(u, U, !0)
            });
          }
        };
        Oe(R, ($) => {
          (x(d) || x(p)) && x(g) && $(N);
        });
      }
      var I = ae(R, 2);
      {
        var B = ($) => {
          const q = /* @__PURE__ */ K(() => x(d) || x(p) ? x(u) : x(s));
          var U = lme();
          let H;
          var G = Y(U);
          let re;
          var ie = Y(G);
          ie.__click = () => {
            let ne = _D(e.charts);
            e.onChartsChange({ [ne]: { type: "builder", title: "New" } }), e.onStateChange({ chartsOrder: [ne, ...x(y)] });
          };
          var se = ae(ie, 2);
          Nt(se, 26, () => x(y), (ne) => ne, (ne, ce, Ce) => {
            const Pe = /* @__PURE__ */ K(() => e.charts[ce]), Me = /* @__PURE__ */ K(() => e.state.chartVisibility?.[ce] ?? !0);
            var _e = ame();
            let he;
            var ke = Y(_e);
            {
              let ve = /* @__PURE__ */ K(() => k.bind(null, ce)), We = /* @__PURE__ */ K(() => x(Ce) > 0 ? b.bind(null, ce, -1) : void 0), Qe = /* @__PURE__ */ K(() => x(Ce) + 1 < x(y).length ? b.bind(null, ce, 1) : void 0);
              f9(ke, {
                get id() {
                  return ce;
                },
                get spec() {
                  return x(Pe);
                },
                onIsVisibleChange: (ot) => {
                  e.onStateChange({ chartVisibility: { [ce]: ot } });
                },
                get isVisible() {
                  return x(Me);
                },
                get colorScheme() {
                  return r();
                },
                get chartView() {
                  return e.chartView;
                },
                get onRemove() {
                  return x(ve);
                },
                get onUp() {
                  return x(We);
                },
                get onDown() {
                  return x(Qe);
                },
                onSpecChange: (ot) => {
                  e.onChartsChange({ [ce]: void 0 }), e.onChartStatesChange({ [ce]: void 0 }), e.onChartsChange({ [ce]: ot });
                }
              });
            }
            J(_e), Ae((ve) => he = ft(_e, "", he, ve), [
              () => ({ width: `${v(x(q), 500) ?? ""}px` })
            ]), bD(_e, () => kD, () => ({ duration: 300 })), cm(2, _e, () => hm), X(ne, _e);
          }), J(G), J(U), Ae(() => {
            H = ft(U, "", H, { width: `${x(q) ?? ""}px` }), re = ft(G, "", re, { width: `${x(q) ?? ""}px` });
          }), cm(3, U, () => hm, () => ({ axis: "x" })), X($, U);
        };
        Oe(I, ($) => {
          x(g) && $(B);
        });
      }
      X(A, O);
    }, D = (A) => {
      var O = hme(), M = Y(O);
      M.__click = () => {
        let R = _D(e.charts);
        e.onChartsChange({ [R]: { type: "builder", title: "New" } }), e.onStateChange({ chartsOrder: [R, ...x(y)] });
      };
      var z = ae(M, 2);
      Nt(z, 26, () => x(c).embedding.concat(x(y), x(c).table), (R) => R, (R, N) => {
        const I = /* @__PURE__ */ K(() => e.state.chartVisibility?.[N] ?? !0), B = /* @__PURE__ */ K(() => x(y).indexOf(N));
        var $ = cme(), q = Y($);
        {
          let U = /* @__PURE__ */ K(() => k.bind(null, N)), H = /* @__PURE__ */ K(() => x(B) > 0 ? b.bind(null, N, -1) : void 0), G = /* @__PURE__ */ K(() => x(B) != -1 && x(B) + 1 < x(y).length ? b.bind(null, N, 1) : void 0);
          f9(q, {
            get id() {
              return N;
            },
            get spec() {
              return e.charts[N];
            },
            onIsVisibleChange: (re) => {
              e.onStateChange({ chartVisibility: { [N]: re } });
            },
            get isVisible() {
              return x(I);
            },
            get colorScheme() {
              return r();
            },
            get chartView() {
              return e.chartView;
            },
            get onRemove() {
              return x(U);
            },
            get onUp() {
              return x(H);
            },
            get onDown() {
              return x(G);
            }
          });
        }
        J($), bD($, () => kD, () => ({ duration: 300 })), cm(2, $, () => hm), X(R, $);
      }), J(O), X(A, O);
    };
    Oe(S, (A) => {
      x(h) ? A(D, !1) : A(_);
    });
  }
  J(C), Ks(C, "clientWidth", (A) => ue(s, A)), Ks(C, "clientHeight", (A) => ue(a, A)), X(t, C), it(), i();
}
nn(["click"]);
var pme = /* @__PURE__ */ me('<span class="flex h-5 items-center"> </span>'), mme = /* @__PURE__ */ me("<button><!> <!></button>");
function Qy(t, e) {
  nt(e, !0);
  let r = ct(e, "title", 3, ""), n = ct(e, "checked", 15), i = ct(e, "label", 3, null), o = ct(e, "icon", 3, null);
  var s = mme();
  let a;
  s.__click = () => {
    n(!n());
  };
  var l = Y(s);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(o);
      var g = kr(), v = Ve(g);
      Qd(v, () => x(p), (y, b) => {
        b(y, { class: "w-5 h-5" });
      }), X(d, g);
    };
    Oe(l, (d) => {
      o() != null && d(u);
    });
  }
  var c = ae(l, 2);
  {
    var h = (d) => {
      var p = pme(), g = Y(p, !0);
      J(p), Ae(() => ut(g, i())), X(d, p);
    };
    Oe(c, (d) => {
      i() != null && d(h);
    });
  }
  J(s), Ae(() => {
    a = Yr(s, 1, "rounded-md px-1.5 py-1.5 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 flex select-none items-center focus-visible:outline-2 outline-blue-600 -outline-offset-1", null, a, {
      "text-slate-400": !n(),
      "dark:text-slate-500": !n()
    }), te(s, "title", r());
  }), X(t, s), it();
}
nn(["click"]);
var gme = /* @__PURE__ */ me("<!> <!> <!>", 1);
function d9(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => LI(e.charts));
  var n = gme(), i = Ve(n);
  {
    var o = (d) => {
      var p = () => e.state.showEmbedding ?? !0, g = (v) => {
        e.onStateChange({ showEmbedding: v });
      };
      Qy(d, {
        get icon() {
          return $pe;
        },
        title: "Show / hide embedding",
        get checked() {
          return p();
        },
        set checked(v) {
          g(v);
        }
      });
    };
    Oe(i, (d) => {
      x(r).embedding.length > 0 && d(o);
    });
  }
  var s = ae(i, 2), a = () => e.state.showTable ?? !0, l = (d) => {
    e.onStateChange({ showTable: d });
  };
  Qy(s, {
    get icon() {
      return jpe;
    },
    title: "Show / hide table",
    get checked() {
      return a();
    },
    set checked(d) {
      l(d);
    }
  });
  var u = ae(s, 2), c = () => e.state.showCharts ?? !0, h = (d) => {
    e.onStateChange({ showCharts: d });
  };
  Qy(u, {
    get icon() {
      return Upe;
    },
    title: "Show / hide charts",
    get checked() {
      return c();
    },
    set checked(d) {
      h(d);
    }
  }), X(t, n), it();
}
const rd = {
  list: [dme, d9],
  grid: [hX, d9]
};
function vme(t) {
  return rd[t] == null ? rd.list[0] : rd[t][0];
}
function yme(t) {
  return rd[t] == null ? rd.list[1] : rd[t][1];
}
function bme(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => yme(e.layout)), n = /* @__PURE__ */ K(() => e.layoutStates[e.layout] ?? {});
  function i(u, c = "merge") {
    pd(e.charts, u, c, (h) => e.onChartsChange?.(h));
  }
  function o(u, c = "merge") {
    pd(e.chartStates, u, c, (h) => e.onChartStatesChange?.(h));
  }
  function s(u, c, h = "merge") {
    _y(e.layoutStates, u, c, h, (d) => e.onLayoutStatesChange?.(d));
  }
  var a = kr(), l = Ve(a);
  {
    let u = /* @__PURE__ */ K(() => s.bind(null, e.layout));
    Qd(l, () => x(r), (c, h) => {
      h(c, {
        get context() {
          return e.context;
        },
        get charts() {
          return e.charts;
        },
        get state() {
          return x(n);
        },
        get onStateChange() {
          return x(u);
        },
        onChartsChange: i,
        onChartStatesChange: o
      });
    });
  }
  X(t, a), it();
}
var xme = /* @__PURE__ */ me("<div><!></div>");
function vc(t, e) {
  let r = ct(e, "defaultWidth", 3, null), n = ct(e, "defaultHeight", 3, null), i = ct(e, "scrollX", 3, !1), o = ct(e, "scrollY", 3, !1), s = /* @__PURE__ */ K(() => e.width != null ? e.width : i() ? void 0 : r()), a = /* @__PURE__ */ K(() => e.height != null ? e.height : o() ? void 0 : n());
  var l = xme();
  let u;
  var c = Y(l);
  Xl(c, () => e.children), J(l), Ae(() => {
    Yr(l, 1, `p-2 ${e.class ?? "" ?? ""}`), u = ft(l, "", u, {
      width: x(s) != null ? `${x(s)}px` : void 0,
      height: x(a) != null ? `${x(a)}px` : void 0,
      "overflow-x": i() && e.width != null ? "auto" : void 0,
      "overflow-y": o() && e.height != null ? "auto" : void 0
    });
  }), X(t, l);
}
var wme = /* @__PURE__ */ me("<div><!></div>");
function p0(t, e) {
  let r = /* @__PURE__ */ De(300), n = /* @__PURE__ */ De(200), i = ct(e, "flexHeight", 3, !0), o = ct(e, "defaultHeight", 3, 200);
  var s = wme();
  let a;
  var l = Y(s);
  Xl(l, () => e.children ?? zt, () => x(r), () => x(n)), J(s), Ae(() => {
    Yr(s, 1, Tb(i() ? "flex-1 min-h-0" : void 0)), a = ft(s, "", a, {
      "user-select": "none",
      position: "relative",
      height: i() ? void 0 : `${o()}px`
    });
  }), Ks(s, "clientWidth", (u) => ue(r, u)), Ks(s, "clientHeight", (u) => ue(n, u)), X(t, s);
}
function kme(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function eb(t, e) {
  if ((r = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
  var r, n = t.slice(0, r);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +t.slice(r + 1)
  ];
}
function Pd(t) {
  return t = eb(Math.abs(t)), t ? t[1] : NaN;
}
function Cme(t, e) {
  return function(r, n) {
    for (var i = r.length, o = [], s = 0, a = t[0], l = 0; i > 0 && a > 0 && (l + a + 1 > n && (a = Math.max(1, n - l)), o.push(r.substring(i -= a, i + a)), !((l += a + 1) > n)); )
      a = t[s = (s + 1) % t.length];
    return o.reverse().join(e);
  };
}
function _me(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(r) {
      return t[+r];
    });
  };
}
var Sme = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Og(t) {
  if (!(e = Sme.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new ES({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
Og.prototype = ES.prototype;
function ES(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
ES.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Ame(t) {
  e: for (var e = t.length, r = 1, n = -1, i; r < e; ++r)
    switch (t[r]) {
      case ".":
        n = i = r;
        break;
      case "0":
        n === 0 && (n = r), i = r;
        break;
      default:
        if (!+t[r]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? t.slice(0, n) + t.slice(i + 1) : t;
}
var zI;
function Eme(t, e) {
  var r = eb(t, e);
  if (!r) return t + "";
  var n = r[0], i = r[1], o = i - (zI = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, s = n.length;
  return o === s ? n : o > s ? n + new Array(o - s + 1).join("0") : o > 0 ? n.slice(0, o) + "." + n.slice(o) : "0." + new Array(1 - o).join("0") + eb(t, Math.max(0, e + o - 1))[0];
}
function p9(t, e) {
  var r = eb(t, e);
  if (!r) return t + "";
  var n = r[0], i = r[1];
  return i < 0 ? "0." + new Array(-i).join("0") + n : n.length > i + 1 ? n.slice(0, i + 1) + "." + n.slice(i + 1) : n + new Array(i - n.length + 2).join("0");
}
const m9 = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: kme,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => p9(t * 100, e),
  r: p9,
  s: Eme,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function g9(t) {
  return t;
}
var v9 = Array.prototype.map, y9 = ["y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Dme(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? g9 : Cme(v9.call(t.grouping, Number), t.thousands + ""), r = t.currency === void 0 ? "" : t.currency[0] + "", n = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", o = t.numerals === void 0 ? g9 : _me(v9.call(t.numerals, String)), s = t.percent === void 0 ? "%" : t.percent + "", a = t.minus === void 0 ? "âˆ’" : t.minus + "", l = t.nan === void 0 ? "NaN" : t.nan + "";
  function u(h) {
    h = Og(h);
    var d = h.fill, p = h.align, g = h.sign, v = h.symbol, y = h.zero, b = h.width, k = h.comma, C = h.precision, S = h.trim, _ = h.type;
    _ === "n" ? (k = !0, _ = "g") : m9[_] || (C === void 0 && (C = 12), S = !0, _ = "g"), (y || d === "0" && p === "=") && (y = !0, d = "0", p = "=");
    var D = v === "$" ? r : v === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "", A = v === "$" ? n : /[%p]/.test(_) ? s : "", O = m9[_], M = /[defgprs%]/.test(_);
    C = C === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, C)) : Math.max(0, Math.min(20, C));
    function z(R) {
      var N = D, I = A, B, $, q;
      if (_ === "c")
        I = O(R) + I, R = "";
      else {
        R = +R;
        var U = R < 0 || 1 / R < 0;
        if (R = isNaN(R) ? l : O(Math.abs(R), C), S && (R = Ame(R)), U && +R == 0 && g !== "+" && (U = !1), N = (U ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + N, I = (_ === "s" ? y9[8 + zI / 3] : "") + I + (U && g === "(" ? ")" : ""), M) {
          for (B = -1, $ = R.length; ++B < $; )
            if (q = R.charCodeAt(B), 48 > q || q > 57) {
              I = (q === 46 ? i + R.slice(B + 1) : R.slice(B)) + I, R = R.slice(0, B);
              break;
            }
        }
      }
      k && !y && (R = e(R, 1 / 0));
      var H = N.length + R.length + I.length, G = H < b ? new Array(b - H + 1).join(d) : "";
      switch (k && y && (R = e(G + R, G.length ? b - I.length : 1 / 0), G = ""), p) {
        case "<":
          R = N + R + I + G;
          break;
        case "=":
          R = N + G + R + I;
          break;
        case "^":
          R = G.slice(0, H = G.length >> 1) + N + R + I + G.slice(H);
          break;
        default:
          R = G + N + R + I;
          break;
      }
      return o(R);
    }
    return z.toString = function() {
      return h + "";
    }, z;
  }
  function c(h, d) {
    var p = u((h = Og(h), h.type = "f", h)), g = Math.max(-8, Math.min(8, Math.floor(Pd(d) / 3))) * 3, v = Math.pow(10, -g), y = y9[8 + g / 3];
    return function(b) {
      return p(v * b) + y;
    };
  }
  return {
    format: u,
    formatPrefix: c
  };
}
var cy, ou, jI;
Ome({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Ome(t) {
  return cy = Dme(t), ou = cy.format, jI = cy.formatPrefix, cy;
}
function Fme(t) {
  return Math.max(0, -Pd(Math.abs(t)));
}
function Tme(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Pd(e) / 3))) * 3 - Pd(Math.abs(t)));
}
function Mme(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, Pd(e) - Pd(t)) + 1;
}
function Xy(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Pme(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function qI(t) {
  let e, r, n;
  t.length !== 2 ? (e = Xy, r = (a, l) => Xy(t(a), l), n = (a, l) => t(a) - l) : (e = t === Xy || t === Pme ? t : Rme, r = t, n = t);
  function i(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const h = u + c >>> 1;
        r(a[h], l) < 0 ? u = h + 1 : c = h;
      } while (u < c);
    }
    return u;
  }
  function o(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const h = u + c >>> 1;
        r(a[h], l) <= 0 ? u = h + 1 : c = h;
      } while (u < c);
    }
    return u;
  }
  function s(a, l, u = 0, c = a.length) {
    const h = i(a, l, u, c - 1);
    return h > u && n(a[h - 1], l) > -n(a[h], l) ? h - 1 : h;
  }
  return { left: i, center: s, right: o };
}
function Rme() {
  return 0;
}
function Nme(t) {
  return t === null ? NaN : +t;
}
const $me = qI(Xy), Ime = $me.right;
qI(Nme).center;
class b9 extends Map {
  constructor(e, r = zme) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null) for (const [n, i] of e) this.set(n, i);
  }
  get(e) {
    return super.get(x9(this, e));
  }
  has(e) {
    return super.has(x9(this, e));
  }
  set(e, r) {
    return super.set(Bme(this, e), r);
  }
  delete(e) {
    return super.delete(Lme(this, e));
  }
}
function x9({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : r;
}
function Bme({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : (t.set(n, r), r);
}
function Lme({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) && (r = t.get(n), t.delete(n)), r;
}
function zme(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
const jme = Math.sqrt(50), qme = Math.sqrt(10), Ume = Math.sqrt(2);
function tb(t, e, r) {
  const n = (e - t) / Math.max(0, r), i = Math.floor(Math.log10(n)), o = n / Math.pow(10, i), s = o >= jme ? 10 : o >= qme ? 5 : o >= Ume ? 2 : 1;
  let a, l, u;
  return i < 0 ? (u = Math.pow(10, -i) / s, a = Math.round(t * u), l = Math.round(e * u), a / u < t && ++a, l / u > e && --l, u = -u) : (u = Math.pow(10, i) * s, a = Math.round(t / u), l = Math.round(e / u), a * u < t && ++a, l * u > e && --l), l < a && 0.5 <= r && r < 2 ? tb(t, e, r * 2) : [a, l, u];
}
function KC(t, e, r) {
  if (e = +e, t = +t, r = +r, !(r > 0)) return [];
  if (t === e) return [t];
  const n = e < t, [i, o, s] = n ? tb(e, t, r) : tb(t, e, r);
  if (!(o >= i)) return [];
  const a = o - i + 1, l = new Array(a);
  if (n)
    if (s < 0) for (let u = 0; u < a; ++u) l[u] = (o - u) / -s;
    else for (let u = 0; u < a; ++u) l[u] = (o - u) * s;
  else if (s < 0) for (let u = 0; u < a; ++u) l[u] = (i + u) / -s;
  else for (let u = 0; u < a; ++u) l[u] = (i + u) * s;
  return l;
}
function QC(t, e, r) {
  return e = +e, t = +t, r = +r, tb(t, e, r)[2];
}
function Hme(t, e, r) {
  e = +e, t = +t, r = +r;
  const n = e < t, i = n ? QC(e, t, r) : QC(t, e, r);
  return (n ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function Vme(t, e, r) {
  t = +t, e = +e, r = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +r;
  for (var n = -1, i = Math.max(0, Math.ceil((e - t) / r)) | 0, o = new Array(i); ++n < i; )
    o[n] = t + n * r;
  return o;
}
function m0(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
const w9 = Symbol("implicit");
function UI() {
  var t = new b9(), e = [], r = [], n = w9;
  function i(o) {
    let s = t.get(o);
    if (s === void 0) {
      if (n !== w9) return n;
      t.set(o, s = e.push(o) - 1);
    }
    return r[s % r.length];
  }
  return i.domain = function(o) {
    if (!arguments.length) return e.slice();
    e = [], t = new b9();
    for (const s of o)
      t.has(s) || t.set(s, e.push(s) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (r = Array.from(o), i) : r.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (n = o, i) : n;
  }, i.copy = function() {
    return UI(e, r).unknown(n);
  }, m0.apply(i, arguments), i;
}
function HI() {
  var t = UI().unknown(void 0), e = t.domain, r = t.range, n = 0, i = 1, o, s, a = !1, l = 0, u = 0, c = 0.5;
  delete t.unknown;
  function h() {
    var d = e().length, p = i < n, g = p ? i : n, v = p ? n : i;
    o = (v - g) / Math.max(1, d - l + u * 2), a && (o = Math.floor(o)), g += (v - g - o * (d - l)) * c, s = o * (1 - l), a && (g = Math.round(g), s = Math.round(s));
    var y = Vme(d).map(function(b) {
      return g + o * b;
    });
    return r(p ? y.reverse() : y);
  }
  return t.domain = function(d) {
    return arguments.length ? (e(d), h()) : e();
  }, t.range = function(d) {
    return arguments.length ? ([n, i] = d, n = +n, i = +i, h()) : [n, i];
  }, t.rangeRound = function(d) {
    return [n, i] = d, n = +n, i = +i, a = !0, h();
  }, t.bandwidth = function() {
    return s;
  }, t.step = function() {
    return o;
  }, t.round = function(d) {
    return arguments.length ? (a = !!d, h()) : a;
  }, t.padding = function(d) {
    return arguments.length ? (l = Math.min(1, u = +d), h()) : l;
  }, t.paddingInner = function(d) {
    return arguments.length ? (l = Math.min(1, d), h()) : l;
  }, t.paddingOuter = function(d) {
    return arguments.length ? (u = +d, h()) : u;
  }, t.align = function(d) {
    return arguments.length ? (c = Math.max(0, Math.min(1, d)), h()) : c;
  }, t.copy = function() {
    return HI(e(), [n, i]).round(a).paddingInner(l).paddingOuter(u).align(c);
  }, m0.apply(h(), arguments);
}
function g0(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function gx(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function Uh() {
}
var Fg = 0.7, rb = 1 / Fg, nd = "\\s*([+-]?\\d+)\\s*", Tg = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ha = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Wme = /^#([0-9a-f]{3,8})$/, Gme = new RegExp(`^rgb\\(${nd},${nd},${nd}\\)$`), Kme = new RegExp(`^rgb\\(${Ha},${Ha},${Ha}\\)$`), Qme = new RegExp(`^rgba\\(${nd},${nd},${nd},${Tg}\\)$`), Xme = new RegExp(`^rgba\\(${Ha},${Ha},${Ha},${Tg}\\)$`), Jme = new RegExp(`^hsl\\(${Tg},${Ha},${Ha}\\)$`), Yme = new RegExp(`^hsla\\(${Tg},${Ha},${Ha},${Tg}\\)$`), k9 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
g0(Uh, Mg, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: C9,
  // Deprecated! Use color.formatHex.
  formatHex: C9,
  formatHex8: Zme,
  formatHsl: ege,
  formatRgb: _9,
  toString: _9
});
function C9() {
  return this.rgb().formatHex();
}
function Zme() {
  return this.rgb().formatHex8();
}
function ege() {
  return WI(this).formatHsl();
}
function _9() {
  return this.rgb().formatRgb();
}
function Mg(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = Wme.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? S9(e) : r === 3 ? new oi(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? hy(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? hy(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = Gme.exec(t)) ? new oi(e[1], e[2], e[3], 1) : (e = Kme.exec(t)) ? new oi(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Qme.exec(t)) ? hy(e[1], e[2], e[3], e[4]) : (e = Xme.exec(t)) ? hy(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = Jme.exec(t)) ? D9(e[1], e[2] / 100, e[3] / 100, 1) : (e = Yme.exec(t)) ? D9(e[1], e[2] / 100, e[3] / 100, e[4]) : k9.hasOwnProperty(t) ? S9(k9[t]) : t === "transparent" ? new oi(NaN, NaN, NaN, 0) : null;
}
function S9(t) {
  return new oi(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function hy(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new oi(t, e, r, n);
}
function VI(t) {
  return t instanceof Uh || (t = Mg(t)), t ? (t = t.rgb(), new oi(t.r, t.g, t.b, t.opacity)) : new oi();
}
function Pg(t, e, r, n) {
  return arguments.length === 1 ? VI(t) : new oi(t, e, r, n ?? 1);
}
function oi(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
g0(oi, Pg, gx(Uh, {
  brighter(t) {
    return t = t == null ? rb : Math.pow(rb, t), new oi(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Fg : Math.pow(Fg, t), new oi(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new oi(ah(this.r), ah(this.g), ah(this.b), nb(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: A9,
  // Deprecated! Use color.formatHex.
  formatHex: A9,
  formatHex8: tge,
  formatRgb: E9,
  toString: E9
}));
function A9() {
  return `#${Xc(this.r)}${Xc(this.g)}${Xc(this.b)}`;
}
function tge() {
  return `#${Xc(this.r)}${Xc(this.g)}${Xc(this.b)}${Xc((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function E9() {
  const t = nb(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${ah(this.r)}, ${ah(this.g)}, ${ah(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function nb(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function ah(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function Xc(t) {
  return t = ah(t), (t < 16 ? "0" : "") + t.toString(16);
}
function D9(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new js(t, e, r, n);
}
function WI(t) {
  if (t instanceof js) return new js(t.h, t.s, t.l, t.opacity);
  if (t instanceof Uh || (t = Mg(t)), !t) return new js();
  if (t instanceof js) return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, i = Math.min(e, r, n), o = Math.max(e, r, n), s = NaN, a = o - i, l = (o + i) / 2;
  return a ? (e === o ? s = (r - n) / a + (r < n) * 6 : r === o ? s = (n - e) / a + 2 : s = (e - r) / a + 4, a /= l < 0.5 ? o + i : 2 - o - i, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new js(s, a, l, t.opacity);
}
function rge(t, e, r, n) {
  return arguments.length === 1 ? WI(t) : new js(t, e, r, n ?? 1);
}
function js(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
g0(js, rge, gx(Uh, {
  brighter(t) {
    return t = t == null ? rb : Math.pow(rb, t), new js(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Fg : Math.pow(Fg, t), new js(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new oi(
      xk(t >= 240 ? t - 240 : t + 120, i, n),
      xk(t, i, n),
      xk(t < 120 ? t + 240 : t - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new js(O9(this.h), fy(this.s), fy(this.l), nb(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = nb(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${O9(this.h)}, ${fy(this.s) * 100}%, ${fy(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function O9(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function fy(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function xk(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const nge = Math.PI / 180, ige = 180 / Math.PI, ib = 18, GI = 0.96422, KI = 1, QI = 0.82521, XI = 4 / 29, id = 6 / 29, JI = 3 * id * id, oge = id * id * id;
function YI(t) {
  if (t instanceof Va) return new Va(t.l, t.a, t.b, t.opacity);
  if (t instanceof zl) return eB(t);
  t instanceof oi || (t = VI(t));
  var e = _k(t.r), r = _k(t.g), n = _k(t.b), i = wk((0.2225045 * e + 0.7168786 * r + 0.0606169 * n) / KI), o, s;
  return e === r && r === n ? o = s = i : (o = wk((0.4360747 * e + 0.3850649 * r + 0.1430804 * n) / GI), s = wk((0.0139322 * e + 0.0971045 * r + 0.7141733 * n) / QI)), new Va(116 * i - 16, 500 * (o - i), 200 * (i - s), t.opacity);
}
function ZI(t, e, r, n) {
  return arguments.length === 1 ? YI(t) : new Va(t, e, r, n ?? 1);
}
function Va(t, e, r, n) {
  this.l = +t, this.a = +e, this.b = +r, this.opacity = +n;
}
g0(Va, ZI, gx(Uh, {
  brighter(t) {
    return new Va(this.l + ib * (t ?? 1), this.a, this.b, this.opacity);
  },
  darker(t) {
    return new Va(this.l - ib * (t ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var t = (this.l + 16) / 116, e = isNaN(this.a) ? t : t + this.a / 500, r = isNaN(this.b) ? t : t - this.b / 200;
    return e = GI * kk(e), t = KI * kk(t), r = QI * kk(r), new oi(
      Ck(3.1338561 * e - 1.6168667 * t - 0.4906146 * r),
      Ck(-0.9787684 * e + 1.9161415 * t + 0.033454 * r),
      Ck(0.0719453 * e - 0.2289914 * t + 1.4052427 * r),
      this.opacity
    );
  }
}));
function wk(t) {
  return t > oge ? Math.pow(t, 1 / 3) : t / JI + XI;
}
function kk(t) {
  return t > id ? t * t * t : JI * (t - XI);
}
function Ck(t) {
  return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function _k(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function sge(t) {
  if (t instanceof zl) return new zl(t.h, t.c, t.l, t.opacity);
  if (t instanceof Va || (t = YI(t)), t.a === 0 && t.b === 0) return new zl(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var e = Math.atan2(t.b, t.a) * ige;
  return new zl(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function age(t, e, r, n) {
  return arguments.length === 1 ? sge(t) : new zl(t, e, r, n ?? 1);
}
function zl(t, e, r, n) {
  this.h = +t, this.c = +e, this.l = +r, this.opacity = +n;
}
function eB(t) {
  if (isNaN(t.h)) return new Va(t.l, 0, 0, t.opacity);
  var e = t.h * nge;
  return new Va(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
}
g0(zl, age, gx(Uh, {
  brighter(t) {
    return new zl(this.h, this.c, this.l + ib * (t ?? 1), this.opacity);
  },
  darker(t) {
    return new zl(this.h, this.c, this.l - ib * (t ?? 1), this.opacity);
  },
  rgb() {
    return eB(this).rgb();
  }
}));
function lge(t, e, r, n, i) {
  var o = t * t, s = o * t;
  return ((1 - 3 * t + 3 * o - s) * e + (4 - 6 * o + 3 * s) * r + (1 + 3 * t + 3 * o - 3 * s) * n + s * i) / 6;
}
function uge(t) {
  var e = t.length - 1;
  return function(r) {
    var n = r <= 0 ? r = 0 : r >= 1 ? (r = 1, e - 1) : Math.floor(r * e), i = t[n], o = t[n + 1], s = n > 0 ? t[n - 1] : 2 * i - o, a = n < e - 1 ? t[n + 2] : 2 * o - i;
    return lge((r - n / e) * e, s, i, o, a);
  };
}
const DS = (t) => () => t;
function cge(t, e) {
  return function(r) {
    return t + r * e;
  };
}
function hge(t, e, r) {
  return t = Math.pow(t, r), e = Math.pow(e, r) - t, r = 1 / r, function(n) {
    return Math.pow(t + n * e, r);
  };
}
function fge(t) {
  return (t = +t) == 1 ? tB : function(e, r) {
    return r - e ? hge(e, r, t) : DS(isNaN(e) ? r : e);
  };
}
function tB(t, e) {
  var r = e - t;
  return r ? cge(t, r) : DS(isNaN(t) ? e : t);
}
const F9 = (function t(e) {
  var r = fge(e);
  function n(i, o) {
    var s = r((i = Pg(i)).r, (o = Pg(o)).r), a = r(i.g, o.g), l = r(i.b, o.b), u = tB(i.opacity, o.opacity);
    return function(c) {
      return i.r = s(c), i.g = a(c), i.b = l(c), i.opacity = u(c), i + "";
    };
  }
  return n.gamma = t, n;
})(1);
function dge(t) {
  return function(e) {
    var r = e.length, n = new Array(r), i = new Array(r), o = new Array(r), s, a;
    for (s = 0; s < r; ++s)
      a = Pg(e[s]), n[s] = a.r || 0, i[s] = a.g || 0, o[s] = a.b || 0;
    return n = t(n), i = t(i), o = t(o), a.opacity = 1, function(l) {
      return a.r = n(l), a.g = i(l), a.b = o(l), a + "";
    };
  };
}
var pge = dge(uge);
function mge(t, e) {
  e || (e = []);
  var r = t ? Math.min(e.length, t.length) : 0, n = e.slice(), i;
  return function(o) {
    for (i = 0; i < r; ++i) n[i] = t[i] * (1 - o) + e[i] * o;
    return n;
  };
}
function gge(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function vge(t, e) {
  var r = e ? e.length : 0, n = t ? Math.min(r, t.length) : 0, i = new Array(n), o = new Array(r), s;
  for (s = 0; s < n; ++s) i[s] = OS(t[s], e[s]);
  for (; s < r; ++s) o[s] = e[s];
  return function(a) {
    for (s = 0; s < n; ++s) o[s] = i[s](a);
    return o;
  };
}
function yge(t, e) {
  var r = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(n) {
    return r.setTime(t * (1 - n) + e * n), r;
  };
}
function ob(t, e) {
  return t = +t, e = +e, function(r) {
    return t * (1 - r) + e * r;
  };
}
function bge(t, e) {
  var r = {}, n = {}, i;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (i in e)
    i in t ? r[i] = OS(t[i], e[i]) : n[i] = e[i];
  return function(o) {
    for (i in r) n[i] = r[i](o);
    return n;
  };
}
var XC = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Sk = new RegExp(XC.source, "g");
function xge(t) {
  return function() {
    return t;
  };
}
function wge(t) {
  return function(e) {
    return t(e) + "";
  };
}
function kge(t, e) {
  var r = XC.lastIndex = Sk.lastIndex = 0, n, i, o, s = -1, a = [], l = [];
  for (t = t + "", e = e + ""; (n = XC.exec(t)) && (i = Sk.exec(e)); )
    (o = i.index) > r && (o = e.slice(r, o), a[s] ? a[s] += o : a[++s] = o), (n = n[0]) === (i = i[0]) ? a[s] ? a[s] += i : a[++s] = i : (a[++s] = null, l.push({ i: s, x: ob(n, i) })), r = Sk.lastIndex;
  return r < e.length && (o = e.slice(r), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? l[0] ? wge(l[0].x) : xge(e) : (e = l.length, function(u) {
    for (var c = 0, h; c < e; ++c) a[(h = l[c]).i] = h.x(u);
    return a.join("");
  });
}
function OS(t, e) {
  var r = typeof e, n;
  return e == null || r === "boolean" ? DS(e) : (r === "number" ? ob : r === "string" ? (n = Mg(e)) ? (e = n, F9) : kge : e instanceof Mg ? F9 : e instanceof Date ? yge : gge(e) ? mge : Array.isArray(e) ? vge : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? bge : ob)(t, e);
}
function Cge(t, e) {
  return t = +t, e = +e, function(r) {
    return Math.round(t * (1 - r) + e * r);
  };
}
function _ge(t) {
  return function() {
    return t;
  };
}
function Sge(t) {
  return +t;
}
var T9 = [0, 1];
function Bf(t) {
  return t;
}
function JC(t, e) {
  return (e -= t = +t) ? function(r) {
    return (r - t) / e;
  } : _ge(isNaN(e) ? NaN : 0.5);
}
function Age(t, e) {
  var r;
  return t > e && (r = t, t = e, e = r), function(n) {
    return Math.max(t, Math.min(e, n));
  };
}
function Ege(t, e, r) {
  var n = t[0], i = t[1], o = e[0], s = e[1];
  return i < n ? (n = JC(i, n), o = r(s, o)) : (n = JC(n, i), o = r(o, s)), function(a) {
    return o(n(a));
  };
}
function Dge(t, e, r) {
  var n = Math.min(t.length, e.length) - 1, i = new Array(n), o = new Array(n), s = -1;
  for (t[n] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < n; )
    i[s] = JC(t[s], t[s + 1]), o[s] = r(e[s], e[s + 1]);
  return function(a) {
    var l = Ime(t, a, 1, n) - 1;
    return o[l](i[l](a));
  };
}
function FS(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function TS() {
  var t = T9, e = T9, r = OS, n, i, o, s = Bf, a, l, u;
  function c() {
    var d = Math.min(t.length, e.length);
    return s !== Bf && (s = Age(t[0], t[d - 1])), a = d > 2 ? Dge : Ege, l = u = null, h;
  }
  function h(d) {
    return d == null || isNaN(d = +d) ? o : (l || (l = a(t.map(n), e, r)))(n(s(d)));
  }
  return h.invert = function(d) {
    return s(i((u || (u = a(e, t.map(n), ob)))(d)));
  }, h.domain = function(d) {
    return arguments.length ? (t = Array.from(d, Sge), c()) : t.slice();
  }, h.range = function(d) {
    return arguments.length ? (e = Array.from(d), c()) : e.slice();
  }, h.rangeRound = function(d) {
    return e = Array.from(d), r = Cge, c();
  }, h.clamp = function(d) {
    return arguments.length ? (s = d ? !0 : Bf, c()) : s !== Bf;
  }, h.interpolate = function(d) {
    return arguments.length ? (r = d, c()) : r;
  }, h.unknown = function(d) {
    return arguments.length ? (o = d, h) : o;
  }, function(d, p) {
    return n = d, i = p, c();
  };
}
function Oge() {
  return TS()(Bf, Bf);
}
function Fge(t, e, r, n) {
  var i = Hme(t, e, r), o;
  switch (n = Og(n ?? ",f"), n.type) {
    case "s": {
      var s = Math.max(Math.abs(t), Math.abs(e));
      return n.precision == null && !isNaN(o = Tme(i, s)) && (n.precision = o), jI(n, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(o = Mme(i, Math.max(Math.abs(t), Math.abs(e)))) && (n.precision = o - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(o = Fme(i)) && (n.precision = o - (n.type === "%") * 2);
      break;
    }
  }
  return ou(n);
}
function rB(t) {
  var e = t.domain;
  return t.ticks = function(r) {
    var n = e();
    return KC(n[0], n[n.length - 1], r ?? 10);
  }, t.tickFormat = function(r, n) {
    var i = e();
    return Fge(i[0], i[i.length - 1], r ?? 10, n);
  }, t.nice = function(r) {
    r == null && (r = 10);
    var n = e(), i = 0, o = n.length - 1, s = n[i], a = n[o], l, u, c = 10;
    for (a < s && (u = s, s = a, a = u, u = i, i = o, o = u); c-- > 0; ) {
      if (u = QC(s, a, r), u === l)
        return n[i] = s, n[o] = a, e(n);
      if (u > 0)
        s = Math.floor(s / u) * u, a = Math.ceil(a / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, a = Math.floor(a * u) / u;
      else
        break;
      l = u;
    }
    return t;
  }, t;
}
function cp() {
  var t = Oge();
  return t.copy = function() {
    return FS(t, cp());
  }, m0.apply(t, arguments), rB(t);
}
function Tge(t, e) {
  t = t.slice();
  var r = 0, n = t.length - 1, i = t[r], o = t[n], s;
  return o < i && (s = r, r = n, n = s, s = i, i = o, o = s), t[r] = e.floor(i), t[n] = e.ceil(o), t;
}
function M9(t) {
  return Math.log(t);
}
function P9(t) {
  return Math.exp(t);
}
function Mge(t) {
  return -Math.log(-t);
}
function Pge(t) {
  return -Math.exp(-t);
}
function Rge(t) {
  return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t;
}
function Nge(t) {
  return t === 10 ? Rge : t === Math.E ? Math.exp : (e) => Math.pow(t, e);
}
function $ge(t) {
  return t === Math.E ? Math.log : t === 10 && Math.log10 || t === 2 && Math.log2 || (t = Math.log(t), (e) => Math.log(e) / t);
}
function R9(t) {
  return (e, r) => -t(-e, r);
}
function Ige(t) {
  const e = t(M9, P9), r = e.domain;
  let n = 10, i, o;
  function s() {
    return i = $ge(n), o = Nge(n), r()[0] < 0 ? (i = R9(i), o = R9(o), t(Mge, Pge)) : t(M9, P9), e;
  }
  return e.base = function(a) {
    return arguments.length ? (n = +a, s()) : n;
  }, e.domain = function(a) {
    return arguments.length ? (r(a), s()) : r();
  }, e.ticks = (a) => {
    const l = r();
    let u = l[0], c = l[l.length - 1];
    const h = c < u;
    h && ([u, c] = [c, u]);
    let d = i(u), p = i(c), g, v;
    const y = a == null ? 10 : +a;
    let b = [];
    if (!(n % 1) && p - d < y) {
      if (d = Math.floor(d), p = Math.ceil(p), u > 0) {
        for (; d <= p; ++d)
          for (g = 1; g < n; ++g)
            if (v = d < 0 ? g / o(-d) : g * o(d), !(v < u)) {
              if (v > c) break;
              b.push(v);
            }
      } else for (; d <= p; ++d)
        for (g = n - 1; g >= 1; --g)
          if (v = d > 0 ? g / o(-d) : g * o(d), !(v < u)) {
            if (v > c) break;
            b.push(v);
          }
      b.length * 2 < y && (b = KC(u, c, y));
    } else
      b = KC(d, p, Math.min(p - d, y)).map(o);
    return h ? b.reverse() : b;
  }, e.tickFormat = (a, l) => {
    if (a == null && (a = 10), l == null && (l = n === 10 ? "s" : ","), typeof l != "function" && (!(n % 1) && (l = Og(l)).precision == null && (l.trim = !0), l = ou(l)), a === 1 / 0) return l;
    const u = Math.max(1, n * a / e.ticks().length);
    return (c) => {
      let h = c / o(Math.round(i(c)));
      return h * n < n - 0.5 && (h *= n), h <= u ? l(c) : "";
    };
  }, e.nice = () => r(Tge(r(), {
    floor: (a) => o(Math.floor(i(a))),
    ceil: (a) => o(Math.ceil(i(a)))
  })), e;
}
function Rg() {
  const t = Ige(TS()).domain([1, 10]);
  return t.copy = () => FS(t, Rg()).base(t.base()), m0.apply(t, arguments), t;
}
function N9(t) {
  return function(e) {
    return Math.sign(e) * Math.log1p(Math.abs(e / t));
  };
}
function $9(t) {
  return function(e) {
    return Math.sign(e) * Math.expm1(Math.abs(e)) * t;
  };
}
function Bge(t) {
  var e = 1, r = t(N9(e), $9(e));
  return r.constant = function(n) {
    return arguments.length ? t(N9(e = +n), $9(e)) : e;
  }, rB(r);
}
function nB() {
  var t = Bge(TS());
  return t.copy = function() {
    return FS(t, nB()).constant(t.constant());
  }, m0.apply(t, arguments);
}
function hp(t) {
  for (var e = t.length / 6 | 0, r = new Array(e), n = 0; n < e; ) r[n] = "#" + t.slice(n * 6, ++n * 6);
  return r;
}
const iB = (t) => pge(t[t.length - 1]);
var Lge = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(hp);
const zge = iB(Lge);
var jge = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(hp);
const qge = iB(jge);
function Uge(t) {
  return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}
function vx(t) {
  var e = t.length;
  return function(r) {
    return t[Math.max(0, Math.min(e - 1, Math.floor(r * e)))];
  };
}
vx(hp("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
vx(hp("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var oB = vx(hp("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
vx(hp("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
var $s = { slate: { 300: "oklch(86.9% 0.022 252.894)", 400: "oklch(70.4% 0.04 256.788)", 500: "oklch(55.4% 0.046 257.417)", 700: "oklch(37.2% 0.044 257.287)" }, gray: { 500: "oklch(55.1% 0.027 264.364)" } };
function sB() {
  return !(navigator.gpu == null || navigator.gpu.requestAdapter == null);
}
function Hge(t) {
  return t == 0 && (t = 4), t % 4 != 0 && (t += 4 - t % 4), t;
}
function od(t, e, r, n) {
  return (t.buffer == null || t.byteSize != r || t.usage != n) && (t.buffer != null && t.buffer.destroy(), t.buffer = e.createBuffer({ size: Hge(r), usage: n }), t.byteSize = r, t.destroy = () => {
    t.buffer?.destroy();
  }), t.buffer;
}
function Ak(t, e, r, n) {
  if (t.buffer !== r || t.data !== n) {
    if (n != null)
      if (n.byteLength % 4 != 0) {
        let i = n.byteLength - n.byteLength % 4;
        if (e.queue.writeBuffer(r, 0, n, 0, i), n instanceof Uint8Array) {
          let o = new Uint8Array(4);
          for (let s = 0; s < 4; s++)
            i + s < n.length && (o[s] = n[i + s]);
          e.queue.writeBuffer(r, i, o);
        }
      } else
        e.queue.writeBuffer(r, 0, n, 0);
    else
      e.queue.writeBuffer(r, 0, new ArrayBuffer(r.size));
    t.buffer = r, t.data = n;
  }
  return r;
}
function I9(t, e, r, n, i, o) {
  return (t.texture == null || t.width != r || t.height != n || t.format != i || t.usage != o) && (t.texture != null && t.texture.destroy(), t.texture = e.createTexture({ size: [r, n], format: i, usage: o }), t.destroy = () => {
    t.texture?.destroy();
  }), t.texture;
}
const vi = 2, yx = 4, bx = 8, su = 16, au = 32, Hh = 64, xx = 128, Ys = 512, si = 1024, ho = 2048, lu = 4096, Ho = 8192, Ku = 16384, wx = 32768, Rd = 65536, B9 = 1 << 17, aB = 1 << 18, fp = 1 << 19, lB = 1 << 20, Ng = 32768, YC = 1 << 21, MS = 1 << 22, Qu = 1 << 23, lh = Symbol("$state"), uB = Symbol("legacy props"), Vge = Symbol(""), Lf = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), PS = 3, dp = 8, Wge = !1;
var cB = Array.isArray, Gge = Array.prototype.indexOf, RS = Array.from, hB = Object.defineProperty, sd = Object.getOwnPropertyDescriptor, fB = Object.getOwnPropertyDescriptors, Kge = Object.prototype, Qge = Array.prototype, NS = Object.getPrototypeOf, L9 = Object.isExtensible;
function Xge(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function dB() {
  var t, e, r = new Promise((n, i) => {
    t = n, e = i;
  });
  return { promise: r, resolve: t, reject: e };
}
function pB(t) {
  return t === this.v;
}
function mB(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function gB(t) {
  return !mB(t, this.v);
}
function vB(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function Jge() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function Yge(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Zge() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function e0e(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function t0e() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function r0e() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function n0e(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function i0e() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function o0e() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function s0e() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function a0e() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let l0e = !1;
const $S = 1, IS = 2, yB = 4, u0e = 8, c0e = 16, h0e = 1, f0e = 4, d0e = 8, p0e = 16, m0e = 1, g0e = 2, bB = "[", kx = "[!", BS = "]", Nd = {}, Zn = Symbol(), v0e = "http://www.w3.org/1999/xhtml";
let fo = null;
function $d(t) {
  fo = t;
}
function Vh(t, e = !1, r) {
  fo = {
    p: fo,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: null
  };
}
function Wh(t) {
  var e = (
    /** @type {ComponentContext} */
    fo
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      GB(n);
  }
  return e.i = !0, fo = e.p, /** @type {T} */
  {};
}
function xB() {
  return !0;
}
let Jc = [];
function wB() {
  var t = Jc;
  Jc = [], Xge(t);
}
function pp(t) {
  if (Jc.length === 0 && !$m) {
    var e = Jc;
    queueMicrotask(() => {
      e === Jc && wB();
    });
  }
  Jc.push(t);
}
function y0e() {
  for (; Jc.length > 0; )
    wB();
}
function Cx(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function b0e() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let or = !1;
function jl(t) {
  or = t;
}
let Zt;
function oo(t) {
  if (t === null)
    throw Cx(), Nd;
  return Zt = t;
}
function v0() {
  return oo(
    /** @type {TemplateNode} */
    /* @__PURE__ */ ul(Zt)
  );
}
function yn(t) {
  if (or) {
    if (/* @__PURE__ */ ul(Zt) !== null)
      throw Cx(), Nd;
    Zt = t;
  }
}
function kB(t = 1) {
  if (or) {
    for (var e = t, r = Zt; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ ul(r);
    Zt = r;
  }
}
function sb(t = !0) {
  for (var e = 0, r = Zt; ; ) {
    if (r.nodeType === dp) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === BS) {
        if (e === 0) return r;
        e -= 1;
      } else (n === bB || n === kx) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ul(r)
    );
    t && r.remove(), r = i;
  }
}
function CB(t) {
  if (!t || t.nodeType !== dp)
    throw Cx(), Nd;
  return (
    /** @type {Comment} */
    t.data
  );
}
function Yc(t) {
  if (typeof t != "object" || t === null || lh in t)
    return t;
  const e = NS(t);
  if (e !== Kge && e !== Qge)
    return t;
  var r = /* @__PURE__ */ new Map(), n = cB(t), i = /* @__PURE__ */ Mr(0), o = ch, s = (a) => {
    if (ch === o)
      return a();
    var l = Jt, u = ch;
    ro(null), H9(o);
    var c = a();
    return ro(l), H9(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ Mr(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && i0e();
        var c = r.get(l);
        return c === void 0 ? c = s(() => {
          var h = /* @__PURE__ */ Mr(u.value);
          return r.set(l, h), h;
        }) : dt(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = s(() => /* @__PURE__ */ Mr(Zn));
            r.set(l, c), Im(i);
          }
        } else
          dt(u, Zn), Im(i);
        return !0;
      },
      get(a, l, u) {
        if (l === lh)
          return t;
        var c = r.get(l), h = l in a;
        if (c === void 0 && (!h || sd(a, l)?.writable) && (c = s(() => {
          var p = Yc(h ? a[l] : Zn), g = /* @__PURE__ */ Mr(p);
          return g;
        }), r.set(l, c)), c !== void 0) {
          var d = W(c);
          return d === Zn ? void 0 : d;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = W(c));
        } else if (u === void 0) {
          var h = r.get(l), d = h?.v;
          if (h !== void 0 && d !== Zn)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === lh)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== Zn || Reflect.has(a, l);
        if (u !== void 0 || sr !== null && (!c || sd(a, l)?.writable)) {
          u === void 0 && (u = s(() => {
            var d = c ? Yc(a[l]) : Zn, p = /* @__PURE__ */ Mr(d);
            return p;
          }), r.set(l, u));
          var h = W(u);
          if (h === Zn)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var h = r.get(l), d = l in a;
        if (n && l === "length")
          for (var p = u; p < /** @type {Source<number>} */
          h.v; p += 1) {
            var g = r.get(p + "");
            g !== void 0 ? dt(g, Zn) : p in a && (g = s(() => /* @__PURE__ */ Mr(Zn)), r.set(p + "", g));
          }
        if (h === void 0)
          (!d || sd(a, l)?.writable) && (h = s(() => /* @__PURE__ */ Mr(void 0)), dt(h, Yc(u)), r.set(l, h));
        else {
          d = h.v !== Zn;
          var v = s(() => Yc(u));
          dt(h, v);
        }
        var y = Reflect.getOwnPropertyDescriptor(a, l);
        if (y?.set && y.set.call(c, u), !d) {
          if (n && typeof l == "string") {
            var b = (
              /** @type {Source<number>} */
              r.get("length")
            ), k = Number(l);
            Number.isInteger(k) && k >= b.v && dt(b, k + 1);
          }
          Im(i);
        }
        return !0;
      },
      ownKeys(a) {
        W(i);
        var l = Reflect.ownKeys(a).filter((h) => {
          var d = r.get(h);
          return d === void 0 || d.v !== Zn;
        });
        for (var [u, c] of r)
          c.v !== Zn && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        o0e();
      }
    }
  );
}
var z9, _B, SB, AB;
function ZC() {
  if (z9 === void 0) {
    z9 = window, _B = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    SB = sd(e, "firstChild").get, AB = sd(e, "nextSibling").get, L9(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), L9(r) && (r.__t = void 0);
  }
}
function Ya(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Yl(t) {
  return SB.call(t);
}
// @__NO_SIDE_EFFECTS__
function ul(t) {
  return AB.call(t);
}
function $n(t, e) {
  if (!or)
    return /* @__PURE__ */ Yl(t);
  var r = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ Yl(Zt)
  );
  if (r === null)
    r = Zt.appendChild(Ya());
  else if (e && r.nodeType !== PS) {
    var n = Ya();
    return r?.before(n), oo(n), n;
  }
  return oo(r), r;
}
function Df(t, e = !1) {
  if (!or) {
    var r = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Yl(
        /** @type {Node} */
        t
      )
    );
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ ul(r) : r;
  }
  if (e && Zt?.nodeType !== PS) {
    var n = Ya();
    return Zt?.before(n), oo(n), n;
  }
  return Zt;
}
function Ur(t, e = 1, r = !1) {
  let n = or ? Zt : t;
  for (var i; e--; )
    i = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ ul(n);
  if (!or)
    return n;
  if (r && n?.nodeType !== PS) {
    var o = Ya();
    return n === null ? i?.after(o) : n.before(o), oo(o), o;
  }
  return oo(n), /** @type {TemplateNode} */
  n;
}
function EB(t) {
  t.textContent = "";
}
function DB(t) {
  var e = sr;
  if (e === null)
    return Jt.f |= Qu, t;
  if ((e.f & wx) === 0) {
    if ((e.f & xx) === 0)
      throw t;
    e.b.error(t);
  } else
    Id(t, e);
}
function Id(t, e) {
  for (; e !== null; ) {
    if ((e.f & xx) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const dy = /* @__PURE__ */ new Set();
let _n = null, Io = null, Oa = [], _x = null, e_ = !1, $m = !1, Zc = class t_ {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #l = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #a = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Oa = [], this.apply();
    var r = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const n of e)
      this.#o(n, r);
    this.is_fork || this.#u(), this.#n > 0 || this.is_fork ? (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects)) : (_n = null, j9(r.render_effects), j9(r.effects), this.#l?.resolve()), Io = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(e, r) {
    e.f ^= si;
    for (var n = e.first; n !== null; ) {
      var i = n.f, o = (i & (au | Hh)) !== 0, s = o && (i & si) !== 0, a = s || (i & Ho) !== 0 || this.skipped_effects.has(n);
      if ((n.f & xx) !== 0 && n.b?.is_pending() && (r = {
        parent: r,
        effect: n,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !a && n.fn !== null) {
        o ? n.f ^= si : (i & yx) !== 0 ? r.effects.push(n) : y0(n) && ((n.f & su) !== 0 && r.block_effects.push(n), Ig(n));
        var l = n.first;
        if (l !== null) {
          n = l;
          continue;
        }
      }
      var u = n.parent;
      for (n = n.next; n === null && u !== null; )
        u === r.effect && (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects), r = /** @type {EffectTarget} */
        r.parent), n = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #s(e) {
    for (const r of e)
      ((r.f & ho) !== 0 ? this.#a : this.#i).push(r), fi(r, si);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    this.previous.has(e) || this.previous.set(e, r), (e.f & Qu) === 0 && (this.current.set(e, e.v), Io?.set(e, e.v));
  }
  activate() {
    _n = this, this.apply();
  }
  deactivate() {
    _n = null, Io = null;
  }
  flush() {
    if (this.activate(), Oa.length > 0) {
      if (OB(), _n !== null && _n !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#n === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#r === 0 && this.#c();
  }
  #c() {
    if (dy.size > 1) {
      this.previous.clear();
      var e = Io, r = !0, n = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of dy) {
        if (i === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (i.current.has(a))
            if (r && l !== i.current.get(a))
              i.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const s = [...i.current.keys()].filter((a) => !this.current.has(a));
        if (s.length > 0) {
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            FB(u, s, a, l);
          if (Oa.length > 0) {
            _n = i, i.apply();
            for (const u of Oa)
              i.#o(u, n);
            Oa = [], i.deactivate();
          }
        }
      }
      _n = null, Io = e;
    }
    this.committed = !0, dy.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), this.revive();
  }
  revive() {
    for (const e of this.#a)
      fi(e, ho), Sh(e);
    for (const e of this.#i)
      fi(e, lu), Sh(e);
    this.#a = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#l ??= dB()).promise;
  }
  static ensure() {
    if (_n === null) {
      const e = _n = new t_();
      dy.add(_n), $m || t_.enqueue(() => {
        _n === e && e.flush();
      });
    }
    return _n;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    pp(e);
  }
  apply() {
  }
};
function x0e(t) {
  var e = $m;
  $m = !0;
  try {
    for (var r; ; ) {
      if (y0e(), Oa.length === 0 && (_n?.flush(), Oa.length === 0))
        return _x = null, /** @type {T} */
        r;
      OB();
    }
  } finally {
    $m = e;
  }
}
function OB() {
  var t = uh;
  e_ = !0;
  try {
    var e = 0;
    for (q9(!0); Oa.length > 0; ) {
      var r = Zc.ensure();
      if (e++ > 1e3) {
        var n, i;
        w0e();
      }
      r.process(Oa), Xu.clear();
    }
  } finally {
    e_ = !1, q9(t), _x = null;
  }
}
function w0e() {
  try {
    t0e();
  } catch (t) {
    Id(t, _x);
  }
}
let Fl = null;
function j9(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (Ku | Ho)) === 0 && y0(n) && (Fl = /* @__PURE__ */ new Set(), Ig(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null && n.ac === null ? JB(n) : n.fn = null), Fl?.size > 0)) {
        Xu.clear();
        for (const i of Fl) {
          if ((i.f & (Ku | Ho)) !== 0) continue;
          const o = [i];
          let s = i.parent;
          for (; s !== null; )
            Fl.has(s) && (Fl.delete(s), o.push(s)), s = s.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (Ku | Ho)) === 0 && Ig(l);
          }
        }
        Fl.clear();
      }
    }
    Fl = null;
  }
}
function FB(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const o = i.f;
      (o & vi) !== 0 ? FB(
        /** @type {Derived} */
        i,
        e,
        r,
        n
      ) : (o & (MS | su)) !== 0 && (o & ho) === 0 && // we may have scheduled this one already
      TB(i, e, n) && (fi(i, ho), Sh(
        /** @type {Effect} */
        i
      ));
    }
}
function TB(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & vi) !== 0 && TB(
        /** @type {Derived} */
        i,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function Sh(t) {
  for (var e = _x = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (e_ && e === sr && (r & su) !== 0 && (r & aB) === 0)
      return;
    if ((r & (Hh | au)) !== 0) {
      if ((r & si) === 0) return;
      e.f ^= si;
    }
  }
  Oa.push(e);
}
function k0e(t) {
  let e = 0, r = Ah(0), n;
  return () => {
    Ax() && (W(r), jS(() => (e === 0 && (n = Kh(() => t(() => Im(r)))), e += 1, () => {
      pp(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Im(r));
      });
    })));
  };
}
var C0e = Rd | fp | xx;
function _0e(t, e, r) {
  new S0e(t, e, r);
}
class S0e {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #r = or ? Zt : null;
  /** @type {BoundaryProps} */
  #n;
  /** @type {((anchor: Node) => void)} */
  #l;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #h = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #f = null;
  #v = k0e(() => (this.#f = Ah(this.#d), () => {
    this.#f = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#t = e, this.#n = r, this.#l = n, this.parent = /** @type {Effect} */
    sr.b, this.#e = !!this.#n.pending, this.#a = Ex(() => {
      if (sr.b = this, or) {
        const o = this.#r;
        v0(), /** @type {Comment} */
        o.nodeType === dp && /** @type {Comment} */
        o.data === kx ? this.#b() : this.#y();
      } else {
        var i = this.#x();
        try {
          this.#i = Is(() => n(i));
        } catch (o) {
          this.error(o);
        }
        this.#h > 0 ? this.#g() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, C0e), or && (this.#t = Zt);
  }
  #y() {
    try {
      this.#i = Is(() => this.#l(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #b() {
    const e = this.#n.pending;
    e && (this.#o = Is(() => e(this.#t)), Zc.enqueue(() => {
      var r = this.#x();
      this.#i = this.#m(() => (Zc.ensure(), Is(() => this.#l(r)))), this.#h > 0 ? this.#g() : (ad(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = Ya(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#n.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(e) {
    var r = sr, n = Jt, i = fo;
    Za(this.#a), ro(this.#a), $d(this.#a.ctx);
    try {
      return e();
    } catch (o) {
      return DB(o), null;
    } finally {
      Za(r), ro(n), $d(i);
    }
  }
  #g() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#n.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), eL(this.#i, this.#u)), this.#o === null && (this.#o = Is(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#h += e, this.#h === 0 && (this.#e = !1, this.#o && ad(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#f && Bd(this.#f, this.#d);
  }
  get_effect_pending() {
    return this.#v(), W(
      /** @type {Source<number>} */
      this.#f
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#n.onerror;
    let n = this.#n.failed;
    if (this.#p || !r && !n)
      throw e;
    this.#i && (Ii(this.#i), this.#i = null), this.#o && (Ii(this.#o), this.#o = null), this.#s && (Ii(this.#s), this.#s = null), or && (oo(
      /** @type {TemplateNode} */
      this.#r
    ), kB(), oo(sb()));
    var i = !1, o = !1;
    const s = () => {
      if (i) {
        b0e();
        return;
      }
      i = !0, o && a0e(), Zc.ensure(), this.#d = 0, this.#s !== null && ad(this.#s, () => {
        this.#s = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#m(() => (this.#p = !1, Is(() => this.#l(this.#t)))), this.#h > 0 ? this.#g() : this.#e = !1;
    };
    var a = Jt;
    try {
      ro(null), o = !0, r?.(e, s), o = !1;
    } catch (l) {
      Id(l, this.#a && this.#a.parent);
    } finally {
      ro(a);
    }
    n && pp(() => {
      this.#s = this.#m(() => {
        Zc.ensure(), this.#p = !0;
        try {
          return Is(() => {
            n(
              this.#t,
              () => e,
              () => s
            );
          });
        } catch (l) {
          return Id(
            l,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function A0e(t, e, r, n) {
  const i = Sx;
  if (r.length === 0 && t.length === 0) {
    n(e.map(i));
    return;
  }
  var o = _n, s = (
    /** @type {Effect} */
    sr
  ), a = E0e();
  function l() {
    Promise.all(r.map((u) => /* @__PURE__ */ D0e(u))).then((u) => {
      a();
      try {
        n([...e.map(i), ...u]);
      } catch (c) {
        (s.f & Ku) === 0 && Id(c, s);
      }
      o?.deactivate(), ab();
    }).catch((u) => {
      Id(u, s);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    a();
    try {
      return l();
    } finally {
      o?.deactivate(), ab();
    }
  }) : l();
}
function E0e() {
  var t = sr, e = Jt, r = fo, n = _n;
  return function(i = !0) {
    Za(t), ro(e), $d(r), i && n?.activate();
  };
}
function ab() {
  Za(null), ro(null), $d(null);
}
// @__NO_SIDE_EFFECTS__
function Sx(t) {
  var e = vi | ho, r = Jt !== null && (Jt.f & vi) !== 0 ? (
    /** @type {Derived} */
    Jt
  ) : null;
  return sr !== null && (sr.f |= fp), {
    ctx: fo,
    deps: null,
    effects: null,
    equals: pB,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      Zn
    ),
    wv: 0,
    parent: r ?? sr,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function D0e(t, e) {
  let r = (
    /** @type {Effect | null} */
    sr
  );
  r === null && Jge();
  var n = (
    /** @type {Boundary} */
    r.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), o = Ah(
    /** @type {V} */
    Zn
  ), s = !Jt, a = /* @__PURE__ */ new Map();
  return I0e(() => {
    var l = dB();
    i = l.promise;
    try {
      Promise.resolve(t()).then(l.resolve, l.reject).then(() => {
        u === _n && u.committed && u.deactivate(), ab();
      });
    } catch (d) {
      l.reject(d), ab();
    }
    var u = (
      /** @type {Batch} */
      _n
    );
    if (s) {
      var c = !n.is_pending();
      n.update_pending_count(1), u.increment(c), a.get(u)?.reject(Lf), a.delete(u), a.set(u, l);
    }
    const h = (d, p = void 0) => {
      if (u.activate(), p)
        p !== Lf && (o.f |= Qu, Bd(o, p));
      else {
        (o.f & Qu) !== 0 && (o.f ^= Qu), Bd(o, d);
        for (const [g, v] of a) {
          if (a.delete(g), g === u) break;
          v.reject(Lf);
        }
      }
      s && (n.update_pending_count(-1), u.decrement(c));
    };
    l.promise.then(h, (d) => h(null, d || "unknown"));
  }), WB(() => {
    for (const l of a.values())
      l.reject(Lf);
  }), new Promise((l) => {
    function u(c) {
      function h() {
        c === i ? l(o) : u(i);
      }
      c.then(h, h);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function gt(t) {
  const e = /* @__PURE__ */ Sx(t);
  return BB(e), e;
}
// @__NO_SIDE_EFFECTS__
function MB(t) {
  const e = /* @__PURE__ */ Sx(t);
  return e.equals = gB, e;
}
function PB(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Ii(
        /** @type {Effect} */
        e[r]
      );
  }
}
function O0e(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & vi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function LS(t) {
  var e, r = sr;
  Za(O0e(t));
  try {
    t.f &= ~Ng, PB(t), e = qB(t);
  } finally {
    Za(r);
  }
  return e;
}
function RB(t) {
  var e = LS(t);
  if (t.equals(e) || (t.v = e, t.wv = zB()), !Gh)
    if (Io !== null)
      Ax() && Io.set(t, t.v);
    else {
      var r = (t.f & Ys) === 0 ? lu : si;
      fi(t, r);
    }
}
let r_ = /* @__PURE__ */ new Set();
const Xu = /* @__PURE__ */ new Map();
let NB = !1;
function Ah(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: pB,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function Mr(t, e) {
  const r = Ah(t);
  return BB(r), r;
}
// @__NO_SIDE_EFFECTS__
function $B(t, e = !1, r = !0) {
  const n = Ah(t);
  return e || (n.equals = gB), n;
}
function dt(t, e, r = !1) {
  Jt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Ba || (Jt.f & B9) !== 0) && xB() && (Jt.f & (vi | su | MS | B9)) !== 0 && !Gl?.includes(t) && s0e();
  let n = r ? Yc(e) : e;
  return Bd(t, n);
}
function Bd(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Gh ? Xu.set(t, e) : Xu.set(t, r), t.v = e;
    var n = Zc.ensure();
    n.capture(t, r), (t.f & vi) !== 0 && ((t.f & ho) !== 0 && LS(
      /** @type {Derived} */
      t
    ), fi(t, (t.f & Ys) !== 0 ? si : lu)), t.wv = zB(), IB(t, ho), sr !== null && (sr.f & si) !== 0 && (sr.f & (au | Hh)) === 0 && (ls === null ? T0e([t]) : ls.push(t)), !n.is_fork && r_.size > 0 && !NB && F0e();
  }
  return e;
}
function F0e() {
  NB = !1;
  const t = Array.from(r_);
  for (const e of t)
    (e.f & si) !== 0 && fi(e, lu), y0(e) && Ig(e);
  r_.clear();
}
function Im(t) {
  dt(t, t.v + 1);
}
function IB(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = r.length, i = 0; i < n; i++) {
      var o = r[i], s = o.f, a = (s & ho) === 0;
      if (a && fi(o, e), (s & vi) !== 0) {
        var l = (
          /** @type {Derived} */
          o
        );
        Io?.delete(l), (s & Ng) === 0 && (s & Ys && (o.f |= Ng), IB(l, lu));
      } else a && ((s & su) !== 0 && Fl !== null && Fl.add(
        /** @type {Effect} */
        o
      ), Sh(
        /** @type {Effect} */
        o
      ));
    }
}
function zS(t) {
  var e = Jt, r = sr;
  ro(null), Za(null);
  try {
    return t();
  } finally {
    ro(e), Za(r);
  }
}
let uh = !1;
function q9(t) {
  uh = t;
}
let Gh = !1;
function U9(t) {
  Gh = t;
}
let Jt = null, Ba = !1;
function ro(t) {
  Jt = t;
}
let sr = null;
function Za(t) {
  sr = t;
}
let Gl = null;
function BB(t) {
  Jt !== null && (Gl === null ? Gl = [t] : Gl.push(t));
}
let Ei = null, Oo = 0, ls = null;
function T0e(t) {
  ls = t;
}
let LB = 1, $g = 0, ch = $g;
function H9(t) {
  ch = t;
}
function zB() {
  return ++LB;
}
function y0(t) {
  var e = t.f;
  if ((e & ho) !== 0)
    return !0;
  if (e & vi && (t.f &= ~Ng), (e & lu) !== 0) {
    var r = t.deps;
    if (r !== null)
      for (var n = r.length, i = 0; i < n; i++) {
        var o = r[i];
        if (y0(
          /** @type {Derived} */
          o
        ) && RB(
          /** @type {Derived} */
          o
        ), o.wv > t.wv)
          return !0;
      }
    (e & Ys) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Io === null && fi(t, si);
  }
  return !1;
}
function jB(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !Gl?.includes(t))
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      (o.f & vi) !== 0 ? jB(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? fi(o, ho) : (o.f & si) !== 0 && fi(o, lu), Sh(
        /** @type {Effect} */
        o
      ));
    }
}
function qB(t) {
  var e = Ei, r = Oo, n = ls, i = Jt, o = Gl, s = fo, a = Ba, l = ch, u = t.f;
  Ei = /** @type {null | Value[]} */
  null, Oo = 0, ls = null, Jt = (u & (au | Hh)) === 0 ? t : null, Gl = null, $d(t.ctx), Ba = !1, ch = ++$g, t.ac !== null && (zS(() => {
    t.ac.abort(Lf);
  }), t.ac = null);
  try {
    t.f |= YC;
    var c = (
      /** @type {Function} */
      t.fn
    ), h = c(), d = t.deps;
    if (Ei !== null) {
      var p;
      if (lb(t, Oo), d !== null && Oo > 0)
        for (d.length = Oo + Ei.length, p = 0; p < Ei.length; p++)
          d[Oo + p] = Ei[p];
      else
        t.deps = d = Ei;
      if (uh && Ax() && (t.f & Ys) !== 0)
        for (p = Oo; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Oo < d.length && (lb(t, Oo), d.length = Oo);
    if (xB() && ls !== null && !Ba && d !== null && (t.f & (vi | lu | ho)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      ls.length; p++)
        jB(
          ls[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && ($g++, ls !== null && (n === null ? n = ls : n.push(.../** @type {Source[]} */
    ls))), (t.f & Qu) !== 0 && (t.f ^= Qu), h;
  } catch (g) {
    return DB(g);
  } finally {
    t.f ^= YC, Ei = e, Oo = r, ls = n, Jt = i, Gl = o, $d(s), Ba = a, ch = l;
  }
}
function M0e(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = Gge.call(r, t);
    if (n !== -1) {
      var i = r.length - 1;
      i === 0 ? r = e.reactions = null : (r[n] = r[i], r.pop());
    }
  }
  r === null && (e.f & vi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Ei === null || !Ei.includes(e)) && (fi(e, lu), (e.f & Ys) !== 0 && (e.f ^= Ys, e.f &= ~Ng), PB(
    /** @type {Derived} **/
    e
  ), lb(
    /** @type {Derived} **/
    e,
    0
  ));
}
function lb(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      M0e(t, r[n]);
}
function Ig(t) {
  var e = t.f;
  if ((e & Ku) === 0) {
    fi(t, si);
    var r = sr, n = uh;
    sr = t, uh = !0;
    try {
      (e & su) !== 0 ? B0e(t) : XB(t), QB(t);
      var i = qB(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = LB;
      var o;
      Wge && l0e && (t.f & ho) !== 0 && t.deps;
    } finally {
      uh = n, sr = r;
    }
  }
}
function W(t) {
  var e = t.f, r = (e & vi) !== 0;
  if (Jt !== null && !Ba) {
    var n = sr !== null && (sr.f & Ku) !== 0;
    if (!n && !Gl?.includes(t)) {
      var i = Jt.deps;
      if ((Jt.f & YC) !== 0)
        t.rv < $g && (t.rv = $g, Ei === null && i !== null && i[Oo] === t ? Oo++ : Ei === null ? Ei = [t] : Ei.includes(t) || Ei.push(t));
      else {
        (Jt.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Jt] : o.includes(Jt) || o.push(Jt);
      }
    }
  }
  if (Gh) {
    if (Xu.has(t))
      return Xu.get(t);
    if (r) {
      var s = (
        /** @type {Derived} */
        t
      ), a = s.v;
      return ((s.f & si) === 0 && s.reactions !== null || HB(s)) && (a = LS(s)), Xu.set(s, a), a;
    }
  } else if (r) {
    if (s = /** @type {Derived} */
    t, Io?.has(s))
      return Io.get(s);
    y0(s) && RB(s), uh && Ax() && (s.f & Ys) === 0 && UB(s);
  } else if (Io?.has(t))
    return Io.get(t);
  if ((t.f & Qu) !== 0)
    throw t.v;
  return t.v;
}
function UB(t) {
  if (t.deps !== null) {
    t.f ^= Ys;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & vi) !== 0 && (e.f & Ys) === 0 && UB(
        /** @type {Derived} */
        e
      );
  }
}
function HB(t) {
  if (t.v === Zn) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Xu.has(e) || (e.f & vi) !== 0 && HB(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function Kh(t) {
  var e = Ba;
  try {
    return Ba = !0, t();
  } finally {
    Ba = e;
  }
}
const P0e = -7169;
function fi(t, e) {
  t.f = t.f & P0e | e;
}
function R0e(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (lh in t)
      n_(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && lh in r && n_(r);
      }
  }
}
function n_(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        n_(t[n], e);
      } catch {
      }
    const r = NS(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = fB(r);
      for (let i in n) {
        const o = n[i].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
function VB(t) {
  sr === null && (Jt === null && e0e(), Zge()), Gh && Yge();
}
function N0e(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function cl(t, e, r, n = !0) {
  var i = sr;
  i !== null && (i.f & Ho) !== 0 && (t |= Ho);
  var o = {
    ctx: fo,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | ho | Ys,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      Ig(o), o.f |= wx;
    } catch (l) {
      throw Ii(o), l;
    }
  else e !== null && Sh(o);
  if (n) {
    var s = o;
    if (r && s.deps === null && s.teardown === null && s.nodes_start === null && s.first === s.last && // either `null`, or a singular child
    (s.f & fp) === 0 && (s = s.first, (t & su) !== 0 && (t & Rd) !== 0 && s !== null && (s.f |= Rd)), s !== null && (s.parent = i, i !== null && N0e(s, i), Jt !== null && (Jt.f & vi) !== 0 && (t & Hh) === 0)) {
      var a = (
        /** @type {Derived} */
        Jt
      );
      (a.effects ??= []).push(s);
    }
  }
  return o;
}
function Ax() {
  return Jt !== null && !Ba;
}
function WB(t) {
  const e = cl(bx, null, !1);
  return fi(e, si), e.teardown = t, e;
}
function El(t) {
  VB();
  var e = (
    /** @type {Effect} */
    sr.f
  ), r = !Jt && (e & au) !== 0 && (e & wx) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      fo
    );
    (n.e ??= []).push(t);
  } else
    return GB(t);
}
function GB(t) {
  return cl(yx | lB, t, !1);
}
function Bm(t) {
  return VB(), cl(bx | lB, t, !0);
}
function $0e(t) {
  Zc.ensure();
  const e = cl(Hh | fp, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? ad(e, () => {
      Ii(e), n(void 0);
    }) : (Ii(e), n(void 0));
  });
}
function KB(t) {
  return cl(yx, t, !1);
}
function I0e(t) {
  return cl(MS | fp, t, !0);
}
function jS(t, e = 0) {
  return cl(bx | e, t, !0);
}
function Bo(t, e = [], r = [], n = [], i = !1) {
  A0e(n, e, r, (o) => {
    cl(i ? yx : bx, () => t(...o.map(W)), !0);
  });
}
function Ex(t, e = 0) {
  var r = cl(su | e, t, !0);
  return r;
}
function Is(t, e = !0) {
  return cl(au | fp, t, !0, e);
}
function QB(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Gh, n = Jt;
    U9(!0), ro(null);
    try {
      e.call(null);
    } finally {
      U9(r), ro(n);
    }
  }
}
function XB(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const i = r.ac;
    i !== null && zS(() => {
      i.abort(Lf);
    });
    var n = r.next;
    (r.f & Hh) !== 0 ? r.parent = null : Ii(r, e), r = n;
  }
}
function B0e(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & au) === 0 && Ii(e), e = r;
  }
}
function Ii(t, e = !0) {
  var r = !1;
  (e || (t.f & aB) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (L0e(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), r = !0), XB(t, e && !r), lb(t, 0), fi(t, Ku);
  var n = t.transitions;
  if (n !== null)
    for (const o of n)
      o.stop();
  QB(t);
  var i = t.parent;
  i !== null && i.first !== null && JB(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function L0e(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ul(t)
    );
    t.remove(), t = r;
  }
}
function JB(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function ad(t, e, r = !0) {
  var n = [];
  qS(t, n, !0), YB(n, () => {
    r && Ii(t), e && e();
  });
}
function YB(t, e) {
  var r = t.length;
  if (r > 0) {
    var n = () => --r || e();
    for (var i of t)
      i.out(n);
  } else
    e();
}
function qS(t, e, r) {
  if ((t.f & Ho) === 0) {
    if (t.f ^= Ho, t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || r) && e.push(s);
    for (var n = t.first; n !== null; ) {
      var i = n.next, o = (n.f & Rd) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (n.f & au) !== 0 && (t.f & su) !== 0;
      qS(n, e, o ? r : !1), n = i;
    }
  }
}
function US(t) {
  ZB(t, !0);
}
function ZB(t, e) {
  if ((t.f & Ho) !== 0) {
    t.f ^= Ho, (t.f & si) === 0 && (fi(t, ho), Sh(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, i = (r.f & Rd) !== 0 || (r.f & au) !== 0;
      ZB(r, i ? e : !1), r = n;
    }
    if (t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || e) && o.in();
  }
}
function eL(t, e) {
  for (var r = t.nodes_start, n = t.nodes_end; r !== null; ) {
    var i = r === n ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ul(r)
    );
    e.append(r), r = i;
  }
}
const tL = /* @__PURE__ */ new Set(), i_ = /* @__PURE__ */ new Set();
function z0e(t, e, r, n = {}) {
  function i(o) {
    if (n.capture || xm.call(e, o), !o.cancelBubble)
      return zS(() => r?.call(this, o));
  }
  return pp(() => {
    e.addEventListener(t, i, n);
  }), i;
}
function j0e(t, e, r, n, i) {
  var o = { capture: n, passive: i }, s = z0e(t, e, r, o);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && WB(() => {
    e.removeEventListener(t, s, o);
  });
}
function q0e(t) {
  for (var e = 0; e < t.length; e++)
    tL.add(t[e]);
  for (var r of i_)
    r(t);
}
let V9 = null;
function xm(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, i = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  V9 = t;
  var s = 0, a = V9 === t && t.__root;
  if (a) {
    var l = i.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    l <= u && (s = l);
  }
  if (o = /** @type {Element} */
  i[s] || t.target, o !== e) {
    hB(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Jt, h = sr;
    ro(null), Za(null);
    try {
      for (var d, p = []; o !== null; ) {
        var g = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var v = o["__" + n];
          v != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && v.call(o, t);
        } catch (y) {
          d ? p.push(y) : d = y;
        }
        if (t.cancelBubble || g === e || g === null)
          break;
        o = g;
      }
      if (d) {
        for (let y of p)
          queueMicrotask(() => {
            throw y;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, ro(c), Za(h);
    }
  }
}
function rL(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Ju(t, e) {
  var r = (
    /** @type {Effect} */
    sr
  );
  r.nodes_start === null && (r.nodes_start = t, r.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function yc(t, e) {
  var r = (e & m0e) !== 0, n = (e & g0e) !== 0, i, o = !t.startsWith("<!>");
  return () => {
    if (or)
      return Ju(Zt, null), Zt;
    i === void 0 && (i = rL(o ? t : "<!>" + t), r || (i = /** @type {Node} */
    /* @__PURE__ */ Yl(i)));
    var s = (
      /** @type {TemplateNode} */
      n || _B ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Yl(s)
      ), l = (
        /** @type {TemplateNode} */
        s.lastChild
      );
      Ju(a, l);
    } else
      Ju(s, s);
    return s;
  };
}
// @__NO_SIDE_EFFECTS__
function U0e(t, e, r = "svg") {
  var n = !t.startsWith("<!>"), i = `<${r}>${n ? t : "<!>" + t}</${r}>`, o;
  return () => {
    if (or)
      return Ju(Zt, null), Zt;
    if (!o) {
      var s = (
        /** @type {DocumentFragment} */
        rL(i)
      ), a = (
        /** @type {Element} */
        /* @__PURE__ */ Yl(s)
      );
      o = /** @type {Element} */
      /* @__PURE__ */ Yl(a);
    }
    var l = (
      /** @type {TemplateNode} */
      o.cloneNode(!0)
    );
    return Ju(l, l), l;
  };
}
// @__NO_SIDE_EFFECTS__
function uu(t, e) {
  return /* @__PURE__ */ U0e(t, e, "svg");
}
function rm() {
  if (or)
    return Ju(Zt, null), Zt;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = Ya();
  return t.append(e, r), Ju(e, r), t;
}
function rn(t, e) {
  if (or) {
    var r = (
      /** @type {Effect} */
      sr
    );
    ((r.f & wx) === 0 || r.nodes_end === null) && (r.nodes_end = Zt), v0();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
const H0e = ["touchstart", "touchmove"];
function V0e(t) {
  return H0e.includes(t);
}
function Lm(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function nL(t, e) {
  return iL(t, e);
}
function W0e(t, e) {
  ZC(), e.intro = e.intro ?? !1;
  const r = e.target, n = or, i = Zt;
  try {
    for (var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Yl(r)
    ); o && (o.nodeType !== dp || /** @type {Comment} */
    o.data !== bB); )
      o = /** @type {TemplateNode} */
      /* @__PURE__ */ ul(o);
    if (!o)
      throw Nd;
    jl(!0), oo(
      /** @type {Comment} */
      o
    );
    const s = iL(t, { ...e, anchor: o });
    return jl(!1), /**  @type {Exports} */
    s;
  } catch (s) {
    if (s instanceof Error && s.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw s;
    return s !== Nd && console.warn("Failed to hydrate: ", s), e.recover === !1 && r0e(), ZC(), EB(r), jl(!1), nL(t, e);
  } finally {
    jl(n), oo(i);
  }
}
const wf = /* @__PURE__ */ new Map();
function iL(t, { target: e, anchor: r, props: n = {}, events: i, context: o, intro: s = !0 }) {
  ZC();
  var a = /* @__PURE__ */ new Set(), l = (h) => {
    for (var d = 0; d < h.length; d++) {
      var p = h[d];
      if (!a.has(p)) {
        a.add(p);
        var g = V0e(p);
        e.addEventListener(p, xm, { passive: g });
        var v = wf.get(p);
        v === void 0 ? (document.addEventListener(p, xm, { passive: g }), wf.set(p, 1)) : wf.set(p, v + 1);
      }
    }
  };
  l(RS(tL)), i_.add(l);
  var u = void 0, c = $0e(() => {
    var h = r ?? e.appendChild(Ya());
    return _0e(
      /** @type {TemplateNode} */
      h,
      {
        pending: () => {
        }
      },
      (d) => {
        if (o) {
          Vh({});
          var p = (
            /** @type {ComponentContext} */
            fo
          );
          p.c = o;
        }
        if (i && (n.$$events = i), or && Ju(
          /** @type {TemplateNode} */
          d,
          null
        ), u = t(d, n) || {}, or && (sr.nodes_end = Zt, Zt === null || Zt.nodeType !== dp || /** @type {Comment} */
        Zt.data !== BS))
          throw Cx(), Nd;
        o && Wh();
      }
    ), () => {
      for (var d of a) {
        e.removeEventListener(d, xm);
        var p = (
          /** @type {number} */
          wf.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, xm), wf.delete(d)) : wf.set(d, p);
      }
      i_.delete(l), h !== r && h.parentNode?.removeChild(h);
    };
  });
  return o_.set(u, c), u;
}
let o_ = /* @__PURE__ */ new WeakMap();
function G0e(t, e) {
  const r = o_.get(t);
  return r ? (o_.delete(t), r(e)) : Promise.resolve();
}
function K0e(t) {
  return new Q0e(t);
}
class Q0e {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, s) => {
      var a = /* @__PURE__ */ $B(s, !1, !1);
      return r.set(o, a), a;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, s) {
          return W(r.get(s) ?? n(s, Reflect.get(o, s)));
        },
        has(o, s) {
          return s === uB ? !0 : (W(r.get(s) ?? n(s, Reflect.get(o, s))), Reflect.has(o, s));
        },
        set(o, s, a) {
          return dt(r.get(s) ?? n(s, a), a), Reflect.set(o, s, a);
        }
      }
    );
    this.#t = (e.hydrate ? W0e : nL)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && x0e(), this.#e = i.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || hB(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(s) {
          this.#t[o] = s;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(i, o);
    }, this.#t.$destroy = () => {
      G0e(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...i) => r.call(this, ...i);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const X0e = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(X0e);
class oL {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #r = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#n = r;
  }
  #l = () => {
    var e = (
      /** @type {Batch} */
      _n
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        US(n);
      else {
        var i = this.#r.get(r);
        i && (this.#t.set(r, i.effect), this.#r.delete(r), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), n = i.effect);
      }
      for (const [o, s] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(s);
        a && (Ii(a.effect), this.#r.delete(s));
      }
      for (const [o, s] of this.#t) {
        if (o === r) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var l = document.createDocumentFragment();
            eL(s, l), l.append(Ya()), this.#r.set(o, { effect: s, fragment: l });
          } else
            Ii(s);
          this.#t.delete(o);
        };
        this.#n || !n ? ad(s, a, !1) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #a = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, i] of this.#r)
      r.includes(n) || (Ii(i.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      _n
    );
    r && !this.#t.has(e) && !this.#r.has(e) && this.#t.set(
      e,
      Is(() => r(this.anchor))
    ), this.#e.set(n, e), or && (this.anchor = Zt), this.#l();
  }
}
function HS(t) {
  fo === null && vB(), El(() => {
    const e = Kh(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function J0e(t) {
  fo === null && vB(), HS(() => () => Kh(t));
}
function Vi(t, e, r = !1) {
  or && v0();
  var n = new oL(t), i = r ? Rd : 0;
  function o(s, a) {
    if (or) {
      const u = CB(t) === kx;
      if (s === u) {
        var l = sb();
        oo(l), n.anchor = l, jl(!1), n.ensure(s, a), jl(!0);
        return;
      }
    }
    n.ensure(s, a);
  }
  Ex(() => {
    var s = !1;
    e((a, l = !0) => {
      s = !0, o(l, a);
    }), s || o(!1, null);
  }, i);
}
function Y0e(t, e, r) {
  or && v0();
  var n = new oL(t);
  Ex(() => {
    var i = e();
    n.ensure(i, r);
  });
}
function Ek(t, e) {
  return e;
}
function Z0e(t, e, r) {
  for (var n = t.items, i = [], o = e.length, s = 0; s < o; s++)
    qS(e[s].e, i, !0);
  var a = o > 0 && i.length === 0 && r !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      r.parentNode
    );
    EB(l), l.append(
      /** @type {Element} */
      r
    ), n.clear(), wa(t, e[0].prev, e[o - 1].next);
  }
  YB(i, () => {
    for (var u = 0; u < o; u++) {
      var c = e[u];
      a || (n.delete(c.k), wa(t, c.prev, c.next)), Ii(c.e, !a);
    }
  });
}
function Dk(t, e, r, n, i, o = null) {
  var s = t, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & yB) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    s = or ? oo(
      /** @type {Comment | Text} */
      /* @__PURE__ */ Yl(u)
    ) : u.appendChild(Ya());
  }
  or && v0();
  var c = null, h = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ MB(() => {
    var b = r();
    return cB(b) ? b : b == null ? [] : RS(b);
  }), g, v;
  function y() {
    eve(
      v,
      g,
      a,
      d,
      s,
      i,
      e,
      n,
      r
    ), o !== null && (g.length === 0 ? c ? US(c) : c = Is(() => o(s)) : c !== null && ad(c, () => {
      c = null;
    }));
  }
  Ex(() => {
    v ??= /** @type {Effect} */
    sr, g = /** @type {V[]} */
    W(p);
    var b = g.length;
    if (h && b === 0)
      return;
    h = b === 0;
    let k = !1;
    if (or) {
      var C = CB(s) === kx;
      C !== (b === 0) && (s = sb(), oo(s), jl(!1), k = !0);
    }
    if (or) {
      for (var S = null, _, D = 0; D < b; D++) {
        if (Zt.nodeType === dp && /** @type {Comment} */
        Zt.data === BS) {
          s = /** @type {Comment} */
          Zt, k = !0, jl(!1);
          break;
        }
        var A = g[D], O = n(A, D);
        _ = sL(
          Zt,
          a,
          S,
          null,
          A,
          O,
          D,
          i,
          e,
          r
        ), a.items.set(O, _), S = _;
      }
      b > 0 && oo(sb());
    }
    or ? b === 0 && o && (c = Is(() => o(s))) : y(), k && jl(!0), W(p);
  }), or && (s = Zt);
}
function eve(t, e, r, n, i, o, s, a, l) {
  var u = (s & u0e) !== 0, c = (s & ($S | IS)) !== 0, h = e.length, d = r.items, p = r.first, g = p, v, y = null, b, k = [], C = [], S, _, D, A;
  if (u)
    for (A = 0; A < h; A += 1)
      S = e[A], _ = a(S, A), D = d.get(_), D !== void 0 && (D.a?.measure(), (b ??= /* @__PURE__ */ new Set()).add(D));
  for (A = 0; A < h; A += 1) {
    if (S = e[A], _ = a(S, A), D = d.get(_), D === void 0) {
      var O = n.get(_);
      if (O !== void 0) {
        n.delete(_), d.set(_, O);
        var M = y ? y.next : g;
        wa(r, y, O), wa(r, O, M), Ok(O, M, i), y = O;
      } else {
        var z = g ? (
          /** @type {TemplateNode} */
          g.e.nodes_start
        ) : i;
        y = sL(
          z,
          r,
          y,
          y === null ? r.first : y.next,
          S,
          _,
          A,
          o,
          s,
          l
        );
      }
      d.set(_, y), k = [], C = [], g = y.next;
      continue;
    }
    if (c && tve(D, S, A, s), (D.e.f & Ho) !== 0 && (US(D.e), u && (D.a?.unfix(), (b ??= /* @__PURE__ */ new Set()).delete(D))), D !== g) {
      if (v !== void 0 && v.has(D)) {
        if (k.length < C.length) {
          var R = C[0], N;
          y = R.prev;
          var I = k[0], B = k[k.length - 1];
          for (N = 0; N < k.length; N += 1)
            Ok(k[N], R, i);
          for (N = 0; N < C.length; N += 1)
            v.delete(C[N]);
          wa(r, I.prev, B.next), wa(r, y, I), wa(r, B, R), g = R, y = B, A -= 1, k = [], C = [];
        } else
          v.delete(D), Ok(D, g, i), wa(r, D.prev, D.next), wa(r, D, y === null ? r.first : y.next), wa(r, y, D), y = D;
        continue;
      }
      for (k = [], C = []; g !== null && g.k !== _; )
        (g.e.f & Ho) === 0 && (v ??= /* @__PURE__ */ new Set()).add(g), C.push(g), g = g.next;
      if (g === null)
        continue;
      D = g;
    }
    k.push(D), y = D, g = D.next;
  }
  if (g !== null || v !== void 0) {
    for (var $ = v === void 0 ? [] : RS(v); g !== null; )
      (g.e.f & Ho) === 0 && $.push(g), g = g.next;
    var q = $.length;
    if (q > 0) {
      var U = (s & yB) !== 0 && h === 0 ? i : null;
      if (u) {
        for (A = 0; A < q; A += 1)
          $[A].a?.measure();
        for (A = 0; A < q; A += 1)
          $[A].a?.fix();
      }
      Z0e(r, $, U);
    }
  }
  u && pp(() => {
    if (b !== void 0)
      for (D of b)
        D.a?.apply();
  }), t.first = r.first && r.first.e, t.last = y && y.e;
  for (var H of n.values())
    Ii(H.e);
  n.clear();
}
function tve(t, e, r, n) {
  (n & $S) !== 0 && Bd(t.v, e), (n & IS) !== 0 ? Bd(
    /** @type {Value<number>} */
    t.i,
    r
  ) : t.i = r;
}
function sL(t, e, r, n, i, o, s, a, l, u, c) {
  var h = (l & $S) !== 0, d = (l & c0e) === 0, p = h ? d ? /* @__PURE__ */ $B(i, !1, !1) : Ah(i) : i, g = (l & IS) === 0 ? s : Ah(s), v = {
    i: g,
    v: p,
    k: o,
    a: null,
    // @ts-expect-error
    e: null,
    prev: r,
    next: n
  };
  try {
    if (t === null) {
      var y = document.createDocumentFragment();
      y.append(t = Ya());
    }
    return v.e = Is(() => a(
      /** @type {Node} */
      t,
      p,
      g,
      u
    ), or), v.e.prev = r && r.e, v.e.next = n && n.e, r === null ? c || (e.first = v) : (r.next = v, r.e.next = v.e), n !== null && (n.prev = v, n.e.prev = v.e), v;
  } finally {
  }
}
function Ok(t, e, r) {
  for (var n = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : r, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : r, o = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); o !== null && o !== n; ) {
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ul(o)
    );
    i.before(o), o = s;
  }
}
function wa(t, e, r) {
  e === null ? t.first = r : (e.next = r, e.e.next = r && r.e), r !== null && (r.prev = e, r.e.prev = e && e.e);
}
function Rs(t, e, r) {
  KB(() => {
    var n = Kh(() => e(t, r?.()) || {});
    if (r && n?.update) {
      var i = !1, o = (
        /** @type {any} */
        {}
      );
      jS(() => {
        var s = r();
        R0e(s), i && mB(o, s) && (o = s, n.update(s));
      }), i = !0;
    }
    if (n?.destroy)
      return () => (
        /** @type {Function} */
        n.destroy()
      );
  });
}
function W9(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var i in t) {
    var o = t[i];
    o != null && o !== "" && (n += " " + i + ": " + o + r);
  }
  return n;
}
function rve(t, e) {
  if (e) {
    var r = "", n, i;
    return Array.isArray(e) ? (n = e[0], i = e[1]) : n = e, n && (r += W9(n)), i && (r += W9(i, !0)), r = r.trim(), r === "" ? null : r;
  }
  return String(t);
}
function Fk(t, e = {}, r, n) {
  for (var i in r) {
    var o = r[i];
    e[i] !== o && (r[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, o, n));
  }
}
function Qt(t, e, r, n) {
  var i = t.__style;
  if (or || i !== e) {
    var o = rve(e, n);
    (!or || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (Fk(t, r?.[0], n[0]), Fk(t, r?.[1], n[1], "important")) : Fk(t, r, n));
  return n;
}
const nve = Symbol("is custom element"), ive = Symbol("is html");
function qe(t, e, r, n) {
  var i = ove(t);
  or && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = r) && (e === "loading" && (t[Vge] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && sve(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function ove(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [nve]: t.nodeName.includes("-"),
      [ive]: t.namespaceURI === v0e
    }
  );
}
var G9 = /* @__PURE__ */ new Map();
function sve(t) {
  var e = t.getAttribute("is") || t.nodeName, r = G9.get(e);
  if (r) return r;
  G9.set(e, r = []);
  for (var n, i = t, o = Element.prototype; o !== i; ) {
    n = fB(i);
    for (var s in n)
      n[s].set && r.push(s);
    i = NS(i);
  }
  return r;
}
function K9(t, e) {
  return t === e || t?.[lh] === e;
}
function s_(t = {}, e, r, n) {
  return KB(() => {
    var i, o;
    return jS(() => {
      i = o, o = [], Kh(() => {
        t !== r(...o) && (e(t, ...o), i && K9(r(...i), t) && e(null, ...i));
      });
    }), () => {
      pp(() => {
        o && K9(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
let py = !1;
function ave(t) {
  var e = py;
  try {
    return py = !1, [t(), py];
  } finally {
    py = e;
  }
}
function tt(t, e, r, n) {
  var i = (r & d0e) !== 0, o = (r & p0e) !== 0, s = (
    /** @type {V} */
    n
  ), a = !0, l = () => (a && (a = !1, s = o ? Kh(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), s), u;
  if (i) {
    var c = lh in t || uB in t;
    u = sd(t, e)?.set ?? (c && e in t ? (k) => t[e] = k : void 0);
  }
  var h, d = !1;
  i ? [h, d] = ave(() => (
    /** @type {V} */
    t[e]
  )) : h = /** @type {V} */
  t[e], h === void 0 && n !== void 0 && (h = l(), u && (n0e(), u(h)));
  var p;
  if (p = () => {
    var k = (
      /** @type {V} */
      t[e]
    );
    return k === void 0 ? l() : (a = !0, k);
  }, (r & f0e) === 0)
    return p;
  if (u) {
    var g = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(k, C) {
        return arguments.length > 0 ? ((!C || g || d) && u(C ? p() : k), k) : p();
      })
    );
  }
  var v = !1, y = ((r & h0e) !== 0 ? Sx : MB)(() => (v = !1, p()));
  i && W(y);
  var b = (
    /** @type {Effect} */
    sr
  );
  return (
    /** @type {() => V} */
    (function(k, C) {
      if (arguments.length > 0) {
        const S = C ? W(y) : i ? Yc(k) : k;
        return dt(y, S), v = !0, s !== void 0 && (s = S), k;
      }
      return Gh && v || (b.f & Ku) !== 0 ? y.v : W(y);
    })
  );
}
var lve = /* @__PURE__ */ uu('<g><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect></g>');
function uve(t, e) {
  Vh(e, !0);
  let r = /* @__PURE__ */ gt(() => e.pointLocation(e.value.xMin, e.value.yMin)), n = /* @__PURE__ */ gt(() => e.pointLocation(e.value.xMax, e.value.yMax));
  const i = 8;
  function o(y) {
    return (b) => {
      e.preventHover(!0);
      let k = [W(r).x, W(r).y, W(n).x, W(n).y];
      return {
        move: (C) => {
          let S = C.pageX - b.pageX, _ = C.pageY - b.pageY, D = [S, _, S, _].map((M, z) => k[z] + M * y[z]), A = e.coordinateAtPoint(D[0], D[1]), O = e.coordinateAtPoint(D[2], D[3]);
          e.onChange({
            xMin: Math.min(A.x, O.x),
            xMax: Math.max(A.x, O.x),
            yMin: Math.min(A.y, O.y),
            yMax: Math.max(A.y, O.y)
          });
        },
        up: () => {
          e.preventHover(!1);
        },
        cancel: () => {
          e.preventHover(!1);
        }
      };
    };
  }
  var s = lve(), a = $n(s);
  Qt(a, "", {}, {
    stroke: "#fff",
    fill: "rgba(128,128,128,0.25)",
    cursor: "move"
  }), Rs(a, (y, b) => gn?.(y, b), () => ({ drag: o([1, 1, 1, 1]) }));
  var l = Ur(a);
  qe(l, "width", i), Qt(l, "", {}, {
    cursor: "ew-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(l, (y, b) => gn?.(y, b), () => ({ drag: o([1, 0, 0, 0]) }));
  var u = Ur(l);
  qe(u, "width", i), Qt(u, "", {}, {
    cursor: "ew-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(u, (y, b) => gn?.(y, b), () => ({ drag: o([0, 0, 1, 0]) }));
  var c = Ur(u);
  qe(c, "height", i), Qt(c, "", {}, {
    cursor: "ns-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(c, (y, b) => gn?.(y, b), () => ({ drag: o([0, 1, 0, 0]) }));
  var h = Ur(c);
  qe(h, "height", i), Qt(h, "", {}, {
    cursor: "ns-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(h, (y, b) => gn?.(y, b), () => ({ drag: o([0, 0, 0, 1]) }));
  var d = Ur(h);
  qe(d, "width", i), qe(d, "height", i), Qt(d, "", {}, {
    cursor: "nesw-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(d, (y, b) => gn?.(y, b), () => ({ drag: o([1, 1, 0, 0]) }));
  var p = Ur(d);
  qe(p, "width", i), qe(p, "height", i), Qt(p, "", {}, {
    cursor: "nwse-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(p, (y, b) => gn?.(y, b), () => ({ drag: o([1, 0, 0, 1]) }));
  var g = Ur(p);
  qe(g, "width", i), qe(g, "height", i), Qt(g, "", {}, {
    cursor: "nwse-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(g, (y, b) => gn?.(y, b), () => ({ drag: o([0, 1, 1, 0]) }));
  var v = Ur(g);
  qe(v, "width", i), qe(v, "height", i), Qt(v, "", {}, {
    cursor: "nesw-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Rs(v, (y, b) => gn?.(y, b), () => ({ drag: o([0, 0, 1, 1]) })), yn(s), Bo(
    (y, b, k, C, S, _, D, A, O, M, z, R) => {
      qe(a, "x", y), qe(a, "width", b), qe(a, "y", k), qe(a, "height", C), qe(l, "x", W(r).x - i / 2), qe(l, "y", S), qe(l, "height", _), qe(u, "x", W(n).x - i / 2), qe(u, "y", D), qe(u, "height", A), qe(c, "x", O), qe(c, "width", M), qe(c, "y", W(r).y - i / 2), qe(h, "x", z), qe(h, "width", R), qe(h, "y", W(n).y - i / 2), qe(d, "x", W(r).x - i / 2), qe(d, "y", W(r).y - i / 2), qe(p, "x", W(r).x - i / 2), qe(p, "y", W(n).y - i / 2), qe(g, "x", W(n).x - i / 2), qe(g, "y", W(r).y - i / 2), qe(v, "x", W(n).x - i / 2), qe(v, "y", W(n).y - i / 2);
    },
    [
      () => Math.min(W(r).x, W(n).x),
      () => Math.abs(W(r).x - W(n).x),
      () => Math.min(W(r).y, W(n).y),
      () => Math.abs(W(r).y - W(n).y),
      () => Math.min(W(r).y, W(n).y),
      () => Math.abs(W(r).y - W(n).y),
      () => Math.min(W(r).y, W(n).y),
      () => Math.abs(W(r).y - W(n).y),
      () => Math.min(W(r).x, W(n).x),
      () => Math.abs(W(r).x - W(n).x),
      () => Math.min(W(r).x, W(n).x),
      () => Math.abs(W(r).x - W(n).x)
    ]
  ), rn(t, s), Wh();
}
function cve(t, e) {
  let r = !1, n, i, o, s = 300, a = 300, l = async (c) => {
    r = !0;
    try {
      await t(c);
    } catch (h) {
      console.error(h);
    }
    if (r = !1, n !== void 0) {
      let h = n;
      n = void 0, u(h);
    }
  }, u = async (c) => {
    if (r) {
      n = c;
      return;
    }
    let h = (/* @__PURE__ */ new Date()).getTime();
    e() && (i = h);
    let d = !0;
    (i == null || h - i < a) && (d = !1), d ? (o && clearTimeout(o), o = setTimeout(() => l(c), s)) : l(c);
  };
  return u;
}
function hve(t, e) {
  let r = t.x - e.x, n = t.y - e.y;
  return Math.sqrt(r * r + n * n);
}
function fve(t) {
  return "M " + t.map(({ x: e, y: r }) => `${e},${r}`).join(" L ") + " Z";
}
function aL(t) {
  let e = 1 / 0, r = -1 / 0, n = 1 / 0, i = -1 / 0;
  for (let { x: o, y: s } of t)
    e = Math.min(e, o), n = Math.min(n, s), r = Math.max(r, o), i = Math.max(i, s);
  return { xMin: e, yMin: n, xMax: r, yMax: i };
}
async function dve(t) {
  let e = JSON.stringify(t);
  return mve(e);
}
function Iu(t, e) {
  if (t === e)
    return !0;
  if (t === null || e === null || typeof t != "object" || typeof e != "object" || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (let r in t)
    if (e.hasOwnProperty(r)) {
      if (!Iu(t[r], e[r]))
        return !1;
    } else
      return !1;
  return !0;
}
function pve(t, e = 0) {
  let r = 3735928559 ^ e, n = 1103547991 ^ e;
  for (let i = 0; i < t.length; i++) {
    let o = t[i];
    r = Math.imul(r ^ o, 2654435761), n = Math.imul(n ^ o, 1597334677);
  }
  return r = Math.imul(r ^ r >>> 16, 2246822507), r ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(r ^ r >>> 13, 3266489909), [n >>> 0, r >>> 0];
}
function mve(t) {
  let e = new TextEncoder().encode(t), r = pve(e);
  return r[0].toString(16).padStart(8, "0") + r[1].toString(16).padStart(8, "0");
}
var gve = /* @__PURE__ */ uu("<path></path>");
function vve(t, e) {
  Vh(e, !0);
  let r = /* @__PURE__ */ gt(() => e.value.map(({ x: i, y: o }) => e.pointLocation(i, o)));
  var n = gve();
  Qt(n, "", {}, { stroke: "#fff", fill: "rgba(128,128,128,0.25)" }), Bo((i) => qe(n, "d", i), [() => fve(W(r))]), rn(t, n), Wh();
}
const yve = {
  marquee: "M7 5a2 2 0 1 1-4 0a2 2 0 0 1 4 0m1-.25c0 .414.336.75.75.75h6.5a.75.75 0 0 0 0-1.5h-6.5a.75.75 0 0 0-.75.75M4.75 8a.75.75 0 0 0-.75.75v6.5a.75.75 0 0 0 1.5 0v-6.5A.75.75 0 0 0 4.75 8m14.5 0a.75.75 0 0 0-.75.75v6.5a.75.75 0 0 0 1.5 0v-6.5a.75.75 0 0 0-.75-.75M8.75 20a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5zM5 21a2 2 0 1 0 0-4a2 2 0 0 0 0 4M21 5a2 2 0 1 1-4 0a2 2 0 0 1 4 0m-2 16a2 2 0 1 0 0-4a2 2 0 0 0 0 4",
  lasso: "M9.703 2.265A10 10 0 0 1 12 2c.79 0 1.559.092 2.297.265a.75.75 0 1 1-.343 1.46A8.5 8.5 0 0 0 12 3.5a8.6 8.6 0 0 0-1.954.225a.75.75 0 1 1-.343-1.46m-1.93 1.47a.75.75 0 0 1-.242 1.033a8.55 8.55 0 0 0-2.763 2.763a.75.75 0 1 1-1.275-.79a10.05 10.05 0 0 1 3.248-3.248a.75.75 0 0 1 1.032.243m8.454 0a.75.75 0 0 1 1.032-.242a10.05 10.05 0 0 1 3.248 3.248a.75.75 0 1 1-1.275.79a8.55 8.55 0 0 0-2.763-2.763a.75.75 0 0 1-.242-1.032m-13.06 5.41a.75.75 0 0 1 .558.901A8.5 8.5 0 0 0 3.5 12c0 .673.078 1.327.225 1.954a.75.75 0 1 1-1.46.343A10 10 0 0 1 2 12c0-.79.092-1.559.265-2.297a.75.75 0 0 1 .902-.559m17.666 0a.75.75 0 0 1 .902.558a10.1 10.1 0 0 1 0 4.595a.75.75 0 1 1-1.46-.343a8.54 8.54 0 0 0-.001-3.908a.75.75 0 0 1 .559-.902M3.736 16.226a.75.75 0 0 1 1.032.242a8.55 8.55 0 0 0 2.763 2.763a.75.75 0 0 1-.79 1.275a10.05 10.05 0 0 1-3.248-3.248a.75.75 0 0 1 .243-1.032m16.685.858a.75.75 0 1 0-1.342-.67l-.002.004l-.015.029l-.069.123a8 8 0 0 1-.289.466a9.6 9.6 0 0 1-.965 1.219c-1.17-1.073-2.756-2.006-4.74-2.006c-2.347 0-3.99 1.203-3.99 2.875S10.653 22 13 22c1.942 0 3.495-.75 4.658-1.645a11.7 11.7 0 0 1 1.315 2.01q.05.099.073.149l.017.035l.004.009a.75.75 0 0 0 1.368-.615c-.087-.183 0-.001 0-.001v-.002l-.003-.004l-.007-.015l-.024-.052l-.091-.184a13.2 13.2 0 0 0-1.538-2.337a11 11 0 0 0 1.525-2.032l.09-.162l.024-.047l.007-.014l.002-.005zM13 17.75c1.433 0 2.644.652 3.616 1.512c-.95.7-2.155 1.238-3.616 1.238c-1.973 0-2.49-.922-2.49-1.375s.517-1.375 2.49-1.375"
};
var bve = /* @__PURE__ */ uu('<svg width="24" height="24" viewBox="0 0 24 24"><path></path></svg>'), xve = /* @__PURE__ */ yc("<button><!></button>");
function Q9(t, e) {
  let r = tt(e, "active", 3, !1);
  var n = xve();
  n.__click = function(...a) {
    e.onClick?.apply(this, a);
  };
  let i;
  var o = $n(n);
  {
    var s = (a) => {
      var l = bve();
      Qt(l, "", {}, { width: "14px", height: "14px" });
      var u = $n(l);
      Qt(u, "", {}, { fill: "currentColor" }), yn(l), Bo(() => qe(u, "d", yve[e.icon])), rn(a, l);
    };
    Vi(o, (a) => {
      e.icon != null && a(s);
    });
  }
  yn(n), Bo(() => {
    qe(n, "title", e.title), i = Qt(n, "", i, {
      border: "none",
      appearance: "none",
      background: r() ? "color-mix(in srgb, currentColor 20%, transparent)" : "none",
      "border-radius": "2px",
      height: "16px",
      width: "16px",
      padding: "0",
      margin: "0",
      "font-family": "inherit",
      "font-size": "1em",
      color: "currentColor",
      display: "flex",
      "flex-direction": "row",
      "align-items": "center",
      "justify-content": "center"
    });
  }), rn(t, n);
}
q0e(["click"]);
var wve = /* @__PURE__ */ yc('<div><div> </div> <svg height="6px"><line shape-rendering="crispEdges"></line><line shape-rendering="crispEdges"></line><line shape-rendering="crispEdges"></line></svg></div>');
function kve(t, e) {
  function r(d, p) {
    let g = Math.log10(p * d), v = Math.round(g), y = [0.1, 0.2, 0.5, 1, 2, 5, 10], b = 0, k = 1e10;
    for (let C of y) {
      let S = Math.abs(Math.log10(C) + v - g);
      S < k && (b = C, k = S);
    }
    return b * Math.pow(10, v);
  }
  let n = /* @__PURE__ */ gt(() => r(e.distancePerPoint, 30)), i = /* @__PURE__ */ gt(() => W(n) / e.distancePerPoint);
  var o = wve();
  Qt(o, "", {}, { display: "flex", "align-items": "center" });
  var s = $n(o);
  Qt(s, "", {}, { "padding-right": "4px" });
  var a = $n(s, !0);
  yn(s);
  var l = Ur(s, 2), u = $n(l);
  qe(u, "x1", 1), qe(u, "y1", 3), qe(u, "y2", 3), Qt(u, "", {}, {
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-cap": "butt"
  });
  var c = Ur(u);
  qe(c, "x1", 1), qe(c, "x2", 1), qe(c, "y1", 0), qe(c, "y2", 6), Qt(c, "", {}, { stroke: "currentColor" });
  var h = Ur(c);
  qe(h, "y1", 0), qe(h, "y2", 6), Qt(h, "", {}, { stroke: "currentColor" }), yn(l), yn(o), Bo(
    (d) => {
      Lm(a, d), qe(l, "width", `${W(i) + 2}px`), qe(u, "x2", W(i) + 1), qe(h, "x1", W(i) + 1), qe(h, "x2", W(i) + 1);
    },
    [() => W(n).toLocaleString()]
  ), rn(t, o);
}
var Cve = /* @__PURE__ */ yc("<div> </div>"), _ve = /* @__PURE__ */ yc('<a target="_blank"> </a> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div>', 1), Sve = /* @__PURE__ */ yc('<div><div><!></div> <div></div> <div><!> <!> <!> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div> <!> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div> <span> </span></div></div>');
function Ave(t, e) {
  Vh(e, !0);
  let r = tt(e, "statusMessage", 3, null);
  var n = Sve();
  let i;
  var o = $n(n);
  let s;
  var a = $n(o);
  {
    var l = (C) => {
      var S = Cve();
      Qt(S, "", {}, { display: "inline-block" });
      var _ = $n(S, !0);
      yn(S), Bo(() => Lm(_, r())), rn(C, S);
    };
    Vi(a, (C) => {
      r() != null && C(l);
    });
  }
  yn(o);
  var u = Ur(o, 2);
  Qt(u, "", {}, { flex: "1 1 0%" });
  var c = Ur(u, 2);
  let h;
  var d = $n(c);
  {
    var p = (C) => {
      var S = _ve(), _ = Df(S);
      Qt(_, "", {}, { color: "currentColor", "text-decoration": "underline" });
      var D = $n(_, !0);
      yn(_), kB(2), Bo(() => {
        qe(_, "href", e.resolvedTheme.brandingLink.href), Lm(D, e.resolvedTheme.brandingLink.text);
      }), rn(C, S);
    };
    Vi(d, (C) => {
      e.resolvedTheme.brandingLink != null && C(p);
    });
  }
  var g = Ur(d, 2);
  {
    let C = /* @__PURE__ */ gt(() => e.selectionMode == "marquee");
    Q9(g, {
      icon: "marquee",
      get active() {
        return W(C);
      },
      title: "Toggle rectangle selection mode. In normal mode, use shift + drag for rectangle selection.",
      onClick: () => e.onSelectionMode(e.selectionMode == "marquee" ? "none" : "marquee")
    });
  }
  var v = Ur(g, 2);
  {
    let C = /* @__PURE__ */ gt(() => e.selectionMode == "lasso");
    Q9(v, {
      icon: "lasso",
      get active() {
        return W(C);
      },
      title: "Toggle lasso selection mode. In normal mode, use shift + meta + drag for lasso selection.",
      onClick: () => e.onSelectionMode(e.selectionMode == "lasso" ? "none" : "lasso")
    });
  }
  var y = Ur(v, 4);
  kve(y, {
    get distancePerPoint() {
      return e.distancePerPoint;
    }
  });
  var b = Ur(y, 4), k = $n(b);
  yn(b), yn(c), yn(n), Bo(
    (C) => {
      i = Qt(n, "", i, {
        "font-size": "12px",
        "line-height": "20px",
        height: "20px",
        color: e.resolvedTheme.statusBarTextColor,
        position: "absolute",
        bottom: "0px",
        left: "0px",
        right: "0px",
        "user-select": "none",
        "font-family": e.resolvedTheme.fontFamily,
        display: "flex",
        "flex-direction": "row"
      }), s = Qt(o, "", s, {
        flex: "none",
        display: "flex",
        "flex-direction": "row",
        gap: "4px",
        padding: "0px 4px",
        "border-radius": "2px",
        background: e.resolvedTheme.statusBarBackgroundColor
      }), h = Qt(c, "", h, {
        flex: "none",
        display: "flex",
        "flex-direction": "row",
        "align-items": "center",
        gap: "4px",
        padding: "0px 4px",
        "border-radius": "2px",
        background: e.resolvedTheme.statusBarBackgroundColor
      }), Lm(k, `${C ?? ""} points`);
    },
    [() => e.pointCount.toLocaleString()]
  ), rn(t, n), Wh();
}
function Eve(t) {
  return (e, r) => {
    let n = new t(e, r);
    return {
      ...n.update ? { update: n.update.bind(n) } : {},
      ...n.destroy ? { destroy: n.destroy.bind(n) } : {}
    };
  };
}
let Tk = /* @__PURE__ */ new WeakMap();
function lL(t) {
  let e = typeof t == "function" ? t : t.class;
  if (Tk.has(e))
    return Tk.get(e);
  {
    let r = Eve(e);
    return Tk.set(e, r), r;
  }
}
function uL(t, e) {
  return typeof t == "function" ? e : { ...t.props ?? {}, ...e };
}
var Dve = /* @__PURE__ */ yc("<div><div></div></div>");
function Ove(t, e) {
  Vh(e, !0);
  let r = tt(e, "margin", 3, 4), n, i, o = /* @__PURE__ */ gt(() => lL(e.customTooltip)), s = /* @__PURE__ */ gt(() => uL(e.customTooltip, { tooltip: e.tooltip }));
  HS(() => {
    Bm(() => {
      let u = W(o), c = null;
      return Bm(() => {
        i.style.left = "0px", i.style.top = "0px", i.style.pointerEvents = e.allowInteraction ? "all" : "none", c == null ? c = u(i, W(s)) : c.update?.(W(s));
        function h(y, b, k, C) {
          let S = e.location.x, _ = e.location.y, D = 2, A = y / 2, O = b + (e.targetHeight + r());
          S - A < k && (A = S - k), S - A > C - y && (A = S - C + y), _ - O < D && (O = -(e.targetHeight + r())), i.style.left = S - A + "px", i.style.top = _ - O + "px";
        }
        let d = n.getBoundingClientRect(), { width: p, height: g } = i.getBoundingClientRect();
        h(p, g, 2, d.width - 2);
        let v = requestAnimationFrame(() => {
          v = null;
          let y = i.getBoundingClientRect();
          (y.width != p || y.height != g) && h(y.width, y.height, 2, d.width - 2);
        });
        return () => {
          v != null && cancelAnimationFrame(v);
        };
      }), () => {
        c?.destroy?.(), i.replaceChildren();
      };
    });
  });
  var a = Dve();
  Qt(a, "", {}, { position: "absolute", width: "100%" });
  var l = $n(a);
  Qt(l, "", {}, {
    display: "flex",
    position: "absolute",
    width: "fit-content",
    height: "fit-content",
    "z-index": "100"
  }), s_(l, (u) => i = u, () => i), yn(a), s_(a, (u) => n = u, () => n), rn(t, a), Wh();
}
function VS(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function cL(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function b0() {
}
var Bg = 0.7, ub = 1 / Bg, ld = "\\s*([+-]?\\d+)\\s*", Lg = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Wa = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Fve = /^#([0-9a-f]{3,8})$/, Tve = new RegExp(`^rgb\\(${ld},${ld},${ld}\\)$`), Mve = new RegExp(`^rgb\\(${Wa},${Wa},${Wa}\\)$`), Pve = new RegExp(`^rgba\\(${ld},${ld},${ld},${Lg}\\)$`), Rve = new RegExp(`^rgba\\(${Wa},${Wa},${Wa},${Lg}\\)$`), Nve = new RegExp(`^hsl\\(${Lg},${Wa},${Wa}\\)$`), $ve = new RegExp(`^hsla\\(${Lg},${Wa},${Wa},${Lg}\\)$`), X9 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
VS(b0, WS, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: J9,
  // Deprecated! Use color.formatHex.
  formatHex: J9,
  formatHex8: Ive,
  formatHsl: Bve,
  formatRgb: Y9,
  toString: Y9
});
function J9() {
  return this.rgb().formatHex();
}
function Ive() {
  return this.rgb().formatHex8();
}
function Bve() {
  return fL(this).formatHsl();
}
function Y9() {
  return this.rgb().formatRgb();
}
function WS(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = Fve.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? Z9(e) : r === 3 ? new no(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? my(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? my(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = Tve.exec(t)) ? new no(e[1], e[2], e[3], 1) : (e = Mve.exec(t)) ? new no(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Pve.exec(t)) ? my(e[1], e[2], e[3], e[4]) : (e = Rve.exec(t)) ? my(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = Nve.exec(t)) ? rO(e[1], e[2] / 100, e[3] / 100, 1) : (e = $ve.exec(t)) ? rO(e[1], e[2] / 100, e[3] / 100, e[4]) : X9.hasOwnProperty(t) ? Z9(X9[t]) : t === "transparent" ? new no(NaN, NaN, NaN, 0) : null;
}
function Z9(t) {
  return new no(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function my(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new no(t, e, r, n);
}
function Lve(t) {
  return t instanceof b0 || (t = WS(t)), t ? (t = t.rgb(), new no(t.r, t.g, t.b, t.opacity)) : new no();
}
function hL(t, e, r, n) {
  return arguments.length === 1 ? Lve(t) : new no(t, e, r, n ?? 1);
}
function no(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
VS(no, hL, cL(b0, {
  brighter(t) {
    return t = t == null ? ub : Math.pow(ub, t), new no(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Bg : Math.pow(Bg, t), new no(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new no(hh(this.r), hh(this.g), hh(this.b), cb(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: eO,
  // Deprecated! Use color.formatHex.
  formatHex: eO,
  formatHex8: zve,
  formatRgb: tO,
  toString: tO
}));
function eO() {
  return `#${eh(this.r)}${eh(this.g)}${eh(this.b)}`;
}
function zve() {
  return `#${eh(this.r)}${eh(this.g)}${eh(this.b)}${eh((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function tO() {
  const t = cb(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${hh(this.r)}, ${hh(this.g)}, ${hh(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function cb(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function hh(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function eh(t) {
  return t = hh(t), (t < 16 ? "0" : "") + t.toString(16);
}
function rO(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new qs(t, e, r, n);
}
function fL(t) {
  if (t instanceof qs) return new qs(t.h, t.s, t.l, t.opacity);
  if (t instanceof b0 || (t = WS(t)), !t) return new qs();
  if (t instanceof qs) return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, i = Math.min(e, r, n), o = Math.max(e, r, n), s = NaN, a = o - i, l = (o + i) / 2;
  return a ? (e === o ? s = (r - n) / a + (r < n) * 6 : r === o ? s = (n - e) / a + 2 : s = (e - r) / a + 4, a /= l < 0.5 ? o + i : 2 - o - i, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new qs(s, a, l, t.opacity);
}
function jve(t, e, r, n) {
  return arguments.length === 1 ? fL(t) : new qs(t, e, r, n ?? 1);
}
function qs(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
VS(qs, jve, cL(b0, {
  brighter(t) {
    return t = t == null ? ub : Math.pow(ub, t), new qs(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Bg : Math.pow(Bg, t), new qs(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new no(
      Mk(t >= 240 ? t - 240 : t + 120, i, n),
      Mk(t, i, n),
      Mk(t < 120 ? t + 240 : t - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new qs(nO(this.h), gy(this.s), gy(this.l), cb(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = cb(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${nO(this.h)}, ${gy(this.s) * 100}%, ${gy(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function nO(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function gy(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function Mk(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const iO = [
  "#1f77b4",
  "#ff7f0e",
  "#2ca02c",
  "#d62728",
  "#9467bd",
  "#8c564b",
  "#e377c2",
  "#7f7f7f",
  "#bcbd22",
  "#17becf"
], vy = [
  "#1f77b4",
  "#aec7e8",
  "#ff7f0e",
  "#ffbb78",
  "#2ca02c",
  "#98df8a",
  "#d62728",
  "#ff9896",
  "#9467bd",
  "#c5b0d5",
  "#8c564b",
  "#c49c94",
  "#e377c2",
  "#f7b6d2",
  "#7f7f7f",
  "#c7c7c7",
  "#bcbd22",
  "#dbdb8d",
  "#17becf",
  "#9edae5"
];
function mp(t) {
  if (t < 1 && (t = 1), t <= iO.length)
    return iO.slice(0, t);
  if (t <= vy.length)
    return vy.slice(0, t);
  {
    let e = [];
    for (let r = 0; r < t; r++)
      e[r] = vy[r % vy.length];
    return e;
  }
}
function GS(t) {
  let { r: e, g: r, b: n, opacity: i } = hL(t);
  return { r: e / 255, g: r / 255, b: n / 255, a: i };
}
function dL() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}
function KS(t, e) {
  return [
    t[0] * e[0] + t[3] * e[1] + t[6] * e[2],
    t[1] * e[0] + t[4] * e[1] + t[7] * e[2],
    t[2] * e[0] + t[5] * e[1] + t[8] * e[2],
    t[0] * e[3] + t[3] * e[4] + t[6] * e[5],
    t[1] * e[3] + t[4] * e[4] + t[7] * e[5],
    t[2] * e[3] + t[5] * e[4] + t[8] * e[5],
    t[0] * e[6] + t[3] * e[7] + t[6] * e[8],
    t[1] * e[6] + t[4] * e[7] + t[7] * e[8],
    t[2] * e[6] + t[5] * e[7] + t[8] * e[8]
  ];
}
function pL(t, e) {
  return [
    e[0] * t[0] + e[3] * t[1] + e[6] * t[2],
    e[1] * t[0] + e[4] * t[1] + e[7] * t[2],
    e[2] * t[0] + e[5] * t[1] + e[8] * t[2]
  ];
}
function qve(t) {
  return t[0] * t[4] * t[8] - t[0] * t[5] * t[7] - t[1] * t[3] * t[8] + t[1] * t[5] * t[6] + t[2] * t[3] * t[7] - t[2] * t[4] * t[6];
}
function mL(t) {
  let e = qve(t);
  return [
    (t[4] * t[8] - t[5] * t[7]) / e,
    (t[2] * t[7] - t[1] * t[8]) / e,
    (t[1] * t[5] - t[2] * t[4]) / e,
    (t[5] * t[6] - t[3] * t[8]) / e,
    (t[0] * t[8] - t[2] * t[6]) / e,
    (t[2] * t[3] - t[0] * t[5]) / e,
    (t[3] * t[7] - t[4] * t[6]) / e,
    (t[1] * t[6] - t[0] * t[7]) / e,
    (t[0] * t[4] - t[1] * t[3]) / e
  ];
}
class Dx {
  viewport;
  width;
  height;
  _matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  _pixel_kx = 0;
  _pixel_bx = 0;
  _pixel_ky = 0;
  _pixel_by = 0;
  constructor(e, r, n) {
    this.viewport = e, this.width = r, this.height = n, this.updateCoefficients();
  }
  update(e, r, n) {
    this.viewport = e, this.width = r, this.height = n, this.updateCoefficients();
  }
  updateCoefficients() {
    let { x: e, y: r, scale: n } = this.viewport, i = n, o = n;
    this.width < this.height ? i *= this.height / this.width : o *= this.width / this.height, this._matrix = [i, 0, 0, 0, o, 0, -e * i, -r * o, 1], this._pixel_kx = this._matrix[0] * this.width / 2, this._pixel_bx = (this._matrix[6] + 1) * this.width / 2, this._pixel_ky = -this._matrix[4] * this.height / 2, this._pixel_by = (-this._matrix[7] + 1) * this.height / 2;
  }
  matrix() {
    return this._matrix;
  }
  pixelLocation(e, r) {
    return { x: e * this._pixel_kx + this._pixel_bx, y: r * this._pixel_ky + this._pixel_by };
  }
  coordinateAtPixel(e, r) {
    return { x: (e - this._pixel_bx) / this._pixel_kx, y: (r - this._pixel_by) / this._pixel_ky };
  }
  pixelLocationFunction() {
    let e = this._pixel_kx, r = this._pixel_ky, n = this._pixel_bx, i = this._pixel_by;
    return (o, s) => ({ x: o * e + n, y: s * r + i });
  }
  coordinateAtPixelFunction() {
    let e = this._pixel_kx, r = this._pixel_ky, n = this._pixel_bx, i = this._pixel_by;
    return (o, s) => ({ x: (o - n) / e, y: (s - i) / r });
  }
}
let a_ = class {
  _needsRun = !0;
  _inputs = /* @__PURE__ */ new Set();
  _targets = /* @__PURE__ */ new Set();
  constructor(t = []) {
    this._inputs = new Set(t);
    for (let e of this._inputs)
      e._targets.add(this);
  }
  addInput(t) {
    this._inputs.add(t), t._targets.add(this);
  }
  removeInput(t) {
    t._targets.delete(this), this._inputs.delete(t);
  }
  run() {
    if (this._needsRun) {
      for (let t of this._inputs)
        t.run();
      this.update(), this._needsRun = !1;
    }
  }
  setNeedsRunDownstream() {
    for (let t of this._targets)
      t._needsRun || (t._needsRun = !0, t.setNeedsRunDownstream());
  }
  update() {
  }
  destroy() {
    for (let t of this._inputs)
      t._targets.delete(this);
  }
}, gp = class extends a_ {
  _value = null;
  setValue(t) {
    this._value !== t && (this._value = t, this.setNeedsRunDownstream());
  }
  get value() {
    return this.run(), this._value;
  }
};
class gL extends gp {
  constructor(e) {
    super([]), this.setValue(e);
  }
  get value() {
    return super.value;
  }
  set value(e) {
    this.setValue(e);
  }
}
let Uve = class extends gp {
  fn;
  constructor(t, e) {
    super(e), this.fn = t;
  }
  update() {
    this.setValue(this.fn());
  }
}, Hve = class extends gp {
  fn;
  state;
  constructor(t, e) {
    super(e), this.fn = t, this.state = {};
  }
  update() {
    this.setValue(this.fn(this.state));
  }
  destroy() {
    super.destroy(), this.state.destroy && this.state.destroy(), this.state = {};
  }
}, Vve = class extends gp {
  parent;
  condition;
  buildTrue;
  buildFalse;
  context = null;
  currentCondition = null;
  currentNode = null;
  constructor(t, e, r, n) {
    super([e]), this.parent = t, this.condition = e, this.buildTrue = r, this.buildFalse = n;
  }
  update() {
    (this.currentNode == null || this.currentCondition !== this.condition.value) && (this.currentNode && this.removeInput(this.currentNode), this.context?.destroy(), this.context = new Qh(this.parent), this.currentCondition = this.condition.value, this.currentCondition ? this.currentNode = this.buildTrue(this.context) : this.currentNode = this.buildFalse(this.context), this.addInput(this.currentNode)), this.setValue(this.currentNode.value);
  }
  destroy() {
    super.destroy(), this.context?.destroy();
  }
}, Wve = class extends gp {
  parent;
  input;
  build;
  cache;
  constructor(t, e, r) {
    super([e]), this.parent = t, this.input = e, this.build = r, this.cache = /* @__PURE__ */ new Map();
  }
  update() {
    let t = /* @__PURE__ */ new Set(), e = this.input.value.map((r) => {
      if (t.add(r), this.cache.has(r)) {
        let n = this.cache.get(r);
        return n.input.value = r, n.output.value;
      } else {
        let n = new Qh(this.parent), i = new gL(r), o = this.build(n, i);
        return this.cache.set(r, { context: n, input: i, output: o }), this.addInput(o), o.value;
      }
    });
    for (let [r, n] of this.cache)
      t.has(r) || (this.cache.delete(r), this.removeInput(n.output), n.context.destroy());
    this.setValue(e);
  }
  destroy() {
    super.destroy();
    for (let t of this.cache.values())
      t.context.destroy();
  }
}, Gve = class extends gp {
  parent;
  input;
  cases;
  currentCase = null;
  currentNode = null;
  currentContext = null;
  constructor(t, e, r) {
    super([e]), this.parent = t, this.input = e, this.cases = r;
  }
  update() {
    (this.currentNode == null || this.input.value !== this.currentCase) && (this.currentNode && this.removeInput(this.currentNode), this.currentContext?.destroy(), this.currentContext = new Qh(this.parent), this.currentCase = this.input.value, this.currentNode = this.cases[this.currentCase](this.currentContext), this.addInput(this.currentNode)), this.setValue(this.currentNode.value);
  }
  destroy() {
    super.destroy(), this.currentContext?.destroy();
  }
};
class Qh {
  _children;
  _nodes;
  /** Creates a new dataflow context. */
  constructor(e = null) {
    this._children = /* @__PURE__ */ new Set(), this._nodes = /* @__PURE__ */ new Set(), e?._children.add(this);
  }
  /** Destroy the dataflow and all associated states. */
  destroy() {
    for (let e of this._children)
      e.destroy();
    for (let e of this._nodes)
      e.destroy();
    this._children.clear(), this._nodes.clear();
  }
  /** Creates a value node. */
  value(e) {
    let r = new gL(e);
    return this._nodes.add(r), r;
  }
  /** Creates a derived value. */
  derive(e, r) {
    let n = e.map((o) => o instanceof a_ ? o : this.value(o)), i = new Uve(() => r(...n.map((o) => o.value)), n);
    return this._nodes.add(i), i;
  }
  /** Creates a stateful derived value. */
  statefulDerive(e, r) {
    let n = e.map((o) => o instanceof a_ ? o : this.value(o)), i = new Hve((o) => r(o, ...n.map((s) => s.value)), n);
    return this._nodes.add(i), i;
  }
  /** Creates a true or false dataflow depending on the value of the condition. */
  if(e, r, n) {
    let i = new Vve(this, e, r, n);
    return this._nodes.add(i), i;
  }
  switch(e, r) {
    let n = new Gve(this, e, r);
    return this._nodes.add(n), n;
  }
  map(e, r) {
    let n = new Wve(this, e, r);
    return this._nodes.add(n), n;
  }
  assertNotNull(e) {
    return e;
  }
  subgraph() {
    return new Qh(this);
  }
}
function el(t, e, r, n) {
  if (t.program == null || t.vsSource != r || t.fsSource != n) {
    t.destroy && t.destroy();
    let o = oO(e, e.VERTEX_SHADER, r), s = oO(e, e.FRAGMENT_SHADER, n), a = e.createProgram();
    if (e.attachShader(a, o), e.attachShader(a, s), e.linkProgram(a), !e.getProgramParameter(a, e.LINK_STATUS)) {
      var i = e.getProgramInfoLog(a);
      throw new Error(`failed to link program: ${i}, vertex source: ${r}, fragment source: ${n}`);
    }
    t.program = a, t.vsSource = r, t.fsSource = n, t.destroy = () => {
      e.deleteProgram(a), e.deleteShader(o), e.deleteShader(s);
    }, t.uniforms = {};
    for (let l of (r + n).matchAll(/uniform +[0-9a-zA-Z_]+ +([0-9a-zA-Z_]+) *(;|\[)/g)) {
      let u = l[1];
      t.uniforms[u] = e.getUniformLocation(a, u);
    }
  }
  return { program: t.program, uniforms: t.uniforms ?? {} };
}
function oO(t, e, r) {
  let n = t.createShader(e);
  if (t.shaderSource(n, r), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) {
    var i = t.getShaderInfoLog(n);
    throw new Error(`failed to compile shader: ${i}, source: ${r}`);
  }
  return n;
}
function Ga(t, e, r, n) {
  if (t.buffer == null) {
    let i = e.createBuffer();
    t.buffer = i, t.destroy = () => {
      e.deleteBuffer(i);
    };
  }
  if (t.data !== r) {
    if (t.data = r, e.bindBuffer(e.ARRAY_BUFFER, t.buffer), r instanceof Array)
      switch (n ?? "f32") {
        case "f32":
          e.bufferData(e.ARRAY_BUFFER, new Float32Array(r), e.STATIC_DRAW);
          break;
        case "i32":
          e.bufferData(e.ARRAY_BUFFER, new Int32Array(r), e.STATIC_DRAW);
          break;
        case "u32":
          e.bufferData(e.ARRAY_BUFFER, new Uint32Array(r), e.STATIC_DRAW);
          break;
        case "i16":
          e.bufferData(e.ARRAY_BUFFER, new Int16Array(r), e.STATIC_DRAW);
          break;
        case "u16":
          e.bufferData(e.ARRAY_BUFFER, new Uint16Array(r), e.STATIC_DRAW);
          break;
        case "i8":
          e.bufferData(e.ARRAY_BUFFER, new Int8Array(r), e.STATIC_DRAW);
          break;
        case "u8":
          e.bufferData(e.ARRAY_BUFFER, new Uint8Array(r), e.STATIC_DRAW);
          break;
        default:
          throw new Error("invalid type");
      }
    else
      e.bufferData(e.ARRAY_BUFFER, r, e.STATIC_DRAW);
    e.bindBuffer(e.ARRAY_BUFFER, null);
  }
  return t.buffer;
}
function Kve(t, e, r, n, i) {
  const o = {
    u8: {
      1: [t.R8, t.RED, t.UNSIGNED_BYTE],
      2: [t.RG8, t.RG, t.UNSIGNED_BYTE],
      3: [t.RGB8, t.RGB, t.UNSIGNED_BYTE],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_BYTE]
    },
    u16: {
      1: [t.R8, t.RED, t.UNSIGNED_SHORT],
      2: [t.RG8, t.RG, t.UNSIGNED_SHORT],
      3: [t.RGB8, t.RGB, t.UNSIGNED_SHORT],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_SHORT]
    },
    u32: {
      1: [t.R8, t.RED, t.UNSIGNED_INT],
      2: [t.RG8, t.RG, t.UNSIGNED_INT],
      3: [t.RGB8, t.RGB, t.UNSIGNED_INT],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_INT]
    },
    f32: {
      1: [t.R32F, t.RED, t.FLOAT],
      2: [t.RG32F, t.RG, t.FLOAT],
      3: [t.RGB32F, t.RGB, t.FLOAT],
      4: [t.RGBA32F, t.RGBA, t.FLOAT]
    }
  };
  let [s, a, l] = o[i][n];
  t.texImage2D(t.TEXTURE_2D, 0, s, e, r, 0, a, l, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
}
function Bu(t, e, r, n, i, o) {
  if (t.framebuffer == null || t.texture == null) {
    let a = e.createFramebuffer(), l = e.createTexture();
    e.bindFramebuffer(e.FRAMEBUFFER, a), e.bindTexture(e.TEXTURE_2D, l), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, l, 0), e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), t.framebuffer = a, t.texture = l, t.destroy = () => {
      e.deleteFramebuffer(a), e.deleteTexture(l);
    };
  }
  let s = `${r},${n},${i},${o}`;
  return t.cacheKey != s && (t.cacheKey = s, e.bindTexture(e.TEXTURE_2D, t.texture), Kve(e, r, n, i, o), e.bindTexture(e.TEXTURE_2D, null)), {
    framebuffer: t.framebuffer,
    texture: t.texture,
    width: r,
    height: n
  };
}
function Qve(t) {
  let e = t.squareMaxSize, r = t.samples, n = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, i = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;
    void main() {
      vec4 color = vec4(0.0);
      const int count = ${e};
      int i = -count;
      while(i + 1 <= count) {
        color += texture(image, uv + direction * (float(i) + 0.5) / resolution) * 2.0;
        i += 2;
      }
      if (i <= count) {
        color += texture(image, uv + direction * float(count) / resolution);
      }
      outColor = color;
    }
  `, o = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform sampler2D imageBox;
    uniform vec2 resolution;
    uniform float scaler;
    in vec2 uv;
    out vec4 outColor;

    void main() {
      vec4 color = texture(imageBox, uv);
      if (color != vec4(0.0)) {
        ${r.map(({ x: s, y: a, w: l }) => `color -= texture(image, uv + vec2(${s.toFixed(8)}, ${a.toFixed(8)}) / resolution) * (${l.toFixed(8)})`).join(";")};
      }
      outColor = color * scaler;
    }
  `;
  return { vertex: n, fragment1: i, fragment2: o };
}
function Xve(t, e, r) {
  let n = t.derive([r], Jve), i = t.derive([n], Qve), o = t.statefulDerive(
    [e, t.derive([i], (l) => l.vertex), t.derive([i], (l) => l.fragment1)],
    el
  ), s = t.statefulDerive(
    [e, t.derive([i], (l) => l.vertex), t.derive([i], (l) => l.fragment2)],
    el
  ), a = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ga);
  return t.derive(
    [e, a, o, s, r, n],
    (l, u, c, h, d, p) => (g, v, y) => {
      let { width: b, height: k } = v;
      l.disable(l.BLEND), l.enableVertexAttribArray(0), l.bindBuffer(l.ARRAY_BUFFER, u), l.vertexAttribPointer(0, 2, l.FLOAT, !1, 0, 0), l.bindBuffer(l.ARRAY_BUFFER, null), l.useProgram(c.program), l.uniform2f(c.uniforms.resolution, b, k), l.uniform1i(c.uniforms.image, 0), l.bindFramebuffer(l.FRAMEBUFFER, v.framebuffer), l.bindTexture(l.TEXTURE_2D, g), l.uniform2f(c.uniforms.direction, 0, 1), l.drawArrays(l.TRIANGLE_STRIP, 0, 4), l.bindFramebuffer(l.FRAMEBUFFER, y.framebuffer), l.bindTexture(l.TEXTURE_2D, v.texture), l.uniform2f(c.uniforms.direction, 1, 0), l.drawArrays(l.TRIANGLE_STRIP, 0, 4), l.bindFramebuffer(l.FRAMEBUFFER, v.framebuffer), l.activeTexture(l.TEXTURE1), l.bindTexture(l.TEXTURE_2D, y.texture), l.activeTexture(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, g), l.useProgram(h.program), l.uniform2f(h.uniforms.resolution, b, k), l.uniform1i(h.uniforms.image, 0), l.uniform1i(h.uniforms.imageBox, 1);
      let C = 1 / p.totalWeight * d * d * Math.PI;
      l.uniform1f(h.uniforms.scaler, C), l.drawArrays(l.TRIANGLE_STRIP, 0, 4), l.bindFramebuffer(l.FRAMEBUFFER, null), l.useProgram(null), l.activeTexture(l.TEXTURE1), l.bindTexture(l.TEXTURE_2D, null), l.activeTexture(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, null), l.disableVertexAttribArray(0);
    }
  );
}
function sO(t, e, r) {
  let n = Math.sqrt(e * e + r * r);
  if (n < t - Math.sqrt(2) / 2)
    return 1;
  if (n > t + Math.sqrt(2) / 2)
    return 0;
  let i = 2, o = 0;
  for (let s = 0; s < i; s++)
    for (let a = 0; a < i; a++) {
      let l = e + (s + 0.5) / i - 0.5, u = r + (a + 0.5) / i - 0.5;
      Math.sqrt(l * l + u * u) < t && (o += 1);
    }
  return o / i / i;
}
function Jve(t) {
  let e = Math.floor(t + 0.5), r = e, n = sO(t, 0, 0), i = [];
  for (let a = -e; a <= e; a++)
    for (let l = -e; l <= e; l++) {
      let u = n - sO(t, a, l);
      if (!(u <= 0))
        if (i.length > 0 && a == i[i.length - 1].x && l == i[i.length - 1].y + 1) {
          let c = i[i.length - 1].w, h = u;
          i[i.length - 1].y += 1 - c / (c + h), i[i.length - 1].w = c + h;
        } else
          i.push({ x: a, y: l, w: u });
    }
  i = i.sort((a, l) => a.y != l.y ? a.y - l.y : a.x - l.x);
  let o = [];
  for (let { x: a, y: l, w: u } of i)
    if (o.length > 0 && l == o[o.length - 1].y && a == o[o.length - 1].x + 1) {
      let c = o[o.length - 1].w, h = u;
      o[o.length - 1].x += 1 - c / (c + h), o[o.length - 1].w = c + h;
    } else
      o.push({ x: a, y: l, w: u });
  let s = -o.reduce((a, l) => a + l.w, 0);
  return s += n * (1 + r * 2) * (1 + r * 2), { squareMaxSize: r, squareWeight: n, samples: o, totalWeight: s };
}
function Yve(t) {
  let e;
  return t ? e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      layout(location=0) in float x;
      layout(location=1) in float y;
      layout(location=2) in int category;
      out vec4 color;
      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        if (category == 0) {
          color = vec4(1, 0, 0, 0);
        } else if (category == 1) {
          color = vec4(0, 1, 0, 0);
        } else if (category == 2) {
          color = vec4(0, 0, 1, 0);
        } else if (category == 3) {
          color = vec4(0, 0, 0, 1);
        }
        gl_PointSize = 1.0;
      }
    ` : e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      layout(location=0) in float x;
      layout(location=1) in float y;
      out vec4 color;
      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        color = vec4(1, 0, 0, 0);
        gl_PointSize = 1.0;
      }
    `, { vertex: e, fragment: `#version 300 es
    precision highp float;
    in vec4 color;
    out vec4 outColor;
    void main() {
      outColor = color;
    }
  ` };
}
function l_(t, e, r, n, i, o) {
  let s = i != null, a = Yve(s), l = t.statefulDerive([e, a.vertex, a.fragment], el);
  return t.derive([e, l, r, n, i, o], (u, c, h, d, p, g) => (v) => {
    u.enable(u.BLEND), u.blendFunc(u.ONE, u.ONE), u.useProgram(c.program), u.enableVertexAttribArray(0), u.bindBuffer(u.ARRAY_BUFFER, h), u.vertexAttribPointer(0, 1, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(1), u.bindBuffer(u.ARRAY_BUFFER, d), u.vertexAttribPointer(1, 1, u.FLOAT, !1, 0, 0), p != null && (u.enableVertexAttribArray(2), u.bindBuffer(u.ARRAY_BUFFER, p), u.vertexAttribIPointer(2, 1, u.BYTE, 0, 0)), u.bindBuffer(u.ARRAY_BUFFER, null), u.uniformMatrix3fv(c.uniforms.matrix, !1, v), u.drawArrays(u.POINTS, 0, g), u.disableVertexAttribArray(0), u.disableVertexAttribArray(1), p != null && u.disableVertexAttribArray(2), u.useProgram(null);
  });
}
function Zve() {
  return { vertex: `#version 300 es
    precision highp float;
    uniform vec2 xyScaler;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy * xyScaler, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform float gamma;
    in vec2 uv;
    out vec4 outColor;
    void main() {
      vec4 color = texture(source, uv);
      color.rgb = pow(color.rgb, vec3(1.0 / gamma));
      outColor = color;
    }
  ` };
}
function vL(t, e) {
  let { vertex: r, fragment: n } = Zve(), i = t.statefulDerive([e, r, n], el), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ga);
  return t.derive([e, i, o], (s, a, l) => (u, c, h, d) => {
    s.disable(s.BLEND), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.xyScaler, h ?? 1, d ?? 1), s.uniform1f(a.uniforms.gamma, c ?? 2.2), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
  });
}
function yL(t) {
  return Math.ceil(t * 3);
}
function eye(t) {
  let e = yL(t), r = [];
  for (let a = -e; a <= e; a++)
    r.push(Math.exp(-a * a / t / t / 2));
  let n = r.reduce((a, l) => a + l, 0);
  r = r.map((a) => a / n);
  let i = rye(r).map(([a, l]) => [a - e, l]), o = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, s = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;

    void main() {
      vec4 color = vec4(0.0);
      ${i.map(([a, l]) => `color += texture(image, uv + direction * vec2(${a.toFixed(10)}) / resolution) * ${l.toFixed(10)};`).join(`
`)}
      outColor = color;
    }
  `;
  return { vertex: o, fragment: s };
}
function tye(t, e, r) {
  let n = t.derive([r], eye), i = t.statefulDerive(
    [e, t.derive([n], (s) => s.vertex), t.derive([n], (s) => s.fragment)],
    el
  ), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ga);
  return t.derive([e, o, i, r], (s, a, l, u) => (c, h, d) => {
    let { width: p, height: g } = h;
    s.disable(s.BLEND), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, a), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.useProgram(l.program), s.uniform2f(l.uniforms.resolution, p, g), s.uniform1i(l.uniforms.image, 0), s.bindFramebuffer(s.FRAMEBUFFER, d.framebuffer), s.bindTexture(s.TEXTURE_2D, c), s.uniform2f(l.uniforms.direction, 0, 1), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.bindFramebuffer(s.FRAMEBUFFER, h.framebuffer), s.bindTexture(s.TEXTURE_2D, d.texture), s.uniform2f(l.uniforms.direction, 1, 0), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.bindFramebuffer(s.FRAMEBUFFER, null), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
  });
}
function rye(t) {
  let e = [];
  for (let r = 0; r < t.length; r += 2)
    if (r + 1 < t.length) {
      let n = t[r], i = t[r + 1], o = 1 - n / (n + i);
      if (o >= 0 && o <= 1) {
        let s = n + i;
        s != 0 && e.push([r + o, s]);
      } else
        e.push([r, t[r]]), e.push([r + 1, t[r + 1]]);
    } else
      e.push([r, t[r]]);
  return e;
}
function nye(t) {
  return Math.ceil(t * 3);
}
function iye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;

    uniform float weight0;
    uniform vec3 distances;
    uniform vec3 weights;

    void main() {
      vec4 color = texture(image, uv) * weight0;
      if (weights.x != 0.0) {
        color += texture(image, uv + direction * vec2(distances.x) / resolution) * weights.x;
        color += texture(image, uv - direction * vec2(distances.x) / resolution) * weights.x;
      }
      if (weights.y != 0.0) {
        color += texture(image, uv + direction * vec2(distances.y) / resolution) * weights.y;
        color += texture(image, uv - direction * vec2(distances.y) / resolution) * weights.y;
      }
      if (weights.z != 0.0) {
        color += texture(image, uv + direction * vec2(distances.z) / resolution) * weights.z;
        color += texture(image, uv - direction * vec2(distances.z) / resolution) * weights.z;
      }
      outColor = color;
    }
  ` };
}
function oye(t, e, r) {
  let { vertex: n, fragment: i } = iye(), o = t.statefulDerive([e, n, i], el), s = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ga);
  return t.derive([e, s, o], (a, l, u) => (c, h, d) => {
    let { width: p, height: g } = h;
    a.disable(a.BLEND), a.enableVertexAttribArray(0), a.bindBuffer(a.ARRAY_BUFFER, l), a.vertexAttribPointer(0, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, null), a.useProgram(u.program), a.uniform2f(u.uniforms.resolution, p, g), a.uniform1i(u.uniforms.image, 0);
    let v = c, y = d, b = h;
    for (let k = 0; k < 2; k++) {
      a.uniform2f(u.uniforms.direction, k, 1 - k);
      for (let [C, S, _] of sye) {
        a.bindFramebuffer(a.FRAMEBUFFER, y.framebuffer), a.bindTexture(a.TEXTURE_2D, v), a.uniform1fv(u.uniforms.weight0, S), a.uniform3fv(u.uniforms.distances, C), a.uniform3fv(u.uniforms.weights, _), a.drawArrays(a.TRIANGLE_STRIP, 0, 4), v = y.texture;
        let D = y;
        y = b, b = D;
      }
    }
    a.bindFramebuffer(a.FRAMEBUFFER, null), a.useProgram(null), a.bindTexture(a.TEXTURE_2D, null), a.disableVertexAttribArray(0);
  });
}
const sye = [
  [[1, 2, 3], [0.2288468365182578], [0.18230006506971572, 0.1356122230111784, 0.06766429365997693]],
  [[2, 6, 10], [0.09116254014100238], [0.23317759354726447, 0.18385867277788717, 0.03738246360434722]],
  [[3, 10, 20], [0.2950645715317288], [0.010918865853671198, 0.23773695670296047, 0.10381189167750389]],
  [[4, 16, 30], [0.20085957073474772], [0.14463019087130788, 0.17934533765938643, 0.07559468610193185]]
];
function aye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform float densityScaler;
    uniform float quantizationStep;
    uniform vec4 channelMask;
    uniform vec4 color;
    uniform float globalAlpha;

    in vec2 uv;
    out vec4 outColor;

    float sample_density(vec2 uv) {
      float d = dot(texture(source, uv), channelMask) * densityScaler;
      d = min(1.0, max(0.0, d));
      d = floor(d / quantizationStep);
      return d;
    }

    void main() {
      // Run the Sobel operator.
      float v = sample_density(uv);
      float v11 = sample_density(uv + vec2(-1, -1) / resolution);
      float v12 = sample_density(uv + vec2(-1,  0) / resolution);
      float v13 = sample_density(uv + vec2(-1, +1) / resolution);
      float v21 = sample_density(uv + vec2( 0, -1) / resolution);
      float v23 = sample_density(uv + vec2( 0, +1) / resolution);
      float v31 = sample_density(uv + vec2(+1, -1) / resolution);
      float v32 = sample_density(uv + vec2(+1,  0) / resolution);
      float v33 = sample_density(uv + vec2(+1, +1) / resolution);
      float gx = v11 + v12 * 2.0 + v13 - v31 - v32 * 2.0 - v33;
      float gy = v11 + v21 * 2.0 + v31 - v13 - v23 * 2.0 - v33;
      // Derive alpha value from the result.
      float alpha = length(vec2(gx, gy)) * 0.2;
      alpha = min(1.0, max(0.0, alpha));
      outColor = color * alpha * globalAlpha;
    }
  ` };
}
function lye(t, e) {
  let { vertex: r, fragment: n } = aye(), i = t.statefulDerive([e, r, n], el), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ga);
  return t.derive(
    [e, i, o],
    (s, a, l) => (u, c, h, d, p, g) => {
      s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u.texture), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.resolution, u.width, u.height), s.uniform1f(a.uniforms.densityScaler, c), s.uniform1f(a.uniforms.quantizationStep, h), s.uniform1f(a.uniforms.globalAlpha, d), s.uniform4fv(a.uniforms.channelMask, p), s.uniform4fv(a.uniforms.color, g), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
    }
  );
}
function uye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
    `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform float densityScaler;
    uniform float quantizationStep;

    uniform mat4 colorMatrix;
    uniform int isDarkMode;
    uniform float globalAlpha;

    in vec2 uv;
    out vec4 outColor;

    /* Combine alphas with symmetric blending equation f(a, b) = a + b - ab. */
    float combine_alphas(vec4 alphas) {
      float r = alphas.x + alphas.y - alphas.x * alphas.y;
      r = r + alphas.z - r * alphas.z;
      r = r + alphas.w - r * alphas.w;
      return r;
    }

    void main() {
      vec4 density = texture(source, uv) * densityScaler;

      if (density.x > 1.0 || density.y > 1.0 || density.z > 1.0 || density.w > 1.0) {
        density = density / max(max(max(density.x, density.y), density.z), density.w);
      } else {
        density = floor(density / quantizationStep) * quantizationStep;
      }

      if (density.x + density.y + density.z + density.w == 0.0) {
        discard;
      }

      float alpha = combine_alphas(density);

      density *= alpha / (density.x + density.y + density.z + density.w);

      vec3 c1 = colorMatrix[0].rgb * density.x;
      vec3 c2 = colorMatrix[1].rgb * density.y;
      vec3 c3 = colorMatrix[2].rgb * density.z;
      vec3 c4 = colorMatrix[3].rgb * density.w;
      vec3 c;

      if (isDarkMode == 0) {
        c = vec3(1.0) - alpha + c1 + c2 + c3 + c4;
      } else {
        c = c1 + c2 + c3 + c4;
      }

      outColor = vec4(c, 1.0) * alpha * globalAlpha;
    }
  ` };
}
function cye(t, e) {
  let { vertex: r, fragment: n } = uye(), i = t.statefulDerive([e, r, n], el), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ga);
  return t.derive(
    [e, i, o],
    (s, a, l) => (u, c, h, d, p, g) => {
      s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u.texture), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.resolution, u.width, u.height), s.uniform1f(a.uniforms.densityScaler, c), s.uniform1f(a.uniforms.quantizationStep, h), s.uniform1f(a.uniforms.globalAlpha, d), s.uniform1i(a.uniforms.isDarkMode, g == "dark" ? 1 : 0), s.uniformMatrix4fv(a.uniforms.colorMatrix, !1, p), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
    }
  );
}
function hye(t) {
  let e;
  return t ? e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      uniform float point_size;
      uniform float alpha;
      uniform vec4 colorScheme[64];

      layout(location=0) in float x;
      layout(location=1) in float y;
      layout(location=2) in int category;

      out vec4 color;

      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        if (category < 64) {
          color = colorScheme[category];
        } else {
          color = vec4(0.5, 0.5, 0.5, 1);
        }
        color *= alpha;
        gl_PointSize = point_size;
      }
    ` : e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      uniform float point_size;
      uniform vec4 colorScheme;
      uniform float alpha;

      layout(location=0) in float x;
      layout(location=1) in float y;

      out vec4 color;

      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        color = colorScheme;
        color *= alpha;
        gl_PointSize = point_size;
      }
    `, { vertex: e, fragment: `#version 300 es
    precision highp float;
    uniform float point_size;
    in vec4 color;
    out vec4 outColor;
    void main() {
      float r = length(gl_PointCoord.xy - vec2(0.5, 0.5)) * point_size;
      float a = max(0.0, min(1.0, point_size / 2.0 - r));
      outColor = color * a;
    }
  ` };
}
function aO(t, e, r, n, i, o) {
  let s = i != null, a = hye(s), l = t.statefulDerive([e, a.vertex, a.fragment], el);
  return t.derive(
    [e, l, r, n, i, o],
    (u, c, h, d, p, g) => (v, y, b, k) => {
      u.enable(u.BLEND), u.blendFunc(u.ONE, u.ONE_MINUS_SRC_ALPHA), u.useProgram(c.program), u.enableVertexAttribArray(0), u.bindBuffer(u.ARRAY_BUFFER, h), u.vertexAttribPointer(0, 1, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(1), u.bindBuffer(u.ARRAY_BUFFER, d), u.vertexAttribPointer(1, 1, u.FLOAT, !1, 0, 0), p != null && (u.enableVertexAttribArray(2), u.bindBuffer(u.ARRAY_BUFFER, p), u.vertexAttribIPointer(2, 1, u.BYTE, 0, 0)), u.bindBuffer(u.ARRAY_BUFFER, null), u.uniformMatrix3fv(c.uniforms.matrix, !1, v), u.uniform1f(c.uniforms.point_size, y * 2), u.uniform1f(c.uniforms.alpha, b), s ? u.uniform4fv(c.uniforms.colorScheme, k) : u.uniform4fv(c.uniforms.colorScheme, k.slice(0, 4)), u.drawArrays(u.POINTS, 0, g), u.disableVertexAttribArray(0), u.disableVertexAttribArray(1), p != null && u.disableVertexAttribArray(2), u.useProgram(null);
    }
  );
}
function fye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform mat4 colorMatrix;
    uniform float pointAlpha;
    uniform float globalAlpha;
    uniform int isDarkMode;
    in vec2 uv;
    out vec4 outColor;

    /* Combine alphas with symmetric blending equation f(a, b) = a + b - ab. */
    float combine_alphas(vec4 alphas) {
      float r = alphas.x + alphas.y - alphas.x * alphas.y;
      r = r + alphas.z - r * alphas.z;
      r = r + alphas.w - r * alphas.w;
      return r;
    }

    void main() {
      vec4 count = texture(source, uv);
      vec4 alphas = pointAlpha >= 0.999
        ? vec4(count.x > 0.0 ? 1.0 : 0.0, count.y > 0.0 ? 1.0 : 0.0, count.z > 0.0 ? 1.0 : 0.0, count.w > 0.0 ? 1.0 : 0.0)
        : vec4(1.0) - pow(vec4(1.0 - pointAlpha), count);
      float a = combine_alphas(alphas);
      if (a <= 0.0) { discard; }
      alphas *= a / (alphas.x + alphas.y + alphas.z + alphas.w);

      vec3 c1 = colorMatrix[0].rgb * alphas.x;
      vec3 c2 = colorMatrix[1].rgb * alphas.y;
      vec3 c3 = colorMatrix[2].rgb * alphas.z;
      vec3 c4 = colorMatrix[3].rgb * alphas.w;
      vec3 c;
      if (isDarkMode == 0) {
        c = vec3(1.0) - a + c1 + c2 + c3 + c4;
      } else {
        c = c1 + c2 + c3 + c4;
      }
      outColor = vec4(c, 1.0) * a * globalAlpha;
    }
  ` };
}
function dye(t, e) {
  let { vertex: r, fragment: n } = fye(), i = t.statefulDerive([e, r, n], el), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ga);
  return t.derive(
    [e, i, o],
    (s, a, l) => (u, c, h, d, p) => {
      s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u.texture), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.resolution, u.width, u.height), s.uniform1f(a.uniforms.pointAlpha, c), s.uniform1f(a.uniforms.globalAlpha, h), s.uniform1i(a.uniforms.isDarkMode, p == "dark" ? 1 : 0), s.uniformMatrix4fv(a.uniforms.colorMatrix, !1, d), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
    }
  );
}
let pye = class {
  props;
  viewport;
  df;
  gl;
  renderInputs;
  dataBuffers;
  renderer;
  constructor(t, e, r) {
    this.props = {
      mode: "points",
      colorScheme: "light",
      x: new Float32Array(),
      y: new Float32Array(),
      category: null,
      categoryCount: 1,
      categoryColors: null,
      viewportX: 0,
      viewportY: 0,
      viewportScale: 1,
      pointSize: 1,
      pointAlpha: 1,
      pointsAlpha: 1,
      densityScaler: 1,
      densityBandwidth: 1,
      densityQuantizationStep: 0.1,
      contoursAlpha: 1,
      densityAlpha: 1,
      gamma: 2.2,
      width: e,
      height: r
    }, this.viewport = new Dx({ x: 0, y: 0, scale: 1 }, e, r);
    let n = new Qh(), i = n.value(t);
    this.df = n, this.gl = i, this.renderInputs = {
      mode: n.value(this.props.mode),
      colorScheme: n.value(this.props.colorScheme),
      xData: n.value(this.props.x),
      yData: n.value(this.props.y),
      categoryData: n.value(this.props.category),
      categoryCount: n.value(this.props.categoryCount),
      matrix: n.value(dL()),
      width: n.value(e),
      height: n.value(r),
      pointSize: n.value(this.props.pointSize),
      densityBandwidth: n.value(this.props.densityBandwidth)
    }, this.dataBuffers = mye(n, i, this.renderInputs), this.renderer = gye(n, i, this.renderInputs, this.dataBuffers);
  }
  setProps(t) {
    let e = !1, r;
    for (r in t)
      t[r] !== this.props[r] && (this.props[r] = t[r], e = !0);
    return this.viewport.update(
      { x: this.props.viewportX, y: this.props.viewportY, scale: this.props.viewportScale },
      this.props.width,
      this.props.height
    ), this.renderInputs.mode.value = this.props.mode, this.renderInputs.colorScheme.value = this.props.colorScheme, this.renderInputs.xData.value = this.props.x, this.renderInputs.yData.value = this.props.y, this.renderInputs.categoryData.value = this.props.category, this.props.category != null ? this.renderInputs.categoryCount.value = this.props.categoryCount : this.renderInputs.categoryCount.value = 1, this.renderInputs.matrix.value = this.viewport.matrix(), this.renderInputs.width.value = this.props.width, this.renderInputs.height.value = this.props.height, this.renderInputs.pointSize.value = this.props.pointSize, this.renderInputs.densityBandwidth.value = this.props.densityBandwidth, e;
  }
  render() {
    this.renderer.value(this.props);
  }
  destroy() {
    this.df.destroy();
  }
  async densityMap(t, e, r, n) {
    let i = this.df.subgraph(), o = bye(i, this.gl, this.dataBuffers, i.value(t), i.value(e), i.value(r)), { x: s, y: a, scale: l } = n, u = [l, 0, 0, 0, l, 0, -s * l, -a * l, 1], c = o.value(u), h = mL(u);
    return i.destroy(), {
      data: c,
      width: t,
      height: e,
      coordinateAtPixel: (d, p) => {
        let g = d / t * 2 - 1, v = p / e * 2 - 1, y = pL([g, v, 1], h);
        return { x: y[0], y: y[1] };
      }
    };
  }
};
function mye(t, e, r) {
  const n = t.statefulDerive([e, r.xData, "f32"], Ga), i = t.statefulDerive([e, r.yData, "f32"], Ga), o = t.if(
    t.derive([r.categoryData], (a) => a != null),
    (a) => a.statefulDerive([e, a.assertNotNull(r.categoryData), "u8"], Ga),
    (a) => a.value(null)
  ), s = t.derive([r.xData], (a) => a.length);
  return { x: n, y: i, category: o, count: s };
}
function gye(t, e, r, n) {
  return t.switch(r.mode, {
    points: (i) => vye(i, e, r, n),
    density: (i) => yye(i, e, r, n)
  });
}
function vye(t, e, r, n) {
  const i = t.derive([r.categoryCount], (l) => l > 1), o = t.statefulDerive([e, r.width, r.height, 4, "f32"], Bu);
  let s = t.if(
    i,
    (l) => aO(l, e, n.x, n.y, l.assertNotNull(n.category), n.count),
    (l) => aO(l, e, n.x, n.y, null, n.count)
  ), a = vL(t, e);
  return t.derive(
    [e, o, s, a, r.colorScheme, r.matrix, r.categoryCount],
    (l, u, c, h, d, p, g) => (v) => {
      let y = [], b = v.categoryColors ?? mp(v.categoryCount);
      for (let k = 0; k < g; k++)
        if (k < b.length) {
          let { r: C, g: S, b: _ } = GS(b[k]);
          C = Math.pow(C, v.gamma), S = Math.pow(S, v.gamma), _ = Math.pow(_, v.gamma), y = y.concat([C, S, _, 1]);
        } else
          y = y.concat([0.5, 0.5, 0.5, 1]);
      l.bindFramebuffer(l.FRAMEBUFFER, u.framebuffer), l.viewport(0, 0, u.width, u.height), d == "light" ? l.clearColor(1, 1, 1, 1) : l.clearColor(0, 0, 0, 1), l.clear(l.COLOR_BUFFER_BIT), c(p, Math.max(3, v.pointSize), v.pointAlpha * v.pointsAlpha, y), l.bindFramebuffer(l.FRAMEBUFFER, null), l.viewport(0, 0, v.width, v.height), h(u.texture, v.gamma);
    }
  );
}
function yye(t, e, r, n) {
  let i = t.derive([r.densityBandwidth], (C) => nye(C) + 1), o = t.derive([r.width, i], (C, S) => C + S * 2), s = t.derive([r.height, i], (C, S) => C + S * 2);
  const a = t.derive([r.categoryCount], (C) => C > 1), l = t.statefulDerive([e, o, s, 4, "f32"], Bu), u = t.statefulDerive([e, o, s, 4, "f32"], Bu), c = t.statefulDerive([e, o, s, 4, "f32"], Bu), h = t.statefulDerive([e, o, s, 4, "f32"], Bu);
  let d = t.if(
    a,
    (C) => l_(C, e, n.x, n.y, C.assertNotNull(n.category), n.count),
    (C) => l_(C, e, n.x, n.y, null, n.count)
  ), p = Xve(t, e, r.pointSize), g = oye(t, e, r.densityBandwidth), v = dye(t, e), y = cye(t, e), b = lye(t, e), k = vL(t, e);
  return t.derive(
    [
      e,
      l,
      u,
      c,
      h,
      r.colorScheme,
      r.matrix,
      d,
      p,
      g,
      v,
      y,
      b,
      k
    ],
    (C, S, _, D, A, O, M, z, R, N, I, B, $, q) => (U) => {
      let H = U.categoryColors ?? mp(U.categoryCount), G = [];
      for (let ne = 0; ne < 4; ne++)
        if (ne < H.length) {
          let { r: ce, g: Ce, b: Pe } = GS(H[ne]);
          ce = Math.pow(ce, U.gamma), Ce = Math.pow(Ce, U.gamma), Pe = Math.pow(Pe, U.gamma), G = G.concat([ce, Ce, Pe, 1]);
        } else
          G = G.concat([0.5, 0.5, 0.5, 1]);
      let re = U.width / _.width, ie = U.height / _.height, se = KS([re, 0, 0, 0, ie, 0, 0, 0, 1], M);
      if (C.bindFramebuffer(C.FRAMEBUFFER, S.framebuffer), C.viewport(0, 0, S.width, S.height), C.clearColor(0, 0, 0, 0), C.clear(C.COLOR_BUFFER_BIT), z(se), C.bindFramebuffer(C.FRAMEBUFFER, _.framebuffer), C.viewport(0, 0, _.width, _.height), O == "light" ? C.clearColor(1, 1, 1, 1) : C.clearColor(0, 0, 0, 1), C.clear(C.COLOR_BUFFER_BIT), U.pointAlpha > 0 && U.pointsAlpha > 0 && (R(S.texture, D, A), C.bindFramebuffer(C.FRAMEBUFFER, _.framebuffer), I(D, U.pointAlpha, U.pointsAlpha, G, O)), U.densityScaler > 0 && (U.densityAlpha > 0 || U.contoursAlpha > 0) && (N(S.texture, D, A), C.bindFramebuffer(C.FRAMEBUFFER, _.framebuffer), U.densityAlpha > 0 && B(
        D,
        U.densityScaler,
        U.densityQuantizationStep,
        U.densityAlpha,
        G,
        O
      ), U.contoursAlpha > 0))
        for (let ne = 0; ne < H.length; ne++) {
          let ce = [0, 0, 0, 0];
          ce[ne] = 1, $(
            D,
            U.densityScaler,
            U.densityQuantizationStep,
            U.contoursAlpha,
            ce,
            G.slice(ne * 4, ne * 4 + 4)
          );
        }
      C.bindFramebuffer(C.FRAMEBUFFER, null), C.viewport(0, 0, U.width, U.height), q(_.texture, U.gamma, 1 / re, 1 / ie);
    }
  );
}
function bye(t, e, r, n, i, o) {
  let s = t.derive([o], (g) => yL(g) + 1), a = t.derive([n, s], (g, v) => g + v * 2), l = t.derive([i, s], (g, v) => g + v * 2);
  const u = t.statefulDerive([e, a, l, 1, "f32"], Bu), c = t.statefulDerive([e, a, l, 1, "f32"], Bu), h = t.statefulDerive([e, a, l, 1, "f32"], Bu);
  let d = l_(t, e, r.x, r.y, null, r.count), p = tye(t, e, o);
  return t.derive(
    [e, s, n, i, u, c, h, d, p],
    (g, v, y, b, k, C, S, _, D) => (A) => {
      let O = y / k.width, M = b / k.height, z = KS([O, 0, 0, 0, M, 0, 0, 0, 1], A);
      g.bindFramebuffer(g.FRAMEBUFFER, k.framebuffer), g.viewport(0, 0, k.width, k.height), g.clearColor(0, 0, 0, 0), g.clear(g.COLOR_BUFFER_BIT), _(z), D(k.texture, C, S), g.bindFramebuffer(g.FRAMEBUFFER, C.framebuffer);
      let R = new Float32Array(y * b);
      return g.readPixels(v, v, y, b, g.RED, g.FLOAT, R), g.bindFramebuffer(g.FRAMEBUFFER, null), R;
    }
  );
}
let xye = class {
  i32View;
  u32View;
  f32View;
  offset;
  constructor(t) {
    this.i32View = new Int32Array(t), this.u32View = new Uint32Array(t), this.f32View = new Float32Array(t), this.offset = 0;
  }
  align2() {
    this.offset % 2 != 0 && (this.offset += 2 - this.offset % 2);
  }
  align4() {
    this.offset % 4 != 0 && (this.offset += 4 - this.offset % 4);
  }
  f32(t) {
    this.f32View[this.offset++] = t;
  }
  u32(t) {
    this.u32View[this.offset++] = t;
  }
  i32(t) {
    this.i32View[this.offset++] = t;
  }
  vec2f(t, e) {
    this.align2(), this.f32View[this.offset++] = t, this.f32View[this.offset++] = e;
  }
  vec3f(t, e, r) {
    this.align4(), this.f32View[this.offset++] = t, this.f32View[this.offset++] = e, this.f32View[this.offset++] = r;
  }
  vec4f(t, e, r, n) {
    this.align4(), this.f32View[this.offset++] = t, this.f32View[this.offset++] = e, this.f32View[this.offset++] = r, this.f32View[this.offset++] = n;
  }
  mat3x3f(t) {
    this.vec3f(t[0], t[1], t[2]), this.vec3f(t[3], t[4], t[5]), this.vec3f(t[6], t[7], t[8]);
  }
  byteOffset() {
    return this.offset * 4;
  }
};
function wye(t, e) {
  let r = new ArrayBuffer(4288), n = t.statefulDerive(
    [e, 4288, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.VERTEX],
    od
  );
  return {
    buffer: n,
    update: t.derive([e, n], (i, o) => (s) => {
      let a = new xye(r);
      a.u32(s.count), a.u32(s.category_count), a.i32(s.framebuffer_width), a.i32(s.framebuffer_height), a.i32(s.density_width), a.i32(s.density_height), a.f32(s.gamma), a.f32(s.point_size), a.f32(s.point_alpha), a.f32(s.points_alpha), a.f32(s.density_scaler), a.f32(s.quantization_step), a.f32(s.density_alpha), a.f32(s.contours_alpha), a.mat3x3f(s.matrix), a.vec2f(...s.view_xy_scaler), a.vec4f(...s.kde_causal), a.vec4f(...s.kde_anticausal), a.vec4f(...s.kde_a), a.vec4f(...s.background_color);
      let l = s.gamma;
      for (let u = 0; u < Math.min(s.category_colors.length, 256); u++) {
        let { r: c, g: h, b: d, a: p } = s.category_colors[u];
        c = Math.pow(c, l), h = Math.pow(h, l), d = Math.pow(d, l), a.vec4f(c, h, d, p);
      }
      i.queue.writeBuffer(o, 0, r, 0, a.byteOffset());
    })
  };
}
const Pk = 64, Rk = 64;
function bL(t, e, r, n, i, o) {
  let s = t.derive(
    [e, r, n.layouts],
    (a, l, u) => a.createComputePipeline({
      layout: a.createPipelineLayout({ bindGroupLayouts: [u.group0, u.group1, u.group2A] }),
      compute: { module: l, entryPoint: "accumulate" }
    })
  );
  return t.derive(
    [
      s,
      n.group0,
      n.group1,
      n.group2A,
      o.countBuffer,
      i.count
    ],
    (a, l, u, c, h, d) => (p) => {
      if (p.clearBuffer(h), d == 0)
        return;
      let g = p.beginComputePass();
      g.setPipeline(a), g.setBindGroup(0, l), g.setBindGroup(1, u), g.setBindGroup(2, c), d <= Pk * Rk ? g.dispatchWorkgroups(Math.ceil(d / Pk)) : g.dispatchWorkgroups(Rk, Math.ceil(d / (Pk * Rk))), g.end();
    }
  );
}
function kye(t) {
  const { COMPUTE: e, VERTEX: r, FRAGMENT: n } = GPUShaderStage;
  return {
    // Group 0
    group0: t.createBindGroupLayout({
      entries: [{ binding: 0, visibility: e | r | n, buffer: { type: "uniform" } }]
    }),
    // Group 1
    group1: t.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: e | r, buffer: { type: "read-only-storage" } },
        { binding: 1, visibility: e | r, buffer: { type: "read-only-storage" } },
        { binding: 2, visibility: e | r, buffer: { type: "read-only-storage" } }
      ]
    }),
    // Group 2
    group2A: t.createBindGroupLayout({
      entries: [{ binding: 0, visibility: e | n, buffer: { type: "storage" } }]
    }),
    group2B: t.createBindGroupLayout({
      entries: [
        { binding: 1, visibility: e | n, buffer: { type: "storage" } },
        { binding: 2, visibility: e | n, buffer: { type: "storage" } }
      ]
    }),
    // Group 3
    group3: t.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    })
  };
}
function xL(t, e, r, n, i) {
  let o = t.derive([e], (h) => kye(h)), s = t.derive(
    [e, o, r],
    (h, d, p) => h.createBindGroup({
      layout: d.group0,
      entries: [{ binding: 0, resource: { buffer: p } }]
    })
  ), a = t.derive(
    [e, o, n.x, n.y, n.category],
    (h, d, p, g, v) => h.createBindGroup({
      layout: d.group1,
      entries: [
        { binding: 0, resource: { buffer: p } },
        { binding: 1, resource: { buffer: g } },
        { binding: 2, resource: { buffer: v ?? p } }
      ]
    })
  ), l = t.derive(
    [e, o, i.countBuffer, i.blurBuffer],
    (h, d, p, g) => h.createBindGroup({
      layout: d.group2A,
      entries: [{ binding: 0, resource: { buffer: p } }]
    })
  ), u = t.derive(
    [e, o, i.countBuffer, i.blurBuffer],
    (h, d, p, g) => h.createBindGroup({
      layout: d.group2B,
      entries: [
        { binding: 1, resource: { buffer: p } },
        { binding: 2, resource: { buffer: g } }
      ]
    })
  ), c = t.derive(
    [e, o, i.colorTexture, i.alphaTexture],
    (h, d, p, g) => h.createBindGroup({
      layout: d.group3,
      entries: [
        { binding: 0, resource: h.createSampler({}) },
        { binding: 1, resource: p.createView() },
        { binding: 2, resource: g.createView() }
      ]
    })
  );
  return {
    layouts: o,
    group0: s,
    group1: a,
    group2A: l,
    group2B: u,
    group3: c
  };
}
function Cye(t, e, r, n, i) {
  const o = t.derive(
    [e, r, n.layouts],
    (s, a, l) => s.createRenderPipeline({
      layout: s.createPipelineLayout({
        bindGroupLayouts: [l.group0, l.group1, l.group2B]
      }),
      vertex: { entryPoint: "draw_density_map_vs", module: a },
      fragment: {
        entryPoint: "draw_density_map_fs",
        module: a,
        targets: [
          {
            format: i.colorTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          },
          {
            format: i.alphaTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [
      o,
      n.group0,
      n.group1,
      n.group2B,
      i.colorTexture,
      i.alphaTexture
    ],
    (s, a, l, u, c, h) => (d) => {
      let p = d.beginRenderPass({
        colorAttachments: [
          { loadOp: "load", storeOp: "store", view: c.createView() },
          { loadOp: "load", storeOp: "store", view: h.createView() }
        ]
      });
      p.setPipeline(s), p.setBindGroup(0, a), p.setBindGroup(1, l), p.setBindGroup(2, u), p.draw(4), p.end();
    }
  );
}
function _ye(t, e, r, n, i, o) {
  const s = t.derive(
    [e, r, n.layouts],
    (a, l, u) => a.createRenderPipeline({
      layout: a.createPipelineLayout({ bindGroupLayouts: [u.group0, u.group1] }),
      vertex: { entryPoint: "points_vs", module: l },
      fragment: {
        entryPoint: "points_fs",
        module: l,
        targets: [
          {
            format: o.colorTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          },
          {
            format: o.alphaTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [
      s,
      n.group0,
      n.group1,
      i.count,
      o.colorTexture,
      o.alphaTexture
    ],
    (a, l, u, c, h, d) => (p) => {
      let g = p.beginRenderPass({
        colorAttachments: [
          { clearValue: [0, 0, 0, 0], loadOp: "clear", storeOp: "store", view: h.createView() },
          { clearValue: [0, 0, 0, 0], loadOp: "clear", storeOp: "store", view: d.createView() }
        ]
      });
      g.setPipeline(a), g.setBindGroup(0, l), g.setBindGroup(1, u), c > 0 && g.draw(4, c), g.end();
    }
  );
}
function Sye(t, e, r, n, i) {
  const o = t.derive(
    [e, r, i.layouts],
    (s, a, l) => s.createRenderPipeline({
      layout: s.createPipelineLayout({
        bindGroupLayouts: [l.group0, l.group1, l.group2B, l.group3]
      }),
      vertex: { entryPoint: "gamma_correction_vs", module: a },
      fragment: { entryPoint: "gamma_correction_fs", module: a, targets: [{ format: n }] },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [o, i.group0, i.group1, i.group2B, i.group3],
    (s, a, l, u, c) => (h, d) => {
      let p = h.beginRenderPass({
        colorAttachments: [{ clearValue: [1, 1, 1, 1], loadOp: "clear", storeOp: "store", view: d }]
      });
      p.setPipeline(s), p.setBindGroup(0, a), p.setBindGroup(1, l), p.setBindGroup(2, u), p.setBindGroup(3, c), p.draw(4), p.end();
    }
  );
}
const lO = 64;
function wL(t, e, r, n, i, o, s) {
  let a = t.derive(
    [e, r, n.layouts],
    (u, c, h) => u.createComputePipeline({
      layout: u.createPipelineLayout({
        bindGroupLayouts: [h.group0, h.group1, h.group2B, h.group3]
      }),
      compute: { module: c, entryPoint: "gaussian_blur_stage_1" }
    })
  ), l = t.derive(
    [e, r, n.layouts],
    (u, c, h) => u.createComputePipeline({
      layout: u.createPipelineLayout({
        bindGroupLayouts: [h.group0, h.group1, h.group2B, h.group3]
      }),
      compute: { module: c, entryPoint: "gaussian_blur_stage_2" }
    })
  );
  return t.derive(
    [
      a,
      l,
      n.group0,
      n.group1,
      n.group2B,
      n.group3,
      i,
      o,
      s
    ],
    (u, c, h, d, p, g, v, y, b) => (k) => {
      let C = k.beginComputePass();
      C.setBindGroup(0, h), C.setBindGroup(1, d), C.setBindGroup(2, p), C.setBindGroup(3, g), C.setPipeline(u), C.dispatchWorkgroups(Math.ceil(v / lO), b), C.setPipeline(c), C.dispatchWorkgroups(Math.ceil(y / lO), b), C.end();
    }
  );
}
function Aye(t, e = !1) {
  const r = new Float64Array(5), n = new Float64Array(4);
  Eye(r, n, t);
  const i = Float64Array.of(
    0,
    n[1] - r[1] * n[0],
    n[2] - r[2] * n[0],
    n[3] - r[3] * n[0],
    -r[4] * n[0]
  ), o = 1 + r[1] + r[2] + r[3] + r[4], s = (n[0] + n[1] + n[2] + n[3]) / o, a = (i[1] + i[2] + i[3] + i[4]) / o;
  return {
    sigma: t,
    negative: e,
    a: r,
    b_causal: n,
    b_anticausal: i,
    sum_causal: s,
    sum_anticausal: a
  };
}
function Eye(t, e, r) {
  const n = Float64Array.of(
    0.84,
    1.8675,
    0.84,
    -1.8675,
    -0.34015,
    -0.1299,
    -0.34015,
    0.1299
  ), i = Math.exp(-1.783 / r), o = Math.exp(-1.723 / r), s = 0.6318 / r, a = 1.997 / r, l = Float64Array.of(
    -i * Math.cos(s),
    i * Math.sin(s),
    -i * Math.cos(-s),
    i * Math.sin(-s),
    -o * Math.cos(a),
    o * Math.sin(a),
    -o * Math.cos(-a),
    o * Math.sin(-a)
  ), u = r * 2.5066282746310007, c = Float64Array.of(n[0], n[1], 0, 0, 0, 0, 0, 0), h = Float64Array.of(1, 0, l[0], l[1], 0, 0, 0, 0, 0, 0);
  let d, p;
  for (p = 2; p < 8; p += 2) {
    for (c[p] = l[p] * c[p - 2] - l[p + 1] * c[p - 1], c[p + 1] = l[p] * c[p - 1] + l[p + 1] * c[p - 2], d = p - 2; d > 0; d -= 2)
      c[d] += l[p] * c[d - 2] - l[p + 1] * c[d - 1], c[d + 1] += l[p] * c[d - 1] + l[p + 1] * c[d - 2];
    for (d = 0; d <= p; d += 2)
      c[d] += n[p] * h[d] - n[p + 1] * h[d + 1], c[d + 1] += n[p] * h[d + 1] + n[p + 1] * h[d];
    for (h[p + 2] = l[p] * h[p] - l[p + 1] * h[p + 1], h[p + 3] = l[p] * h[p + 1] + l[p + 1] * h[p], d = p; d > 0; d -= 2)
      h[d] += l[p] * h[d - 2] - l[p + 1] * h[d - 1], h[d + 1] += l[p] * h[d - 1] + l[p + 1] * h[d - 2];
  }
  for (p = 0; p < 4; ++p)
    d = p << 1, e[p] = c[d] / u, t[p + 1] = h[d + 2];
}
function kL(t) {
  let e = Aye(t);
  return {
    kde_causal: [e.b_causal[0], e.b_causal[1], e.b_causal[2], e.b_causal[3]],
    kde_anticausal: [e.b_anticausal[1], e.b_anticausal[2], e.b_anticausal[3], e.b_anticausal[4]],
    kde_a: [e.a[1], e.a[2], e.a[3], e.a[4]]
  };
}
const Dye = `// Copyright (c) 2025 Apple Inc. Licensed under MIT License.

enable f16;

struct Uniforms {
  count: u32,
  category_count: u32,
  framebuffer_width: i32,
  framebuffer_height: i32,
  density_width: i32,
  density_height: i32,
  gamma: f32,
  point_size: f32,
  point_alpha: f32,
  points_alpha: f32,
  density_scaler: f32,
  quantization_step: f32,
  density_alpha: f32,
  contours_alpha: f32,
  matrix: mat3x3<f32>,
  view_xy_scaler: vec2<f32>,
  kde_causal: vec4<f32>,
  kde_anticausal: vec4<f32>,
  kde_a: vec4<f32>,
  background_color: vec4<f32>,
  category_colors: array<vec4<f32>, 256>,
}

struct PointData {
  position: vec3<f32>,
  category: u32,
}

struct FragmentOutput {
  @location(0) color: vec4<f32>,
  @location(1) log1malpha: f32, // log(1 - alpha)
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@group(1) @binding(0) var<storage, read> x_buffer: array<f32>;
@group(1) @binding(1) var<storage, read> y_buffer: array<f32>;
@group(1) @binding(2) var<storage, read> category_buffer: array<u32>;

@group(2) @binding(0) var<storage, read_write> count_buffer: array<atomic<u32>>;
@group(2) @binding(1) var<storage, read_write> blur_buffer: array<f16>;
@group(2) @binding(2) var<storage, read_write> blur_swap_buffer: array<f16>;

@group(3) @binding(0) var framebuffer_sampler: sampler;
@group(3) @binding(1) var color_texture: texture_2d<f32>;
@group(3) @binding(2) var log1malpha_texture: texture_2d<f32>;

fn get_point(index: u32) -> PointData {
  var result: PointData;
  result.position = vec3(x_buffer[index], y_buffer[index], 1.0);
  if (uniforms.category_count > 1) {
    result.category = (category_buffer[index >> 2] >> ((index & 3) << 3)) & 0xff;
  } else {
    result.category = 0;
  }
  return result;
}

const ACCUMULATE_UNIT: u32 = 4096;

fn increment_count(x: i32, y: i32, category: u32, value: u32) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  if (x < 0 || x >= width || y < 0 || y >= height || category >= uniforms.category_count || value == 0) {
    return;
  }
  let offset = (y * width + x) + i32(category) * (width * height);
  atomicAdd(&count_buffer[offset], value);
}

@compute @workgroup_size(64, 1)
fn accumulate(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let index = id.y * 4096 + id.x; // 4096 = 64 * 64
  if (index >= uniforms.count) { return; }
  let point = get_point(index);
  let pos = uniforms.matrix * point.position;
  let x = (pos.x + 1.0) / 2.0 * f32(width) - 0.5;
  let y = (pos.y + 1.0) / 2.0 * f32(height) - 0.5;
  let ix = i32(x);
  let iy = i32(y);
  let tx = x - f32(ix);
  let ty = y - f32(iy);
  let w1: u32 = u32((1 - tx) * (1 - ty) * f32(ACCUMULATE_UNIT));
  let w2: u32 = u32(tx * (1 - ty) * f32(ACCUMULATE_UNIT));
  let w3: u32 = u32((1 - tx) * ty * f32(ACCUMULATE_UNIT));
  let w123 = w1 + w2 + w3;
  var w4: u32 = select(0, ACCUMULATE_UNIT - w123, w123 < ACCUMULATE_UNIT);
  increment_count(ix, iy, point.category, w1);
  increment_count(ix + 1, iy, point.category, w2);
  increment_count(ix, iy + 1, point.category, w3);
  increment_count(ix + 1, iy + 1, point.category, w4);
}

// Draw Discrete Points

struct PointsVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) dp: vec3<f32>,
  @location(1) color: vec4<f32>,
}

@vertex
fn points_vs(
  @builtin(instance_index) index: u32,
  @builtin(vertex_index) part: u32,
) -> PointsVertexOutput {
  let framebuffer_size = vec2(f32(uniforms.framebuffer_width), f32(uniforms.framebuffer_height));
  let alpha = uniforms.point_alpha * uniforms.points_alpha;
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  let point = get_point(index);
  let pos = uniforms.matrix * point.position;

  var out: PointsVertexOutput;
  out.position = vec4<f32>(pos.xy + dp * uniforms.point_size / framebuffer_size * 2.0, 0.0, 1.0);
  out.dp = vec3(dp, uniforms.point_size);
  out.color = uniforms.category_colors[point.category] * alpha;
  return out;
}

@fragment
fn points_fs(in: PointsVertexOutput) -> FragmentOutput {
  let r = length(in.dp.xy) * in.dp.z;
  let a = max(0.0, min(1.0, in.dp.z - r));
  var out: FragmentOutput;
  out.color = in.color * a;
  out.log1malpha = log(1 - out.color.a);
  return out;
}

// Draw Density Map

struct DrawDensityMapVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) texture_coord: vec2<f32>,
}

@vertex
fn draw_density_map_vs(
  @builtin(vertex_index) part: u32,
) -> DrawDensityMapVertexOutput {
  let framebuffer_size = vec2(f32(uniforms.framebuffer_width), f32(uniforms.framebuffer_height));
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  var out: DrawDensityMapVertexOutput;
  out.position = vec4(dp, 0.0, 1.0);
  out.texture_coord = (vec2(dp.x, dp.y) + 1.0) / 2.0 * framebuffer_size;
  return out;
}

fn get_density_raw(x: i32, y: i32, category: u32) -> f32 {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let density_scaler = uniforms.density_scaler;
  if (x < 0 || x >= width || y < 0 || y >= height) {
    return 0.0;
  }
  let offset = (y * width + x) + i32(category) * (width * height);
  return max(0.0, f32(blur_buffer[offset]) * density_scaler);
}

fn get_density(x: f32, y: f32, category: u32) -> f32 {
  let px = x / f32(uniforms.framebuffer_width) * f32(uniforms.density_width) - 0.5;
  let py = y / f32(uniforms.framebuffer_height) * f32(uniforms.density_height) - 0.5;
  let ix = i32(px);
  let iy = i32(py);
  let tx = px - f32(ix);
  let ty = py - f32(iy);
  let v00 = get_density_raw(ix, iy, category);
  let v10 = get_density_raw(ix + 1, iy, category);
  let v01 = get_density_raw(ix, iy + 1, category);
  let v11 = get_density_raw(ix + 1, iy + 1, category);
  return mix(mix(v00, v10, tx), mix(v01, v11, tx), ty);
}

fn get_density_quantized(x: f32, y: f32, category: u32) -> f32 {
  let v = get_density(x, y, category);
  return floor(clamp(v, 0, 1) / uniforms.quantization_step);
}

fn get_density_quantized_sobel(x: f32, y: f32, category: u32) -> vec2<f32> {
  let v11 = get_density_quantized(x - 1, y - 1, category);
  let v21 = get_density_quantized(x, y - 1, category);
  let v31 = get_density_quantized(x + 1, y - 1, category);
  let v12 = get_density_quantized(x - 1, y, category);
  let v22 = get_density_quantized(x, y, category);
  let v32 = get_density_quantized(x + 1, y, category);
  let v13 = get_density_quantized(x - 1, y + 1, category);
  let v23 = get_density_quantized(x, y + 1, category);
  let v33 = get_density_quantized(x + 1, y + 1, category);
  let gx = v11 + v12 * 2.0 + v13 - v31 - v32 * 2.0 - v33;
  let gy = v11 + v21 * 2.0 + v31 - v13 - v23 * 2.0 - v33;
  return vec2(gx, gy);
}

@fragment
fn draw_density_map_fs(in: DrawDensityMapVertexOutput) -> FragmentOutput {
  let px = in.texture_coord.x;
  let py = in.texture_coord.y;
  let quantization_step: f32 = uniforms.quantization_step;

  var sum_color: vec4<f32> = vec4(0);
  var sum_log1malpha: f32 = 0.0;

  for (var i: u32 = 0; i < uniforms.category_count; i++) {
    let density = get_density(px, py, i);
    var alpha = min(1.0, floor(density / quantization_step) * quantization_step);
    alpha *= uniforms.density_alpha;
    let color = uniforms.category_colors[i] * alpha;
    sum_color += color;
    sum_log1malpha += log(1 - color.a);
  }

  if (uniforms.contours_alpha > 0.0) {
    for (var i: u32 = 0; i < uniforms.category_count; i++) {
      let sobel = get_density_quantized_sobel(px, py, i);
      let alpha = clamp(length(sobel) * 0.2, 0.0, 1.0) * uniforms.contours_alpha;
      let color = uniforms.category_colors[i] * alpha;
      sum_color += color;
      sum_log1malpha += log(1 - color.a);
    }
  }

  var out: FragmentOutput;
  out.color = sum_color;
  out.log1malpha = sum_log1malpha;
  return out;
}

// Gamma Correction

struct GammaCorrectionVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) texture_coord: vec2<f32>,
}

@vertex
fn gamma_correction_vs(
  @builtin(vertex_index) part: u32,
) -> GammaCorrectionVertexOutput {
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  var out: GammaCorrectionVertexOutput;
  out.position = vec4(dp * uniforms.view_xy_scaler, 0.0, 1.0);
  out.texture_coord = (vec2(dp.x, -dp.y) + 1.0) / 2.0;
  return out;
}

@fragment
fn gamma_correction_fs(in: GammaCorrectionVertexOutput) -> @location(0) vec4<f32> {
  let sum_color = textureSample(color_texture, framebuffer_sampler, in.texture_coord);
  let sum_log_one_minus_alpha = textureSample(log1malpha_texture, framebuffer_sampler, in.texture_coord).r;
  var color: vec4<f32>;
  if (sum_color.a > 0.0) {
    color = sum_color / sum_color.a * (1.0 - exp(sum_log_one_minus_alpha));
    color = color + uniforms.background_color * (1 - color.a);
  } else {
    color = uniforms.background_color;
  }
  let rgb = pow(color.rgb, vec3(1.0 / uniforms.gamma));
  return vec4(rgb, 1.0);
}

// Gaussian Blur

@compute @workgroup_size(64, 1)
fn gaussian_blur_stage_1(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let x = id.x;
  if (x >= u32(width)) { return; }
  let start = x + id.y * u32(width * height);
  let count = u32(height);
  let stride = u32(width);

  deriche_conv_1d(
    &blur_buffer, &blur_swap_buffer, start, stride, count,
    uniforms.kde_causal, uniforms.kde_anticausal, uniforms.kde_a,
    true
  );
}

@compute @workgroup_size(64, 1)
fn gaussian_blur_stage_2(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let y = id.x;
  if (y >= u32(height)) { return; }
  let start = y * u32(width) + id.y * u32(width * height);
  let count = u32(width);
  let stride = u32(1);

  deriche_conv_1d(
    &blur_swap_buffer, &blur_buffer, start, stride, count,
    uniforms.kde_causal, uniforms.kde_anticausal, uniforms.kde_a,
    false
  );
}

fn deriche_conv_1d(
    src: ptr<storage, array<f16>, read_write>,
    dst: ptr<storage, array<f16>, read_write>,
    start: u32, stride: u32, count: u32,
    kde_causal: vec4<f32>, kde_anticausal: vec4<f32>, kde_a: vec4<f32>,
    src_is_u32: bool
) {
  var s: vec4<f32> = vec4(0.0);
  var y0: f32 = 0.0;
  var y1234: vec4<f32> = vec4(0.0);

  var first_nonzero: u32 = count;
  var last_nonzero: u32 = 0;

  for (var i: u32 = 0; i < count; i++) {
    let offset = start + i * stride;
    var input: f32;
    if (src_is_u32) {
      input = f32(bitcast<u32>(vec2((*src)[offset * 2], (*src)[offset * 2 + 1]))) / f32(ACCUMULATE_UNIT);
    } else {
      input = f32((*src)[offset]);
    }
    if (input != 0.0) {
      first_nonzero = min(i, first_nonzero);
      last_nonzero = max(i, last_nonzero);
    }
    s = vec4(input, s.xyz);
    y1234 = vec4(y0, y1234.xyz);
    y0 = dot(kde_causal, s) - dot(kde_a, y1234);
    (*dst)[offset] = f16(y0);
  }

  if (first_nonzero > last_nonzero) {
    return;
  }

  s = vec4(0.0);
  y0 = 0.0;
  y1234 = vec4(0.0);

  for (var i: u32 = count - 1 - last_nonzero; i < count; i++) {
    let p = count - 1 - i;
    let offset = start + p * stride;
    var input: f32 = 0.0;
    if (p >= first_nonzero) {
      if (src_is_u32) {
        input = f32(bitcast<u32>(vec2((*src)[offset * 2], (*src)[offset * 2 + 1]))) / f32(ACCUMULATE_UNIT);
      } else {
        input = f32((*src)[offset]);
      }
    }
    y1234 = vec4(y0, y1234.xyz);
    y0 = dot(kde_anticausal, s) - dot(kde_a, y1234);
    s = vec4(input, s.xyz);
    if (y0 != 0.0) {
      (*dst)[offset] = f16(f32((*dst)[offset]) + y0);
    }
  }
}
`;
class Oye {
  props;
  viewport;
  df;
  device;
  module;
  uniforms;
  context;
  renderInputs;
  dataBuffers;
  renderer;
  constructor(e, r, n, i, o) {
    this.context = e, this.props = {
      mode: "points",
      colorScheme: "light",
      x: new Float32Array(),
      y: new Float32Array(),
      category: null,
      categoryCount: 1,
      categoryColors: null,
      viewportX: 0,
      viewportY: 0,
      viewportScale: 1,
      pointSize: 1,
      pointAlpha: 1,
      pointsAlpha: 1,
      densityScaler: 1,
      densityBandwidth: 1,
      densityQuantizationStep: 0.1,
      contoursAlpha: 1,
      densityAlpha: 1,
      gamma: 2.2,
      width: i,
      height: o
    }, this.viewport = new Dx({ x: 0, y: 0, scale: 1 }, i, o), this.df = new Qh();
    let s = this.df;
    this.renderInputs = {
      mode: s.value(this.props.mode),
      colorScheme: s.value(this.props.colorScheme),
      xData: s.value(this.props.x),
      yData: s.value(this.props.y),
      categoryData: s.value(this.props.category),
      categoryCount: s.value(this.props.categoryCount),
      categoryColors: s.value(this.props.categoryColors),
      matrix: s.value(dL()),
      width: s.value(i),
      height: s.value(o),
      pointSize: s.value(this.props.pointSize),
      densityBandwidth: s.value(this.props.densityBandwidth)
    }, this.device = s.value(r), this.dataBuffers = Fye(s, this.device, this.renderInputs), this.module = s.derive([this.device], (a) => a.createShaderModule({ code: Dye })), this.uniforms = wye(s, this.device), this.renderer = Tye(
      s,
      this.device,
      this.module,
      this.uniforms,
      n,
      this.renderInputs,
      this.dataBuffers
    );
  }
  setProps(e) {
    let r = !1, n;
    for (n in e)
      e[n] !== this.props[n] && (this.props[n] = e[n], r = !0);
    return this.viewport.update(
      { x: this.props.viewportX, y: this.props.viewportY, scale: this.props.viewportScale },
      this.props.width,
      this.props.height
    ), this.renderInputs.mode.value = this.props.mode, this.renderInputs.colorScheme.value = this.props.colorScheme, this.renderInputs.xData.value = this.props.x, this.renderInputs.yData.value = this.props.y, this.renderInputs.categoryData.value = this.props.category, this.renderInputs.categoryColors.value = this.props.categoryColors, this.props.category != null ? this.renderInputs.categoryCount.value = this.props.categoryCount : this.renderInputs.categoryCount.value = 1, this.renderInputs.matrix.value = this.viewport.matrix(), this.renderInputs.width.value = this.props.width, this.renderInputs.height.value = this.props.height, this.renderInputs.pointSize.value = this.props.pointSize, this.renderInputs.densityBandwidth.value = this.props.densityBandwidth, r;
  }
  render() {
    this.renderer.value(this.props, this.context.getCurrentTexture().createView());
  }
  destroy() {
    this.df.destroy();
  }
  async densityMap(e, r, n, i) {
    let o = this.df.subgraph(), { x: s, y: a, scale: l } = i, u = [l, 0, 0, 0, l, 0, -s * l, -a * l, 1], c = mL(u), h = await Mye(
      o,
      this.device,
      this.module,
      this.uniforms,
      o.value(e),
      o.value(r),
      o.value(n),
      o.value(u),
      this.dataBuffers
    ).value();
    return o.destroy(), {
      data: h,
      width: e,
      height: r,
      coordinateAtPixel: (d, p) => {
        let g = d / e * 2 - 1, v = p / r * 2 - 1, y = pL([g, v, 1], c);
        return { x: y[0], y: y[1] };
      }
    };
  }
}
function Fye(t, e, r) {
  let n = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
  const i = t.derive([r.xData], (c) => c.length), o = t.derive([i], (c) => c * 4), s = i, a = t.statefulDerive(
    [e, t.statefulDerive([e, o, n], od), r.xData],
    Ak
  ), l = t.statefulDerive(
    [e, t.statefulDerive([e, o, n], od), r.yData],
    Ak
  ), u = t.statefulDerive(
    [e, t.statefulDerive([e, s, n], od), r.categoryData],
    Ak
  );
  return { x: a, y: l, category: u, count: i };
}
function CL(t, e, r, n, i, o, s) {
  let a = "rgba16float", l = "r16float", u = GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, c = t.statefulDerive(
    [e, r, n, a, u],
    I9
  ), h = t.statefulDerive(
    [e, r, n, l, u],
    I9
  ), d = t.derive(
    [i, o, s],
    (y, b, k) => y * b * k * 4
    // w * h * categoryCount * sizeof(uint32)
  ), p = t.derive(
    [i, o, s],
    (y, b, k) => y * b * k * 2
    // w * h * categoryCount * sizeof(f16)
  ), g = t.statefulDerive(
    [e, d, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC],
    od
  ), v = t.statefulDerive([e, p, GPUBufferUsage.STORAGE], od);
  return {
    colorTexture: c,
    alphaTexture: h,
    colorTextureFormat: a,
    alphaTextureFormat: l,
    countBuffer: g,
    blurBuffer: v
  };
}
function Tye(t, e, r, n, i, o, s) {
  let a = t.derive([o.densityBandwidth], (_) => Math.ceil(_ * 3) + 1), l = t.derive([o.width, a], (_, D) => _ + D * 2), u = t.derive([o.height, a], (_, D) => _ + D * 2), c = t.derive([l], (_) => Math.ceil(_ / 4)), h = t.derive([u], (_) => Math.ceil(_ / 4)), d = CL(
    t,
    e,
    l,
    u,
    c,
    h,
    o.categoryCount
  ), p = xL(t, e, n.buffer, s, d), g = bL(t, e, r, p, s, d), v = _ye(t, e, r, p, s, d), y = Cye(t, e, r, p, d), b = Sye(t, e, r, i, p), k = wL(t, e, r, p, l, u, o.categoryCount), C = t.derive(
    [o.densityBandwidth, l, c],
    (_, D, A) => kL(_ / D * A)
  ), S = t.derive(
    [o.categoryColors, o.categoryCount],
    (_, D) => (_ == null && (_ = mp(D)), _.map((A) => GS(A)))
  );
  return t.derive(
    [
      e,
      l,
      u,
      c,
      h,
      n.update,
      s.count,
      o.matrix,
      S,
      v,
      b,
      g,
      k,
      y,
      C
    ],
    (_, D, A, O, M, z, R, N, I, B, $, q, U, H, G) => (re, ie) => {
      let se = re.colorScheme == "light" ? [1, 1, 1, 1] : [0, 0, 0, 1], ne = re.width / D, ce = re.height / A, Ce = KS([ne, 0, 0, 0, ce, 0, 0, 0, 1], N);
      z({
        count: R,
        category_count: re.categoryCount,
        framebuffer_width: D,
        framebuffer_height: A,
        density_width: O,
        density_height: M,
        gamma: re.gamma,
        point_size: Math.max(re.mode == "points" ? 3 : 1, re.pointSize),
        point_alpha: re.pointAlpha,
        points_alpha: re.pointsAlpha,
        density_scaler: re.densityScaler / 16,
        quantization_step: re.densityQuantizationStep,
        density_alpha: re.densityAlpha,
        contours_alpha: re.contoursAlpha,
        matrix: Ce,
        view_xy_scaler: [1 / ne, 1 / ce],
        kde_causal: G.kde_causal,
        kde_anticausal: G.kde_anticausal,
        kde_a: G.kde_a,
        background_color: se,
        category_colors: I
      });
      let Pe = _.createCommandEncoder();
      B(Pe), re.mode == "density" && (re.densityAlpha > 0 || re.contoursAlpha > 0) && (q(Pe), U(Pe), H(Pe)), $(Pe, ie), _.queue.submit([Pe.finish()]);
    }
  );
}
function Mye(t, e, r, n, i, o, s, a, l) {
  let u = CL(t, e, i, o, i, o, t.value(1)), c = xL(t, e, n.buffer, l, u), h = bL(t, e, r, c, l, u), d = wL(t, e, r, c, i, o, t.value(1));
  return t.derive(
    [
      e,
      i,
      o,
      l.count,
      n.update,
      s,
      a,
      h,
      d,
      u.countBuffer
    ],
    (p, g, v, y, b, k, C, S, _, D) => () => {
      let A = p.createCommandEncoder(), O = kL(k);
      b({
        count: y,
        category_count: 1,
        framebuffer_width: g,
        framebuffer_height: v,
        density_width: g,
        density_height: v,
        gamma: 1,
        point_size: 0,
        point_alpha: 0,
        points_alpha: 0,
        density_scaler: 0,
        quantization_step: 0,
        density_alpha: 0,
        contours_alpha: 0,
        matrix: C,
        view_xy_scaler: [1, 1],
        kde_causal: O.kde_causal,
        kde_anticausal: O.kde_anticausal,
        kde_a: O.kde_a,
        background_color: [0, 0, 0, 0],
        category_colors: []
      }), S(A), _(A);
      let M = p.createBuffer({
        size: g * v * 2,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      return A.copyBufferToBuffer(D, 0, M, 0, g * v * 2), p.queue.submit([A.finish()]), M.mapAsync(GPUMapMode.READ, 0, g * v * 2).then(() => Pye(M.getMappedRange()));
    }
  );
}
function Pye(t) {
  let e = new Uint16Array(t), r = new Uint32Array(e.length);
  for (let n = 0; n < e.length; n++) {
    let i = e[n] & 32767, o = e[n] & 32768, s = e[n] & 31744;
    i <<= 13, o <<= 16, i += 939524096, i = s == 0 ? 0 : i, i |= o, r[n] = i;
  }
  return new Float32Array(r.buffer);
}
let nm;
function Rye() {
  return nm == null && (nm = document.createElement("canvas"), nm.width = 1, nm.height = 1), nm.getContext("2d");
}
function Nye(t) {
  let e = Rye();
  e.font = `${t.fontSize ?? 10}px ${t.fontFamily ?? "system-ui"}`;
  let r = t.text.split(`
`).map((i) => e.measureText(i).width), n = (t.fontSize ?? 10) * (t.lineSpacing ?? 1) * r.length;
  return {
    width: r.reduce((i, o) => Math.max(i, o)),
    height: n
  };
}
let Nk = null, u_ = /* @__PURE__ */ new Map();
function $ye() {
  return Nk == null && (Nk = new Promise((t, e) => {
    let r = new Worker(new URL("./clustering.worker.js", import.meta.url), { type: "module" });
    r.onmessage = (n) => {
      if (n.data.ready) {
        t(r);
        return;
      }
      if (n.data.id != null) {
        let i = u_.get(n.data.id);
        i != null && (u_.delete(n.data.id), i(n.data));
      }
    };
  })), Nk;
}
function vp(t, e, r = []) {
  return new Promise((n, i) => {
    $ye().then((o) => {
      let s = (/* @__PURE__ */ new Date()).getTime().toString() + "-" + Math.random().toString();
      u_.set(s, (a) => {
        n(a.payload);
      }), o.postMessage({ id: s, name: t, payload: e }, r);
    });
  });
}
let Iye = (t, e, r, n) => vp("findClusters", [t, e, r, n], [t.buffer]), Bye = (...t) => vp("dynamicLabelPlacement", t), Lye = (...t) => vp("textSummarizerCreate", t), zye = (...t) => vp("textSummarizerDestroy", t), jye = (...t) => vp("textSummarizerAdd", t), qye = (...t) => vp("textSummarizerSummarize", t);
async function uO(t, e, r, n, i) {
  let o = new Dx(r, t, e), s = n.reduce((g, v) => Math.min(g, v.level ?? 0), 0), a = n.reduce((g, v) => Math.max(g, v.level ?? 0), 0), l = r.scale, u = r.scale / 2, c = u * 4, h = l / c, d = n.map((g) => {
    let v = o.pixelLocation(g.x, g.y), y = g.level ?? 0, b = y == 0 ? 14 : 12, k = Nye({
      text: g.text,
      fontSize: b,
      fontFamily: i
    });
    return k.width += 4, k.height += 4, {
      text: g.text,
      fontSize: b,
      bounds: {
        xMin: v.x - k.width / 2,
        xMax: v.x + k.width / 2,
        yMin: v.y - k.height / 2,
        yMax: v.y + k.height / 2
      },
      locationAtZero: v,
      priority: g.priority,
      minScale: g.level == a ? null : h * Math.pow(2, -y) / 1.2,
      maxScale: g.level == s ? null : h * Math.pow(2, -y + 1),
      coordinate: { x: g.x, y: g.y },
      placement: null
    };
  }), p = await Bye(d, { globalMaxScale: l / u });
  for (let g = 0; g < p.length; g++) {
    let v = p[g];
    if (v != null) {
      let y = l / v.minScale, b = l / v.maxScale;
      d[g].placement = { minScale: b, maxScale: y };
    }
  }
  return d;
}
function Uye(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var cO = { exports: {} }, hO;
function Hye() {
  return hO || (hO = 1, (function(t) {
    (function() {
      function e(a, l) {
        var u = a.x - l.x, c = a.y - l.y;
        return u * u + c * c;
      }
      function r(a, l, u) {
        var c = l.x, h = l.y, d = u.x - c, p = u.y - h;
        if (d !== 0 || p !== 0) {
          var g = ((a.x - c) * d + (a.y - h) * p) / (d * d + p * p);
          g > 1 ? (c = u.x, h = u.y) : g > 0 && (c += d * g, h += p * g);
        }
        return d = a.x - c, p = a.y - h, d * d + p * p;
      }
      function n(a, l) {
        for (var u = a[0], c = [u], h, d = 1, p = a.length; d < p; d++)
          h = a[d], e(h, u) > l && (c.push(h), u = h);
        return u !== h && c.push(h), c;
      }
      function i(a, l, u, c, h) {
        for (var d = c, p, g = l + 1; g < u; g++) {
          var v = r(a[g], a[l], a[u]);
          v > d && (p = g, d = v);
        }
        d > c && (p - l > 1 && i(a, l, p, c, h), h.push(a[p]), u - p > 1 && i(a, p, u, c, h));
      }
      function o(a, l) {
        var u = a.length - 1, c = [a[0]];
        return i(a, 0, u, l, c), c.push(a[u]), c;
      }
      function s(a, l, u) {
        if (a.length <= 2) return a;
        var c = l !== void 0 ? l * l : 1;
        return a = u ? a : n(a, c), a = o(a, c), a;
      }
      t.exports = s, t.exports.default = s;
    })();
  })(cO)), cO.exports;
}
var Vye = Hye();
const fO = /* @__PURE__ */ Uye(Vye);
function Wye(t, e) {
  let r = t.slice();
  for (let n = 0; n < e; n++) {
    const i = [], o = r.length;
    for (let s = 0; s < o; s++) {
      const a = r[s], l = r[(s + 1) % o], u = {
        x: 0.75 * a.x + 0.25 * l.x,
        y: 0.75 * a.y + 0.25 * l.y
      }, c = {
        x: 0.25 * a.x + 0.75 * l.x,
        y: 0.25 * a.y + 0.75 * l.y
      };
      i.push(u, c);
    }
    r = i;
  }
  return r;
}
function Gye(t, e) {
  const r = Wye(t, 5), n = aL(r);
  let i = Math.max(n.xMax - n.xMin, n.yMax - n.yMin) / 100, o = fO(r, i), s = 0;
  for (; o.length > e && s < 20; )
    i *= 1.1, s += 1, o = fO(r, i);
  return o;
}
const dO = {
  light: {
    fontFamily: "system-ui,sans-serif",
    clusterLabelColor: "#000",
    clusterLabelOutlineColor: "rgba(255,255,255,0.8)",
    clusterLabelOpacity: 0.8,
    statusBar: !0,
    statusBarTextColor: "#525252",
    statusBarBackgroundColor: "rgba(255,255,255,0.9)",
    brandingLink: { text: "Embedding Atlas", href: "https://apple.github.io/embedding-atlas" }
  },
  dark: {
    fontFamily: "system-ui,sans-serif",
    clusterLabelColor: "#ccc",
    clusterLabelOutlineColor: "rgba(0,0,0,0.8)",
    clusterLabelOpacity: 0.8,
    statusBar: !0,
    statusBarTextColor: "#d9d9d9",
    statusBarBackgroundColor: "rgba(0,0,0,0.9)",
    brandingLink: { text: "Embedding Atlas", href: "https://apple.github.io/embedding-atlas" }
  }
};
function Kye(t, e) {
  return t == null ? dO[e] : { ...dO[e], ...t, ...t[e] != null ? t[e] : {} };
}
function Qye(t, e, r, n, i, o, s) {
  let a = Math.max(n, i) / o, l = t / (r * r) / (a * a), u = 1 / (l / (o * o)) * 0.2, c = Math.sqrt(t / e / (a * a)), h = Math.log(c), d = Math.log(r), p = (Math.min(Math.max((d - h) * 2, -1), 1) + 1) / 2, g;
  if (s != null)
    g = s * o;
  else {
    let b = 0.25 / Math.sqrt(l);
    g = Math.max(0.2, Math.min(5, b)) * o;
  }
  let v = 1 - p, y = 0.5 + p * 0.5;
  return {
    densityScaler: u,
    densityAlpha: v,
    contoursAlpha: v,
    pointSize: g,
    pointAlpha: 0.7,
    pointsAlpha: y,
    densityBandwidth: 20
  };
}
var Xye = /* @__PURE__ */ yc("<div></div>"), Jye = /* @__PURE__ */ uu("<circle></circle>"), Yye = /* @__PURE__ */ uu("<circle></circle>"), Zye = /* @__PURE__ */ uu('<text dominant-baseline="middle"> </text>'), e1e = /* @__PURE__ */ uu("<g></g>"), t1e = /* @__PURE__ */ uu("<g><!></g>"), r1e = /* @__PURE__ */ uu("<g></g>"), n1e = /* @__PURE__ */ yc('<div><canvas></canvas> <div><!></div> <svg role="none"><!><!><!><!></svg> <!> <!></div>');
function i1e(t, e) {
  Vh(e, !0);
  let r = tt(e, "data", 19, () => ({ x: new Float32Array(), y: new Float32Array(), category: null })), n = tt(e, "categoryCount", 3, 1), i = tt(e, "categoryColors", 3, null), o = tt(e, "width", 3, 800), s = tt(e, "height", 3, 800), a = tt(e, "pixelRatio", 3, 2), l = tt(e, "theme", 3, null), u = tt(e, "config", 3, null), c = tt(e, "totalCount", 3, null), h = tt(e, "maxDensity", 3, null), d = tt(e, "labels", 3, null), p = tt(e, "queryClusterLabels", 3, null), g = tt(e, "tooltip", 7, null), v = tt(e, "selection", 7, null), y = tt(e, "querySelection", 3, null), b = tt(e, "rangeSelection", 7, null), k = tt(e, "defaultViewportState", 3, null), C = tt(e, "viewportState", 7, null), S = tt(e, "customTooltip", 3, null), _ = tt(e, "customOverlay", 3, null), D = tt(e, "onViewportState", 3, null), A = tt(e, "onTooltip", 3, null), O = tt(e, "onSelection", 3, null), M = tt(e, "onRangeSelection", 3, null), z = tt(e, "cache", 3, null), R = /* @__PURE__ */ gt(() => u()?.colorScheme ?? "light"), N = /* @__PURE__ */ gt(() => Kye(l(), W(R))), I = /* @__PURE__ */ gt(() => i() ?? mp(n())), B = /* @__PURE__ */ gt(() => C() ?? k() ?? { x: 0, y: 0, scale: 1 }), $ = /* @__PURE__ */ gt(() => new Dx(W(B), o(), s())), q = /* @__PURE__ */ gt(() => W($).pixelLocationFunction()), U = /* @__PURE__ */ gt(() => W($).coordinateAtPixelFunction()), H = /* @__PURE__ */ Mr(!1);
  function G(xe, Te) {
    return xe.x == Te.x && xe.y == Te.y && xe.category == Te.category && xe.text == Te.text;
  }
  let re = /* @__PURE__ */ gt(() => v()?.length == 1 && g() != null && G(v()[0], g()));
  function ie(xe) {
    Iu(C(), xe) || (C(xe), D()?.(xe));
  }
  function se(xe) {
    Iu(g(), xe) || (g(xe), A()?.(xe));
  }
  function ne(xe) {
    Iu(v(), xe) || (v(xe), O()?.(xe));
  }
  function ce(xe) {
    Iu(b(), xe) || (b(xe), M()?.(xe));
  }
  let Ce = /* @__PURE__ */ Mr(Yc([])), Pe = /* @__PURE__ */ Mr(null), Me = /* @__PURE__ */ Mr("none"), _e = /* @__PURE__ */ gt(() => o() * a()), he = /* @__PURE__ */ gt(() => s() * a()), ke = /* @__PURE__ */ Mr(null), ve = /* @__PURE__ */ Mr(null), We = /* @__PURE__ */ Mr(null), Qe = /* @__PURE__ */ gt(() => u()?.minimumDensity ?? 1 / 16), ot = /* @__PURE__ */ gt(() => u()?.pointSize ?? null), Ye = /* @__PURE__ */ gt(() => u()?.mode ?? "points"), Ht = /* @__PURE__ */ gt(() => u()?.autoLabelEnabled), St = /* @__PURE__ */ gt(() => Qye(h() ?? (c() ?? r().x.length) / 4, W(Qe), W(B).scale, W(_e), W(he), a(), W(ot))), Gt = /* @__PURE__ */ gt(() => W(St).pointSize), $t = !0;
  Bm(() => {
    W(ve)?.setProps({
      mode: W(Ye),
      colorScheme: W(R),
      viewportX: W(B).x,
      viewportY: W(B).y,
      viewportScale: W(B).scale,
      width: W(_e),
      height: W(he),
      x: r().x,
      y: r().y,
      category: r().category,
      categoryCount: n(),
      categoryColors: W(I),
      ...W(St)
    }) && (It(), (W(Ht) !== !1 || d() != null) && $t && W(ve) != null && r().x != null && r().x.length > 0 && k() != null && ($t = !1, Br(k())));
  });
  function Ge() {
    Ze = null, !(!W(ke) || !W(ve)) && (W(ke).width = W(ve).props.width, W(ke).height = W(ve).props.height, W(ke).style.width = `${W(ve).props.width / a()}px`, W(ke).style.height = `${W(ve).props.height / a()}px`, W(ve).render());
  }
  let Ze = null;
  function It() {
    Ze == null && (Ze = requestAnimationFrame(Ge));
  }
  function rr(xe) {
    let Te;
    function je() {
      Te = xe.getContext("webgl2", { antialias: !1 }), Te.getExtension("EXT_color_buffer_float"), Te.getExtension("EXT_float_blend"), Te.getExtension("OES_texture_float_linear"), dt(ve, new pye(Te, W(_e), W(he)), !0);
    }
    je(), xe.addEventListener("webglcontextlost", () => {
      W(ve)?.destroy(), dt(ve, null), Te = null;
    }), xe.addEventListener("webglcontextrestored", () => {
      je();
    });
  }
  function Fe(xe) {
    async function Te() {
      let je = xe.getContext("webgpu");
      if (je == null) {
        console.error("Could not get WebGPU canvas context");
        return;
      }
      let Ke = await navigator.gpu.requestAdapter();
      if (!Ke) {
        console.error("Could not request WebGPU adapter");
        return;
      }
      let et = 512 * 1048576, ht = 512 * 1048576;
      et = Math.min(et, Ke.limits.maxBufferSize), ht = Math.min(ht, Ke.limits.maxStorageBufferBindingSize);
      let Vt = {
        requiredLimits: { maxBufferSize: et, maxStorageBufferBindingSize: ht },
        requiredFeatures: ["shader-f16"]
      }, gr = await Ke.requestDevice(Vt);
      gr.lost.then((ln) => {
        console.info(`WebGPU device was lost: ${ln.message}`), ln.reason != "destroyed" && (W(ve)?.destroy(), dt(ve, null), Te());
      });
      let Sr = navigator.gpu.getPreferredCanvasFormat();
      je.configure({ device: gr, format: Sr, alphaMode: "premultiplied" }), dt(ve, new Oye(je, gr, Sr, W(_e), W(he)), !0);
    }
    Te();
  }
  function $e(xe) {
    xe != null && C() == null && ie(xe);
  }
  Bm(() => $e(k())), HS(() => {
    W(ke) != null && (sB() ? Fe(W(ke)) : (rr(W(ke)), dt(We, "WebGPU is unavailable. If you are using Safari, please enable the WebGPU feature flag.")));
  }), J0e(() => {
    W(ve)?.destroy(), dt(ve, null);
  });
  function lt(xe) {
    let Te = W(ke)?.getBoundingClientRect() ?? { left: 0, top: 0 };
    return { x: xe.clientX - Te.left, y: xe.clientY - Te.top };
  }
  function kt(xe) {
    xe.preventDefault();
    let { x: Te, y: je } = lt(xe), Ke = Math.exp(-xe.deltaY / 200);
    pr(Ke, { x: Te, y: je });
  }
  function pr(xe, Te) {
    let { x: je, y: Ke, scale: et } = W(B);
    se(null);
    let ht = Math.min(100, Math.max(0.01, et * xe)), Vt = W(ke).getBoundingClientRect(), gr = Math.max(Vt.width, Vt.height), Sr = (Te.x - Vt.width / 2) / gr * 2, ln = (Vt.height / 2 - Te.y) / gr * 2, Jo = je + Sr / et - Sr / ht, Fn = Ke + ln / et - ln / ht;
    ie({ x: Jo, y: Fn, scale: ht });
  }
  function Zr(xe) {
    se(null);
    let Te = "pan";
    W(Me) != "none" ? xe.modifiers.shift || (Te = W(Me)) : xe.modifiers.shift && (Te = xe.modifiers.meta ? "lasso" : "marquee");
    let je = lt(xe);
    switch (Te) {
      case "marquee":
        return {
          move: (Ke) => {
            if (se(null), W(ve) == null)
              return;
            let et = lt(Ke), ht = W(U)(je.x, je.y), Vt = W(U)(et.x, et.y);
            ce({
              xMin: Math.min(ht.x, Vt.x),
              yMin: Math.min(ht.y, Vt.y),
              xMax: Math.max(ht.x, Vt.x),
              yMax: Math.max(ht.y, Vt.y)
            });
          }
        };
      case "lasso": {
        let Ke = [W(U)(je.x, je.y)];
        return {
          move: (et) => {
            if (se(null), W(ve) == null)
              return;
            let ht = lt(et);
            Ke = [...Ke, W(U)(ht.x, ht.y)], Ke.length >= 3 && ce(Gye(Ke, 24));
          }
        };
      }
      case "pan": {
        let Ke = W(U)(0, 0), et = W(U)(1, 1), ht = Ke.x - et.x, Vt = Ke.y - et.y, gr = W(B).x, Sr = W(B).y;
        return {
          move: (ln) => {
            ie({
              x: gr + (ln.clientX - xe.clientX) * ht,
              y: Sr + (ln.clientY - xe.clientY) * Vt,
              scale: W(B).scale
            });
          }
        };
      }
    }
  }
  async function Kt(xe) {
    if (b() != null)
      ce(null);
    else {
      const Te = await en(lt(xe));
      if (Te == null)
        ne([]), se(null);
      else if (xe.modifiers.shift || xe.modifiers.ctrl || xe.modifiers.meta) {
        let je = v()?.findIndex((Ke) => Ke.x == Te.x && Ke.y == Te.y && Ke.category == Te.category);
        v() == null || je == null || je < 0 ? (ne([...v() ?? [], Te]), se(Te)) : (ne([
          ...v().slice(0, je),
          ...v().slice(je + 1)
        ]), se(null));
      } else
        ne([Te]), se(Te);
    }
  }
  let Je = cve(
    async (xe) => {
      let Te = xe ? lt(xe) : null;
      if (v() != null && v().length == 1) {
        let je = W(q)(v()[0].x, v()[0].y);
        Te != null && hve(Te, je) < 10 && se(v()[0]);
      } else
        se(await en(Te));
    },
    () => g() != null
  );
  function mr(xe) {
    xe != null ? W(H) || Je(xe) : Je(null);
  }
  Bm(() => {
    W(H) && Je(null);
  });
  async function en(xe) {
    if (W(ve) == null || xe == null || y() == null)
      return null;
    let { x: Te, y: je } = W(U)(xe.x, xe.y), Ke = Math.abs(W(U)(xe.x + 1, xe.y).x - Te);
    return await y()(Te, je, Ke);
  }
  async function xi(xe, Te, je, Ke = 5e-3) {
    let et = await xe.densityMap(1e3, 1e3, Te, je), ht = await Iye(et.data, et.width, et.height), Vt = [];
    for (let Sr = 0; Sr < ht.length; Sr++) {
      let ln = ht[Sr], Jo = et.coordinateAtPixel(ln.meanX, ln.meanY), Fn = ln.boundaryRectApproximation.map(([yo, Es, Ep, Ds]) => {
        let ml = et.coordinateAtPixel(yo, Es), gl = et.coordinateAtPixel(Ep, Ds);
        return {
          xMin: Math.min(ml.x, gl.x),
          xMax: Math.max(ml.x, gl.x),
          yMin: Math.min(ml.y, gl.y),
          yMax: Math.max(ml.y, gl.y)
        };
      });
      Vt.push({
        x: Jo.x,
        y: Jo.y,
        sumDensity: ln.sumDensity,
        rects: Fn,
        bandwidth: Te
      });
    }
    let gr = Vt.reduce((Sr, ln) => Math.max(Sr, ln.sumDensity), 0);
    return Vt.filter((Sr) => Sr.sumDensity / gr > Ke);
  }
  async function pl(xe) {
    if (W(ve) == null || p() == null)
      return [];
    let Te = await dve({
      autoLabel: {
        version: 1,
        viewport: xe,
        stopWords: u()?.autoLabelStopWords,
        densityThreshold: u()?.autoLabelDensityThreshold
      }
    });
    if (z() != null) {
      let et = await z().get(Te);
      if (et != null)
        return et;
    }
    let je = await xi(W(ve), 10, xe, u()?.autoLabelDensityThreshold ?? 5e-3);
    if (je = je.concat(await xi(W(ve), 5, xe)), p()) {
      let et = await p()(je.map((ht) => ht.rects));
      for (let ht = 0; ht < je.length; ht++)
        je[ht].label = et[ht];
    }
    let Ke = je.filter((et) => et.label != null && et.label.length > 0).map((et) => ({
      x: et.x,
      y: et.y,
      text: et.label,
      priority: et.sumDensity,
      level: et.bandwidth == 10 ? 0 : 1
    }));
    return z() != null && await z().set(Te, Ke), Ke;
  }
  async function Br(xe) {
    if (W(ve) != null)
      if (d() != null)
        dt(Ce, await uO(o(), s(), xe, d(), W(N).fontFamily), !0);
      else {
        dt(Pe, "Generating labels...");
        let Te = await pl(xe);
        dt(Ce, await uO(o(), s(), xe, Te, W(N).fontFamily), !0), dt(Pe, null);
      }
  }
  class qn {
    content;
    constructor(Te, je) {
      let Ke = document.createElement("div");
      this.content = Ke, this.update(je), Te.appendChild(Ke);
    }
    update(Te) {
      let je = this.content;
      je.style.fontFamily = Te.fontFamily, W(R) == "light" ? (je.style.color = "#000", je.style.background = "#fff", je.style.border = "1px solid #000") : (je.style.color = "#ccc", je.style.background = "#000", je.style.border = "1px solid #ccc"), je.style.borderRadius = "2px", je.style.padding = "5px", je.style.fontSize = "12px", je.style.maxWidth = "300px", je.innerText = Te.tooltip.text ?? JSON.stringify(Te.tooltip);
    }
  }
  var vo = n1e();
  let la;
  var Ss = $n(vo);
  Qt(Ss, "", {}, { position: "absolute", top: "0", left: "0" }), s_(Ss, (xe) => dt(ke, xe), () => W(ke));
  var As = Ur(Ss, 2);
  let xc;
  var Kx = $n(As);
  {
    var Qx = (xe) => {
      const Te = /* @__PURE__ */ gt(() => lL(_())), je = /* @__PURE__ */ gt(() => ({
        location: W(q),
        width: o(),
        height: s()
      }));
      var Ke = rm(), et = Df(Ke);
      Y0e(et, () => W(Te), (ht) => {
        var Vt = Xye();
        Rs(Vt, (gr, Sr) => W(Te)?.(gr, Sr), () => uL(_(), { proxy: W(je) })), rn(ht, Vt);
      }), rn(xe, Ke);
    };
    Vi(Kx, (xe) => {
      _() && xe(Qx);
    });
  }
  yn(As);
  var ua = Ur(As, 2);
  Qt(ua, "", {}, { position: "absolute", left: "0", top: "0" });
  var D0 = $n(ua);
  {
    var O0 = (xe) => {
      const Te = /* @__PURE__ */ gt(() => {
        const { x: Vt, y: gr } = W(q)(g().x, g().y);
        return { x: Vt, y: gr };
      }), je = /* @__PURE__ */ gt(() => Math.max(3, W(Gt) / a()) + 1);
      var Ke = rm(), et = Df(Ke);
      {
        var ht = (Vt) => {
          var gr = Jye();
          let Sr;
          Bo(() => {
            qe(gr, "cx", W(Te).x), qe(gr, "cy", W(Te).y), qe(gr, "r", W(je)), Sr = Qt(gr, "", Sr, {
              stroke: W(R) == "light" ? "#000" : "#fff",
              "stroke-width": 1,
              fill: "none"
            });
          }), rn(Vt, gr);
        };
        Vi(et, (Vt) => {
          isFinite(W(Te).x) && isFinite(W(Te).y) && isFinite(W(je)) && Vt(ht);
        });
      }
      rn(xe, Ke);
    };
    Vi(D0, (xe) => {
      g() != null && W(ve) != null && xe(O0);
    });
  }
  var F0 = Ur(D0);
  {
    var Xx = (xe) => {
      var Te = rm(), je = Df(Te);
      Dk(je, 17, v, Ek, (Ke, et) => {
        const ht = /* @__PURE__ */ gt(() => {
          const { x: Fn, y: yo } = W(q)(W(et).x, W(et).y);
          return { x: Fn, y: yo };
        }), Vt = /* @__PURE__ */ gt(() => W(et).category != null ? W(I)[W(et).category] : W(I)[0]), gr = /* @__PURE__ */ gt(() => Math.max(3, W(Gt) / a()) + 1);
        var Sr = rm(), ln = Df(Sr);
        {
          var Jo = (Fn) => {
            var yo = Yye();
            let Es;
            Bo(() => {
              qe(yo, "cx", W(ht).x), qe(yo, "cy", W(ht).y), qe(yo, "r", W(gr)), Es = Qt(yo, "", Es, {
                stroke: W(R) == "light" ? "#000" : "#fff",
                "stroke-width": 2,
                fill: W(Vt)
              });
            }), rn(Fn, yo);
          };
          Vi(ln, (Fn) => {
            isFinite(W(ht).x) && isFinite(W(ht).y) && isFinite(W(gr)) && Fn(Jo);
          });
        }
        rn(Ke, Sr);
      }), rn(xe, Te);
    };
    Vi(F0, (xe) => {
      v() != null && W(ve) != null && xe(Xx);
    });
  }
  var T0 = Ur(F0);
  {
    var Sp = (xe) => {
      var Te = r1e();
      Dk(Te, 21, () => W(Ce), Ek, (je, Ke) => {
        const et = /* @__PURE__ */ gt(() => W(Ke).text.split(`
`)), ht = /* @__PURE__ */ gt(() => W(q)(W(Ke).coordinate.x, W(Ke).coordinate.y)), Vt = /* @__PURE__ */ gt(() => W(Ke).placement != null && W(Ke).placement.minScale <= W(B).scale && W(B).scale <= W(Ke).placement.maxScale);
        var gr = t1e(), Sr = $n(gr);
        {
          var ln = (Jo) => {
            var Fn = e1e();
            Dk(Fn, 21, () => W(et), Ek, (yo, Es, Ep) => {
              var Ds = Zye();
              qe(Ds, "x", 0);
              let ml;
              var gl = $n(Ds, !0);
              yn(Ds), Bo(() => {
                qe(Ds, "y", (Ep - (W(et).length - 1) / 2) * W(Ke).fontSize), qe(Ds, "font-size", W(Ke).fontSize), ml = Qt(Ds, "", ml, {
                  "paint-order": "stroke",
                  "stroke-width": "4",
                  "stroke-linejoin": "round",
                  "stroke-linecap": "round",
                  "text-anchor": "middle",
                  fill: W(N).clusterLabelColor,
                  stroke: W(N).clusterLabelOutlineColor,
                  opacity: W(N).clusterLabelOpacity,
                  "user-select": "none",
                  "-webkit-user-select": "none",
                  "font-family": W(N).fontFamily
                }), Lm(gl, W(Es));
              }), rn(yo, Ds);
            }), yn(Fn), rn(Jo, Fn);
          };
          Vi(Sr, (Jo) => {
            W(Vt) && Jo(ln);
          });
        }
        yn(gr), Bo(() => qe(gr, "transform", `translate(${W(ht).x ?? ""},${W(ht).y ?? ""})`)), rn(je, gr);
      }), yn(Te), rn(xe, Te);
    };
    Vi(T0, (xe) => {
      xe(Sp);
    });
  }
  var Jx = Ur(T0);
  {
    var Ap = (xe) => {
      var Te = rm(), je = Df(Te);
      {
        var Ke = (ht) => {
          vve(ht, {
            get value() {
              return b();
            },
            get pointLocation() {
              return W(q);
            }
          });
        }, et = (ht) => {
          uve(ht, {
            get value() {
              return b();
            },
            onChange: ce,
            get pointLocation() {
              return W(q);
            },
            get coordinateAtPoint() {
              return W(U);
            },
            preventHover: (Vt) => {
              dt(H, Vt, !0);
            }
          });
        };
        Vi(je, (ht) => {
          b() instanceof Array ? ht(Ke) : ht(et, !1);
        });
      }
      rn(xe, Te);
    };
    Vi(Jx, (xe) => {
      b() != null && W(ve) != null && xe(Ap);
    });
  }
  yn(ua), Rs(ua, (xe, Te) => gn?.(xe, Te), () => ({ click: Kt, drag: Zr, hover: mr }));
  var M0 = Ur(ua, 2);
  {
    var Yx = (xe) => {
      const Te = /* @__PURE__ */ gt(() => W(q)(g().x, g().y));
      {
        let je = /* @__PURE__ */ gt(() => Math.max(3, W(Gt) / a())), Ke = /* @__PURE__ */ gt(() => S() ?? {
          class: qn,
          props: {
            colorScheme: W(R),
            fontFamily: W(N).fontFamily
          }
        });
        Ove(xe, {
          get location() {
            return W(Te);
          },
          get allowInteraction() {
            return W(re);
          },
          get targetHeight() {
            return W(je);
          },
          get customTooltip() {
            return W(Ke);
          },
          get tooltip() {
            return g();
          }
        });
      }
    };
    Vi(M0, (xe) => {
      g() != null && W(ve) != null && xe(Yx);
    });
  }
  var Zx = Ur(M0, 2);
  {
    var ew = (xe) => {
      {
        let Te = /* @__PURE__ */ gt(() => W(Pe) ?? W(We)), je = /* @__PURE__ */ gt(() => 1 / (W(q)(1, 0).x - W(q)(0, 0).x));
        Ave(xe, {
          get resolvedTheme() {
            return W(N);
          },
          get statusMessage() {
            return W(Te);
          },
          get distancePerPoint() {
            return W(je);
          },
          get pointCount() {
            return r().x.length;
          },
          get selectionMode() {
            return W(Me);
          },
          onSelectionMode: (Ke) => dt(Me, Ke, !0)
        });
      }
    };
    Vi(Zx, (xe) => {
      W(N).statusBar && xe(ew);
    });
  }
  yn(vo), Bo(() => {
    la = Qt(vo, "", la, {
      width: `${o() ?? ""}px`,
      height: `${s() ?? ""}px`,
      position: "relative"
    }), xc = Qt(As, "", xc, {
      width: `${o() ?? ""}px`,
      height: `${s() ?? ""}px`,
      position: "absolute",
      top: "0",
      left: "0"
    }), qe(ua, "width", o()), qe(ua, "height", s());
  }), j0e("wheel", ua, kt), rn(t, vo), Wh();
}
function pO(t, e) {
  if (e.length == 0)
    return T.literal(!1);
  if (t.identifier != null) {
    let r = t.identifier;
    return T.or(...e.map((n) => T.eq(T.column(r), T.literal(n.identifier))));
  } else {
    let r = t.x, n = t.y, i = t.category;
    return i != null ? T.or(
      ...e.map(
        (o) => T.and(
          T.eq(T.cast(T.column(r), "DOUBLE"), T.literal(o.x)),
          T.eq(T.cast(T.column(n), "DOUBLE"), T.literal(o.y)),
          T.eq(T.cast(T.column(i), "INTEGER"), T.literal(o.category))
        )
      )
    ) : T.or(
      ...e.map(
        (o) => T.and(
          T.eq(T.cast(T.column(r), "DOUBLE"), T.literal(o.x)),
          T.eq(T.cast(T.column(n), "DOUBLE"), T.literal(o.y))
        )
      )
    );
  }
}
function o1e(t, e, r) {
  let n = [];
  for (let o = 0; o < r.length; o++) {
    let s = (o + 1) % r.length, { x: a, y: l } = r[o], { x: u, y: c } = r[s], h = l < c ? T.and(T.lte(T.literal(l), e), T.lt(e, T.literal(c))) : T.and(T.lte(T.literal(c), e), T.lt(e, T.literal(l))), d = (l < c ? T.lt : T.gt)(
      T.sub(T.mul(T.literal(u - a), e), T.mul(T.literal(c - l), t)),
      T.literal((u - a) * l - (c - l) * a)
    );
    n.push(T.cast(T.and(h, d), "INT"));
  }
  let i = n.reduce((o, s) => T.add(o, s));
  return T.eq(T.mod(i, T.literal(2)), T.literal(1));
}
function s1e(t, e) {
  if (e instanceof Array) {
    if (e.length < 3)
      return T.literal(!1);
    let r = aL(e);
    return T.and(
      T.isBetween(T.column(t.x), [r.xMin, r.xMax]),
      T.isBetween(T.column(t.y), [r.yMin, r.yMax]),
      o1e(T.column(t.x), T.column(t.y), e)
    );
  } else
    return T.and(
      T.isBetween(T.column(t.x), [e.xMin, e.xMax]),
      T.isBetween(T.column(t.y), [e.yMin, e.yMax])
    );
}
async function a1e(t, e) {
  let { x: r, y: n, table: i } = e, o = await t.query(
    T.Query.from(i).select({
      centerX: T.sql`MEDIAN(${T.column(r)})`,
      centerY: T.sql`MEDIAN(${T.column(n)})`,
      stdX: T.sql`STDDEV(${T.column(r)})`,
      stdY: T.sql`STDDEV(${T.column(n)})`,
      ...e.category != null ? {
        maxCategory: T.sql`MAX(${T.column(e.category)}::UTINYINT)`
      } : {}
    })
  ), { centerX: s, centerY: a, stdX: l, stdY: u, maxCategory: c } = o.get(0), h = 1 / (Math.max(l, u, 1e-3) * 3), d = 0.1 / h, p = T.sql`FLOOR((${T.column(r)} - ${s}) / ${d})`, g = T.sql`FLOOR((${T.column(n)} - ${a}) / ${d})`, v = e.category != null ? T.column(e.category) : null, y = v != null ? [p, g, v] : [p, g], b = T.Query.from(
    T.Query.from(i).select({ count: T.sql`COUNT(*)` }).groupby(...y)
  ).select({
    totalCount: T.sql`SUM(count)::INT`,
    maxCount: T.sql`MAX(count)::INT`
  });
  o = await t.query(b);
  let { maxCount: k, totalCount: C } = o.get(0), S = k / (d * d);
  return {
    centerX: s,
    centerY: a,
    scaler: h,
    totalCount: C,
    categoryCount: (c ?? 0) + 1,
    maxDensity: S
  };
}
class l1e {
  coordinator;
  source;
  lastDistance;
  selectParams;
  constructor(e, r) {
    this.coordinator = e, this.source = r, this.lastDistance = 0;
    let { x: n, y: i, category: o, text: s, identifier: a } = this.source, l = {}, u = r.additionalFields ?? {};
    for (let c in u) {
      let h = u[c];
      typeof h == "string" ? l["field_" + c] = T.column(h) : l["field_" + c] = T.sql`${h.sql}`;
    }
    this.selectParams = {
      x: T.sql`${T.column(n)}::DOUBLE`,
      y: T.sql`${T.column(i)}::DOUBLE`,
      ...o != null ? { category: T.sql`${T.column(o)}::INT` } : {},
      ...s != null ? { text: T.sql`${T.column(s)}` } : {},
      ...a != null ? { identifier: T.sql`${T.column(a)}` } : {},
      ...l
    };
  }
  _convertToDataPoint(e) {
    let r = {};
    for (let n in e)
      n.startsWith("field_") && (r[n.slice(6)] = e[n]);
    return {
      x: e.x,
      y: e.y,
      category: e.category,
      text: e.text,
      identifier: e.identifier,
      fields: r
    };
  }
  async queryClosestPoint(e, r, n, i) {
    let o = i * 12, { x: s, y: a } = this.source;
    for (let l of [this.lastDistance, o]) {
      if (l == 0 || l > o)
        continue;
      let u = T.Query.from(this.source.table).select(this.selectParams);
      u = u.where(T.sql`${T.column(s)} BETWEEN ${r - l} AND ${r + l}`), u = u.where(T.sql`${T.column(a)} BETWEEN ${n - l} AND ${n + l}`), e && (u = u.where(e)), u = u.orderby(T.sql`(x - (${r}))**2 + (y - (${n}))**2`).limit(1);
      let c = (await this.coordinator.query(u)).get(0);
      if (c)
        return this.lastDistance = Math.max(Math.abs(c.x - r), Math.abs(c.y - n)) * 4, this._convertToDataPoint(c);
    }
    return null;
  }
  async queryPoints(e) {
    let { table: r, identifier: n } = this.source;
    if (n == null)
      return [];
    let i = T.Query.from(r).select(this.selectParams);
    return i = i.where(
      T.isIn(
        T.column(n),
        e.map((o) => T.literal(o))
      )
    ), Array.from(await this.coordinator.query(i)).map((o) => this._convertToDataPoint(o));
  }
}
function u1e(t, e) {
  Vh(e, !0);
  let r = tt(e, "coordinator", 19, _F), n = tt(e, "category", 3, null), i = tt(e, "text", 3, null), o = tt(e, "identifier", 3, null), s = tt(e, "filter", 3, null), a = tt(e, "categoryColors", 3, null), l = tt(e, "tooltip", 3, null), u = tt(e, "additionalFields", 3, null), c = tt(e, "selection", 3, null), h = tt(e, "rangeSelection", 3, null), d = tt(e, "rangeSelectionValue", 3, null), p = tt(e, "width", 3, null), g = tt(e, "height", 3, null), v = tt(e, "pixelRatio", 3, null), y = tt(e, "config", 3, null), b = tt(e, "theme", 3, null), k = tt(e, "viewportState", 3, null), C = tt(e, "labels", 3, null), S = tt(e, "customTooltip", 3, null), _ = tt(e, "customOverlay", 3, null), D = tt(e, "onViewportState", 3, null), A = tt(e, "onTooltip", 3, null), O = tt(e, "onSelection", 3, null), M = tt(e, "onRangeSelection", 3, null), z = tt(e, "cache", 3, null), R = /* @__PURE__ */ Mr(new Float32Array()), N = /* @__PURE__ */ Mr(new Float32Array()), I = /* @__PURE__ */ Mr(null), B = /* @__PURE__ */ Mr(1), $ = /* @__PURE__ */ Mr(1), q = /* @__PURE__ */ Mr(1), U = /* @__PURE__ */ Mr(null), H = /* @__PURE__ */ Mr(null), G = /* @__PURE__ */ Mr(null), re = /* @__PURE__ */ Mr(null), ie = /* @__PURE__ */ Mr(null);
  El(() => {
    let he = {
      coordinator: r(),
      source: {
        table: e.table,
        x: e.x,
        y: e.y,
        category: n()
      }
    }, ke = null, ve = !1;
    async function We() {
      let Qe = he.source, ot = await a1e(he.coordinator, Qe);
      if (ve)
        return;
      let Ye = ot.scaler * 0.95;
      dt(U, {
        x: ot.centerX,
        y: ot.centerY,
        scale: Ye
      }), dt($, ot.totalCount), dt(q, ot.maxDensity), dt(B, ot.categoryCount), ke = il({
        coordinator: he.coordinator,
        selection: s() ?? void 0,
        query: (Ht) => T.Query.from(Qe.table).select({
          x: T.sql`${T.column(Qe.x)}::FLOAT`,
          y: T.sql`${T.column(Qe.y)}::FLOAT`,
          ...Qe.category != null ? { c: T.sql`${T.column(Qe.category)}::UTINYINT` } : {}
        }).where(Ht),
        queryResult: (Ht) => {
          let St = Ht.getChild("x").toArray(), Gt = Ht.getChild("y").toArray(), $t = Ht.getChild("c")?.toArray() ?? null;
          St != null && !(St instanceof Float32Array) && (St = new Float32Array(St)), Gt != null && !(Gt instanceof Float32Array) && (Gt = new Float32Array(Gt)), $t != null && !($t instanceof Uint8Array) && ($t = new Uint8Array($t)), dt(R, St), dt(N, Gt), dt(I, $t), se(null), ne(null);
        }
      }), ke.reset = () => {
        ce();
      }, dt(ie, ke);
    }
    return We(), () => {
      dt(ie, null), ve = !0, ke?.destroy();
    };
  }), El(() => {
    if (o3(l())) {
      let he = W(ie);
      if (he == null)
        return;
      let ke = l();
      dt(H, ke.valueFor(he) ?? null);
      let ve = () => {
        dt(H, ke.valueFor(he) ?? null);
      };
      return El(() => {
        let We = W(H), Qe = {
          x: e.x,
          y: e.y,
          category: n(),
          identifier: o()
        };
        ke.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          predicate: We != null ? pO(Qe, [We]) : null,
          value: We
        });
      }), ke.addEventListener("value", ve), () => {
        ke.removeEventListener("value", ve), ke.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          value: null,
          predicate: null
        });
      };
    } else if (l() == null || typeof l() == "object")
      dt(H, l());
    else {
      if (W(H)?.identifier == l())
        return;
      let he = !1;
      return Me([l()]).then((ke) => {
        he || (ke.length > 0 ? dt(H, ke[0]) : dt(H, null));
      }), () => {
        he = !0;
      };
    }
  });
  function se(he) {
    Iu(l(), he) || (dt(H, he), A()?.(he));
  }
  El(() => {
    if (o3(c())) {
      let he = W(ie);
      if (he == null)
        return;
      let ke = c();
      dt(G, ke.valueFor(he) ?? null);
      let ve = () => {
        dt(G, ke.valueFor(he) ?? null);
      };
      return El(() => {
        let We = W(G), Qe = {
          x: e.x,
          y: e.y,
          category: n(),
          identifier: o()
        };
        ke.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          predicate: We != null ? pO(Qe, We) : null,
          value: We
        });
      }), ke.addEventListener("value", ve), () => {
        ke.removeEventListener("value", ve), ke.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          value: null,
          predicate: null
        });
      };
    } else if (c() == null)
      dt(G, null);
    else if (c().length == 0)
      dt(G, []);
    else if (c().every((he) => typeof he == "object"))
      dt(G, c());
    else {
      let he = !1;
      return Me(c()).then((ke) => {
        he || dt(G, ke);
      }), () => {
        he = !0;
      };
    }
  });
  function ne(he) {
    Iu(c(), he) || (dt(G, he), O()?.(he));
  }
  El(() => {
    let he = W(ie);
    if (he == null)
      return;
    let ke = h();
    if (ke != null)
      return El(() => {
        let ve = W(re), We = { x: e.x, y: e.y }, Qe = {
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          predicate: ve != null ? s1e(We, ve) : null,
          value: ve
        };
        ke.update(Qe), ke.activate(Qe);
      }), () => {
        ke.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          value: null,
          predicate: null
        });
      };
  }), El(() => {
    Iu(Kh(() => W(re)), d()) || dt(re, d());
  });
  function ce() {
    ne(null), se(null), M()?.(null), dt(re, null);
  }
  let Ce = /* @__PURE__ */ gt(() => new l1e(r(), {
    table: e.table,
    x: e.x,
    y: e.y,
    category: n(),
    text: i(),
    identifier: o(),
    additionalFields: u()
  }));
  async function Pe(he, ke, ve) {
    return await W(Ce).queryClosestPoint(s()?.predicate?.(W(ie)), he, ke, ve);
  }
  async function Me(he) {
    return await W(Ce).queryPoints(he);
  }
  async function _e(he) {
    if (i() == null)
      return he.map(() => null);
    let ke = await Lye({
      regions: he,
      stopWords: y()?.autoLabelStopWords ?? null
    }), ve = 0, We = 1e4, Qe = null;
    for (; ; ) {
      let Ye = await r().query(T.Query.from(e.table).select({
        x: T.column(e.x),
        y: T.column(e.y),
        text: T.column(i())
      }).offset(ve).limit(We)), Ht = {
        x: Ye.getChild("x").toArray(),
        y: Ye.getChild("y").toArray(),
        text: Ye.getChild("text").toArray()
      };
      if (Qe != null && await Qe, Qe = jye(ke, Ht), Ye.getChild("text").length < We)
        break;
      ve += We;
    }
    Qe != null && await Qe;
    let ot = await qye(ke);
    return await zye(ke), ot.map((Ye) => Ye.length == 0 ? null : Ye.length > 2 ? Ye.slice(0, 2).join("-") + `-
` + Ye.slice(2).join("-") : Ye.join("-"));
  }
  {
    let he = /* @__PURE__ */ gt(() => p() ?? 800), ke = /* @__PURE__ */ gt(() => g() ?? 800), ve = /* @__PURE__ */ gt(() => v() ?? 2), We = /* @__PURE__ */ gt(() => ({
      x: W(R),
      y: W(N),
      category: W(I)
    }));
    i1e(t, {
      get width() {
        return W(he);
      },
      get height() {
        return W(ke);
      },
      get pixelRatio() {
        return W(ve);
      },
      get theme() {
        return b();
      },
      get config() {
        return y();
      },
      get data() {
        return W(We);
      },
      get totalCount() {
        return W($);
      },
      get maxDensity() {
        return W(q);
      },
      get categoryCount() {
        return W(B);
      },
      get categoryColors() {
        return a();
      },
      get defaultViewportState() {
        return W(U);
      },
      querySelection: Pe,
      queryClusterLabels: _e,
      get labels() {
        return C();
      },
      get customTooltip() {
        return S();
      },
      get customOverlay() {
        return _();
      },
      get tooltip() {
        return W(H);
      },
      onTooltip: se,
      get selection() {
        return W(G);
      },
      onSelection: ne,
      get viewportState() {
        return k();
      },
      get onViewportState() {
        return D();
      },
      get rangeSelection() {
        return W(re);
      },
      onRangeSelection: (Qe) => {
        dt(re, Qe), M()?.(Qe);
      },
      get cache() {
        return z();
      }
    });
  }
  Wh();
}
class c1e {
  component;
  currentProps;
  constructor(e, r) {
    this.currentProps = { ...r }, this.component = K0e({ component: u1e, target: e, props: r });
  }
  update(e) {
    let r = {};
    for (let n in e)
      e[n] !== this.currentProps[n] && (r[n] = e[n], this.currentProps[n] = e[n]);
    this.component.$set(r);
  }
  destroy() {
    this.component.$destroy();
  }
}
function h1e() {
  return sB() ? 32 : 4;
}
function yy(t, e = 0) {
  let r = ZI(t);
  return r.l += e, r.a = 0, r.b = 0, r.rgb().formatHex8();
}
const bc = {
  light: {
    scheme: "light",
    continuousColorScheme: "YlGnBu",
    continuousColorSchemeAtZero: qge(0),
    markColor: "#3b82f6",
    markColorFade: "#dbeafe",
    markColorGray: yy("#3b82f6", 20),
    markColorGrayFade: yy("#dbeafe"),
    gridColor: $s.slate[300],
    labelColor: $s.slate[400],
    titleColor: $s.slate[400],
    brushBorder: $s.slate[500],
    brushBorderBack: "#fff",
    brushFill: "rgba(0,0,0,0.1)"
  },
  dark: {
    scheme: "dark",
    continuousColorScheme: "Inferno",
    continuousColorSchemeAtZero: oB(0),
    markColor: "#3b82f6",
    markColorFade: "#3b4d7f",
    markColorGray: yy("#3b82f6", -20),
    markColorGrayFade: yy("#1f398a"),
    gridColor: $s.slate[700],
    labelColor: $s.slate[500],
    titleColor: $s.slate[500],
    brushBorder: $s.slate[400],
    brushBorderBack: "#000",
    brushFill: "rgba(255,255,255,0.1)"
  }
};
function _L(t) {
  let e = [];
  for (let r = 0; r < t; r++)
    e.push(Uge((r + 0.5) / t));
  return e;
}
const SL = "system-ui", c_ = 11, f1e = 80;
let im;
function d1e() {
  return im == null && (im = document.createElement("canvas"), im.width = 1, im.height = 1), im.getContext("2d");
}
function h_(t) {
  let e = d1e();
  e.font = `${c_}px ${SL}`;
  let r = e.measureText(t);
  return {
    width: Math.min(f1e, r.width),
    height: c_
  };
}
function AL(t, e, r = 0) {
  let n = 0, i = 0;
  for (let o of t) {
    let { width: s, height: a } = o.size;
    n = Math.max(n, s), i = Math.max(i, a);
  }
  switch (e) {
    case "x":
      return { left: n / 2, right: n / 2, top: 0, bottom: i + r };
    case "y":
      return { left: n + r, right: 0, top: i / 2, bottom: i / 2 };
  }
}
function mO(t, e, r) {
  switch (t.type) {
    case "band":
      return p1e(t, e, r);
    default:
      return m1e(t, e, r);
  }
}
function p1e(t, e, r) {
  let n = [...t.domain, ...t.specialValues ?? []];
  n = Array.from(new Set(n)), r == "y" && (n = n.reverse());
  let i = HI().domain(n).padding(0.1), o = [], s = [], a = { left: 0, right: 0, top: 0, bottom: 0 };
  if (e) {
    let l = e.values ?? i.domain(), u = e.labelPadding ?? 6;
    o = l.map((c) => {
      let { width: h, height: d } = h_(c);
      return r == "y" ? {
        text: c,
        value: c,
        padding: u,
        level: 0,
        size: { width: h, height: d },
        orientation: "horizontal"
      } : {
        text: c,
        value: c,
        padding: u,
        level: 0,
        size: { width: d, height: h },
        orientation: "vertical"
      };
    }), s = l.map((c) => ({ value: c, level: 0 })), a = QS([a, AL(o, r, u)]);
  }
  return {
    extents: a,
    labels: o,
    gridLines: [],
    ticks: s,
    concrete: (l) => v1e(i, t.domain, t.specialValues ?? [], l)
  };
}
function m1e(t, e, r) {
  let n;
  switch (t.type) {
    case "linear": {
      n = cp().domain(t.domain);
      break;
    }
    case "log": {
      n = Rg().domain(t.domain);
      break;
    }
    case "symlog": {
      let a = t.constant ?? 1;
      n = nB().constant(a).domain(t.domain), n.nice = () => n, n.ticks = (l) => y1e(n.domain(), a, l), n.tickFormat = () => ou("~s");
      break;
    }
    default:
      throw new Error("invalid scale type");
  }
  let i = [], o = [], s = { left: 0, right: 0, top: 0, bottom: 0 };
  if (e) {
    let a = [];
    if (e.extendScaleToTicks ?? !0)
      if (e.values) {
        a = e.values;
        let h = n.domain().concat(a);
        n = n.domain([
          h.reduce((d, p) => Math.min(d, p), h[0]),
          h.reduce((d, p) => Math.max(d, p), h[0])
        ]);
      } else {
        let h = e.desiredTickCount ?? 5;
        n.nice && (n = n.nice(h)), a = n.ticks(h);
      }
    else {
      if (e.values)
        a = e.values;
      else {
        let p = e.desiredTickCount ?? 5;
        a = n.ticks(p);
      }
      let [h, d] = n.domain();
      a = a.filter((p) => p >= h && p <= d);
    }
    let l = e.labelPadding ?? 6, u = n.tickFormat(e.values ? e.values.length : e.desiredTickCount ?? 5), c = (h) => t.type == "log" || t.type == "symlog" ? Math.round(Math.log10(Math.abs(h))) == Math.log10(Math.abs(h)) ? 0 : 1 : 0;
    i = a.map((h) => {
      let d = u(h);
      return {
        text: d,
        value: h,
        padding: l,
        level: c(h),
        size: h_(d),
        orientation: "horizontal"
      };
    });
    for (let h of t.specialValues ?? [])
      i.push({
        text: h,
        value: h,
        padding: l,
        level: 0,
        size: h_(h),
        orientation: "horizontal"
      });
    o = a.map((h) => ({ value: h, level: c(h) })), s = QS([s, AL(i, r, l)]);
  }
  return {
    extents: s,
    labels: i,
    gridLines: o,
    ticks: o,
    concrete: (a) => g1e(n, t.specialValues ?? [], a)
  };
}
function QS(t) {
  let e = { left: 0, right: 0, top: 0, bottom: 0 };
  for (let r of t)
    e.left = Math.max(e.left, r.left), e.right = Math.max(e.right, r.right), e.top = Math.max(e.top, r.top), e.bottom = Math.max(e.bottom, r.bottom);
  return e;
}
function gO(t, e, r = {}) {
  let n = r.gap ?? 0, i = t.map((a, l) => ({ ...e(a), index: l })).sort((a, l) => a.priority - l.priority), o = t.map((a) => !1), s = (a, l) => Math.abs(a.center - l.center) < n + a.length / 2 + l.length / 2;
  for (let a = 0; a < i.length; a++) {
    let l = !1;
    for (let u = 0; u < a; u++)
      if (o[i[u].index] && s(i[a], i[u])) {
        l = !0;
        break;
      }
    o[i[a].index] = !l;
  }
  return t.filter((a, l) => o[l]);
}
function g1e(t, e, r) {
  e = Array.from(new Set(e));
  let n = r[0], i = r[1], o = /* @__PURE__ */ new Map(), s;
  if (e.length > 0) {
    let l = 22, u = 8, c = 20, h = e.length * c, d = 2, p = n;
    n < i ? (n = n + h + l, s = [p, p + h + l - u]) : (n = n - h - l, p = n + l, s = [p - l + u, p + h]);
    for (let g = 0; g < e.length; g++)
      o.set(e[g], [p + g * c + d, p + g * c + c - d]);
  }
  let a = t.copy().range([n, i]);
  return {
    domain: t.domain(),
    specialValues: e ?? [],
    range: [n, i],
    rangeBands: [[n, i], ...s ? [s] : []],
    apply: (l) => {
      let u = o.get(l);
      return u != null ? (u[0] + u[1]) / 2 : a(l);
    },
    applyBand: (l) => {
      let u = o.get(l);
      if (u != null)
        return u;
      if (typeof l != "number")
        return [a(l[0]), a(l[1])];
      {
        let c = a(l);
        return [c, c];
      }
    },
    invert: (l, u) => {
      if (u != "number") {
        for (let [c, h] of o.entries())
          if (l >= Math.min(...h) && l <= Math.max(...h))
            return c;
      }
      return a.invert(l);
    }
  };
}
function v1e(t, e, r, n) {
  let i = n[0], o = n[1], s = t.copy().range(n), a = s.bandwidth(), l = s.step();
  return {
    domain: e,
    specialValues: r,
    range: [i, o],
    rangeBands: [[i, o]],
    apply: (u) => (s(u) ?? 0) + a / 2,
    applyBand: (u) => {
      let c = s(u) ?? 0;
      return [c, c + a];
    },
    invert: (u) => {
      let c = (u - i) / (o - i), h = Math.floor(c * Math.abs(o - i) / l);
      return t.domain()[h];
    }
  };
}
function y1e(t, e, r) {
  r = r ?? 5;
  let n = t[0], i = t[1];
  if (n > 0 && i > 0 && n / i > 0.5 || n < 0 && i < 0 && i / n > 0.5)
    return cp().domain([n, i]).ticks(r);
  let o = e * 2, s = e * 5;
  return n < -s && i > s && (r = Math.ceil(r / 2)), [
    ...n < -s ? Rg().domain([o, -n]).ticks(r).map((a) => -a) : [],
    0,
    ...i > s ? Rg().domain([o, i]).ticks(r) : []
  ].filter((a) => a >= n && a <= i);
}
function b1e(t, e) {
  let { min: r, max: n, median: i, count: o, minPositive: s } = t, a = {
    type: "linear",
    domain: [r, n]
  };
  return e == null ? o >= 100 && r >= 0 && i < n * 0.05 && (a.type = r > 0 ? "log" : "symlog") : a.type = e, a.type == "log" && (a.domain[0] = s), a;
}
function x1e(t, e = {}) {
  let r = e.fade ?? [], n = e.ordinal ?? !1, i = [], o = (l) => JSON.stringify(l);
  for (let l of t) {
    let u = o(l);
    typeof l == "string" && r.indexOf(l) >= 0 || i.push(u);
  }
  let s = n ? _L(i.length) : mp(i.length), a = new Map(i.map((l, u) => [l, s[u]]));
  return {
    domain: t,
    apply: (l) => {
      let u = o(l);
      return a.get(u) ?? "#888888";
    }
  };
}
var w1e = /* @__PURE__ */ Dt("<g><foreignObject><div> </div></foreignObject></g>");
function vO(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => e.dimension == "x" ? {
    px: e.proxy.xScale?.apply(e.label.value) ?? 0,
    py: e.proxy.plotHeight + e.label.padding,
    anchorX: 0.5,
    anchorY: 0
  } : {
    px: -e.label.padding,
    py: e.proxy.yScale?.apply(e.label.value) ?? 0,
    anchorX: 1,
    anchorY: 0.5
  }), n = /* @__PURE__ */ K(() => x(r).px), i = /* @__PURE__ */ K(() => x(r).py), o = /* @__PURE__ */ K(() => x(r).anchorX), s = /* @__PURE__ */ K(() => x(r).anchorY), a = /* @__PURE__ */ K(() => e.label.orientation == "vertical" ? {
    rotation: 90,
    shiftX: x(o) * e.label.size.width,
    shiftY: -x(s) * e.label.size.height,
    width: e.label.size.height,
    height: e.label.size.width
  } : {
    rotation: 0,
    shiftX: -x(o) * e.label.size.width,
    shiftY: -x(s) * e.label.size.height,
    width: e.label.size.width,
    height: e.label.size.height
  }), l = /* @__PURE__ */ K(() => x(a).rotation), u = /* @__PURE__ */ K(() => x(a).shiftX), c = /* @__PURE__ */ K(() => x(a).shiftY), h = /* @__PURE__ */ K(() => x(a).width), d = /* @__PURE__ */ K(() => x(a).height), p = 4, g = 4;
  var v = w1e(), y = Y(v);
  te(y, "x", -p), te(y, "y", -g);
  var b = Y(y);
  let k;
  var C = Y(b, !0);
  J(b), J(y), J(v), Ae(() => {
    te(v, "transform", `translate(${x(n) + x(u)}, ${x(i) + x(c)}) rotate(${x(l) ?? ""})`), te(y, "width", x(h) + p * 2), te(y, "height", x(d) + g * 2), te(b, "title", e.label.text), k = ft(b, "", k, {
      width: `${x(h) + 2}px`,
      height: `${x(d) + g * 2}px`,
      "line-height": `${x(d) + g * 2}px`,
      "font-family": SL,
      "font-size": `${c_}px`,
      "margin-left": "4px",
      color: e.color,
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }), ut(C, e.label.text);
  }), X(t, v), it();
}
var k1e = /* @__PURE__ */ Dt('<line stroke-linecap="butt"></line>'), C1e = /* @__PURE__ */ Dt('<line stroke-dasharray="1,3" stroke-linecap="square"></line>'), _1e = /* @__PURE__ */ Dt("<g><!><!><!></g>"), S1e = /* @__PURE__ */ Dt('<line stroke-linecap="butt"></line>'), A1e = /* @__PURE__ */ Dt('<line stroke-linecap="square"></line>'), E1e = /* @__PURE__ */ Dt("<g><!><!><!></g>"), D1e = /* @__PURE__ */ me("<div><svg><g><!><!><!><!></g></svg></div>");
function Ld(t, e) {
  nt(e, !0);
  const r = 4;
  let n = ct(e, "xAxis", 19, () => ({})), i = ct(e, "yAxis", 19, () => ({})), o = /* @__PURE__ */ K(() => e.xScale ? mO(e.xScale, n(), "x") : null), s = /* @__PURE__ */ K(() => e.yScale ? mO(e.yScale, i(), "y") : null), a = /* @__PURE__ */ K(() => QS([
    x(o)?.extents,
    x(s)?.extents,
    e.extents
  ].filter((M) => M != null))), l = /* @__PURE__ */ K(() => ({
    x: x(a).left,
    y: x(a).top,
    width: e.width - x(a).left - x(a).right,
    height: e.height - x(a).top - x(a).bottom
  })), u = /* @__PURE__ */ K(() => x(o)?.concrete([0, x(l).width])), c = /* @__PURE__ */ K(() => x(s)?.concrete([x(l).height, 0])), h = /* @__PURE__ */ K(() => x(o) && x(u) ? gO(
    x(o).labels,
    (M) => ({
      center: x(u).apply(M.value),
      length: M.size.width,
      priority: M.level
    }),
    { gap: 4 }
  ) : []), d = /* @__PURE__ */ K(() => x(s) && x(c) ? gO(
    x(s).labels,
    (M) => ({
      center: x(c).apply(M.value),
      length: M.size.height,
      priority: M.level
    }),
    { gap: 2 }
  ) : []), p = /* @__PURE__ */ K(() => bc[e.colorScheme ?? "light"]), g = /* @__PURE__ */ K(() => ({
    xScale: x(u),
    yScale: x(c),
    plotWidth: x(l).width,
    plotHeight: x(l).height
  }));
  var v = D1e();
  let y;
  var b = Y(v);
  ft(b, "", {}, { position: "absolute", left: "-4px", top: "-4px" });
  var k = Y(b), C = Y(k);
  Xl(C, () => e.childrenBelow ?? zt, () => x(g));
  var S = ae(C);
  {
    var _ = (M) => {
      var z = _1e(), R = Y(z);
      Nt(R, 17, () => x(o).ticks, cr, (B, $) => {
        const q = /* @__PURE__ */ K(() => x(u).apply(x($).value));
        var U = k1e();
        Ae(() => {
          te(U, "x1", x(q)), te(U, "y1", x(l).height), te(U, "x2", x(q)), te(U, "y2", x(l).height + (x($).level == 0 ? 3 : 0)), te(U, "stroke", x(p).gridColor), te(U, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
        }), X(B, U);
      });
      var N = ae(R);
      Nt(N, 17, () => x(o).gridLines, cr, (B, $) => {
        const q = /* @__PURE__ */ K(() => x(u).apply(x($).value));
        var U = kr(), H = Ve(U);
        Nt(H, 17, () => x(c)?.rangeBands ?? [], cr, (G, re) => {
          var ie = /* @__PURE__ */ K(() => sD(x(re), 2));
          let se = () => x(ie)[0], ne = () => x(ie)[1];
          var ce = C1e();
          Ae(
            (Ce, Pe) => {
              te(ce, "x1", x(q)), te(ce, "y1", Ce), te(ce, "x2", x(q)), te(ce, "y2", Pe), te(ce, "stroke", x(p).gridColor), te(ce, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
            },
            [() => Math.min(se(), ne()), () => Math.max(se(), ne())]
          ), X(G, ce);
        }), X(B, U);
      });
      var I = ae(N);
      Nt(I, 17, () => x(h), cr, (B, $) => {
        vO(B, {
          get label() {
            return x($);
          },
          dimension: "x",
          get proxy() {
            return x(g);
          },
          get color() {
            return x(p).labelColor;
          }
        });
      }), J(z), X(M, z);
    };
    Oe(S, (M) => {
      x(o) && x(u) && n() && M(_);
    });
  }
  var D = ae(S);
  {
    var A = (M) => {
      var z = E1e(), R = Y(z);
      Nt(R, 17, () => x(s).ticks, cr, (B, $) => {
        const q = /* @__PURE__ */ K(() => x(c).apply(x($).value));
        var U = S1e();
        te(U, "x2", 0), Ae(() => {
          te(U, "x1", -(x($).level == 0 ? 3 : 0)), te(U, "y1", x(q)), te(U, "y2", x(q)), te(U, "stroke", x(p).gridColor), te(U, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
        }), X(B, U);
      });
      var N = ae(R);
      Nt(N, 17, () => x(s).gridLines, cr, (B, $) => {
        const q = /* @__PURE__ */ K(() => x(c).apply(x($).value));
        var U = kr(), H = Ve(U);
        Nt(H, 17, () => x(u)?.rangeBands ?? [], cr, (G, re) => {
          var ie = /* @__PURE__ */ K(() => sD(x(re), 2));
          let se = () => x(ie)[0], ne = () => x(ie)[1];
          var ce = A1e();
          Ae(() => {
            te(ce, "x1", se()), te(ce, "y1", x(q)), te(ce, "x2", ne()), te(ce, "y2", x(q)), te(ce, "stroke", x(p).gridColor), te(ce, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
          }), X(G, ce);
        }), X(B, U);
      });
      var I = ae(N);
      Nt(I, 17, () => x(d), cr, (B, $) => {
        vO(B, {
          get label() {
            return x($);
          },
          dimension: "y",
          get proxy() {
            return x(g);
          },
          get color() {
            return x(p).labelColor;
          }
        });
      }), J(z), X(M, z);
    };
    Oe(D, (M) => {
      x(s) && x(c) && i() && M(A);
    });
  }
  var O = ae(D);
  Xl(O, () => e.children ?? zt, () => x(g)), J(k), J(b), J(v), Ae(() => {
    y = ft(v, "", y, {
      width: `${e.width ?? ""}py`,
      height: `${e.height ?? ""}px`,
      position: "relative",
      "user-select": "none",
      "-webkit-user-select": "none",
      cursor: "default"
    }), te(b, "width", e.width + r * 2), te(b, "height", e.height + r * 2), te(k, "transform", `translate(${r + x(l).x},${r + x(l).y})`);
  }), X(t, v), it();
}
var O1e = /* @__PURE__ */ Dt('<rect role="none"></rect><rect role="none"></rect>', 1), F1e = /* @__PURE__ */ Dt('<rect role="none"></rect><rect role="none"></rect>', 1), T1e = /* @__PURE__ */ Dt('<rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect>', 1), M1e = /* @__PURE__ */ Dt('<rect></rect><rect role="none"></rect><!><!><!>', 1), P1e = /* @__PURE__ */ Dt('<g><rect stroke="none" fill="none" role="none"></rect><!></g>');
function Ox(t, e) {
  nt(e, !0);
  const r = 8;
  let n = /* @__PURE__ */ K(() => bc[e.colorScheme ?? "light"]), i, o = /* @__PURE__ */ K(() => e.proxy.xScale != null && e.value?.x != null ? e.proxy.xScale.applyBand(e.value.x) : [0, e.proxy.plotWidth]), s = /* @__PURE__ */ K(() => e.proxy.yScale != null && e.value?.y != null ? e.proxy.yScale.applyBand(e.value.y) : [0, e.proxy.plotHeight]);
  function a(y) {
    return y instanceof Array && y.length == 2 && typeof y[0] == "number" && typeof y[1] == "number";
  }
  function l(y, b, k) {
    let C = y.invert(b, k);
    if (y.domain.length == 2 && typeof y.domain[0] == "number" && typeof C == "number") {
      let [S, _] = y.domain;
      return Math.max(Math.min(S, _), Math.min(Math.max(S, _), C));
    }
    return C;
  }
  function u(y, b) {
    return (b == "x" || b == "xy") && y.x == null ? !1 : !((b == "y" || b == "xy") && y.y == null);
  }
  function c() {
    return (y) => {
      let b = i.getBoundingClientRect().left, k = i.getBoundingClientRect().top, C = y.clientX - b, S = y.clientY - k, _ = e.proxy.xScale ? l(e.proxy.xScale, C) : null, D = e.proxy.yScale ? l(e.proxy.yScale, S) : null;
      if (_ == null && (e.mode == "x" || e.mode == "xy") || D == null && (e.mode == "y" || e.mode == "xy"))
        return;
      let A = (M, z) => typeof M == "number" && typeof z == "number" ? M != z ? [Math.min(M, z), Math.max(M, z)] : null : z, O = (M) => {
        let z = M.clientX - b, R = M.clientY - k, N = e.proxy.xScale ? l(e.proxy.xScale, z, typeof _ == "number" ? "number" : void 0) : null, I = e.proxy.yScale ? l(e.proxy.yScale, R, typeof D == "number" ? "number" : void 0) : null, B = {};
        return (e.mode == "x" || e.mode == "xy") && (B.x = A(_, N)), (e.mode == "y" || e.mode == "xy") && (B.y = A(D, I)), u(B, e.mode) ? B : null;
      };
      return {
        move: (M) => {
          e.onChange(O(M));
        },
        up: (M) => {
          e.onChange(O(M));
        }
      };
    };
  }
  function h(y) {
    return (b) => {
      if (e.value == null)
        return;
      let k = { ...e.value }, { xScale: C, yScale: S } = e.proxy, _ = a(k.x), D = a(k.y), A = [
        ...C && k.x ? C.applyBand(k.x) : [0, 0],
        ...S && k.y ? S.applyBand(k.y) : [0, 0]
      ];
      if (!_) {
        let M = Math.max(y[0], y[1]);
        y = [M, M, y[2], y[3]];
      }
      if (!D) {
        let M = Math.max(y[2], y[3]);
        y = [y[0], y[1], M, M];
      }
      let O = (M) => {
        let z = M.pageX - b.pageX, R = M.pageY - b.pageY, N = [z, z, R, R].map((B, $) => A[$] + B * y[$]), I = { ...k };
        if (C && (e.mode == "x" || e.mode == "xy"))
          if (_) {
            let B = l(C, N[0], "number"), $ = l(C, N[1], "number");
            I.x = B == $ ? null : B < $ ? [B, $] : [$, B];
          } else
            I.x = l(C, (N[0] + N[1]) / 2), typeof I.x != "string" && (I.x = null);
        if (S != null && (e.mode == "y" || e.mode == "xy"))
          if (D) {
            let B = l(S, N[2], "number"), $ = l(S, N[3], "number");
            I.y = B == $ ? null : B < $ ? [B, $] : [$, B];
          } else
            I.y = l(S, (N[2] + N[3]) / 2), typeof I.y != "string" && (I.y = null);
        return u(I, e.mode) || (I = null), I;
      };
      return {
        move: (M) => {
          e.onChange(O(M));
        },
        up: (M) => {
          let z = O(M);
          z && !_ && !D && z.x == k.x && z.y == k.y && (z = null), e.onChange(z);
        }
      };
    };
  }
  var d = P1e(), p = Y(d);
  te(p, "x", 0), te(p, "y", 0), ft(p, "", {}, {
    "pointer-events": "fill",
    "user-select": "none",
    cursor: "crosshair"
  }), Qs(p, (y) => i = y, () => i), To(p, (y, b) => gn?.(y, b), () => ({
    click: () => {
      e.onChange(null);
    },
    drag: c()
  }));
  var g = ae(p);
  {
    var v = (y) => {
      var b = M1e(), k = Ve(b);
      let C;
      var S = ae(k);
      let _;
      To(S, (N, I) => gn?.(N, I), () => ({ drag: h([1, 1, 1, 1]) }));
      var D = ae(S);
      {
        var A = (N) => {
          var I = O1e(), B = Ve(I);
          te(B, "width", r), ft(B, "", {}, {
            cursor: "ew-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To(B, (q, U) => gn?.(q, U), () => ({ drag: h([1, 0, 0, 0]) }));
          var $ = ae(B);
          te($, "width", r), ft($, "", {}, {
            cursor: "ew-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To($, (q, U) => gn?.(q, U), () => ({ drag: h([0, 1, 0, 0]) })), Ae(
            (q, U, H, G) => {
              te(B, "x", x(o)[0] - r / 2), te(B, "y", q), te(B, "height", U), te($, "x", x(o)[1] - r / 2), te($, "y", H), te($, "height", G);
            },
            [
              () => Math.min(x(s)[0], x(s)[1]),
              () => Math.abs(x(s)[0] - x(s)[1]),
              () => Math.min(x(s)[0], x(s)[1]),
              () => Math.abs(x(s)[0] - x(s)[1])
            ]
          ), X(N, I);
        };
        Oe(D, (N) => {
          (e.mode == "x" || e.mode == "xy") && a(e.value.x) && N(A);
        });
      }
      var O = ae(D);
      {
        var M = (N) => {
          var I = F1e(), B = Ve(I);
          te(B, "height", r), ft(B, "", {}, {
            cursor: "ns-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To(B, (q, U) => gn?.(q, U), () => ({ drag: h([0, 0, 1, 0]) }));
          var $ = ae(B);
          te($, "height", r), ft($, "", {}, {
            cursor: "ns-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To($, (q, U) => gn?.(q, U), () => ({ drag: h([0, 0, 0, 1]) })), Ae(
            (q, U, H, G) => {
              te(B, "x", q), te(B, "width", U), te(B, "y", x(s)[0] - r / 2), te($, "x", H), te($, "width", G), te($, "y", x(s)[1] - r / 2);
            },
            [
              () => Math.min(x(o)[0], x(o)[1]),
              () => Math.abs(x(o)[0] - x(o)[1]),
              () => Math.min(x(o)[0], x(o)[1]),
              () => Math.abs(x(o)[0] - x(o)[1])
            ]
          ), X(N, I);
        };
        Oe(O, (N) => {
          (e.mode == "y" || e.mode == "xy") && a(e.value.y) && N(M);
        });
      }
      var z = ae(O);
      {
        var R = (N) => {
          var I = T1e(), B = Ve(I);
          te(B, "width", r), te(B, "height", r), ft(B, "", {}, {
            cursor: "nesw-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To(B, (H, G) => gn?.(H, G), () => ({ drag: h([1, 0, 1, 0]) }));
          var $ = ae(B);
          te($, "width", r), te($, "height", r), ft($, "", {}, {
            cursor: "nwse-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To($, (H, G) => gn?.(H, G), () => ({ drag: h([1, 0, 0, 1]) }));
          var q = ae($);
          te(q, "width", r), te(q, "height", r), ft(q, "", {}, {
            cursor: "nwse-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To(q, (H, G) => gn?.(H, G), () => ({ drag: h([0, 1, 1, 0]) }));
          var U = ae(q);
          te(U, "width", r), te(U, "height", r), ft(U, "", {}, {
            cursor: "nesw-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), To(U, (H, G) => gn?.(H, G), () => ({ drag: h([0, 1, 0, 1]) })), Ae(() => {
            te(B, "x", x(o)[0] - r / 2), te(B, "y", x(s)[0] - r / 2), te($, "x", x(o)[0] - r / 2), te($, "y", x(s)[1] - r / 2), te(q, "x", x(o)[1] - r / 2), te(q, "y", x(s)[0] - r / 2), te(U, "x", x(o)[1] - r / 2), te(U, "y", x(s)[1] - r / 2);
          }), X(N, I);
        };
        Oe(z, (N) => {
          e.mode == "xy" && a(e.value.x) && a(e.value.y) && N(R);
        });
      }
      Ae(
        (N, I, B, $, q, U, H, G) => {
          te(k, "x", N), te(k, "width", I), te(k, "y", B), te(k, "height", $), C = ft(k, "", C, {
            stroke: x(n).brushBorderBack,
            fill: "none",
            "stroke-width": 2
          }), te(S, "x", q), te(S, "width", U), te(S, "y", H), te(S, "height", G), _ = ft(S, "", _, {
            stroke: x(n).brushBorder,
            fill: x(n).brushFill,
            cursor: "move"
          });
        },
        [
          () => Math.min(x(o)[0], x(o)[1]),
          () => Math.abs(x(o)[0] - x(o)[1]),
          () => Math.min(x(s)[0], x(s)[1]),
          () => Math.abs(x(s)[0] - x(s)[1]),
          () => Math.min(x(o)[0], x(o)[1]),
          () => Math.abs(x(o)[0] - x(o)[1]),
          () => Math.min(x(s)[0], x(s)[1]),
          () => Math.abs(x(s)[0] - x(s)[1])
        ]
      ), X(y, b);
    };
    Oe(g, (y) => {
      x(o) && x(s) && e.value && y(v);
    });
  }
  J(d), Ae(() => {
    te(p, "width", e.proxy.plotWidth), te(p, "height", e.proxy.plotHeight);
  }), X(t, d), it();
}
const R1e = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let EL = (t = 21) => {
  let e = "", r = crypto.getRandomValues(new Uint8Array(t |= 0));
  for (; t--; )
    e += R1e[r[t] & 63];
  return e;
};
var N1e = /* @__PURE__ */ me("<option> </option>"), $1e = /* @__PURE__ */ me('<select class="form-select text-center pl-[4px] pr-[16px] py-0 my-0 border-0 rounded text-sm! text-slate-500 bg-slate-100 dark:text-slate-400 dark:bg-slate-900"></select>');
function Fx(t, e) {
  nt(e, !0);
  let r;
  const n = EL(), i = n + "_null", o = n + "_undefined", s = (d) => d === null ? i : d === void 0 ? o : d.toString(), a = (d) => d === i ? null : d === o ? void 0 : d, l = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 20">
    <path d="M 2,8 L 5,12 L 8,8" style="stroke:${$s.gray[500]};stroke-opacity:0.7;stroke-width:1.5;fill:none;stroke-linecap:round;stroke-linejoin:round" />
  </svg>`;
  var u = $1e();
  u.__change = () => {
    e.onChange(a(r.value));
  };
  let c;
  Nt(u, 21, () => e.options, cr, (d, p) => {
    var g = N1e(), v = Y(g, !0);
    J(g);
    var y = {};
    Ae(
      (b) => {
        ut(v, x(p).label), y !== (y = b) && (g.value = (g.__value = b) ?? "");
      },
      [() => s(x(p).value)]
    ), X(d, g);
  }), J(u), Qs(u, (d) => r = d, () => r);
  var h;
  i1(u), Ae(
    (d, p) => {
      c = ft(u, "", c, d), h !== (h = p) && (u.value = (u.__value = p) ?? "", yd(u, p));
    },
    [
      () => ({
        "background-image": `url(data:image/svg+xml;base64,${btoa(l) ?? ""})`,
        "background-position": "right center"
      }),
      () => s(e.value)
    ]
  ), X(t, u), it();
}
nn(["change"]);
var I1e = /* @__PURE__ */ me('<span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm"> </span> <!></span>');
function Eh(t, e) {
  nt(e, !0);
  let r = ct(e, "value", 15);
  const n = ["linear", "log", "symlog"];
  var i = kr(), o = Ve(i);
  {
    var s = (a) => {
      var l = I1e(), u = Y(l), c = Y(u);
      J(u);
      var h = ae(u, 2);
      {
        let d = /* @__PURE__ */ K(() => n.map((p) => ({ value: p, label: p })));
        Fx(h, {
          get options() {
            return x(d);
          },
          get value() {
            return r();
          },
          onChange: (p) => r(p)
        });
      }
      J(l), Ae(() => ut(c, `${e.label ?? ""}:`)), X(a, l);
    };
    Oe(o, (a) => {
      r() != null && r() != "band" && a(s);
    });
  }
  X(t, i), it();
}
function DL(t) {
  return t == null ? null : t instanceof Array ? t.length == 0 ? null : T.and(t).toString().trim() : typeof t == "string" ? t.trim() : typeof t == "boolean" ? T.literal(t).toString() : t.toString().trim();
}
async function OL(t, e) {
  return Array.from(await t.query(`DESCRIBE ${e}`)).map((r) => ({
    name: r.column_name,
    type: r.column_type,
    jsType: XS(r.column_type)
  }));
}
async function FL(t, e, r) {
  return (await t.query(`SELECT COUNT(DISTINCT ${T.column(r)}) AS count FROM ${e}`)).get(0).count;
}
function XS(t) {
  return B1e.has(t) ? "number" : L1e.has(t) ? "string" : t.match(/^(VARCHAR|TEXT)\[\d*\]$/) ? "string[]" : null;
}
const B1e = /* @__PURE__ */ new Set([
  "REAL",
  "FLOAT4",
  "FLOAT8",
  "FLOAT",
  "DOUBLE",
  "INT",
  "TINYINT",
  "INT1",
  "SMALLINT",
  "INT2",
  "SHORT",
  "INTEGER",
  "INT4",
  "INT",
  "SIGNED",
  "INT8",
  "LONG",
  "BIGINT",
  "UTINYINT",
  "USMALLINT",
  "UINTEGER",
  "UBIGINT",
  "UHUGEINT"
]), L1e = /* @__PURE__ */ new Set(["BOOLEAN", "DATE", "VARCHAR", "CHAR", "BPCHAR", "TEXT", "STRING"]), om = {
  linear: { type: "linear", expr: (t) => t, forward: (t) => t, reverse: (t) => t },
  log: {
    type: "log",
    expr: (t) => T.cond(T.gt(t, 0), T.log(t), T.literal("nan")),
    forward: (t) => Math.log10(t),
    reverse: (t) => Math.pow(10, t)
  },
  symlog: {
    type: "symlog",
    expr: (t, e) => T.mul(T.sign(t), T.ln(T.add(1, T.abs(T.div(t, e))))),
    forward: (t, e) => Math.sign(t) * Math.log1p(Math.abs(t) / e),
    reverse: (t, e) => Math.sign(t) * Math.expm1(Math.abs(t)) * e
  }
};
function z1e(t, e) {
  let r = t, n = 1 / 0;
  for (let i of e) {
    let o = Math.abs(t - i);
    o < n && (n = o, r = i);
  }
  return r;
}
function TL(t, e = {}) {
  let { min: r, max: n, median: i, count: o } = t, s = e.scale;
  s == "band" && (s = null), s == null && (s = "linear", o >= 100 && r >= 0 && i < n * 0.05 && (s = r > 0 ? "log" : "symlog")), r <= 0 && s == "log" && (n <= 0 ? (r = 1, n = 10) : r = Math.min(t.minPositive, n / 10));
  let a = e.desiredCount ?? 5;
  switch (s) {
    case "linear": {
      let l = cp().domain([r, n]).nice(a), u = l.ticks(a);
      return {
        scale: { ...om.linear, domain: l.domain() },
        binStart: l.domain()[0],
        binSize: u[1] - u[0]
      };
    }
    case "log": {
      let l = Rg().domain([r, n]).nice(), u = Math.log10(l.domain()[0]), c = (Math.log10(l.domain()[1]) - u) / a;
      return c = z1e(c, [0.05, 0.1, 0.2, 0.5, 1, 1.5, 2]), {
        scale: { ...om.log, domain: l.domain() },
        binStart: u,
        binSize: c
      };
    }
    case "symlog": {
      let l = Math.max(Math.abs(r), Math.abs(n)), u = l >= 100 ? 1 : l > 0 ? l / 1e5 : 1, c = om.symlog.forward(r, u), h = om.symlog.forward(n, u);
      return {
        scale: { ...om.symlog, domain: [r, n], constant: u },
        binStart: c,
        binSize: (h - c) / a
      };
    }
    default:
      throw new Error("invalid scale type");
  }
}
async function Zl(t, e, r) {
  let n = (s) => t.query(s), i = (await n(T.Query.describe(T.Query.from(e).select({ field: T.column(r, e) })))).get(0)?.column_type;
  if (i == null)
    return null;
  let o = XS(i);
  if (o == "number") {
    let s = T.cast(T.column(r, e), "DOUBLE"), a = await n(
      T.Query.from(e).select({
        count: T.count(),
        min: T.min(s),
        minPositive: T.min(T.cond(T.gt(s, 0), s, T.literal(null))),
        max: T.max(s),
        mean: T.avg(s),
        median: T.median(s)
      }).where(T.isFinite(s))
    ), l = await n(
      T.Query.from(e).select({
        countNonFinite: T.count()
      }).where(T.or(T.not(T.isFinite(s)), T.isNull(s)))
    );
    return {
      table: e,
      field: r,
      quantitative: { ...a.get(0), ...l.get(0) }
    };
  } else if (o == "string") {
    let s = T.cast(T.column(r, e), "TEXT"), a = Array.from(
      await n(
        T.Query.from(e).select({ value: s, count: T.count() }).where(T.isNotNull(s)).groupby(s).orderby(T.desc(T.count())).limit(1e3)
      )
    ), l = (await n(T.Query.from(e).select({ count: T.count() }).where(T.isNull(s)))).get(0).count, { otherCount: u, numOtherLevels: c } = (await n(
      T.Query.from(e).select({ otherCount: T.count(), numOtherLevels: T.sql`COUNT(DISTINCT(${s}))` }).where(
        T.isNotNull(s),
        T.not(
          T.isIn(
            s,
            a.map((h) => T.literal(h.value))
          )
        )
      )
    )).get(0);
    return {
      table: e,
      field: r,
      nominal: {
        levels: a,
        numOtherLevels: c,
        otherCount: u,
        nullCount: l
      }
    };
  }
  return null;
}
function yp(...t) {
  let e = {}, r = {}, n = {}, i = {}, o = {};
  for (let l of t) {
    if (l.stats.quantitative) {
      let u = TL(l.stats.quantitative, {
        scale: l.scaleType,
        desiredCount: l.binCount ?? 20
      }), c = T.cast(T.column(l.stats.field), "DOUBLE"), h = u.scale.expr(c, u.scale.constant ?? 0);
      e[l.key] = u.scale.type == "log" ? T.cond(
        T.and(T.isFinite(c), T.gt(c, T.literal(0))),
        T.floor(T.mul(T.sub(h, u.binStart), 1 / u.binSize)),
        T.literal(null)
      ) : T.cond(
        T.isFinite(c),
        T.floor(T.mul(T.sub(h, u.binStart), 1 / u.binSize)),
        T.literal(null)
      );
      let d = (C) => Math.floor((u.scale.forward(C, u.scale.constant ?? 0) - u.binStart) / u.binSize), p = (C) => u.scale.reverse(C * u.binSize + u.binStart, u.scale.constant ?? 0);
      n[l.key] = (C) => C == null ? "n/a" : [p(C), p(C + 1)];
      let g = d(
        u.scale.type == "log" ? l.stats.quantitative.minPositive : l.stats.quantitative.min
      ), v = d(l.stats.quantitative.max), y = [p(g), p(v + 1)], b = l.stats.quantitative.countNonFinite > 0;
      u.scale.type == "log" && l.stats.quantitative.min < 0 && (b = !0), r[l.key] = {
        type: u.scale.type,
        constant: u.scale.constant,
        domain: y,
        specialValues: b ? ["n/a"] : []
      };
      let k = (C) => {
        if (typeof C == "string") {
          if (C == "n/a")
            return T.or(T.not(T.isFinite(c)), T.isNull(c));
        } else if (C instanceof Array)
          if (C.length == 2 && typeof C[0] == "number") {
            let [S, _] = C;
            if (typeof S == "number" && typeof _ == "number")
              return T.isBetween(c, [Math.min(S, _), Math.max(S, _)]);
          } else
            return T.or(...C.map(k));
        return T.literal(!1);
      };
      i[l.key] = k, o[l.key] = (C, S) => {
        let _ = typeof C == "string" ? [1, 0] : [0, C[0]], D = typeof S == "string" ? [1, 0] : [0, S[0]];
        return _[0] != D[0] ? _[0] - D[0] : _[1] - D[1];
      };
    }
    if (l.stats.nominal) {
      let u = l.binCount ?? 15, { levels: c, nullCount: h, otherCount: d, numOtherLevels: p } = l.stats.nominal;
      c.length > u && (p += c.length - u, d = c.slice(u).reduce((S, _) => S + _.count, 0), c = c.slice(0, u));
      let g = `(${p.toLocaleString()} others)`, v = "(null)", y = T.cast(T.column(l.stats.field), "TEXT");
      e[l.key] = T.cond(
        T.isIn(
          y,
          c.map((S) => T.literal(S.value))
        ),
        y,
        T.cond(T.isNull(y), T.literal(v), T.literal(g))
      );
      let b = [...d > 0 ? [g] : [], ...h > 0 ? [v] : []];
      r[l.key] = {
        type: "band",
        domain: c.map((S) => S.value),
        specialValues: b
      }, n[l.key] = (S) => S;
      let k = (S) => S == v ? T.isNull(y) : S == g ? T.and(
        T.not(
          T.isIn(
            y,
            c.map((_) => T.literal(_.value))
          )
        ),
        T.isNotNull(y)
      ) : T.isNotDistinct(y, T.literal(S));
      i[l.key] = (S) => S instanceof Array ? T.or(...S.map((_) => k(_))) : typeof S == "string" ? k(S) : null;
      let C = c.map((S) => S.value);
      o[l.key] = (S, _) => {
        if (typeof S == "string" && typeof _ == "string") {
          let D = C.indexOf(S);
          D < 0 && (D = C.length + b.indexOf(S));
          let A = C.indexOf(_);
          return A < 0 && (A = C.length + b.indexOf(_)), D - A;
        }
        return 0;
      };
    }
  }
  function s(l) {
    let u = { ...l };
    for (let c of t)
      u[c.key] = n[c.key](u[c.key]);
    return u;
  }
  function a(l) {
    let u = [];
    for (let c of t) {
      let h = l[c.key], d = h != null ? i[c.key](h) : null;
      d && u.push(d);
    }
    return {
      value: { ...l },
      predicate: u.length > 0 ? T.and(...u) : null
    };
  }
  return { select: e, collect: s, scales: r, clause: a, order: o };
}
var j1e = /* @__PURE__ */ Dt('<line></line><line></line><line></line><rect></rect><line stroke-linecap="butt"></line>', 1), q1e = /* @__PURE__ */ Dt("<!><!>", 1), U1e = /* @__PURE__ */ me('<div class="text-slate-400 mb-1 select-none"> </div> <!> <div class="text-slate-400 mb-1 select-none text-right"> </div> <div class="flex flex-col items-end gap-1"><div class="flex flex gap-2 mt-2"><!> <!></div></div>', 1);
function H1e(t, e) {
  nt(e, !0);
  const r = () => mi(o, "$colorScheme", n), [n, i] = Xo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.state.brush), a = /* @__PURE__ */ K(() => bc[r()]), l = /* @__PURE__ */ De(null), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(null);
  function h(d, p, g, v, y) {
    let b = /* @__PURE__ */ De(null);
    Promise.all([
      Zl(d, p, g),
      Zl(d, p, v)
    ]).then(([_, D]) => {
      ue(b, _ != null && D != null ? { x: _, y: D } : null);
    });
    let k = /* @__PURE__ */ K(() => x(b) ? yp({
      key: "x",
      stats: x(b).x,
      scaleType: e.spec.xScaleType,
      binCount: e.spec.xBinCount
    }) : null), C = /* @__PURE__ */ K(() => x(b)?.y.quantitative ? b1e(x(b).y.quantitative, e.spec.yScaleType) : null);
    mt(() => {
      x(u) == null && x(k)?.scales.x?.type != null && ue(u, x(k)?.scales.x?.type), x(c) == null && x(C)?.type != null && ue(c, x(C)?.type);
    });
    function S(_, D, A) {
      return il({
        coordinator: d,
        selection: D ?? void 0,
        query: (O) => {
          let M = T.column(v, p);
          return T.Query.from(p).select({
            ..._.select,
            min: T.min(M),
            max: T.max(M),
            p50: T.median(M),
            p25: T.quantile(M, 0.25),
            p75: T.quantile(M, 0.75)
          }).where(O, T.isFinite(M)).groupby(_.select.x);
        },
        queryResult: (O) => {
          A(Array.from(O).map(_.collect));
        }
      });
    }
    mt(() => {
      if (x(k) == null || x(C) == null)
        return;
      let _ = x(k), D = /* @__PURE__ */ De(fs([])), A = S(_, y, (O) => {
        ue(D, O, !0);
      });
      return A.reset = () => {
        e.onStateChange({ brush: null });
      }, mt(() => {
        ue(l, {
          xScale: _.scales.x,
          yScale: x(C),
          items: x(D)
        });
      }), mt(() => {
        let O = {
          source: A,
          clients: /* @__PURE__ */ new Set([A]),
          ...x(s) != null ? _.clause(x(s)) : { value: null, predicate: null }
        };
        y.update(O), y.activate(O);
      }), () => {
        A.destroy(), y.update({
          source: A,
          clients: /* @__PURE__ */ new Set([A]),
          value: null,
          predicate: null
        });
      };
    });
  }
  mt(() => {
    h(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y, e.context.filter);
  }), vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col",
    children: (d, p) => {
      var g = U1e(), v = Ve(g), y = Y(v);
      J(v);
      var b = ae(v, 2);
      {
        const N = (B, $ = zt, q = zt) => {
          var U = kr(), H = Ve(U);
          {
            var G = (re) => {
              Ld(re, {
                get width() {
                  return $();
                },
                get height() {
                  return q();
                },
                get xScale() {
                  return x(l).xScale;
                },
                get yScale() {
                  return x(l).yScale;
                },
                get colorScheme() {
                  return r();
                },
                children: (ie, se = zt) => {
                  const ne = /* @__PURE__ */ K(() => se().xScale), ce = /* @__PURE__ */ K(() => se().yScale), Ce = /* @__PURE__ */ K(() => r() == "dark" ? "#bbbbbb" : "black");
                  var Pe = q1e(), Me = Ve(Pe);
                  Nt(Me, 17, () => x(l)?.items ?? [], cr, (he, ke) => {
                    const ve = /* @__PURE__ */ K(() => {
                      const [rr, Fe] = x(ne).applyBand(x(ke).x);
                      return { x0: rr, x1: Fe };
                    }), We = /* @__PURE__ */ K(() => x(ce).apply(x(ke).p50)), Qe = /* @__PURE__ */ K(() => {
                      const [rr, Fe] = x(ce).applyBand([x(ke).min, x(ke).max]);
                      return { ey0: rr, ey1: Fe };
                    }), ot = /* @__PURE__ */ K(() => {
                      const [rr, Fe] = x(ce).applyBand([x(ke).p25, x(ke).p75]);
                      return { by0: rr, by1: Fe };
                    }), Ye = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ve).x1 - x(ve).x0) * 0.1, 1)), Ht = /* @__PURE__ */ K(() => Math.abs(x(ve).x1 - x(ve).x0) / 3);
                    var St = j1e(), Gt = Ve(St), $t = ae(Gt), Ge = ae($t), Ze = ae(Ge), It = ae(Ze);
                    Ae(
                      (rr, Fe, $e, lt, kt, pr) => {
                        te(Gt, "y1", x(Qe).ey0), te(Gt, "y2", x(Qe).ey1), te(Gt, "x1", (x(ve).x0 + x(ve).x1) / 2), te(Gt, "x2", (x(ve).x0 + x(ve).x1) / 2), te(Gt, "stroke", x(Ce)), te($t, "y1", x(Qe).ey0), te($t, "y2", x(Qe).ey0), te($t, "x1", (x(ve).x0 + x(ve).x1) / 2 - x(Ht) / 2), te($t, "x2", (x(ve).x0 + x(ve).x1) / 2 + x(Ht) / 2), te($t, "stroke", x(Ce)), te(Ge, "y1", x(Qe).ey1), te(Ge, "y2", x(Qe).ey1), te(Ge, "x1", (x(ve).x0 + x(ve).x1) / 2 - x(Ht) / 2), te(Ge, "x2", (x(ve).x0 + x(ve).x1) / 2 + x(Ht) / 2), te(Ge, "stroke", x(Ce)), te(Ze, "x", rr), te(Ze, "height", Fe), te(Ze, "y", $e), te(Ze, "width", lt), te(Ze, "fill", x(a).markColor), te(It, "y1", x(We)), te(It, "y2", x(We)), te(It, "x1", kt), te(It, "x2", pr), te(It, "stroke", x(Ce));
                      },
                      [
                        () => Math.min(x(ve).x0, x(ve).x1) + x(Ye) / 2,
                        () => Math.abs(x(ot).by0 - x(ot).by1),
                        () => Math.min(x(ot).by0, x(ot).by1),
                        () => Math.abs(x(ve).x0 - x(ve).x1) - x(Ye),
                        () => Math.min(x(ve).x0, x(ve).x1) + x(Ye) / 2,
                        () => Math.max(x(ve).x0, x(ve).x1) - x(Ye) / 2
                      ]
                    ), X(he, St);
                  });
                  var _e = ae(Me);
                  {
                    let he = /* @__PURE__ */ K(() => x(s) ?? null);
                    Ox(_e, {
                      get proxy() {
                        return se();
                      },
                      mode: "x",
                      get value() {
                        return x(he);
                      },
                      get colorScheme() {
                        return r();
                      },
                      onChange: (ke) => {
                        e.onStateChange({ brush: ke != null && ke.x != null ? { x: ke.x } : null });
                      }
                    });
                  }
                  X(ie, Pe);
                },
                $$slots: { default: !0 }
              });
            };
            Oe(H, (re) => {
              x(l) != null && re(G);
            });
          }
          X(B, U);
        };
        let I = /* @__PURE__ */ K(() => e.height != null);
        p0(b, {
          get flexHeight() {
            return x(I);
          },
          children: N,
          $$slots: { default: !0 }
        });
      }
      var k = ae(b, 2), C = Y(k);
      J(k);
      var S = ae(k, 2), _ = Y(S), D = Y(_), A = () => e.spec.xScaleType ?? x(u) ?? "linear", O = (N) => {
        e.onSpecChange({ xScaleType: N });
      };
      Eh(D, {
        label: "X",
        get value() {
          return A();
        },
        set value(N) {
          O(N);
        }
      });
      var M = ae(D, 2), z = () => e.spec.yScaleType ?? x(c) ?? "linear", R = (N) => {
        e.onSpecChange({ yScaleType: N });
      };
      Eh(M, {
        label: "Y",
        get value() {
          return z();
        },
        set value(N) {
          R(N);
        }
      }), J(_), J(S), Ae(() => {
        ut(y, `â†‘ ${e.spec.data.y ?? ""}`), ut(C, `${e.spec.data.x ?? ""} â†’`);
      }), X(d, g);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var V1e = /* @__PURE__ */ me('<hr class="mt-1 mb-1 border-slate-300 dark:border-slate-500 border-dashed"/>'), W1e = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>'), G1e = /* @__PURE__ */ me('<!> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), K1e = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>'), Q1e = /* @__PURE__ */ me('<!> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), X1e = /* @__PURE__ */ me('<!> <button class="text-left items-center flex py-0.5"><div class="w-40 flex-none overflow-hidden whitespace-nowrap text-ellipsis pr-1"><span> </span></div> <div class="flex-1 h-4 relative"><!></div> <div class="flex-none"><span><!></span></div></button>', 1), J1e = /* @__PURE__ */ me('<button class="py-0.5 text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden"><!></button>'), Y1e = /* @__PURE__ */ me('<!> <div class="flex"><div class="flex-1 pl-40 mr-2 overflow-hidden"><!></div> <div class="flex"><!></div></div>', 1), Z1e = /* @__PURE__ */ me('<div class="flex flex-col text-sm w-full select-none"><!></div>');
function ebe(t, e) {
  nt(e, !0);
  const r = () => mi(l, "$colorScheme", n), [n, i] = Xo(), o = 10, s = 100;
  let { coordinator: a, colorScheme: l } = e.context, u = /* @__PURE__ */ K(() => e.state.selection), c = /* @__PURE__ */ K(() => e.spec.expanded), h = /* @__PURE__ */ K(() => e.spec.percentage), d = /* @__PURE__ */ De(null), p = /* @__PURE__ */ De(400), g = /* @__PURE__ */ K(() => x(d)?.items.reduce((O, M) => Math.max(O, x(h) ? M.selected : M.total), 0) ?? 0), v = /* @__PURE__ */ K(() => cp([0, Math.max(1, x(g))], [0, x(p) - 250])), y = /* @__PURE__ */ K(() => (O) => O != 0 ? Math.max(1, x(v)(O)) : 0), b = /* @__PURE__ */ K(() => bc[r()]);
  function k(O, M, z, R) {
    let N = /* @__PURE__ */ De(null);
    Zl(O, M, z).then(($) => {
      ue(N, $);
    });
    let I = /* @__PURE__ */ K(() => x(N) ? yp({
      key: "x",
      stats: x(N),
      binCount: x(c) ? s : o
    }) : null);
    function B($, q, U) {
      return il({
        coordinator: O,
        selection: q ?? void 0,
        query: (H) => T.Query.from(M).select({ ...$.select, count: T.count() }).where(H).groupby($.select.x),
        queryResult: (H) => {
          U(Array.from(H).map($.collect));
        }
      });
    }
    mt(() => {
      if (x(I) == null)
        return;
      let $ = x(I), q = /* @__PURE__ */ De([]), U = /* @__PURE__ */ De([]), H = B($, null, (ie) => {
        ue(q, ie);
      }), G = B($, R, (ie) => {
        ue(U, ie);
      }), re = {
        reset: () => {
          e.onStateChange({ selection: null });
        }
      };
      return mt(() => {
        if (x(q).length > 0) {
          let ie = (ce) => JSON.stringify(ce), se = new Map(x(q).map(({ x: ce, count: Ce }) => [ie(ce), Ce])), ne = new Map(x(U).map(({ x: ce, count: Ce }) => [ie(ce), Ce]));
          if (x(q).every((ce) => typeof ce.x == "string")) {
            let ce = $.scales.x.specialValues ?? [], Ce = ce.filter((he) => he != "(null)").length > 0, Pe = [...$.scales.x.domain, ...ce].map((he) => ({
              x: he,
              total: se.get(ie(he)) ?? 0,
              selected: ne.get(ie(he)) ?? 0
            })), Me = Pe.reduce((he, ke) => he + ke.total, 0), _e = Pe.reduce((he, ke) => he + ke.selected, 0);
            ue(d, {
              items: Pe,
              sumTotal: Me,
              sumSelected: _e,
              firstSpecialIndex: $.scales.x.domain.length,
              hasOther: Ce
            });
          } else {
            let ce = Array.from(se.keys()).map((_e) => JSON.parse(_e));
            ce = ce.sort((_e, he) => {
              let ke = typeof _e == "string" ? 1 / 0 : _e[0], ve = typeof he == "string" ? 1 / 0 : he[0];
              return ke - ve;
            });
            let Ce = ce.map((_e) => ({
              x: _e,
              total: se.get(ie(_e)) ?? 0,
              selected: ne.get(ie(_e)) ?? 0
            })), Pe = Ce.reduce((_e, he) => _e + he.total, 0), Me = Ce.reduce((_e, he) => _e + he.selected, 0);
            ue(d, {
              items: Ce,
              sumTotal: Pe,
              sumSelected: Me,
              firstSpecialIndex: ce.findIndex((_e) => typeof _e == "string"),
              hasOther: !1
            });
          }
        }
      }), mt(() => {
        let ie = {
          source: re,
          clients: /* @__PURE__ */ new Set([G]),
          ...x(u) != null ? $.clause({ x: x(u) }) : { value: null, predicate: null }
        };
        R.update(ie), R.activate(ie);
      }), () => {
        H.destroy(), G.destroy(), R.update({
          source: re,
          clients: /* @__PURE__ */ new Set([G]),
          value: null,
          predicate: null
        });
      };
    });
  }
  mt(() => {
    k(a, e.context.table, e.spec.data.field, e.context.filter);
  });
  const C = (O, M) => JSON.stringify(O) == JSON.stringify(M);
  function S(O, M) {
    if (x(u) == null || x(u).length == 0)
      e.onStateChange({ selection: [O] });
    else {
      let z = x(u).findIndex((R) => C(R, O)) >= 0;
      M ? z ? e.onStateChange({ selection: x(u).filter((R) => !C(R, O)) }) : e.onStateChange({ selection: [...x(u), O] }) : z ? e.onStateChange({ selection: null }) : e.onStateChange({ selection: [O] });
    }
  }
  const _ = ou(".6");
  function D(O) {
    return typeof O == "string" ? O : "[" + _(O[0]) + ", " + _(O[1]) + ")";
  }
  function A(O, M) {
    return M == 0 ? "-%" : (O / M * 100).toFixed(1) + "%";
  }
  vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (O, M) => {
      var z = Z1e(), R = Y(z);
      {
        var N = (I) => {
          var B = Y1e(), $ = Ve(B);
          Nt($, 17, () => x(d).items, cr, (se, ne, ce) => {
            const Ce = /* @__PURE__ */ K(() => x(u) == null || x(u).length == 0 || x(u).findIndex(($e) => C($e, x(ne).x)) >= 0), Pe = /* @__PURE__ */ K(() => !x(d).items.every(($e) => $e.total == $e.selected));
            var Me = X1e(), _e = Ve(Me);
            {
              var he = ($e) => {
                var lt = V1e();
                X($e, lt);
              };
              Oe(_e, ($e) => {
                ce == x(d).firstSpecialIndex && $e(he);
              });
            }
            var ke = ae(_e, 2);
            ke.__click = ($e) => S(x(ne).x, $e.shiftKey);
            var ve = Y(ke), We = Y(ve);
            let Qe;
            var ot = Y(We, !0);
            J(We), J(ve);
            var Ye = ae(ve, 2), Ht = Y(Ye);
            {
              var St = ($e) => {
                var lt = G1e(), kt = Ve(lt);
                {
                  var pr = (Je) => {
                    var mr = W1e();
                    let en;
                    Ae((xi) => en = ft(mr, "", en, xi), [
                      () => ({
                        background: x(b).markColorFade,
                        width: `${x(y)(x(ne).total) ?? ""}px`
                      })
                    ]), X(Je, mr);
                  };
                  Oe(kt, (Je) => {
                    x(h) || Je(pr);
                  });
                }
                var Zr = ae(kt, 2);
                let Kt;
                Ae((Je) => Kt = ft(Zr, "", Kt, Je), [
                  () => ({
                    background: x(b).markColor,
                    width: `${x(y)(x(ne).selected) ?? ""}px`
                  })
                ]), X($e, lt);
              }, Gt = ($e) => {
                var lt = Q1e(), kt = Ve(lt);
                {
                  var pr = (Je) => {
                    var mr = K1e();
                    let en;
                    Ae((xi) => en = ft(mr, "", en, xi), [
                      () => ({
                        background: x(b).markColorGrayFade,
                        width: `${x(y)(x(ne).total) ?? ""}px`
                      })
                    ]), X(Je, mr);
                  };
                  Oe(kt, (Je) => {
                    x(h) || Je(pr);
                  });
                }
                var Zr = ae(kt, 2);
                let Kt;
                Ae((Je) => Kt = ft(Zr, "", Kt, Je), [
                  () => ({
                    background: x(b).markColorGray,
                    width: `${x(y)(x(ne).selected) ?? ""}px`
                  })
                ]), X($e, lt);
              };
              Oe(Ht, ($e) => {
                x(Ce) ? $e(St) : $e(Gt, !1);
              });
            }
            J(Ye);
            var $t = ae(Ye, 2), Ge = Y($t);
            let Ze;
            var It = Y(Ge);
            {
              var rr = ($e) => {
                var lt = kr(), kt = Ve(lt);
                {
                  var pr = (Kt) => {
                    var Je = Ro();
                    Ae((mr) => ut(Je, mr), [
                      () => A(x(ne).selected, x(d).sumSelected)
                    ]), X(Kt, Je);
                  }, Zr = (Kt) => {
                    var Je = Ro();
                    Ae((mr) => ut(Je, mr), [
                      () => x(ne).selected.toLocaleString() + " / " + x(ne).total.toLocaleString()
                    ]), X(Kt, Je);
                  };
                  Oe(kt, (Kt) => {
                    x(h) ? Kt(pr) : Kt(Zr, !1);
                  });
                }
                X($e, lt);
              }, Fe = ($e) => {
                var lt = kr(), kt = Ve(lt);
                {
                  var pr = (Kt) => {
                    var Je = Ro();
                    Ae((mr) => ut(Je, mr), [
                      () => A(x(ne).total, x(d).sumTotal)
                    ]), X(Kt, Je);
                  }, Zr = (Kt) => {
                    var Je = Ro();
                    Ae((mr) => ut(Je, mr), [() => x(ne).total.toLocaleString()]), X(Kt, Je);
                  };
                  Oe(
                    kt,
                    (Kt) => {
                      x(h) ? Kt(pr) : Kt(Zr, !1);
                    },
                    !0
                  );
                }
                X($e, lt);
              };
              Oe(It, ($e) => {
                x(Pe) ? $e(rr) : $e(Fe, !1);
              });
            }
            J(Ge), J($t), J(ke), Ae(
              ($e, lt) => {
                te(ke, "title", x(ne).x), Qe = Yr(We, 1, "", null, Qe, {
                  "text-gray-400": !x(Ce),
                  "dark:text-gray-400": !x(Ce)
                }), ut(ot, $e), Ze = Yr(Ge, 1, "text-slate-400 dark:text-slate-500", null, Ze, {
                  "!text-gray-200": !x(Ce),
                  "dark:!text-gray-600": !x(Ce)
                }), te(Ge, "title", lt);
              },
              [
                () => D(x(ne).x),
                () => x(Pe) ? `${x(ne).selected.toLocaleString()} / ${x(ne).total.toLocaleString()} (${A(x(ne).selected, x(ne).total)})
${A(x(ne).selected, x(d).sumSelected)} of selection` : `${x(ne).total.toLocaleString()}
${A(x(ne).total, x(d).sumTotal)} of all rows`
              ]
            ), X(se, Me);
          });
          var q = ae($, 2), U = Y(q), H = Y(U);
          {
            var G = (se) => {
              var ne = J1e();
              ne.__click = () => {
                x(c) == !0 ? (e.onSpecChange({ expanded: !1 }), e.onStateChange({ selection: null })) : e.onSpecChange({ expanded: !0 });
              };
              var ce = Y(ne);
              {
                var Ce = (Me) => {
                  var _e = Ro();
                  _e.nodeValue = "â†‘ Show up to 10 values", X(Me, _e);
                }, Pe = (Me) => {
                  var _e = Ro();
                  _e.nodeValue = "â†“ Show up to 100 values", X(Me, _e);
                };
                Oe(ce, (Me) => {
                  x(c) ? Me(Ce) : Me(Pe, !1);
                });
              }
              J(ne), X(se, ne);
            };
            Oe(H, (se) => {
              (x(c) || x(d).hasOther) && se(G);
            });
          }
          J(U);
          var re = ae(U, 2), ie = Y(re);
          {
            let se = /* @__PURE__ */ K(() => x(h)?.toString() ?? "false");
            Fx(ie, {
              options: [
                { value: "true", label: "%" },
                { value: "false", label: "#/#" }
              ],
              get value() {
                return x(se);
              },
              onChange: (ne) => e.onSpecChange({ percentage: ne == "true" })
            });
          }
          J(re), J(q), X(I, B);
        };
        Oe(R, (I) => {
          x(d) && I(N);
        });
      }
      J(z), Ks(z, "clientWidth", (I) => ue(p, I)), X(O, z);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
nn(["click"]);
async function tbe(t, e, r, n) {
  let i = T.column(r, e), o = await t.query(T.Query.from(T.Query.from(e).select({ value: T.sql`UNNEST(${i})` })).select({ value: "value", count: T.count() }).groupby("value").orderby(T.desc("count")).limit(n + 1)), s = Array.from(o);
  return {
    values: s.slice(0, n),
    hasOther: s.length > n
  };
}
function rbe(t, e) {
  return T.or(...e.map((r) => T.sql`${T.literal(r)} IN ${T.column(t)}`));
}
var nbe = /* @__PURE__ */ me('<hr class="mt-1 mb-1 border-slate-300 dark:border-slate-500 border-dashed"/>'), ibe = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), obe = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), sbe = /* @__PURE__ */ me('<!> <button class="text-left items-center flex py-0.5"><div class="w-40 flex-none overflow-hidden whitespace-nowrap text-ellipsis pr-1"><span> </span></div> <div class="flex-1 h-4 relative"><!></div> <div class="flex-none"><span><!></span></div></button>', 1), abe = /* @__PURE__ */ me('<button class="py-0.5 text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden"><!></button>'), lbe = /* @__PURE__ */ me('<!> <div class="flex"><div class="flex-1 pl-40 mr-2 overflow-hidden"><!></div></div>', 1), ube = /* @__PURE__ */ me('<div class="flex flex-col text-sm w-full select-none"><!></div>');
function cbe(t, e) {
  nt(e, !0);
  const r = () => mi(a, "$colorScheme", n), [n, i] = Xo(), o = 10, s = 100;
  let a = e.context.colorScheme, l = /* @__PURE__ */ K(() => e.state.selection), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(400), h = /* @__PURE__ */ K(() => x(u)?.items.reduce((_, D) => Math.max(_, D.total), 0) ?? 0), d = /* @__PURE__ */ K(() => cp([0, Math.max(1, x(h))], [0, x(c) - 250])), p = /* @__PURE__ */ K(() => (_) => _ != 0 ? Math.max(1, x(d)(_)) : 0), g = /* @__PURE__ */ K(() => bc[r()]);
  function v(_, D, A, O, M) {
    let z = /* @__PURE__ */ De(null);
    tbe(_, D, A, M).then((N) => {
      ue(z, N);
    });
    function R(N, I, B) {
      return il({
        coordinator: _,
        selection: N ?? void 0,
        query: ($) => {
          let q = T.column(A, D);
          return T.Query.from(T.Query.from(D).select({ value: T.sql`UNNEST(${q})` }).where($)).select({ x: "value", count: T.count() }).where(T.isIn("value", I.map((U) => T.literal(U)))).groupby("value").orderby(T.desc("count"));
        },
        queryResult: ($) => {
          B(Array.from($));
        }
      });
    }
    mt(() => {
      if (x(z) == null)
        return;
      let N = x(z).values.map((G) => G.value), I = x(z).hasOther, B = /* @__PURE__ */ De([]), $ = /* @__PURE__ */ De([]), q = R(null, N, (G) => {
        ue(B, G);
      }), U = R(O, N, (G) => {
        ue($, G);
      }), H = {
        reset: () => {
          e.onStateChange({ selection: null });
        }
      };
      return mt(() => {
        if (x(B).length > 0) {
          let G = (ne) => JSON.stringify(ne), re = new Map(x(B).map(({ x: ne, count: ce }) => [G(ne), ce])), ie = new Map(x($).map(({ x: ne, count: ce }) => [G(ne), ce])), se = N.map((ne) => ({
            x: ne,
            total: re.get(G(ne)) ?? 0,
            selected: ie.get(G(ne)) ?? 0
          }));
          ue(u, { items: se, firstSpecialIndex: N.length, hasOther: I });
        }
      }), mt(() => {
        let G = {
          source: H,
          clients: /* @__PURE__ */ new Set([U]),
          ...x(l) != null ? {
            value: x(l),
            predicate: rbe(A, x(l))
          } : { value: null, predicate: null }
        };
        O.update(G), O.activate(G);
      }), () => {
        q.destroy(), U.destroy(), O.update({
          source: H,
          clients: /* @__PURE__ */ new Set([U]),
          value: null,
          predicate: null
        });
      };
    });
  }
  mt(() => {
    v(e.context.coordinator, e.context.table, e.spec.data.field, e.context.filter, e.spec.expanded ? s : o);
  });
  const y = (_, D) => JSON.stringify(_) == JSON.stringify(D);
  function b(_, D) {
    if (x(l) == null || x(l).length == 0)
      e.onStateChange({ selection: [_] });
    else {
      let A = x(l).findIndex((O) => y(O, _)) >= 0;
      D ? A ? e.onStateChange({ selection: x(l).filter((O) => !y(O, _)) }) : e.onStateChange({ selection: [...x(l), _] }) : A ? e.onStateChange({ selection: null }) : e.onStateChange({ selection: [_] });
    }
  }
  const k = ou(".6");
  function C(_) {
    return typeof _ == "string" ? _ : "[" + k(_[0]) + ", " + k(_[1]) + ")";
  }
  function S(_, D) {
    return D == 0 ? "-%" : (_ / D * 100).toFixed(1) + "%";
  }
  vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (_, D) => {
      var A = ube(), O = Y(A);
      {
        var M = (z) => {
          var R = lbe(), N = Ve(R);
          Nt(N, 17, () => x(u).items, cr, (U, H, G) => {
            const re = /* @__PURE__ */ K(() => x(l) == null || x(l).length == 0 || x(l).findIndex((Ge) => y(Ge, x(H).x)) >= 0), ie = /* @__PURE__ */ K(() => !x(u).items.every((Ge) => Ge.total == Ge.selected));
            var se = sbe(), ne = Ve(se);
            {
              var ce = (Ge) => {
                var Ze = nbe();
                X(Ge, Ze);
              };
              Oe(ne, (Ge) => {
                G == x(u).firstSpecialIndex && Ge(ce);
              });
            }
            var Ce = ae(ne, 2);
            Ce.__click = (Ge) => b(x(H).x, Ge.shiftKey);
            var Pe = Y(Ce), Me = Y(Pe);
            let _e;
            var he = Y(Me, !0);
            J(Me), J(Pe);
            var ke = ae(Pe, 2), ve = Y(ke);
            {
              var We = (Ge) => {
                var Ze = ibe(), It = Ve(Ze);
                let rr;
                var Fe = ae(It, 2);
                let $e;
                Ae(
                  (lt, kt) => {
                    rr = ft(It, "", rr, lt), $e = ft(Fe, "", $e, kt);
                  },
                  [
                    () => ({
                      background: x(g).markColorFade,
                      width: `${x(p)(x(H).total) ?? ""}px`
                    }),
                    () => ({
                      background: x(g).markColor,
                      width: `${x(p)(x(H).selected) ?? ""}px`
                    })
                  ]
                ), X(Ge, Ze);
              }, Qe = (Ge) => {
                var Ze = obe(), It = Ve(Ze);
                let rr;
                var Fe = ae(It, 2);
                let $e;
                Ae(
                  (lt, kt) => {
                    rr = ft(It, "", rr, lt), $e = ft(Fe, "", $e, kt);
                  },
                  [
                    () => ({
                      background: x(g).markColorGrayFade,
                      width: `${x(p)(x(H).total) ?? ""}px`
                    }),
                    () => ({
                      background: x(g).markColorGray,
                      width: `${x(p)(x(H).selected) ?? ""}px`
                    })
                  ]
                ), X(Ge, Ze);
              };
              Oe(ve, (Ge) => {
                x(re) ? Ge(We) : Ge(Qe, !1);
              });
            }
            J(ke);
            var ot = ae(ke, 2), Ye = Y(ot);
            let Ht;
            var St = Y(Ye);
            {
              var Gt = (Ge) => {
                var Ze = Ro();
                Ae((It) => ut(Ze, It), [
                  () => x(H).selected.toLocaleString() + " / " + x(H).total.toLocaleString()
                ]), X(Ge, Ze);
              }, $t = (Ge) => {
                var Ze = Ro();
                Ae((It) => ut(Ze, It), [() => x(H).total.toLocaleString()]), X(Ge, Ze);
              };
              Oe(St, (Ge) => {
                x(ie) ? Ge(Gt) : Ge($t, !1);
              });
            }
            J(Ye), J(ot), J(Ce), Ae(
              (Ge, Ze) => {
                te(Ce, "title", x(H).x), _e = Yr(Me, 1, "", null, _e, {
                  "text-gray-400": !x(re),
                  "dark:text-gray-400": !x(re)
                }), ut(he, Ge), Ht = Yr(Ye, 1, "text-slate-400 dark:text-slate-500", null, Ht, {
                  "!text-gray-200": !x(re),
                  "dark:!text-gray-600": !x(re)
                }), te(Ye, "title", Ze);
              },
              [
                () => C(x(H).x),
                () => x(ie) ? `${x(H).total.toLocaleString()} rows contain "${x(H).x}"; ${x(H).selected.toLocaleString()} (${S(x(H).selected, x(H).total)}) in selection` : `${x(H).total.toLocaleString()} rows contain "${x(H).x}"`
              ]
            ), X(U, se);
          });
          var I = ae(N, 2), B = Y(I), $ = Y(B);
          {
            var q = (U) => {
              var H = abe();
              H.__click = () => {
                let se = !e.spec.expanded;
                e.onSpecChange({ expanded: se }), se == !1 && e.onStateChange({ selection: null });
              };
              var G = Y(H);
              {
                var re = (se) => {
                  var ne = Ro();
                  ne.nodeValue = "â†‘ Show up to 10 values", X(se, ne);
                }, ie = (se) => {
                  var ne = Ro();
                  ne.nodeValue = "â†“ Show up to 100 values", X(se, ne);
                };
                Oe(G, (se) => {
                  e.spec.expanded ? se(re) : se(ie, !1);
                });
              }
              J(H), X(U, H);
            };
            Oe($, (U) => {
              (e.spec.expanded || x(u).hasOther) && U(q);
            });
          }
          J(B), J(I), X(z, R);
        };
        Oe(O, (z) => {
          x(u) && z(M);
        });
      }
      J(A), Ks(A, "clientWidth", (z) => ue(c, z)), X(_, A);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
nn(["click"]);
var hbe = /* @__PURE__ */ Dt("<rect></rect>"), fbe = /* @__PURE__ */ Dt("<rect></rect>"), dbe = /* @__PURE__ */ Dt("<!><!><!>", 1), pbe = /* @__PURE__ */ me('<div class="flex gap items-center text-sm"><span class="flex-1 text-slate-400 dark:text-slate-500"><!></span> <!></div>'), mbe = /* @__PURE__ */ me("<!> <!>", 1);
function gbe(t, e) {
  nt(e, !0);
  const r = () => mi(s, "$colorScheme", n), [n, i] = Xo();
  let { coordinator: o, colorScheme: s } = e.context, a = /* @__PURE__ */ K(() => e.state.brush), l = /* @__PURE__ */ K(() => bc[r()]), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(null);
  function h(d, p, g, v) {
    let y = /* @__PURE__ */ De(null);
    Zl(d, p, g).then((C) => {
      ue(y, C);
    });
    let b = /* @__PURE__ */ K(() => x(y) ? yp({
      key: "x",
      stats: x(y),
      scaleType: e.spec.xScaleType,
      binCount: e.spec.binCount
    }) : null);
    mt(() => {
      x(c) == null && x(b)?.scales.x?.type != null && ue(c, x(b)?.scales.x?.type, !0);
    });
    function k(C, S, _) {
      return il({
        coordinator: d,
        selection: S ?? void 0,
        query: (D) => T.Query.from(p).select({ ...C.select, count: T.count() }).where(D).groupby(C.select.x),
        queryResult: (D) => {
          _(Array.from(D).map(C.collect));
        }
      });
    }
    mt(() => {
      if (x(b) == null)
        return;
      let C = x(b), S = /* @__PURE__ */ De(fs([])), _ = /* @__PURE__ */ De(fs([])), D = k(C, null, (M) => {
        ue(S, M, !0);
      }), A = k(C, v, (M) => {
        ue(_, M, !0);
      });
      mt(() => {
        x(S).length > 0 && ue(u, {
          xScale: C.scales.x,
          allItems: x(S),
          filteredItems: x(_)
        });
      });
      let O = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return mt(() => {
        let M = {
          source: O,
          clients: /* @__PURE__ */ new Set([A]),
          ...x(a) != null ? C.clause(x(a)) : { value: null, predicate: null }
        };
        v.update(M), v.activate(M);
      }), () => {
        D.destroy(), A.destroy(), v.update({
          source: O,
          clients: /* @__PURE__ */ new Set([A]),
          value: null,
          predicate: null
        });
      };
    });
  }
  mt(() => {
    h(o, e.context.table, e.spec.data.field, e.context.filter);
  }), vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (d, p) => {
      var g = mbe(), v = Ve(g);
      {
        const k = (S, _ = zt, D = zt) => {
          var A = kr(), O = Ve(A);
          {
            var M = (z) => {
              const R = /* @__PURE__ */ K(() => x(u).allItems.reduce((N, I) => Math.max(N, I.count), 1));
              {
                const N = (B, $ = zt) => {
                  const q = /* @__PURE__ */ K(() => $().xScale), U = /* @__PURE__ */ K(() => $().yScale);
                  var H = dbe(), G = Ve(H);
                  Nt(G, 17, () => x(u)?.allItems ?? [], cr, (se, ne) => {
                    const ce = /* @__PURE__ */ K(() => {
                      const [_e, he] = x(q).applyBand(x(ne).x);
                      return { x0: _e, x1: he };
                    }), Ce = /* @__PURE__ */ K(() => {
                      const [_e, he] = x(U).applyBand([0, x(ne).count]);
                      return { y0: _e, y1: he };
                    }), Pe = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ce).x1 - x(ce).x0) * 0.1, 1));
                    var Me = hbe();
                    Ae(
                      (_e, he, ke, ve) => {
                        te(Me, "x", _e), te(Me, "y", he), te(Me, "width", ke), te(Me, "height", ve), te(Me, "fill", x(l).markColorFade);
                      },
                      [
                        () => Math.min(x(ce).x0, x(ce).x1) + x(Pe) / 2,
                        () => Math.min(x(Ce).y0, x(Ce).y1),
                        () => Math.abs(x(ce).x0 - x(ce).x1) - x(Pe),
                        () => Math.abs(x(Ce).y0 - x(Ce).y1)
                      ]
                    ), X(se, Me);
                  });
                  var re = ae(G);
                  Nt(re, 17, () => x(u)?.filteredItems ?? [], cr, (se, ne) => {
                    const ce = /* @__PURE__ */ K(() => {
                      const [_e, he] = x(q).applyBand(x(ne).x);
                      return { x0: _e, x1: he };
                    }), Ce = /* @__PURE__ */ K(() => {
                      const [_e, he] = x(U).applyBand([0, x(ne).count]);
                      return { y0: _e, y1: he };
                    }), Pe = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ce).x1 - x(ce).x0) * 0.1, 1));
                    var Me = fbe();
                    Ae(
                      (_e, he, ke, ve) => {
                        te(Me, "x", _e), te(Me, "height", he), te(Me, "y", ke), te(Me, "width", ve), te(Me, "fill", x(l).markColor);
                      },
                      [
                        () => Math.min(x(ce).x0, x(ce).x1) + x(Pe) / 2,
                        () => Math.abs(x(Ce).y0 - x(Ce).y1),
                        () => Math.min(x(Ce).y0, x(Ce).y1),
                        () => Math.abs(x(ce).x0 - x(ce).x1) - x(Pe)
                      ]
                    ), X(se, Me);
                  });
                  var ie = ae(re);
                  {
                    let se = /* @__PURE__ */ K(() => x(a) ?? null);
                    Ox(ie, {
                      get proxy() {
                        return $();
                      },
                      mode: "x",
                      get value() {
                        return x(se);
                      },
                      get colorScheme() {
                        return r();
                      },
                      onChange: (ne) => {
                        e.onStateChange({ brush: ne != null && ne.x != null ? { x: ne.x } : null });
                      }
                    });
                  }
                  X(B, H);
                };
                let I = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(R)] }));
                Ld(z, {
                  get width() {
                    return _();
                  },
                  get height() {
                    return D();
                  },
                  get xScale() {
                    return x(u).xScale;
                  },
                  get yScale() {
                    return x(I);
                  },
                  get colorScheme() {
                    return r();
                  },
                  children: N,
                  $$slots: { default: !0 }
                });
              }
            };
            Oe(O, (z) => {
              x(u) != null && z(M);
            });
          }
          X(S, A);
        };
        let C = /* @__PURE__ */ K(() => e.height != null);
        p0(v, {
          get flexHeight() {
            return x(C);
          },
          children: k,
          $$slots: { default: !0 }
        });
      }
      var y = ae(v, 2);
      {
        var b = (k) => {
          var C = pbe(), S = Y(C), _ = Y(S);
          {
            var D = (z) => {
              var R = kr(), N = Ve(R);
              {
                var I = ($) => {
                  var q = Ro();
                  Ae(() => ut(q, `[${x(a).x ?? ""}]`)), X($, q);
                }, B = ($) => {
                  const q = /* @__PURE__ */ K(() => ou(".4"));
                  var U = Ro();
                  Ae((H, G) => ut(U, `[${H ?? ""}, ${G ?? ""}]`), [
                    () => x(q)(x(a).x[0]),
                    () => x(q)(x(a).x[1])
                  ]), X($, U);
                };
                Oe(N, ($) => {
                  typeof x(a).x == "string" ? $(I) : $(B, !1);
                });
              }
              X(z, R);
            };
            Oe(_, (z) => {
              x(a) && z(D);
            });
          }
          J(S);
          var A = ae(S, 2), O = () => e.spec.xScaleType ?? x(c) ?? "linear", M = (z) => {
            e.onSpecChange({ xScaleType: z });
          };
          Eh(A, {
            label: "X",
            get value() {
              return O();
            },
            set value(z) {
              M(z);
            }
          }), J(C), X(k, C);
        };
        Oe(y, (k) => {
          x(u)?.xScale.type != "band" && k(b);
        });
      }
      X(d, g);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var vbe = /* @__PURE__ */ Dt('<image preserveAspectRatio="none"></image>');
function ybe(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => e.proxy.xScale && e.xDomain ? e.proxy.xScale.apply(e.xDomain[0]) : 0), n = /* @__PURE__ */ K(() => e.proxy.xScale && e.xDomain ? e.proxy.xScale.apply(e.xDomain[1]) : e.proxy.plotWidth), i = /* @__PURE__ */ K(() => e.proxy.yScale && e.yDomain ? e.proxy.yScale.apply(e.yDomain[0]) : 0), o = /* @__PURE__ */ K(() => e.proxy.yScale && e.yDomain ? e.proxy.yScale.apply(e.yDomain[1]) : e.proxy.plotHeight), s = /* @__PURE__ */ De(null), a = document.createElement("canvas");
  mt(() => {
    a.width = e.rasterWidth, a.height = e.rasterHeight;
    let u = a.getContext("2d", { colorSpace: "srgb", willReadFrequently: !0 });
    u.clearRect(0, 0, a.width, a.height);
    let c = u.getImageData(0, 0, a.width, a.height), h = 0;
    for (let d = 0; d < a.height; d++)
      for (let p = 0; p < a.width; p++) {
        let g = (p + 0.5) / a.width * (x(n) - x(r)) + x(r), v = (d + 0.5) / a.height * (x(o) - x(i)) + x(i), y = e.proxy.xScale?.invert(g) ?? 0, b = e.proxy.yScale?.invert(v) ?? 0, { r: k, g: C, b: S, opacity: _ } = Pg(e.color(y, b));
        c.data[h++] = k, c.data[h++] = C, c.data[h++] = S, c.data[h++] = _ * 255;
      }
    u.putImageData(c, 0, 0), ue(s, a.toDataURL("image/png"), !0);
  });
  var l = vbe();
  Ae(
    (u, c, h, d) => {
      te(l, "x", u), te(l, "y", c), te(l, "width", h), te(l, "height", d), te(l, "href", x(s));
    },
    [
      () => Math.min(x(r), x(n)),
      () => Math.min(x(i), x(o)),
      () => Math.abs(x(r) - x(n)),
      () => Math.abs(x(i) - x(o))
    ]
  ), X(t, l), it();
}
var bbe = /* @__PURE__ */ Dt("<rect></rect>"), xbe = /* @__PURE__ */ Dt("<rect></rect><!>", 1), wbe = /* @__PURE__ */ me('<div class="text-slate-400 mb-1 select-none"> </div> <!> <div class="text-slate-400 mb-1 select-none text-right"> </div> <div class="flex gap items-center text-sm"><span class="flex-1 text-slate-400 dark:text-slate-500"><!></span> <span class="flex flex-col items-end gap-1"><span class="flex gap-2"><!> <!></span> <span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm">Normalize:</span> <!></span></span></div>', 1);
function kbe(t, e) {
  nt(e, !0);
  const r = () => mi(o, "$colorScheme", n), [n, i] = Xo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.state.brush), a = /* @__PURE__ */ De(null), l = /* @__PURE__ */ K(() => x(a)?.items.reduce((v, y) => Math.max(v, y.value), 1) ?? 1);
  const u = 0.07, c = (v) => v > 0 ? u + (1 - u) * v : 0;
  let h = /* @__PURE__ */ K(() => r() == "dark" ? (v) => oB(c(v / x(l))) : (v) => zge(c(v / x(l)))), d = /* @__PURE__ */ De(null), p = /* @__PURE__ */ De(null);
  function g(v, y, b, k, C) {
    let S = /* @__PURE__ */ De(null);
    Promise.all([
      Zl(v, y, b),
      Zl(v, y, k)
    ]).then(([A, O]) => {
      ue(S, A != null && O != null ? { x: A, y: O } : null);
    });
    let _ = /* @__PURE__ */ K(() => x(S) ? yp(
      {
        key: "x",
        stats: x(S).x,
        scaleType: e.spec.xScaleType,
        binCount: e.spec.xBinCount
      },
      {
        key: "y",
        stats: x(S).y,
        scaleType: e.spec.yScaleType,
        binCount: e.spec.yBinCount
      }
    ) : null);
    mt(() => {
      x(d) == null && x(_)?.scales.x?.type != null && ue(d, x(_)?.scales.x?.type), x(p) == null && x(_)?.scales.y?.type != null && ue(p, x(_)?.scales.y?.type);
    });
    function D(A, O, M) {
      return il({
        coordinator: v,
        selection: O ?? void 0,
        query: (z) => T.Query.from(T.Query.from(y).select({ ...A.select, count: T.count() }).where(z).groupby(A.select.x, A.select.y)).select({
          x: "x",
          y: "y",
          count: "count",
          normalizeByX: T.sql`count / (SUM(count) OVER (PARTITION BY x))`,
          normalizeByY: T.sql`count / (SUM(count) OVER (PARTITION BY y))`
        }),
        queryResult: (z) => {
          M(Array.from(z).map(A.collect));
        }
      });
    }
    mt(() => {
      if (x(_) == null)
        return;
      let A = x(_), O = /* @__PURE__ */ De(null), M = D(A, C, (R) => {
        ue(O, R);
      }), z = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return mt(() => {
        x(O) != null && ue(a, {
          xScale: A.scales.x,
          yScale: A.scales.y,
          items: x(O).map((R) => ({
            x: R.x,
            y: R.y,
            value: e.spec.normalization == "x" ? R.normalizeByX : e.spec.normalization == "y" ? R.normalizeByY : R.count
          }))
        });
      }), mt(() => {
        let R = {
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          ...x(s) != null ? A.clause(x(s)) : { value: null, predicate: null }
        };
        C.update(R), C.activate(R);
      }), () => {
        M.destroy(), C.update({
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          value: null,
          predicate: null
        });
      };
    });
  }
  mt(() => {
    g(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y, e.context.filter);
  }), vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col",
    children: (v, y) => {
      var b = wbe(), k = Ve(b), C = Y(k);
      J(k);
      var S = ae(k, 2);
      {
        const re = (ne, ce = zt, Ce = zt) => {
          var Pe = kr(), Me = Ve(Pe);
          {
            var _e = (he) => {
              Ld(he, {
                get width() {
                  return ce();
                },
                get height() {
                  return Ce();
                },
                get xScale() {
                  return x(a).xScale;
                },
                get yScale() {
                  return x(a).yScale;
                },
                get colorScheme() {
                  return r();
                },
                childrenBelow: (ke, ve = zt) => {
                  const We = /* @__PURE__ */ K(() => ve().xScale), Qe = /* @__PURE__ */ K(() => ve().yScale);
                  var ot = xbe(), Ye = Ve(ot);
                  te(Ye, "x", 0), te(Ye, "y", 0);
                  var Ht = ae(Ye);
                  Nt(Ht, 17, () => x(a)?.items ?? [], cr, (St, Gt) => {
                    const $t = /* @__PURE__ */ K(() => {
                      const [rr, Fe] = x(We).applyBand(x(Gt).x);
                      return { x0: rr, x1: Fe };
                    }), Ge = /* @__PURE__ */ K(() => {
                      const [rr, Fe] = x(Qe).applyBand(x(Gt).y);
                      return { y0: rr, y1: Fe };
                    }), Ze = /* @__PURE__ */ K(() => 0);
                    var It = bbe();
                    Ae(
                      (rr, Fe, $e, lt, kt) => {
                        te(It, "x", rr), te(It, "y", Fe), te(It, "width", $e), te(It, "height", lt), te(It, "fill", kt);
                      },
                      [
                        () => Math.min(x($t).x0, x($t).x1) + x(Ze) / 2,
                        () => Math.min(x(Ge).y0, x(Ge).y1) + x(Ze) / 2,
                        () => Math.abs(x($t).x0 - x($t).x1) - x(Ze),
                        () => Math.abs(x(Ge).y0 - x(Ge).y1) - x(Ze),
                        () => x(h)(x(Gt).value)
                      ]
                    ), X(St, It);
                  }), Ae(
                    (St) => {
                      te(Ye, "width", ve().plotWidth), te(Ye, "height", ve().plotHeight), te(Ye, "fill", St);
                    },
                    [() => x(h)(0)]
                  ), X(ke, ot);
                },
                children: (ke, ve = zt) => {
                  Ox(ke, {
                    get proxy() {
                      return ve();
                    },
                    mode: "xy",
                    get value() {
                      return x(s);
                    },
                    get colorScheme() {
                      return r();
                    },
                    onChange: (We) => {
                      e.onStateChange({
                        brush: We != null && We.x != null && We.y != null ? { x: We.x, y: We.y } : null
                      });
                    }
                  });
                },
                $$slots: { childrenBelow: !0, default: !0 }
              });
            };
            Oe(Me, (he) => {
              x(a) != null && he(_e);
            });
          }
          X(ne, Pe);
        };
        let ie = /* @__PURE__ */ K(() => e.height != null), se = /* @__PURE__ */ K(() => Math.min(300, e.width ?? 300));
        p0(S, {
          get flexHeight() {
            return x(ie);
          },
          get defaultHeight() {
            return x(se);
          },
          children: re,
          $$slots: { default: !0 }
        });
      }
      var _ = ae(S, 2), D = Y(_);
      J(_);
      var A = ae(_, 2), O = Y(A), M = Y(O);
      {
        const re = (se, ne = zt) => {
          {
            let ce = /* @__PURE__ */ K(() => ne().xScale?.domain);
            ybe(se, {
              get color() {
                return x(h);
              },
              rasterWidth: 100,
              rasterHeight: 1,
              get proxy() {
                return ne();
              },
              get xDomain() {
                return x(ce);
              }
            });
          }
        };
        let ie = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(l)] }));
        Ld(M, {
          get xScale() {
            return x(ie);
          },
          xAxis: { extendScaleToTicks: !1 },
          width: 230,
          height: 24,
          extents: { left: 30, right: 30, top: 0, bottom: 0 },
          get colorScheme() {
            return r();
          },
          children: re,
          $$slots: { default: !0 }
        });
      }
      J(O);
      var z = ae(O, 2), R = Y(z), N = Y(R), I = () => e.spec.xScaleType ?? x(d) ?? "linear", B = (re) => {
        e.onSpecChange({ xScaleType: re });
      };
      Eh(N, {
        label: "X",
        get value() {
          return I();
        },
        set value(re) {
          B(re);
        }
      });
      var $ = ae(N, 2), q = () => e.spec.yScaleType ?? x(p) ?? "linear", U = (re) => {
        e.onSpecChange({ yScaleType: re });
      };
      Eh($, {
        label: "Y",
        get value() {
          return q();
        },
        set value(re) {
          U(re);
        }
      }), J(R);
      var H = ae(R, 2), G = ae(Y(H), 2);
      {
        let re = /* @__PURE__ */ K(() => e.spec.normalization ?? null);
        Fx(G, {
          options: [
            { value: null, label: "off" },
            { value: "x", label: "X" },
            { value: "y", label: "Y" }
          ],
          get value() {
            return x(re);
          },
          onChange: (ie) => e.onSpecChange({ normalization: ie })
        });
      }
      J(H), J(z), J(A), Ae(() => {
        ut(C, `â†‘ ${e.spec.data.y ?? ""}`), ut(D, `${e.spec.data.x ?? ""} â†’`);
      }), X(v, b);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var Cbe = /* @__PURE__ */ Dt("<rect></rect>"), _be = /* @__PURE__ */ Dt("<rect></rect>"), Sbe = /* @__PURE__ */ Dt("<!><!><!>", 1), Abe = /* @__PURE__ */ me('<div class="flex gap-1 items-center"><div class="w-3 h-3 block rounded-sm"></div> <div class="whitespace-nowrap max-w-32 overflow-hidden text-ellipsis"> </div></div>'), Ebe = /* @__PURE__ */ me('<div class="flex gap-2 flex-wrap items-center select-none"></div>'), Dbe = /* @__PURE__ */ me('<!> <div class="flex-none flex gap-2 items-start text-sm"><div class="flex-1 text-slate-400 dark:text-slate-500"><!></div> <span class="flex flex-col items-end gap-1"><!> <span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm">Normalize:</span> <!></span></span></div>', 1);
function Obe(t, e) {
  nt(e, !0);
  const r = () => mi(o, "$colorScheme", n), [n, i] = Xo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.state.brush), a = /* @__PURE__ */ K(() => bc[r()]), l = /* @__PURE__ */ De(null), u = /* @__PURE__ */ De(null);
  function c(p, g, v, y, b) {
    let k = /* @__PURE__ */ De(null);
    Promise.all([
      Zl(p, g, v),
      Zl(p, g, y)
    ]).then(([_, D]) => {
      ue(k, _ != null && D != null ? { x: _, group: D } : null);
    });
    let C = /* @__PURE__ */ K(() => x(k) ? yp(
      {
        key: "x",
        stats: x(k).x,
        scaleType: e.spec.xScaleType,
        binCount: e.spec.xBinCount
      },
      {
        key: "group",
        stats: x(k).group,
        binCount: e.spec.groupBinCount
      }
    ) : null);
    mt(() => {
      x(u) == null && x(C)?.scales.x?.type != null && ue(u, x(C)?.scales.x?.type, !0);
    });
    function S(_, D, A) {
      return il({
        coordinator: p,
        selection: D ?? void 0,
        query: (O) => T.Query.from(T.Query.from(g).select({ ..._.select, count: T.count() }).where(O).groupby(_.select.x, _.select.group)).select({
          x: "x",
          group: "group",
          count: "count",
          normalizeByX: T.sql`count / (SUM(count) OVER (PARTITION BY x))`
        }),
        queryResult: (O) => {
          A(Array.from(O).map(_.collect));
        }
      });
    }
    mt(() => {
      if (x(C) == null)
        return;
      let _ = x(C), D = /* @__PURE__ */ De(null), A = /* @__PURE__ */ De(null), O = S(_, null, (R) => {
        ue(D, R);
      }), M = S(_, b, (R) => {
        ue(A, R);
      }), z = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return mt(() => {
        if (x(D) != null && x(A) != null) {
          let R = (H) => JSON.stringify(H), N = e.spec.normalization == "x" ? "normalizeByX" : "count", I = Array.from(h(x(D), (H) => R(H.group), (H) => H[0].group).entries()).sort((H, G) => _.order.group(H[1], G[1])), B = h(x(D), (H) => R(H.x), (H) => ({
            x: H[0].x,
            total: H.reduce((G, re) => G + re[N], 0)
          })), $ = h(x(A), (H) => R(H.x), (H) => {
            H = H.sort((ie, se) => _.order.group(ie.group, se.group));
            let G = [], re = 0;
            for (let ie of H)
              G.push({ group: ie.group, y1: re, y2: re + ie[N] }), re += ie[N];
            return { x: H[0].x, groups: G };
          }), q = B.values().reduce((H, G) => Math.max(H, G.total), 1);
          e.spec.normalization && (q = 1);
          let U = x1e(Array.from(I.map((H) => H[1])), {
            fade: ["n/a", "(null)"],
            ordinal: _.scales.group.type != "band"
          });
          ue(l, {
            xScale: _.scales.x,
            yScale: { type: "linear", domain: [0, q] },
            colorScale: U,
            totals: Array.from(B.values()),
            items: Array.from($.values())
          });
        }
      }), mt(() => {
        let R = {
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          ...x(s) != null ? _.clause(x(s)) : { value: null, predicate: null }
        };
        b.update(R), b.activate(R);
      }), () => {
        O.destroy(), M.destroy(), b.update({
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          value: null,
          predicate: null
        });
      };
    });
  }
  mt(() => {
    c(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.group, e.context.filter);
  });
  function h(p, g, v) {
    let y = /* @__PURE__ */ new Map();
    for (let b of p) {
      let k = g(b), C = y.get(k);
      C || (C = [], y.set(k, C)), C.push(b);
    }
    return new Map(y.entries().map(([b, k]) => [b, v(k)]));
  }
  function d(p) {
    if (typeof p == "string")
      return p;
    {
      let g = ou(".6");
      if (p.length == 2)
        return `[${g(p[0])}, ${g(p[1])})`;
    }
    return "(invalid)";
  }
  vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (p, g) => {
      var v = Dbe(), y = Ve(v);
      {
        const R = (I, B = zt, $ = zt) => {
          var q = kr(), U = Ve(q);
          {
            var H = (G) => {
              Ld(G, {
                get width() {
                  return B();
                },
                get height() {
                  return $();
                },
                get xScale() {
                  return x(l).xScale;
                },
                get yScale() {
                  return x(l).yScale;
                },
                get colorScheme() {
                  return r();
                },
                children: (re, ie = zt) => {
                  const se = /* @__PURE__ */ K(() => ie().xScale), ne = /* @__PURE__ */ K(() => ie().yScale);
                  var ce = Sbe(), Ce = Ve(ce);
                  Nt(Ce, 17, () => x(l)?.totals ?? [], cr, (_e, he) => {
                    const ke = /* @__PURE__ */ K(() => {
                      const [ot, Ye] = x(se).applyBand(x(he).x);
                      return { x0: ot, x1: Ye };
                    }), ve = /* @__PURE__ */ K(() => {
                      const [ot, Ye] = x(ne).applyBand([0, x(he).total]);
                      return { y0: ot, y1: Ye };
                    }), We = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ke).x1 - x(ke).x0) * 0.2, Math.abs(x(ve).y1 - x(ve).y0) * 0.2, 1));
                    var Qe = Cbe();
                    Ae(
                      (ot, Ye, Ht, St) => {
                        te(Qe, "x", ot), te(Qe, "y", Ye), te(Qe, "width", Ht), te(Qe, "height", St), te(Qe, "fill", x(a).markColorFade);
                      },
                      [
                        () => Math.min(x(ke).x0, x(ke).x1) + x(We) / 2,
                        () => Math.min(x(ve).y0, x(ve).y1),
                        () => Math.abs(x(ke).x0 - x(ke).x1) - x(We),
                        () => Math.abs(x(ve).y0 - x(ve).y1)
                      ]
                    ), X(_e, Qe);
                  });
                  var Pe = ae(Ce);
                  Nt(Pe, 17, () => x(l)?.items ?? [], cr, (_e, he) => {
                    let ke = () => x(he).x, ve = () => x(he).groups;
                    const We = /* @__PURE__ */ K(() => {
                      const [Ye, Ht] = x(se).applyBand(ke());
                      return { x0: Ye, x1: Ht };
                    });
                    var Qe = kr(), ot = Ve(Qe);
                    Nt(ot, 17, ve, cr, (Ye, Ht) => {
                      const St = /* @__PURE__ */ K(() => {
                        const [Ge, Ze] = x(ne).applyBand([x(Ht).y1, x(Ht).y2]);
                        return { y0: Ge, y1: Ze };
                      }), Gt = /* @__PURE__ */ K(() => Math.min(Math.abs(x(We).x1 - x(We).x0) * 0.2, Math.abs(x(St).y1 - x(St).y0) * 0.2, 1));
                      var $t = _be();
                      Ae(
                        (Ge, Ze, It, rr, Fe) => {
                          te($t, "x", Ge), te($t, "y", Ze), te($t, "width", It), te($t, "height", rr), te($t, "fill", Fe);
                        },
                        [
                          () => Math.min(x(We).x0, x(We).x1) + x(Gt) / 2,
                          () => Math.min(x(St).y0, x(St).y1),
                          () => Math.abs(x(We).x0 - x(We).x1) - x(Gt),
                          () => Math.abs(x(St).y0 - x(St).y1),
                          () => x(l)?.colorScale.apply(x(Ht).group)
                        ]
                      ), X(Ye, $t);
                    }), X(_e, Qe);
                  });
                  var Me = ae(Pe);
                  Ox(Me, {
                    get proxy() {
                      return ie();
                    },
                    mode: "x",
                    get value() {
                      return x(s);
                    },
                    get colorScheme() {
                      return r();
                    },
                    onChange: (_e) => {
                      e.onStateChange({ brush: _e != null && _e.x != null ? { x: _e.x } : null });
                    }
                  }), X(re, ce);
                },
                $$slots: { default: !0 }
              });
            };
            Oe(U, (G) => {
              x(l) != null && G(H);
            });
          }
          X(I, q);
        };
        let N = /* @__PURE__ */ K(() => e.height != null);
        p0(y, {
          get flexHeight() {
            return x(N);
          },
          children: R,
          $$slots: { default: !0 }
        });
      }
      var b = ae(y, 2), k = Y(b), C = Y(k);
      {
        var S = (R) => {
          var N = Ebe();
          Nt(N, 21, () => x(l).colorScale.domain, cr, (I, B) => {
            var $ = Abe(), q = Y($);
            let U;
            var H = ae(q, 2), G = Y(H, !0);
            J(H), J($), Ae(
              (re, ie, se) => {
                te($, "title", re), U = ft(q, "", U, ie), ut(G, se);
              },
              [
                () => JSON.stringify(x(B)),
                () => ({ background: x(l).colorScale.apply(x(B)) }),
                () => d(x(B))
              ]
            ), X(I, $);
          }), J(N), X(R, N);
        };
        Oe(C, (R) => {
          x(l) && R(S);
        });
      }
      J(k);
      var _ = ae(k, 2), D = Y(_), A = () => e.spec.xScaleType ?? x(u) ?? "linear", O = (R) => {
        e.onSpecChange({ xScaleType: R });
      };
      Eh(D, {
        label: "X",
        get value() {
          return A();
        },
        set value(R) {
          O(R);
        }
      });
      var M = ae(D, 2), z = ae(Y(M), 2);
      Fx(z, {
        options: [{ value: null, label: "off" }, { value: "x", label: "X" }],
        get value() {
          return e.spec.normalization;
        },
        onChange: (R) => e.onSpecChange({ normalization: R })
      }), J(M), J(_), J(b), X(p, v);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var Fbe = /* @__PURE__ */ Dt('<circle r="3"></circle>'), Tbe = /* @__PURE__ */ Dt('<path fill="none" stroke-width="2"></path><!>', 1), Mbe = /* @__PURE__ */ me('<div class="flex gap items-center text-sm"><span class="flex-1"></span> <!></div>'), Pbe = /* @__PURE__ */ me("<!> <!>", 1);
function Rbe(t, e) {
  nt(e, !0);
  const r = () => mi(s, "$colorScheme", n), [n, i] = Xo();
  let { coordinator: o, colorScheme: s } = e.context, a = /* @__PURE__ */ K(() => bc[r()]), l = /* @__PURE__ */ De(null), u = /* @__PURE__ */ De(null);
  function c(h, d, p) {
    let g = /* @__PURE__ */ De(null);
    Zl(h, d, p).then((b) => {
      ue(g, b);
    });
    let v = /* @__PURE__ */ K(() => x(g) ? yp({
      key: "x",
      stats: x(g),
      scaleType: e.spec.xScaleType,
      binCount: 52
    }) : null);
    mt(() => {
      x(u) == null && x(v)?.scales.x?.type != null && ue(u, x(v)?.scales.x?.type, !0);
    });
    function y(b, k) {
      return il({
        coordinator: h,
        selection: e.context.filter,
        query: (C) => T.Query.from(d).select({ ...b.select, count: T.count() }).where(C).groupby(b.select.x).orderby(b.select.x),
        queryResult: (C) => {
          k(Array.from(C).map(b.collect));
        }
      });
    }
    mt(() => {
      if (x(v) == null)
        return;
      let b = x(v), k = /* @__PURE__ */ De(fs([])), C = y(b, (S) => {
        ue(k, S, !0);
      });
      return mt(() => {
        x(k).length > 0 && ue(l, { xScale: b.scales.x, points: x(k) });
      }), () => {
        C.destroy();
      };
    });
  }
  mt(() => {
    c(o, e.context.table, e.spec.data.x);
  }), vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (h, d) => {
      var p = Pbe(), g = Ve(p);
      {
        const b = (C, S = zt, _ = zt) => {
          var D = kr(), A = Ve(D);
          {
            var O = (M) => {
              const z = /* @__PURE__ */ K(() => x(l).points.reduce((R, N) => Math.max(R, N.count), 1));
              {
                const R = (I, B = zt) => {
                  const $ = /* @__PURE__ */ K(() => B().xScale), q = /* @__PURE__ */ K(() => B().yScale);
                  var U = kr(), H = Ve(U);
                  {
                    var G = (re) => {
                      const ie = /* @__PURE__ */ K(() => x(l).points.map((Ce, Pe) => {
                        const Me = x($).apply(Ce.x), _e = x(q).apply(Ce.count);
                        return `${Pe === 0 ? "M" : "L"} ${Me} ${_e}`;
                      }).join(" "));
                      var se = Tbe(), ne = Ve(se), ce = ae(ne);
                      Nt(ce, 17, () => x(l).points, cr, (Ce, Pe) => {
                        const Me = /* @__PURE__ */ K(() => x($).apply(x(Pe).x)), _e = /* @__PURE__ */ K(() => x(q).apply(x(Pe).count));
                        var he = Fbe();
                        Ae(() => {
                          te(he, "cx", x(Me)), te(he, "cy", x(_e)), te(he, "fill", x(a).markColor);
                        }), X(Ce, he);
                      }), Ae(() => {
                        te(ne, "d", x(ie)), te(ne, "stroke", x(a).markColor);
                      }), X(re, se);
                    };
                    Oe(H, (re) => {
                      x(l).points.length > 1 && re(G);
                    });
                  }
                  X(I, U);
                };
                let N = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(z)] }));
                Ld(M, {
                  get width() {
                    return S();
                  },
                  get height() {
                    return _();
                  },
                  get xScale() {
                    return x(l).xScale;
                  },
                  get yScale() {
                    return x(N);
                  },
                  get colorScheme() {
                    return r();
                  },
                  children: R,
                  $$slots: { default: !0 }
                });
              }
            };
            Oe(A, (M) => {
              x(l) != null && M(O);
            });
          }
          X(C, D);
        };
        let k = /* @__PURE__ */ K(() => e.height != null);
        p0(g, {
          get flexHeight() {
            return x(k);
          },
          children: b,
          $$slots: { default: !0 }
        });
      }
      var v = ae(g, 2);
      {
        var y = (b) => {
          var k = Mbe(), C = ae(Y(k), 2);
          {
            let S = /* @__PURE__ */ K(() => e.spec.xScaleType ?? x(u) ?? "linear");
            Eh(C, {
              label: "X",
              get value() {
                return x(S);
              },
              onChange: (_) => {
                e.onSpecChange({ xScaleType: _ });
              }
            });
          }
          J(k), X(b, k);
        };
        Oe(v, (b) => {
          x(l)?.xScale.type != "band" && b(y);
        });
      }
      X(h, p);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var Nbe = /* @__PURE__ */ me('<div class="p-2 w-full"></div>');
function $be(t, e) {
  nt(e, !0);
  let { coordinator: r, colorScheme: n } = e.context, i = /* @__PURE__ */ De(void 0), o = /* @__PURE__ */ De(fs(e.width ?? 800));
  function s(c, h) {
    if (!c) return !1;
    let d = h.mark?.plot?.element;
    return d == null ? !1 : c?.contains(d) ?? !1;
  }
  async function a(c, h, d, p = {}) {
    try {
      const g = _K(h), v = AK({ coordinator: c }), y = await SK(g, { params: new Map(Object.entries(p)), api: v });
      return d.innerHTML = "", y.element && d.appendChild(y.element), () => {
        for (const b in p) {
          const k = p[b];
          if (o3(k))
            for (const C of k.clauses)
              s(d, C.source) && (C.source?.reset?.(), k.update({ ...C, value: null, predicate: null }));
        }
        y.element?.remove();
      };
    } catch (g) {
      return console.error("[MosaicSpec] Failed to render vgplot spec:", g), d.innerHTML = `<div style="padding: 1rem; color: #ef4444;">
        Failed to render chart: ${g instanceof Error ? g.message : String(g)}
      </div>`, () => {
      };
    }
  }
  Kg(() => {
    mt(() => {
      let c = null;
      async function h() {
        x(i) && e.spec.spec && (c = await a(r, e.spec.spec, x(i), { filter: e.context.filter }));
      }
      return h(), () => {
        c?.();
      };
    });
  }), Vs(() => {
    e.width != null && ue(o, e.width, !0);
  });
  var l = Nbe();
  let u;
  Qs(l, (c) => ue(i, c), () => x(i)), Ae(() => u = ft(l, "", u, {
    height: e.height != null ? `${e.height}px` : "100%"
  })), Ks(l, "clientWidth", (c) => ue(o, c)), X(t, l), it();
}
var Ibe = /* @__PURE__ */ me('<div class="bg-slate-100 p-2 rounded-md w-full h-full overflow-y-scroll"><pre> </pre></div>');
function $k(t, e) {
  nt(e, !0);
  var r = Ibe(), n = Y(r), i = Y(n, !0);
  J(n), J(r), Ae((o) => ut(i, o), [() => JSON.stringify(e.spec, null, 2)]), X(t, r), it();
}
var Bbe = /* @__PURE__ */ me('<span class="mx-1"> </span>'), Lbe = /* @__PURE__ */ me("<button><!> <!></button>");
function Tu(t, e) {
  nt(e, !0);
  let r = ct(e, "label", 3, null), n = ct(e, "icon", 3, null), i = ct(e, "title", 3, ""), o = ct(e, "order", 3, null);
  var s = Lbe();
  s.__click = () => {
    e.onClick?.();
  };
  let a;
  var l = Y(s);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(n);
      var g = kr(), v = Ve(g);
      Qd(v, () => x(p), (y, b) => {
        b(y, { class: "w-5 h-5" });
      }), X(d, g);
    };
    Oe(l, (d) => {
      n() != null && d(u);
    });
  }
  var c = ae(l, 2);
  {
    var h = (d) => {
      var p = Bbe(), g = Y(p, !0);
      J(p), Ae(() => ut(g, r())), X(d, p);
    };
    Oe(c, (d) => {
      r() != null && r() != "" && d(h);
    });
  }
  J(s), Ae(() => {
    Yr(s, 1, `rounded-md flex select-none items-center px-1.5 py-1.5 h-[28px] border bg-white dark:bg-slate-900 border-slate-300 dark:border-slate-600 dark:text-slate-400 focus-visible:outline-2 outline-blue-600 -outline-offset-1 ${e.class ?? "" ?? ""}`), te(s, "title", i()), a = ft(s, "", a, { order: o() });
  }), X(t, s), it();
}
nn(["click"]);
var zbe = /* @__PURE__ */ me("<input/>");
function ML(t, e) {
  nt(e, !0);
  let r = ct(e, "value", 15), n = ct(e, "type", 3, "text"), i = ct(e, "placeholder", 3, ""), o = ct(e, "className", 3, "");
  function s(l) {
    l.key == "Escape" && l.stopPropagation();
  }
  var a = zbe();
  OT(a), a.__keydown = s, Ae(() => {
    te(a, "type", n()), te(a, "placeholder", i()), Yr(a, 1, `form-input rounded-md py-1 bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 ${o() ?? "" ?? ""}`);
  }), eX(a, r), X(t, a), it();
}
nn(["keydown"]);
var jbe = /* @__PURE__ */ me('<div><button class="flex-1 overflow-hidden text-left"><div class="text-ellipsis overflow-hidden w-full"> </div> <div class="text-ellipsis overflow-hidden w-full"><code class="text-xs whitespace-nowrap"> </code></div></button> <div class="flex-none flex gap-1"><!> <!></div></div>'), qbe = /* @__PURE__ */ me('<div class="mt-4"><!> <div class="text-slate-500 dark:text-slate-400 text-sm mb-1">SQL Predicate</div> <div class="w-full !h-32 mb-2"><!></div> <div class="flex gap-2"><!> <!> <div class="flex-1"></div> <button class="text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200">Current Predicate</button></div></div>'), Ube = /* @__PURE__ */ me('<div class="flex flex-col gap-1"><!> <button class="text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden">+ Add Predicate</button></div> <!>', 1);
function Hbe(t, e) {
  nt(e, !0);
  const r = () => mi(o, "$colorScheme", n), [n, i] = Xo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.spec.items ?? []), a = /* @__PURE__ */ K(() => e.state.selectedPredicates ?? []), l = /* @__PURE__ */ De(!1), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(""), h = /* @__PURE__ */ De("");
  function d() {
    ue(l, !1), ue(u, null), ue(h, ""), ue(c, "");
  }
  function p(v) {
    e.onSpecChange({ items: v }), e.onStateChange({
      selectedPredicates: (e.state.selectedPredicates ?? []).filter((y) => v.find((b) => b.predicate == y) != null)
    });
  }
  async function g() {
    let v = x(h).trim();
    v == "" && (v = "Predicate");
    let y = x(c).trim();
    if (y == "")
      return null;
    try {
      await e.context.coordinator.query(T.Query.from(e.context.table).select({ count: T.count() }).where(y));
    } catch (b) {
      return alert(b.toString()), null;
    }
    return { name: v, predicate: y };
  }
  mt(() => {
    let v = il({
      coordinator: e.context.coordinator,
      selection: e.context.filter,
      query: () => T.sql`SELECT 1`
    }), y = {
      reset: () => {
        e.onStateChange({ selectedPredicates: [] });
      }
    };
    return Vs(() => {
      if (x(a).length == 0)
        e.context.filter.update({
          source: y,
          clients: /* @__PURE__ */ new Set([v]),
          predicate: null,
          value: null
        });
      else {
        let b = x(a).map((k) => "(" + k + ")").join(" OR ");
        e.context.filter.update({
          source: y,
          clients: /* @__PURE__ */ new Set([v]),
          predicate: T.asVerbatim(b),
          value: b
        });
      }
    }), () => {
      v.destroy();
    };
  }), vc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (v, y) => {
      var b = Ube(), k = Ve(b), C = Y(k);
      Nt(C, 17, () => x(s), cr, (A, O) => {
        const M = /* @__PURE__ */ K(() => x(a).indexOf(x(O).predicate) >= 0);
        var z = jbe();
        let R;
        var N = Y(z);
        N.__click = (ie) => {
          ie.shiftKey ? ue(a, x(M) ? x(a).filter((se) => se != x(O).predicate) : [...x(a), x(O).predicate]) : x(M) ? ue(a, []) : ue(a, [x(O).predicate]);
        };
        var I = Y(N), B = Y(I, !0);
        J(I);
        var $ = ae(I, 2), q = Y($), U = Y(q, !0);
        J(q), J($), J(N);
        var H = ae(N, 2), G = Y(H);
        Tu(G, {
          get icon() {
            return II;
          },
          onClick: () => {
            ue(u, x(O)), ue(c, x(O).predicate, !0), ue(h, x(O).name, !0), ue(l, !0);
          }
        });
        var re = ae(G, 2);
        Tu(re, {
          get icon() {
            return mx;
          },
          onClick: () => {
            p(x(s).filter((ie) => ie !== x(O)));
          }
        }), J(H), J(z), Ae(() => {
          R = Yr(z, 1, "flex gap-4 w-full bg-white dark:bg-slate-800 p-2 rounded-md border border-slate-200 dark:border-slate-600 select-none", null, R, {
            "!bg-blue-100": x(M),
            "!border-blue-400": x(M),
            "dark:!bg-blue-800": x(M),
            "dark:!border-blue-600": x(M)
          }), ut(B, x(O).name), te(q, "title", x(O).predicate), ut(U, x(O).predicate);
        }), X(A, z);
      });
      var S = ae(C, 2);
      S.__click = () => {
        ue(l, !0), ue(u, null);
      }, J(k);
      var _ = ae(k, 2);
      {
        var D = (A) => {
          var O = qbe(), M = Y(O);
          ML(M, {
            placeholder: "name",
            className: "w-full mb-2",
            get value() {
              return x(h);
            },
            set value(H) {
              ue(h, H, !0);
            }
          });
          var z = ae(M, 4), R = Y(z);
          {
            let H = /* @__PURE__ */ K(() => ({
              table: e.context.table,
              columns: e.context.columns
            }));
            AS(R, {
              language: "sql",
              get sql() {
                return x(H);
              },
              class: "w-full h-full",
              get colorScheme() {
                return r();
              },
              get value() {
                return x(c);
              },
              onChange: (G) => ue(c, G, !0)
            });
          }
          J(z);
          var N = ae(z, 2), I = Y(N);
          {
            var B = (H) => {
              Tu(H, {
                label: "Update",
                onClick: async () => {
                  let G = await g();
                  G && (p(x(s).map((re) => re === x(u) ? G : re)), d());
                }
              });
            }, $ = (H) => {
              Tu(H, {
                label: "Add",
                onClick: async () => {
                  let G = await g();
                  G && (p([...x(s), G]), d());
                }
              });
            };
            Oe(I, (H) => {
              x(u) != null ? H(B) : H($, !1);
            });
          }
          var q = ae(I, 2);
          Tu(q, {
            label: "Cancel",
            onClick: () => {
              ue(u, null), ue(l, !1);
            }
          });
          var U = ae(q, 4);
          U.__click = () => ue(c, DL(e.context.filter.predicate(null)) ?? "", !0), J(N), J(O), X(A, O);
        };
        Oe(_, (A) => {
          x(l) && A(D);
        });
      }
      X(v, b);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
nn(["click"]);
var Vbe = /* @__PURE__ */ me("<option disabled selected> </option>"), Wbe = /* @__PURE__ */ me("<hr/>"), Gbe = /* @__PURE__ */ me("<option> </option>"), Kbe = /* @__PURE__ */ me('<label class="select-none flex items-center gap-2"><span class="text-slate-500 dark:text-slate-400 whitespace-nowrap"> </span> <select><!><!></select></label>'), Qbe = /* @__PURE__ */ me("<option disabled selected> </option>"), Xbe = /* @__PURE__ */ me("<hr/>"), Jbe = /* @__PURE__ */ me("<option> </option>"), Ybe = /* @__PURE__ */ me("<select><!><!></select>");
function Dh(t, e) {
  nt(e, !0);
  let r = ct(e, "label", 3, void 0), n = ct(e, "disabled", 3, !1), i = ct(e, "placeholder", 3, null), o = ct(e, "options", 19, () => []), s = ct(e, "onChange", 3, void 0), a = /* @__PURE__ */ De(void 0);
  const l = EL(), u = l + "_null", c = l + "_undefined", h = (k) => k === null ? u : k === void 0 ? c : k.toString(), d = (k) => k === u ? null : k === c ? void 0 : k;
  function p(k) {
    !s() || !x(a) || s()(d(x(a).value));
  }
  var g = kr(), v = Ve(g);
  {
    var y = (k) => {
      var C = Kbe(), S = Y(C), _ = Y(S, !0);
      J(S);
      var D = ae(S, 2);
      D.__change = p;
      var A = Y(D);
      {
        var O = (R) => {
          var N = Vbe(), I = Y(N, !0);
          J(N), N.value = (N.__value = null) ?? "", Ae(() => ut(I, i())), X(R, N);
        };
        Oe(A, (R) => {
          i() != null && R(O);
        });
      }
      var M = ae(A);
      Nt(M, 17, o, cr, (R, N) => {
        var I = kr(), B = Ve(I);
        {
          var $ = (U) => {
            var H = Wbe();
            X(U, H);
          }, q = (U) => {
            var H = Gbe(), G = Y(H, !0);
            J(H);
            var re = {};
            Ae(
              (ie) => {
                ut(G, x(N).label), re !== (re = ie) && (H.value = (H.__value = ie) ?? "");
              },
              [() => h(x(N).value)]
            ), X(U, H);
          };
          Oe(B, (U) => {
            x(N) === "---" ? U($) : U(q, !1);
          });
        }
        X(R, I);
      }), J(D), Qs(D, (R) => ue(a, R), () => x(a));
      var z;
      i1(D), J(C), Ae(
        (R) => {
          ut(_, r()), Yr(D, 1, `form-select rounded-md py-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 dark:text-slate-400 text-ellipsis ${e.class ?? "" ?? ""}`), D.disabled = n(), z !== (z = R) && (D.value = (D.__value = R) ?? "", yd(D, R));
        },
        [() => h(e.value)]
      ), X(k, C);
    }, b = (k) => {
      var C = Ybe();
      C.__change = p;
      var S = Y(C);
      {
        var _ = (O) => {
          var M = Qbe(), z = Y(M, !0);
          J(M), M.value = (M.__value = null) ?? "", Ae(() => ut(z, i())), X(O, M);
        };
        Oe(S, (O) => {
          i() != null && O(_);
        });
      }
      var D = ae(S);
      Nt(D, 17, o, cr, (O, M) => {
        var z = kr(), R = Ve(z);
        {
          var N = (B) => {
            var $ = Xbe();
            X(B, $);
          }, I = (B) => {
            var $ = Jbe(), q = Y($, !0);
            J($);
            var U = {};
            Ae(
              (H) => {
                ut(q, x(M).label), U !== (U = H) && ($.value = ($.__value = H) ?? "");
              },
              [() => h(x(M).value)]
            ), X(B, $);
          };
          Oe(R, (B) => {
            x(M) === "---" ? B(N) : B(I, !1);
          });
        }
        X(O, z);
      }), J(C), Qs(C, (O) => ue(a, O), () => x(a));
      var A;
      i1(C), Ae(
        (O) => {
          Yr(C, 1, `form-select rounded-md py-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 dark:text-slate-400 select-none text-ellipsis ${e.class ?? "" ?? ""}`), C.disabled = n(), A !== (A = O) && (C.value = (C.__value = O) ?? "", yd(C, O));
        },
        [() => h(e.value)]
      ), X(k, C);
    };
    Oe(v, (k) => {
      r() != null ? k(y) : k(b, !1);
    });
  }
  X(t, g), it();
}
nn(["change"]);
const Zbe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<line x1="15" y1="54" x2="15" y2="12" stroke="black" stroke-width="2"/>
<line x1="32" y1="53" x2="32" y2="10" stroke="black" stroke-width="2"/>
<line x1="49" y1="45" x2="49" y2="19" stroke="black" stroke-width="2"/>
<rect x="8" y="27" width="14" height="18" rx="3" fill="#007AFF"/>
<rect x="25" y="22" width="14" height="14" rx="3" fill="#007AFF"/>
<rect x="42" y="27" width="14" height="12" rx="3" fill="#007AFF"/>
</svg>
`, exe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="32" cy="28" r="2" fill="#007AFF"/>
<circle cx="32" cy="24" r="2" fill="#007AFF"/>
<circle cx="32" cy="20" r="2" fill="#007AFF"/>
<circle cx="36" cy="32" r="2" fill="#007AFF"/>
<circle cx="36" cy="28" r="2" fill="#007AFF"/>
<circle cx="36" cy="24" r="2" fill="#007AFF"/>
<circle cx="28" cy="32" r="2" fill="#007AFF"/>
<circle cx="28" cy="28" r="2" fill="#007AFF"/>
<circle cx="28" cy="24" r="2" fill="#007AFF"/>
<circle cx="28" cy="20" r="2" fill="#007AFF"/>
<circle cx="28" cy="16" r="2" fill="#007AFF"/>
<circle cx="44" cy="24" r="2" fill="#A3CFFF"/>
<circle cx="44" cy="20" r="2" fill="#A3CFFF"/>
<circle cx="44" cy="16" r="2" fill="#A3CFFF"/>
<circle cx="40" cy="20" r="2" fill="#A3CFFF"/>
<circle cx="40" cy="16" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="32" r="2" fill="#007AFF"/>
<circle cx="20" cy="28" r="2" fill="#007AFF"/>
<circle cx="20" cy="24" r="2" fill="#007AFF"/>
<circle cx="20" cy="20" r="2" fill="#3897FF"/>
<circle cx="20" cy="16" r="2" fill="#3897FF"/>
<circle cx="24" cy="32" r="2" fill="#007AFF"/>
<circle cx="24" cy="28" r="2" fill="#007AFF"/>
<circle cx="24" cy="24" r="2" fill="#007AFF"/>
<circle cx="24" cy="20" r="2" fill="#3897FF"/>
<circle cx="24" cy="16" r="2" fill="#3897FF"/>
<circle cx="16" cy="32" r="2" fill="#3897FF"/>
<circle cx="16" cy="28" r="2" fill="#3897FF"/>
<circle cx="16" cy="24" r="2" fill="#3897FF"/>
<circle cx="32" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="32" cy="36" r="2" fill="#007AFF"/>
<circle cx="36" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="36" cy="36" r="2" fill="#007AFF"/>
<circle cx="28" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="28" cy="36" r="2" fill="#007AFF"/>
<circle cx="44" cy="44" r="2" fill="#3897FF"/>
<circle cx="48" cy="44" r="2" fill="#3897FF"/>
<circle cx="48" cy="40" r="2" fill="#3897FF"/>
<circle cx="52" cy="32" r="2" fill="#A3CFFF"/>
<circle cx="52" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="32" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="28" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="52" cy="36" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="36" r="2" fill="#A3CFFF"/>
<circle cx="8" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="12" cy="32" r="2" fill="#3897FF"/>
<circle cx="12" cy="28" r="2" fill="#3897FF"/>
<circle cx="28" cy="8" r="2" fill="#A3CFFF"/>
<circle cx="48" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="48" cy="8" r="2" fill="#E0EFFF"/>
<circle cx="20" cy="12" r="2" fill="#A3CFFF"/>
<circle cx="24" cy="12" r="2" fill="#A3CFFF"/>
<circle cx="24" cy="8" r="2" fill="#A3CFFF"/>
<circle cx="52" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="8" r="2" fill="#E0EFFF"/>
<circle cx="8" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="12" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="32" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="32" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="36" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="28" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="28" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="44" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="40" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="20" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="24" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="24" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="16" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="12" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="8" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="12" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="12" cy="44" r="2" fill="#3897FF"/>
<circle cx="40" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="40" r="2" fill="#007AFF"/>
<circle cx="24" cy="36" r="2" fill="#007AFF"/>
<circle cx="16" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="16" cy="40" r="2" fill="#3897FF"/>
<circle cx="16" cy="36" r="2" fill="#3897FF"/>
</svg>
`, txe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="8" y="8" width="48" height="14" rx="3" fill="#007AFF"/>
<rect x="8" y="25" width="36" height="14" rx="3" fill="#007AFF"/>
<rect x="8" y="42" width="24" height="14" rx="3" fill="#007AFF"/>
</svg>
`, rxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="48" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="48" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.78"/>
<rect x="48" y="28" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="48" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.5"/>
<rect x="48" y="8" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="38" y="48" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.96"/>
<rect x="38" y="38" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="38" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.63"/>
<rect x="38" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.36"/>
<rect x="38" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.64"/>
<rect x="28" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="28" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.45"/>
<rect x="28" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.28"/>
<rect x="28" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.8"/>
<rect x="28" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.7"/>
<rect x="18" y="48" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.27"/>
<rect x="18" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.46"/>
<rect x="18" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.74"/>
<rect x="18" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.96"/>
<rect x="18" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.82"/>
<rect x="8" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="8" y="38" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="8" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.33"/>
<rect x="8" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.12"/>
<rect x="8" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.4"/>
</svg>
`, nxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M24.5966 37L26.2869 26.8182H29.7273C30.5227 26.8182 31.1508 26.9607 31.6115 27.2457C32.0755 27.5308 32.3887 27.9169 32.5511 28.4041C32.7169 28.8913 32.75 29.4366 32.6506 30.0398C32.5511 30.6364 32.3374 31.1799 32.0092 31.6705C31.6844 32.161 31.2436 32.5521 30.6868 32.8438C30.1333 33.1354 29.4621 33.2812 28.6733 33.2812H26.2074L26.3864 32.1875H28.8125C29.3561 32.1875 29.8101 32.093 30.1747 31.9041C30.5393 31.7152 30.8243 31.4583 31.0298 31.1335C31.2353 30.8087 31.3712 30.4441 31.4375 30.0398C31.5038 29.6288 31.4872 29.2642 31.3878 28.946C31.2917 28.6245 31.0911 28.3726 30.7862 28.1903C30.4846 28.0047 30.0587 27.9119 29.5085 27.9119H27.3409L25.8295 37H24.5966ZM33.3105 37L34.5833 29.3636H35.7168L35.5179 30.517H35.5975C35.7963 30.1392 36.0996 29.8326 36.5073 29.5973C36.915 29.362 37.3475 29.2443 37.8049 29.2443C37.8944 29.2443 38.0021 29.246 38.128 29.2493C38.254 29.2493 38.3517 29.2543 38.4213 29.2642L38.2225 30.4574C38.1827 30.4474 38.0932 30.4325 37.954 30.4126C37.8148 30.3894 37.6657 30.3778 37.5066 30.3778C37.1354 30.3778 36.7923 30.4557 36.4775 30.6115C36.1626 30.764 35.8991 30.9761 35.687 31.2479C35.4748 31.5163 35.339 31.8229 35.2793 32.1676L34.4838 37H33.3105ZM41.4963 37.1591C40.7638 37.1591 40.1589 36.9967 39.6816 36.6719C39.2044 36.3438 38.8713 35.8864 38.6824 35.2997C38.4934 34.7098 38.4636 34.0237 38.5929 33.2415C38.7221 32.4593 38.979 31.7699 39.3635 31.1733C39.7479 30.5734 40.2269 30.1061 40.8002 29.7713C41.3736 29.4332 42.0034 29.2642 42.6895 29.2642C43.0872 29.2642 43.47 29.3305 43.8379 29.4631C44.2058 29.5956 44.524 29.8111 44.7924 30.1094C45.0609 30.4044 45.2482 30.7955 45.3542 31.2827C45.4603 31.7699 45.4537 32.3698 45.3343 33.0824L45.2548 33.5795H39.3684L39.5275 32.5653H44.2207C44.2969 32.1345 44.277 31.75 44.161 31.4119C44.0484 31.0739 43.8511 30.8071 43.5694 30.6115C43.291 30.416 42.938 30.3182 42.5105 30.3182C42.0697 30.3182 41.6587 30.4375 41.2775 30.6761C40.8964 30.9115 40.5782 31.2098 40.323 31.571C40.0678 31.929 39.9087 32.2936 39.8457 32.6648L39.7065 33.5398C39.6071 34.1728 39.622 34.6766 39.7512 35.0511C39.8838 35.4257 40.1142 35.6958 40.4423 35.8615C40.7704 36.0239 41.1814 36.1051 41.6752 36.1051C41.9901 36.1051 42.2801 36.062 42.5453 35.9759C42.8104 35.8864 43.0474 35.7538 43.2562 35.5781C43.465 35.3991 43.6407 35.1771 43.7832 34.9119L44.8571 35.2301C44.6748 35.6146 44.4179 35.9527 44.0865 36.2443C43.7583 36.5327 43.3739 36.758 42.9331 36.9205C42.4956 37.0795 42.0166 37.1591 41.4963 37.1591ZM49.3638 37.1591C48.7241 37.1591 48.1872 36.9983 47.753 36.6768C47.3188 36.352 47.0123 35.8946 46.8333 35.3047C46.6576 34.7114 46.6361 34.0104 46.7686 33.2017C46.9045 32.3996 47.1581 31.7036 47.5293 31.1136C47.9038 30.5237 48.3629 30.0679 48.9064 29.7464C49.45 29.425 50.0433 29.2642 50.6863 29.2642C51.1834 29.2642 51.5629 29.3471 51.8248 29.5128C52.0899 29.6752 52.2821 29.8608 52.4015 30.0696C52.5208 30.2751 52.6119 30.4441 52.6749 30.5767H52.7743L53.4007 26.8182H54.574L52.8837 37H51.7502L51.949 35.8267H51.8098C51.7005 35.9659 51.548 36.1416 51.3525 36.3537C51.1569 36.5625 50.8984 36.7498 50.5769 36.9155C50.2587 37.0779 49.8543 37.1591 49.3638 37.1591ZM49.6522 36.1051C50.1228 36.1051 50.5437 35.9825 50.915 35.7372C51.2895 35.4886 51.601 35.1456 51.8496 34.7081C52.0982 34.2673 52.2705 33.7585 52.3667 33.1818C52.4628 32.6117 52.4595 32.1129 52.3567 31.6854C52.254 31.2545 52.0568 30.9197 51.7651 30.6811C51.4734 30.4392 51.0873 30.3182 50.6067 30.3182C50.1129 30.3182 49.6837 30.4458 49.3191 30.701C48.9545 30.9529 48.6578 31.2959 48.4292 31.7301C48.2005 32.161 48.0414 32.6449 47.9519 33.1818C47.8624 33.7254 47.8607 34.2192 47.9469 34.6634C48.0331 35.1042 48.2154 35.4555 48.4938 35.7173C48.7755 35.9759 49.1616 36.1051 49.6522 36.1051Z" fill="#007AFF"/>
<path d="M24.5966 20L26.2869 9.81818H29.7273C30.5227 9.81818 31.1508 9.9607 31.6115 10.2457C32.0755 10.5308 32.3887 10.9169 32.5511 11.4041C32.7169 11.8913 32.75 12.4366 32.6506 13.0398C32.5511 13.6364 32.3374 14.1799 32.0092 14.6705C31.6844 15.161 31.2436 15.5521 30.6868 15.8438C30.1333 16.1354 29.4621 16.2812 28.6733 16.2812H26.2074L26.3864 15.1875H28.8125C29.3561 15.1875 29.8101 15.093 30.1747 14.9041C30.5393 14.7152 30.8243 14.4583 31.0298 14.1335C31.2353 13.8087 31.3712 13.4441 31.4375 13.0398C31.5038 12.6288 31.4872 12.2642 31.3878 11.946C31.2917 11.6245 31.0911 11.3726 30.7862 11.1903C30.4846 11.0047 30.0587 10.9119 29.5085 10.9119H27.3409L25.8295 20H24.5966ZM33.3105 20L34.5833 12.3636H35.7168L35.5179 13.517H35.5975C35.7963 13.1392 36.0996 12.8326 36.5073 12.5973C36.915 12.362 37.3475 12.2443 37.8049 12.2443C37.8944 12.2443 38.0021 12.246 38.128 12.2493C38.254 12.2493 38.3517 12.2543 38.4213 12.2642L38.2225 13.4574C38.1827 13.4474 38.0932 13.4325 37.954 13.4126C37.8148 13.3894 37.6657 13.3778 37.5066 13.3778C37.1354 13.3778 36.7923 13.4557 36.4775 13.6115C36.1626 13.764 35.8991 13.9761 35.687 14.2479C35.4748 14.5163 35.339 14.8229 35.2793 15.1676L34.4838 20H33.3105ZM41.4963 20.1591C40.7638 20.1591 40.1589 19.9967 39.6816 19.6719C39.2044 19.3438 38.8713 18.8864 38.6824 18.2997C38.4934 17.7098 38.4636 17.0237 38.5929 16.2415C38.7221 15.4593 38.979 14.7699 39.3635 14.1733C39.7479 13.5734 40.2269 13.1061 40.8002 12.7713C41.3736 12.4332 42.0034 12.2642 42.6895 12.2642C43.0872 12.2642 43.47 12.3305 43.8379 12.4631C44.2058 12.5956 44.524 12.8111 44.7924 13.1094C45.0609 13.4044 45.2482 13.7955 45.3542 14.2827C45.4603 14.7699 45.4537 15.3698 45.3343 16.0824L45.2548 16.5795H39.3684L39.5275 15.5653H44.2207C44.2969 15.1345 44.277 14.75 44.161 14.4119C44.0484 14.0739 43.8511 13.8071 43.5694 13.6115C43.291 13.416 42.938 13.3182 42.5105 13.3182C42.0697 13.3182 41.6587 13.4375 41.2775 13.6761C40.8964 13.9115 40.5782 14.2098 40.323 14.571C40.0678 14.929 39.9087 15.2936 39.8457 15.6648L39.7065 16.5398C39.6071 17.1728 39.622 17.6766 39.7512 18.0511C39.8838 18.4257 40.1142 18.6958 40.4423 18.8615C40.7704 19.0239 41.1814 19.1051 41.6752 19.1051C41.9901 19.1051 42.2801 19.062 42.5453 18.9759C42.8104 18.8864 43.0474 18.7538 43.2562 18.5781C43.465 18.3991 43.6407 18.1771 43.7832 17.9119L44.8571 18.2301C44.6748 18.6146 44.4179 18.9527 44.0865 19.2443C43.7583 19.5327 43.3739 19.758 42.9331 19.9205C42.4956 20.0795 42.0166 20.1591 41.4963 20.1591ZM49.3638 20.1591C48.7241 20.1591 48.1872 19.9983 47.753 19.6768C47.3188 19.352 47.0123 18.8946 46.8333 18.3047C46.6576 17.7114 46.6361 17.0104 46.7686 16.2017C46.9045 15.3996 47.1581 14.7036 47.5293 14.1136C47.9038 13.5237 48.3629 13.0679 48.9064 12.7464C49.45 12.425 50.0433 12.2642 50.6863 12.2642C51.1834 12.2642 51.5629 12.3471 51.8248 12.5128C52.0899 12.6752 52.2821 12.8608 52.4015 13.0696C52.5208 13.2751 52.6119 13.4441 52.6749 13.5767H52.7743L53.4007 9.81818H54.574L52.8837 20H51.7502L51.949 18.8267H51.8098C51.7005 18.9659 51.548 19.1416 51.3525 19.3537C51.1569 19.5625 50.8984 19.7498 50.5769 19.9155C50.2587 20.0779 49.8543 20.1591 49.3638 20.1591ZM49.6522 19.1051C50.1228 19.1051 50.5437 18.9825 50.915 18.7372C51.2895 18.4886 51.601 18.1456 51.8496 17.7081C52.0982 17.2673 52.2705 16.7585 52.3667 16.1818C52.4628 15.6117 52.4595 15.1129 52.3567 14.6854C52.254 14.2545 52.0568 13.9197 51.7651 13.6811C51.4734 13.4392 51.0873 13.3182 50.6067 13.3182C50.1129 13.3182 49.6837 13.4458 49.3191 13.701C48.9545 13.9529 48.6578 14.2959 48.4292 14.7301C48.2005 15.161 48.0414 15.6449 47.9519 16.1818C47.8624 16.7254 47.8607 17.2192 47.9469 17.6634C48.0331 18.1042 48.2154 18.4555 48.4938 18.7173C48.7755 18.9759 49.1616 19.1051 49.6522 19.1051Z" fill="#007AFF" fill-opacity="0.25"/>
<path d="M24.5966 54L26.2869 43.8182H29.7273C30.5227 43.8182 31.1508 43.9607 31.6115 44.2457C32.0755 44.5308 32.3887 44.9169 32.5511 45.4041C32.7169 45.8913 32.75 46.4366 32.6506 47.0398C32.5511 47.6364 32.3374 48.1799 32.0092 48.6705C31.6844 49.161 31.2436 49.5521 30.6868 49.8438C30.1333 50.1354 29.4621 50.2812 28.6733 50.2812H26.2074L26.3864 49.1875H28.8125C29.3561 49.1875 29.8101 49.093 30.1747 48.9041C30.5393 48.7152 30.8243 48.4583 31.0298 48.1335C31.2353 47.8087 31.3712 47.4441 31.4375 47.0398C31.5038 46.6288 31.4872 46.2642 31.3878 45.946C31.2917 45.6245 31.0911 45.3726 30.7862 45.1903C30.4846 45.0047 30.0587 44.9119 29.5085 44.9119H27.3409L25.8295 54H24.5966ZM33.3105 54L34.5833 46.3636H35.7168L35.5179 47.517H35.5975C35.7963 47.1392 36.0996 46.8326 36.5073 46.5973C36.915 46.362 37.3475 46.2443 37.8049 46.2443C37.8944 46.2443 38.0021 46.246 38.128 46.2493C38.254 46.2493 38.3517 46.2543 38.4213 46.2642L38.2225 47.4574C38.1827 47.4474 38.0932 47.4325 37.954 47.4126C37.8148 47.3894 37.6657 47.3778 37.5066 47.3778C37.1354 47.3778 36.7923 47.4557 36.4775 47.6115C36.1626 47.764 35.8991 47.9761 35.687 48.2479C35.4748 48.5163 35.339 48.8229 35.2793 49.1676L34.4838 54H33.3105ZM41.4963 54.1591C40.7638 54.1591 40.1589 53.9967 39.6816 53.6719C39.2044 53.3438 38.8713 52.8864 38.6824 52.2997C38.4934 51.7098 38.4636 51.0237 38.5929 50.2415C38.7221 49.4593 38.979 48.7699 39.3635 48.1733C39.7479 47.5734 40.2269 47.1061 40.8002 46.7713C41.3736 46.4332 42.0034 46.2642 42.6895 46.2642C43.0872 46.2642 43.47 46.3305 43.8379 46.4631C44.2058 46.5956 44.524 46.8111 44.7924 47.1094C45.0609 47.4044 45.2482 47.7955 45.3542 48.2827C45.4603 48.7699 45.4537 49.3698 45.3343 50.0824L45.2548 50.5795H39.3684L39.5275 49.5653H44.2207C44.2969 49.1345 44.277 48.75 44.161 48.4119C44.0484 48.0739 43.8511 47.8071 43.5694 47.6115C43.291 47.416 42.938 47.3182 42.5105 47.3182C42.0697 47.3182 41.6587 47.4375 41.2775 47.6761C40.8964 47.9115 40.5782 48.2098 40.323 48.571C40.0678 48.929 39.9087 49.2936 39.8457 49.6648L39.7065 50.5398C39.6071 51.1728 39.622 51.6766 39.7512 52.0511C39.8838 52.4257 40.1142 52.6958 40.4423 52.8615C40.7704 53.0239 41.1814 53.1051 41.6752 53.1051C41.9901 53.1051 42.2801 53.062 42.5453 52.9759C42.8104 52.8864 43.0474 52.7538 43.2562 52.5781C43.465 52.3991 43.6407 52.1771 43.7832 51.9119L44.8571 52.2301C44.6748 52.6146 44.4179 52.9527 44.0865 53.2443C43.7583 53.5327 43.3739 53.758 42.9331 53.9205C42.4956 54.0795 42.0166 54.1591 41.4963 54.1591ZM49.3638 54.1591C48.7241 54.1591 48.1872 53.9983 47.753 53.6768C47.3188 53.352 47.0123 52.8946 46.8333 52.3047C46.6576 51.7114 46.6361 51.0104 46.7686 50.2017C46.9045 49.3996 47.1581 48.7036 47.5293 48.1136C47.9038 47.5237 48.3629 47.0679 48.9064 46.7464C49.45 46.425 50.0433 46.2642 50.6863 46.2642C51.1834 46.2642 51.5629 46.3471 51.8248 46.5128C52.0899 46.6752 52.2821 46.8608 52.4015 47.0696C52.5208 47.2751 52.6119 47.4441 52.6749 47.5767H52.7743L53.4007 43.8182H54.574L52.8837 54H51.7502L51.949 52.8267H51.8098C51.7005 52.9659 51.548 53.1416 51.3525 53.3537C51.1569 53.5625 50.8984 53.7498 50.5769 53.9155C50.2587 54.0779 49.8543 54.1591 49.3638 54.1591ZM49.6522 53.1051C50.1228 53.1051 50.5437 52.9825 50.915 52.7372C51.2895 52.4886 51.601 52.1456 51.8496 51.7081C52.0982 51.2673 52.2705 50.7585 52.3667 50.1818C52.4628 49.6117 52.4595 49.1129 52.3567 48.6854C52.254 48.2545 52.0568 47.9197 51.7651 47.6811C51.4734 47.4392 51.0873 47.3182 50.6067 47.3182C50.1129 47.3182 49.6837 47.4458 49.3191 47.701C48.9545 47.9529 48.6578 48.2959 48.4292 48.7301C48.2005 49.161 48.0414 49.6449 47.9519 50.1818C47.8624 50.7254 47.8607 51.2192 47.9469 51.6634C48.0331 52.1042 48.2154 52.4555 48.4938 52.7173C48.7755 52.9759 49.1616 53.1051 49.6522 53.1051Z" fill="#007AFF" fill-opacity="0.25"/>
<rect x="9" y="10" width="10" height="10" rx="3" fill="#007AFF" fill-opacity="0.25"/>
<rect x="9" y="27" width="10" height="10" rx="3" fill="#007AFF"/>
<rect x="9" y="44" width="10" height="10" rx="3" fill="#007AFF" fill-opacity="0.25"/>
</svg>
`, ixe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M28.1666 45.7042C28.9268 45.8901 29.611 45.5001 29.8329 44.7506L36.9814 20.6115C37.1728 19.9366 36.8385 19.2589 36.0783 19.0547C35.3333 18.8689 34.6979 19.1477 34.4425 20.0235L27.3365 44.0276C27.1175 44.7804 27.3579 45.5001 28.1666 45.7042Z" fill="black"/>
<path d="M12 32.3568C12 32.7499 12.1764 33.1396 12.5046 33.4216L22.0655 41.9466C22.6825 42.4776 23.4794 42.4744 23.9719 41.9287C24.4765 41.3647 24.3975 40.5639 23.829 40.0662L15.214 32.3568L23.829 24.6476C24.3975 24.1496 24.4765 23.3488 23.9719 22.7851C23.4794 22.2391 22.6825 22.2362 22.0655 22.7669L12.5046 31.2922C12.1764 31.5742 12 31.9639 12 32.3568ZM52.1638 32.3568C52.1638 31.9639 52.0027 31.5742 51.6742 31.2922L42.1015 22.7669C41.481 22.2362 40.6997 22.2391 40.1948 22.7851C39.6871 23.3488 39.7663 24.1496 40.3378 24.6476L48.968 32.3568L40.3378 40.0662C39.7663 40.5639 39.6871 41.3647 40.1948 41.9287C40.6997 42.4744 41.481 42.4776 42.1015 41.9466L51.6742 33.4216C52.0027 33.1396 52.1638 32.7499 52.1638 32.3568Z" fill="black"/>
</svg>
`, oxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 33H22V53C22 54.6569 20.6569 56 19 56H11C9.34315 56 8 54.6569 8 53V33Z" fill="#34C759"/>
<path d="M8 19C8 17.3431 9.34315 16 11 16H19C20.6569 16 22 17.3431 22 19V34H8V19Z" fill="#007AFF"/>
<path d="M25 39H39V53C39 54.6569 37.6569 56 36 56H28C26.3431 56 25 54.6569 25 53V39Z" fill="#34C759"/>
<path d="M42 32H56V53C56 54.6569 54.6569 56 53 56H45C43.3431 56 42 54.6569 42 53V32Z" fill="#34C759"/>
<path d="M25 29C25 27.3431 26.3431 26 28 26H36C37.6569 26 39 27.3431 39 29V40H25V29Z" fill="#3C82F6"/>
<path d="M42 16C42 14.3431 43.3431 13 45 13H53C54.6569 13 56 14.3431 56 16V33H42V16Z" fill="#007AFF"/>
</svg>
`, sxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="8" y="32" width="14" height="24" rx="3" fill="#007AFF"/>
<rect x="25" y="12" width="14" height="44" rx="3" fill="#007AFF"/>
<rect x="42" y="24" width="14" height="32" rx="3" fill="#007AFF"/>
</svg>
`, axe = {
  "chart-boxplot": Zbe,
  "chart-h-bar": txe,
  "chart-heatmap": rxe,
  "chart-embedding": exe,
  "chart-stacked": oxe,
  "chart-v-histogram": sxe,
  "chart-spec": ixe,
  "chart-predicates": nxe
};
var lxe = /* @__PURE__ */ me('<div class="w-12 h-12"><!></div>');
function uxe(t, e) {
  nt(e, !0);
  function r(o, s) {
    o = o.replace("xmlns", 'style="width:100%;height:100%" xmlns');
    let a = s == "dark" ? { black: $s.slate[400] } : { black: $s.slate[500] };
    for (let l in a)
      o = o.replaceAll(l, a[l]);
    return o;
  }
  var n = lxe(), i = Y(n);
  UQ(i, () => r(axe[e.type] ?? "", e.colorScheme ?? "light")), J(n), X(t, n), it();
}
var cxe = /* @__PURE__ */ me("<button><!></button>"), hxe = /* @__PURE__ */ me('<span class="text-slate-500 dark:text-slate-400"> </span> <!>', 1), fxe = /* @__PURE__ */ me('<div class="w-full h-64"><!></div>'), dxe = /* @__PURE__ */ me("<!> <!>", 1), pxe = /* @__PURE__ */ me('<div class="border-t border-b border-dotted border-slate-400 dark:border-slate-500 py-2 my-1"><div class="-m-2 rounded-md"><!></div></div>'), mxe = /* @__PURE__ */ me("<div> </div>"), gxe = /* @__PURE__ */ me('<div class="p-2 flex flex-col gap-2"><div class="flex flex-wrap gap-2"></div> <div> </div> <!> <!> <div><button>Confirm</button></div> <!></div>');
function vxe(t, e) {
  nt(e, !0);
  const r = () => mi(s, "$colorScheme", n), [n, i] = Xo();
  let { columns: o, colorScheme: s } = e.context, a = a_e(), l = /* @__PURE__ */ De(a[0]), u = /* @__PURE__ */ De(fs({})), c = /* @__PURE__ */ De(!1), h = /* @__PURE__ */ De(null), d = /* @__PURE__ */ De(null);
  mt(() => {
    x(l);
    let I = Go(() => x(u)), B = {};
    for (let $ of x(l).ui)
      if ("field" in $) {
        let q = y(o, $.field.types), U = I[$.field.key];
        U != null && q.findIndex(({ name: H }) => H == U) >= 0 && (B[$.field.key] = U);
      }
    ue(u, B, !0);
  }), mt(() => {
    try {
      let I = g();
      if (I == null) {
        ue(c, !1), ue(d, null), ue(h, null);
        return;
      }
      let B = x(l).create(I, { table: e.context.table, id: e.context.id });
      ue(c, B != null), ue(d, B), ue(h, null);
    } catch (I) {
      ue(c, I.toString(), !0);
    }
  });
  function p() {
    x(d) != null && (e.onSpecChange(x(d), "replace"), e.onStateChange(x(h) ?? {}, "replace"));
  }
  function g() {
    let I = { ...x(u) };
    for (let B of x(l).ui)
      if ("field" in B) {
        let $ = v(I[B.field.key]);
        if (B.field.required && $ == null)
          return;
        I[B.field.key] = $;
      }
    return I;
  }
  function v(I) {
    let B = o.find(($) => $.name == I);
    if (B == null || B.jsType == null)
      return null;
    switch (B.jsType) {
      case "number":
        return { name: B.name, type: "continuous" };
      case "string":
        return { name: B.name, type: "discrete" };
      case "string[]":
        return { name: B.name, type: "discrete[]" };
      default:
        return null;
    }
  }
  function y(I, B) {
    return B == null ? I.filter(($) => $.jsType != null) : I.filter(($) => $.jsType != null && B.indexOf($.jsType) >= 0);
  }
  var b = gxe(), k = Y(b);
  Nt(k, 21, () => a, cr, (I, B) => {
    const $ = /* @__PURE__ */ K(() => x(l) == x(B));
    var q = cxe();
    q.__click = () => {
      ue(l, x(B));
    };
    let U;
    var H = Y(q);
    uxe(H, {
      get type() {
        return x(B).icon;
      },
      get colorScheme() {
        return r();
      }
    }), J(q), Ae(() => {
      te(q, "title", x(B).description), U = Yr(q, 1, "rounded-md border border-slate-200 dark:border-slate-700", null, U, {
        "!border-slate-600": x($),
        "dark:!border-slate-400": x($),
        "!bg-slate-100": x($),
        "dark:!bg-slate-700": x($)
      });
    }), X(I, q);
  }), J(k);
  var C = ae(k, 2), S = Y(C, !0);
  J(C);
  var _ = ae(C, 2);
  Nt(_, 17, () => x(l).ui, cr, (I, B) => {
    var $ = dxe(), q = Ve($);
    {
      var U = (re) => {
        const ie = /* @__PURE__ */ K(() => x(B).field.key);
        var se = hxe(), ne = Ve(se), ce = Y(ne, !0);
        J(ne);
        var Ce = ae(ne, 2);
        {
          let Pe = /* @__PURE__ */ K(() => x(u)[x(ie)] ?? null), Me = /* @__PURE__ */ K(() => y(o, x(B).field.types).map((_e) => ({ value: _e.name, label: `${_e.name} (${_e.type})` })));
          Dh(Ce, {
            get value() {
              return x(Pe);
            },
            onChange: (_e) => x(u)[x(ie)] = _e,
            placeholder: "(select field)",
            class: "w-full",
            get options() {
              return x(Me);
            }
          });
        }
        Ae(() => ut(ce, x(B).field.label)), X(re, se);
      };
      Oe(q, (re) => {
        "field" in x(B) && re(U);
      });
    }
    var H = ae(q, 2);
    {
      var G = (re) => {
        const ie = /* @__PURE__ */ K(() => x(B).code.key);
        var se = fxe(), ne = Y(se);
        {
          let ce = /* @__PURE__ */ K(() => x(B).code.language ?? "plain");
          AS(ne, {
            class: "w-full h-full",
            get value() {
              return x(u)[x(ie)];
            },
            onChange: (Ce) => x(u)[x(ie)] = Ce,
            get colorScheme() {
              return r();
            },
            get language() {
              return x(ce);
            }
          });
        }
        J(se), X(re, se);
      };
      Oe(H, (re) => {
        "code" in x(B) && re(G);
      });
    }
    X(I, $);
  });
  var D = ae(_, 2);
  {
    var A = (I) => {
      var B = kr(), $ = Ve(B);
      _T($, () => x(d), (q) => {
        var U = pxe(), H = Y(U), G = Y(H);
        {
          let re = /* @__PURE__ */ K(() => x(h) ?? {});
          uj(G, {
            get context() {
              return e.context;
            },
            get spec() {
              return x(d);
            },
            get state() {
              return x(re);
            },
            width: "container",
            onStateChange: (ie, se = "merge") => {
              pd(x(h) ?? {}, ie, se, (ne) => ue(h, ne));
            },
            onSpecChange: (ie, se = "merge") => {
              pd(x(d) ?? {}, ie, se, (ne) => ue(d, ne));
            }
          });
        }
        J(H), J(U), X(q, U);
      }), X(I, B);
    };
    Oe(D, (I) => {
      x(d) != null && x(l).preview !== !1 && I(A);
    });
  }
  var O = ae(D, 2), M = Y(O);
  let z;
  M.__click = p, J(O);
  var R = ae(O, 2);
  {
    var N = (I) => {
      var B = mxe(), $ = Y(B, !0);
      J(B), Ae(() => ut($, x(c))), X(I, B);
    };
    Oe(R, (I) => {
      typeof x(c) == "string" && x(c).trim() != "" && I(N);
    });
  }
  J(b), Ae(() => {
    ut(S, x(l).description), z = Yr(M, 1, "px-2 h-8 w-24 rounded-md text-white text-sm", null, z, {
      "bg-blue-500": x(c) === !0,
      "bg-gray-300": x(c) !== !0,
      "dark:text-gray-500": x(c) !== !0,
      "dark:bg-gray-700": x(c) !== !0
    }), M.disabled = x(c) !== !0;
  }), X(t, b), it(), i();
}
nn(["click"]);
var yxe = /* @__PURE__ */ Dt('<line class="stroke-orange-500"></line>'), bxe = /* @__PURE__ */ Dt('<circle class="fill-orange-500 stroke-orange-700 stroke-2"></circle>'), xxe = /* @__PURE__ */ Dt("<svg><g><!><!></g></svg>");
function wxe(t, e) {
  nt(e, !0);
  var r = xxe(), n = Y(r), i = Y(n);
  {
    var o = (a) => {
      const l = /* @__PURE__ */ K(() => e.proxy.location(e.center.x, e.center.y));
      var u = kr(), c = Ve(u);
      Nt(c, 17, () => e.points ?? [], cr, (h, d) => {
        const p = /* @__PURE__ */ K(() => e.proxy.location(x(d).x, x(d).y));
        var g = yxe();
        Ae(() => {
          te(g, "x1", x(l).x), te(g, "y1", x(l).y), te(g, "x2", x(p).x), te(g, "y2", x(p).y);
        }), X(h, g);
      }), X(a, u);
    };
    Oe(i, (a) => {
      e.center != null && a(o);
    });
  }
  var s = ae(i);
  Nt(s, 17, () => e.points ?? [], cr, (a, l) => {
    const u = /* @__PURE__ */ K(() => e.proxy.location(x(l).x, x(l).y));
    var c = bxe();
    te(c, "r", 4), Ae(() => {
      te(c, "cx", x(u).x), te(c, "cy", x(u).y);
    }), X(a, c);
  }), J(n), J(r), Ae(() => {
    te(r, "width", e.proxy.width), te(r, "height", e.proxy.height);
  }), X(t, r), it();
}
function kxe(t) {
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
function Cxe(t) {
  const e = atob(t);
  return new Uint8Array([...e].map((r) => r.charCodeAt(0)));
}
function kf(t, e) {
  if (t.length < e.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (t[r] != e[r])
      return !1;
  return !0;
}
function yO(t) {
  return kf(t, [137, 80, 78, 71, 13, 10, 26, 10]) ? "image/png" : kf(t, [255, 216, 255]) ? "image/jpeg" : kf(t, [73, 73, 42, 0]) ? "image/tiff" : kf(t, [66, 77]) ? "image/bmp" : kf(t, [71, 73, 70, 56, 55, 97]) || kf(t, [71, 73, 70, 56, 55, 97]) ? "image/gif" : "application/octet-stream";
}
function PL(t) {
  if (t == null)
    return null;
  if (typeof t == "string")
    return t.startsWith("data:") ? t : `data:${yO(Cxe(t))};base64,` + t;
  {
    let e = null;
    if (t.bytes && t.bytes instanceof Uint8Array && (e = t.bytes), t instanceof Uint8Array && (e = t), e != null)
      return `data:${yO(e)};base64,` + kxe(e);
  }
  return null;
}
class _xe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    if (e.value == null) {
      this.element.innerText = "(null)";
      return;
    }
    let r = PL(e.value);
    if (r != null) {
      let n = e.size ?? 100, i = document.createElement("img");
      i.src = r, i.style.maxHeight = n + "px", i.style.maxWidth = n + "px", this.element.replaceChildren(i);
    } else
      this.element.innerText = "(unknown)";
  }
}
function RL(t, e) {
  try {
    return JSON.stringify(
      t,
      (r, n) => n instanceof Object && ArrayBuffer.isView(n) ? Array.from(n) : n,
      e
    );
  } catch {
    return "(invalid)";
  }
}
class Sxe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    let r = document.createElement("pre");
    r.className = "text-sm", r.style.whiteSpace = "pre-wrap", r.style.wordBreak = "break-all", r.innerText = RL(e.value, 2), this.element.replaceChildren(r);
  }
}
function JS() {
  return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
}
var Xh = JS();
function NL(t) {
  Xh = t;
}
var zm = { exec: () => null };
function ar(t, e = "") {
  let r = typeof t == "string" ? t : t.source, n = { replace: (i, o) => {
    let s = typeof o == "string" ? o : o.source;
    return s = s.replace(Ri.caret, "$1"), r = r.replace(i, s), n;
  }, getRegex: () => new RegExp(r, e) };
  return n;
}
var Axe = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return !1;
  }
})(), Ri = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`), htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i") }, Exe = /^(?:[ \t]*(?:\n|$))+/, Dxe = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Oxe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, x0 = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Fxe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, YS = /(?:[*+-]|\d{1,9}[.)])/, $L = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, IL = ar($L).replace(/bull/g, YS).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Txe = ar($L).replace(/bull/g, YS).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), ZS = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Mxe = /^[^\n]+/, e5 = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, Pxe = ar(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", e5).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Rxe = ar(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, YS).getRegex(), Tx = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", t5 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Nxe = ar("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", t5).replace("tag", Tx).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), BL = ar(ZS).replace("hr", x0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Tx).getRegex(), $xe = ar(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", BL).getRegex(), r5 = { blockquote: $xe, code: Dxe, def: Pxe, fences: Oxe, heading: Fxe, hr: x0, html: Nxe, lheading: IL, list: Rxe, newline: Exe, paragraph: BL, table: zm, text: Mxe }, bO = ar("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", x0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Tx).getRegex(), Ixe = { ...r5, lheading: Txe, table: bO, paragraph: ar(ZS).replace("hr", x0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", bO).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Tx).getRegex() }, Bxe = { ...r5, html: ar(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", t5).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: zm, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: ar(ZS).replace("hr", x0).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", IL).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Lxe = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, zxe = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, LL = /^( {2,}|\\)\n(?!\s*$)/, jxe = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, Mx = /[\p{P}\p{S}]/u, n5 = /[\s\p{P}\p{S}]/u, zL = /[^\s\p{P}\p{S}]/u, qxe = ar(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, n5).getRegex(), jL = /(?!~)[\p{P}\p{S}]/u, Uxe = /(?!~)[\s\p{P}\p{S}]/u, Hxe = /(?:[^\s\p{P}\p{S}]|~)/u, Vxe = ar(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", Axe ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), qL = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, Wxe = ar(qL, "u").replace(/punct/g, Mx).getRegex(), Gxe = ar(qL, "u").replace(/punct/g, jL).getRegex(), UL = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Kxe = ar(UL, "gu").replace(/notPunctSpace/g, zL).replace(/punctSpace/g, n5).replace(/punct/g, Mx).getRegex(), Qxe = ar(UL, "gu").replace(/notPunctSpace/g, Hxe).replace(/punctSpace/g, Uxe).replace(/punct/g, jL).getRegex(), Xxe = ar("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, zL).replace(/punctSpace/g, n5).replace(/punct/g, Mx).getRegex(), Jxe = ar(/\\(punct)/, "gu").replace(/punct/g, Mx).getRegex(), Yxe = ar(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Zxe = ar(t5).replace("(?:-->|$)", "-->").getRegex(), ewe = ar("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Zxe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), hb = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, twe = ar(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", hb).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), HL = ar(/^!?\[(label)\]\[(ref)\]/).replace("label", hb).replace("ref", e5).getRegex(), VL = ar(/^!?\[(ref)\](?:\[\])?/).replace("ref", e5).getRegex(), rwe = ar("reflink|nolink(?!\\()", "g").replace("reflink", HL).replace("nolink", VL).getRegex(), xO = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, i5 = { _backpedal: zm, anyPunctuation: Jxe, autolink: Yxe, blockSkip: Vxe, br: LL, code: zxe, del: zm, emStrongLDelim: Wxe, emStrongRDelimAst: Kxe, emStrongRDelimUnd: Xxe, escape: Lxe, link: twe, nolink: VL, punctuation: qxe, reflink: HL, reflinkSearch: rwe, tag: ewe, text: jxe, url: zm }, nwe = { ...i5, link: ar(/^!?\[(label)\]\((.*?)\)/).replace("label", hb).getRegex(), reflink: ar(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", hb).getRegex() }, f_ = { ...i5, emStrongRDelimAst: Qxe, emStrongLDelim: Gxe, url: ar(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", xO).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: ar(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", xO).getRegex() }, iwe = { ...f_, br: ar(LL).replace("{2,}", "*").getRegex(), text: ar(f_.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, by = { normal: r5, gfm: Ixe, pedantic: Bxe }, sm = { normal: i5, gfm: f_, breaks: iwe, pedantic: nwe }, owe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, wO = (t) => owe[t];
function ba(t, e) {
  if (e) {
    if (Ri.escapeTest.test(t)) return t.replace(Ri.escapeReplace, wO);
  } else if (Ri.escapeTestNoEncode.test(t)) return t.replace(Ri.escapeReplaceNoEncode, wO);
  return t;
}
function kO(t) {
  try {
    t = encodeURI(t).replace(Ri.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function CO(t, e) {
  let r = t.replace(Ri.findPipe, (o, s, a) => {
    let l = !1, u = s;
    for (; --u >= 0 && a[u] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), n = r.split(Ri.splitPipe), i = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; i < n.length; i++) n[i] = n[i].trim().replace(Ri.slashPipe, "|");
  return n;
}
function am(t, e, r) {
  let n = t.length;
  if (n === 0) return "";
  let i = 0;
  for (; i < n && t.charAt(n - i - 1) === e; )
    i++;
  return t.slice(0, n - i);
}
function swe(t, e) {
  if (t.indexOf(e[1]) === -1) return -1;
  let r = 0;
  for (let n = 0; n < t.length; n++) if (t[n] === "\\") n++;
  else if (t[n] === e[0]) r++;
  else if (t[n] === e[1] && (r--, r < 0)) return n;
  return r > 0 ? -2 : -1;
}
function _O(t, e, r, n, i) {
  let o = e.href, s = e.title || null, a = t[1].replace(i.other.outputLinkReplace, "$1");
  n.state.inLink = !0;
  let l = { type: t[0].charAt(0) === "!" ? "image" : "link", raw: r, href: o, title: s, text: a, tokens: n.inlineTokens(a) };
  return n.state.inLink = !1, l;
}
function awe(t, e, r) {
  let n = t.match(r.other.indentCodeCompensation);
  if (n === null) return e;
  let i = n[1];
  return e.split(`
`).map((o) => {
    let s = o.match(r.other.beginningSpace);
    if (s === null) return o;
    let [a] = s;
    return a.length >= i.length ? o.slice(i.length) : o;
  }).join(`
`);
}
var fb = class {
  options;
  rules;
  lexer;
  constructor(t) {
    this.options = t || Xh;
  }
  space(t) {
    let e = this.rules.block.newline.exec(t);
    if (e && e[0].length > 0) return { type: "space", raw: e[0] };
  }
  code(t) {
    let e = this.rules.block.code.exec(t);
    if (e) {
      let r = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: e[0], codeBlockStyle: "indented", text: this.options.pedantic ? r : am(r, `
`) };
    }
  }
  fences(t) {
    let e = this.rules.block.fences.exec(t);
    if (e) {
      let r = e[0], n = awe(r, e[3] || "", this.rules);
      return { type: "code", raw: r, lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2], text: n };
    }
  }
  heading(t) {
    let e = this.rules.block.heading.exec(t);
    if (e) {
      let r = e[2].trim();
      if (this.rules.other.endingHash.test(r)) {
        let n = am(r, "#");
        (this.options.pedantic || !n || this.rules.other.endingSpaceChar.test(n)) && (r = n.trim());
      }
      return { type: "heading", raw: e[0], depth: e[1].length, text: r, tokens: this.lexer.inline(r) };
    }
  }
  hr(t) {
    let e = this.rules.block.hr.exec(t);
    if (e) return { type: "hr", raw: am(e[0], `
`) };
  }
  blockquote(t) {
    let e = this.rules.block.blockquote.exec(t);
    if (e) {
      let r = am(e[0], `
`).split(`
`), n = "", i = "", o = [];
      for (; r.length > 0; ) {
        let s = !1, a = [], l;
        for (l = 0; l < r.length; l++) if (this.rules.other.blockquoteStart.test(r[l])) a.push(r[l]), s = !0;
        else if (!s) a.push(r[l]);
        else break;
        r = r.slice(l);
        let u = a.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        n = n ? `${n}
${u}` : u, i = i ? `${i}
${c}` : c;
        let h = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(c, o, !0), this.lexer.state.top = h, r.length === 0) break;
        let d = o.at(-1);
        if (d?.type === "code") break;
        if (d?.type === "blockquote") {
          let p = d, g = p.raw + `
` + r.join(`
`), v = this.blockquote(g);
          o[o.length - 1] = v, n = n.substring(0, n.length - p.raw.length) + v.raw, i = i.substring(0, i.length - p.text.length) + v.text;
          break;
        } else if (d?.type === "list") {
          let p = d, g = p.raw + `
` + r.join(`
`), v = this.list(g);
          o[o.length - 1] = v, n = n.substring(0, n.length - d.raw.length) + v.raw, i = i.substring(0, i.length - p.raw.length) + v.raw, r = g.substring(o.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: n, tokens: o, text: i };
    }
  }
  list(t) {
    let e = this.rules.block.list.exec(t);
    if (e) {
      let r = e[1].trim(), n = r.length > 1, i = { type: "list", raw: "", ordered: n, start: n ? +r.slice(0, -1) : "", loose: !1, items: [] };
      r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = n ? r : "[*+-]");
      let o = this.rules.other.listItemRegex(r), s = !1;
      for (; t; ) {
        let l = !1, u = "", c = "";
        if (!(e = o.exec(t)) || this.rules.block.hr.test(t)) break;
        u = e[0], t = t.substring(u.length);
        let h = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (b) => " ".repeat(3 * b.length)), d = t.split(`
`, 1)[0], p = !h.trim(), g = 0;
        if (this.options.pedantic ? (g = 2, c = h.trimStart()) : p ? g = e[1].length + 1 : (g = e[2].search(this.rules.other.nonSpaceChar), g = g > 4 ? 1 : g, c = h.slice(g), g += e[1].length), p && this.rules.other.blankLine.test(d) && (u += d + `
`, t = t.substring(d.length + 1), l = !0), !l) {
          let b = this.rules.other.nextBulletRegex(g), k = this.rules.other.hrRegex(g), C = this.rules.other.fencesBeginRegex(g), S = this.rules.other.headingBeginRegex(g), _ = this.rules.other.htmlBeginRegex(g);
          for (; t; ) {
            let D = t.split(`
`, 1)[0], A;
            if (d = D, this.options.pedantic ? (d = d.replace(this.rules.other.listReplaceNesting, "  "), A = d) : A = d.replace(this.rules.other.tabCharGlobal, "    "), C.test(d) || S.test(d) || _.test(d) || b.test(d) || k.test(d)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= g || !d.trim()) c += `
` + A.slice(g);
            else {
              if (p || h.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || C.test(h) || S.test(h) || k.test(h)) break;
              c += `
` + d;
            }
            !p && !d.trim() && (p = !0), u += D + `
`, t = t.substring(D.length + 1), h = A.slice(g);
          }
        }
        i.loose || (s ? i.loose = !0 : this.rules.other.doubleBlankLine.test(u) && (s = !0));
        let v = null, y;
        this.options.gfm && (v = this.rules.other.listIsTask.exec(c), v && (y = v[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: u, task: !!v, checked: y, loose: !1, text: c, tokens: [] }), i.raw += u;
      }
      let a = i.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let l = 0; l < i.items.length; l++) if (this.lexer.state.top = !1, i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, []), !i.loose) {
        let u = i.items[l].tokens.filter((h) => h.type === "space"), c = u.length > 0 && u.some((h) => this.rules.other.anyLine.test(h.raw));
        i.loose = c;
      }
      if (i.loose) for (let l = 0; l < i.items.length; l++) i.items[l].loose = !0;
      return i;
    }
  }
  html(t) {
    let e = this.rules.block.html.exec(t);
    if (e) return { type: "html", block: !0, raw: e[0], pre: e[1] === "pre" || e[1] === "script" || e[1] === "style", text: e[0] };
  }
  def(t) {
    let e = this.rules.block.def.exec(t);
    if (e) {
      let r = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), n = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return { type: "def", tag: r, raw: e[0], href: n, title: i };
    }
  }
  table(t) {
    let e = this.rules.block.table.exec(t);
    if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
    let r = CO(e[1]), n = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = e[3]?.trim() ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], o = { type: "table", raw: e[0], header: [], align: [], rows: [] };
    if (r.length === n.length) {
      for (let s of n) this.rules.other.tableAlignRight.test(s) ? o.align.push("right") : this.rules.other.tableAlignCenter.test(s) ? o.align.push("center") : this.rules.other.tableAlignLeft.test(s) ? o.align.push("left") : o.align.push(null);
      for (let s = 0; s < r.length; s++) o.header.push({ text: r[s], tokens: this.lexer.inline(r[s]), header: !0, align: o.align[s] });
      for (let s of i) o.rows.push(CO(s, o.header.length).map((a, l) => ({ text: a, tokens: this.lexer.inline(a), header: !1, align: o.align[l] })));
      return o;
    }
  }
  lheading(t) {
    let e = this.rules.block.lheading.exec(t);
    if (e) return { type: "heading", raw: e[0], depth: e[2].charAt(0) === "=" ? 1 : 2, text: e[1], tokens: this.lexer.inline(e[1]) };
  }
  paragraph(t) {
    let e = this.rules.block.paragraph.exec(t);
    if (e) {
      let r = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return { type: "paragraph", raw: e[0], text: r, tokens: this.lexer.inline(r) };
    }
  }
  text(t) {
    let e = this.rules.block.text.exec(t);
    if (e) return { type: "text", raw: e[0], text: e[0], tokens: this.lexer.inline(e[0]) };
  }
  escape(t) {
    let e = this.rules.inline.escape.exec(t);
    if (e) return { type: "escape", raw: e[0], text: e[1] };
  }
  tag(t) {
    let e = this.rules.inline.tag.exec(t);
    if (e) return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: e[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: e[0] };
  }
  link(t) {
    let e = this.rules.inline.link.exec(t);
    if (e) {
      let r = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
        if (!this.rules.other.endAngleBracket.test(r)) return;
        let o = am(r.slice(0, -1), "\\");
        if ((r.length - o.length) % 2 === 0) return;
      } else {
        let o = swe(e[2], "()");
        if (o === -2) return;
        if (o > -1) {
          let s = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + o;
          e[2] = e[2].substring(0, o), e[0] = e[0].substring(0, s).trim(), e[3] = "";
        }
      }
      let n = e[2], i = "";
      if (this.options.pedantic) {
        let o = this.rules.other.pedanticHrefTitle.exec(n);
        o && (n = o[1], i = o[3]);
      } else i = e[3] ? e[3].slice(1, -1) : "";
      return n = n.trim(), this.rules.other.startAngleBracket.test(n) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? n = n.slice(1) : n = n.slice(1, -1)), _O(e, { href: n && n.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, e[0], this.lexer, this.rules);
    }
  }
  reflink(t, e) {
    let r;
    if ((r = this.rules.inline.reflink.exec(t)) || (r = this.rules.inline.nolink.exec(t))) {
      let n = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = e[n.toLowerCase()];
      if (!i) {
        let o = r[0].charAt(0);
        return { type: "text", raw: o, text: o };
      }
      return _O(r, i, r[0], this.lexer, this.rules);
    }
  }
  emStrong(t, e, r = "") {
    let n = this.rules.inline.emStrongLDelim.exec(t);
    if (!(!n || n[3] && r.match(this.rules.other.unicodeAlphaNumeric)) && (!(n[1] || n[2]) || !r || this.rules.inline.punctuation.exec(r))) {
      let i = [...n[0]].length - 1, o, s, a = i, l = 0, u = n[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (u.lastIndex = 0, e = e.slice(-1 * t.length + i); (n = u.exec(e)) != null; ) {
        if (o = n[1] || n[2] || n[3] || n[4] || n[5] || n[6], !o) continue;
        if (s = [...o].length, n[3] || n[4]) {
          a += s;
          continue;
        } else if ((n[5] || n[6]) && i % 3 && !((i + s) % 3)) {
          l += s;
          continue;
        }
        if (a -= s, a > 0) continue;
        s = Math.min(s, s + a + l);
        let c = [...n[0]][0].length, h = t.slice(0, i + n.index + c + s);
        if (Math.min(i, s) % 2) {
          let p = h.slice(1, -1);
          return { type: "em", raw: h, text: p, tokens: this.lexer.inlineTokens(p) };
        }
        let d = h.slice(2, -2);
        return { type: "strong", raw: h, text: d, tokens: this.lexer.inlineTokens(d) };
      }
    }
  }
  codespan(t) {
    let e = this.rules.inline.code.exec(t);
    if (e) {
      let r = e[2].replace(this.rules.other.newLineCharGlobal, " "), n = this.rules.other.nonSpaceChar.test(r), i = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r);
      return n && i && (r = r.substring(1, r.length - 1)), { type: "codespan", raw: e[0], text: r };
    }
  }
  br(t) {
    let e = this.rules.inline.br.exec(t);
    if (e) return { type: "br", raw: e[0] };
  }
  del(t) {
    let e = this.rules.inline.del.exec(t);
    if (e) return { type: "del", raw: e[0], text: e[2], tokens: this.lexer.inlineTokens(e[2]) };
  }
  autolink(t) {
    let e = this.rules.inline.autolink.exec(t);
    if (e) {
      let r, n;
      return e[2] === "@" ? (r = e[1], n = "mailto:" + r) : (r = e[1], n = r), { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  url(t) {
    let e;
    if (e = this.rules.inline.url.exec(t)) {
      let r, n;
      if (e[2] === "@") r = e[0], n = "mailto:" + r;
      else {
        let i;
        do
          i = e[0], e[0] = this.rules.inline._backpedal.exec(e[0])?.[0] ?? "";
        while (i !== e[0]);
        r = e[0], e[1] === "www." ? n = "http://" + e[0] : n = e[0];
      }
      return { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  inlineText(t) {
    let e = this.rules.inline.text.exec(t);
    if (e) {
      let r = this.lexer.state.inRawBlock;
      return { type: "text", raw: e[0], text: e[0], escaped: r };
    }
  }
}, Ls = class d_ {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Xh, this.options.tokenizer = this.options.tokenizer || new fb(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    let r = { other: Ri, block: by.normal, inline: sm.normal };
    this.options.pedantic ? (r.block = by.pedantic, r.inline = sm.pedantic) : this.options.gfm && (r.block = by.gfm, this.options.breaks ? r.inline = sm.breaks : r.inline = sm.gfm), this.tokenizer.rules = r;
  }
  static get rules() {
    return { block: by, inline: sm };
  }
  static lex(e, r) {
    return new d_(r).lex(e);
  }
  static lexInline(e, r) {
    return new d_(r).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Ri.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      let n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = !1) {
    for (this.options.pedantic && (e = e.replace(Ri.tabCharGlobal, "    ").replace(Ri.spaceLine, "")); e; ) {
      let i;
      if (this.options.extensions?.block?.some((s) => (i = s.call({ lexer: this }, e, r)) ? (e = e.substring(i.raw.length), r.push(i), !0) : !1)) continue;
      if (i = this.tokenizer.space(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        i.raw.length === 1 && s !== void 0 ? s.raw += `
` : r.push(i);
        continue;
      }
      if (i = this.tokenizer.code(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (i = this.tokenizer.fences(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.heading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.hr(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.blockquote(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.list(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.html(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.def(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title }, r.push(i));
        continue;
      }
      if (i = this.tokenizer.table(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.lheading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      let o = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, a = e.slice(1), l;
        this.options.extensions.startBlock.forEach((u) => {
          l = u.call({ lexer: this }, a), typeof l == "number" && l >= 0 && (s = Math.min(s, l));
        }), s < 1 / 0 && s >= 0 && (o = e.substring(0, s + 1));
      }
      if (this.state.top && (i = this.tokenizer.paragraph(o))) {
        let s = r.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i), n = o.length !== e.length, e = e.substring(i.raw.length);
        continue;
      }
      if (i = this.tokenizer.text(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = !0, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  inlineTokens(e, r = []) {
    let n = e, i = null;
    if (this.tokens.links) {
      let l = Object.keys(this.tokens.links);
      if (l.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) l.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, i.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let o;
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) o = i[2] ? i[2].length : 0, n = n.slice(0, i.index + o) + "[" + "a".repeat(i[0].length - o - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let s = !1, a = "";
    for (; e; ) {
      s || (a = ""), s = !1;
      let l;
      if (this.options.extensions?.inline?.some((c) => (l = c.call({ lexer: this }, e, r)) ? (e = e.substring(l.raw.length), r.push(l), !0) : !1)) continue;
      if (l = this.tokenizer.escape(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.tag(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.link(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(l.raw.length);
        let c = r.at(-1);
        l.type === "text" && c?.type === "text" ? (c.raw += l.raw, c.text += l.text) : r.push(l);
        continue;
      }
      if (l = this.tokenizer.emStrong(e, n, a)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.codespan(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.br(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.del(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.autolink(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (!this.state.inLink && (l = this.tokenizer.url(e))) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      let u = e;
      if (this.options.extensions?.startInline) {
        let c = 1 / 0, h = e.slice(1), d;
        this.options.extensions.startInline.forEach((p) => {
          d = p.call({ lexer: this }, h), typeof d == "number" && d >= 0 && (c = Math.min(c, d));
        }), c < 1 / 0 && c >= 0 && (u = e.substring(0, c + 1));
      }
      if (l = this.tokenizer.inlineText(u)) {
        e = e.substring(l.raw.length), l.raw.slice(-1) !== "_" && (a = l.raw.slice(-1)), s = !0;
        let c = r.at(-1);
        c?.type === "text" ? (c.raw += l.raw, c.text += l.text) : r.push(l);
        continue;
      }
      if (e) {
        let c = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(c);
          break;
        } else throw new Error(c);
      }
    }
    return r;
  }
}, db = class {
  options;
  parser;
  constructor(t) {
    this.options = t || Xh;
  }
  space(t) {
    return "";
  }
  code({ text: t, lang: e, escaped: r }) {
    let n = (e || "").match(Ri.notSpaceStart)?.[0], i = t.replace(Ri.endingNewline, "") + `
`;
    return n ? '<pre><code class="language-' + ba(n) + '">' + (r ? i : ba(i, !0)) + `</code></pre>
` : "<pre><code>" + (r ? i : ba(i, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: t }) {
    return `<blockquote>
${this.parser.parse(t)}</blockquote>
`;
  }
  html({ text: t }) {
    return t;
  }
  def(t) {
    return "";
  }
  heading({ tokens: t, depth: e }) {
    return `<h${e}>${this.parser.parseInline(t)}</h${e}>
`;
  }
  hr(t) {
    return `<hr>
`;
  }
  list(t) {
    let e = t.ordered, r = t.start, n = "";
    for (let s = 0; s < t.items.length; s++) {
      let a = t.items[s];
      n += this.listitem(a);
    }
    let i = e ? "ol" : "ul", o = e && r !== 1 ? ' start="' + r + '"' : "";
    return "<" + i + o + `>
` + n + "</" + i + `>
`;
  }
  listitem(t) {
    let e = "";
    if (t.task) {
      let r = this.checkbox({ checked: !!t.checked });
      t.loose ? t.tokens[0]?.type === "paragraph" ? (t.tokens[0].text = r + " " + t.tokens[0].text, t.tokens[0].tokens && t.tokens[0].tokens.length > 0 && t.tokens[0].tokens[0].type === "text" && (t.tokens[0].tokens[0].text = r + " " + ba(t.tokens[0].tokens[0].text), t.tokens[0].tokens[0].escaped = !0)) : t.tokens.unshift({ type: "text", raw: r + " ", text: r + " ", escaped: !0 }) : e += r + " ";
    }
    return e += this.parser.parse(t.tokens, !!t.loose), `<li>${e}</li>
`;
  }
  checkbox({ checked: t }) {
    return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: t }) {
    return `<p>${this.parser.parseInline(t)}</p>
`;
  }
  table(t) {
    let e = "", r = "";
    for (let i = 0; i < t.header.length; i++) r += this.tablecell(t.header[i]);
    e += this.tablerow({ text: r });
    let n = "";
    for (let i = 0; i < t.rows.length; i++) {
      let o = t.rows[i];
      r = "";
      for (let s = 0; s < o.length; s++) r += this.tablecell(o[s]);
      n += this.tablerow({ text: r });
    }
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + n + `</table>
`;
  }
  tablerow({ text: t }) {
    return `<tr>
${t}</tr>
`;
  }
  tablecell(t) {
    let e = this.parser.parseInline(t.tokens), r = t.header ? "th" : "td";
    return (t.align ? `<${r} align="${t.align}">` : `<${r}>`) + e + `</${r}>
`;
  }
  strong({ tokens: t }) {
    return `<strong>${this.parser.parseInline(t)}</strong>`;
  }
  em({ tokens: t }) {
    return `<em>${this.parser.parseInline(t)}</em>`;
  }
  codespan({ text: t }) {
    return `<code>${ba(t, !0)}</code>`;
  }
  br(t) {
    return "<br>";
  }
  del({ tokens: t }) {
    return `<del>${this.parser.parseInline(t)}</del>`;
  }
  link({ href: t, title: e, tokens: r }) {
    let n = this.parser.parseInline(r), i = kO(t);
    if (i === null) return n;
    t = i;
    let o = '<a href="' + t + '"';
    return e && (o += ' title="' + ba(e) + '"'), o += ">" + n + "</a>", o;
  }
  image({ href: t, title: e, text: r, tokens: n }) {
    n && (r = this.parser.parseInline(n, this.parser.textRenderer));
    let i = kO(t);
    if (i === null) return ba(r);
    t = i;
    let o = `<img src="${t}" alt="${r}"`;
    return e && (o += ` title="${ba(e)}"`), o += ">", o;
  }
  text(t) {
    return "tokens" in t && t.tokens ? this.parser.parseInline(t.tokens) : "escaped" in t && t.escaped ? t.text : ba(t.text);
  }
}, o5 = class {
  strong({ text: t }) {
    return t;
  }
  em({ text: t }) {
    return t;
  }
  codespan({ text: t }) {
    return t;
  }
  del({ text: t }) {
    return t;
  }
  html({ text: t }) {
    return t;
  }
  text({ text: t }) {
    return t;
  }
  link({ text: t }) {
    return "" + t;
  }
  image({ text: t }) {
    return "" + t;
  }
  br() {
    return "";
  }
}, zs = class p_ {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || Xh, this.options.renderer = this.options.renderer || new db(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new o5();
  }
  static parse(e, r) {
    return new p_(r).parse(e);
  }
  static parseInline(e, r) {
    return new p_(r).parseInline(e);
  }
  parse(e, r = !0) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.options.extensions?.renderers?.[o.type]) {
        let a = o, l = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (l !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(a.type)) {
          n += l || "";
          continue;
        }
      }
      let s = o;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let a = s, l = this.renderer.text(a);
          for (; i + 1 < e.length && e[i + 1].type === "text"; ) a = e[++i], l += `
` + this.renderer.text(a);
          r ? n += this.renderer.paragraph({ type: "paragraph", raw: l, text: l, tokens: [{ type: "text", raw: l, text: l, escaped: !0 }] }) : n += l;
          continue;
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
  parseInline(e, r = this.renderer) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.options.extensions?.renderers?.[o.type]) {
        let a = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (a !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type)) {
          n += a || "";
          continue;
        }
      }
      let s = o;
      switch (s.type) {
        case "escape": {
          n += r.text(s);
          break;
        }
        case "html": {
          n += r.html(s);
          break;
        }
        case "link": {
          n += r.link(s);
          break;
        }
        case "image": {
          n += r.image(s);
          break;
        }
        case "strong": {
          n += r.strong(s);
          break;
        }
        case "em": {
          n += r.em(s);
          break;
        }
        case "codespan": {
          n += r.codespan(s);
          break;
        }
        case "br": {
          n += r.br(s);
          break;
        }
        case "del": {
          n += r.del(s);
          break;
        }
        case "text": {
          n += r.text(s);
          break;
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
}, wm = class {
  options;
  block;
  constructor(t) {
    this.options = t || Xh;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(t) {
    return t;
  }
  postprocess(t) {
    return t;
  }
  processAllTokens(t) {
    return t;
  }
  emStrongMask(t) {
    return t;
  }
  provideLexer() {
    return this.block ? Ls.lex : Ls.lexInline;
  }
  provideParser() {
    return this.block ? zs.parse : zs.parseInline;
  }
}, lwe = class {
  defaults = JS();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = zs;
  Renderer = db;
  TextRenderer = o5;
  Lexer = Ls;
  Tokenizer = fb;
  Hooks = wm;
  constructor(...t) {
    this.use(...t);
  }
  walkTokens(t, e) {
    let r = [];
    for (let n of t) switch (r = r.concat(e.call(this, n)), n.type) {
      case "table": {
        let i = n;
        for (let o of i.header) r = r.concat(this.walkTokens(o.tokens, e));
        for (let o of i.rows) for (let s of o) r = r.concat(this.walkTokens(s.tokens, e));
        break;
      }
      case "list": {
        let i = n;
        r = r.concat(this.walkTokens(i.items, e));
        break;
      }
      default: {
        let i = n;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((o) => {
          let s = i[o].flat(1 / 0);
          r = r.concat(this.walkTokens(s, e));
        }) : i.tokens && (r = r.concat(this.walkTokens(i.tokens, e)));
      }
    }
    return r;
  }
  use(...t) {
    let e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t.forEach((r) => {
      let n = { ...r };
      if (n.async = this.defaults.async || n.async || !1, r.extensions && (r.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let o = e.renderers[i.name];
          o ? e.renderers[i.name] = function(...s) {
            let a = i.renderer.apply(this, s);
            return a === !1 && (a = o.apply(this, s)), a;
          } : e.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let o = e[i.level];
          o ? o.unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (e.childTokens[i.name] = i.childTokens);
      }), n.extensions = e), r.renderer) {
        let i = this.defaults.renderer || new db(this.defaults);
        for (let o in r.renderer) {
          if (!(o in i)) throw new Error(`renderer '${o}' does not exist`);
          if (["options", "parser"].includes(o)) continue;
          let s = o, a = r.renderer[s], l = i[s];
          i[s] = (...u) => {
            let c = a.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c || "";
          };
        }
        n.renderer = i;
      }
      if (r.tokenizer) {
        let i = this.defaults.tokenizer || new fb(this.defaults);
        for (let o in r.tokenizer) {
          if (!(o in i)) throw new Error(`tokenizer '${o}' does not exist`);
          if (["options", "rules", "lexer"].includes(o)) continue;
          let s = o, a = r.tokenizer[s], l = i[s];
          i[s] = (...u) => {
            let c = a.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c;
          };
        }
        n.tokenizer = i;
      }
      if (r.hooks) {
        let i = this.defaults.hooks || new wm();
        for (let o in r.hooks) {
          if (!(o in i)) throw new Error(`hook '${o}' does not exist`);
          if (["options", "block"].includes(o)) continue;
          let s = o, a = r.hooks[s], l = i[s];
          wm.passThroughHooks.has(o) ? i[s] = (u) => {
            if (this.defaults.async && wm.passThroughHooksRespectAsync.has(o)) return (async () => {
              let h = await a.call(i, u);
              return l.call(i, h);
            })();
            let c = a.call(i, u);
            return l.call(i, c);
          } : i[s] = (...u) => {
            if (this.defaults.async) return (async () => {
              let h = await a.apply(i, u);
              return h === !1 && (h = await l.apply(i, u)), h;
            })();
            let c = a.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c;
          };
        }
        n.hooks = i;
      }
      if (r.walkTokens) {
        let i = this.defaults.walkTokens, o = r.walkTokens;
        n.walkTokens = function(s) {
          let a = [];
          return a.push(o.call(this, s)), i && (a = a.concat(i.call(this, s))), a;
        };
      }
      this.defaults = { ...this.defaults, ...n };
    }), this;
  }
  setOptions(t) {
    return this.defaults = { ...this.defaults, ...t }, this;
  }
  lexer(t, e) {
    return Ls.lex(t, e ?? this.defaults);
  }
  parser(t, e) {
    return zs.parse(t, e ?? this.defaults);
  }
  parseMarkdown(t) {
    return (e, r) => {
      let n = { ...r }, i = { ...this.defaults, ...n }, o = this.onError(!!i.silent, !!i.async);
      if (this.defaults.async === !0 && n.async === !1) return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof e > "u" || e === null) return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof e != "string") return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"));
      if (i.hooks && (i.hooks.options = i, i.hooks.block = t), i.async) return (async () => {
        let s = i.hooks ? await i.hooks.preprocess(e) : e, a = await (i.hooks ? await i.hooks.provideLexer() : t ? Ls.lex : Ls.lexInline)(s, i), l = i.hooks ? await i.hooks.processAllTokens(a) : a;
        i.walkTokens && await Promise.all(this.walkTokens(l, i.walkTokens));
        let u = await (i.hooks ? await i.hooks.provideParser() : t ? zs.parse : zs.parseInline)(l, i);
        return i.hooks ? await i.hooks.postprocess(u) : u;
      })().catch(o);
      try {
        i.hooks && (e = i.hooks.preprocess(e));
        let s = (i.hooks ? i.hooks.provideLexer() : t ? Ls.lex : Ls.lexInline)(e, i);
        i.hooks && (s = i.hooks.processAllTokens(s)), i.walkTokens && this.walkTokens(s, i.walkTokens);
        let a = (i.hooks ? i.hooks.provideParser() : t ? zs.parse : zs.parseInline)(s, i);
        return i.hooks && (a = i.hooks.postprocess(a)), a;
      } catch (s) {
        return o(s);
      }
    };
  }
  onError(t, e) {
    return (r) => {
      if (r.message += `
Please report this to https://github.com/markedjs/marked.`, t) {
        let n = "<p>An error occurred:</p><pre>" + ba(r.message + "", !0) + "</pre>";
        return e ? Promise.resolve(n) : n;
      }
      if (e) return Promise.reject(r);
      throw r;
    };
  }
}, Oh = new lwe();
function wr(t, e) {
  return Oh.parse(t, e);
}
wr.options = wr.setOptions = function(t) {
  return Oh.setOptions(t), wr.defaults = Oh.defaults, NL(wr.defaults), wr;
};
wr.getDefaults = JS;
wr.defaults = Xh;
wr.use = function(...t) {
  return Oh.use(...t), wr.defaults = Oh.defaults, NL(wr.defaults), wr;
};
wr.walkTokens = function(t, e) {
  return Oh.walkTokens(t, e);
};
wr.parseInline = Oh.parseInline;
wr.Parser = zs;
wr.parser = zs.parse;
wr.Renderer = db;
wr.TextRenderer = o5;
wr.Lexer = Ls;
wr.lexer = Ls.lex;
wr.Tokenizer = fb;
wr.Hooks = wm;
wr.parse = wr;
wr.options;
wr.setOptions;
wr.use;
wr.walkTokens;
wr.parseInline;
zs.parse;
Ls.lex;
class uwe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    this.element.innerHTML = '<div class="markdown-content">' + wr(e.value?.toString() ?? "(null)", { async: !1, gfm: !0 }) + "</div>";
  }
}
class cwe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    if (e.value != null) {
      let r = document.createElement("a");
      r.href = e.value, r.innerText = e.value, r.className = "underline", r.target = "_blank", this.element.replaceChildren(r);
    } else
      this.element.innerText = "(null)";
  }
}
let WL = {
  markdown: uwe,
  image: _xe,
  url: cwe,
  json: Sxe
}, hwe = [
  { renderer: "markdown", label: "Markdown" },
  { renderer: "image", label: "Image" },
  { renderer: "url", label: "Link" },
  { renderer: "json", label: "JSON" }
];
function SO(t) {
  if (t != null)
    return typeof t == "string" ? WL[t] : t;
}
function fwe(t) {
  return typeof t == "string" && (t.startsWith("http://") || t.startsWith("https://"));
}
function dwe(t) {
  return t == null ? !1 : !!(typeof t == "string" && t.startsWith("data:image/") || t.bytes && t.bytes instanceof Uint8Array);
}
function s5(t) {
  if (t == null)
    return "(null)";
  if (typeof t == "string")
    return t.toString();
  if (typeof t == "number")
    return t.toLocaleString();
  if (Array.isArray(t))
    return "[" + t.map((e) => s5(e)).join(", ") + "]";
  try {
    return RL(t);
  } catch {
    return t.toString();
  }
}
var pwe = /* @__PURE__ */ me('<a class="underline" target="_blank"> </a>'), mwe = /* @__PURE__ */ me('<img alt="" class="max-w-24 max-h-24"/>'), gwe = /* @__PURE__ */ me("<div></div>");
function AO(t, e) {
  nt(e, !0);
  let r = ct(e, "value", 3, ""), n = ct(e, "rendererOptions", 19, () => ({})), i = /* @__PURE__ */ K(() => e.renderer != null ? WL[e.renderer] ?? null : null);
  function o(c, h) {
    let d = new h.class(c, { value: h.value, ...h.options });
    return {
      update(p) {
        d.update?.({ value: p.value, ...p.options });
      },
      destroy() {
        d.destroy?.();
      }
    };
  }
  var s = kr(), a = Ve(s);
  {
    var l = (c) => {
      var h = kr(), d = Ve(h);
      {
        var p = (v) => {
          var y = pwe(), b = Y(y, !0);
          J(y), Ae(() => {
            te(y, "href", r()), ut(b, r());
          }), X(v, y);
        }, g = (v) => {
          var y = kr(), b = Ve(y);
          {
            var k = (S) => {
              var _ = mwe();
              Ae((D) => te(_, "src", D), [() => PL(r())]), X(S, _);
            }, C = (S) => {
              var _ = Ro();
              Ae((D) => ut(_, D), [() => s5(r())]), X(S, _);
            };
            Oe(
              b,
              (S) => {
                dwe(r()) ? S(k) : S(C, !1);
              },
              !0
            );
          }
          X(v, y);
        };
        Oe(d, (v) => {
          fwe(r()) ? v(p) : v(g, !1);
        });
      }
      X(c, h);
    }, u = (c) => {
      var h = kr(), d = Ve(h);
      _T(d, () => x(i), (p) => {
        var g = gwe();
        To(g, (v, y) => o?.(v, y), () => ({
          class: x(i),
          value: r(),
          options: n() ?? {}
        })), X(p, g);
      }), X(c, h);
    };
    Oe(a, (c) => {
      x(i) == null ? c(l) : c(u, !1);
    });
  }
  X(t, s), it();
}
var vwe = /* @__PURE__ */ me('<div class="flex flex-col"><div class="text-slate-400 dark:text-slate-400 font-medium text-xs"> </div> <div><!></div></div>'), ywe = /* @__PURE__ */ me('<div class="px-2 flex items-center gap-2 border border-slate-200 dark:border-slate-700 bg-slate-100/25 dark:bg-slate-700/25 text-slate-700 dark:text-slate-300 rounded-md"><div class="text-slate-400 dark:text-slate-400 font-medium text-sm"> </div> <div class="text-ellipsis whitespace-nowrap overflow-hidden max-w-72"><!></div></div>'), bwe = /* @__PURE__ */ me('<div class="flex flex-col gap-2"><!> <div class="flex-none flex flex-row gap-1 flex-wrap items-start"></div></div>');
function GL(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => Object.keys(e.columnStyles).filter((a) => e.columnStyles[a].display == "full")), n = /* @__PURE__ */ K(() => Object.keys(e.columnStyles).filter((a) => e.columnStyles[a].display == "badge"));
  var i = bwe(), o = Y(i);
  Nt(o, 17, () => x(r), cr, (a, l) => {
    const u = /* @__PURE__ */ K(() => e.values[x(l)]);
    var c = vwe(), h = Y(c), d = Y(h, !0);
    J(h);
    var p = ae(h, 2), g = Y(p);
    AO(g, {
      get value() {
        return x(u);
      },
      get renderer() {
        return e.columnStyles[x(l)].renderer;
      },
      get rendererOptions() {
        return e.columnStyles[x(l)].rendererOptions;
      }
    }), J(p), J(c), Ae(() => ut(d, x(l))), X(a, c);
  });
  var s = ae(o, 2);
  Nt(s, 21, () => x(n), cr, (a, l) => {
    const u = /* @__PURE__ */ K(() => e.values[x(l)]);
    var c = ywe(), h = Y(c), d = Y(h, !0);
    J(h);
    var p = ae(h, 2), g = Y(p);
    AO(g, {
      get value() {
        return x(u);
      }
    }), J(p), J(c), Ae(
      (v) => {
        ut(d, x(l)), te(p, "title", v);
      },
      [() => s5(x(u))]
    ), X(a, c);
  }), J(s), J(i), X(t, i), it();
}
var xwe = /* @__PURE__ */ me('<div><button class="text-sm flex gap-0.5 items-center text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-300"><!> Nearest Neighbors</button></div>'), wwe = /* @__PURE__ */ me('<div class="embedding-atlas-root"><div><!> <!></div></div>');
function kwe(t, e) {
  nt(e, !0);
  var r = wwe(), n = Y(r);
  let i;
  ft(n, "", {}, { "max-width": "400px", "max-height": "300px" });
  var o = Y(n);
  {
    let l = /* @__PURE__ */ K(() => e.tooltip.fields ?? {}), u = /* @__PURE__ */ K(() => e.columnStyles ?? {});
    GL(o, {
      get values() {
        return x(l);
      },
      get columnStyles() {
        return x(u);
      }
    });
  }
  var s = ae(o, 2);
  {
    var a = (l) => {
      var u = xwe(), c = Y(u);
      c.__click = () => {
        e.onNearestNeighborSearch?.(e.tooltip.identifier);
      };
      var h = Y(c);
      Vpe(h, {}), q_(), J(c), J(u), X(l, u);
    };
    Oe(s, (l) => {
      e.onNearestNeighborSearch && l(a);
    });
  }
  J(n), J(r), Ae(() => i = Yr(n, 1, "p-2 border flex flex-col gap-2 border-slate-300 dark:border-slate-600 shadow-md text-slate-700 dark:text-slate-300 rounded-md text-ellipsis overflow-x-hidden overflow-y-scroll bg-white/75 dark:bg-slate-800/75 backdrop-blur-sm", null, i, { dark: e.colorScheme == "dark" })), X(t, r), it();
}
nn(["click"]);
function KL(t) {
  return class {
    component;
    constructor(e, r) {
      this.component = kT({ component: t, target: e, props: r });
    }
    update(e) {
      this.component.$set(e);
    }
    destroy() {
      this.component.$destroy();
    }
  };
}
var Cwe = /* @__PURE__ */ me("<div></div>");
function _we(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]), n;
  Kg(() => {
    let o = new c1e(n, r);
    Vs(() => {
      o.update(r);
    }), CT(() => {
      o.destroy();
    });
  });
  var i = Cwe();
  ft(i, "", {}, { display: "flex" }), Qs(i, (o) => n = o, () => n), X(t, i), it();
}
const pb = Math.min, fh = Math.max, mb = Math.round, xy = Math.floor, Ka = (t) => ({
  x: t,
  y: t
});
function EO(t, e, r) {
  return fh(t, pb(e, r));
}
function a5(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Px(t) {
  return t.split("-")[0];
}
function QL(t) {
  return t.split("-")[1];
}
function XL(t) {
  return t === "x" ? "y" : "x";
}
function Swe(t) {
  return t === "y" ? "height" : "width";
}
const Awe = /* @__PURE__ */ new Set(["top", "bottom"]);
function Rx(t) {
  return Awe.has(Px(t)) ? "y" : "x";
}
function Ewe(t) {
  return XL(Rx(t));
}
function Dwe(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Owe(t) {
  return typeof t != "number" ? Dwe(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function gb(t) {
  const {
    x: e,
    y: r,
    width: n,
    height: i
  } = t;
  return {
    width: n,
    height: i,
    top: r,
    left: e,
    right: e + n,
    bottom: r + i,
    x: e,
    y: r
  };
}
function DO(t, e, r) {
  let {
    reference: n,
    floating: i
  } = t;
  const o = Rx(e), s = Ewe(e), a = Swe(s), l = Px(e), u = o === "y", c = n.x + n.width / 2 - i.width / 2, h = n.y + n.height / 2 - i.height / 2, d = n[a] / 2 - i[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: c,
        y: n.y - i.height
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: n.y + n.height
      };
      break;
    case "right":
      p = {
        x: n.x + n.width,
        y: h
      };
      break;
    case "left":
      p = {
        x: n.x - i.width,
        y: h
      };
      break;
    default:
      p = {
        x: n.x,
        y: n.y
      };
  }
  switch (QL(e)) {
    case "start":
      p[s] -= d * (r && u ? -1 : 1);
      break;
    case "end":
      p[s] += d * (r && u ? -1 : 1);
      break;
  }
  return p;
}
const Fwe = async (t, e, r) => {
  const {
    placement: n = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = r, a = o.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let u = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: c,
    y: h
  } = DO(u, n, l), d = n, p = {}, g = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: y,
      fn: b
    } = a[v], {
      x: k,
      y: C,
      data: S,
      reset: _
    } = await b({
      x: c,
      y: h,
      initialPlacement: n,
      placement: d,
      strategy: i,
      middlewareData: p,
      rects: u,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    c = k ?? c, h = C ?? h, p = {
      ...p,
      [y]: {
        ...p[y],
        ...S
      }
    }, _ && g <= 50 && (g++, typeof _ == "object" && (_.placement && (d = _.placement), _.rects && (u = _.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: i
    }) : _.rects), {
      x: c,
      y: h
    } = DO(u, d, l)), v = -1);
  }
  return {
    x: c,
    y: h,
    placement: d,
    strategy: i,
    middlewareData: p
  };
};
async function Twe(t, e) {
  var r;
  e === void 0 && (e = {});
  const {
    x: n,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: h = "floating",
    altBoundary: d = !1,
    padding: p = 0
  } = a5(e, t), g = Owe(p), v = a[d ? h === "floating" ? "reference" : "floating" : h], y = gb(await o.getClippingRect({
    element: (r = await (o.isElement == null ? void 0 : o.isElement(v))) == null || r ? v : v.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), b = h === "floating" ? {
    x: n,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, k = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), C = await (o.isElement == null ? void 0 : o.isElement(k)) ? await (o.getScale == null ? void 0 : o.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = gb(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: b,
    offsetParent: k,
    strategy: l
  }) : b);
  return {
    top: (y.top - S.top + g.top) / C.y,
    bottom: (S.bottom - y.bottom + g.bottom) / C.y,
    left: (y.left - S.left + g.left) / C.x,
    right: (S.right - y.right + g.right) / C.x
  };
}
const Mwe = /* @__PURE__ */ new Set(["left", "top"]);
async function Pwe(t, e) {
  const {
    placement: r,
    platform: n,
    elements: i
  } = t, o = await (n.isRTL == null ? void 0 : n.isRTL(i.floating)), s = Px(r), a = QL(r), l = Rx(r) === "y", u = Mwe.has(s) ? -1 : 1, c = o && l ? -1 : 1, h = a5(e, t);
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: g
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof g == "number" && (p = a === "end" ? g * -1 : g), l ? {
    x: p * c,
    y: d * u
  } : {
    x: d * u,
    y: p * c
  };
}
const Rwe = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var r, n;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: a
      } = e, l = await Pwe(e, t);
      return s === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: i + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, Nwe = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: r,
        y: n,
        placement: i
      } = e, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (y) => {
            let {
              x: b,
              y: k
            } = y;
            return {
              x: b,
              y: k
            };
          }
        },
        ...l
      } = a5(t, e), u = {
        x: r,
        y: n
      }, c = await Twe(e, l), h = Rx(Px(i)), d = XL(h);
      let p = u[d], g = u[h];
      if (o) {
        const y = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", k = p + c[y], C = p - c[b];
        p = EO(k, p, C);
      }
      if (s) {
        const y = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", k = g + c[y], C = g - c[b];
        g = EO(k, g, C);
      }
      const v = a.fn({
        ...e,
        [d]: p,
        [h]: g
      });
      return {
        ...v,
        data: {
          x: v.x - r,
          y: v.y - n,
          enabled: {
            [d]: o,
            [h]: s
          }
        }
      };
    }
  };
};
function Nx() {
  return typeof window < "u";
}
function bp(t) {
  return JL(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Vo(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function hl(t) {
  var e;
  return (e = (JL(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function JL(t) {
  return Nx() ? t instanceof Node || t instanceof Vo(t).Node : !1;
}
function Zs(t) {
  return Nx() ? t instanceof Element || t instanceof Vo(t).Element : !1;
}
function tl(t) {
  return Nx() ? t instanceof HTMLElement || t instanceof Vo(t).HTMLElement : !1;
}
function OO(t) {
  return !Nx() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Vo(t).ShadowRoot;
}
const $we = /* @__PURE__ */ new Set(["inline", "contents"]);
function w0(t) {
  const {
    overflow: e,
    overflowX: r,
    overflowY: n,
    display: i
  } = ea(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !$we.has(i);
}
const Iwe = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Bwe(t) {
  return Iwe.has(bp(t));
}
const Lwe = [":popover-open", ":modal"];
function $x(t) {
  return Lwe.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const zwe = ["transform", "translate", "scale", "rotate", "perspective"], jwe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], qwe = ["paint", "layout", "strict", "content"];
function l5(t) {
  const e = u5(), r = Zs(t) ? ea(t) : t;
  return zwe.some((n) => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || jwe.some((n) => (r.willChange || "").includes(n)) || qwe.some((n) => (r.contain || "").includes(n));
}
function Uwe(t) {
  let e = hc(t);
  for (; tl(e) && !zd(e); ) {
    if (l5(e))
      return e;
    if ($x(e))
      return null;
    e = hc(e);
  }
  return null;
}
function u5() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const Hwe = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function zd(t) {
  return Hwe.has(bp(t));
}
function ea(t) {
  return Vo(t).getComputedStyle(t);
}
function Ix(t) {
  return Zs(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function hc(t) {
  if (bp(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    OO(t) && t.host || // Fallback.
    hl(t)
  );
  return OO(e) ? e.host : e;
}
function YL(t) {
  const e = hc(t);
  return zd(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : tl(e) && w0(e) ? e : YL(e);
}
function zg(t, e, r) {
  var n;
  e === void 0 && (e = []), r === void 0 && (r = !0);
  const i = YL(t), o = i === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Vo(i);
  if (o) {
    const a = m_(s);
    return e.concat(s, s.visualViewport || [], w0(i) ? i : [], a && r ? zg(a) : []);
  }
  return e.concat(i, zg(i, [], r));
}
function m_(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function ZL(t) {
  const e = ea(t);
  let r = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const i = tl(t), o = i ? t.offsetWidth : r, s = i ? t.offsetHeight : n, a = mb(r) !== o || mb(n) !== s;
  return a && (r = o, n = s), {
    width: r,
    height: n,
    $: a
  };
}
function c5(t) {
  return Zs(t) ? t : t.contextElement;
}
function ud(t) {
  const e = c5(t);
  if (!tl(e))
    return Ka(1);
  const r = e.getBoundingClientRect(), {
    width: n,
    height: i,
    $: o
  } = ZL(e);
  let s = (o ? mb(r.width) : r.width) / n, a = (o ? mb(r.height) : r.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const Vwe = /* @__PURE__ */ Ka(0);
function ez(t) {
  const e = Vo(t);
  return !u5() || !e.visualViewport ? Vwe : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function Wwe(t, e, r) {
  return e === void 0 && (e = !1), !r || e && r !== Vo(t) ? !1 : e;
}
function Fh(t, e, r, n) {
  e === void 0 && (e = !1), r === void 0 && (r = !1);
  const i = t.getBoundingClientRect(), o = c5(t);
  let s = Ka(1);
  e && (n ? Zs(n) && (s = ud(n)) : s = ud(t));
  const a = Wwe(o, r, n) ? ez(o) : Ka(0);
  let l = (i.left + a.x) / s.x, u = (i.top + a.y) / s.y, c = i.width / s.x, h = i.height / s.y;
  if (o) {
    const d = Vo(o), p = n && Zs(n) ? Vo(n) : n;
    let g = d, v = m_(g);
    for (; v && n && p !== g; ) {
      const y = ud(v), b = v.getBoundingClientRect(), k = ea(v), C = b.left + (v.clientLeft + parseFloat(k.paddingLeft)) * y.x, S = b.top + (v.clientTop + parseFloat(k.paddingTop)) * y.y;
      l *= y.x, u *= y.y, c *= y.x, h *= y.y, l += C, u += S, g = Vo(v), v = m_(g);
    }
  }
  return gb({
    width: c,
    height: h,
    x: l,
    y: u
  });
}
function Bx(t, e) {
  const r = Ix(t).scrollLeft;
  return e ? e.left + r : Fh(hl(t)).left + r;
}
function tz(t, e) {
  const r = t.getBoundingClientRect(), n = r.left + e.scrollLeft - Bx(t, r), i = r.top + e.scrollTop;
  return {
    x: n,
    y: i
  };
}
function Gwe(t) {
  let {
    elements: e,
    rect: r,
    offsetParent: n,
    strategy: i
  } = t;
  const o = i === "fixed", s = hl(n), a = e ? $x(e.floating) : !1;
  if (n === s || a && o)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Ka(1);
  const c = Ka(0), h = tl(n);
  if ((h || !h && !o) && ((bp(n) !== "body" || w0(s)) && (l = Ix(n)), tl(n))) {
    const p = Fh(n);
    u = ud(n), c.x = p.x + n.clientLeft, c.y = p.y + n.clientTop;
  }
  const d = s && !h && !o ? tz(s, l) : Ka(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - l.scrollLeft * u.x + c.x + d.x,
    y: r.y * u.y - l.scrollTop * u.y + c.y + d.y
  };
}
function Kwe(t) {
  return Array.from(t.getClientRects());
}
function Qwe(t) {
  const e = hl(t), r = Ix(t), n = t.ownerDocument.body, i = fh(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), o = fh(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let s = -r.scrollLeft + Bx(t);
  const a = -r.scrollTop;
  return ea(n).direction === "rtl" && (s += fh(e.clientWidth, n.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
const FO = 25;
function Xwe(t, e) {
  const r = Vo(t), n = hl(t), i = r.visualViewport;
  let o = n.clientWidth, s = n.clientHeight, a = 0, l = 0;
  if (i) {
    o = i.width, s = i.height;
    const c = u5();
    (!c || c && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  const u = Bx(n);
  if (u <= 0) {
    const c = n.ownerDocument, h = c.body, d = getComputedStyle(h), p = c.compatMode === "CSS1Compat" && parseFloat(d.marginLeft) + parseFloat(d.marginRight) || 0, g = Math.abs(n.clientWidth - h.clientWidth - p);
    g <= FO && (o -= g);
  } else u <= FO && (o += u);
  return {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
const Jwe = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Ywe(t, e) {
  const r = Fh(t, !0, e === "fixed"), n = r.top + t.clientTop, i = r.left + t.clientLeft, o = tl(t) ? ud(t) : Ka(1), s = t.clientWidth * o.x, a = t.clientHeight * o.y, l = i * o.x, u = n * o.y;
  return {
    width: s,
    height: a,
    x: l,
    y: u
  };
}
function TO(t, e, r) {
  let n;
  if (e === "viewport")
    n = Xwe(t, r);
  else if (e === "document")
    n = Qwe(hl(t));
  else if (Zs(e))
    n = Ywe(e, r);
  else {
    const i = ez(t);
    n = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return gb(n);
}
function rz(t, e) {
  const r = hc(t);
  return r === e || !Zs(r) || zd(r) ? !1 : ea(r).position === "fixed" || rz(r, e);
}
function Zwe(t, e) {
  const r = e.get(t);
  if (r)
    return r;
  let n = zg(t, [], !1).filter((a) => Zs(a) && bp(a) !== "body"), i = null;
  const o = ea(t).position === "fixed";
  let s = o ? hc(t) : t;
  for (; Zs(s) && !zd(s); ) {
    const a = ea(s), l = l5(s);
    !l && a.position === "fixed" && (i = null), (o ? !l && !i : !l && a.position === "static" && i && Jwe.has(i.position) || w0(s) && !l && rz(t, s)) ? n = n.filter((u) => u !== s) : i = a, s = hc(s);
  }
  return e.set(t, n), n;
}
function e2e(t) {
  let {
    element: e,
    boundary: r,
    rootBoundary: n,
    strategy: i
  } = t;
  const o = [...r === "clippingAncestors" ? $x(e) ? [] : Zwe(e, this._c) : [].concat(r), n], s = o[0], a = o.reduce((l, u) => {
    const c = TO(e, u, i);
    return l.top = fh(c.top, l.top), l.right = pb(c.right, l.right), l.bottom = pb(c.bottom, l.bottom), l.left = fh(c.left, l.left), l;
  }, TO(e, s, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function t2e(t) {
  const {
    width: e,
    height: r
  } = ZL(t);
  return {
    width: e,
    height: r
  };
}
function r2e(t, e, r) {
  const n = tl(e), i = hl(e), o = r === "fixed", s = Fh(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Ka(0);
  function u() {
    l.x = Bx(i);
  }
  if (n || !n && !o)
    if ((bp(e) !== "body" || w0(i)) && (a = Ix(e)), n) {
      const p = Fh(e, !0, o, e);
      l.x = p.x + e.clientLeft, l.y = p.y + e.clientTop;
    } else i && u();
  o && !n && i && u();
  const c = i && !n && !o ? tz(i, a) : Ka(0), h = s.left + a.scrollLeft - l.x - c.x, d = s.top + a.scrollTop - l.y - c.y;
  return {
    x: h,
    y: d,
    width: s.width,
    height: s.height
  };
}
function Ik(t) {
  return ea(t).position === "static";
}
function MO(t, e) {
  if (!tl(t) || ea(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let r = t.offsetParent;
  return hl(t) === r && (r = r.ownerDocument.body), r;
}
function nz(t, e) {
  const r = Vo(t);
  if ($x(t))
    return r;
  if (!tl(t)) {
    let i = hc(t);
    for (; i && !zd(i); ) {
      if (Zs(i) && !Ik(i))
        return i;
      i = hc(i);
    }
    return r;
  }
  let n = MO(t, e);
  for (; n && Bwe(n) && Ik(n); )
    n = MO(n, e);
  return n && zd(n) && Ik(n) && !l5(n) ? r : n || Uwe(t) || r;
}
const n2e = async function(t) {
  const e = this.getOffsetParent || nz, r = this.getDimensions, n = await r(t.floating);
  return {
    reference: r2e(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function i2e(t) {
  return ea(t).direction === "rtl";
}
const o2e = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Gwe,
  getDocumentElement: hl,
  getClippingRect: e2e,
  getOffsetParent: nz,
  getElementRects: n2e,
  getClientRects: Kwe,
  getDimensions: t2e,
  getScale: ud,
  isElement: Zs,
  isRTL: i2e
};
function iz(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function s2e(t, e) {
  let r = null, n;
  const i = hl(t);
  function o() {
    var a;
    clearTimeout(n), (a = r) == null || a.disconnect(), r = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const u = t.getBoundingClientRect(), {
      left: c,
      top: h,
      width: d,
      height: p
    } = u;
    if (a || e(), !d || !p)
      return;
    const g = xy(h), v = xy(i.clientWidth - (c + d)), y = xy(i.clientHeight - (h + p)), b = xy(c), k = {
      rootMargin: -g + "px " + -v + "px " + -y + "px " + -b + "px",
      threshold: fh(0, pb(1, l)) || 1
    };
    let C = !0;
    function S(_) {
      const D = _[0].intersectionRatio;
      if (D !== l) {
        if (!C)
          return s();
        D ? s(!1, D) : n = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !iz(u, t.getBoundingClientRect()) && s(), C = !1;
    }
    try {
      r = new IntersectionObserver(S, {
        ...k,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(S, k);
    }
    r.observe(t);
  }
  return s(!0), o;
}
function a2e(t, e, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, u = c5(t), c = i || o ? [...u ? zg(u) : [], ...zg(e)] : [];
  c.forEach((b) => {
    i && b.addEventListener("scroll", r, {
      passive: !0
    }), o && b.addEventListener("resize", r);
  });
  const h = u && a ? s2e(u, r) : null;
  let d = -1, p = null;
  s && (p = new ResizeObserver((b) => {
    let [k] = b;
    k && k.target === u && p && (p.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var C;
      (C = p) == null || C.observe(e);
    })), r();
  }), u && !l && p.observe(u), p.observe(e));
  let g, v = l ? Fh(t) : null;
  l && y();
  function y() {
    const b = Fh(t);
    v && !iz(v, b) && r(), v = b, g = requestAnimationFrame(y);
  }
  return r(), () => {
    var b;
    c.forEach((k) => {
      i && k.removeEventListener("scroll", r), o && k.removeEventListener("resize", r);
    }), h?.(), (b = p) == null || b.disconnect(), p = null, l && cancelAnimationFrame(g);
  };
}
const l2e = Rwe, u2e = Nwe, c2e = (t, e, r) => {
  const n = /* @__PURE__ */ new Map(), i = {
    platform: o2e,
    ...r
  }, o = {
    ...i.platform,
    _c: n
  };
  return Fwe(t, e, {
    ...i,
    platform: o
  });
};
var h2e = /* @__PURE__ */ me('<div class="relative"><!> <div class="absolute px-3 py-3 rounded-md z-20 bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-700 shadow-lg" popover=""><!></div></div>');
function oz(t, e) {
  nt(e, !0);
  let r = ct(e, "title", 3, ""), n = ct(e, "label", 3, null), i = ct(e, "icon", 3, null);
  ct(e, "anchor", 3, "right");
  let o = /* @__PURE__ */ De(!1), s;
  function a(g) {
    x(o) && g.key == "Escape" && (ue(o, !1), g.stopPropagation());
  }
  Vs(() => {
    if (s != null) {
      let g = (y) => {
        !x(o) || !s || y.target && !s.contains(y.target) && ue(o, !1);
      }, v = s.getRootNode();
      return v.addEventListener("mousedown", g), () => {
        v.removeEventListener("mousedown", g);
      };
    }
  });
  let l;
  Vs(() => {
    x(o) && Vs(() => u());
  });
  function u() {
    l.showPopover();
    function g() {
      c2e(s, l, { placement: "bottom", middleware: [l2e(3), u2e()] }).then(({ x: v, y }) => {
        l.style.left = v + "px", l.style.top = y + "px";
      });
    }
    return a2e(s, l, g);
  }
  var c = h2e();
  c.__keydown = a;
  var h = Y(c);
  Qy(h, {
    get icon() {
      return i();
    },
    get title() {
      return r();
    },
    get label() {
      return n();
    },
    get checked() {
      return x(o);
    },
    set checked(g) {
      ue(o, g, !0);
    }
  });
  var d = ae(h, 2);
  ft(d, "", {}, { width: "max-content" });
  var p = Y(d);
  Xl(p, () => e.children ?? zt), J(d), Qs(d, (g) => l = g, () => l), J(c), Qs(c, (g) => s = g, () => s), X(t, c), it();
}
nn(["keydown"]);
var f2e = /* @__PURE__ */ me('<div class="group relative" role="slider" tabindex="0"><div class="bg-slate-400 dark:bg-slate-500 rounded-full absolute"></div> <div class="bg-blue-500 rounded-full absolute group-hover:bg-blue-600 dark:group-hover:bg-blue-400"></div></div>');
function g_(t, e) {
  nt(e, !0);
  let r = ct(e, "value", 15, 0), n = ct(e, "min", 3, 0), i = ct(e, "max", 3, 100), o = ct(e, "step", 3, void 0), s = ct(e, "width", 3, 100), a = 15, l = /* @__PURE__ */ K(() => (_) => (_ - n()) / (i() - n()) * (s() - a)), u = /* @__PURE__ */ K(() => (_) => _ / (s() - a) * (i() - n()) + n()), c = /* @__PURE__ */ K(() => x(l)(r())), h = /* @__PURE__ */ De(void 0);
  function d(_) {
    let D = x(u)(_ - a / 2);
    D = Math.max(n(), Math.min(i(), D)), o() != null && (D = Math.round(D / o()) * o()), r(D);
  }
  function p(_) {
    d(_.clientX - x(h).getBoundingClientRect().left);
    let D = (O) => {
      d(O.clientX - x(h).getBoundingClientRect().left);
    }, A = () => {
      window.removeEventListener("mousemove", D), window.removeEventListener("mouseup", A);
    };
    window.addEventListener("mousemove", D), window.addEventListener("mouseup", A);
  }
  function g(_) {
    _.key == "ArrowLeft" ? r(Math.max(r() - (o() ?? 1), n())) : _.key == "ArrowRight" && r(Math.min(r() + (o() ?? 1), i()));
  }
  var v = f2e();
  v.__mousedown = p, v.__keydown = g;
  let y;
  var b = Y(v);
  let k;
  var C = ae(b, 2);
  let S;
  J(v), Qs(v, (_) => ue(h, _), () => x(h)), Ae(() => {
    te(v, "aria-valuenow", r()), te(v, "aria-valuemin", n()), te(v, "aria-valuemax", i()), y = ft(v, "", y, { width: `${s() ?? ""}px`, height: "28px" }), k = ft(b, "", k, {
      left: "0px",
      top: "12px",
      width: `${s() ?? ""}px`,
      height: "4px"
    }), S = ft(C, "", S, {
      left: `${x(c) ?? ""}px`,
      top: "6.5px",
      width: "15px",
      height: "15px"
    });
  }), X(t, v), it();
}
nn(["mousedown", "keydown"]);
var d2e = /* @__PURE__ */ me('<tr><td class="first:rounded-tl-md first:rounded-bl-md"><div class="block w-4 h-4 mx-2 rounded-full"></div></td><td><div class="whitespace-nowrap nowrap max-w-72 text-ellipsis overflow-hidden"> </div></td><td class="text-slate-400 px-2 text-xs text-right last:rounded-tr-md last:rounded-br-md" title="Count"> </td></tr>'), p2e = /* @__PURE__ */ me("<table><tbody></tbody></table>");
function m2e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => {
    let l = new Set(e.state.selection ?? []);
    return new Set(e.spec.items.filter((u) => l.has(u.label)));
  });
  class n extends O_ {
    reset() {
      e.onStateChange({ selection: void 0 });
    }
  }
  const i = new n();
  function o(l, u) {
    let c = new Set(e.state.selection ?? []);
    u.shiftKey || u.metaKey ? (c.has(l.label) ? c.delete(l.label) : c.add(l.label), e.onStateChange({ selection: Array.from(c) })) : c.has(l.label) && c.size == 1 ? e.onStateChange({ selection: void 0 }) : e.onStateChange({ selection: [l.label] });
  }
  mt(() => (mt(() => {
    let l = new Set(e.state.selection ?? []), u = e.spec.items.filter((d) => l.has(d.label)), c = u.length != 0 ? T.or(u.map((d) => d.predicate)) : null, h = {
      source: i,
      clients: /* @__PURE__ */ new Set([i]),
      value: u.length == 0 ? null : u,
      predicate: c
    };
    e.context.filter.update(h);
  }), () => {
    e.context.filter.update({
      source: i,
      clients: /* @__PURE__ */ new Set([i]),
      value: null,
      predicate: null
    });
  }));
  var s = p2e(), a = Y(s);
  Nt(a, 21, () => e.spec.items, cr, (l, u) => {
    const c = /* @__PURE__ */ K(() => x(r).has(x(u)) || x(r).size == 0);
    var h = d2e();
    let d;
    h.__click = (_) => {
      o(x(u), _);
    };
    var p = Y(h), g = Y(p);
    let v;
    J(p);
    var y = ae(p), b = Y(y), k = Y(b, !0);
    J(b), J(y);
    var C = ae(y), S = Y(C, !0);
    J(C), J(h), Ae(
      (_) => {
        d = Yr(h, 1, "hover:bg-slate-200 dark:hover:bg-slate-700 select-none leading-7", null, d, { "opacity-20": !x(c) }), v = ft(g, "", v, { "background-color": x(u).color }), te(b, "title", x(u).label), ut(k, x(u).label), ut(S, _);
      },
      [() => x(u).count.toLocaleString()]
    ), X(l, h);
  }), J(a), J(s), X(t, s), it();
}
nn(["click"]);
function sz(t) {
  let e = 0;
  function r(n) {
    e += 1;
    try {
      n();
    } finally {
      e -= 1;
    }
  }
  return {
    set(n) {
      r(() => {
        t.set(n);
      });
    },
    update(n) {
      r(() => {
        t.update(n);
      });
    },
    subscribe(n) {
      return t.subscribe((i) => {
        e == 0 && n(i);
      });
    }
  };
}
async function g2e(t, e, r) {
  if (r == null)
    return null;
  let [n] = Array.from(await t.query(T.Query.describe(T.Query.from(e).select(r))));
  if (n == null)
    return null;
  let i = XS(n.column_type);
  return i == "string" ? await PO(t, e, r, 10) : i == "number" ? await FL(t, e, r) <= 10 ? await PO(t, e, r, 10) : await v2e(t, e, r) : null;
}
async function PO(t, e, r, n) {
  let i = `_ev_${r}_id`, o = Array.from(
    await t.query(
      T.Query.from(e).select({ value: T.cast(T.column(r), "TEXT"), count: T.count() }).where(T.not(T.isNull(T.cast(T.column(r), "TEXT")))).groupby(T.cast(T.column(r), "TEXT")).orderby(T.desc(T.count())).limit(n)
    )
  ), s = o.length, a = o.length + 1;
  await t.exec(`
    ALTER TABLE ${e} ADD COLUMN IF NOT EXISTS ${T.column(i)} INTEGER DEFAULT 0;
    UPDATE ${e}
    SET ${T.column(i)} = CASE ${T.column(r)}::TEXT
          ${o.map(({ value: g }, v) => T.sql`WHEN ${T.literal(g)} THEN ${T.literal(v)}`).join(" ")}
          ELSE (CASE WHEN ${T.column(r)} IS NULL THEN ${T.literal(a)} ELSE ${T.literal(s)} END) END
  `);
  let l = Array.from(
    await t.query(
      T.Query.from(e).select({ index: T.column(i), count: T.cast(T.count(), "INT") }).groupby(T.column(i))
    )
  ), u = /* @__PURE__ */ new Map();
  for (let g of l)
    u.set(g.index, g.count);
  let c = u.get(s) ?? 0, h = u.get(a) ?? 0, d = mp(o.length), p = o.map(({ value: g }, v) => ({
    label: g,
    color: d[v],
    predicate: T.eq(T.cast(T.column(r), "TEXT"), T.literal(g)),
    count: u.get(v) ?? 0
  }));
  if (c > 0) {
    let { otherCategoryCount: g } = (await t.query(`
        SELECT COUNT(DISTINCT(${T.column(r)}::TEXT)) AS otherCategoryCount
        FROM ${e}
        WHERE ${T.column(i)} = ${T.literal(s)} AND ${T.column(r)} IS NOT NULL
    `)).get(0);
    p.push({
      label: `(other ${g.toLocaleString()})`,
      color: "#9eabc2",
      predicate: o.length > 0 ? T.sql`${T.column(r)} IS NOT NULL AND ${T.column(r)}::TEXT NOT IN (${o.map((v) => T.literal(v.value)).join(",")})` : T.sql`${T.column(r)} IS NOT NULL`,
      count: c
    });
  }
  return h > 0 && (c <= 0 && (await t.exec(`
          UPDATE ${e}
          SET ${T.column(i)} = ${T.column(i)} - 1 WHERE ${T.column(i)} = ${T.literal(a)}
        `), a -= 1), p.push({
    label: "(null)",
    color: "#aaaaaa",
    predicate: T.isNull(T.column(r)),
    count: h
  })), {
    indexColumn: i,
    legend: p
  };
}
async function v2e(t, e, r) {
  let n = (await t.query(
    T.Query.from(e).select({
      count: T.count(),
      min: T.min(T.column(r)),
      max: T.max(T.column(r)),
      mean: T.avg(T.column(r)),
      median: T.median(T.column(r))
    }).where(T.isFinite(T.column(r)))
  )).get(0), i = TL(n), o = `_ev_${r}_id`, s = T.cast(T.column(r), "DOUBLE");
  s = i.scale.expr(s, i.scale.constant ?? 0);
  let a = T.cond(
    T.isFinite(T.cast(T.column(r), "DOUBLE")),
    T.floor(T.mul(T.sub(s, i.binStart), 1 / i.binSize)),
    T.literal(null)
  );
  await t.exec(`
    ALTER TABLE ${e} ADD COLUMN IF NOT EXISTS ${T.column(o)} INTEGER DEFAULT 0;
    UPDATE ${e}
    SET ${T.column(o)} = ${a}
  `);
  let l = Array.from(
    await t.query(`
      SELECT ${T.column(o)} AS index, COUNT(*)::INT AS count
      FROM ${e}
      GROUP BY ${T.column(o)}
      ORDER BY ${T.column(o)} ASC
    `)
  ), u = null, c = null, h = /* @__PURE__ */ new Map(), d = (v) => i.scale.reverse(v, i.scale.constant ?? 0);
  for (let { index: v, count: y } of l)
    v != null && ((u == null || v < u) && (u = v), (c == null || v > c) && (c = v)), h.set(v, y);
  let p = [], g = ou(".6");
  if (u != null && c != null) {
    let v = _L(c - u + 1);
    for (let y = u; y <= c; y++) {
      let b = d(y * i.binSize + i.binStart), k = d((y + 1) * i.binSize + i.binStart);
      p.push({
        label: `[${g(b)}, ${g(k)})`,
        color: v[y - u],
        predicate: T.eq(a, T.literal(y)),
        count: h.get(y) ?? 0
      });
    }
  }
  if (h.has(null)) {
    let v = p.length;
    await t.exec(`
        UPDATE ${e}
        SET ${T.column(o)} = ${T.literal(v)}
        WHERE ${T.column(o)} IS NULL
      `), p.push({
      label: "(null / nan / inf)",
      color: "#aaaaaa",
      predicate: T.isNull(a),
      count: h.get(null) ?? 0
    });
  }
  return {
    indexColumn: o,
    legend: p
  };
}
function wy(t, e, r) {
  return t + (e - t) * r;
}
function y2e(t, e, r) {
  let n = Math.log(t.scale), i = Math.log(e.scale);
  if (Math.abs(i - n) < 1e-5)
    return {
      x: wy(t.x, e.x, r),
      y: wy(t.y, e.y, r),
      scale: wy(t.scale, e.scale, r)
    };
  let o = Math.exp(wy(n, i, r));
  return {
    x: (e.x * e.scale - t.x * t.scale + (t.x - e.x) * (t.scale * e.scale / o)) / (e.scale - t.scale),
    y: (e.y * e.scale - t.y * t.scale + (t.y - e.y) * (t.scale * e.scale / o)) / (e.scale - t.scale),
    scale: o
  };
}
async function b2e(t, e, r, n) {
  let { stdX: i, stdY: o } = (await t.query(T.Query.from(e).select({
    stdX: T.sql`STDDEV(${T.column(r)})::FLOAT`,
    stdY: T.sql`STDDEV(${T.column(n)})::FLOAT`
  }))).get(0);
  return 1 / (Math.max(i, o, 1e-3) * 3);
}
const x2e = KL(kwe), w2e = KL(wxe);
var k2e = /* @__PURE__ */ me('<div class="flex-none m-2 p-2 rounded-md bg-slate-100/75 dark:bg-slate-800/75 backdrop-blur-sm pointer-events-auto order-3"><!></div>'), C2e = /* @__PURE__ */ me('<div class="flex flex-col gap-2 w-64"><div class="text-slate-500 dark:text-slate-400 select-none">Display Mode</div> <div class="flex gap-2 items-center"><!> <!></div> <div class="text-slate-500 dark:text-slate-400 select-none">Point Size</div> <div class="flex gap-2 items-center"><!> <!></div></div>'), _2e = /* @__PURE__ */ me('<div class="relative"><!> <div class="absolute top-0 left-0 right-0 flex flex-wrap justify-between items-start pointer-events-none"><!> <div class="flex-none p-2 rounded-ss-md rounded-ee-md bg-white/75 dark:bg-black/75 backdrop-blur-sm flex items-center gap-2 pointer-events-auto order-1"><!> <!></div></div></div>');
function S2e(t, e) {
  nt(e, !0);
  const r = () => mi(l, "$colorScheme", i), n = () => mi(u, "$columnStyles", i), [i, o] = Xo(), s = Math.min(20, h1e()), a = 1 / 16;
  let { colorScheme: l, columnStyles: u, searchResult: c } = e.context, h = sz(e.context.highlight), d = /* @__PURE__ */ K(() => e.spec.data.category), p = /* @__PURE__ */ De(null), g = /* @__PURE__ */ De(null), v = /* @__PURE__ */ De(null), y = /* @__PURE__ */ De(null);
  mt(() => {
    e.context.cache.value(`embedding/category/${x(d)}`, () => g2e(e.context.coordinator, e.context.table, x(d))).then(($) => {
      ue(p, $), (x(p)?.legend.length ?? 0) > s && e.onSpecChange({ mode: "points" });
    });
  }), mt(() => h.subscribe(($) => {
    $ !== null && b($);
  })), mt(() => c.subscribe(async ($) => {
    if ($ == null || $.ids.length == 0) {
      ue(y, null);
      return;
    }
    let q = null;
    $.mode == "neighbors" && (q = $.query);
    let U = Array.from(await e.context.coordinator.query(T.Query.from(e.context.table).select({
      identifier: T.column(e.context.id),
      x: T.column(e.spec.data.x),
      y: T.column(e.spec.data.y)
    }).where(T.isIn(e.context.id, $.ids.concat(q != null ? [q] : []).map((H) => T.literal(H))))));
    ue(y, {
      center: U.filter((H) => H.identifier === q)[0] ?? null,
      points: U.filter((H) => H.identifier !== q)
    });
  }));
  async function b($) {
    let q = await e.context.cache.value(`embedding/default-viewport-scale/${e.spec.data.x},${e.spec.data.y}`, () => b2e(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y)) * 2, U = await e.context.coordinator.query(T.Query.from(e.context.table).select({
      x: T.column(e.spec.data.x),
      y: T.column(e.spec.data.y)
    }).where(T.eq(T.column(e.context.id), T.literal($)))), { x: H, y: G } = U.get(0);
    S({ x: H, y: G, scale: q }), ue(v, [$]), ue(g, $);
  }
  let k, C = /* @__PURE__ */ De(null);
  function S($) {
    ue(g, null);
    let q = x(C) ?? e.state.viewport;
    if (q == null) {
      e.onStateChange({ viewport: $ });
      return;
    }
    ue(C, q);
    let U = 800, H = (/* @__PURE__ */ new Date()).getTime(), G = () => {
      let re = ((/* @__PURE__ */ new Date()).getTime() - H) / U;
      re > 1 && (re = 1), ue(C, y2e(q, $, PT(re))), re < 1 ? k = requestAnimationFrame(G) : e.onStateChange({ viewport: x(C) });
    };
    k && cancelAnimationFrame(k), k = requestAnimationFrame(G);
  }
  var _ = { startViewportAnimation: S }, D = _2e(), A = Y(D);
  {
    let $ = /* @__PURE__ */ K(() => x(p)?.indexColumn), q = /* @__PURE__ */ K(() => x(p)?.legend.map((se) => se.color)), U = /* @__PURE__ */ K(() => ({
      colorScheme: r(),
      ...e.context.embeddingViewConfig,
      mode: e.spec.mode ?? "points",
      ...e.spec.minimumDensity != null ? { minimumDensity: e.spec.minimumDensity } : {},
      ...e.spec.pointSize != null ? { pointSize: e.spec.pointSize } : {}
    })), H = /* @__PURE__ */ K(() => Object.fromEntries(e.context.columns.map((se) => [se.name, se.name]))), G = /* @__PURE__ */ K(() => ({
      class: x2e,
      props: {
        darkMode: r(),
        columnStyles: n(),
        onNearestNeighborSearch: (e.context.searchModes ?? []).indexOf("neighbors") >= 0 ? (se) => e.context.search?.(se, "neighbors") : null
      }
    })), re = /* @__PURE__ */ K(() => ({
      class: w2e,
      props: { ...x(y) ?? { points: [], center: null } }
    })), ie = /* @__PURE__ */ K(() => x(C) ?? e.state.viewport);
    _we(A, {
      get width() {
        return e.width;
      },
      get height() {
        return e.height;
      },
      get coordinator() {
        return e.context.coordinator;
      },
      get table() {
        return e.context.table;
      },
      get filter() {
        return e.context.filter;
      },
      get rangeSelection() {
        return e.context.filter;
      },
      get identifier() {
        return e.context.id;
      },
      get x() {
        return e.spec.data.x;
      },
      get y() {
        return e.spec.data.y;
      },
      get text() {
        return e.spec.data.text;
      },
      get category() {
        return x($);
      },
      get categoryColors() {
        return x(q);
      },
      get config() {
        return x(U);
      },
      get labels() {
        return e.context.embeddingViewLabels;
      },
      get cache() {
        return e.context.persistentCache;
      },
      get additionalFields() {
        return x(H);
      },
      get customTooltip() {
        return x(G);
      },
      get customOverlay() {
        return x(re);
      },
      get viewportState() {
        return x(ie);
      },
      onViewportState: (se) => e.onStateChange({ viewport: se }),
      get rangeSelectionValue() {
        return e.state.brush;
      },
      onRangeSelection: (se) => e.onStateChange({ brush: se }),
      get tooltip() {
        return x(g);
      },
      onTooltip: (se) => {
        ue(g, se);
      },
      get selection() {
        return x(v);
      },
      onSelection: (se) => {
        ue(v, se), se != null && se.length == 1 && h.set(se[0].identifier);
      }
    });
  }
  var O = ae(A, 2), M = Y(O);
  {
    var z = ($) => {
      var q = k2e(), U = Y(q);
      {
        let H = /* @__PURE__ */ K(() => ({ items: x(p).legend })), G = /* @__PURE__ */ K(() => e.state.legend ?? {});
        m2e(U, {
          get context() {
            return e.context;
          },
          get spec() {
            return x(H);
          },
          get state() {
            return x(G);
          },
          onSpecChange: () => {
          },
          onStateChange: (re, ie) => {
            e.onStateChange({ legend: re });
          }
        });
      }
      J(q), X($, q);
    };
    Oe(M, ($) => {
      x(p) != null && $(z);
    });
  }
  var R = ae(M, 2), N = Y(R);
  {
    let $ = /* @__PURE__ */ K(() => [
      { value: null, label: "(none)" },
      ...e.context.columns.filter((q) => q.jsType == "string" || q.jsType == "number").map((q) => ({ value: q.name, label: `${q.name} (${q.type})` }))
    ]);
    Dh(N, {
      class: "max-w-64",
      label: "Color",
      get value() {
        return x(d);
      },
      onChange: (q) => e.onSpecChange({ data: { ...e.spec.data, category: q } }),
      get options() {
        return x($);
      }
    });
  }
  var I = ae(N, 2);
  oz(I, {
    get icon() {
      return BI;
    },
    title: "Options",
    children: ($, q) => {
      var U = C2e(), H = ae(Y(U), 2), G = Y(H);
      {
        let Me = /* @__PURE__ */ K(() => e.spec.mode ?? "points"), _e = /* @__PURE__ */ K(() => x(p) != null && x(p).legend.length > s);
        Dh(G, {
          get value() {
            return x(Me);
          },
          onChange: (he) => e.onSpecChange({ mode: he }),
          get disabled() {
            return x(_e);
          },
          options: [
            { value: "points", label: "Points" },
            { value: "density", label: "Density" }
          ]
        });
      }
      var re = ae(G, 2);
      {
        var ie = (Me) => {
          var _e = () => Math.log((e.spec.minimumDensity ?? a) / a), he = (ke) => e.onSpecChange({ minimumDensity: a * Math.exp(ke) });
          g_(Me, {
            get value() {
              return _e();
            },
            set value(ke) {
              he(ke);
            },
            min: -4,
            max: 4,
            step: 0.05
          });
        };
        Oe(re, (Me) => {
          (e.spec.mode ?? "points") == "density" && Me(ie);
        });
      }
      J(H);
      var se = ae(H, 4), ne = Y(se), ce = () => e.spec.pointSize ?? 1, Ce = (Me) => e.onSpecChange({ pointSize: Me });
      g_(ne, {
        get value() {
          return ce();
        },
        set value(Me) {
          Ce(Me);
        },
        min: 1,
        max: 10,
        step: 0.05
      });
      var Pe = ae(ne, 2);
      Tu(Pe, {
        label: "Auto",
        onClick: () => e.onSpecChange({ pointSize: void 0 })
      }), J(se), J(U), X($, U);
    },
    $$slots: { default: !0 }
  }), J(R), J(O), J(D), X(t, D);
  var B = it(_);
  return o(), B;
}
const yi = 2, Lx = 4, h5 = 8, cu = 16, hu = 32, Jh = 64, zx = 128, ta = 512, ai = 1024, po = 2048, fu = 4096, Wo = 8192, Yu = 16384, jx = 32768, Th = 65536, RO = 1 << 17, az = 1 << 18, xp = 1 << 19, A2e = 1 << 20, jg = 32768, v_ = 1 << 21, f5 = 1 << 22, Zu = 1 << 23, dh = Symbol("$state"), lz = Symbol("legacy props"), E2e = Symbol(""), zf = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), d5 = 3, wp = 8, D2e = !1;
var p5 = Array.isArray, O2e = Array.prototype.indexOf, m5 = Array.from, uz = Object.defineProperty, cd = Object.getOwnPropertyDescriptor, cz = Object.getOwnPropertyDescriptors, hz = Object.prototype, F2e = Array.prototype, qx = Object.getPrototypeOf, NO = Object.isExtensible;
function T2e(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function fz() {
  var t, e, r = new Promise((n, i) => {
    t = n, e = i;
  });
  return { promise: r, resolve: t, reject: e };
}
function dz(t) {
  return t === this.v;
}
function pz(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function mz(t) {
  return !pz(t, this.v);
}
function gz(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function M2e() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function P2e(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function R2e() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function N2e(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function $2e() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function I2e() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function B2e() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function L2e() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function z2e() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function j2e() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let k0 = !1, q2e = !1;
function U2e() {
  k0 = !0;
}
const g5 = 1, v5 = 2, vz = 4, H2e = 8, V2e = 16, W2e = 1, G2e = 2, yz = "[", Ux = "[!", y5 = "]", jd = {}, ei = Symbol(), K2e = "http://www.w3.org/1999/xhtml", Q2e = [];
function bz(t, e = !1, r = !1) {
  return Jy(t, /* @__PURE__ */ new Map(), "", Q2e, null, r);
}
function Jy(t, e, r, n, i = null, o = !1) {
  if (typeof t == "object" && t !== null) {
    var s = e.get(t);
    if (s !== void 0) return s;
    if (t instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(t)
    );
    if (t instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(t)
    );
    if (p5(t)) {
      var a = (
        /** @type {Snapshot<any>} */
        Array(t.length)
      );
      e.set(t, a), i !== null && e.set(i, a);
      for (var l = 0; l < t.length; l += 1) {
        var u = t[l];
        l in t && (a[l] = Jy(u, e, r, n, null, o));
      }
      return a;
    }
    if (qx(t) === hz) {
      a = {}, e.set(t, a), i !== null && e.set(i, a);
      for (var c in t)
        a[c] = Jy(
          // @ts-expect-error
          t[c],
          e,
          r,
          n,
          null,
          o
        );
      return a;
    }
    if (t instanceof Date)
      return (
        /** @type {Snapshot<T>} */
        structuredClone(t)
      );
    if (typeof /** @type {T & { toJSON?: any } } */
    t.toJSON == "function" && !o)
      return Jy(
        /** @type {T & { toJSON(): any } } */
        t.toJSON(),
        e,
        r,
        n,
        // Associate the instance with the toJSON clone
        t
      );
  }
  if (t instanceof EventTarget)
    return (
      /** @type {Snapshot<T>} */
      t
    );
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(t)
    );
  } catch {
    return (
      /** @type {Snapshot<T>} */
      t
    );
  }
}
let Jr = null;
function qd(t) {
  Jr = t;
}
function Qi(t) {
  return (
    /** @type {T} */
    xz().get(t)
  );
}
function cs(t, e) {
  return xz().set(t, e), e;
}
function on(t, e = !1, r) {
  Jr = {
    p: Jr,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: k0 && !e ? { s: null, u: null, $: [] } : null
  };
}
function sn(t) {
  var e = (
    /** @type {ComponentContext} */
    Jr
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      Vz(n);
  }
  return e.i = !0, Jr = e.p, /** @type {T} */
  {};
}
function kp() {
  return !k0 || Jr !== null && Jr.l === null;
}
function xz(t) {
  return Jr === null && gz(), Jr.c ??= new Map(X2e(Jr) || void 0);
}
function X2e(t) {
  let e = t.p;
  for (; e !== null; ) {
    const r = e.c;
    if (r !== null)
      return r;
    e = e.p;
  }
  return null;
}
let th = [];
function wz() {
  var t = th;
  th = [], T2e(t);
}
function Yh(t) {
  if (th.length === 0 && !jm) {
    var e = th;
    queueMicrotask(() => {
      e === th && wz();
    });
  }
  th.push(t);
}
function J2e() {
  for (; th.length > 0; )
    wz();
}
function Hx(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function Y2e() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Ut = !1;
function ql(t) {
  Ut = t;
}
let dr;
function so(t) {
  if (t === null)
    throw Hx(), jd;
  return dr = t;
}
function C0() {
  return so(
    /** @type {TemplateNode} */
    /* @__PURE__ */ fl(dr)
  );
}
function fr(t) {
  if (Ut) {
    if (/* @__PURE__ */ fl(dr) !== null)
      throw Hx(), jd;
    dr = t;
  }
}
function Z2e(t = 1) {
  if (Ut) {
    for (var e = t, r = dr; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ fl(r);
    dr = r;
  }
}
function vb(t = !0) {
  for (var e = 0, r = dr; ; ) {
    if (r.nodeType === wp) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === y5) {
        if (e === 0) return r;
        e -= 1;
      } else (n === yz || n === Ux) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ fl(r)
    );
    t && r.remove(), r = i;
  }
}
function kz(t) {
  if (!t || t.nodeType !== wp)
    throw Hx(), jd;
  return (
    /** @type {Comment} */
    t.data
  );
}
function li(t) {
  if (typeof t != "object" || t === null || dh in t)
    return t;
  const e = qx(t);
  if (e !== hz && e !== F2e)
    return t;
  var r = /* @__PURE__ */ new Map(), n = p5(t), i = /* @__PURE__ */ Ue(0), o = mh, s = (a) => {
    if (mh === o)
      return a();
    var l = Yt, u = mh;
    io(null), zO(o);
    var c = a();
    return io(l), zO(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ Ue(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && B2e();
        var c = r.get(l);
        return c === void 0 ? c = s(() => {
          var h = /* @__PURE__ */ Ue(u.value);
          return r.set(l, h), h;
        }) : be(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = s(() => /* @__PURE__ */ Ue(ei));
            r.set(l, c), qm(i);
          }
        } else
          be(u, ei), qm(i);
        return !0;
      },
      get(a, l, u) {
        if (l === dh)
          return t;
        var c = r.get(l), h = l in a;
        if (c === void 0 && (!h || cd(a, l)?.writable) && (c = s(() => {
          var p = li(h ? a[l] : ei), g = /* @__PURE__ */ Ue(p);
          return g;
        }), r.set(l, c)), c !== void 0) {
          var d = j(c);
          return d === ei ? void 0 : d;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = j(c));
        } else if (u === void 0) {
          var h = r.get(l), d = h?.v;
          if (h !== void 0 && d !== ei)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === dh)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== ei || Reflect.has(a, l);
        if (u !== void 0 || tr !== null && (!c || cd(a, l)?.writable)) {
          u === void 0 && (u = s(() => {
            var d = c ? li(a[l]) : ei, p = /* @__PURE__ */ Ue(d);
            return p;
          }), r.set(l, u));
          var h = j(u);
          if (h === ei)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var h = r.get(l), d = l in a;
        if (n && l === "length")
          for (var p = u; p < /** @type {Source<number>} */
          h.v; p += 1) {
            var g = r.get(p + "");
            g !== void 0 ? be(g, ei) : p in a && (g = s(() => /* @__PURE__ */ Ue(ei)), r.set(p + "", g));
          }
        if (h === void 0)
          (!d || cd(a, l)?.writable) && (h = s(() => /* @__PURE__ */ Ue(void 0)), be(h, li(u)), r.set(l, h));
        else {
          d = h.v !== ei;
          var v = s(() => li(u));
          be(h, v);
        }
        var y = Reflect.getOwnPropertyDescriptor(a, l);
        if (y?.set && y.set.call(c, u), !d) {
          if (n && typeof l == "string") {
            var b = (
              /** @type {Source<number>} */
              r.get("length")
            ), k = Number(l);
            Number.isInteger(k) && k >= b.v && be(b, k + 1);
          }
          qm(i);
        }
        return !0;
      },
      ownKeys(a) {
        j(i);
        var l = Reflect.ownKeys(a).filter((h) => {
          var d = r.get(h);
          return d === void 0 || d.v !== ei;
        });
        for (var [u, c] of r)
          c.v !== ei && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        L2e();
      }
    }
  );
}
var y_, Cz, _z, Sz;
function b_() {
  if (y_ === void 0) {
    y_ = window, Cz = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    _z = cd(e, "firstChild").get, Sz = cd(e, "nextSibling").get, NO(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), NO(r) && (r.__t = void 0);
  }
}
function rl(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Mh(t) {
  return _z.call(t);
}
// @__NO_SIDE_EFFECTS__
function fl(t) {
  return Sz.call(t);
}
function yr(t, e) {
  if (!Ut)
    return /* @__PURE__ */ Mh(t);
  var r = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ Mh(dr)
  );
  if (r === null)
    r = dr.appendChild(rl());
  else if (e && r.nodeType !== d5) {
    var n = rl();
    return r?.before(n), so(n), n;
  }
  return so(r), r;
}
function Lo(t, e = !1) {
  if (!Ut) {
    var r = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Mh(
        /** @type {Node} */
        t
      )
    );
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ fl(r) : r;
  }
  if (e && dr?.nodeType !== d5) {
    var n = rl();
    return dr?.before(n), so(n), n;
  }
  return dr;
}
function ms(t, e = 1, r = !1) {
  let n = Ut ? dr : t;
  for (var i; e--; )
    i = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ fl(n);
  if (!Ut)
    return n;
  if (r && n?.nodeType !== d5) {
    var o = rl();
    return n === null ? i?.after(o) : n.before(o), so(o), o;
  }
  return so(n), /** @type {TemplateNode} */
  n;
}
function Az(t) {
  t.textContent = "";
}
function Ez(t) {
  var e = tr;
  if (e === null)
    return Yt.f |= Zu, t;
  if ((e.f & jx) === 0) {
    if ((e.f & zx) === 0)
      throw t;
    e.b.error(t);
  } else
    Ud(t, e);
}
function Ud(t, e) {
  for (; e !== null; ) {
    if ((e.f & zx) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const ky = /* @__PURE__ */ new Set();
let Sn = null, zo = null, Fa = [], Vx = null, x_ = !1, jm = !1;
class La {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #l = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #a = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Fa = [], this.apply();
    var r = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const n of e)
      this.#o(n, r);
    this.is_fork || this.#u(), this.#n > 0 || this.is_fork ? (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects)) : (Sn = null, $O(r.render_effects), $O(r.effects), this.#l?.resolve()), zo = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(e, r) {
    e.f ^= ai;
    for (var n = e.first; n !== null; ) {
      var i = n.f, o = (i & (hu | Jh)) !== 0, s = o && (i & ai) !== 0, a = s || (i & Wo) !== 0 || this.skipped_effects.has(n);
      if ((n.f & zx) !== 0 && n.b?.is_pending() && (r = {
        parent: r,
        effect: n,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !a && n.fn !== null) {
        o ? n.f ^= ai : (i & Lx) !== 0 ? r.effects.push(n) : _0(n) && ((n.f & cu) !== 0 && r.block_effects.push(n), Ug(n));
        var l = n.first;
        if (l !== null) {
          n = l;
          continue;
        }
      }
      var u = n.parent;
      for (n = n.next; n === null && u !== null; )
        u === r.effect && (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects), r = /** @type {EffectTarget} */
        r.parent), n = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #s(e) {
    for (const r of e)
      ((r.f & po) !== 0 ? this.#a : this.#i).push(r), di(r, ai);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    this.previous.has(e) || this.previous.set(e, r), (e.f & Zu) === 0 && (this.current.set(e, e.v), zo?.set(e, e.v));
  }
  activate() {
    Sn = this, this.apply();
  }
  deactivate() {
    Sn = null, zo = null;
  }
  flush() {
    if (this.activate(), Fa.length > 0) {
      if (Dz(), Sn !== null && Sn !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#n === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#r === 0 && this.#c();
  }
  #c() {
    if (ky.size > 1) {
      this.previous.clear();
      var e = zo, r = !0, n = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of ky) {
        if (i === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (i.current.has(a))
            if (r && l !== i.current.get(a))
              i.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const s = [...i.current.keys()].filter((a) => !this.current.has(a));
        if (s.length > 0) {
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            Oz(u, s, a, l);
          if (Fa.length > 0) {
            Sn = i, i.apply();
            for (const u of Fa)
              i.#o(u, n);
            Fa = [], i.deactivate();
          }
        }
      }
      Sn = null, zo = e;
    }
    this.committed = !0, ky.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), this.revive();
  }
  revive() {
    for (const e of this.#a)
      di(e, po), Ph(e);
    for (const e of this.#i)
      di(e, fu), Ph(e);
    this.#a = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#l ??= fz()).promise;
  }
  static ensure() {
    if (Sn === null) {
      const e = Sn = new La();
      ky.add(Sn), jm || La.enqueue(() => {
        Sn === e && e.flush();
      });
    }
    return Sn;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    Yh(e);
  }
  apply() {
  }
}
function eke(t) {
  var e = jm;
  jm = !0;
  try {
    for (var r; ; ) {
      if (J2e(), Fa.length === 0 && (Sn?.flush(), Fa.length === 0))
        return Vx = null, /** @type {T} */
        r;
      Dz();
    }
  } finally {
    jm = e;
  }
}
function Dz() {
  var t = ph;
  x_ = !0;
  try {
    var e = 0;
    for (BO(!0); Fa.length > 0; ) {
      var r = La.ensure();
      if (e++ > 1e3) {
        var n, i;
        tke();
      }
      r.process(Fa), ec.clear();
    }
  } finally {
    x_ = !1, BO(t), Vx = null;
  }
}
function tke() {
  try {
    $2e();
  } catch (t) {
    Ud(t, Vx);
  }
}
let Tl = null;
function $O(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (Yu | Wo)) === 0 && _0(n) && (Tl = /* @__PURE__ */ new Set(), Ug(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null && n.ac === null ? Kz(n) : n.fn = null), Tl?.size > 0)) {
        ec.clear();
        for (const i of Tl) {
          if ((i.f & (Yu | Wo)) !== 0) continue;
          const o = [i];
          let s = i.parent;
          for (; s !== null; )
            Tl.has(s) && (Tl.delete(s), o.push(s)), s = s.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (Yu | Wo)) === 0 && Ug(l);
          }
        }
        Tl.clear();
      }
    }
    Tl = null;
  }
}
function Oz(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const o = i.f;
      (o & yi) !== 0 ? Oz(
        /** @type {Derived} */
        i,
        e,
        r,
        n
      ) : (o & (f5 | cu)) !== 0 && (o & po) === 0 && // we may have scheduled this one already
      Fz(i, e, n) && (di(i, po), Ph(
        /** @type {Effect} */
        i
      ));
    }
}
function Fz(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & yi) !== 0 && Fz(
        /** @type {Derived} */
        i,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function Ph(t) {
  for (var e = Vx = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (x_ && e === tr && (r & cu) !== 0 && (r & az) === 0)
      return;
    if ((r & (Jh | hu)) !== 0) {
      if ((r & ai) === 0) return;
      e.f ^= ai;
    }
  }
  Fa.push(e);
}
function rke(t) {
  let e = 0, r = Rh(0), n;
  return () => {
    Gx() && (j(r), w5(() => (e === 0 && (n = S0(() => t(() => qm(r)))), e += 1, () => {
      Yh(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, qm(r));
      });
    })));
  };
}
var nke = Th | xp | zx;
function ike(t, e, r) {
  new oke(t, e, r);
}
class oke {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #r = Ut ? dr : null;
  /** @type {BoundaryProps} */
  #n;
  /** @type {((anchor: Node) => void)} */
  #l;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #h = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #f = null;
  #v = rke(() => (this.#f = Rh(this.#d), () => {
    this.#f = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#t = e, this.#n = r, this.#l = n, this.parent = /** @type {Effect} */
    tr.b, this.#e = !!this.#n.pending, this.#a = E0(() => {
      if (tr.b = this, Ut) {
        const o = this.#r;
        C0(), /** @type {Comment} */
        o.nodeType === wp && /** @type {Comment} */
        o.data === Ux ? this.#b() : this.#y();
      } else {
        var i = this.#x();
        try {
          this.#i = Bs(() => n(i));
        } catch (o) {
          this.error(o);
        }
        this.#h > 0 ? this.#g() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, nke), Ut && (this.#t = dr);
  }
  #y() {
    try {
      this.#i = Bs(() => this.#l(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #b() {
    const e = this.#n.pending;
    e && (this.#o = Bs(() => e(this.#t)), La.enqueue(() => {
      var r = this.#x();
      this.#i = this.#m(() => (La.ensure(), Bs(() => this.#l(r)))), this.#h > 0 ? this.#g() : (hd(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = rl(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#n.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(e) {
    var r = tr, n = Yt, i = Jr;
    nl(this.#a), io(this.#a), qd(this.#a.ctx);
    try {
      return e();
    } catch (o) {
      return Ez(o), null;
    } finally {
      nl(r), io(n), qd(i);
    }
  }
  #g() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#n.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), Jz(this.#i, this.#u)), this.#o === null && (this.#o = Bs(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#h += e, this.#h === 0 && (this.#e = !1, this.#o && hd(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#f && Hd(this.#f, this.#d);
  }
  get_effect_pending() {
    return this.#v(), j(
      /** @type {Source<number>} */
      this.#f
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#n.onerror;
    let n = this.#n.failed;
    if (this.#p || !r && !n)
      throw e;
    this.#i && (Bi(this.#i), this.#i = null), this.#o && (Bi(this.#o), this.#o = null), this.#s && (Bi(this.#s), this.#s = null), Ut && (so(
      /** @type {TemplateNode} */
      this.#r
    ), Z2e(), so(vb()));
    var i = !1, o = !1;
    const s = () => {
      if (i) {
        Y2e();
        return;
      }
      i = !0, o && j2e(), La.ensure(), this.#d = 0, this.#s !== null && hd(this.#s, () => {
        this.#s = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#m(() => (this.#p = !1, Bs(() => this.#l(this.#t)))), this.#h > 0 ? this.#g() : this.#e = !1;
    };
    var a = Yt;
    try {
      io(null), o = !0, r?.(e, s), o = !1;
    } catch (l) {
      Ud(l, this.#a && this.#a.parent);
    } finally {
      io(a);
    }
    n && Yh(() => {
      this.#s = this.#m(() => {
        La.ensure(), this.#p = !0;
        try {
          return Bs(() => {
            n(
              this.#t,
              () => e,
              () => s
            );
          });
        } catch (l) {
          return Ud(
            l,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function ske(t, e, r, n) {
  const i = kp() ? Wx : Tz;
  if (r.length === 0 && t.length === 0) {
    n(e.map(i));
    return;
  }
  var o = Sn, s = (
    /** @type {Effect} */
    tr
  ), a = ake();
  function l() {
    Promise.all(r.map((u) => /* @__PURE__ */ lke(u))).then((u) => {
      a();
      try {
        n([...e.map(i), ...u]);
      } catch (c) {
        (s.f & Yu) === 0 && Ud(c, s);
      }
      o?.deactivate(), yb();
    }).catch((u) => {
      Ud(u, s);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    a();
    try {
      return l();
    } finally {
      o?.deactivate(), yb();
    }
  }) : l();
}
function ake() {
  var t = tr, e = Yt, r = Jr, n = Sn;
  return function(i = !0) {
    nl(t), io(e), qd(r), i && n?.activate();
  };
}
function yb() {
  nl(null), io(null), qd(null);
}
// @__NO_SIDE_EFFECTS__
function Wx(t) {
  var e = yi | po, r = Yt !== null && (Yt.f & yi) !== 0 ? (
    /** @type {Derived} */
    Yt
  ) : null;
  return tr !== null && (tr.f |= xp), {
    ctx: Jr,
    deps: null,
    effects: null,
    equals: dz,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      ei
    ),
    wv: 0,
    parent: r ?? tr,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function lke(t, e) {
  let r = (
    /** @type {Effect | null} */
    tr
  );
  r === null && M2e();
  var n = (
    /** @type {Boundary} */
    r.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), o = Rh(
    /** @type {V} */
    ei
  ), s = !Yt, a = /* @__PURE__ */ new Map();
  return bke(() => {
    var l = fz();
    i = l.promise;
    try {
      Promise.resolve(t()).then(l.resolve, l.reject).then(() => {
        u === Sn && u.committed && u.deactivate(), yb();
      });
    } catch (d) {
      l.reject(d), yb();
    }
    var u = (
      /** @type {Batch} */
      Sn
    );
    if (s) {
      var c = !n.is_pending();
      n.update_pending_count(1), u.increment(c), a.get(u)?.reject(zf), a.delete(u), a.set(u, l);
    }
    const h = (d, p = void 0) => {
      if (u.activate(), p)
        p !== zf && (o.f |= Zu, Hd(o, p));
      else {
        (o.f & Zu) !== 0 && (o.f ^= Zu), Hd(o, d);
        for (const [g, v] of a) {
          if (a.delete(g), g === u) break;
          v.reject(zf);
        }
      }
      s && (n.update_pending_count(-1), u.decrement(c));
    };
    l.promise.then(h, (d) => h(null, d || "unknown"));
  }), Hz(() => {
    for (const l of a.values())
      l.reject(zf);
  }), new Promise((l) => {
    function u(c) {
      function h() {
        c === i ? l(o) : u(i);
      }
      c.then(h, h);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function Se(t) {
  const e = /* @__PURE__ */ Wx(t);
  return Iz(e), e;
}
// @__NO_SIDE_EFFECTS__
function Tz(t) {
  const e = /* @__PURE__ */ Wx(t);
  return e.equals = mz, e;
}
function Mz(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Bi(
        /** @type {Effect} */
        e[r]
      );
  }
}
function uke(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & yi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function b5(t) {
  var e, r = tr;
  nl(uke(t));
  try {
    t.f &= ~jg, Mz(t), e = jz(t);
  } finally {
    nl(r);
  }
  return e;
}
function Pz(t) {
  var e = b5(t);
  if (t.equals(e) || (t.v = e, t.wv = Lz()), !Zh)
    if (zo !== null)
      Gx() && zo.set(t, t.v);
    else {
      var r = (t.f & ta) === 0 ? fu : ai;
      di(t, r);
    }
}
let w_ = /* @__PURE__ */ new Set();
const ec = /* @__PURE__ */ new Map();
let Rz = !1;
function Rh(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: dz,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function Ue(t, e) {
  const r = Rh(t);
  return Iz(r), r;
}
// @__NO_SIDE_EFFECTS__
function Nz(t, e = !1, r = !0) {
  const n = Rh(t);
  return e || (n.equals = mz), k0 && r && Jr !== null && Jr.l !== null && (Jr.l.s ??= []).push(n), n;
}
function be(t, e, r = !1) {
  Yt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!za || (Yt.f & RO) !== 0) && kp() && (Yt.f & (yi | cu | f5 | RO)) !== 0 && !Kl?.includes(t) && z2e();
  let n = r ? li(e) : e;
  return Hd(t, n);
}
function Hd(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Zh ? ec.set(t, e) : ec.set(t, r), t.v = e;
    var n = La.ensure();
    n.capture(t, r), (t.f & yi) !== 0 && ((t.f & po) !== 0 && b5(
      /** @type {Derived} */
      t
    ), di(t, (t.f & ta) !== 0 ? ai : fu)), t.wv = Lz(), $z(t, po), kp() && tr !== null && (tr.f & ai) !== 0 && (tr.f & (hu | Jh)) === 0 && (us === null ? fke([t]) : us.push(t)), !n.is_fork && w_.size > 0 && !Rz && cke();
  }
  return e;
}
function cke() {
  Rz = !1;
  const t = Array.from(w_);
  for (const e of t)
    (e.f & ai) !== 0 && di(e, fu), _0(e) && Ug(e);
  w_.clear();
}
function qm(t) {
  be(t, t.v + 1);
}
function $z(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = kp(), i = r.length, o = 0; o < i; o++) {
      var s = r[o], a = s.f;
      if (!(!n && s === tr)) {
        var l = (a & po) === 0;
        if (l && di(s, e), (a & yi) !== 0) {
          var u = (
            /** @type {Derived} */
            s
          );
          zo?.delete(u), (a & jg) === 0 && (a & ta && (s.f |= jg), $z(u, fu));
        } else l && ((a & cu) !== 0 && Tl !== null && Tl.add(
          /** @type {Effect} */
          s
        ), Ph(
          /** @type {Effect} */
          s
        ));
      }
    }
}
let IO = !1;
function hke() {
  IO || (IO = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function x5(t) {
  var e = Yt, r = tr;
  io(null), nl(null);
  try {
    return t();
  } finally {
    io(e), nl(r);
  }
}
let ph = !1;
function BO(t) {
  ph = t;
}
let Zh = !1;
function LO(t) {
  Zh = t;
}
let Yt = null, za = !1;
function io(t) {
  Yt = t;
}
let tr = null;
function nl(t) {
  tr = t;
}
let Kl = null;
function Iz(t) {
  Yt !== null && (Kl === null ? Kl = [t] : Kl.push(t));
}
let Di = null, Fo = 0, us = null;
function fke(t) {
  us = t;
}
let Bz = 1, qg = 0, mh = qg;
function zO(t) {
  mh = t;
}
function Lz() {
  return ++Bz;
}
function _0(t) {
  var e = t.f;
  if ((e & po) !== 0)
    return !0;
  if (e & yi && (t.f &= ~jg), (e & fu) !== 0) {
    var r = t.deps;
    if (r !== null)
      for (var n = r.length, i = 0; i < n; i++) {
        var o = r[i];
        if (_0(
          /** @type {Derived} */
          o
        ) && Pz(
          /** @type {Derived} */
          o
        ), o.wv > t.wv)
          return !0;
      }
    (e & ta) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    zo === null && di(t, ai);
  }
  return !1;
}
function zz(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !Kl?.includes(t))
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      (o.f & yi) !== 0 ? zz(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? di(o, po) : (o.f & ai) !== 0 && di(o, fu), Ph(
        /** @type {Effect} */
        o
      ));
    }
}
function jz(t) {
  var e = Di, r = Fo, n = us, i = Yt, o = Kl, s = Jr, a = za, l = mh, u = t.f;
  Di = /** @type {null | Value[]} */
  null, Fo = 0, us = null, Yt = (u & (hu | Jh)) === 0 ? t : null, Kl = null, qd(t.ctx), za = !1, mh = ++qg, t.ac !== null && (x5(() => {
    t.ac.abort(zf);
  }), t.ac = null);
  try {
    t.f |= v_;
    var c = (
      /** @type {Function} */
      t.fn
    ), h = c(), d = t.deps;
    if (Di !== null) {
      var p;
      if (bb(t, Fo), d !== null && Fo > 0)
        for (d.length = Fo + Di.length, p = 0; p < Di.length; p++)
          d[Fo + p] = Di[p];
      else
        t.deps = d = Di;
      if (ph && Gx() && (t.f & ta) !== 0)
        for (p = Fo; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Fo < d.length && (bb(t, Fo), d.length = Fo);
    if (kp() && us !== null && !za && d !== null && (t.f & (yi | fu | po)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      us.length; p++)
        zz(
          us[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (qg++, us !== null && (n === null ? n = us : n.push(.../** @type {Source[]} */
    us))), (t.f & Zu) !== 0 && (t.f ^= Zu), h;
  } catch (g) {
    return Ez(g);
  } finally {
    t.f ^= v_, Di = e, Fo = r, us = n, Yt = i, Kl = o, qd(s), za = a, mh = l;
  }
}
function dke(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = O2e.call(r, t);
    if (n !== -1) {
      var i = r.length - 1;
      i === 0 ? r = e.reactions = null : (r[n] = r[i], r.pop());
    }
  }
  r === null && (e.f & yi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Di === null || !Di.includes(e)) && (di(e, fu), (e.f & ta) !== 0 && (e.f ^= ta, e.f &= ~jg), Mz(
    /** @type {Derived} **/
    e
  ), bb(
    /** @type {Derived} **/
    e,
    0
  ));
}
function bb(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      dke(t, r[n]);
}
function Ug(t) {
  var e = t.f;
  if ((e & Yu) === 0) {
    di(t, ai);
    var r = tr, n = ph;
    tr = t, ph = !0;
    try {
      (e & cu) !== 0 ? xke(t) : Gz(t), Wz(t);
      var i = jz(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = Bz;
      var o;
      D2e && q2e && (t.f & po) !== 0 && t.deps;
    } finally {
      ph = n, tr = r;
    }
  }
}
function j(t) {
  var e = t.f, r = (e & yi) !== 0;
  if (Yt !== null && !za) {
    var n = tr !== null && (tr.f & Yu) !== 0;
    if (!n && !Kl?.includes(t)) {
      var i = Yt.deps;
      if ((Yt.f & v_) !== 0)
        t.rv < qg && (t.rv = qg, Di === null && i !== null && i[Fo] === t ? Fo++ : Di === null ? Di = [t] : Di.includes(t) || Di.push(t));
      else {
        (Yt.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Yt] : o.includes(Yt) || o.push(Yt);
      }
    }
  }
  if (Zh) {
    if (ec.has(t))
      return ec.get(t);
    if (r) {
      var s = (
        /** @type {Derived} */
        t
      ), a = s.v;
      return ((s.f & ai) === 0 && s.reactions !== null || Uz(s)) && (a = b5(s)), ec.set(s, a), a;
    }
  } else if (r) {
    if (s = /** @type {Derived} */
    t, zo?.has(s))
      return zo.get(s);
    _0(s) && Pz(s), ph && Gx() && (s.f & ta) === 0 && qz(s);
  } else if (zo?.has(t))
    return zo.get(t);
  if ((t.f & Zu) !== 0)
    throw t.v;
  return t.v;
}
function qz(t) {
  if (t.deps !== null) {
    t.f ^= ta;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & yi) !== 0 && (e.f & ta) === 0 && qz(
        /** @type {Derived} */
        e
      );
  }
}
function Uz(t) {
  if (t.v === ei) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (ec.has(e) || (e.f & yi) !== 0 && Uz(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function S0(t) {
  var e = za;
  try {
    return za = !0, t();
  } finally {
    za = e;
  }
}
const pke = -7169;
function di(t, e) {
  t.f = t.f & pke | e;
}
function mke(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (dh in t)
      k_(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && dh in r && k_(r);
      }
  }
}
function k_(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        k_(t[n], e);
      } catch {
      }
    const r = qx(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = cz(r);
      for (let i in n) {
        const o = n[i].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
function gke(t) {
  tr === null && (Yt === null && N2e(), R2e()), Zh && P2e();
}
function vke(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function du(t, e, r, n = !0) {
  var i = tr;
  i !== null && (i.f & Wo) !== 0 && (t |= Wo);
  var o = {
    ctx: Jr,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | po | ta,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      Ug(o), o.f |= jx;
    } catch (l) {
      throw Bi(o), l;
    }
  else e !== null && Ph(o);
  if (n) {
    var s = o;
    if (r && s.deps === null && s.teardown === null && s.nodes_start === null && s.first === s.last && // either `null`, or a singular child
    (s.f & xp) === 0 && (s = s.first, (t & cu) !== 0 && (t & Th) !== 0 && s !== null && (s.f |= Th)), s !== null && (s.parent = i, i !== null && vke(s, i), Yt !== null && (Yt.f & yi) !== 0 && (t & Jh) === 0)) {
      var a = (
        /** @type {Derived} */
        Yt
      );
      (a.effects ??= []).push(s);
    }
  }
  return o;
}
function Gx() {
  return Yt !== null && !za;
}
function Hz(t) {
  const e = du(h5, null, !1);
  return di(e, ai), e.teardown = t, e;
}
function Kr(t) {
  gke();
  var e = (
    /** @type {Effect} */
    tr.f
  ), r = !Yt && (e & hu) !== 0 && (e & jx) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      Jr
    );
    (n.e ??= []).push(t);
  } else
    return Vz(t);
}
function Vz(t) {
  return du(Lx | A2e, t, !1);
}
function yke(t) {
  La.ensure();
  const e = du(Jh | xp, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? hd(e, () => {
      Bi(e), n(void 0);
    }) : (Bi(e), n(void 0));
  });
}
function A0(t) {
  return du(Lx, t, !1);
}
function bke(t) {
  return du(f5 | xp, t, !0);
}
function w5(t, e = 0) {
  return du(h5 | e, t, !0);
}
function pn(t, e = [], r = [], n = [], i = !1) {
  ske(n, e, r, (o) => {
    du(i ? Lx : h5, () => t(...o.map(j)), !0);
  });
}
function E0(t, e = 0) {
  var r = du(cu | e, t, !0);
  return r;
}
function Bs(t, e = !0) {
  return du(hu | xp, t, !0, e);
}
function Wz(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Zh, n = Yt;
    LO(!0), io(null);
    try {
      e.call(null);
    } finally {
      LO(r), io(n);
    }
  }
}
function Gz(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const i = r.ac;
    i !== null && x5(() => {
      i.abort(zf);
    });
    var n = r.next;
    (r.f & Jh) !== 0 ? r.parent = null : Bi(r, e), r = n;
  }
}
function xke(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & hu) === 0 && Bi(e), e = r;
  }
}
function Bi(t, e = !0) {
  var r = !1;
  (e || (t.f & az) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (wke(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), r = !0), Gz(t, e && !r), bb(t, 0), di(t, Yu);
  var n = t.transitions;
  if (n !== null)
    for (const o of n)
      o.stop();
  Wz(t);
  var i = t.parent;
  i !== null && i.first !== null && Kz(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function wke(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ fl(t)
    );
    t.remove(), t = r;
  }
}
function Kz(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function hd(t, e, r = !0) {
  var n = [];
  k5(t, n, !0), Qz(n, () => {
    r && Bi(t), e && e();
  });
}
function Qz(t, e) {
  var r = t.length;
  if (r > 0) {
    var n = () => --r || e();
    for (var i of t)
      i.out(n);
  } else
    e();
}
function k5(t, e, r) {
  if ((t.f & Wo) === 0) {
    if (t.f ^= Wo, t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || r) && e.push(s);
    for (var n = t.first; n !== null; ) {
      var i = n.next, o = (n.f & Th) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (n.f & hu) !== 0 && (t.f & cu) !== 0;
      k5(n, e, o ? r : !1), n = i;
    }
  }
}
function C5(t) {
  Xz(t, !0);
}
function Xz(t, e) {
  if ((t.f & Wo) !== 0) {
    t.f ^= Wo, (t.f & ai) === 0 && (di(t, po), Ph(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, i = (r.f & Th) !== 0 || (r.f & hu) !== 0;
      Xz(r, i ? e : !1), r = n;
    }
    if (t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || e) && o.in();
  }
}
function Jz(t, e) {
  for (var r = t.nodes_start, n = t.nodes_end; r !== null; ) {
    var i = r === n ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ fl(r)
    );
    e.append(r), r = i;
  }
}
const Yz = /* @__PURE__ */ new Set(), C_ = /* @__PURE__ */ new Set();
function kke(t) {
  if (!Ut) return;
  t.removeAttribute("onload"), t.removeAttribute("onerror");
  const e = t.__e;
  e !== void 0 && (t.__e = void 0, queueMicrotask(() => {
    t.isConnected && t.dispatchEvent(e);
  }));
}
function Cke(t, e, r, n = {}) {
  function i(o) {
    if (n.capture || km.call(e, o), !o.cancelBubble)
      return x5(() => r?.call(this, o));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? Yh(() => {
    e.addEventListener(t, i, n);
  }) : e.addEventListener(t, i, n), i;
}
function Vd(t, e, r, n, i) {
  var o = { capture: n, passive: i }, s = Cke(t, e, r, o);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && Hz(() => {
    e.removeEventListener(t, s, o);
  });
}
function pu(t) {
  for (var e = 0; e < t.length; e++)
    Yz.add(t[e]);
  for (var r of C_)
    r(t);
}
let jO = null;
function km(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, i = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  jO = t;
  var s = 0, a = jO === t && t.__root;
  if (a) {
    var l = i.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    l <= u && (s = l);
  }
  if (o = /** @type {Element} */
  i[s] || t.target, o !== e) {
    uz(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Yt, h = tr;
    io(null), nl(null);
    try {
      for (var d, p = []; o !== null; ) {
        var g = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var v = o["__" + n];
          v != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && v.call(o, t);
        } catch (y) {
          d ? p.push(y) : d = y;
        }
        if (t.cancelBubble || g === e || g === null)
          break;
        o = g;
      }
      if (d) {
        for (let y of p)
          queueMicrotask(() => {
            throw y;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, io(c), nl(h);
    }
  }
}
function _ke(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function fd(t, e) {
  var r = (
    /** @type {Effect} */
    tr
  );
  r.nodes_start === null && (r.nodes_start = t, r.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function lr(t, e) {
  var r = (e & W2e) !== 0, n = (e & G2e) !== 0, i, o = !t.startsWith("<!>");
  return () => {
    if (Ut)
      return fd(dr, null), dr;
    i === void 0 && (i = _ke(o ? t : "<!>" + t), r || (i = /** @type {Node} */
    /* @__PURE__ */ Mh(i)));
    var s = (
      /** @type {TemplateNode} */
      n || Cz ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Mh(s)
      ), l = (
        /** @type {TemplateNode} */
        s.lastChild
      );
      fd(a, l);
    } else
      fd(s, s);
    return s;
  };
}
function zc() {
  if (Ut)
    return fd(dr, null), dr;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = rl();
  return t.append(e, r), fd(e, r), t;
}
function Mt(t, e) {
  if (Ut) {
    var r = (
      /** @type {Effect} */
      tr
    );
    ((r.f & jx) === 0 || r.nodes_end === null) && (r.nodes_end = dr), C0();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
const Ske = ["touchstart", "touchmove"];
function Ake(t) {
  return Ske.includes(t);
}
function dl(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function Zz(t, e) {
  return ej(t, e);
}
function Eke(t, e) {
  b_(), e.intro = e.intro ?? !1;
  const r = e.target, n = Ut, i = dr;
  try {
    for (var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Mh(r)
    ); o && (o.nodeType !== wp || /** @type {Comment} */
    o.data !== yz); )
      o = /** @type {TemplateNode} */
      /* @__PURE__ */ fl(o);
    if (!o)
      throw jd;
    ql(!0), so(
      /** @type {Comment} */
      o
    );
    const s = ej(t, { ...e, anchor: o });
    return ql(!1), /**  @type {Exports} */
    s;
  } catch (s) {
    if (s instanceof Error && s.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw s;
    return s !== jd && console.warn("Failed to hydrate: ", s), e.recover === !1 && I2e(), b_(), Az(r), ql(!1), Zz(t, e);
  } finally {
    ql(n), so(i);
  }
}
const Cf = /* @__PURE__ */ new Map();
function ej(t, { target: e, anchor: r, props: n = {}, events: i, context: o, intro: s = !0 }) {
  b_();
  var a = /* @__PURE__ */ new Set(), l = (h) => {
    for (var d = 0; d < h.length; d++) {
      var p = h[d];
      if (!a.has(p)) {
        a.add(p);
        var g = Ake(p);
        e.addEventListener(p, km, { passive: g });
        var v = Cf.get(p);
        v === void 0 ? (document.addEventListener(p, km, { passive: g }), Cf.set(p, 1)) : Cf.set(p, v + 1);
      }
    }
  };
  l(m5(Yz)), C_.add(l);
  var u = void 0, c = yke(() => {
    var h = r ?? e.appendChild(rl());
    return ike(
      /** @type {TemplateNode} */
      h,
      {
        pending: () => {
        }
      },
      (d) => {
        if (o) {
          on({});
          var p = (
            /** @type {ComponentContext} */
            Jr
          );
          p.c = o;
        }
        if (i && (n.$$events = i), Ut && fd(
          /** @type {TemplateNode} */
          d,
          null
        ), u = t(d, n) || {}, Ut && (tr.nodes_end = dr, dr === null || dr.nodeType !== wp || /** @type {Comment} */
        dr.data !== y5))
          throw Hx(), jd;
        o && sn();
      }
    ), () => {
      for (var d of a) {
        e.removeEventListener(d, km);
        var p = (
          /** @type {number} */
          Cf.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, km), Cf.delete(d)) : Cf.set(d, p);
      }
      C_.delete(l), h !== r && h.parentNode?.removeChild(h);
    };
  });
  return __.set(u, c), u;
}
let __ = /* @__PURE__ */ new WeakMap();
function Dke(t, e) {
  const r = __.get(t);
  return r ? (__.delete(t), r(e)) : Promise.resolve();
}
function Oke(t) {
  return new Fke(t);
}
class Fke {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, s) => {
      var a = /* @__PURE__ */ Nz(s, !1, !1);
      return r.set(o, a), a;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, s) {
          return j(r.get(s) ?? n(s, Reflect.get(o, s)));
        },
        has(o, s) {
          return s === lz ? !0 : (j(r.get(s) ?? n(s, Reflect.get(o, s))), Reflect.has(o, s));
        },
        set(o, s, a) {
          return be(r.get(s) ?? n(s, a), a), Reflect.set(o, s, a);
        }
      }
    );
    this.#t = (e.hydrate ? Eke : Zz)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && eke(), this.#e = i.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || uz(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(s) {
          this.#t[o] = s;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(i, o);
    }, this.#t.$destroy = () => {
      Dke(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...i) => r.call(this, ...i);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const Tke = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(Tke);
class _5 {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #r = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#n = r;
  }
  #l = () => {
    var e = (
      /** @type {Batch} */
      Sn
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        C5(n);
      else {
        var i = this.#r.get(r);
        i && (this.#t.set(r, i.effect), this.#r.delete(r), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), n = i.effect);
      }
      for (const [o, s] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(s);
        a && (Bi(a.effect), this.#r.delete(s));
      }
      for (const [o, s] of this.#t) {
        if (o === r) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var l = document.createDocumentFragment();
            Jz(s, l), l.append(rl()), this.#r.set(o, { effect: s, fragment: l });
          } else
            Bi(s);
          this.#t.delete(o);
        };
        this.#n || !n ? hd(s, a, !1) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #a = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, i] of this.#r)
      r.includes(n) || (Bi(i.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      Sn
    );
    r && !this.#t.has(e) && !this.#r.has(e) && this.#t.set(
      e,
      Bs(() => r(this.anchor))
    ), this.#e.set(n, e), Ut && (this.anchor = dr), this.#l();
  }
}
function S5(t, e, ...r) {
  var n = new _5(t);
  E0(() => {
    const i = e() ?? null;
    n.ensure(i, i && ((o) => i(o, ...r)));
  }, Th);
}
function Cp(t) {
  Jr === null && gz(), k0 && Jr.l !== null ? Mke(Jr).m.push(t) : Kr(() => {
    const e = S0(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function Mke(t) {
  var e = (
    /** @type {ComponentContextLegacy} */
    t.l
  );
  return e.u ??= { a: [], b: [], m: [] };
}
function Xi(t, e, r = !1) {
  Ut && C0();
  var n = new _5(t), i = r ? Th : 0;
  function o(s, a) {
    if (Ut) {
      const u = kz(t) === Ux;
      if (s === u) {
        var l = vb();
        so(l), n.anchor = l, ql(!1), n.ensure(s, a), ql(!0);
        return;
      }
    }
    n.ensure(s, a);
  }
  E0(() => {
    var s = !1;
    e((a, l = !0) => {
      s = !0, o(l, a);
    }), s || o(!1, null);
  }, i);
}
function Pke(t, e, r) {
  Ut && C0();
  var n = new _5(t), i = !kp();
  E0(() => {
    var o = e();
    i && o !== null && typeof o == "object" && (o = /** @type {V} */
    {}), n.ensure(o, r);
  });
}
function Rke(t, e) {
  return e;
}
function Nke(t, e, r) {
  for (var n = t.items, i = [], o = e.length, s = 0; s < o; s++)
    k5(e[s].e, i, !0);
  var a = o > 0 && i.length === 0 && r !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      r.parentNode
    );
    Az(l), l.append(
      /** @type {Element} */
      r
    ), n.clear(), ka(t, e[0].prev, e[o - 1].next);
  }
  Qz(i, () => {
    for (var u = 0; u < o; u++) {
      var c = e[u];
      a || (n.delete(c.k), ka(t, c.prev, c.next)), Bi(c.e, !a);
    }
  });
}
function Um(t, e, r, n, i, o = null) {
  var s = t, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & vz) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    s = Ut ? so(
      /** @type {Comment | Text} */
      /* @__PURE__ */ Mh(u)
    ) : u.appendChild(rl());
  }
  Ut && C0();
  var c = null, h = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ Tz(() => {
    var b = r();
    return p5(b) ? b : b == null ? [] : m5(b);
  }), g, v;
  function y() {
    $ke(
      v,
      g,
      a,
      d,
      s,
      i,
      e,
      n,
      r
    ), o !== null && (g.length === 0 ? c ? C5(c) : c = Bs(() => o(s)) : c !== null && hd(c, () => {
      c = null;
    }));
  }
  E0(() => {
    v ??= /** @type {Effect} */
    tr, g = /** @type {V[]} */
    j(p);
    var b = g.length;
    if (h && b === 0)
      return;
    h = b === 0;
    let k = !1;
    if (Ut) {
      var C = kz(s) === Ux;
      C !== (b === 0) && (s = vb(), so(s), ql(!1), k = !0);
    }
    if (Ut) {
      for (var S = null, _, D = 0; D < b; D++) {
        if (dr.nodeType === wp && /** @type {Comment} */
        dr.data === y5) {
          s = /** @type {Comment} */
          dr, k = !0, ql(!1);
          break;
        }
        var A = g[D], O = n(A, D);
        _ = tj(
          dr,
          a,
          S,
          null,
          A,
          O,
          D,
          i,
          e,
          r
        ), a.items.set(O, _), S = _;
      }
      b > 0 && so(vb());
    }
    Ut ? b === 0 && o && (c = Bs(() => o(s))) : y(), k && ql(!0), j(p);
  }), Ut && (s = dr);
}
function $ke(t, e, r, n, i, o, s, a, l) {
  var u = (s & H2e) !== 0, c = (s & (g5 | v5)) !== 0, h = e.length, d = r.items, p = r.first, g = p, v, y = null, b, k = [], C = [], S, _, D, A;
  if (u)
    for (A = 0; A < h; A += 1)
      S = e[A], _ = a(S, A), D = d.get(_), D !== void 0 && (D.a?.measure(), (b ??= /* @__PURE__ */ new Set()).add(D));
  for (A = 0; A < h; A += 1) {
    if (S = e[A], _ = a(S, A), D = d.get(_), D === void 0) {
      var O = n.get(_);
      if (O !== void 0) {
        n.delete(_), d.set(_, O);
        var M = y ? y.next : g;
        ka(r, y, O), ka(r, O, M), Bk(O, M, i), y = O;
      } else {
        var z = g ? (
          /** @type {TemplateNode} */
          g.e.nodes_start
        ) : i;
        y = tj(
          z,
          r,
          y,
          y === null ? r.first : y.next,
          S,
          _,
          A,
          o,
          s,
          l
        );
      }
      d.set(_, y), k = [], C = [], g = y.next;
      continue;
    }
    if (c && Ike(D, S, A, s), (D.e.f & Wo) !== 0 && (C5(D.e), u && (D.a?.unfix(), (b ??= /* @__PURE__ */ new Set()).delete(D))), D !== g) {
      if (v !== void 0 && v.has(D)) {
        if (k.length < C.length) {
          var R = C[0], N;
          y = R.prev;
          var I = k[0], B = k[k.length - 1];
          for (N = 0; N < k.length; N += 1)
            Bk(k[N], R, i);
          for (N = 0; N < C.length; N += 1)
            v.delete(C[N]);
          ka(r, I.prev, B.next), ka(r, y, I), ka(r, B, R), g = R, y = B, A -= 1, k = [], C = [];
        } else
          v.delete(D), Bk(D, g, i), ka(r, D.prev, D.next), ka(r, D, y === null ? r.first : y.next), ka(r, y, D), y = D;
        continue;
      }
      for (k = [], C = []; g !== null && g.k !== _; )
        (g.e.f & Wo) === 0 && (v ??= /* @__PURE__ */ new Set()).add(g), C.push(g), g = g.next;
      if (g === null)
        continue;
      D = g;
    }
    k.push(D), y = D, g = D.next;
  }
  if (g !== null || v !== void 0) {
    for (var $ = v === void 0 ? [] : m5(v); g !== null; )
      (g.e.f & Wo) === 0 && $.push(g), g = g.next;
    var q = $.length;
    if (q > 0) {
      var U = (s & vz) !== 0 && h === 0 ? i : null;
      if (u) {
        for (A = 0; A < q; A += 1)
          $[A].a?.measure();
        for (A = 0; A < q; A += 1)
          $[A].a?.fix();
      }
      Nke(r, $, U);
    }
  }
  u && Yh(() => {
    if (b !== void 0)
      for (D of b)
        D.a?.apply();
  }), t.first = r.first && r.first.e, t.last = y && y.e;
  for (var H of n.values())
    Bi(H.e);
  n.clear();
}
function Ike(t, e, r, n) {
  (n & g5) !== 0 && Hd(t.v, e), (n & v5) !== 0 ? Hd(
    /** @type {Value<number>} */
    t.i,
    r
  ) : t.i = r;
}
function tj(t, e, r, n, i, o, s, a, l, u, c) {
  var h = (l & g5) !== 0, d = (l & V2e) === 0, p = h ? d ? /* @__PURE__ */ Nz(i, !1, !1) : Rh(i) : i, g = (l & v5) === 0 ? s : Rh(s), v = {
    i: g,
    v: p,
    k: o,
    a: null,
    // @ts-expect-error
    e: null,
    prev: r,
    next: n
  };
  try {
    if (t === null) {
      var y = document.createDocumentFragment();
      y.append(t = rl());
    }
    return v.e = Bs(() => a(
      /** @type {Node} */
      t,
      p,
      g,
      u
    ), Ut), v.e.prev = r && r.e, v.e.next = n && n.e, r === null ? c || (e.first = v) : (r.next = v, r.e.next = v.e), n !== null && (n.prev = v, n.e.prev = v.e), v;
  } finally {
  }
}
function Bk(t, e, r) {
  for (var n = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : r, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : r, o = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); o !== null && o !== n; ) {
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ fl(o)
    );
    i.before(o), o = s;
  }
}
function ka(t, e, r) {
  e === null ? t.first = r : (e.next = r, e.e.next = r && r.e), r !== null && (r.prev = e, r.e.prev = e && e.e);
}
function an(t, e) {
  A0(() => {
    var r = t.getRootNode(), n = (
      /** @type {ShadowRoot} */
      r.host ? (
        /** @type {ShadowRoot} */
        r
      ) : (
        /** @type {Document} */
        r.head ?? /** @type {Document} */
        r.ownerDocument.head
      )
    );
    if (!n.querySelector("#" + e.hash)) {
      const i = document.createElement("style");
      i.id = e.hash, i.textContent = e.code, n.appendChild(i);
    }
  });
}
function A5(t, e, r) {
  A0(() => {
    var n = S0(() => e(t, r?.()) || {});
    if (r && n?.update) {
      var i = !1, o = (
        /** @type {any} */
        {}
      );
      w5(() => {
        var s = r();
        mke(s), i && pz(o, s) && (o = s, n.update(s));
      }), i = !0;
    }
    if (n?.destroy)
      return () => (
        /** @type {Function} */
        n.destroy()
      );
  });
}
function Bke(t, e, r) {
  var n = t == null ? "" : "" + t;
  return e && (n = n ? n + " " + e : e), n === "" ? null : n;
}
function qO(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var i in t) {
    var o = t[i];
    o != null && o !== "" && (n += " " + i + ": " + o + r);
  }
  return n;
}
function Lke(t, e) {
  if (e) {
    var r = "", n, i;
    return Array.isArray(e) ? (n = e[0], i = e[1]) : n = e, n && (r += qO(n)), i && (r += qO(i, !0)), r = r.trim(), r === "" ? null : r;
  }
  return String(t);
}
function fc(t, e, r, n, i, o) {
  var s = t.__className;
  if (Ut || s !== r || s === void 0) {
    var a = Bke(r, n);
    (!Ut || a !== t.getAttribute("class")) && (a == null ? t.removeAttribute("class") : t.className = a), t.__className = r;
  }
  return o;
}
function Lk(t, e = {}, r, n) {
  for (var i in r) {
    var o = r[i];
    e[i] !== o && (r[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, o, n));
  }
}
function mo(t, e, r, n) {
  var i = t.__style;
  if (Ut || i !== e) {
    var o = Lke(e, n);
    (!Ut || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (Lk(t, r?.[0], n[0]), Lk(t, r?.[1], n[1], "important")) : Lk(t, r, n));
  return n;
}
const zke = Symbol("is custom element"), jke = Symbol("is html");
function qke(t) {
  if (Ut) {
    var e = !1, r = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var n = t.value;
          Hg(t, "value", null), t.value = n;
        }
        if (t.hasAttribute("checked")) {
          var i = t.checked;
          Hg(t, "checked", null), t.checked = i;
        }
      }
    };
    t.__on_r = r, Yh(r), hke();
  }
}
function Uke(t, e) {
  var r = rj(t);
  r.checked !== (r.checked = // treat null and undefined the same for the initial value
  e ?? void 0) && (t.checked = e);
}
function Hg(t, e, r, n) {
  var i = rj(t);
  Ut && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = r) && (e === "loading" && (t[E2e] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && Hke(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function rj(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [zke]: t.nodeName.includes("-"),
      [jke]: t.namespaceURI === K2e
    }
  );
}
var UO = /* @__PURE__ */ new Map();
function Hke(t) {
  var e = t.getAttribute("is") || t.nodeName, r = UO.get(e);
  if (r) return r;
  UO.set(e, r = []);
  for (var n, i = t, o = Element.prototype; o !== i; ) {
    n = cz(i);
    for (var s in n)
      n[s].set && r.push(s);
    i = qx(i);
  }
  return r;
}
class E5 {
  /** */
  #e = /* @__PURE__ */ new WeakMap();
  /** @type {ResizeObserver | undefined} */
  #t;
  /** @type {ResizeObserverOptions} */
  #r;
  /** @static */
  static entries = /* @__PURE__ */ new WeakMap();
  /** @param {ResizeObserverOptions} options */
  constructor(e) {
    this.#r = e;
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(e, r) {
    var n = this.#e.get(e) || /* @__PURE__ */ new Set();
    return n.add(r), this.#e.set(e, n), this.#n().observe(e, this.#r), () => {
      var i = this.#e.get(e);
      i.delete(r), i.size === 0 && (this.#e.delete(e), this.#t.unobserve(e));
    };
  }
  #n() {
    return this.#t ?? (this.#t = new ResizeObserver(
      /** @param {any} entries */
      (e) => {
        for (var r of e) {
          E5.entries.set(r.target, r);
          for (var n of this.#e.get(r.target) || [])
            n(r);
        }
      }
    ));
  }
}
var Vke = /* @__PURE__ */ new E5({
  box: "border-box"
});
function ra(t, e, r) {
  var n = Vke.observe(t, () => r(t[e]));
  A0(() => (S0(() => r(t[e])), n));
}
function HO(t, e) {
  return t === e || t?.[dh] === e;
}
function Li(t = {}, e, r, n) {
  return A0(() => {
    var i, o;
    return w5(() => {
      i = o, o = [], S0(() => {
        t !== r(...o) && (e(t, ...o), i && HO(r(...i), t) && e(null, ...i));
      });
    }), () => {
      Yh(() => {
        o && HO(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
let Cy = !1;
function Wke(t) {
  var e = Cy;
  try {
    return Cy = !1, [t(), Cy];
  } finally {
    Cy = e;
  }
}
function _p(t, e, r, n) {
  var i = (
    /** @type {V} */
    n
  ), o = !0, s = () => (o && (o = !1, i = /** @type {V} */
  n), i), a;
  {
    var l = dh in t || lz in t;
    a = cd(t, e)?.set ?? (l && e in t ? (y) => t[e] = y : void 0);
  }
  var u, c = !1;
  [u, c] = Wke(() => (
    /** @type {V} */
    t[e]
  ));
  var h;
  if (h = () => {
    var y = (
      /** @type {V} */
      t[e]
    );
    return y === void 0 ? s() : (o = !0, y);
  }, a) {
    var d = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(y, b) {
        return arguments.length > 0 ? ((!b || d || c) && a(b ? h() : y), y) : h();
      })
    );
  }
  var p = !1, g = /* @__PURE__ */ Wx(() => (p = !1, h()));
  j(g);
  var v = (
    /** @type {Effect} */
    tr
  );
  return (
    /** @type {() => V} */
    (function(y, b) {
      if (arguments.length > 0) {
        const k = b ? j(g) : li(y);
        return be(g, k), p = !0, i !== void 0 && (i = k), y;
      }
      return Zh && p || (v.f & Yu) !== 0 ? g.v : j(g);
    })
  );
}
var Lu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function D5(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Yy = { exports: {} }, Gke = Yy.exports, VO;
function Kke() {
  return VO || (VO = 1, (function(t, e) {
    (function() {
      var r, n = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", a = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", u = 500, c = "__lodash_placeholder__", h = 1, d = 2, p = 4, g = 1, v = 2, y = 1, b = 2, k = 4, C = 8, S = 16, _ = 32, D = 64, A = 128, O = 256, M = 512, z = 30, R = "...", N = 800, I = 16, B = 1, $ = 2, q = 3, U = 1 / 0, H = 9007199254740991, G = 17976931348623157e292, re = NaN, ie = 4294967295, se = ie - 1, ne = ie >>> 1, ce = [
        ["ary", A],
        ["bind", y],
        ["bindKey", b],
        ["curry", C],
        ["curryRight", S],
        ["flip", M],
        ["partial", _],
        ["partialRight", D],
        ["rearg", O]
      ], Ce = "[object Arguments]", Pe = "[object Array]", Me = "[object AsyncFunction]", _e = "[object Boolean]", he = "[object Date]", ke = "[object DOMException]", ve = "[object Error]", We = "[object Function]", Qe = "[object GeneratorFunction]", ot = "[object Map]", Ye = "[object Number]", Ht = "[object Null]", St = "[object Object]", Gt = "[object Promise]", $t = "[object Proxy]", Ge = "[object RegExp]", Ze = "[object Set]", It = "[object String]", rr = "[object Symbol]", Fe = "[object Undefined]", $e = "[object WeakMap]", lt = "[object WeakSet]", kt = "[object ArrayBuffer]", pr = "[object DataView]", Zr = "[object Float32Array]", Kt = "[object Float64Array]", Je = "[object Int8Array]", mr = "[object Int16Array]", en = "[object Int32Array]", xi = "[object Uint8Array]", pl = "[object Uint8ClampedArray]", Br = "[object Uint16Array]", qn = "[object Uint32Array]", vo = /\b__p \+= '';/g, la = /\b(__p \+=) '' \+/g, Ss = /(__e\(.*?\)|\b__t\)) \+\n'';/g, As = /&(?:amp|lt|gt|quot|#39);/g, xc = /[&<>"']/g, Kx = RegExp(As.source), Qx = RegExp(xc.source), ua = /<%-([\s\S]+?)%>/g, D0 = /<%([\s\S]+?)%>/g, O0 = /<%=([\s\S]+?)%>/g, F0 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Xx = /^\w*$/, T0 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Sp = /[\\^$.*+?()[\]{}|]/g, Jx = RegExp(Sp.source), Ap = /^\s+/, M0 = /\s/, Yx = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Zx = /\{\n\/\* \[wrapped with (.+)\] \*/, ew = /,? & /, xe = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Te = /[()=,{}\[\]\/\s]/, je = /\\(\\)?/g, Ke = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, et = /\w*$/, ht = /^[-+]0x[0-9a-f]+$/i, Vt = /^0b[01]+$/i, gr = /^\[object .+?Constructor\]$/, Sr = /^0o[0-7]+$/i, ln = /^(?:0|[1-9]\d*)$/, Jo = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Fn = /($^)/, yo = /['\n\r\u2028\u2029\\]/g, Es = "\\ud800-\\udfff", Ep = "\\u0300-\\u036f", Ds = "\\ufe20-\\ufe2f", ml = "\\u20d0-\\u20ff", gl = Ep + Ds + ml, F5 = "\\u2700-\\u27bf", T5 = "a-z\\xdf-\\xf6\\xf8-\\xff", dj = "\\xac\\xb1\\xd7\\xf7", pj = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", mj = "\\u2000-\\u206f", gj = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", M5 = "A-Z\\xc0-\\xd6\\xd8-\\xde", P5 = "\\ufe0e\\ufe0f", R5 = dj + pj + mj + gj, tw = "['â€™]", vj = "[" + Es + "]", N5 = "[" + R5 + "]", P0 = "[" + gl + "]", $5 = "\\d+", yj = "[" + F5 + "]", I5 = "[" + T5 + "]", B5 = "[^" + Es + R5 + $5 + F5 + T5 + M5 + "]", rw = "\\ud83c[\\udffb-\\udfff]", bj = "(?:" + P0 + "|" + rw + ")", L5 = "[^" + Es + "]", nw = "(?:\\ud83c[\\udde6-\\uddff]){2}", iw = "[\\ud800-\\udbff][\\udc00-\\udfff]", ef = "[" + M5 + "]", z5 = "\\u200d", j5 = "(?:" + I5 + "|" + B5 + ")", xj = "(?:" + ef + "|" + B5 + ")", q5 = "(?:" + tw + "(?:d|ll|m|re|s|t|ve))?", U5 = "(?:" + tw + "(?:D|LL|M|RE|S|T|VE))?", H5 = bj + "?", V5 = "[" + P5 + "]?", wj = "(?:" + z5 + "(?:" + [L5, nw, iw].join("|") + ")" + V5 + H5 + ")*", kj = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Cj = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", W5 = V5 + H5 + wj, _j = "(?:" + [yj, nw, iw].join("|") + ")" + W5, Sj = "(?:" + [L5 + P0 + "?", P0, nw, iw, vj].join("|") + ")", Aj = RegExp(tw, "g"), Ej = RegExp(P0, "g"), ow = RegExp(rw + "(?=" + rw + ")|" + Sj + W5, "g"), Dj = RegExp([
        ef + "?" + I5 + "+" + q5 + "(?=" + [N5, ef, "$"].join("|") + ")",
        xj + "+" + U5 + "(?=" + [N5, ef + j5, "$"].join("|") + ")",
        ef + "?" + j5 + "+" + q5,
        ef + "+" + U5,
        Cj,
        kj,
        $5,
        _j
      ].join("|"), "g"), Oj = RegExp("[" + z5 + Es + gl + P5 + "]"), Fj = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Tj = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], Mj = -1, Rr = {};
      Rr[Zr] = Rr[Kt] = Rr[Je] = Rr[mr] = Rr[en] = Rr[xi] = Rr[pl] = Rr[Br] = Rr[qn] = !0, Rr[Ce] = Rr[Pe] = Rr[kt] = Rr[_e] = Rr[pr] = Rr[he] = Rr[ve] = Rr[We] = Rr[ot] = Rr[Ye] = Rr[St] = Rr[Ge] = Rr[Ze] = Rr[It] = Rr[$e] = !1;
      var Fr = {};
      Fr[Ce] = Fr[Pe] = Fr[kt] = Fr[pr] = Fr[_e] = Fr[he] = Fr[Zr] = Fr[Kt] = Fr[Je] = Fr[mr] = Fr[en] = Fr[ot] = Fr[Ye] = Fr[St] = Fr[Ge] = Fr[Ze] = Fr[It] = Fr[rr] = Fr[xi] = Fr[pl] = Fr[Br] = Fr[qn] = !0, Fr[ve] = Fr[We] = Fr[$e] = !1;
      var Pj = {
        // Latin-1 Supplement block.
        Ã€: "A",
        Ã: "A",
        Ã‚: "A",
        Ãƒ: "A",
        Ã„: "A",
        Ã…: "A",
        Ã : "a",
        Ã¡: "a",
        Ã¢: "a",
        Ã£: "a",
        Ã¤: "a",
        Ã¥: "a",
        Ã‡: "C",
        Ã§: "c",
        Ã: "D",
        Ã°: "d",
        Ãˆ: "E",
        Ã‰: "E",
        ÃŠ: "E",
        Ã‹: "E",
        Ã¨: "e",
        Ã©: "e",
        Ãª: "e",
        Ã«: "e",
        ÃŒ: "I",
        Ã: "I",
        ÃŽ: "I",
        Ã: "I",
        Ã¬: "i",
        Ã­: "i",
        Ã®: "i",
        Ã¯: "i",
        Ã‘: "N",
        Ã±: "n",
        Ã’: "O",
        Ã“: "O",
        Ã”: "O",
        Ã•: "O",
        Ã–: "O",
        Ã˜: "O",
        Ã²: "o",
        Ã³: "o",
        Ã´: "o",
        Ãµ: "o",
        Ã¶: "o",
        Ã¸: "o",
        Ã™: "U",
        Ãš: "U",
        Ã›: "U",
        Ãœ: "U",
        Ã¹: "u",
        Ãº: "u",
        Ã»: "u",
        Ã¼: "u",
        Ã: "Y",
        Ã½: "y",
        Ã¿: "y",
        Ã†: "Ae",
        Ã¦: "ae",
        Ãž: "Th",
        Ã¾: "th",
        ÃŸ: "ss",
        // Latin Extended-A block.
        Ä€: "A",
        Ä‚: "A",
        Ä„: "A",
        Ä: "a",
        Äƒ: "a",
        Ä…: "a",
        Ä†: "C",
        Äˆ: "C",
        ÄŠ: "C",
        ÄŒ: "C",
        Ä‡: "c",
        Ä‰: "c",
        Ä‹: "c",
        Ä: "c",
        ÄŽ: "D",
        Ä: "D",
        Ä: "d",
        Ä‘: "d",
        Ä’: "E",
        Ä”: "E",
        Ä–: "E",
        Ä˜: "E",
        Äš: "E",
        Ä“: "e",
        Ä•: "e",
        Ä—: "e",
        Ä™: "e",
        Ä›: "e",
        Äœ: "G",
        Äž: "G",
        Ä : "G",
        Ä¢: "G",
        Ä: "g",
        ÄŸ: "g",
        Ä¡: "g",
        Ä£: "g",
        Ä¤: "H",
        Ä¦: "H",
        Ä¥: "h",
        Ä§: "h",
        Ä¨: "I",
        Äª: "I",
        Ä¬: "I",
        Ä®: "I",
        Ä°: "I",
        Ä©: "i",
        Ä«: "i",
        Ä­: "i",
        Ä¯: "i",
        Ä±: "i",
        Ä´: "J",
        Äµ: "j",
        Ä¶: "K",
        Ä·: "k",
        Ä¸: "k",
        Ä¹: "L",
        Ä»: "L",
        Ä½: "L",
        Ä¿: "L",
        Å: "L",
        Äº: "l",
        Ä¼: "l",
        Ä¾: "l",
        Å€: "l",
        Å‚: "l",
        Åƒ: "N",
        Å…: "N",
        Å‡: "N",
        ÅŠ: "N",
        Å„: "n",
        Å†: "n",
        Åˆ: "n",
        Å‹: "n",
        ÅŒ: "O",
        ÅŽ: "O",
        Å: "O",
        Å: "o",
        Å: "o",
        Å‘: "o",
        Å”: "R",
        Å–: "R",
        Å˜: "R",
        Å•: "r",
        Å—: "r",
        Å™: "r",
        Åš: "S",
        Åœ: "S",
        Åž: "S",
        Å : "S",
        Å›: "s",
        Å: "s",
        ÅŸ: "s",
        Å¡: "s",
        Å¢: "T",
        Å¤: "T",
        Å¦: "T",
        Å£: "t",
        Å¥: "t",
        Å§: "t",
        Å¨: "U",
        Åª: "U",
        Å¬: "U",
        Å®: "U",
        Å°: "U",
        Å²: "U",
        Å©: "u",
        Å«: "u",
        Å­: "u",
        Å¯: "u",
        Å±: "u",
        Å³: "u",
        Å´: "W",
        Åµ: "w",
        Å¶: "Y",
        Å·: "y",
        Å¸: "Y",
        Å¹: "Z",
        Å»: "Z",
        Å½: "Z",
        Åº: "z",
        Å¼: "z",
        Å¾: "z",
        Ä²: "IJ",
        Ä³: "ij",
        Å’: "Oe",
        Å“: "oe",
        Å‰: "'n",
        Å¿: "s"
      }, Rj = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, Nj = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, $j = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, Ij = parseFloat, Bj = parseInt, G5 = typeof Lu == "object" && Lu && Lu.Object === Object && Lu, Lj = typeof self == "object" && self && self.Object === Object && self, Un = G5 || Lj || Function("return this")(), sw = e && !e.nodeType && e, wc = sw && !0 && t && !t.nodeType && t, K5 = wc && wc.exports === sw, aw = K5 && G5.process, Yo = (function() {
        try {
          var Z = wc && wc.require && wc.require("util").types;
          return Z || aw && aw.binding && aw.binding("util");
        } catch {
        }
      })(), Q5 = Yo && Yo.isArrayBuffer, X5 = Yo && Yo.isDate, J5 = Yo && Yo.isMap, Y5 = Yo && Yo.isRegExp, Z5 = Yo && Yo.isSet, eA = Yo && Yo.isTypedArray;
      function bo(Z, fe, le) {
        switch (le.length) {
          case 0:
            return Z.call(fe);
          case 1:
            return Z.call(fe, le[0]);
          case 2:
            return Z.call(fe, le[0], le[1]);
          case 3:
            return Z.call(fe, le[0], le[1], le[2]);
        }
        return Z.apply(fe, le);
      }
      function zj(Z, fe, le, ze) {
        for (var vt = -1, ur = Z == null ? 0 : Z.length; ++vt < ur; ) {
          var kn = Z[vt];
          fe(ze, kn, le(kn), Z);
        }
        return ze;
      }
      function Zo(Z, fe) {
        for (var le = -1, ze = Z == null ? 0 : Z.length; ++le < ze && fe(Z[le], le, Z) !== !1; )
          ;
        return Z;
      }
      function jj(Z, fe) {
        for (var le = Z == null ? 0 : Z.length; le-- && fe(Z[le], le, Z) !== !1; )
          ;
        return Z;
      }
      function tA(Z, fe) {
        for (var le = -1, ze = Z == null ? 0 : Z.length; ++le < ze; )
          if (!fe(Z[le], le, Z))
            return !1;
        return !0;
      }
      function gu(Z, fe) {
        for (var le = -1, ze = Z == null ? 0 : Z.length, vt = 0, ur = []; ++le < ze; ) {
          var kn = Z[le];
          fe(kn, le, Z) && (ur[vt++] = kn);
        }
        return ur;
      }
      function R0(Z, fe) {
        var le = Z == null ? 0 : Z.length;
        return !!le && tf(Z, fe, 0) > -1;
      }
      function lw(Z, fe, le) {
        for (var ze = -1, vt = Z == null ? 0 : Z.length; ++ze < vt; )
          if (le(fe, Z[ze]))
            return !0;
        return !1;
      }
      function Lr(Z, fe) {
        for (var le = -1, ze = Z == null ? 0 : Z.length, vt = Array(ze); ++le < ze; )
          vt[le] = fe(Z[le], le, Z);
        return vt;
      }
      function vu(Z, fe) {
        for (var le = -1, ze = fe.length, vt = Z.length; ++le < ze; )
          Z[vt + le] = fe[le];
        return Z;
      }
      function uw(Z, fe, le, ze) {
        var vt = -1, ur = Z == null ? 0 : Z.length;
        for (ze && ur && (le = Z[++vt]); ++vt < ur; )
          le = fe(le, Z[vt], vt, Z);
        return le;
      }
      function qj(Z, fe, le, ze) {
        var vt = Z == null ? 0 : Z.length;
        for (ze && vt && (le = Z[--vt]); vt--; )
          le = fe(le, Z[vt], vt, Z);
        return le;
      }
      function cw(Z, fe) {
        for (var le = -1, ze = Z == null ? 0 : Z.length; ++le < ze; )
          if (fe(Z[le], le, Z))
            return !0;
        return !1;
      }
      var Uj = hw("length");
      function Hj(Z) {
        return Z.split("");
      }
      function Vj(Z) {
        return Z.match(xe) || [];
      }
      function rA(Z, fe, le) {
        var ze;
        return le(Z, function(vt, ur, kn) {
          if (fe(vt, ur, kn))
            return ze = ur, !1;
        }), ze;
      }
      function N0(Z, fe, le, ze) {
        for (var vt = Z.length, ur = le + (ze ? 1 : -1); ze ? ur-- : ++ur < vt; )
          if (fe(Z[ur], ur, Z))
            return ur;
        return -1;
      }
      function tf(Z, fe, le) {
        return fe === fe ? nq(Z, fe, le) : N0(Z, nA, le);
      }
      function Wj(Z, fe, le, ze) {
        for (var vt = le - 1, ur = Z.length; ++vt < ur; )
          if (ze(Z[vt], fe))
            return vt;
        return -1;
      }
      function nA(Z) {
        return Z !== Z;
      }
      function iA(Z, fe) {
        var le = Z == null ? 0 : Z.length;
        return le ? dw(Z, fe) / le : re;
      }
      function hw(Z) {
        return function(fe) {
          return fe == null ? r : fe[Z];
        };
      }
      function fw(Z) {
        return function(fe) {
          return Z == null ? r : Z[fe];
        };
      }
      function oA(Z, fe, le, ze, vt) {
        return vt(Z, function(ur, kn, Ar) {
          le = ze ? (ze = !1, ur) : fe(le, ur, kn, Ar);
        }), le;
      }
      function Gj(Z, fe) {
        var le = Z.length;
        for (Z.sort(fe); le--; )
          Z[le] = Z[le].value;
        return Z;
      }
      function dw(Z, fe) {
        for (var le, ze = -1, vt = Z.length; ++ze < vt; ) {
          var ur = fe(Z[ze]);
          ur !== r && (le = le === r ? ur : le + ur);
        }
        return le;
      }
      function pw(Z, fe) {
        for (var le = -1, ze = Array(Z); ++le < Z; )
          ze[le] = fe(le);
        return ze;
      }
      function Kj(Z, fe) {
        return Lr(fe, function(le) {
          return [le, Z[le]];
        });
      }
      function sA(Z) {
        return Z && Z.slice(0, cA(Z) + 1).replace(Ap, "");
      }
      function xo(Z) {
        return function(fe) {
          return Z(fe);
        };
      }
      function mw(Z, fe) {
        return Lr(fe, function(le) {
          return Z[le];
        });
      }
      function Dp(Z, fe) {
        return Z.has(fe);
      }
      function aA(Z, fe) {
        for (var le = -1, ze = Z.length; ++le < ze && tf(fe, Z[le], 0) > -1; )
          ;
        return le;
      }
      function lA(Z, fe) {
        for (var le = Z.length; le-- && tf(fe, Z[le], 0) > -1; )
          ;
        return le;
      }
      function Qj(Z, fe) {
        for (var le = Z.length, ze = 0; le--; )
          Z[le] === fe && ++ze;
        return ze;
      }
      var Xj = fw(Pj), Jj = fw(Rj);
      function Yj(Z) {
        return "\\" + $j[Z];
      }
      function Zj(Z, fe) {
        return Z == null ? r : Z[fe];
      }
      function rf(Z) {
        return Oj.test(Z);
      }
      function eq(Z) {
        return Fj.test(Z);
      }
      function tq(Z) {
        for (var fe, le = []; !(fe = Z.next()).done; )
          le.push(fe.value);
        return le;
      }
      function gw(Z) {
        var fe = -1, le = Array(Z.size);
        return Z.forEach(function(ze, vt) {
          le[++fe] = [vt, ze];
        }), le;
      }
      function uA(Z, fe) {
        return function(le) {
          return Z(fe(le));
        };
      }
      function yu(Z, fe) {
        for (var le = -1, ze = Z.length, vt = 0, ur = []; ++le < ze; ) {
          var kn = Z[le];
          (kn === fe || kn === c) && (Z[le] = c, ur[vt++] = le);
        }
        return ur;
      }
      function $0(Z) {
        var fe = -1, le = Array(Z.size);
        return Z.forEach(function(ze) {
          le[++fe] = ze;
        }), le;
      }
      function rq(Z) {
        var fe = -1, le = Array(Z.size);
        return Z.forEach(function(ze) {
          le[++fe] = [ze, ze];
        }), le;
      }
      function nq(Z, fe, le) {
        for (var ze = le - 1, vt = Z.length; ++ze < vt; )
          if (Z[ze] === fe)
            return ze;
        return -1;
      }
      function iq(Z, fe, le) {
        for (var ze = le + 1; ze--; )
          if (Z[ze] === fe)
            return ze;
        return ze;
      }
      function nf(Z) {
        return rf(Z) ? sq(Z) : Uj(Z);
      }
      function Os(Z) {
        return rf(Z) ? aq(Z) : Hj(Z);
      }
      function cA(Z) {
        for (var fe = Z.length; fe-- && M0.test(Z.charAt(fe)); )
          ;
        return fe;
      }
      var oq = fw(Nj);
      function sq(Z) {
        for (var fe = ow.lastIndex = 0; ow.test(Z); )
          ++fe;
        return fe;
      }
      function aq(Z) {
        return Z.match(ow) || [];
      }
      function lq(Z) {
        return Z.match(Dj) || [];
      }
      var uq = (function Z(fe) {
        fe = fe == null ? Un : of.defaults(Un.Object(), fe, of.pick(Un, Tj));
        var le = fe.Array, ze = fe.Date, vt = fe.Error, ur = fe.Function, kn = fe.Math, Ar = fe.Object, vw = fe.RegExp, cq = fe.String, es = fe.TypeError, I0 = le.prototype, hq = ur.prototype, sf = Ar.prototype, B0 = fe["__core-js_shared__"], L0 = hq.toString, br = sf.hasOwnProperty, fq = 0, hA = (function() {
          var f = /[^.]+$/.exec(B0 && B0.keys && B0.keys.IE_PROTO || "");
          return f ? "Symbol(src)_1." + f : "";
        })(), z0 = sf.toString, dq = L0.call(Ar), pq = Un._, mq = vw(
          "^" + L0.call(br).replace(Sp, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), j0 = K5 ? fe.Buffer : r, bu = fe.Symbol, q0 = fe.Uint8Array, fA = j0 ? j0.allocUnsafe : r, U0 = uA(Ar.getPrototypeOf, Ar), dA = Ar.create, pA = sf.propertyIsEnumerable, H0 = I0.splice, mA = bu ? bu.isConcatSpreadable : r, Op = bu ? bu.iterator : r, kc = bu ? bu.toStringTag : r, V0 = (function() {
          try {
            var f = Ec(Ar, "defineProperty");
            return f({}, "", {}), f;
          } catch {
          }
        })(), gq = fe.clearTimeout !== Un.clearTimeout && fe.clearTimeout, vq = ze && ze.now !== Un.Date.now && ze.now, yq = fe.setTimeout !== Un.setTimeout && fe.setTimeout, W0 = kn.ceil, G0 = kn.floor, yw = Ar.getOwnPropertySymbols, bq = j0 ? j0.isBuffer : r, gA = fe.isFinite, xq = I0.join, wq = uA(Ar.keys, Ar), Cn = kn.max, Xn = kn.min, kq = ze.now, Cq = fe.parseInt, vA = kn.random, _q = I0.reverse, bw = Ec(fe, "DataView"), Fp = Ec(fe, "Map"), xw = Ec(fe, "Promise"), af = Ec(fe, "Set"), Tp = Ec(fe, "WeakMap"), Mp = Ec(Ar, "create"), K0 = Tp && new Tp(), lf = {}, Sq = Dc(bw), Aq = Dc(Fp), Eq = Dc(xw), Dq = Dc(af), Oq = Dc(Tp), Q0 = bu ? bu.prototype : r, Pp = Q0 ? Q0.valueOf : r, yA = Q0 ? Q0.toString : r;
        function P(f) {
          if (tn(f) && !bt(f) && !(f instanceof Bt)) {
            if (f instanceof ts)
              return f;
            if (br.call(f, "__wrapped__"))
              return bE(f);
          }
          return new ts(f);
        }
        var uf = /* @__PURE__ */ (function() {
          function f() {
          }
          return function(m) {
            if (!Wr(m))
              return {};
            if (dA)
              return dA(m);
            f.prototype = m;
            var w = new f();
            return f.prototype = r, w;
          };
        })();
        function X0() {
        }
        function ts(f, m) {
          this.__wrapped__ = f, this.__actions__ = [], this.__chain__ = !!m, this.__index__ = 0, this.__values__ = r;
        }
        P.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: ua,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: D0,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: O0,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: P
          }
        }, P.prototype = X0.prototype, P.prototype.constructor = P, ts.prototype = uf(X0.prototype), ts.prototype.constructor = ts;
        function Bt(f) {
          this.__wrapped__ = f, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = ie, this.__views__ = [];
        }
        function Fq() {
          var f = new Bt(this.__wrapped__);
          return f.__actions__ = zi(this.__actions__), f.__dir__ = this.__dir__, f.__filtered__ = this.__filtered__, f.__iteratees__ = zi(this.__iteratees__), f.__takeCount__ = this.__takeCount__, f.__views__ = zi(this.__views__), f;
        }
        function Tq() {
          if (this.__filtered__) {
            var f = new Bt(this);
            f.__dir__ = -1, f.__filtered__ = !0;
          } else
            f = this.clone(), f.__dir__ *= -1;
          return f;
        }
        function Mq() {
          var f = this.__wrapped__.value(), m = this.__dir__, w = bt(f), E = m < 0, F = w ? f.length : 0, L = HU(0, F, this.__views__), V = L.start, Q = L.end, ee = Q - V, pe = E ? Q : V - 1, ge = this.__iteratees__, we = ge.length, Ne = 0, He = Xn(ee, this.__takeCount__);
          if (!w || !E && F == ee && He == ee)
            return qA(f, this.__actions__);
          var st = [];
          e:
            for (; ee-- && Ne < He; ) {
              pe += m;
              for (var Ot = -1, at = f[pe]; ++Ot < we; ) {
                var Rt = ge[Ot], qt = Rt.iteratee, Co = Rt.type, Ci = qt(at);
                if (Co == $)
                  at = Ci;
                else if (!Ci) {
                  if (Co == B)
                    continue e;
                  break e;
                }
              }
              st[Ne++] = at;
            }
          return st;
        }
        Bt.prototype = uf(X0.prototype), Bt.prototype.constructor = Bt;
        function Cc(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.clear(); ++m < w; ) {
            var E = f[m];
            this.set(E[0], E[1]);
          }
        }
        function Pq() {
          this.__data__ = Mp ? Mp(null) : {}, this.size = 0;
        }
        function Rq(f) {
          var m = this.has(f) && delete this.__data__[f];
          return this.size -= m ? 1 : 0, m;
        }
        function Nq(f) {
          var m = this.__data__;
          if (Mp) {
            var w = m[f];
            return w === l ? r : w;
          }
          return br.call(m, f) ? m[f] : r;
        }
        function $q(f) {
          var m = this.__data__;
          return Mp ? m[f] !== r : br.call(m, f);
        }
        function Iq(f, m) {
          var w = this.__data__;
          return this.size += this.has(f) ? 0 : 1, w[f] = Mp && m === r ? l : m, this;
        }
        Cc.prototype.clear = Pq, Cc.prototype.delete = Rq, Cc.prototype.get = Nq, Cc.prototype.has = $q, Cc.prototype.set = Iq;
        function vl(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.clear(); ++m < w; ) {
            var E = f[m];
            this.set(E[0], E[1]);
          }
        }
        function Bq() {
          this.__data__ = [], this.size = 0;
        }
        function Lq(f) {
          var m = this.__data__, w = J0(m, f);
          if (w < 0)
            return !1;
          var E = m.length - 1;
          return w == E ? m.pop() : H0.call(m, w, 1), --this.size, !0;
        }
        function zq(f) {
          var m = this.__data__, w = J0(m, f);
          return w < 0 ? r : m[w][1];
        }
        function jq(f) {
          return J0(this.__data__, f) > -1;
        }
        function qq(f, m) {
          var w = this.__data__, E = J0(w, f);
          return E < 0 ? (++this.size, w.push([f, m])) : w[E][1] = m, this;
        }
        vl.prototype.clear = Bq, vl.prototype.delete = Lq, vl.prototype.get = zq, vl.prototype.has = jq, vl.prototype.set = qq;
        function yl(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.clear(); ++m < w; ) {
            var E = f[m];
            this.set(E[0], E[1]);
          }
        }
        function Uq() {
          this.size = 0, this.__data__ = {
            hash: new Cc(),
            map: new (Fp || vl)(),
            string: new Cc()
          };
        }
        function Hq(f) {
          var m = uv(this, f).delete(f);
          return this.size -= m ? 1 : 0, m;
        }
        function Vq(f) {
          return uv(this, f).get(f);
        }
        function Wq(f) {
          return uv(this, f).has(f);
        }
        function Gq(f, m) {
          var w = uv(this, f), E = w.size;
          return w.set(f, m), this.size += w.size == E ? 0 : 1, this;
        }
        yl.prototype.clear = Uq, yl.prototype.delete = Hq, yl.prototype.get = Vq, yl.prototype.has = Wq, yl.prototype.set = Gq;
        function _c(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.__data__ = new yl(); ++m < w; )
            this.add(f[m]);
        }
        function Kq(f) {
          return this.__data__.set(f, l), this;
        }
        function Qq(f) {
          return this.__data__.has(f);
        }
        _c.prototype.add = _c.prototype.push = Kq, _c.prototype.has = Qq;
        function Fs(f) {
          var m = this.__data__ = new vl(f);
          this.size = m.size;
        }
        function Xq() {
          this.__data__ = new vl(), this.size = 0;
        }
        function Jq(f) {
          var m = this.__data__, w = m.delete(f);
          return this.size = m.size, w;
        }
        function Yq(f) {
          return this.__data__.get(f);
        }
        function Zq(f) {
          return this.__data__.has(f);
        }
        function eU(f, m) {
          var w = this.__data__;
          if (w instanceof vl) {
            var E = w.__data__;
            if (!Fp || E.length < i - 1)
              return E.push([f, m]), this.size = ++w.size, this;
            w = this.__data__ = new yl(E);
          }
          return w.set(f, m), this.size = w.size, this;
        }
        Fs.prototype.clear = Xq, Fs.prototype.delete = Jq, Fs.prototype.get = Yq, Fs.prototype.has = Zq, Fs.prototype.set = eU;
        function bA(f, m) {
          var w = bt(f), E = !w && Oc(f), F = !w && !E && _u(f), L = !w && !E && !F && df(f), V = w || E || F || L, Q = V ? pw(f.length, cq) : [], ee = Q.length;
          for (var pe in f)
            (m || br.call(f, pe)) && !(V && // Safari 9 has enumerable `arguments.length` in strict mode.
            (pe == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            F && (pe == "offset" || pe == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            L && (pe == "buffer" || pe == "byteLength" || pe == "byteOffset") || // Skip index properties.
            kl(pe, ee))) && Q.push(pe);
          return Q;
        }
        function xA(f) {
          var m = f.length;
          return m ? f[Tw(0, m - 1)] : r;
        }
        function tU(f, m) {
          return cv(zi(f), Sc(m, 0, f.length));
        }
        function rU(f) {
          return cv(zi(f));
        }
        function ww(f, m, w) {
          (w !== r && !Ts(f[m], w) || w === r && !(m in f)) && bl(f, m, w);
        }
        function Rp(f, m, w) {
          var E = f[m];
          (!(br.call(f, m) && Ts(E, w)) || w === r && !(m in f)) && bl(f, m, w);
        }
        function J0(f, m) {
          for (var w = f.length; w--; )
            if (Ts(f[w][0], m))
              return w;
          return -1;
        }
        function nU(f, m, w, E) {
          return xu(f, function(F, L, V) {
            m(E, F, w(F), V);
          }), E;
        }
        function wA(f, m) {
          return f && ha(m, Tn(m), f);
        }
        function iU(f, m) {
          return f && ha(m, qi(m), f);
        }
        function bl(f, m, w) {
          m == "__proto__" && V0 ? V0(f, m, {
            configurable: !0,
            enumerable: !0,
            value: w,
            writable: !0
          }) : f[m] = w;
        }
        function kw(f, m) {
          for (var w = -1, E = m.length, F = le(E), L = f == null; ++w < E; )
            F[w] = L ? r : r2(f, m[w]);
          return F;
        }
        function Sc(f, m, w) {
          return f === f && (w !== r && (f = f <= w ? f : w), m !== r && (f = f >= m ? f : m)), f;
        }
        function rs(f, m, w, E, F, L) {
          var V, Q = m & h, ee = m & d, pe = m & p;
          if (w && (V = F ? w(f, E, F, L) : w(f)), V !== r)
            return V;
          if (!Wr(f))
            return f;
          var ge = bt(f);
          if (ge) {
            if (V = WU(f), !Q)
              return zi(f, V);
          } else {
            var we = Jn(f), Ne = we == We || we == Qe;
            if (_u(f))
              return VA(f, Q);
            if (we == St || we == Ce || Ne && !F) {
              if (V = ee || Ne ? {} : cE(f), !Q)
                return ee ? NU(f, iU(V, f)) : RU(f, wA(V, f));
            } else {
              if (!Fr[we])
                return F ? f : {};
              V = GU(f, we, Q);
            }
          }
          L || (L = new Fs());
          var He = L.get(f);
          if (He)
            return He;
          L.set(f, V), LE(f) ? f.forEach(function(at) {
            V.add(rs(at, m, w, at, f, L));
          }) : IE(f) && f.forEach(function(at, Rt) {
            V.set(Rt, rs(at, m, w, Rt, f, L));
          });
          var st = pe ? ee ? qw : jw : ee ? qi : Tn, Ot = ge ? r : st(f);
          return Zo(Ot || f, function(at, Rt) {
            Ot && (Rt = at, at = f[Rt]), Rp(V, Rt, rs(at, m, w, Rt, f, L));
          }), V;
        }
        function oU(f) {
          var m = Tn(f);
          return function(w) {
            return kA(w, f, m);
          };
        }
        function kA(f, m, w) {
          var E = w.length;
          if (f == null)
            return !E;
          for (f = Ar(f); E--; ) {
            var F = w[E], L = m[F], V = f[F];
            if (V === r && !(F in f) || !L(V))
              return !1;
          }
          return !0;
        }
        function CA(f, m, w) {
          if (typeof f != "function")
            throw new es(s);
          return jp(function() {
            f.apply(r, w);
          }, m);
        }
        function Np(f, m, w, E) {
          var F = -1, L = R0, V = !0, Q = f.length, ee = [], pe = m.length;
          if (!Q)
            return ee;
          w && (m = Lr(m, xo(w))), E ? (L = lw, V = !1) : m.length >= i && (L = Dp, V = !1, m = new _c(m));
          e:
            for (; ++F < Q; ) {
              var ge = f[F], we = w == null ? ge : w(ge);
              if (ge = E || ge !== 0 ? ge : 0, V && we === we) {
                for (var Ne = pe; Ne--; )
                  if (m[Ne] === we)
                    continue e;
                ee.push(ge);
              } else L(m, we, E) || ee.push(ge);
            }
          return ee;
        }
        var xu = XA(ca), _A = XA(_w, !0);
        function sU(f, m) {
          var w = !0;
          return xu(f, function(E, F, L) {
            return w = !!m(E, F, L), w;
          }), w;
        }
        function Y0(f, m, w) {
          for (var E = -1, F = f.length; ++E < F; ) {
            var L = f[E], V = m(L);
            if (V != null && (Q === r ? V === V && !ko(V) : w(V, Q)))
              var Q = V, ee = L;
          }
          return ee;
        }
        function aU(f, m, w, E) {
          var F = f.length;
          for (w = At(w), w < 0 && (w = -w > F ? 0 : F + w), E = E === r || E > F ? F : At(E), E < 0 && (E += F), E = w > E ? 0 : jE(E); w < E; )
            f[w++] = m;
          return f;
        }
        function SA(f, m) {
          var w = [];
          return xu(f, function(E, F, L) {
            m(E, F, L) && w.push(E);
          }), w;
        }
        function Hn(f, m, w, E, F) {
          var L = -1, V = f.length;
          for (w || (w = QU), F || (F = []); ++L < V; ) {
            var Q = f[L];
            m > 0 && w(Q) ? m > 1 ? Hn(Q, m - 1, w, E, F) : vu(F, Q) : E || (F[F.length] = Q);
          }
          return F;
        }
        var Cw = JA(), AA = JA(!0);
        function ca(f, m) {
          return f && Cw(f, m, Tn);
        }
        function _w(f, m) {
          return f && AA(f, m, Tn);
        }
        function Z0(f, m) {
          return gu(m, function(w) {
            return Cl(f[w]);
          });
        }
        function Ac(f, m) {
          m = ku(m, f);
          for (var w = 0, E = m.length; f != null && w < E; )
            f = f[fa(m[w++])];
          return w && w == E ? f : r;
        }
        function EA(f, m, w) {
          var E = m(f);
          return bt(f) ? E : vu(E, w(f));
        }
        function wi(f) {
          return f == null ? f === r ? Fe : Ht : kc && kc in Ar(f) ? UU(f) : rH(f);
        }
        function Sw(f, m) {
          return f > m;
        }
        function lU(f, m) {
          return f != null && br.call(f, m);
        }
        function uU(f, m) {
          return f != null && m in Ar(f);
        }
        function cU(f, m, w) {
          return f >= Xn(m, w) && f < Cn(m, w);
        }
        function Aw(f, m, w) {
          for (var E = w ? lw : R0, F = f[0].length, L = f.length, V = L, Q = le(L), ee = 1 / 0, pe = []; V--; ) {
            var ge = f[V];
            V && m && (ge = Lr(ge, xo(m))), ee = Xn(ge.length, ee), Q[V] = !w && (m || F >= 120 && ge.length >= 120) ? new _c(V && ge) : r;
          }
          ge = f[0];
          var we = -1, Ne = Q[0];
          e:
            for (; ++we < F && pe.length < ee; ) {
              var He = ge[we], st = m ? m(He) : He;
              if (He = w || He !== 0 ? He : 0, !(Ne ? Dp(Ne, st) : E(pe, st, w))) {
                for (V = L; --V; ) {
                  var Ot = Q[V];
                  if (!(Ot ? Dp(Ot, st) : E(f[V], st, w)))
                    continue e;
                }
                Ne && Ne.push(st), pe.push(He);
              }
            }
          return pe;
        }
        function hU(f, m, w, E) {
          return ca(f, function(F, L, V) {
            m(E, w(F), L, V);
          }), E;
        }
        function $p(f, m, w) {
          m = ku(m, f), f = pE(f, m);
          var E = f == null ? f : f[fa(is(m))];
          return E == null ? r : bo(E, f, w);
        }
        function DA(f) {
          return tn(f) && wi(f) == Ce;
        }
        function fU(f) {
          return tn(f) && wi(f) == kt;
        }
        function dU(f) {
          return tn(f) && wi(f) == he;
        }
        function Ip(f, m, w, E, F) {
          return f === m ? !0 : f == null || m == null || !tn(f) && !tn(m) ? f !== f && m !== m : pU(f, m, w, E, Ip, F);
        }
        function pU(f, m, w, E, F, L) {
          var V = bt(f), Q = bt(m), ee = V ? Pe : Jn(f), pe = Q ? Pe : Jn(m);
          ee = ee == Ce ? St : ee, pe = pe == Ce ? St : pe;
          var ge = ee == St, we = pe == St, Ne = ee == pe;
          if (Ne && _u(f)) {
            if (!_u(m))
              return !1;
            V = !0, ge = !1;
          }
          if (Ne && !ge)
            return L || (L = new Fs()), V || df(f) ? aE(f, m, w, E, F, L) : jU(f, m, ee, w, E, F, L);
          if (!(w & g)) {
            var He = ge && br.call(f, "__wrapped__"), st = we && br.call(m, "__wrapped__");
            if (He || st) {
              var Ot = He ? f.value() : f, at = st ? m.value() : m;
              return L || (L = new Fs()), F(Ot, at, w, E, L);
            }
          }
          return Ne ? (L || (L = new Fs()), qU(f, m, w, E, F, L)) : !1;
        }
        function mU(f) {
          return tn(f) && Jn(f) == ot;
        }
        function Ew(f, m, w, E) {
          var F = w.length, L = F, V = !E;
          if (f == null)
            return !L;
          for (f = Ar(f); F--; ) {
            var Q = w[F];
            if (V && Q[2] ? Q[1] !== f[Q[0]] : !(Q[0] in f))
              return !1;
          }
          for (; ++F < L; ) {
            Q = w[F];
            var ee = Q[0], pe = f[ee], ge = Q[1];
            if (V && Q[2]) {
              if (pe === r && !(ee in f))
                return !1;
            } else {
              var we = new Fs();
              if (E)
                var Ne = E(pe, ge, ee, f, m, we);
              if (!(Ne === r ? Ip(ge, pe, g | v, E, we) : Ne))
                return !1;
            }
          }
          return !0;
        }
        function OA(f) {
          if (!Wr(f) || JU(f))
            return !1;
          var m = Cl(f) ? mq : gr;
          return m.test(Dc(f));
        }
        function gU(f) {
          return tn(f) && wi(f) == Ge;
        }
        function vU(f) {
          return tn(f) && Jn(f) == Ze;
        }
        function yU(f) {
          return tn(f) && gv(f.length) && !!Rr[wi(f)];
        }
        function FA(f) {
          return typeof f == "function" ? f : f == null ? Ui : typeof f == "object" ? bt(f) ? PA(f[0], f[1]) : MA(f) : YE(f);
        }
        function Dw(f) {
          if (!zp(f))
            return wq(f);
          var m = [];
          for (var w in Ar(f))
            br.call(f, w) && w != "constructor" && m.push(w);
          return m;
        }
        function bU(f) {
          if (!Wr(f))
            return tH(f);
          var m = zp(f), w = [];
          for (var E in f)
            E == "constructor" && (m || !br.call(f, E)) || w.push(E);
          return w;
        }
        function Ow(f, m) {
          return f < m;
        }
        function TA(f, m) {
          var w = -1, E = ji(f) ? le(f.length) : [];
          return xu(f, function(F, L, V) {
            E[++w] = m(F, L, V);
          }), E;
        }
        function MA(f) {
          var m = Hw(f);
          return m.length == 1 && m[0][2] ? fE(m[0][0], m[0][1]) : function(w) {
            return w === f || Ew(w, f, m);
          };
        }
        function PA(f, m) {
          return Ww(f) && hE(m) ? fE(fa(f), m) : function(w) {
            var E = r2(w, f);
            return E === r && E === m ? n2(w, f) : Ip(m, E, g | v);
          };
        }
        function ev(f, m, w, E, F) {
          f !== m && Cw(m, function(L, V) {
            if (F || (F = new Fs()), Wr(L))
              xU(f, m, V, w, ev, E, F);
            else {
              var Q = E ? E(Kw(f, V), L, V + "", f, m, F) : r;
              Q === r && (Q = L), ww(f, V, Q);
            }
          }, qi);
        }
        function xU(f, m, w, E, F, L, V) {
          var Q = Kw(f, w), ee = Kw(m, w), pe = V.get(ee);
          if (pe) {
            ww(f, w, pe);
            return;
          }
          var ge = L ? L(Q, ee, w + "", f, m, V) : r, we = ge === r;
          if (we) {
            var Ne = bt(ee), He = !Ne && _u(ee), st = !Ne && !He && df(ee);
            ge = ee, Ne || He || st ? bt(Q) ? ge = Q : un(Q) ? ge = zi(Q) : He ? (we = !1, ge = VA(ee, !0)) : st ? (we = !1, ge = WA(ee, !0)) : ge = [] : qp(ee) || Oc(ee) ? (ge = Q, Oc(Q) ? ge = qE(Q) : (!Wr(Q) || Cl(Q)) && (ge = cE(ee))) : we = !1;
          }
          we && (V.set(ee, ge), F(ge, ee, E, L, V), V.delete(ee)), ww(f, w, ge);
        }
        function RA(f, m) {
          var w = f.length;
          if (w)
            return m += m < 0 ? w : 0, kl(m, w) ? f[m] : r;
        }
        function NA(f, m, w) {
          m.length ? m = Lr(m, function(L) {
            return bt(L) ? function(V) {
              return Ac(V, L.length === 1 ? L[0] : L);
            } : L;
          }) : m = [Ui];
          var E = -1;
          m = Lr(m, xo(rt()));
          var F = TA(f, function(L, V, Q) {
            var ee = Lr(m, function(pe) {
              return pe(L);
            });
            return { criteria: ee, index: ++E, value: L };
          });
          return Gj(F, function(L, V) {
            return PU(L, V, w);
          });
        }
        function wU(f, m) {
          return $A(f, m, function(w, E) {
            return n2(f, E);
          });
        }
        function $A(f, m, w) {
          for (var E = -1, F = m.length, L = {}; ++E < F; ) {
            var V = m[E], Q = Ac(f, V);
            w(Q, V) && Bp(L, ku(V, f), Q);
          }
          return L;
        }
        function kU(f) {
          return function(m) {
            return Ac(m, f);
          };
        }
        function Fw(f, m, w, E) {
          var F = E ? Wj : tf, L = -1, V = m.length, Q = f;
          for (f === m && (m = zi(m)), w && (Q = Lr(f, xo(w))); ++L < V; )
            for (var ee = 0, pe = m[L], ge = w ? w(pe) : pe; (ee = F(Q, ge, ee, E)) > -1; )
              Q !== f && H0.call(Q, ee, 1), H0.call(f, ee, 1);
          return f;
        }
        function IA(f, m) {
          for (var w = f ? m.length : 0, E = w - 1; w--; ) {
            var F = m[w];
            if (w == E || F !== L) {
              var L = F;
              kl(F) ? H0.call(f, F, 1) : Rw(f, F);
            }
          }
          return f;
        }
        function Tw(f, m) {
          return f + G0(vA() * (m - f + 1));
        }
        function CU(f, m, w, E) {
          for (var F = -1, L = Cn(W0((m - f) / (w || 1)), 0), V = le(L); L--; )
            V[E ? L : ++F] = f, f += w;
          return V;
        }
        function Mw(f, m) {
          var w = "";
          if (!f || m < 1 || m > H)
            return w;
          do
            m % 2 && (w += f), m = G0(m / 2), m && (f += f);
          while (m);
          return w;
        }
        function Tt(f, m) {
          return Qw(dE(f, m, Ui), f + "");
        }
        function _U(f) {
          return xA(pf(f));
        }
        function SU(f, m) {
          var w = pf(f);
          return cv(w, Sc(m, 0, w.length));
        }
        function Bp(f, m, w, E) {
          if (!Wr(f))
            return f;
          m = ku(m, f);
          for (var F = -1, L = m.length, V = L - 1, Q = f; Q != null && ++F < L; ) {
            var ee = fa(m[F]), pe = w;
            if (ee === "__proto__" || ee === "constructor" || ee === "prototype")
              return f;
            if (F != V) {
              var ge = Q[ee];
              pe = E ? E(ge, ee, Q) : r, pe === r && (pe = Wr(ge) ? ge : kl(m[F + 1]) ? [] : {});
            }
            Rp(Q, ee, pe), Q = Q[ee];
          }
          return f;
        }
        var BA = K0 ? function(f, m) {
          return K0.set(f, m), f;
        } : Ui, AU = V0 ? function(f, m) {
          return V0(f, "toString", {
            configurable: !0,
            enumerable: !1,
            value: o2(m),
            writable: !0
          });
        } : Ui;
        function EU(f) {
          return cv(pf(f));
        }
        function ns(f, m, w) {
          var E = -1, F = f.length;
          m < 0 && (m = -m > F ? 0 : F + m), w = w > F ? F : w, w < 0 && (w += F), F = m > w ? 0 : w - m >>> 0, m >>>= 0;
          for (var L = le(F); ++E < F; )
            L[E] = f[E + m];
          return L;
        }
        function DU(f, m) {
          var w;
          return xu(f, function(E, F, L) {
            return w = m(E, F, L), !w;
          }), !!w;
        }
        function tv(f, m, w) {
          var E = 0, F = f == null ? E : f.length;
          if (typeof m == "number" && m === m && F <= ne) {
            for (; E < F; ) {
              var L = E + F >>> 1, V = f[L];
              V !== null && !ko(V) && (w ? V <= m : V < m) ? E = L + 1 : F = L;
            }
            return F;
          }
          return Pw(f, m, Ui, w);
        }
        function Pw(f, m, w, E) {
          var F = 0, L = f == null ? 0 : f.length;
          if (L === 0)
            return 0;
          m = w(m);
          for (var V = m !== m, Q = m === null, ee = ko(m), pe = m === r; F < L; ) {
            var ge = G0((F + L) / 2), we = w(f[ge]), Ne = we !== r, He = we === null, st = we === we, Ot = ko(we);
            if (V)
              var at = E || st;
            else pe ? at = st && (E || Ne) : Q ? at = st && Ne && (E || !He) : ee ? at = st && Ne && !He && (E || !Ot) : He || Ot ? at = !1 : at = E ? we <= m : we < m;
            at ? F = ge + 1 : L = ge;
          }
          return Xn(L, se);
        }
        function LA(f, m) {
          for (var w = -1, E = f.length, F = 0, L = []; ++w < E; ) {
            var V = f[w], Q = m ? m(V) : V;
            if (!w || !Ts(Q, ee)) {
              var ee = Q;
              L[F++] = V === 0 ? 0 : V;
            }
          }
          return L;
        }
        function zA(f) {
          return typeof f == "number" ? f : ko(f) ? re : +f;
        }
        function wo(f) {
          if (typeof f == "string")
            return f;
          if (bt(f))
            return Lr(f, wo) + "";
          if (ko(f))
            return yA ? yA.call(f) : "";
          var m = f + "";
          return m == "0" && 1 / f == -U ? "-0" : m;
        }
        function wu(f, m, w) {
          var E = -1, F = R0, L = f.length, V = !0, Q = [], ee = Q;
          if (w)
            V = !1, F = lw;
          else if (L >= i) {
            var pe = m ? null : LU(f);
            if (pe)
              return $0(pe);
            V = !1, F = Dp, ee = new _c();
          } else
            ee = m ? [] : Q;
          e:
            for (; ++E < L; ) {
              var ge = f[E], we = m ? m(ge) : ge;
              if (ge = w || ge !== 0 ? ge : 0, V && we === we) {
                for (var Ne = ee.length; Ne--; )
                  if (ee[Ne] === we)
                    continue e;
                m && ee.push(we), Q.push(ge);
              } else F(ee, we, w) || (ee !== Q && ee.push(we), Q.push(ge));
            }
          return Q;
        }
        function Rw(f, m) {
          return m = ku(m, f), f = pE(f, m), f == null || delete f[fa(is(m))];
        }
        function jA(f, m, w, E) {
          return Bp(f, m, w(Ac(f, m)), E);
        }
        function rv(f, m, w, E) {
          for (var F = f.length, L = E ? F : -1; (E ? L-- : ++L < F) && m(f[L], L, f); )
            ;
          return w ? ns(f, E ? 0 : L, E ? L + 1 : F) : ns(f, E ? L + 1 : 0, E ? F : L);
        }
        function qA(f, m) {
          var w = f;
          return w instanceof Bt && (w = w.value()), uw(m, function(E, F) {
            return F.func.apply(F.thisArg, vu([E], F.args));
          }, w);
        }
        function Nw(f, m, w) {
          var E = f.length;
          if (E < 2)
            return E ? wu(f[0]) : [];
          for (var F = -1, L = le(E); ++F < E; )
            for (var V = f[F], Q = -1; ++Q < E; )
              Q != F && (L[F] = Np(L[F] || V, f[Q], m, w));
          return wu(Hn(L, 1), m, w);
        }
        function UA(f, m, w) {
          for (var E = -1, F = f.length, L = m.length, V = {}; ++E < F; ) {
            var Q = E < L ? m[E] : r;
            w(V, f[E], Q);
          }
          return V;
        }
        function $w(f) {
          return un(f) ? f : [];
        }
        function Iw(f) {
          return typeof f == "function" ? f : Ui;
        }
        function ku(f, m) {
          return bt(f) ? f : Ww(f, m) ? [f] : yE(vr(f));
        }
        var OU = Tt;
        function Cu(f, m, w) {
          var E = f.length;
          return w = w === r ? E : w, !m && w >= E ? f : ns(f, m, w);
        }
        var HA = gq || function(f) {
          return Un.clearTimeout(f);
        };
        function VA(f, m) {
          if (m)
            return f.slice();
          var w = f.length, E = fA ? fA(w) : new f.constructor(w);
          return f.copy(E), E;
        }
        function Bw(f) {
          var m = new f.constructor(f.byteLength);
          return new q0(m).set(new q0(f)), m;
        }
        function FU(f, m) {
          var w = m ? Bw(f.buffer) : f.buffer;
          return new f.constructor(w, f.byteOffset, f.byteLength);
        }
        function TU(f) {
          var m = new f.constructor(f.source, et.exec(f));
          return m.lastIndex = f.lastIndex, m;
        }
        function MU(f) {
          return Pp ? Ar(Pp.call(f)) : {};
        }
        function WA(f, m) {
          var w = m ? Bw(f.buffer) : f.buffer;
          return new f.constructor(w, f.byteOffset, f.length);
        }
        function GA(f, m) {
          if (f !== m) {
            var w = f !== r, E = f === null, F = f === f, L = ko(f), V = m !== r, Q = m === null, ee = m === m, pe = ko(m);
            if (!Q && !pe && !L && f > m || L && V && ee && !Q && !pe || E && V && ee || !w && ee || !F)
              return 1;
            if (!E && !L && !pe && f < m || pe && w && F && !E && !L || Q && w && F || !V && F || !ee)
              return -1;
          }
          return 0;
        }
        function PU(f, m, w) {
          for (var E = -1, F = f.criteria, L = m.criteria, V = F.length, Q = w.length; ++E < V; ) {
            var ee = GA(F[E], L[E]);
            if (ee) {
              if (E >= Q)
                return ee;
              var pe = w[E];
              return ee * (pe == "desc" ? -1 : 1);
            }
          }
          return f.index - m.index;
        }
        function KA(f, m, w, E) {
          for (var F = -1, L = f.length, V = w.length, Q = -1, ee = m.length, pe = Cn(L - V, 0), ge = le(ee + pe), we = !E; ++Q < ee; )
            ge[Q] = m[Q];
          for (; ++F < V; )
            (we || F < L) && (ge[w[F]] = f[F]);
          for (; pe--; )
            ge[Q++] = f[F++];
          return ge;
        }
        function QA(f, m, w, E) {
          for (var F = -1, L = f.length, V = -1, Q = w.length, ee = -1, pe = m.length, ge = Cn(L - Q, 0), we = le(ge + pe), Ne = !E; ++F < ge; )
            we[F] = f[F];
          for (var He = F; ++ee < pe; )
            we[He + ee] = m[ee];
          for (; ++V < Q; )
            (Ne || F < L) && (we[He + w[V]] = f[F++]);
          return we;
        }
        function zi(f, m) {
          var w = -1, E = f.length;
          for (m || (m = le(E)); ++w < E; )
            m[w] = f[w];
          return m;
        }
        function ha(f, m, w, E) {
          var F = !w;
          w || (w = {});
          for (var L = -1, V = m.length; ++L < V; ) {
            var Q = m[L], ee = E ? E(w[Q], f[Q], Q, w, f) : r;
            ee === r && (ee = f[Q]), F ? bl(w, Q, ee) : Rp(w, Q, ee);
          }
          return w;
        }
        function RU(f, m) {
          return ha(f, Vw(f), m);
        }
        function NU(f, m) {
          return ha(f, lE(f), m);
        }
        function nv(f, m) {
          return function(w, E) {
            var F = bt(w) ? zj : nU, L = m ? m() : {};
            return F(w, f, rt(E, 2), L);
          };
        }
        function cf(f) {
          return Tt(function(m, w) {
            var E = -1, F = w.length, L = F > 1 ? w[F - 1] : r, V = F > 2 ? w[2] : r;
            for (L = f.length > 3 && typeof L == "function" ? (F--, L) : r, V && ki(w[0], w[1], V) && (L = F < 3 ? r : L, F = 1), m = Ar(m); ++E < F; ) {
              var Q = w[E];
              Q && f(m, Q, E, L);
            }
            return m;
          });
        }
        function XA(f, m) {
          return function(w, E) {
            if (w == null)
              return w;
            if (!ji(w))
              return f(w, E);
            for (var F = w.length, L = m ? F : -1, V = Ar(w); (m ? L-- : ++L < F) && E(V[L], L, V) !== !1; )
              ;
            return w;
          };
        }
        function JA(f) {
          return function(m, w, E) {
            for (var F = -1, L = Ar(m), V = E(m), Q = V.length; Q--; ) {
              var ee = V[f ? Q : ++F];
              if (w(L[ee], ee, L) === !1)
                break;
            }
            return m;
          };
        }
        function $U(f, m, w) {
          var E = m & y, F = Lp(f);
          function L() {
            var V = this && this !== Un && this instanceof L ? F : f;
            return V.apply(E ? w : this, arguments);
          }
          return L;
        }
        function YA(f) {
          return function(m) {
            m = vr(m);
            var w = rf(m) ? Os(m) : r, E = w ? w[0] : m.charAt(0), F = w ? Cu(w, 1).join("") : m.slice(1);
            return E[f]() + F;
          };
        }
        function hf(f) {
          return function(m) {
            return uw(XE(QE(m).replace(Aj, "")), f, "");
          };
        }
        function Lp(f) {
          return function() {
            var m = arguments;
            switch (m.length) {
              case 0:
                return new f();
              case 1:
                return new f(m[0]);
              case 2:
                return new f(m[0], m[1]);
              case 3:
                return new f(m[0], m[1], m[2]);
              case 4:
                return new f(m[0], m[1], m[2], m[3]);
              case 5:
                return new f(m[0], m[1], m[2], m[3], m[4]);
              case 6:
                return new f(m[0], m[1], m[2], m[3], m[4], m[5]);
              case 7:
                return new f(m[0], m[1], m[2], m[3], m[4], m[5], m[6]);
            }
            var w = uf(f.prototype), E = f.apply(w, m);
            return Wr(E) ? E : w;
          };
        }
        function IU(f, m, w) {
          var E = Lp(f);
          function F() {
            for (var L = arguments.length, V = le(L), Q = L, ee = ff(F); Q--; )
              V[Q] = arguments[Q];
            var pe = L < 3 && V[0] !== ee && V[L - 1] !== ee ? [] : yu(V, ee);
            if (L -= pe.length, L < w)
              return nE(
                f,
                m,
                iv,
                F.placeholder,
                r,
                V,
                pe,
                r,
                r,
                w - L
              );
            var ge = this && this !== Un && this instanceof F ? E : f;
            return bo(ge, this, V);
          }
          return F;
        }
        function ZA(f) {
          return function(m, w, E) {
            var F = Ar(m);
            if (!ji(m)) {
              var L = rt(w, 3);
              m = Tn(m), w = function(Q) {
                return L(F[Q], Q, F);
              };
            }
            var V = f(m, w, E);
            return V > -1 ? F[L ? m[V] : V] : r;
          };
        }
        function eE(f) {
          return wl(function(m) {
            var w = m.length, E = w, F = ts.prototype.thru;
            for (f && m.reverse(); E--; ) {
              var L = m[E];
              if (typeof L != "function")
                throw new es(s);
              if (F && !V && lv(L) == "wrapper")
                var V = new ts([], !0);
            }
            for (E = V ? E : w; ++E < w; ) {
              L = m[E];
              var Q = lv(L), ee = Q == "wrapper" ? Uw(L) : r;
              ee && Gw(ee[0]) && ee[1] == (A | C | _ | O) && !ee[4].length && ee[9] == 1 ? V = V[lv(ee[0])].apply(V, ee[3]) : V = L.length == 1 && Gw(L) ? V[Q]() : V.thru(L);
            }
            return function() {
              var pe = arguments, ge = pe[0];
              if (V && pe.length == 1 && bt(ge))
                return V.plant(ge).value();
              for (var we = 0, Ne = w ? m[we].apply(this, pe) : ge; ++we < w; )
                Ne = m[we].call(this, Ne);
              return Ne;
            };
          });
        }
        function iv(f, m, w, E, F, L, V, Q, ee, pe) {
          var ge = m & A, we = m & y, Ne = m & b, He = m & (C | S), st = m & M, Ot = Ne ? r : Lp(f);
          function at() {
            for (var Rt = arguments.length, qt = le(Rt), Co = Rt; Co--; )
              qt[Co] = arguments[Co];
            if (He)
              var Ci = ff(at), _o = Qj(qt, Ci);
            if (E && (qt = KA(qt, E, F, He)), L && (qt = QA(qt, L, V, He)), Rt -= _o, He && Rt < pe) {
              var cn = yu(qt, Ci);
              return nE(
                f,
                m,
                iv,
                at.placeholder,
                w,
                qt,
                cn,
                Q,
                ee,
                pe - Rt
              );
            }
            var Ms = we ? w : this, Sl = Ne ? Ms[f] : f;
            return Rt = qt.length, Q ? qt = nH(qt, Q) : st && Rt > 1 && qt.reverse(), ge && ee < Rt && (qt.length = ee), this && this !== Un && this instanceof at && (Sl = Ot || Lp(Sl)), Sl.apply(Ms, qt);
          }
          return at;
        }
        function tE(f, m) {
          return function(w, E) {
            return hU(w, f, m(E), {});
          };
        }
        function ov(f, m) {
          return function(w, E) {
            var F;
            if (w === r && E === r)
              return m;
            if (w !== r && (F = w), E !== r) {
              if (F === r)
                return E;
              typeof w == "string" || typeof E == "string" ? (w = wo(w), E = wo(E)) : (w = zA(w), E = zA(E)), F = f(w, E);
            }
            return F;
          };
        }
        function Lw(f) {
          return wl(function(m) {
            return m = Lr(m, xo(rt())), Tt(function(w) {
              var E = this;
              return f(m, function(F) {
                return bo(F, E, w);
              });
            });
          });
        }
        function sv(f, m) {
          m = m === r ? " " : wo(m);
          var w = m.length;
          if (w < 2)
            return w ? Mw(m, f) : m;
          var E = Mw(m, W0(f / nf(m)));
          return rf(m) ? Cu(Os(E), 0, f).join("") : E.slice(0, f);
        }
        function BU(f, m, w, E) {
          var F = m & y, L = Lp(f);
          function V() {
            for (var Q = -1, ee = arguments.length, pe = -1, ge = E.length, we = le(ge + ee), Ne = this && this !== Un && this instanceof V ? L : f; ++pe < ge; )
              we[pe] = E[pe];
            for (; ee--; )
              we[pe++] = arguments[++Q];
            return bo(Ne, F ? w : this, we);
          }
          return V;
        }
        function rE(f) {
          return function(m, w, E) {
            return E && typeof E != "number" && ki(m, w, E) && (w = E = r), m = _l(m), w === r ? (w = m, m = 0) : w = _l(w), E = E === r ? m < w ? 1 : -1 : _l(E), CU(m, w, E, f);
          };
        }
        function av(f) {
          return function(m, w) {
            return typeof m == "string" && typeof w == "string" || (m = os(m), w = os(w)), f(m, w);
          };
        }
        function nE(f, m, w, E, F, L, V, Q, ee, pe) {
          var ge = m & C, we = ge ? V : r, Ne = ge ? r : V, He = ge ? L : r, st = ge ? r : L;
          m |= ge ? _ : D, m &= ~(ge ? D : _), m & k || (m &= -4);
          var Ot = [
            f,
            m,
            F,
            He,
            we,
            st,
            Ne,
            Q,
            ee,
            pe
          ], at = w.apply(r, Ot);
          return Gw(f) && mE(at, Ot), at.placeholder = E, gE(at, f, m);
        }
        function zw(f) {
          var m = kn[f];
          return function(w, E) {
            if (w = os(w), E = E == null ? 0 : Xn(At(E), 292), E && gA(w)) {
              var F = (vr(w) + "e").split("e"), L = m(F[0] + "e" + (+F[1] + E));
              return F = (vr(L) + "e").split("e"), +(F[0] + "e" + (+F[1] - E));
            }
            return m(w);
          };
        }
        var LU = af && 1 / $0(new af([, -0]))[1] == U ? function(f) {
          return new af(f);
        } : l2;
        function iE(f) {
          return function(m) {
            var w = Jn(m);
            return w == ot ? gw(m) : w == Ze ? rq(m) : Kj(m, f(m));
          };
        }
        function xl(f, m, w, E, F, L, V, Q) {
          var ee = m & b;
          if (!ee && typeof f != "function")
            throw new es(s);
          var pe = E ? E.length : 0;
          if (pe || (m &= -97, E = F = r), V = V === r ? V : Cn(At(V), 0), Q = Q === r ? Q : At(Q), pe -= F ? F.length : 0, m & D) {
            var ge = E, we = F;
            E = F = r;
          }
          var Ne = ee ? r : Uw(f), He = [
            f,
            m,
            w,
            E,
            F,
            ge,
            we,
            L,
            V,
            Q
          ];
          if (Ne && eH(He, Ne), f = He[0], m = He[1], w = He[2], E = He[3], F = He[4], Q = He[9] = He[9] === r ? ee ? 0 : f.length : Cn(He[9] - pe, 0), !Q && m & (C | S) && (m &= -25), !m || m == y)
            var st = $U(f, m, w);
          else m == C || m == S ? st = IU(f, m, Q) : (m == _ || m == (y | _)) && !F.length ? st = BU(f, m, w, E) : st = iv.apply(r, He);
          var Ot = Ne ? BA : mE;
          return gE(Ot(st, He), f, m);
        }
        function oE(f, m, w, E) {
          return f === r || Ts(f, sf[w]) && !br.call(E, w) ? m : f;
        }
        function sE(f, m, w, E, F, L) {
          return Wr(f) && Wr(m) && (L.set(m, f), ev(f, m, r, sE, L), L.delete(m)), f;
        }
        function zU(f) {
          return qp(f) ? r : f;
        }
        function aE(f, m, w, E, F, L) {
          var V = w & g, Q = f.length, ee = m.length;
          if (Q != ee && !(V && ee > Q))
            return !1;
          var pe = L.get(f), ge = L.get(m);
          if (pe && ge)
            return pe == m && ge == f;
          var we = -1, Ne = !0, He = w & v ? new _c() : r;
          for (L.set(f, m), L.set(m, f); ++we < Q; ) {
            var st = f[we], Ot = m[we];
            if (E)
              var at = V ? E(Ot, st, we, m, f, L) : E(st, Ot, we, f, m, L);
            if (at !== r) {
              if (at)
                continue;
              Ne = !1;
              break;
            }
            if (He) {
              if (!cw(m, function(Rt, qt) {
                if (!Dp(He, qt) && (st === Rt || F(st, Rt, w, E, L)))
                  return He.push(qt);
              })) {
                Ne = !1;
                break;
              }
            } else if (!(st === Ot || F(st, Ot, w, E, L))) {
              Ne = !1;
              break;
            }
          }
          return L.delete(f), L.delete(m), Ne;
        }
        function jU(f, m, w, E, F, L, V) {
          switch (w) {
            case pr:
              if (f.byteLength != m.byteLength || f.byteOffset != m.byteOffset)
                return !1;
              f = f.buffer, m = m.buffer;
            case kt:
              return !(f.byteLength != m.byteLength || !L(new q0(f), new q0(m)));
            case _e:
            case he:
            case Ye:
              return Ts(+f, +m);
            case ve:
              return f.name == m.name && f.message == m.message;
            case Ge:
            case It:
              return f == m + "";
            case ot:
              var Q = gw;
            case Ze:
              var ee = E & g;
              if (Q || (Q = $0), f.size != m.size && !ee)
                return !1;
              var pe = V.get(f);
              if (pe)
                return pe == m;
              E |= v, V.set(f, m);
              var ge = aE(Q(f), Q(m), E, F, L, V);
              return V.delete(f), ge;
            case rr:
              if (Pp)
                return Pp.call(f) == Pp.call(m);
          }
          return !1;
        }
        function qU(f, m, w, E, F, L) {
          var V = w & g, Q = jw(f), ee = Q.length, pe = jw(m), ge = pe.length;
          if (ee != ge && !V)
            return !1;
          for (var we = ee; we--; ) {
            var Ne = Q[we];
            if (!(V ? Ne in m : br.call(m, Ne)))
              return !1;
          }
          var He = L.get(f), st = L.get(m);
          if (He && st)
            return He == m && st == f;
          var Ot = !0;
          L.set(f, m), L.set(m, f);
          for (var at = V; ++we < ee; ) {
            Ne = Q[we];
            var Rt = f[Ne], qt = m[Ne];
            if (E)
              var Co = V ? E(qt, Rt, Ne, m, f, L) : E(Rt, qt, Ne, f, m, L);
            if (!(Co === r ? Rt === qt || F(Rt, qt, w, E, L) : Co)) {
              Ot = !1;
              break;
            }
            at || (at = Ne == "constructor");
          }
          if (Ot && !at) {
            var Ci = f.constructor, _o = m.constructor;
            Ci != _o && "constructor" in f && "constructor" in m && !(typeof Ci == "function" && Ci instanceof Ci && typeof _o == "function" && _o instanceof _o) && (Ot = !1);
          }
          return L.delete(f), L.delete(m), Ot;
        }
        function wl(f) {
          return Qw(dE(f, r, kE), f + "");
        }
        function jw(f) {
          return EA(f, Tn, Vw);
        }
        function qw(f) {
          return EA(f, qi, lE);
        }
        var Uw = K0 ? function(f) {
          return K0.get(f);
        } : l2;
        function lv(f) {
          for (var m = f.name + "", w = lf[m], E = br.call(lf, m) ? w.length : 0; E--; ) {
            var F = w[E], L = F.func;
            if (L == null || L == f)
              return F.name;
          }
          return m;
        }
        function ff(f) {
          var m = br.call(P, "placeholder") ? P : f;
          return m.placeholder;
        }
        function rt() {
          var f = P.iteratee || s2;
          return f = f === s2 ? FA : f, arguments.length ? f(arguments[0], arguments[1]) : f;
        }
        function uv(f, m) {
          var w = f.__data__;
          return XU(m) ? w[typeof m == "string" ? "string" : "hash"] : w.map;
        }
        function Hw(f) {
          for (var m = Tn(f), w = m.length; w--; ) {
            var E = m[w], F = f[E];
            m[w] = [E, F, hE(F)];
          }
          return m;
        }
        function Ec(f, m) {
          var w = Zj(f, m);
          return OA(w) ? w : r;
        }
        function UU(f) {
          var m = br.call(f, kc), w = f[kc];
          try {
            f[kc] = r;
            var E = !0;
          } catch {
          }
          var F = z0.call(f);
          return E && (m ? f[kc] = w : delete f[kc]), F;
        }
        var Vw = yw ? function(f) {
          return f == null ? [] : (f = Ar(f), gu(yw(f), function(m) {
            return pA.call(f, m);
          }));
        } : u2, lE = yw ? function(f) {
          for (var m = []; f; )
            vu(m, Vw(f)), f = U0(f);
          return m;
        } : u2, Jn = wi;
        (bw && Jn(new bw(new ArrayBuffer(1))) != pr || Fp && Jn(new Fp()) != ot || xw && Jn(xw.resolve()) != Gt || af && Jn(new af()) != Ze || Tp && Jn(new Tp()) != $e) && (Jn = function(f) {
          var m = wi(f), w = m == St ? f.constructor : r, E = w ? Dc(w) : "";
          if (E)
            switch (E) {
              case Sq:
                return pr;
              case Aq:
                return ot;
              case Eq:
                return Gt;
              case Dq:
                return Ze;
              case Oq:
                return $e;
            }
          return m;
        });
        function HU(f, m, w) {
          for (var E = -1, F = w.length; ++E < F; ) {
            var L = w[E], V = L.size;
            switch (L.type) {
              case "drop":
                f += V;
                break;
              case "dropRight":
                m -= V;
                break;
              case "take":
                m = Xn(m, f + V);
                break;
              case "takeRight":
                f = Cn(f, m - V);
                break;
            }
          }
          return { start: f, end: m };
        }
        function VU(f) {
          var m = f.match(Zx);
          return m ? m[1].split(ew) : [];
        }
        function uE(f, m, w) {
          m = ku(m, f);
          for (var E = -1, F = m.length, L = !1; ++E < F; ) {
            var V = fa(m[E]);
            if (!(L = f != null && w(f, V)))
              break;
            f = f[V];
          }
          return L || ++E != F ? L : (F = f == null ? 0 : f.length, !!F && gv(F) && kl(V, F) && (bt(f) || Oc(f)));
        }
        function WU(f) {
          var m = f.length, w = new f.constructor(m);
          return m && typeof f[0] == "string" && br.call(f, "index") && (w.index = f.index, w.input = f.input), w;
        }
        function cE(f) {
          return typeof f.constructor == "function" && !zp(f) ? uf(U0(f)) : {};
        }
        function GU(f, m, w) {
          var E = f.constructor;
          switch (m) {
            case kt:
              return Bw(f);
            case _e:
            case he:
              return new E(+f);
            case pr:
              return FU(f, w);
            case Zr:
            case Kt:
            case Je:
            case mr:
            case en:
            case xi:
            case pl:
            case Br:
            case qn:
              return WA(f, w);
            case ot:
              return new E();
            case Ye:
            case It:
              return new E(f);
            case Ge:
              return TU(f);
            case Ze:
              return new E();
            case rr:
              return MU(f);
          }
        }
        function KU(f, m) {
          var w = m.length;
          if (!w)
            return f;
          var E = w - 1;
          return m[E] = (w > 1 ? "& " : "") + m[E], m = m.join(w > 2 ? ", " : " "), f.replace(Yx, `{
/* [wrapped with ` + m + `] */
`);
        }
        function QU(f) {
          return bt(f) || Oc(f) || !!(mA && f && f[mA]);
        }
        function kl(f, m) {
          var w = typeof f;
          return m = m ?? H, !!m && (w == "number" || w != "symbol" && ln.test(f)) && f > -1 && f % 1 == 0 && f < m;
        }
        function ki(f, m, w) {
          if (!Wr(w))
            return !1;
          var E = typeof m;
          return (E == "number" ? ji(w) && kl(m, w.length) : E == "string" && m in w) ? Ts(w[m], f) : !1;
        }
        function Ww(f, m) {
          if (bt(f))
            return !1;
          var w = typeof f;
          return w == "number" || w == "symbol" || w == "boolean" || f == null || ko(f) ? !0 : Xx.test(f) || !F0.test(f) || m != null && f in Ar(m);
        }
        function XU(f) {
          var m = typeof f;
          return m == "string" || m == "number" || m == "symbol" || m == "boolean" ? f !== "__proto__" : f === null;
        }
        function Gw(f) {
          var m = lv(f), w = P[m];
          if (typeof w != "function" || !(m in Bt.prototype))
            return !1;
          if (f === w)
            return !0;
          var E = Uw(w);
          return !!E && f === E[0];
        }
        function JU(f) {
          return !!hA && hA in f;
        }
        var YU = B0 ? Cl : c2;
        function zp(f) {
          var m = f && f.constructor, w = typeof m == "function" && m.prototype || sf;
          return f === w;
        }
        function hE(f) {
          return f === f && !Wr(f);
        }
        function fE(f, m) {
          return function(w) {
            return w == null ? !1 : w[f] === m && (m !== r || f in Ar(w));
          };
        }
        function ZU(f) {
          var m = pv(f, function(E) {
            return w.size === u && w.clear(), E;
          }), w = m.cache;
          return m;
        }
        function eH(f, m) {
          var w = f[1], E = m[1], F = w | E, L = F < (y | b | A), V = E == A && w == C || E == A && w == O && f[7].length <= m[8] || E == (A | O) && m[7].length <= m[8] && w == C;
          if (!(L || V))
            return f;
          E & y && (f[2] = m[2], F |= w & y ? 0 : k);
          var Q = m[3];
          if (Q) {
            var ee = f[3];
            f[3] = ee ? KA(ee, Q, m[4]) : Q, f[4] = ee ? yu(f[3], c) : m[4];
          }
          return Q = m[5], Q && (ee = f[5], f[5] = ee ? QA(ee, Q, m[6]) : Q, f[6] = ee ? yu(f[5], c) : m[6]), Q = m[7], Q && (f[7] = Q), E & A && (f[8] = f[8] == null ? m[8] : Xn(f[8], m[8])), f[9] == null && (f[9] = m[9]), f[0] = m[0], f[1] = F, f;
        }
        function tH(f) {
          var m = [];
          if (f != null)
            for (var w in Ar(f))
              m.push(w);
          return m;
        }
        function rH(f) {
          return z0.call(f);
        }
        function dE(f, m, w) {
          return m = Cn(m === r ? f.length - 1 : m, 0), function() {
            for (var E = arguments, F = -1, L = Cn(E.length - m, 0), V = le(L); ++F < L; )
              V[F] = E[m + F];
            F = -1;
            for (var Q = le(m + 1); ++F < m; )
              Q[F] = E[F];
            return Q[m] = w(V), bo(f, this, Q);
          };
        }
        function pE(f, m) {
          return m.length < 2 ? f : Ac(f, ns(m, 0, -1));
        }
        function nH(f, m) {
          for (var w = f.length, E = Xn(m.length, w), F = zi(f); E--; ) {
            var L = m[E];
            f[E] = kl(L, w) ? F[L] : r;
          }
          return f;
        }
        function Kw(f, m) {
          if (!(m === "constructor" && typeof f[m] == "function") && m != "__proto__")
            return f[m];
        }
        var mE = vE(BA), jp = yq || function(f, m) {
          return Un.setTimeout(f, m);
        }, Qw = vE(AU);
        function gE(f, m, w) {
          var E = m + "";
          return Qw(f, KU(E, iH(VU(E), w)));
        }
        function vE(f) {
          var m = 0, w = 0;
          return function() {
            var E = kq(), F = I - (E - w);
            if (w = E, F > 0) {
              if (++m >= N)
                return arguments[0];
            } else
              m = 0;
            return f.apply(r, arguments);
          };
        }
        function cv(f, m) {
          var w = -1, E = f.length, F = E - 1;
          for (m = m === r ? E : m; ++w < m; ) {
            var L = Tw(w, F), V = f[L];
            f[L] = f[w], f[w] = V;
          }
          return f.length = m, f;
        }
        var yE = ZU(function(f) {
          var m = [];
          return f.charCodeAt(0) === 46 && m.push(""), f.replace(T0, function(w, E, F, L) {
            m.push(F ? L.replace(je, "$1") : E || w);
          }), m;
        });
        function fa(f) {
          if (typeof f == "string" || ko(f))
            return f;
          var m = f + "";
          return m == "0" && 1 / f == -U ? "-0" : m;
        }
        function Dc(f) {
          if (f != null) {
            try {
              return L0.call(f);
            } catch {
            }
            try {
              return f + "";
            } catch {
            }
          }
          return "";
        }
        function iH(f, m) {
          return Zo(ce, function(w) {
            var E = "_." + w[0];
            m & w[1] && !R0(f, E) && f.push(E);
          }), f.sort();
        }
        function bE(f) {
          if (f instanceof Bt)
            return f.clone();
          var m = new ts(f.__wrapped__, f.__chain__);
          return m.__actions__ = zi(f.__actions__), m.__index__ = f.__index__, m.__values__ = f.__values__, m;
        }
        function oH(f, m, w) {
          (w ? ki(f, m, w) : m === r) ? m = 1 : m = Cn(At(m), 0);
          var E = f == null ? 0 : f.length;
          if (!E || m < 1)
            return [];
          for (var F = 0, L = 0, V = le(W0(E / m)); F < E; )
            V[L++] = ns(f, F, F += m);
          return V;
        }
        function sH(f) {
          for (var m = -1, w = f == null ? 0 : f.length, E = 0, F = []; ++m < w; ) {
            var L = f[m];
            L && (F[E++] = L);
          }
          return F;
        }
        function aH() {
          var f = arguments.length;
          if (!f)
            return [];
          for (var m = le(f - 1), w = arguments[0], E = f; E--; )
            m[E - 1] = arguments[E];
          return vu(bt(w) ? zi(w) : [w], Hn(m, 1));
        }
        var lH = Tt(function(f, m) {
          return un(f) ? Np(f, Hn(m, 1, un, !0)) : [];
        }), uH = Tt(function(f, m) {
          var w = is(m);
          return un(w) && (w = r), un(f) ? Np(f, Hn(m, 1, un, !0), rt(w, 2)) : [];
        }), cH = Tt(function(f, m) {
          var w = is(m);
          return un(w) && (w = r), un(f) ? Np(f, Hn(m, 1, un, !0), r, w) : [];
        });
        function hH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (m = w || m === r ? 1 : At(m), ns(f, m < 0 ? 0 : m, E)) : [];
        }
        function fH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (m = w || m === r ? 1 : At(m), m = E - m, ns(f, 0, m < 0 ? 0 : m)) : [];
        }
        function dH(f, m) {
          return f && f.length ? rv(f, rt(m, 3), !0, !0) : [];
        }
        function pH(f, m) {
          return f && f.length ? rv(f, rt(m, 3), !0) : [];
        }
        function mH(f, m, w, E) {
          var F = f == null ? 0 : f.length;
          return F ? (w && typeof w != "number" && ki(f, m, w) && (w = 0, E = F), aU(f, m, w, E)) : [];
        }
        function xE(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = w == null ? 0 : At(w);
          return F < 0 && (F = Cn(E + F, 0)), N0(f, rt(m, 3), F);
        }
        function wE(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = E - 1;
          return w !== r && (F = At(w), F = w < 0 ? Cn(E + F, 0) : Xn(F, E - 1)), N0(f, rt(m, 3), F, !0);
        }
        function kE(f) {
          var m = f == null ? 0 : f.length;
          return m ? Hn(f, 1) : [];
        }
        function gH(f) {
          var m = f == null ? 0 : f.length;
          return m ? Hn(f, U) : [];
        }
        function vH(f, m) {
          var w = f == null ? 0 : f.length;
          return w ? (m = m === r ? 1 : At(m), Hn(f, m)) : [];
        }
        function yH(f) {
          for (var m = -1, w = f == null ? 0 : f.length, E = {}; ++m < w; ) {
            var F = f[m];
            E[F[0]] = F[1];
          }
          return E;
        }
        function CE(f) {
          return f && f.length ? f[0] : r;
        }
        function bH(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = w == null ? 0 : At(w);
          return F < 0 && (F = Cn(E + F, 0)), tf(f, m, F);
        }
        function xH(f) {
          var m = f == null ? 0 : f.length;
          return m ? ns(f, 0, -1) : [];
        }
        var wH = Tt(function(f) {
          var m = Lr(f, $w);
          return m.length && m[0] === f[0] ? Aw(m) : [];
        }), kH = Tt(function(f) {
          var m = is(f), w = Lr(f, $w);
          return m === is(w) ? m = r : w.pop(), w.length && w[0] === f[0] ? Aw(w, rt(m, 2)) : [];
        }), CH = Tt(function(f) {
          var m = is(f), w = Lr(f, $w);
          return m = typeof m == "function" ? m : r, m && w.pop(), w.length && w[0] === f[0] ? Aw(w, r, m) : [];
        });
        function _H(f, m) {
          return f == null ? "" : xq.call(f, m);
        }
        function is(f) {
          var m = f == null ? 0 : f.length;
          return m ? f[m - 1] : r;
        }
        function SH(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = E;
          return w !== r && (F = At(w), F = F < 0 ? Cn(E + F, 0) : Xn(F, E - 1)), m === m ? iq(f, m, F) : N0(f, nA, F, !0);
        }
        function AH(f, m) {
          return f && f.length ? RA(f, At(m)) : r;
        }
        var EH = Tt(_E);
        function _E(f, m) {
          return f && f.length && m && m.length ? Fw(f, m) : f;
        }
        function DH(f, m, w) {
          return f && f.length && m && m.length ? Fw(f, m, rt(w, 2)) : f;
        }
        function OH(f, m, w) {
          return f && f.length && m && m.length ? Fw(f, m, r, w) : f;
        }
        var FH = wl(function(f, m) {
          var w = f == null ? 0 : f.length, E = kw(f, m);
          return IA(f, Lr(m, function(F) {
            return kl(F, w) ? +F : F;
          }).sort(GA)), E;
        });
        function TH(f, m) {
          var w = [];
          if (!(f && f.length))
            return w;
          var E = -1, F = [], L = f.length;
          for (m = rt(m, 3); ++E < L; ) {
            var V = f[E];
            m(V, E, f) && (w.push(V), F.push(E));
          }
          return IA(f, F), w;
        }
        function Xw(f) {
          return f == null ? f : _q.call(f);
        }
        function MH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (w && typeof w != "number" && ki(f, m, w) ? (m = 0, w = E) : (m = m == null ? 0 : At(m), w = w === r ? E : At(w)), ns(f, m, w)) : [];
        }
        function PH(f, m) {
          return tv(f, m);
        }
        function RH(f, m, w) {
          return Pw(f, m, rt(w, 2));
        }
        function NH(f, m) {
          var w = f == null ? 0 : f.length;
          if (w) {
            var E = tv(f, m);
            if (E < w && Ts(f[E], m))
              return E;
          }
          return -1;
        }
        function $H(f, m) {
          return tv(f, m, !0);
        }
        function IH(f, m, w) {
          return Pw(f, m, rt(w, 2), !0);
        }
        function BH(f, m) {
          var w = f == null ? 0 : f.length;
          if (w) {
            var E = tv(f, m, !0) - 1;
            if (Ts(f[E], m))
              return E;
          }
          return -1;
        }
        function LH(f) {
          return f && f.length ? LA(f) : [];
        }
        function zH(f, m) {
          return f && f.length ? LA(f, rt(m, 2)) : [];
        }
        function jH(f) {
          var m = f == null ? 0 : f.length;
          return m ? ns(f, 1, m) : [];
        }
        function qH(f, m, w) {
          return f && f.length ? (m = w || m === r ? 1 : At(m), ns(f, 0, m < 0 ? 0 : m)) : [];
        }
        function UH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (m = w || m === r ? 1 : At(m), m = E - m, ns(f, m < 0 ? 0 : m, E)) : [];
        }
        function HH(f, m) {
          return f && f.length ? rv(f, rt(m, 3), !1, !0) : [];
        }
        function VH(f, m) {
          return f && f.length ? rv(f, rt(m, 3)) : [];
        }
        var WH = Tt(function(f) {
          return wu(Hn(f, 1, un, !0));
        }), GH = Tt(function(f) {
          var m = is(f);
          return un(m) && (m = r), wu(Hn(f, 1, un, !0), rt(m, 2));
        }), KH = Tt(function(f) {
          var m = is(f);
          return m = typeof m == "function" ? m : r, wu(Hn(f, 1, un, !0), r, m);
        });
        function QH(f) {
          return f && f.length ? wu(f) : [];
        }
        function XH(f, m) {
          return f && f.length ? wu(f, rt(m, 2)) : [];
        }
        function JH(f, m) {
          return m = typeof m == "function" ? m : r, f && f.length ? wu(f, r, m) : [];
        }
        function Jw(f) {
          if (!(f && f.length))
            return [];
          var m = 0;
          return f = gu(f, function(w) {
            if (un(w))
              return m = Cn(w.length, m), !0;
          }), pw(m, function(w) {
            return Lr(f, hw(w));
          });
        }
        function SE(f, m) {
          if (!(f && f.length))
            return [];
          var w = Jw(f);
          return m == null ? w : Lr(w, function(E) {
            return bo(m, r, E);
          });
        }
        var YH = Tt(function(f, m) {
          return un(f) ? Np(f, m) : [];
        }), ZH = Tt(function(f) {
          return Nw(gu(f, un));
        }), eV = Tt(function(f) {
          var m = is(f);
          return un(m) && (m = r), Nw(gu(f, un), rt(m, 2));
        }), tV = Tt(function(f) {
          var m = is(f);
          return m = typeof m == "function" ? m : r, Nw(gu(f, un), r, m);
        }), rV = Tt(Jw);
        function nV(f, m) {
          return UA(f || [], m || [], Rp);
        }
        function iV(f, m) {
          return UA(f || [], m || [], Bp);
        }
        var oV = Tt(function(f) {
          var m = f.length, w = m > 1 ? f[m - 1] : r;
          return w = typeof w == "function" ? (f.pop(), w) : r, SE(f, w);
        });
        function AE(f) {
          var m = P(f);
          return m.__chain__ = !0, m;
        }
        function sV(f, m) {
          return m(f), f;
        }
        function hv(f, m) {
          return m(f);
        }
        var aV = wl(function(f) {
          var m = f.length, w = m ? f[0] : 0, E = this.__wrapped__, F = function(L) {
            return kw(L, f);
          };
          return m > 1 || this.__actions__.length || !(E instanceof Bt) || !kl(w) ? this.thru(F) : (E = E.slice(w, +w + (m ? 1 : 0)), E.__actions__.push({
            func: hv,
            args: [F],
            thisArg: r
          }), new ts(E, this.__chain__).thru(function(L) {
            return m && !L.length && L.push(r), L;
          }));
        });
        function lV() {
          return AE(this);
        }
        function uV() {
          return new ts(this.value(), this.__chain__);
        }
        function cV() {
          this.__values__ === r && (this.__values__ = zE(this.value()));
          var f = this.__index__ >= this.__values__.length, m = f ? r : this.__values__[this.__index__++];
          return { done: f, value: m };
        }
        function hV() {
          return this;
        }
        function fV(f) {
          for (var m, w = this; w instanceof X0; ) {
            var E = bE(w);
            E.__index__ = 0, E.__values__ = r, m ? F.__wrapped__ = E : m = E;
            var F = E;
            w = w.__wrapped__;
          }
          return F.__wrapped__ = f, m;
        }
        function dV() {
          var f = this.__wrapped__;
          if (f instanceof Bt) {
            var m = f;
            return this.__actions__.length && (m = new Bt(this)), m = m.reverse(), m.__actions__.push({
              func: hv,
              args: [Xw],
              thisArg: r
            }), new ts(m, this.__chain__);
          }
          return this.thru(Xw);
        }
        function pV() {
          return qA(this.__wrapped__, this.__actions__);
        }
        var mV = nv(function(f, m, w) {
          br.call(f, w) ? ++f[w] : bl(f, w, 1);
        });
        function gV(f, m, w) {
          var E = bt(f) ? tA : sU;
          return w && ki(f, m, w) && (m = r), E(f, rt(m, 3));
        }
        function vV(f, m) {
          var w = bt(f) ? gu : SA;
          return w(f, rt(m, 3));
        }
        var yV = ZA(xE), bV = ZA(wE);
        function xV(f, m) {
          return Hn(fv(f, m), 1);
        }
        function wV(f, m) {
          return Hn(fv(f, m), U);
        }
        function kV(f, m, w) {
          return w = w === r ? 1 : At(w), Hn(fv(f, m), w);
        }
        function EE(f, m) {
          var w = bt(f) ? Zo : xu;
          return w(f, rt(m, 3));
        }
        function DE(f, m) {
          var w = bt(f) ? jj : _A;
          return w(f, rt(m, 3));
        }
        var CV = nv(function(f, m, w) {
          br.call(f, w) ? f[w].push(m) : bl(f, w, [m]);
        });
        function _V(f, m, w, E) {
          f = ji(f) ? f : pf(f), w = w && !E ? At(w) : 0;
          var F = f.length;
          return w < 0 && (w = Cn(F + w, 0)), vv(f) ? w <= F && f.indexOf(m, w) > -1 : !!F && tf(f, m, w) > -1;
        }
        var SV = Tt(function(f, m, w) {
          var E = -1, F = typeof m == "function", L = ji(f) ? le(f.length) : [];
          return xu(f, function(V) {
            L[++E] = F ? bo(m, V, w) : $p(V, m, w);
          }), L;
        }), AV = nv(function(f, m, w) {
          bl(f, w, m);
        });
        function fv(f, m) {
          var w = bt(f) ? Lr : TA;
          return w(f, rt(m, 3));
        }
        function EV(f, m, w, E) {
          return f == null ? [] : (bt(m) || (m = m == null ? [] : [m]), w = E ? r : w, bt(w) || (w = w == null ? [] : [w]), NA(f, m, w));
        }
        var DV = nv(function(f, m, w) {
          f[w ? 0 : 1].push(m);
        }, function() {
          return [[], []];
        });
        function OV(f, m, w) {
          var E = bt(f) ? uw : oA, F = arguments.length < 3;
          return E(f, rt(m, 4), w, F, xu);
        }
        function FV(f, m, w) {
          var E = bt(f) ? qj : oA, F = arguments.length < 3;
          return E(f, rt(m, 4), w, F, _A);
        }
        function TV(f, m) {
          var w = bt(f) ? gu : SA;
          return w(f, mv(rt(m, 3)));
        }
        function MV(f) {
          var m = bt(f) ? xA : _U;
          return m(f);
        }
        function PV(f, m, w) {
          (w ? ki(f, m, w) : m === r) ? m = 1 : m = At(m);
          var E = bt(f) ? tU : SU;
          return E(f, m);
        }
        function RV(f) {
          var m = bt(f) ? rU : EU;
          return m(f);
        }
        function NV(f) {
          if (f == null)
            return 0;
          if (ji(f))
            return vv(f) ? nf(f) : f.length;
          var m = Jn(f);
          return m == ot || m == Ze ? f.size : Dw(f).length;
        }
        function $V(f, m, w) {
          var E = bt(f) ? cw : DU;
          return w && ki(f, m, w) && (m = r), E(f, rt(m, 3));
        }
        var IV = Tt(function(f, m) {
          if (f == null)
            return [];
          var w = m.length;
          return w > 1 && ki(f, m[0], m[1]) ? m = [] : w > 2 && ki(m[0], m[1], m[2]) && (m = [m[0]]), NA(f, Hn(m, 1), []);
        }), dv = vq || function() {
          return Un.Date.now();
        };
        function BV(f, m) {
          if (typeof m != "function")
            throw new es(s);
          return f = At(f), function() {
            if (--f < 1)
              return m.apply(this, arguments);
          };
        }
        function OE(f, m, w) {
          return m = w ? r : m, m = f && m == null ? f.length : m, xl(f, A, r, r, r, r, m);
        }
        function FE(f, m) {
          var w;
          if (typeof m != "function")
            throw new es(s);
          return f = At(f), function() {
            return --f > 0 && (w = m.apply(this, arguments)), f <= 1 && (m = r), w;
          };
        }
        var Yw = Tt(function(f, m, w) {
          var E = y;
          if (w.length) {
            var F = yu(w, ff(Yw));
            E |= _;
          }
          return xl(f, E, m, w, F);
        }), TE = Tt(function(f, m, w) {
          var E = y | b;
          if (w.length) {
            var F = yu(w, ff(TE));
            E |= _;
          }
          return xl(m, E, f, w, F);
        });
        function ME(f, m, w) {
          m = w ? r : m;
          var E = xl(f, C, r, r, r, r, r, m);
          return E.placeholder = ME.placeholder, E;
        }
        function PE(f, m, w) {
          m = w ? r : m;
          var E = xl(f, S, r, r, r, r, r, m);
          return E.placeholder = PE.placeholder, E;
        }
        function RE(f, m, w) {
          var E, F, L, V, Q, ee, pe = 0, ge = !1, we = !1, Ne = !0;
          if (typeof f != "function")
            throw new es(s);
          m = os(m) || 0, Wr(w) && (ge = !!w.leading, we = "maxWait" in w, L = we ? Cn(os(w.maxWait) || 0, m) : L, Ne = "trailing" in w ? !!w.trailing : Ne);
          function He(cn) {
            var Ms = E, Sl = F;
            return E = F = r, pe = cn, V = f.apply(Sl, Ms), V;
          }
          function st(cn) {
            return pe = cn, Q = jp(Rt, m), ge ? He(cn) : V;
          }
          function Ot(cn) {
            var Ms = cn - ee, Sl = cn - pe, ZE = m - Ms;
            return we ? Xn(ZE, L - Sl) : ZE;
          }
          function at(cn) {
            var Ms = cn - ee, Sl = cn - pe;
            return ee === r || Ms >= m || Ms < 0 || we && Sl >= L;
          }
          function Rt() {
            var cn = dv();
            if (at(cn))
              return qt(cn);
            Q = jp(Rt, Ot(cn));
          }
          function qt(cn) {
            return Q = r, Ne && E ? He(cn) : (E = F = r, V);
          }
          function Co() {
            Q !== r && HA(Q), pe = 0, E = ee = F = Q = r;
          }
          function Ci() {
            return Q === r ? V : qt(dv());
          }
          function _o() {
            var cn = dv(), Ms = at(cn);
            if (E = arguments, F = this, ee = cn, Ms) {
              if (Q === r)
                return st(ee);
              if (we)
                return HA(Q), Q = jp(Rt, m), He(ee);
            }
            return Q === r && (Q = jp(Rt, m)), V;
          }
          return _o.cancel = Co, _o.flush = Ci, _o;
        }
        var LV = Tt(function(f, m) {
          return CA(f, 1, m);
        }), zV = Tt(function(f, m, w) {
          return CA(f, os(m) || 0, w);
        });
        function jV(f) {
          return xl(f, M);
        }
        function pv(f, m) {
          if (typeof f != "function" || m != null && typeof m != "function")
            throw new es(s);
          var w = function() {
            var E = arguments, F = m ? m.apply(this, E) : E[0], L = w.cache;
            if (L.has(F))
              return L.get(F);
            var V = f.apply(this, E);
            return w.cache = L.set(F, V) || L, V;
          };
          return w.cache = new (pv.Cache || yl)(), w;
        }
        pv.Cache = yl;
        function mv(f) {
          if (typeof f != "function")
            throw new es(s);
          return function() {
            var m = arguments;
            switch (m.length) {
              case 0:
                return !f.call(this);
              case 1:
                return !f.call(this, m[0]);
              case 2:
                return !f.call(this, m[0], m[1]);
              case 3:
                return !f.call(this, m[0], m[1], m[2]);
            }
            return !f.apply(this, m);
          };
        }
        function qV(f) {
          return FE(2, f);
        }
        var UV = OU(function(f, m) {
          m = m.length == 1 && bt(m[0]) ? Lr(m[0], xo(rt())) : Lr(Hn(m, 1), xo(rt()));
          var w = m.length;
          return Tt(function(E) {
            for (var F = -1, L = Xn(E.length, w); ++F < L; )
              E[F] = m[F].call(this, E[F]);
            return bo(f, this, E);
          });
        }), Zw = Tt(function(f, m) {
          var w = yu(m, ff(Zw));
          return xl(f, _, r, m, w);
        }), NE = Tt(function(f, m) {
          var w = yu(m, ff(NE));
          return xl(f, D, r, m, w);
        }), HV = wl(function(f, m) {
          return xl(f, O, r, r, r, m);
        });
        function VV(f, m) {
          if (typeof f != "function")
            throw new es(s);
          return m = m === r ? m : At(m), Tt(f, m);
        }
        function WV(f, m) {
          if (typeof f != "function")
            throw new es(s);
          return m = m == null ? 0 : Cn(At(m), 0), Tt(function(w) {
            var E = w[m], F = Cu(w, 0, m);
            return E && vu(F, E), bo(f, this, F);
          });
        }
        function GV(f, m, w) {
          var E = !0, F = !0;
          if (typeof f != "function")
            throw new es(s);
          return Wr(w) && (E = "leading" in w ? !!w.leading : E, F = "trailing" in w ? !!w.trailing : F), RE(f, m, {
            leading: E,
            maxWait: m,
            trailing: F
          });
        }
        function KV(f) {
          return OE(f, 1);
        }
        function QV(f, m) {
          return Zw(Iw(m), f);
        }
        function XV() {
          if (!arguments.length)
            return [];
          var f = arguments[0];
          return bt(f) ? f : [f];
        }
        function JV(f) {
          return rs(f, p);
        }
        function YV(f, m) {
          return m = typeof m == "function" ? m : r, rs(f, p, m);
        }
        function ZV(f) {
          return rs(f, h | p);
        }
        function eW(f, m) {
          return m = typeof m == "function" ? m : r, rs(f, h | p, m);
        }
        function tW(f, m) {
          return m == null || kA(f, m, Tn(m));
        }
        function Ts(f, m) {
          return f === m || f !== f && m !== m;
        }
        var rW = av(Sw), nW = av(function(f, m) {
          return f >= m;
        }), Oc = DA(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? DA : function(f) {
          return tn(f) && br.call(f, "callee") && !pA.call(f, "callee");
        }, bt = le.isArray, iW = Q5 ? xo(Q5) : fU;
        function ji(f) {
          return f != null && gv(f.length) && !Cl(f);
        }
        function un(f) {
          return tn(f) && ji(f);
        }
        function oW(f) {
          return f === !0 || f === !1 || tn(f) && wi(f) == _e;
        }
        var _u = bq || c2, sW = X5 ? xo(X5) : dU;
        function aW(f) {
          return tn(f) && f.nodeType === 1 && !qp(f);
        }
        function lW(f) {
          if (f == null)
            return !0;
          if (ji(f) && (bt(f) || typeof f == "string" || typeof f.splice == "function" || _u(f) || df(f) || Oc(f)))
            return !f.length;
          var m = Jn(f);
          if (m == ot || m == Ze)
            return !f.size;
          if (zp(f))
            return !Dw(f).length;
          for (var w in f)
            if (br.call(f, w))
              return !1;
          return !0;
        }
        function uW(f, m) {
          return Ip(f, m);
        }
        function cW(f, m, w) {
          w = typeof w == "function" ? w : r;
          var E = w ? w(f, m) : r;
          return E === r ? Ip(f, m, r, w) : !!E;
        }
        function e2(f) {
          if (!tn(f))
            return !1;
          var m = wi(f);
          return m == ve || m == ke || typeof f.message == "string" && typeof f.name == "string" && !qp(f);
        }
        function hW(f) {
          return typeof f == "number" && gA(f);
        }
        function Cl(f) {
          if (!Wr(f))
            return !1;
          var m = wi(f);
          return m == We || m == Qe || m == Me || m == $t;
        }
        function $E(f) {
          return typeof f == "number" && f == At(f);
        }
        function gv(f) {
          return typeof f == "number" && f > -1 && f % 1 == 0 && f <= H;
        }
        function Wr(f) {
          var m = typeof f;
          return f != null && (m == "object" || m == "function");
        }
        function tn(f) {
          return f != null && typeof f == "object";
        }
        var IE = J5 ? xo(J5) : mU;
        function fW(f, m) {
          return f === m || Ew(f, m, Hw(m));
        }
        function dW(f, m, w) {
          return w = typeof w == "function" ? w : r, Ew(f, m, Hw(m), w);
        }
        function pW(f) {
          return BE(f) && f != +f;
        }
        function mW(f) {
          if (YU(f))
            throw new vt(o);
          return OA(f);
        }
        function gW(f) {
          return f === null;
        }
        function vW(f) {
          return f == null;
        }
        function BE(f) {
          return typeof f == "number" || tn(f) && wi(f) == Ye;
        }
        function qp(f) {
          if (!tn(f) || wi(f) != St)
            return !1;
          var m = U0(f);
          if (m === null)
            return !0;
          var w = br.call(m, "constructor") && m.constructor;
          return typeof w == "function" && w instanceof w && L0.call(w) == dq;
        }
        var t2 = Y5 ? xo(Y5) : gU;
        function yW(f) {
          return $E(f) && f >= -H && f <= H;
        }
        var LE = Z5 ? xo(Z5) : vU;
        function vv(f) {
          return typeof f == "string" || !bt(f) && tn(f) && wi(f) == It;
        }
        function ko(f) {
          return typeof f == "symbol" || tn(f) && wi(f) == rr;
        }
        var df = eA ? xo(eA) : yU;
        function bW(f) {
          return f === r;
        }
        function xW(f) {
          return tn(f) && Jn(f) == $e;
        }
        function wW(f) {
          return tn(f) && wi(f) == lt;
        }
        var kW = av(Ow), CW = av(function(f, m) {
          return f <= m;
        });
        function zE(f) {
          if (!f)
            return [];
          if (ji(f))
            return vv(f) ? Os(f) : zi(f);
          if (Op && f[Op])
            return tq(f[Op]());
          var m = Jn(f), w = m == ot ? gw : m == Ze ? $0 : pf;
          return w(f);
        }
        function _l(f) {
          if (!f)
            return f === 0 ? f : 0;
          if (f = os(f), f === U || f === -U) {
            var m = f < 0 ? -1 : 1;
            return m * G;
          }
          return f === f ? f : 0;
        }
        function At(f) {
          var m = _l(f), w = m % 1;
          return m === m ? w ? m - w : m : 0;
        }
        function jE(f) {
          return f ? Sc(At(f), 0, ie) : 0;
        }
        function os(f) {
          if (typeof f == "number")
            return f;
          if (ko(f))
            return re;
          if (Wr(f)) {
            var m = typeof f.valueOf == "function" ? f.valueOf() : f;
            f = Wr(m) ? m + "" : m;
          }
          if (typeof f != "string")
            return f === 0 ? f : +f;
          f = sA(f);
          var w = Vt.test(f);
          return w || Sr.test(f) ? Bj(f.slice(2), w ? 2 : 8) : ht.test(f) ? re : +f;
        }
        function qE(f) {
          return ha(f, qi(f));
        }
        function _W(f) {
          return f ? Sc(At(f), -H, H) : f === 0 ? f : 0;
        }
        function vr(f) {
          return f == null ? "" : wo(f);
        }
        var SW = cf(function(f, m) {
          if (zp(m) || ji(m)) {
            ha(m, Tn(m), f);
            return;
          }
          for (var w in m)
            br.call(m, w) && Rp(f, w, m[w]);
        }), UE = cf(function(f, m) {
          ha(m, qi(m), f);
        }), yv = cf(function(f, m, w, E) {
          ha(m, qi(m), f, E);
        }), AW = cf(function(f, m, w, E) {
          ha(m, Tn(m), f, E);
        }), EW = wl(kw);
        function DW(f, m) {
          var w = uf(f);
          return m == null ? w : wA(w, m);
        }
        var OW = Tt(function(f, m) {
          f = Ar(f);
          var w = -1, E = m.length, F = E > 2 ? m[2] : r;
          for (F && ki(m[0], m[1], F) && (E = 1); ++w < E; )
            for (var L = m[w], V = qi(L), Q = -1, ee = V.length; ++Q < ee; ) {
              var pe = V[Q], ge = f[pe];
              (ge === r || Ts(ge, sf[pe]) && !br.call(f, pe)) && (f[pe] = L[pe]);
            }
          return f;
        }), FW = Tt(function(f) {
          return f.push(r, sE), bo(HE, r, f);
        });
        function TW(f, m) {
          return rA(f, rt(m, 3), ca);
        }
        function MW(f, m) {
          return rA(f, rt(m, 3), _w);
        }
        function PW(f, m) {
          return f == null ? f : Cw(f, rt(m, 3), qi);
        }
        function RW(f, m) {
          return f == null ? f : AA(f, rt(m, 3), qi);
        }
        function NW(f, m) {
          return f && ca(f, rt(m, 3));
        }
        function $W(f, m) {
          return f && _w(f, rt(m, 3));
        }
        function IW(f) {
          return f == null ? [] : Z0(f, Tn(f));
        }
        function BW(f) {
          return f == null ? [] : Z0(f, qi(f));
        }
        function r2(f, m, w) {
          var E = f == null ? r : Ac(f, m);
          return E === r ? w : E;
        }
        function LW(f, m) {
          return f != null && uE(f, m, lU);
        }
        function n2(f, m) {
          return f != null && uE(f, m, uU);
        }
        var zW = tE(function(f, m, w) {
          m != null && typeof m.toString != "function" && (m = z0.call(m)), f[m] = w;
        }, o2(Ui)), jW = tE(function(f, m, w) {
          m != null && typeof m.toString != "function" && (m = z0.call(m)), br.call(f, m) ? f[m].push(w) : f[m] = [w];
        }, rt), qW = Tt($p);
        function Tn(f) {
          return ji(f) ? bA(f) : Dw(f);
        }
        function qi(f) {
          return ji(f) ? bA(f, !0) : bU(f);
        }
        function UW(f, m) {
          var w = {};
          return m = rt(m, 3), ca(f, function(E, F, L) {
            bl(w, m(E, F, L), E);
          }), w;
        }
        function HW(f, m) {
          var w = {};
          return m = rt(m, 3), ca(f, function(E, F, L) {
            bl(w, F, m(E, F, L));
          }), w;
        }
        var VW = cf(function(f, m, w) {
          ev(f, m, w);
        }), HE = cf(function(f, m, w, E) {
          ev(f, m, w, E);
        }), WW = wl(function(f, m) {
          var w = {};
          if (f == null)
            return w;
          var E = !1;
          m = Lr(m, function(L) {
            return L = ku(L, f), E || (E = L.length > 1), L;
          }), ha(f, qw(f), w), E && (w = rs(w, h | d | p, zU));
          for (var F = m.length; F--; )
            Rw(w, m[F]);
          return w;
        });
        function GW(f, m) {
          return VE(f, mv(rt(m)));
        }
        var KW = wl(function(f, m) {
          return f == null ? {} : wU(f, m);
        });
        function VE(f, m) {
          if (f == null)
            return {};
          var w = Lr(qw(f), function(E) {
            return [E];
          });
          return m = rt(m), $A(f, w, function(E, F) {
            return m(E, F[0]);
          });
        }
        function QW(f, m, w) {
          m = ku(m, f);
          var E = -1, F = m.length;
          for (F || (F = 1, f = r); ++E < F; ) {
            var L = f == null ? r : f[fa(m[E])];
            L === r && (E = F, L = w), f = Cl(L) ? L.call(f) : L;
          }
          return f;
        }
        function XW(f, m, w) {
          return f == null ? f : Bp(f, m, w);
        }
        function JW(f, m, w, E) {
          return E = typeof E == "function" ? E : r, f == null ? f : Bp(f, m, w, E);
        }
        var WE = iE(Tn), GE = iE(qi);
        function YW(f, m, w) {
          var E = bt(f), F = E || _u(f) || df(f);
          if (m = rt(m, 4), w == null) {
            var L = f && f.constructor;
            F ? w = E ? new L() : [] : Wr(f) ? w = Cl(L) ? uf(U0(f)) : {} : w = {};
          }
          return (F ? Zo : ca)(f, function(V, Q, ee) {
            return m(w, V, Q, ee);
          }), w;
        }
        function ZW(f, m) {
          return f == null ? !0 : Rw(f, m);
        }
        function eG(f, m, w) {
          return f == null ? f : jA(f, m, Iw(w));
        }
        function tG(f, m, w, E) {
          return E = typeof E == "function" ? E : r, f == null ? f : jA(f, m, Iw(w), E);
        }
        function pf(f) {
          return f == null ? [] : mw(f, Tn(f));
        }
        function rG(f) {
          return f == null ? [] : mw(f, qi(f));
        }
        function nG(f, m, w) {
          return w === r && (w = m, m = r), w !== r && (w = os(w), w = w === w ? w : 0), m !== r && (m = os(m), m = m === m ? m : 0), Sc(os(f), m, w);
        }
        function iG(f, m, w) {
          return m = _l(m), w === r ? (w = m, m = 0) : w = _l(w), f = os(f), cU(f, m, w);
        }
        function oG(f, m, w) {
          if (w && typeof w != "boolean" && ki(f, m, w) && (m = w = r), w === r && (typeof m == "boolean" ? (w = m, m = r) : typeof f == "boolean" && (w = f, f = r)), f === r && m === r ? (f = 0, m = 1) : (f = _l(f), m === r ? (m = f, f = 0) : m = _l(m)), f > m) {
            var E = f;
            f = m, m = E;
          }
          if (w || f % 1 || m % 1) {
            var F = vA();
            return Xn(f + F * (m - f + Ij("1e-" + ((F + "").length - 1))), m);
          }
          return Tw(f, m);
        }
        var sG = hf(function(f, m, w) {
          return m = m.toLowerCase(), f + (w ? KE(m) : m);
        });
        function KE(f) {
          return i2(vr(f).toLowerCase());
        }
        function QE(f) {
          return f = vr(f), f && f.replace(Jo, Xj).replace(Ej, "");
        }
        function aG(f, m, w) {
          f = vr(f), m = wo(m);
          var E = f.length;
          w = w === r ? E : Sc(At(w), 0, E);
          var F = w;
          return w -= m.length, w >= 0 && f.slice(w, F) == m;
        }
        function lG(f) {
          return f = vr(f), f && Qx.test(f) ? f.replace(xc, Jj) : f;
        }
        function uG(f) {
          return f = vr(f), f && Jx.test(f) ? f.replace(Sp, "\\$&") : f;
        }
        var cG = hf(function(f, m, w) {
          return f + (w ? "-" : "") + m.toLowerCase();
        }), hG = hf(function(f, m, w) {
          return f + (w ? " " : "") + m.toLowerCase();
        }), fG = YA("toLowerCase");
        function dG(f, m, w) {
          f = vr(f), m = At(m);
          var E = m ? nf(f) : 0;
          if (!m || E >= m)
            return f;
          var F = (m - E) / 2;
          return sv(G0(F), w) + f + sv(W0(F), w);
        }
        function pG(f, m, w) {
          f = vr(f), m = At(m);
          var E = m ? nf(f) : 0;
          return m && E < m ? f + sv(m - E, w) : f;
        }
        function mG(f, m, w) {
          f = vr(f), m = At(m);
          var E = m ? nf(f) : 0;
          return m && E < m ? sv(m - E, w) + f : f;
        }
        function gG(f, m, w) {
          return w || m == null ? m = 0 : m && (m = +m), Cq(vr(f).replace(Ap, ""), m || 0);
        }
        function vG(f, m, w) {
          return (w ? ki(f, m, w) : m === r) ? m = 1 : m = At(m), Mw(vr(f), m);
        }
        function yG() {
          var f = arguments, m = vr(f[0]);
          return f.length < 3 ? m : m.replace(f[1], f[2]);
        }
        var bG = hf(function(f, m, w) {
          return f + (w ? "_" : "") + m.toLowerCase();
        });
        function xG(f, m, w) {
          return w && typeof w != "number" && ki(f, m, w) && (m = w = r), w = w === r ? ie : w >>> 0, w ? (f = vr(f), f && (typeof m == "string" || m != null && !t2(m)) && (m = wo(m), !m && rf(f)) ? Cu(Os(f), 0, w) : f.split(m, w)) : [];
        }
        var wG = hf(function(f, m, w) {
          return f + (w ? " " : "") + i2(m);
        });
        function kG(f, m, w) {
          return f = vr(f), w = w == null ? 0 : Sc(At(w), 0, f.length), m = wo(m), f.slice(w, w + m.length) == m;
        }
        function CG(f, m, w) {
          var E = P.templateSettings;
          w && ki(f, m, w) && (m = r), f = vr(f), m = yv({}, m, E, oE);
          var F = yv({}, m.imports, E.imports, oE), L = Tn(F), V = mw(F, L), Q, ee, pe = 0, ge = m.interpolate || Fn, we = "__p += '", Ne = vw(
            (m.escape || Fn).source + "|" + ge.source + "|" + (ge === O0 ? Ke : Fn).source + "|" + (m.evaluate || Fn).source + "|$",
            "g"
          ), He = "//# sourceURL=" + (br.call(m, "sourceURL") ? (m.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Mj + "]") + `
`;
          f.replace(Ne, function(at, Rt, qt, Co, Ci, _o) {
            return qt || (qt = Co), we += f.slice(pe, _o).replace(yo, Yj), Rt && (Q = !0, we += `' +
__e(` + Rt + `) +
'`), Ci && (ee = !0, we += `';
` + Ci + `;
__p += '`), qt && (we += `' +
((__t = (` + qt + `)) == null ? '' : __t) +
'`), pe = _o + at.length, at;
          }), we += `';
`;
          var st = br.call(m, "variable") && m.variable;
          if (!st)
            we = `with (obj) {
` + we + `
}
`;
          else if (Te.test(st))
            throw new vt(a);
          we = (ee ? we.replace(vo, "") : we).replace(la, "$1").replace(Ss, "$1;"), we = "function(" + (st || "obj") + `) {
` + (st ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Q ? ", __e = _.escape" : "") + (ee ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + we + `return __p
}`;
          var Ot = JE(function() {
            return ur(L, He + "return " + we).apply(r, V);
          });
          if (Ot.source = we, e2(Ot))
            throw Ot;
          return Ot;
        }
        function _G(f) {
          return vr(f).toLowerCase();
        }
        function SG(f) {
          return vr(f).toUpperCase();
        }
        function AG(f, m, w) {
          if (f = vr(f), f && (w || m === r))
            return sA(f);
          if (!f || !(m = wo(m)))
            return f;
          var E = Os(f), F = Os(m), L = aA(E, F), V = lA(E, F) + 1;
          return Cu(E, L, V).join("");
        }
        function EG(f, m, w) {
          if (f = vr(f), f && (w || m === r))
            return f.slice(0, cA(f) + 1);
          if (!f || !(m = wo(m)))
            return f;
          var E = Os(f), F = lA(E, Os(m)) + 1;
          return Cu(E, 0, F).join("");
        }
        function DG(f, m, w) {
          if (f = vr(f), f && (w || m === r))
            return f.replace(Ap, "");
          if (!f || !(m = wo(m)))
            return f;
          var E = Os(f), F = aA(E, Os(m));
          return Cu(E, F).join("");
        }
        function OG(f, m) {
          var w = z, E = R;
          if (Wr(m)) {
            var F = "separator" in m ? m.separator : F;
            w = "length" in m ? At(m.length) : w, E = "omission" in m ? wo(m.omission) : E;
          }
          f = vr(f);
          var L = f.length;
          if (rf(f)) {
            var V = Os(f);
            L = V.length;
          }
          if (w >= L)
            return f;
          var Q = w - nf(E);
          if (Q < 1)
            return E;
          var ee = V ? Cu(V, 0, Q).join("") : f.slice(0, Q);
          if (F === r)
            return ee + E;
          if (V && (Q += ee.length - Q), t2(F)) {
            if (f.slice(Q).search(F)) {
              var pe, ge = ee;
              for (F.global || (F = vw(F.source, vr(et.exec(F)) + "g")), F.lastIndex = 0; pe = F.exec(ge); )
                var we = pe.index;
              ee = ee.slice(0, we === r ? Q : we);
            }
          } else if (f.indexOf(wo(F), Q) != Q) {
            var Ne = ee.lastIndexOf(F);
            Ne > -1 && (ee = ee.slice(0, Ne));
          }
          return ee + E;
        }
        function FG(f) {
          return f = vr(f), f && Kx.test(f) ? f.replace(As, oq) : f;
        }
        var TG = hf(function(f, m, w) {
          return f + (w ? " " : "") + m.toUpperCase();
        }), i2 = YA("toUpperCase");
        function XE(f, m, w) {
          return f = vr(f), m = w ? r : m, m === r ? eq(f) ? lq(f) : Vj(f) : f.match(m) || [];
        }
        var JE = Tt(function(f, m) {
          try {
            return bo(f, r, m);
          } catch (w) {
            return e2(w) ? w : new vt(w);
          }
        }), MG = wl(function(f, m) {
          return Zo(m, function(w) {
            w = fa(w), bl(f, w, Yw(f[w], f));
          }), f;
        });
        function PG(f) {
          var m = f == null ? 0 : f.length, w = rt();
          return f = m ? Lr(f, function(E) {
            if (typeof E[1] != "function")
              throw new es(s);
            return [w(E[0]), E[1]];
          }) : [], Tt(function(E) {
            for (var F = -1; ++F < m; ) {
              var L = f[F];
              if (bo(L[0], this, E))
                return bo(L[1], this, E);
            }
          });
        }
        function RG(f) {
          return oU(rs(f, h));
        }
        function o2(f) {
          return function() {
            return f;
          };
        }
        function NG(f, m) {
          return f == null || f !== f ? m : f;
        }
        var $G = eE(), IG = eE(!0);
        function Ui(f) {
          return f;
        }
        function s2(f) {
          return FA(typeof f == "function" ? f : rs(f, h));
        }
        function BG(f) {
          return MA(rs(f, h));
        }
        function LG(f, m) {
          return PA(f, rs(m, h));
        }
        var zG = Tt(function(f, m) {
          return function(w) {
            return $p(w, f, m);
          };
        }), jG = Tt(function(f, m) {
          return function(w) {
            return $p(f, w, m);
          };
        });
        function a2(f, m, w) {
          var E = Tn(m), F = Z0(m, E);
          w == null && !(Wr(m) && (F.length || !E.length)) && (w = m, m = f, f = this, F = Z0(m, Tn(m)));
          var L = !(Wr(w) && "chain" in w) || !!w.chain, V = Cl(f);
          return Zo(F, function(Q) {
            var ee = m[Q];
            f[Q] = ee, V && (f.prototype[Q] = function() {
              var pe = this.__chain__;
              if (L || pe) {
                var ge = f(this.__wrapped__), we = ge.__actions__ = zi(this.__actions__);
                return we.push({ func: ee, args: arguments, thisArg: f }), ge.__chain__ = pe, ge;
              }
              return ee.apply(f, vu([this.value()], arguments));
            });
          }), f;
        }
        function qG() {
          return Un._ === this && (Un._ = pq), this;
        }
        function l2() {
        }
        function UG(f) {
          return f = At(f), Tt(function(m) {
            return RA(m, f);
          });
        }
        var HG = Lw(Lr), VG = Lw(tA), WG = Lw(cw);
        function YE(f) {
          return Ww(f) ? hw(fa(f)) : kU(f);
        }
        function GG(f) {
          return function(m) {
            return f == null ? r : Ac(f, m);
          };
        }
        var KG = rE(), QG = rE(!0);
        function u2() {
          return [];
        }
        function c2() {
          return !1;
        }
        function XG() {
          return {};
        }
        function JG() {
          return "";
        }
        function YG() {
          return !0;
        }
        function ZG(f, m) {
          if (f = At(f), f < 1 || f > H)
            return [];
          var w = ie, E = Xn(f, ie);
          m = rt(m), f -= ie;
          for (var F = pw(E, m); ++w < f; )
            m(w);
          return F;
        }
        function eK(f) {
          return bt(f) ? Lr(f, fa) : ko(f) ? [f] : zi(yE(vr(f)));
        }
        function tK(f) {
          var m = ++fq;
          return vr(f) + m;
        }
        var rK = ov(function(f, m) {
          return f + m;
        }, 0), nK = zw("ceil"), iK = ov(function(f, m) {
          return f / m;
        }, 1), oK = zw("floor");
        function sK(f) {
          return f && f.length ? Y0(f, Ui, Sw) : r;
        }
        function aK(f, m) {
          return f && f.length ? Y0(f, rt(m, 2), Sw) : r;
        }
        function lK(f) {
          return iA(f, Ui);
        }
        function uK(f, m) {
          return iA(f, rt(m, 2));
        }
        function cK(f) {
          return f && f.length ? Y0(f, Ui, Ow) : r;
        }
        function hK(f, m) {
          return f && f.length ? Y0(f, rt(m, 2), Ow) : r;
        }
        var fK = ov(function(f, m) {
          return f * m;
        }, 1), dK = zw("round"), pK = ov(function(f, m) {
          return f - m;
        }, 0);
        function mK(f) {
          return f && f.length ? dw(f, Ui) : 0;
        }
        function gK(f, m) {
          return f && f.length ? dw(f, rt(m, 2)) : 0;
        }
        return P.after = BV, P.ary = OE, P.assign = SW, P.assignIn = UE, P.assignInWith = yv, P.assignWith = AW, P.at = EW, P.before = FE, P.bind = Yw, P.bindAll = MG, P.bindKey = TE, P.castArray = XV, P.chain = AE, P.chunk = oH, P.compact = sH, P.concat = aH, P.cond = PG, P.conforms = RG, P.constant = o2, P.countBy = mV, P.create = DW, P.curry = ME, P.curryRight = PE, P.debounce = RE, P.defaults = OW, P.defaultsDeep = FW, P.defer = LV, P.delay = zV, P.difference = lH, P.differenceBy = uH, P.differenceWith = cH, P.drop = hH, P.dropRight = fH, P.dropRightWhile = dH, P.dropWhile = pH, P.fill = mH, P.filter = vV, P.flatMap = xV, P.flatMapDeep = wV, P.flatMapDepth = kV, P.flatten = kE, P.flattenDeep = gH, P.flattenDepth = vH, P.flip = jV, P.flow = $G, P.flowRight = IG, P.fromPairs = yH, P.functions = IW, P.functionsIn = BW, P.groupBy = CV, P.initial = xH, P.intersection = wH, P.intersectionBy = kH, P.intersectionWith = CH, P.invert = zW, P.invertBy = jW, P.invokeMap = SV, P.iteratee = s2, P.keyBy = AV, P.keys = Tn, P.keysIn = qi, P.map = fv, P.mapKeys = UW, P.mapValues = HW, P.matches = BG, P.matchesProperty = LG, P.memoize = pv, P.merge = VW, P.mergeWith = HE, P.method = zG, P.methodOf = jG, P.mixin = a2, P.negate = mv, P.nthArg = UG, P.omit = WW, P.omitBy = GW, P.once = qV, P.orderBy = EV, P.over = HG, P.overArgs = UV, P.overEvery = VG, P.overSome = WG, P.partial = Zw, P.partialRight = NE, P.partition = DV, P.pick = KW, P.pickBy = VE, P.property = YE, P.propertyOf = GG, P.pull = EH, P.pullAll = _E, P.pullAllBy = DH, P.pullAllWith = OH, P.pullAt = FH, P.range = KG, P.rangeRight = QG, P.rearg = HV, P.reject = TV, P.remove = TH, P.rest = VV, P.reverse = Xw, P.sampleSize = PV, P.set = XW, P.setWith = JW, P.shuffle = RV, P.slice = MH, P.sortBy = IV, P.sortedUniq = LH, P.sortedUniqBy = zH, P.split = xG, P.spread = WV, P.tail = jH, P.take = qH, P.takeRight = UH, P.takeRightWhile = HH, P.takeWhile = VH, P.tap = sV, P.throttle = GV, P.thru = hv, P.toArray = zE, P.toPairs = WE, P.toPairsIn = GE, P.toPath = eK, P.toPlainObject = qE, P.transform = YW, P.unary = KV, P.union = WH, P.unionBy = GH, P.unionWith = KH, P.uniq = QH, P.uniqBy = XH, P.uniqWith = JH, P.unset = ZW, P.unzip = Jw, P.unzipWith = SE, P.update = eG, P.updateWith = tG, P.values = pf, P.valuesIn = rG, P.without = YH, P.words = XE, P.wrap = QV, P.xor = ZH, P.xorBy = eV, P.xorWith = tV, P.zip = rV, P.zipObject = nV, P.zipObjectDeep = iV, P.zipWith = oV, P.entries = WE, P.entriesIn = GE, P.extend = UE, P.extendWith = yv, a2(P, P), P.add = rK, P.attempt = JE, P.camelCase = sG, P.capitalize = KE, P.ceil = nK, P.clamp = nG, P.clone = JV, P.cloneDeep = ZV, P.cloneDeepWith = eW, P.cloneWith = YV, P.conformsTo = tW, P.deburr = QE, P.defaultTo = NG, P.divide = iK, P.endsWith = aG, P.eq = Ts, P.escape = lG, P.escapeRegExp = uG, P.every = gV, P.find = yV, P.findIndex = xE, P.findKey = TW, P.findLast = bV, P.findLastIndex = wE, P.findLastKey = MW, P.floor = oK, P.forEach = EE, P.forEachRight = DE, P.forIn = PW, P.forInRight = RW, P.forOwn = NW, P.forOwnRight = $W, P.get = r2, P.gt = rW, P.gte = nW, P.has = LW, P.hasIn = n2, P.head = CE, P.identity = Ui, P.includes = _V, P.indexOf = bH, P.inRange = iG, P.invoke = qW, P.isArguments = Oc, P.isArray = bt, P.isArrayBuffer = iW, P.isArrayLike = ji, P.isArrayLikeObject = un, P.isBoolean = oW, P.isBuffer = _u, P.isDate = sW, P.isElement = aW, P.isEmpty = lW, P.isEqual = uW, P.isEqualWith = cW, P.isError = e2, P.isFinite = hW, P.isFunction = Cl, P.isInteger = $E, P.isLength = gv, P.isMap = IE, P.isMatch = fW, P.isMatchWith = dW, P.isNaN = pW, P.isNative = mW, P.isNil = vW, P.isNull = gW, P.isNumber = BE, P.isObject = Wr, P.isObjectLike = tn, P.isPlainObject = qp, P.isRegExp = t2, P.isSafeInteger = yW, P.isSet = LE, P.isString = vv, P.isSymbol = ko, P.isTypedArray = df, P.isUndefined = bW, P.isWeakMap = xW, P.isWeakSet = wW, P.join = _H, P.kebabCase = cG, P.last = is, P.lastIndexOf = SH, P.lowerCase = hG, P.lowerFirst = fG, P.lt = kW, P.lte = CW, P.max = sK, P.maxBy = aK, P.mean = lK, P.meanBy = uK, P.min = cK, P.minBy = hK, P.stubArray = u2, P.stubFalse = c2, P.stubObject = XG, P.stubString = JG, P.stubTrue = YG, P.multiply = fK, P.nth = AH, P.noConflict = qG, P.noop = l2, P.now = dv, P.pad = dG, P.padEnd = pG, P.padStart = mG, P.parseInt = gG, P.random = oG, P.reduce = OV, P.reduceRight = FV, P.repeat = vG, P.replace = yG, P.result = QW, P.round = dK, P.runInContext = Z, P.sample = MV, P.size = NV, P.snakeCase = bG, P.some = $V, P.sortedIndex = PH, P.sortedIndexBy = RH, P.sortedIndexOf = NH, P.sortedLastIndex = $H, P.sortedLastIndexBy = IH, P.sortedLastIndexOf = BH, P.startCase = wG, P.startsWith = kG, P.subtract = pK, P.sum = mK, P.sumBy = gK, P.template = CG, P.times = ZG, P.toFinite = _l, P.toInteger = At, P.toLength = jE, P.toLower = _G, P.toNumber = os, P.toSafeInteger = _W, P.toString = vr, P.toUpper = SG, P.trim = AG, P.trimEnd = EG, P.trimStart = DG, P.truncate = OG, P.unescape = FG, P.uniqueId = tK, P.upperCase = TG, P.upperFirst = i2, P.each = EE, P.eachRight = DE, P.first = CE, a2(P, (function() {
          var f = {};
          return ca(P, function(m, w) {
            br.call(P.prototype, w) || (f[w] = m);
          }), f;
        })(), { chain: !1 }), P.VERSION = n, Zo(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(f) {
          P[f].placeholder = P;
        }), Zo(["drop", "take"], function(f, m) {
          Bt.prototype[f] = function(w) {
            w = w === r ? 1 : Cn(At(w), 0);
            var E = this.__filtered__ && !m ? new Bt(this) : this.clone();
            return E.__filtered__ ? E.__takeCount__ = Xn(w, E.__takeCount__) : E.__views__.push({
              size: Xn(w, ie),
              type: f + (E.__dir__ < 0 ? "Right" : "")
            }), E;
          }, Bt.prototype[f + "Right"] = function(w) {
            return this.reverse()[f](w).reverse();
          };
        }), Zo(["filter", "map", "takeWhile"], function(f, m) {
          var w = m + 1, E = w == B || w == q;
          Bt.prototype[f] = function(F) {
            var L = this.clone();
            return L.__iteratees__.push({
              iteratee: rt(F, 3),
              type: w
            }), L.__filtered__ = L.__filtered__ || E, L;
          };
        }), Zo(["head", "last"], function(f, m) {
          var w = "take" + (m ? "Right" : "");
          Bt.prototype[f] = function() {
            return this[w](1).value()[0];
          };
        }), Zo(["initial", "tail"], function(f, m) {
          var w = "drop" + (m ? "" : "Right");
          Bt.prototype[f] = function() {
            return this.__filtered__ ? new Bt(this) : this[w](1);
          };
        }), Bt.prototype.compact = function() {
          return this.filter(Ui);
        }, Bt.prototype.find = function(f) {
          return this.filter(f).head();
        }, Bt.prototype.findLast = function(f) {
          return this.reverse().find(f);
        }, Bt.prototype.invokeMap = Tt(function(f, m) {
          return typeof f == "function" ? new Bt(this) : this.map(function(w) {
            return $p(w, f, m);
          });
        }), Bt.prototype.reject = function(f) {
          return this.filter(mv(rt(f)));
        }, Bt.prototype.slice = function(f, m) {
          f = At(f);
          var w = this;
          return w.__filtered__ && (f > 0 || m < 0) ? new Bt(w) : (f < 0 ? w = w.takeRight(-f) : f && (w = w.drop(f)), m !== r && (m = At(m), w = m < 0 ? w.dropRight(-m) : w.take(m - f)), w);
        }, Bt.prototype.takeRightWhile = function(f) {
          return this.reverse().takeWhile(f).reverse();
        }, Bt.prototype.toArray = function() {
          return this.take(ie);
        }, ca(Bt.prototype, function(f, m) {
          var w = /^(?:filter|find|map|reject)|While$/.test(m), E = /^(?:head|last)$/.test(m), F = P[E ? "take" + (m == "last" ? "Right" : "") : m], L = E || /^find/.test(m);
          F && (P.prototype[m] = function() {
            var V = this.__wrapped__, Q = E ? [1] : arguments, ee = V instanceof Bt, pe = Q[0], ge = ee || bt(V), we = function(Rt) {
              var qt = F.apply(P, vu([Rt], Q));
              return E && Ne ? qt[0] : qt;
            };
            ge && w && typeof pe == "function" && pe.length != 1 && (ee = ge = !1);
            var Ne = this.__chain__, He = !!this.__actions__.length, st = L && !Ne, Ot = ee && !He;
            if (!L && ge) {
              V = Ot ? V : new Bt(this);
              var at = f.apply(V, Q);
              return at.__actions__.push({ func: hv, args: [we], thisArg: r }), new ts(at, Ne);
            }
            return st && Ot ? f.apply(this, Q) : (at = this.thru(we), st ? E ? at.value()[0] : at.value() : at);
          });
        }), Zo(["pop", "push", "shift", "sort", "splice", "unshift"], function(f) {
          var m = I0[f], w = /^(?:push|sort|unshift)$/.test(f) ? "tap" : "thru", E = /^(?:pop|shift)$/.test(f);
          P.prototype[f] = function() {
            var F = arguments;
            if (E && !this.__chain__) {
              var L = this.value();
              return m.apply(bt(L) ? L : [], F);
            }
            return this[w](function(V) {
              return m.apply(bt(V) ? V : [], F);
            });
          };
        }), ca(Bt.prototype, function(f, m) {
          var w = P[m];
          if (w) {
            var E = w.name + "";
            br.call(lf, E) || (lf[E] = []), lf[E].push({ name: m, func: w });
          }
        }), lf[iv(r, b).name] = [{
          name: "wrapper",
          func: r
        }], Bt.prototype.clone = Fq, Bt.prototype.reverse = Tq, Bt.prototype.value = Mq, P.prototype.at = aV, P.prototype.chain = lV, P.prototype.commit = uV, P.prototype.next = cV, P.prototype.plant = fV, P.prototype.reverse = dV, P.prototype.toJSON = P.prototype.valueOf = P.prototype.value = pV, P.prototype.first = P.prototype.head, Op && (P.prototype[Op] = hV), P;
      }), of = uq();
      wc ? ((wc.exports = of)._ = of, sw._ = of) : Un._ = of;
    }).call(Gke);
  })(Yy, Yy.exports)), Yy.exports;
}
var S_ = Kke();
const nj = /* @__PURE__ */ D5(S_), Qke = {
  headerHeight: null,
  columnConfigs: {},
  onColumnConfigsChange: () => {
  },
  minColumnWidths: {},
  rowRenderBatchSize: 4,
  minFetchSize: 1,
  renderWindowOffset: 400,
  verticalScrollbarPillHeight: 4,
  verticalScrollbarWidth: 24,
  horizontalScrollbarHeight: 16,
  lineHeight: 20,
  textMaxLines: 3,
  betweenRowPadding: 8,
  betweenColPadding: 24,
  scrollOverflowValue: 1e6,
  // keep this below chrome's maximum translate value
  onRowClick: null,
  highlightedRows: null,
  firstColLeftPadding: 8,
  showRowNumber: !0,
  onShowRowNumberChange: () => {
  },
  highlightHoveredRow: !1,
  get rowHeight() {
    return this.textMaxLines * this.lineHeight + this.betweenRowPadding;
  },
  DEFAULT_TEXT_MAX_LINES: 3,
  DEFAULT_LINE_HEIGHT: 20,
  DEFAULT_ROW_NUMBER_COL_WIDTH: 60
};
class Xke {
  #e = /* @__PURE__ */ Ue(li(Qke));
  get config() {
    return j(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const WO = Symbol("config");
class xr {
  static initialize() {
    cs(WO, new Xke());
  }
  static get config() {
    const e = Qi(WO);
    if (e == null)
      throw new Error("config context not yet set");
    return e.config;
  }
}
class Jke {
  tableModel;
  tableController;
  margin = 2;
  isDragging = !1;
  lastDragX = 0;
  #e = /* @__PURE__ */ Ue(0);
  get elementWidth() {
    return j(this.#e);
  }
  set elementWidth(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ Se(() => this.elementWidth - this.margin * 2);
  get scrollbarWidth() {
    return j(this.#t);
  }
  set scrollbarWidth(e) {
    be(this.#t, e);
  }
  #r = /* @__PURE__ */ Se(() => this.tableController.viewWidth / this.tableModel.colsRightmostPosition * this.scrollbarWidth);
  get pillWidth() {
    return j(this.#r);
  }
  set pillWidth(e) {
    be(this.#r, e);
  }
  #n = /* @__PURE__ */ Se(() => -this.tableController.xScroll / this.tableModel.colsRightmostPosition * this.scrollbarWidth);
  get pillLeft() {
    return j(this.#n);
  }
  set pillLeft(e) {
    be(this.#n, e);
  }
  constructor({ tableModel: e, tableController: r }) {
    this.tableModel = e, this.tableController = r;
  }
  handlePointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0, this.lastDragX = e.offsetX;
  };
  handlePointerMove = (e) => {
    this.isDragging && this.lastDragX !== null && this.tableController.scroll({ deltaX: e.offsetX - this.lastDragX, deltaY: 0 });
  };
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.lastDragX = null;
  };
}
const GO = Symbol("mosaic-coordinator");
class A_ {
  static get coordinator() {
    return Qi(GO) ?? _F();
  }
  static set coordinator(e) {
    cs(GO, e);
  }
}
const Wi = "__oid", Yke = 120;
class Zke {
  schema;
  #e = /* @__PURE__ */ Ue(li({}));
  get data() {
    return j(this.#e);
  }
  set data(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ Ue(li({}));
  get defaultColWidths() {
    return j(this.#t);
  }
  set defaultColWidths(e) {
    be(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ Ue(li([]));
  get columns() {
    return j(this.#r);
  }
  set columns(e) {
    be(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ Ue(0);
  get numRows() {
    return j(this.#n);
  }
  set numRows(e) {
    be(this.#n, e, !0);
  }
  #l = /* @__PURE__ */ Ue(0);
  get renderOffset() {
    return j(this.#l);
  }
  set renderOffset(e) {
    be(this.#l, e, !0);
  }
  #a = /* @__PURE__ */ Ue(li({}));
  get rowHeightAddition() {
    return j(this.#a);
  }
  set rowHeightAddition(e) {
    be(this.#a, e, !0);
  }
  #i = /* @__PURE__ */ Se(() => this.columns.reduce(
    (e, r) => (xr.config.columnConfigs[r]?.hidden && e.add(r), r === Wi && xr.config.showRowNumber === !1 && e.add(Wi), e),
    /* @__PURE__ */ new Set()
  ));
  get hiddenColumns() {
    return j(this.#i);
  }
  set hiddenColumns(e) {
    be(this.#i, e);
  }
  rowKeyColumn = null;
  constructor(e) {
    this.schema = e;
  }
  #o = /* @__PURE__ */ Se(() => Object.keys(this.data).sort((e, r) => this.data[e][Wi] - this.data[r][Wi]));
  get renderableRows() {
    return j(this.#o);
  }
  set renderableRows(e) {
    be(this.#o, e);
  }
  #s = /* @__PURE__ */ Se(() => this.columns.filter((e) => !this.hiddenColumns.has(e)));
  get renderableCols() {
    return j(this.#s);
  }
  set renderableCols(e) {
    be(this.#s, e);
  }
  #u = /* @__PURE__ */ Se(() => this.renderableRows.length === 0 ? this.zeroRowPosition : Math.min(...this.renderableRows.map((e) => this.rowPositions[e])));
  get minRowPosition() {
    return j(this.#u);
  }
  set minRowPosition(e) {
    be(this.#u, e);
  }
  #c = /* @__PURE__ */ Se(() => this.renderableRows.length === 0 ? this.finalRowPosition : Math.max(...this.renderableRows.map((e) => this.rowPositions[e])));
  get maxRowPosition() {
    return j(this.#c);
  }
  set maxRowPosition(e) {
    be(this.#c, e);
  }
  #d = /* @__PURE__ */ Se(() => {
    const e = Math.min(...this.renderableRows.map((r) => this.data[r][Wi]));
    return Number.isSafeInteger(e) ? e : 0;
  });
  get minRowOID() {
    return j(this.#d);
  }
  set minRowOID(e) {
    be(this.#d, e);
  }
  #h = /* @__PURE__ */ Se(() => {
    const e = Math.max(...this.renderableRows.map((r) => this.data[r][Wi]));
    return Number.isSafeInteger(e) ? e : 0;
  });
  get maxRowOID() {
    return j(this.#h);
  }
  set maxRowOID(e) {
    be(this.#h, e);
  }
  #p = /* @__PURE__ */ Se(() => 0);
  get zeroRowPosition() {
    return j(this.#p);
  }
  set zeroRowPosition(e) {
    be(this.#p, e);
  }
  #f = /* @__PURE__ */ Se(() => (this.numRows - 1) * xr.config.rowHeight + this.rowPositionOffsets.cumulative);
  get finalRowPosition() {
    return j(this.#f);
  }
  set finalRowPosition(e) {
    be(this.#f, e);
  }
  colsLeftmostPosition = 0;
  #v = /* @__PURE__ */ Se(() => {
    const e = this.renderableCols[this.renderableCols.length - 1];
    return this.colPositions[e] + this.colWidths[e];
  });
  get colsRightmostPosition() {
    return j(this.#v);
  }
  set colsRightmostPosition(e) {
    be(this.#v, e);
  }
  #y = /* @__PURE__ */ Se(() => this.renderableRows.reduce(
    ({ offsets: e, cumulative: r }, n) => {
      e[n] = r;
      const i = this.rowHeightAddition[n] ?? 0;
      return { offsets: e, cumulative: r + i };
    },
    { offsets: {}, cumulative: 0 }
  ));
  get rowPositionOffsets() {
    return j(this.#y);
  }
  set rowPositionOffsets(e) {
    be(this.#y, e);
  }
  #b = /* @__PURE__ */ Se(() => this.renderableRows.reduce(
    (e, r) => {
      const n = (this.data[r][Wi] - 1) * xr.config.rowHeight + this.rowPositionOffsets.offsets[r];
      return e[r] = n, e;
    },
    {}
  ));
  get rowPositions() {
    return j(this.#b);
  }
  set rowPositions(e) {
    be(this.#b, e);
  }
  #x = /* @__PURE__ */ Se(() => {
    let e = 0;
    return this.columns.reduce(
      (r, n, i) => (this.hiddenColumns.has(n) || (r[n] = e, e += this.colWidths[n]), r),
      {}
    );
  });
  get colPositions() {
    return j(this.#x);
  }
  set colPositions(e) {
    be(this.#x, e);
  }
  #m = /* @__PURE__ */ Se(() => this.renderableRows.reduce(
    (e, r) => (e[r] = xr.config.rowHeight + (this.rowHeightAddition[r] ?? 0), e),
    {}
  ));
  get rowHeights() {
    return j(this.#m);
  }
  set rowHeights(e) {
    be(this.#m, e);
  }
  #g = /* @__PURE__ */ Se(() => this.columns.reduce(
    (e, r, n) => (e[r] = Math.max(xr.config.columnConfigs[r]?.width ?? this.defaultColWidths[r] ?? Yke, xr.config.minColumnWidths[r] ?? 0), this.isFirstCol(r) && (e[r] += xr.config.firstColLeftPadding), this.isLastCol(r) && (e[r] += xr.config.verticalScrollbarWidth), e),
    {}
  ));
  get colWidths() {
    return j(this.#g);
  }
  set colWidths(e) {
    be(this.#g, e);
  }
  getContent({ row: e, col: r }) {
    return this.data[e] ? this.data[e][r] : null;
  }
  getRowData(e) {
    return this.data[e] ? this.data[e] : null;
  }
  getPosition({ row: e, col: r }) {
    const n = this.colPositions[r], i = this.rowPositions[e];
    return { x: n, y: i };
  }
  getDimensions({ row: e, col: r }) {
    const n = this.colWidths[r], i = this.rowHeights[e];
    return { width: n, height: i };
  }
  getRowParity(e) {
    return this.data[e] && this.data[e][Wi] % 2 === 0 ? "even" : "odd";
  }
  isFirstCol(e) {
    return this.renderableCols.indexOf(e) === 0;
  }
  isLastCol(e) {
    return this.renderableCols.indexOf(e) === this.renderableCols.length - 1;
  }
  // Deletes the given row and returns the offset necessary to remove from scroll position.
  deleteRow(e) {
    delete this.data[e];
    const r = this.rowHeightAddition[e] ?? 0;
    return delete this.rowHeightAddition[e], r;
  }
  collapseRow(e) {
    const r = this.rowHeightAddition[e] ?? 0;
    return delete this.rowHeightAddition[e], r;
  }
  reset() {
    this.data = {}, this.rowHeightAddition = {};
  }
  teardown() {
    this.reset();
  }
}
class e3e extends O_ {
  tableName;
  onResult;
  constructor(e, r, n) {
    super(r ?? void 0), this.tableName = e, this.onResult = n;
  }
  queryResult(e) {
    const r = e.toArray()[0].count;
    return this.onResult(r), this;
  }
  query(e = []) {
    return dd.from(this.tableName).select({ count: CK() }).where(e);
  }
}
const Gi = "__oid";
class t3e extends O_ {
  tableName;
  columns;
  onResult;
  onColumnInfo;
  limit = 20;
  offset = 0;
  sort = null;
  info = null;
  columnInfo = null;
  isReady = !1;
  constructor(e, r, n, i, o) {
    super(n ?? void 0), this.tableName = e, this.columns = r, this.onResult = i, this.onColumnInfo = o;
  }
  async prepare() {
    if (this.coordinator == null)
      return;
    const e = (await yK(this.coordinator, [{ table: this.tableName, column: "*" }])).reduce((r, n) => (r[n.column] = n, r), {});
    this.columnInfo = e, this.onColumnInfo(e), this.isReady = !0;
  }
  getSelect({ includeRowNumber: e } = { includeRowNumber: !0 }) {
    const r = this.columns.reduce((n, i) => (this.columnInfo?.[i]?.sqlType === "BIGINT" ? n[i] = tD(lm(i), "TEXT") : n[i] = lm(i), n), {});
    return e || delete r[Gi], r;
  }
  queryResult(e) {
    return this.onResult(e), this;
  }
  query(e = []) {
    if (!this.isReady)
      return null;
    const r = this.columns.reduce((n, i) => (this.columnInfo?.[i]?.sqlType === "BIGINT" ? n[i] = tD(lm(i), "TEXT") : n[i] = lm(i), n), {});
    if (r[Gi] = wK(), this.sort) {
      const n = this.sort.direction === "ascending" ? this.sort.column : kK(this.sort.column);
      r[Gi] = r[Gi].orderby(n);
    }
    return dd.from(this.tableName).select(r).where(e).limit(this.limit).offset(this.offset);
  }
  fetchRows(e, r) {
    this.offset = e, this.limit = r, this.requestUpdate();
  }
}
class r3e {
  model;
  schema;
  config;
  #e = /* @__PURE__ */ Se(() => A_.coordinator);
  get coordinator() {
    return j(this.#e);
  }
  set coordinator(e) {
    be(this.#e, e);
  }
  filterBy = null;
  rowsClient = null;
  numRowsClient = null;
  rowKeyColumn = null;
  #t = /* @__PURE__ */ Ue(null);
  get element() {
    return j(this.#t);
  }
  set element(e) {
    be(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ Ue(0);
  get viewHeight() {
    return j(this.#r);
  }
  set viewHeight(e) {
    be(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ Ue(0);
  get viewWidth() {
    return j(this.#n);
  }
  set viewWidth(e) {
    be(this.#n, e, !0);
  }
  #l = /* @__PURE__ */ Ue(0);
  get yScroll() {
    return j(this.#l);
  }
  set yScroll(e) {
    be(this.#l, e, !0);
  }
  #a = /* @__PURE__ */ Ue(0);
  get xScroll() {
    return j(this.#a);
  }
  set xScroll(e) {
    be(this.#a, e, !0);
  }
  #i = /* @__PURE__ */ Ue(!1);
  get isFetching() {
    return j(this.#i);
  }
  set isFetching(e) {
    be(this.#i, e, !0);
  }
  #o = /* @__PURE__ */ Ue(!1);
  get isJumping() {
    return j(this.#o);
  }
  set isJumping(e) {
    be(this.#o, e, !0);
  }
  #s = /* @__PURE__ */ Ue(null);
  get sort() {
    return j(this.#s);
  }
  set sort(e) {
    be(this.#s, e, !0);
  }
  #u = /* @__PURE__ */ Ue(!1);
  get isReady() {
    return j(this.#u);
  }
  set isReady(e) {
    be(this.#u, e, !0);
  }
  #c = /* @__PURE__ */ Ue(0);
  get updateKey() {
    return j(this.#c);
  }
  set updateKey(e) {
    be(this.#c, e, !0);
  }
  #d = /* @__PURE__ */ Ue(!1);
  get isStale() {
    return j(this.#d);
  }
  set isStale(e) {
    be(this.#d, e, !0);
  }
  #h = /* @__PURE__ */ Ue(null);
  get flashedRowId() {
    return j(this.#h);
  }
  set flashedRowId(e) {
    be(this.#h, e, !0);
  }
  #p = /* @__PURE__ */ Ue(null);
  get hoveredRowId() {
    return j(this.#p);
  }
  set hoveredRowId(e) {
    be(this.#p, e, !0);
  }
  #f = /* @__PURE__ */ Se(() => Math.ceil(this.viewHeight / xr.config.rowHeight));
  get rowsOnScreen() {
    return j(this.#f);
  }
  set rowsOnScreen(e) {
    be(this.#f, e);
  }
  #v = /* @__PURE__ */ Se(() => this.isJumping ? 0 : xr.config.renderWindowOffset);
  get renderWindowOffset() {
    return j(this.#v);
  }
  set renderWindowOffset(e) {
    be(this.#v, e);
  }
  #y = /* @__PURE__ */ Se(() => {
    if (this.model.renderableRows.length === 0)
      return null;
    const e = this.model.renderableRows.filter((n) => {
      const i = this.model.rowPositions[n] + this.yScroll;
      return i + this.model.rowHeights[n] > 0 && i < this.viewHeight;
    });
    if (e.length === 0)
      return null;
    const r = e[0];
    return this.model.data[r][Gi];
  });
  get firstVisibleRowOID() {
    return j(this.#y);
  }
  set firstVisibleRowOID(e) {
    be(this.#y, e);
  }
  #b = /* @__PURE__ */ Se(() => Math.max(0, Math.floor(-this.yScroll / xr.config.rowHeight)));
  get offset() {
    return j(this.#b);
  }
  set offset(e) {
    be(this.#b, e);
  }
  onFetchResolveBegin = null;
  onFetchResolveEnd = null;
  constructor(e, r) {
    this.model = e, this.schema = r, this.config = xr.config;
  }
  handleFilterBy = () => {
    this.rowsClient && (this.rowsClient.offset = 0, this.rowsClient.limit = this.rowsOnScreen, this.isJumping = !0, this.markStale());
  };
  updateData = (e) => {
    if (!this.model || !this.rowKeyColumn)
      return;
    this.onFetchResolveBegin && (this.onFetchResolveBegin(), this.onFetchResolveBegin = null);
    const r = e.toArray(), n = {};
    for (const i of r) {
      const o = i[this.rowKeyColumn];
      n[o] = i;
    }
    this.model.data = { ...this.model.data, ...n }, this.onFetchResolveEnd && (this.onFetchResolveEnd(), this.onFetchResolveEnd = null), this.isFetching = !1;
  };
  initialize({ tableName: e, rowKey: r, columns: n, filterBy: i }) {
    if (this.model.columns = n, this.model.rowKeyColumn = r, this.rowKeyColumn = r, i && (this.filterBy = i, this.filterBy.addEventListener("value", this.handleFilterBy)), !this.rowKeyColumn)
      throw new Error("rowkey cannot be null");
    let o = n.includes(this.rowKeyColumn) ? n : [...n, this.rowKeyColumn];
    this.rowsClient = new t3e(
      e,
      o,
      i,
      (s) => {
        this.updateData(s);
      },
      (s) => {
        this.schema.columnInfo = s, this.computeColWidths(e, n), this.isReady = !0;
      }
    ), this.coordinator.connect(this.rowsClient), this.numRowsClient = new e3e(e, i, (s) => {
      this.model && (this.model.numRows = s);
    }), this.coordinator.connect(this.numRowsClient), Kr(() => {
      if (!this.rowsClient || this.isFetching || !this.isReady)
        return;
      const s = -this.renderWindowOffset, a = this.viewHeight + this.renderWindowOffset, l = this.model.maxRowPosition + this.yScroll + this.config.rowHeight, u = this.model.minRowPosition + this.yScroll;
      if (u < 0 && l < 0 || u > this.viewHeight && l > this.viewHeight) {
        const v = this.rowsOnScreen;
        this.isFetching = !0, this.rowsClient.fetchRows(this.offset, v);
      } else {
        if (l < a) {
          const y = S_.clamp(Math.ceil((a - l) / this.config.rowHeight), this.config.minFetchSize, this.rowsOnScreen);
          y > 0 && this.model.maxRowOID !== this.model.numRows && (this.isFetching = !0, this.rowsClient.fetchRows(this.model.maxRowOID, y));
        }
        const v = this.model.minRowPosition + this.yScroll;
        if (v > s && this.model.minRowOID !== 1) {
          const y = S_.clamp(Math.ceil((v - s) / this.config.rowHeight), this.config.minFetchSize, this.rowsOnScreen);
          y > 0 && (this.isFetching = !0, this.rowsClient.fetchRows(Math.max(0, this.model.minRowOID - 1 - y), y));
        }
      }
      const c = bz(this.model.renderableRows);
      let h = 0;
      for (; this.model.rowPositions[c[h]] + this.yScroll + this.model.rowHeights[c[h]] < 0; )
        this.yScroll += this.model.collapseRow(c[h]), h += 1;
      let d = c.length - 1;
      for (; this.model.rowPositions[c[d]] + this.yScroll > this.viewHeight; )
        this.model.collapseRow(c[d]), d -= 1;
      let p = 0;
      for (; this.model.rowPositions[c[p]] + this.yScroll + this.model.rowHeights[c[p]] < s; )
        this.model.deleteRow(c[p]), p += 1;
      let g = c.length - 1;
      for (; this.model.rowPositions[c[g]] + this.yScroll > a; )
        this.model.deleteRow(c[g]), g -= 1;
    });
  }
  teardown() {
    this.filterBy && this.filterBy.removeEventListener("value", this.handleFilterBy);
  }
  cellIsVisible(e) {
    const { x: r, y: n } = this.model.getPosition(e), { width: i, height: o } = this.model.getDimensions(e), s = r + this.xScroll, a = n + this.yScroll;
    return s + i >= 0 && s <= this.viewWidth && a + o >= 0 && a <= this.viewHeight;
  }
  rowIsVisible(e) {
    const r = this.model.rowPositions[e], n = this.model.rowHeights[e], i = r + this.yScroll;
    return i + n >= 0 && i <= this.viewHeight;
  }
  rowStillExists(e) {
    return this.model.data[e] != null;
  }
  colIsVisible(e) {
    const r = this.model.colPositions[e], n = this.model.colWidths[e], i = r + this.xScroll;
    return i + n >= 0 && i <= this.viewWidth;
  }
  scroll({ deltaX: e, deltaY: r }) {
    if (Math.abs(r) > Math.abs(e)) {
      const n = this.yScroll - r;
      this.model.zeroRowPosition + n > 0 ? this.yScroll = -this.model.zeroRowPosition : this.model.finalRowPosition + n < 0 ? this.yScroll = -this.model.finalRowPosition : this.yScroll = n;
    } else {
      const n = this.xScroll - e;
      -n < 0 ? this.xScroll = 0 : -n > Math.max(this.model.colsRightmostPosition, this.viewWidth) - this.viewWidth ? this.xScroll = -Math.max(this.model.colsRightmostPosition, this.viewWidth) + this.viewWidth : this.xScroll = n;
    }
  }
  handleWheel = (e) => {
    e.preventDefault(), this.isJumping = !1, this.scroll({ deltaX: e.deltaX, deltaY: e.deltaY });
  };
  jumpToOffset(e) {
    if (!this.rowsClient)
      return;
    this.isFetching = !0;
    const r = this.rowsOnScreen, n = this.onFetchResolveEnd;
    this.onFetchResolveEnd = () => {
      n && n(), this.yScroll = -(e * this.config.rowHeight);
    }, this.markStale(), this.rowsClient.fetchRows(e, r);
  }
  handleSort = (e) => {
    this.rowsClient && (this.sort = e, this.rowsClient.sort = e, this.resetRows());
  };
  resetRows() {
    this.model.reset(), this.yScroll = 0;
  }
  flashRow(e) {
    this.flashedRowId = e, setTimeout(
      () => {
        this.flashedRowId = null;
      },
      400
    );
  }
  async scrollToRow(e, r = !0) {
    if (!this.rowsClient)
      return;
    this.isFetching = !0;
    const n = dd.with({
      original: this.rowsClient.query(this.rowsClient.filterBy?.predicate(this.rowsClient)).offset(0).limit(this.model.numRows)
    }).select([Gi]).from("original").where(bK(lm(this.rowKeyColumn), xK(e))), i = (await this.coordinator.query(n)).toArray();
    if (i.length > 0) {
      const o = i[0][Gi] - 1;
      this.onFetchResolveEnd = () => {
        r && this.flashRow(e);
      }, this.jumpToOffset(o);
    } else
      this.isFetching = !1, console.error("no row", e, "found");
  }
  addHeightToRow(e, r) {
    this.model.rowHeightAddition[e] = (this.model.rowHeightAddition[e] ?? 0) + r;
  }
  hideColumn(e) {
    e === Gi ? this.config.onShowRowNumberChange ? this.config.onShowRowNumberChange(!1) : this.config.showRowNumber = !1 : (this.config.columnConfigs[e] || (this.config.columnConfigs[e] = {}), this.config.columnConfigs[e].hidden = !0);
  }
  showColumn(e) {
    e === Gi ? this.config.onShowRowNumberChange ? this.config.onShowRowNumberChange(!0) : this.config.showRowNumber = !0 : (this.config.columnConfigs[e] || (this.config.columnConfigs[e] = {}), this.config.columnConfigs[e].hidden = !1);
  }
  // Marks the current state stale, telling the view to destroy any existing cells on next render.
  markStale() {
    this.isStale = !0;
    const e = this.onFetchResolveBegin;
    this.onFetchResolveBegin = () => {
      e && e(), this.resetRows();
    };
    const r = this.onFetchResolveEnd;
    this.onFetchResolveEnd = () => {
      r && r(), this.updateKey += 1, this.isStale = !1;
    };
  }
  async computeColWidths(e, r) {
    const n = r.filter((l) => l !== Gi), i = this.rowsClient?.getSelect({ includeRowNumber: !1 }), o = n.reduce(
      (l, u) => (l[u] = 0, l),
      {}
    ), s = dd.from(e).select(i).offset(0).limit(10), a = (await this.coordinator.query(s)).toArray();
    for (const l of a)
      for (const u of n)
        o[u] = Math.max(o[u], n3e(l[u]));
    r.includes(Gi) && (o[Gi] = this.config.DEFAULT_ROW_NUMBER_COL_WIDTH), this.model.defaultColWidths = o;
  }
}
function n3e(t) {
  const e = String(t).length;
  return e > 200 ? 600 : e > 100 ? 300 : e > 20 ? 200 : e > 10 ? 150 : 120;
}
class i3e {
  tableController;
  #e = /* @__PURE__ */ Se(() => this.tableController.element);
  get tableElement() {
    return j(this.#e);
  }
  set tableElement(e) {
    be(this.#e, e);
  }
  constructor(e) {
    this.tableController = e;
  }
  mount(e, r, n, i, o) {
    if (!this.tableElement)
      return;
    const s = r.getBoundingClientRect(), a = this.tableElement.getBoundingClientRect(), l = a.top, u = a.left;
    switch (n) {
      case "inside":
        switch (o) {
          case "top":
            e.style.top = s.top - l + "px";
            break;
          case "middle":
          case "bottom":
            throw new Error("not yet implemented" + n + o);
        }
        switch (i) {
          case "left":
            e.style.left = s.left - u + "px";
          case "center":
          case "right":
            throw new Error("not yet implemented" + n + i);
        }
        break;
      case "outside":
        switch (o) {
          case "top":
            e.style.top = s.bottom - l + "px";
            break;
          case "middle":
          case "bottom":
            throw new Error("not yet implemented" + n + o);
        }
        switch (i) {
          case "left":
            e.style.left = s.left - u + "px";
            break;
          case "center":
          case "right":
            throw new Error("not yet implemented" + n + i);
        }
        break;
    }
    this.tableElement.appendChild(e);
  }
  destroy(e) {
    this.tableElement && this.tableElement.contains(e) && this.tableElement.removeChild(e);
  }
}
var zk, KO;
function o3e() {
  if (KO) return zk;
  KO = 1;
  function t(e, r, n) {
    return e === e && (n !== void 0 && (e = e <= n ? e : n), r !== void 0 && (e = e >= r ? e : r)), e;
  }
  return zk = t, zk;
}
var jk, QO;
function s3e() {
  if (QO) return jk;
  QO = 1;
  var t = /\s/;
  function e(r) {
    for (var n = r.length; n-- && t.test(r.charAt(n)); )
      ;
    return n;
  }
  return jk = e, jk;
}
var qk, XO;
function a3e() {
  if (XO) return qk;
  XO = 1;
  var t = s3e(), e = /^\s+/;
  function r(n) {
    return n && n.slice(0, t(n) + 1).replace(e, "");
  }
  return qk = r, qk;
}
var Uk, JO;
function O5() {
  if (JO) return Uk;
  JO = 1;
  function t(e) {
    var r = typeof e;
    return e != null && (r == "object" || r == "function");
  }
  return Uk = t, Uk;
}
var Hk, YO;
function l3e() {
  if (YO) return Hk;
  YO = 1;
  var t = typeof Lu == "object" && Lu && Lu.Object === Object && Lu;
  return Hk = t, Hk;
}
var Vk, ZO;
function ij() {
  if (ZO) return Vk;
  ZO = 1;
  var t = l3e(), e = typeof self == "object" && self && self.Object === Object && self, r = t || e || Function("return this")();
  return Vk = r, Vk;
}
var Wk, eF;
function oj() {
  if (eF) return Wk;
  eF = 1;
  var t = ij(), e = t.Symbol;
  return Wk = e, Wk;
}
var Gk, tF;
function u3e() {
  if (tF) return Gk;
  tF = 1;
  var t = oj(), e = Object.prototype, r = e.hasOwnProperty, n = e.toString, i = t ? t.toStringTag : void 0;
  function o(s) {
    var a = r.call(s, i), l = s[i];
    try {
      s[i] = void 0;
      var u = !0;
    } catch {
    }
    var c = n.call(s);
    return u && (a ? s[i] = l : delete s[i]), c;
  }
  return Gk = o, Gk;
}
var Kk, rF;
function c3e() {
  if (rF) return Kk;
  rF = 1;
  var t = Object.prototype, e = t.toString;
  function r(n) {
    return e.call(n);
  }
  return Kk = r, Kk;
}
var Qk, nF;
function h3e() {
  if (nF) return Qk;
  nF = 1;
  var t = oj(), e = u3e(), r = c3e(), n = "[object Null]", i = "[object Undefined]", o = t ? t.toStringTag : void 0;
  function s(a) {
    return a == null ? a === void 0 ? i : n : o && o in Object(a) ? e(a) : r(a);
  }
  return Qk = s, Qk;
}
var Xk, iF;
function f3e() {
  if (iF) return Xk;
  iF = 1;
  function t(e) {
    return e != null && typeof e == "object";
  }
  return Xk = t, Xk;
}
var Jk, oF;
function d3e() {
  if (oF) return Jk;
  oF = 1;
  var t = h3e(), e = f3e(), r = "[object Symbol]";
  function n(i) {
    return typeof i == "symbol" || e(i) && t(i) == r;
  }
  return Jk = n, Jk;
}
var Yk, sF;
function sj() {
  if (sF) return Yk;
  sF = 1;
  var t = a3e(), e = O5(), r = d3e(), n = NaN, i = /^[-+]0x[0-9a-f]+$/i, o = /^0b[01]+$/i, s = /^0o[0-7]+$/i, a = parseInt;
  function l(u) {
    if (typeof u == "number")
      return u;
    if (r(u))
      return n;
    if (e(u)) {
      var c = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(c) ? c + "" : c;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = t(u);
    var h = o.test(u);
    return h || s.test(u) ? a(u.slice(2), h ? 2 : 8) : i.test(u) ? n : +u;
  }
  return Yk = l, Yk;
}
var Zk, aF;
function p3e() {
  if (aF) return Zk;
  aF = 1;
  var t = o3e(), e = sj();
  function r(n, i, o) {
    return o === void 0 && (o = i, i = void 0), o !== void 0 && (o = e(o), o = o === o ? o : 0), i !== void 0 && (i = e(i), i = i === i ? i : 0), t(e(n), i, o);
  }
  return Zk = r, Zk;
}
var m3e = p3e();
const g3e = /* @__PURE__ */ D5(m3e);
var e3, lF;
function v3e() {
  if (lF) return e3;
  lF = 1;
  var t = ij(), e = function() {
    return t.Date.now();
  };
  return e3 = e, e3;
}
var t3, uF;
function y3e() {
  if (uF) return t3;
  uF = 1;
  var t = O5(), e = v3e(), r = sj(), n = "Expected a function", i = Math.max, o = Math.min;
  function s(a, l, u) {
    var c, h, d, p, g, v, y = 0, b = !1, k = !1, C = !0;
    if (typeof a != "function")
      throw new TypeError(n);
    l = r(l) || 0, t(u) && (b = !!u.leading, k = "maxWait" in u, d = k ? i(r(u.maxWait) || 0, l) : d, C = "trailing" in u ? !!u.trailing : C);
    function S(I) {
      var B = c, $ = h;
      return c = h = void 0, y = I, p = a.apply($, B), p;
    }
    function _(I) {
      return y = I, g = setTimeout(O, l), b ? S(I) : p;
    }
    function D(I) {
      var B = I - v, $ = I - y, q = l - B;
      return k ? o(q, d - $) : q;
    }
    function A(I) {
      var B = I - v, $ = I - y;
      return v === void 0 || B >= l || B < 0 || k && $ >= d;
    }
    function O() {
      var I = e();
      if (A(I))
        return M(I);
      g = setTimeout(O, D(I));
    }
    function M(I) {
      return g = void 0, C && c ? S(I) : (c = h = void 0, p);
    }
    function z() {
      g !== void 0 && clearTimeout(g), y = 0, c = v = h = g = void 0;
    }
    function R() {
      return g === void 0 ? p : M(e());
    }
    function N() {
      var I = e(), B = A(I);
      if (c = arguments, h = this, v = I, B) {
        if (g === void 0)
          return _(v);
        if (k)
          return clearTimeout(g), g = setTimeout(O, l), S(v);
      }
      return g === void 0 && (g = setTimeout(O, l)), p;
    }
    return N.cancel = z, N.flush = R, N;
  }
  return t3 = s, t3;
}
var r3, cF;
function b3e() {
  if (cF) return r3;
  cF = 1;
  var t = y3e(), e = O5(), r = "Expected a function";
  function n(i, o, s) {
    var a = !0, l = !0;
    if (typeof i != "function")
      throw new TypeError(r);
    return e(s) && (a = "leading" in s ? !!s.leading : a, l = "trailing" in s ? !!s.trailing : l), t(i, o, {
      leading: a,
      maxWait: o,
      trailing: l
    });
  }
  return r3 = n, r3;
}
var x3e = b3e();
const hF = /* @__PURE__ */ D5(x3e);
class w3e {
  tableModel;
  tableController;
  isDragging = !1;
  #e = /* @__PURE__ */ Ue(0);
  get elementHeight() {
    return j(this.#e);
  }
  set elementHeight(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ Ue(0);
  get labelHeight() {
    return j(this.#t);
  }
  set labelHeight(e) {
    be(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ Se(() => xr.config.verticalScrollbarPillHeight);
  get pillHeight() {
    return j(this.#r);
  }
  set pillHeight(e) {
    be(this.#r, e);
  }
  #n = /* @__PURE__ */ Se(() => this.elementHeight - this.pillHeight);
  get scrollbarHeight() {
    return j(this.#n);
  }
  set scrollbarHeight(e) {
    be(this.#n, e);
  }
  #l = /* @__PURE__ */ Se(() => this.tableController.firstVisibleRowOID ? this.tableController.firstVisibleRowOID : this.tableController.offset + 1);
  get displayRow() {
    return j(this.#l);
  }
  set displayRow(e) {
    be(this.#l, e);
  }
  #a = /* @__PURE__ */ Se(() => (this.displayRow - 1) / (this.tableModel.numRows - 1) * this.scrollbarHeight);
  get pillPosition() {
    return j(this.#a);
  }
  set pillPosition(e) {
    be(this.#a, e);
  }
  #i = /* @__PURE__ */ Se(() => {
    if (this.pillPosition === null)
      return 0;
    const e = this.pillPosition + this.pillHeight / 2 - this.labelHeight / 2;
    if (e < 0)
      return e;
    const r = this.pillPosition + this.pillHeight / 2 + this.labelHeight / 2;
    return r > this.elementHeight ? r - this.elementHeight : 0;
  });
  get labelOffset() {
    return j(this.#i);
  }
  set labelOffset(e) {
    be(this.#i, e);
  }
  constructor({ tableModel: e, tableController: r }) {
    this.tableModel = e, this.tableController = r;
  }
  computeOffsetFromPointer = (e) => {
    this.isDragging = !0;
    let r = Math.round(e.offsetY / this.scrollbarHeight * (this.tableModel.numRows - 1));
    return g3e(r, 0, this.tableModel.numRows - 1);
  };
  pointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0;
    const r = this.computeOffsetFromPointer(e);
    this.tableController.isJumping = !0, this.tableController.jumpToOffset(r);
  };
  handlePointerDown = hF(this.pointerDown, 50);
  pointerMove = (e) => {
    if (this.isDragging) {
      const r = this.computeOffsetFromPointer(e);
      this.tableController.jumpToOffset(r);
    }
  };
  handlePointerMove = hF(this.pointerMove, 50);
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.tableController.isJumping = !1;
  };
}
class k3e {
  #e = /* @__PURE__ */ Ue(null);
  get columnInfo() {
    return j(this.#e);
  }
  set columnInfo(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ Se(() => this.columnInfo ? Object.keys(this.columnInfo).reduce(
    (e, r) => (e[r] = this.columnInfo[r].type, e),
    {}
  ) : {});
  get dataType() {
    return j(this.#t);
  }
  set dataType(e) {
    be(this.#t, e);
  }
  #r = /* @__PURE__ */ Se(() => this.columnInfo ? Object.keys(this.columnInfo).reduce(
    (e, r) => (e[r] = this.columnInfo[r].sqlType, e),
    {}
  ) : {});
  get sqlType() {
    return j(this.#r);
  }
  set sqlType(e) {
    be(this.#r, e);
  }
}
class C3e {
  tableController;
  #e = /* @__PURE__ */ Se(() => Math.floor(-this.tableController.yScroll / xr.config.scrollOverflowValue) * xr.config.scrollOverflowValue);
  get offset() {
    return j(this.#e);
  }
  set offset(e) {
    be(this.#e, e);
  }
  constructor(e) {
    this.tableController = e;
  }
  y(e) {
    return e - this.offset;
  }
  yScroll(e) {
    return e + this.offset;
  }
}
const fF = Symbol("schema"), dF = Symbol("model"), pF = Symbol("controller"), mF = Symbol("vertical-scrollbar-controller"), gF = Symbol("horizontal-scrollbar-controller"), vF = Symbol("table-portal-controller"), yF = Symbol("overscroll-modifier");
class Cr {
  static initialize() {
    const e = new k3e(), r = new Zke(e), n = new r3e(r, e), i = new w3e({ tableModel: r, tableController: n }), o = new Jke({ tableModel: r, tableController: n }), s = new i3e(n), a = new C3e(n);
    cs(fF, e), cs(dF, r), cs(pF, n), cs(mF, i), cs(gF, o), cs(vF, s), cs(yF, a);
  }
  static get schema() {
    return Qi(fF);
  }
  static get model() {
    return Qi(dF);
  }
  static get controller() {
    return Qi(pF);
  }
  static get verticalScrollbarController() {
    return Qi(mF);
  }
  static get horizontalScrollbarController() {
    return Qi(gF);
  }
  static get tablePortalController() {
    return Qi(vF);
  }
  static get overscrollModifier() {
    return Qi(yF);
  }
}
var _3e = /* @__PURE__ */ lr('<div class="horizontal-scrollbar svelte-csucem"><div class="pill svelte-csucem"></div></div>');
const S3e = {
  hash: "svelte-csucem",
  code: ".horizontal-scrollbar.svelte-csucem {position:absolute;bottom:0;left:0;width:100%;height:var(--height);transition:opacity 200ms linear;background-color:var(--scrollbar-bg);}.horizontal-scrollbar.svelte-csucem:hover {opacity:1 !important;}.pill.svelte-csucem {width:var(--width);height:calc(var(--height) - var(--margin) * 2);margin:var(--margin);border-radius:2px;background-color:var(--scrollbar-pill-bg);}"
};
function A3e(t, e) {
  on(e, !0), an(t, S3e);
  const r = Cr.horizontalScrollbarController, n = Cr.controller, i = xr.config;
  let o = /* @__PURE__ */ Ue(0), s = /* @__PURE__ */ Ue(null), a = /* @__PURE__ */ Ue(null), l = 0;
  Cp(() => (l = requestAnimationFrame(h), () => {
    cancelAnimationFrame(l);
  }));
  function u() {
    j(s) && (j(s).style.opacity = "0");
  }
  const c = nj.debounce(u, 1e3);
  Kr(() => {
    j(s) && (n.xScroll, j(s).style.opacity = "1", c());
  });
  function h() {
    be(o, r.pillWidth, !0), j(a) && (j(a).style.transform = `translate(${r.pillLeft}px, 0)`), l = requestAnimationFrame(h);
  }
  var d = _3e();
  let p;
  var g = yr(d);
  g.__pointerdown = function(...y) {
    r.handlePointerDown?.apply(this, y);
  }, g.__pointermove = function(...y) {
    r.handlePointerMove?.apply(this, y);
  }, g.__pointerup = function(...y) {
    r.handlePointerUp?.apply(this, y);
  };
  let v;
  Li(g, (y) => be(a, y), () => j(a)), fr(d), Li(d, (y) => be(s, y), () => j(s)), pn(() => {
    p = mo(d, "", p, { "--height": i.horizontalScrollbarHeight + "px" }), v = mo(g, "", v, {
      "--width": j(o) + "px",
      "--margin": r.margin + "px"
    });
  }), ra(d, "clientWidth", (y) => r.elementWidth = y), Mt(t, d), sn();
}
pu(["pointerdown", "pointermove", "pointerup"]);
var E3e = /* @__PURE__ */ lr('<div class="vertical-scrollbar svelte-d1fz7o"><div class="pill svelte-d1fz7o"><div class="label svelte-d1fz7o"> </div></div></div>');
const D3e = {
  hash: "svelte-d1fz7o",
  code: ".vertical-scrollbar.svelte-d1fz7o {position:absolute;right:0;top:0;width:var(--width);height:calc(100% - var(--offset-bottom));contain:layout;cursor:row-resize;transition:opacity 200ms linear;user-select:none;background-color:var(--scrollbar-bg);}.vertical-scrollbar.svelte-d1fz7o:hover {opacity:1 !important;}.pill.svelte-d1fz7o {--pill-height: 4px;position:relative;pointer-events:none; /* let the container respond to pointer events */top:0;left:0;width:calc(var(--width) - 2px);margin-left:1px;margin-right:1px;height:var(--pill-height);border-radius:2px;will-change:transform;background-color:var(--scrollbar-pill-bg);}.label.svelte-d1fz7o {--offset: 0;position:absolute;pointer-events:none;top:0;left:-4px;font-family:var(--font-family);font-size:14px;white-space:nowrap;padding:2px 4px;box-shadow:var(--shadow);transform:translate(-100%, calc(-50% + var(--pill-height) / 2 - var(--offset)));border-radius:2px;color:var(--secondary-text-color);background-color:var(--scrollbar-label-bg);border:var(--outline);}"
};
function O3e(t, e) {
  on(e, !0), an(t, D3e);
  const r = Cr.verticalScrollbarController, n = Cr.controller, i = xr.config;
  let o = /* @__PURE__ */ Ue(0), s = /* @__PURE__ */ Ue(0), a = /* @__PURE__ */ Ue(null), l = /* @__PURE__ */ Ue(null), u = /* @__PURE__ */ Ue(null), c = /* @__PURE__ */ Se(() => new Intl.NumberFormat().format(j(s))), h = 0;
  Cp(() => (h = requestAnimationFrame(g), () => {
    cancelAnimationFrame(h);
  }));
  function d() {
    j(a) && (j(a).style.opacity = "0");
  }
  const p = nj.debounce(d, 1e3);
  Kr(() => {
    j(a) && (n.yScroll, j(a).style.opacity = "1", p());
  });
  function g() {
    be(o, r.pillPosition ?? j(o), !0), be(s, r.displayRow ?? j(s), !0), j(l) && (j(l).style.transform = `translate3d(0, ${j(o)}px, 0)`), j(u) && j(u).style.setProperty("--offset", r.labelOffset - 1 + "px"), h = requestAnimationFrame(g);
  }
  var v = E3e();
  v.__pointerdown = function(..._) {
    r.handlePointerDown?.apply(this, _);
  }, v.__pointermove = function(..._) {
    r.handlePointerMove?.apply(this, _);
  }, v.__pointerup = function(..._) {
    r.handlePointerUp?.apply(this, _);
  };
  let y;
  var b = yr(v);
  let k;
  var C = yr(b), S = yr(C, !0);
  fr(C), Li(C, (_) => be(u, _), () => j(u)), fr(b), Li(b, (_) => be(l, _), () => j(l)), fr(v), Li(v, (_) => be(a, _), () => j(a)), pn(() => {
    y = mo(v, "", y, {
      "--offset-bottom": i.horizontalScrollbarHeight + "px",
      "--width": i.verticalScrollbarWidth + "px"
    }), k = mo(b, "", k, {
      "--pill-height": r.pillHeight + "px"
    }), dl(S, j(c));
  }), ra(C, "clientHeight", (_) => r.labelHeight = _), ra(v, "clientHeight", (_) => r.elementHeight = _), Mt(t, v), sn();
}
pu(["pointerdown", "pointermove", "pointerup"]);
var F3e = /* @__PURE__ */ lr('<div class="bigint-content svelte-1x1osq0"> </div>');
const T3e = {
  hash: "svelte-1x1osq0",
  code: ".bigint-content.svelte-1x1osq0 {text-align:right;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function M3e(t, e) {
  on(e, !0), an(t, T3e);
  let r = _p(e, "height");
  function n(s) {
    return s === null ? null : s.toLocaleString();
  }
  var i = F3e(), o = yr(i, !0);
  fr(i), pn((s) => dl(o, s), [() => n(e.bigint)]), ra(i, "clientHeight", r), Mt(t, i), sn();
}
var P3e = /* @__PURE__ */ lr("<div></div>");
const R3e = { hash: "svelte-ubqfz9", code: "" };
function N3e(t, e) {
  on(e, !0), an(t, R3e);
  let r = _p(e, "height");
  const n = Cr.model, i = (u) => typeof u == "function" ? (c, h) => {
    let d = new u(c, h);
    return {
      ...d.update ? { update: d.update.bind(d) } : {},
      ...d.destroy ? { destroy: d.destroy.bind(d) } : {}
    };
  } : (c, h) => {
    let d = new u.class(c, h);
    return {
      ...d.update ? { update: d.update.bind(d) } : {},
      ...d.destroy ? { destroy: d.destroy.bind(d) } : {}
    };
  };
  let o = /* @__PURE__ */ Se(() => i(e.customCell)), s = /* @__PURE__ */ Se(() => n.getContent({ row: e.row, col: e.col })), a = /* @__PURE__ */ Se(() => n.getRowData(e.row));
  var l = P3e();
  A5(l, (u, c) => j(o)?.(u, c), () => ({ value: j(s), rowData: j(a) })), A0(() => ra(l, "clientHeight", r)), Mt(t, l), sn();
}
var $3e = /* @__PURE__ */ lr('<img alt=""/>');
function I3e(t, e) {
  on(e, !0);
  let r = _p(e, "height");
  xr.config;
  let n = /* @__PURE__ */ Ue(null);
  function i(c) {
    let h = "";
    for (let d = 0; d < c.length; d++)
      h += String.fromCharCode(c[d]);
    return btoa(h);
  }
  function o(c) {
    const h = atob(c);
    return new Uint8Array([...h].map((d) => d.charCodeAt(0)));
  }
  function s(c, h) {
    if (c.length < h.length)
      return !1;
    for (let d = 0; d < h.length; d++)
      if (c[d] != h[d])
        return !1;
    return !0;
  }
  function a(c) {
    return s(c, [137, 80, 78, 71, 13, 10, 26, 10]) ? "image/png" : s(c, [255, 216, 255]) ? "image/jpeg" : s(c, [73, 73, 42, 0]) ? "image/tiff" : s(c, [66, 77]) ? "image/bmp" : s(c, [71, 73, 70, 56, 55, 97]) || s(c, [71, 73, 70, 56, 55, 97]) ? "image/gif" : "application/octet-stream";
  }
  function l(c) {
    if (c == null)
      return null;
    if (typeof c == "string")
      return c.startsWith("data:") ? c : `data:${a(o(c))};base64,` + c;
    {
      let h = null;
      if (c.bytes && c.bytes instanceof Uint8Array && (h = c.bytes), c instanceof Uint8Array && (h = c), h != null)
        return `data:${a(h)};base64,` + i(h);
    }
    return null;
  }
  var u = $3e();
  Li(u, (c) => be(n, c), () => j(n)), pn((c) => Hg(u, "src", c), [() => l(e.image)]), Vd("load", u, () => {
    j(n) && r(j(n).scrollHeight);
  }), kke(u), Mt(t, u), sn();
}
var B3e = /* @__PURE__ */ lr('<a target="_blank"> </a>'), L3e = /* @__PURE__ */ lr('<div class="link-content"><!></div>');
const z3e = { hash: "svelte-1wimtwv", code: "" };
function j3e(t, e) {
  on(e, !0), an(t, z3e);
  let r = _p(e, "height");
  var n = L3e(), i = yr(n);
  {
    var o = (s) => {
      var a = B3e(), l = yr(a, !0);
      fr(a), pn(() => {
        Hg(a, "href", e.url), dl(l, e.url);
      }), Mt(s, a);
    };
    Xi(i, (s) => {
      e.url && s(o);
    });
  }
  fr(n), ra(n, "clientHeight", r), Mt(t, n), sn();
}
var q3e = /* @__PURE__ */ lr('<div class="number-content svelte-1xfvszy"> </div>');
const U3e = {
  hash: "svelte-1xfvszy",
  code: ".number-content.svelte-1xfvszy {text-align:right;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function H3e(t, e) {
  on(e, !0), an(t, U3e);
  let r = _p(e, "height");
  function n(s) {
    return s === null ? null : Number.isInteger(s) ? s.toString() : s.toPrecision(4).toString();
  }
  var i = q3e(), o = yr(i, !0);
  fr(i), pn((s) => dl(o, s), [() => n(e.number)]), ra(i, "clientHeight", r), Mt(t, i), sn();
}
var V3e = /* @__PURE__ */ lr("<div> </div>");
const W3e = {
  hash: "svelte-1ngffx0",
  code: ".clamped.svelte-1ngffx0 {display:-webkit-box;-webkit-box-orient:vertical;line-clamp:var(--lines, var(--num-lines)); /* fallback to numlines from parent */-webkit-line-clamp:var(--lines, var(--num-lines));overflow:hidden;text-overflow:ellipsis;}"
};
function bF(t, e) {
  on(e, !0), an(t, W3e);
  let r = _p(e, "height");
  const n = xr.config;
  let i = /* @__PURE__ */ Ue(null), o = /* @__PURE__ */ Ue(null);
  Kr(() => {
    j(i) && (r(j(i).scrollHeight), be(o, Math.floor(e.parentHeight / n.lineHeight), !0));
  });
  var s = V3e();
  let a;
  var l = yr(s, !0);
  fr(s), Li(s, (u) => be(i, u), () => j(i)), pn(() => {
    fc(s, 1, `text-content ${(e.clamped ? "clamped" : null) ?? ""}`, "svelte-1ngffx0"), a = mo(s, "", a, { "--lines": j(o) }), dl(l, e.text);
  }), Mt(t, s), sn();
}
class G3e {
  #e = /* @__PURE__ */ Ue(li({}));
  get config() {
    return j(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const n3 = Symbol("custom-cells");
class Zy {
  static initialize() {
    cs(n3, new G3e());
  }
  static set config(e) {
    const r = Qi(n3);
    r.config = e;
  }
  static get config() {
    return Qi(n3).config;
  }
}
var K3e = /* @__PURE__ */ lr("<button>â†˜</button>"), Q3e = /* @__PURE__ */ lr('<div class="cell-content clamp svelte-8bpcsh"><!> <!></div>');
const X3e = {
  hash: "svelte-8bpcsh",
  code: ".cell-content.svelte-8bpcsh {position:relative;flex-grow:1;line-height:var(--lineHeight);overflow-wrap:anywhere;overflow:hidden;}.expand-button.svelte-8bpcsh {all:unset;visibility:hidden;position:absolute;bottom:0;right:0;cursor:pointer;font-size:12px;line-height:18px;padding-left:4px;padding-right:4px;border-radius:2px;color:var(--secondary-text-color);background-color:var(--background-color);border:var(--outline);}.expand-button.show.svelte-8bpcsh {visibility:visible;}"
};
function J3e(t, e) {
  on(e, !0), an(t, X3e);
  const r = Cr.model, n = Cr.controller, i = Cr.schema, o = xr.config;
  let s = /* @__PURE__ */ Se(() => Zy.config), a = /* @__PURE__ */ Ue(0), l = /* @__PURE__ */ Ue(0), u = /* @__PURE__ */ Se(() => j(l) > j(a));
  const c = r.getContent({ row: e.row, col: e.col }), h = i.dataType[e.col] ?? "string", d = i.sqlType[e.col] ?? "TEXT";
  function p(D) {
    return typeof D == "string" && (D.startsWith("http://") || D.startsWith("https://"));
  }
  function g(D) {
    return D == null ? !1 : !!(typeof D == "string" && D.startsWith("data:image/") || D.bytes && D.bytes instanceof Uint8Array);
  }
  var v = Q3e();
  let y;
  var b = yr(v);
  {
    var k = (D) => {
      N3e(D, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        },
        get customCell() {
          return j(s)[e.col];
        },
        get height() {
          return j(l);
        },
        set height(A) {
          be(l, A, !0);
        }
      });
    }, C = (D) => {
      var A = zc(), O = Lo(A);
      {
        var M = (R) => {
          var N = zc(), I = Lo(N);
          {
            var B = (q) => {
              j3e(q, {
                get url() {
                  return c;
                },
                get height() {
                  return j(l);
                },
                set height(U) {
                  be(l, U, !0);
                }
              });
            }, $ = (q) => {
              bF(q, {
                get text() {
                  return c;
                },
                get clamped() {
                  return j(u);
                },
                get parentHeight() {
                  return j(a);
                },
                get height() {
                  return j(l);
                },
                set height(U) {
                  be(l, U, !0);
                }
              });
            };
            Xi(I, (q) => {
              c && p(c) ? q(B) : q($, !1);
            });
          }
          Mt(R, N);
        }, z = (R) => {
          var N = zc(), I = Lo(N);
          {
            var B = (q) => {
              var U = zc(), H = Lo(U);
              {
                var G = (ie) => {
                  {
                    let se = /* @__PURE__ */ Se(() => BigInt(c ?? ""));
                    M3e(ie, {
                      get bigint() {
                        return j(se);
                      },
                      get height() {
                        return j(l);
                      },
                      set height(ne) {
                        be(l, ne, !0);
                      }
                    });
                  }
                }, re = (ie) => {
                  H3e(ie, {
                    get number() {
                      return c;
                    },
                    get height() {
                      return j(l);
                    },
                    set height(se) {
                      be(l, se, !0);
                    }
                  });
                };
                Xi(H, (ie) => {
                  d === "BIGINT" ? ie(G) : ie(re, !1);
                });
              }
              Mt(q, U);
            }, $ = (q) => {
              var U = zc(), H = Lo(U);
              {
                var G = (ie) => {
                  I3e(ie, {
                    get image() {
                      return c;
                    },
                    get height() {
                      return j(l);
                    },
                    set height(se) {
                      be(l, se, !0);
                    }
                  });
                }, re = (ie) => {
                  bF(ie, {
                    get text() {
                      return c;
                    },
                    get clamped() {
                      return j(u);
                    },
                    get parentHeight() {
                      return j(a);
                    },
                    get height() {
                      return j(l);
                    },
                    set height(se) {
                      be(l, se, !0);
                    }
                  });
                };
                Xi(
                  H,
                  (ie) => {
                    g(c) ? ie(G) : ie(re, !1);
                  },
                  !0
                );
              }
              Mt(q, U);
            };
            Xi(
              I,
              (q) => {
                h === "number" ? q(B) : q($, !1);
              },
              !0
            );
          }
          Mt(R, N);
        };
        Xi(
          O,
          (R) => {
            h === "string" ? R(M) : R(z, !1);
          },
          !0
        );
      }
      Mt(D, A);
    };
    Xi(b, (D) => {
      j(s)[e.col] ? D(k) : D(C, !1);
    });
  }
  var S = ms(b, 2);
  {
    var _ = (D) => {
      var A = K3e();
      A.__click = () => {
        n.addHeightToRow(e.row, j(l) - j(a));
      }, pn(() => fc(A, 1, `expand-button ${e.hovered ? "show" : "hide"}`, "svelte-8bpcsh")), Mt(D, A);
    };
    Xi(S, (D) => {
      j(u) && D(_);
    });
  }
  fr(v), pn(() => y = mo(v, "", y, {
    "--lineHeight": o.lineHeight + "px",
    "--num-lines": o.textMaxLines
  })), ra(v, "clientHeight", (D) => be(a, D)), Mt(t, v), sn();
}
pu(["click"]);
var Y3e = /* @__PURE__ */ lr('<div class="row-number svelte-1e2x749"> </div>');
const Z3e = {
  hash: "svelte-1e2x749",
  code: ".row-number.svelte-1e2x749 {flex-grow:1;text-align:right;color:var(--secondary-text-color);text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function eCe(t, e) {
  on(e, !0), an(t, Z3e);
  const r = Cr.model.getContent({ row: e.row, col: e.col }), n = /* @__PURE__ */ Se(() => new Intl.NumberFormat().format(r ?? 0));
  var i = Y3e(), o = yr(i, !0);
  fr(i), pn(() => dl(o, j(n))), Mt(t, i), sn();
}
var tCe = /* @__PURE__ */ lr('<div class="cell svelte-16dgxhm"><!></div>');
const rCe = {
  hash: "svelte-16dgxhm",
  code: ".cell.svelte-16dgxhm {--x: 0px;--y: 0px;--width: 0px;--height: 0px;display:flex;box-sizing:border-box;padding-top:calc(var(--padding-y) / 2);padding-bottom:calc(var(--padding-y) / 2);padding-right:calc(calc(var(--padding-x) / 2) + var(--extra-right-padding));padding-left:calc(calc(var(--padding-x) / 2) + var(--extra-left-padding));position:absolute;left:0;top:0;width:var(--width);height:var(--height);transform:translate(var(--x), var(--y));contain:layout paint;color:var(--primary-text-color);font-family:var(--cell-font-family);font-size:var(--cell-font-size);}"
};
function nCe(t, e) {
  on(e, !0), an(t, rCe);
  const r = Cr.model, n = Cr.controller, i = Cr.overscrollModifier, o = xr.config;
  let s = /* @__PURE__ */ Se(() => r.getPosition({ row: e.row, col: e.col })), a = /* @__PURE__ */ Se(() => j(s).x), l = /* @__PURE__ */ Se(() => j(s).y), u = /* @__PURE__ */ Se(() => i.y(j(l))), c = /* @__PURE__ */ Se(() => r.getDimensions({ row: e.row, col: e.col })), h = /* @__PURE__ */ Se(() => j(c).width), d = /* @__PURE__ */ Se(() => j(c).height), p = /* @__PURE__ */ Se(() => r.isFirstCol(e.col)), g = /* @__PURE__ */ Se(() => r.isLastCol(e.col)), v = /* @__PURE__ */ Se(() => r.getRowParity(e.row) === "even" ? "var(--primary-bg)" : "var(--secondary-bg)"), y = () => {
    o.onRowClick && o.onRowClick(e.row);
  }, b = /* @__PURE__ */ Ue(!1);
  var k = tCe();
  k.__click = y, k.__keydown = (A) => {
    A.key === "Enter" && y();
  };
  let C;
  var S = yr(k);
  {
    var _ = (A) => {
      J3e(A, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        },
        get hovered() {
          return j(b);
        }
      });
    }, D = (A) => {
      eCe(A, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        }
      });
    };
    Xi(S, (A) => {
      e.col !== Wi ? A(_) : A(D, !1);
    });
  }
  fr(k), pn(() => C = mo(k, "", C, {
    "--x": j(a) + "px",
    "--y": j(u) + "px",
    "--width": j(h) + "px",
    "--height": j(d) + "px",
    "--padding-x": o.betweenColPadding + "px",
    "--padding-y": o.betweenRowPadding + "px",
    "--extra-right-padding": (j(g) ? o.verticalScrollbarWidth : 0) + "px",
    "--extra-left-padding": (j(p) ? o.firstColLeftPadding : 0) + "px",
    "--background-color": j(v)
  })), Vd("pointerenter", k, () => {
    be(b, !0), n.hoveredRowId = e.row;
  }), Vd("pointerleave", k, () => {
    be(b, !1), n.hoveredRowId = null;
  }), Mt(t, k), sn();
}
pu(["click", "keydown"]);
var iCe = /* @__PURE__ */ lr('<div class="header-title svelte-1si5830"> </div>');
const oCe = {
  hash: "svelte-1si5830",
  code: ".header-title.svelte-1si5830 {flex-shrink:1;margin-right:2px;}"
};
function sCe(t, e) {
  on(e, !0), an(t, oCe);
  const r = xr.config;
  var n = iCe(), i = yr(n, !0);
  fr(n), pn(() => dl(i, r.columnConfigs[e.col]?.title ?? e.col)), Mt(t, n), sn();
}
U2e();
var aCe = /* @__PURE__ */ lr('<div class="row-number-header svelte-v1uha2">#</div>');
const lCe = {
  hash: "svelte-v1uha2",
  code: ".row-number-header.svelte-v1uha2 {flex-grow:1;text-align:right;margin-right:4px;box-sizing:border-box;color:var(--secondary-text-color);}"
};
function uCe(t) {
  an(t, lCe);
  var e = aCe();
  Mt(t, e);
}
var cCe = /* @__PURE__ */ lr('<button class="sort-buttons svelte-mgubjs"><div> </div></button>');
const hCe = {
  hash: "svelte-mgubjs",
  code: ".sort-buttons.svelte-mgubjs {all:unset;flex-shrink:0;width:16px;cursor:pointer;display:flex;justify-content:center;flex-direction:row;margin-left:4px;border-radius:2px;padding-left:4px;padding-right:4px;color:var(--tertiary-text-color);}.sort-buttons.svelte-mgubjs:hover {--placeholder: 0;background-color:var(--hover-bg);}.sort-glyph.svelte-mgubjs {color:var(--tertiary-text-color);}.sort-buttons.svelte-mgubjs:hover .sort-glyph:where(.svelte-mgubjs) {color:var(--tertiary-text-color);}.selected.svelte-mgubjs {color:var(--primary-text-color) !important;}"
};
function fCe(t, e) {
  on(e, !0), an(t, hCe);
  const r = Cr.controller;
  let n = /* @__PURE__ */ Se(() => r.sort ? r.sort.column === e.col : !1), i = /* @__PURE__ */ Se(() => r.sort ? r.sort.direction : null), o = /* @__PURE__ */ Se(() => j(n) ? j(i) === "ascending" ? "â†‘" : "â†“" : "â‡…");
  var s = cCe();
  s.__click = () => {
    const u = j(n) ? j(i) === "ascending" ? "descending" : null : "ascending";
    u ? r.handleSort({ column: e.col, direction: u }) : r.handleSort(null);
  };
  var a = yr(s), l = yr(a, !0);
  fr(a), fr(s), pn(() => {
    fc(a, 1, `sort-button ${(j(n) ? "selected" : null) ?? ""} sort-glyph`, "svelte-mgubjs"), dl(l, j(o));
  }), Mt(t, s), sn();
}
pu(["click"]);
class dCe {
  #e = /* @__PURE__ */ Ue(li({}));
  get config() {
    return j(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const i3 = Symbol("custom-headers");
class e1 {
  static initialize() {
    cs(i3, new dCe());
  }
  static set config(e) {
    const r = Qi(i3);
    r.config = e;
  }
  static get config() {
    return Qi(i3).config;
  }
}
var pCe = /* @__PURE__ */ lr("<div></div>");
const mCe = { hash: "svelte-v680az", code: "" };
function gCe(t, e) {
  on(e, !0), an(t, mCe), Cr.model;
  const r = (o) => typeof o == "function" ? (s, a) => {
    let l = new o(s, a);
    return {
      ...l.update ? { update: l.update.bind(l) } : {},
      ...l.destroy ? { destroy: l.destroy.bind(l) } : {}
    };
  } : (s, a) => {
    let l = new o.class(s, a);
    return {
      ...l.update ? { update: l.update.bind(l) } : {},
      ...l.destroy ? { destroy: l.destroy.bind(l) } : {}
    };
  };
  let n = /* @__PURE__ */ Se(() => r(e.customHeader));
  var i = pCe();
  A5(i, (o, s) => j(n)?.(o, s), () => ({ column: e.col })), Mt(t, i), sn();
}
var vCe = /* @__PURE__ */ lr("<!> <!>", 1), yCe = /* @__PURE__ */ lr('<div><div class="header-content svelte-1vl6s3u"><!> <div class="header-title svelte-1vl6s3u"><!></div></div></div>');
const bCe = {
  hash: "svelte-1vl6s3u",
  code: ".header-cell.svelte-1vl6s3u {position:relative;display:flex;flex-direction:row;align-items:end;width:var(--width);min-height:var(--height);flex-shrink:0;box-sizing:border-box;padding:0.25em;padding-right:calc(calc(var(--padding-x) / 2) + var(--extra-padding-right));padding-left:calc(calc(var(--padding-x) / 2) + var(--extra-padding-left));color:var(--secondary-text-color);font-family:var(--header-font-family);font-size:var(--header-font-size);}.header-cell.number.svelte-1vl6s3u {justify-content:end;}.header-content.svelte-1vl6s3u {display:flex;flex-direction:column;flex-shrink:0;}.header-title.svelte-1vl6s3u {height:1.5em;align-items:center;display:flex;flex-direction:row;flex-shrink:0;}"
};
function xCe(t, e) {
  on(e, !0), an(t, bCe);
  const r = Cr.model, n = Cr.schema, i = xr.config;
  let o = /* @__PURE__ */ Se(() => e1.config), s = /* @__PURE__ */ Ue(null), a = /* @__PURE__ */ Ue(0);
  Kr(() => {
    i.minColumnWidths[e.col] = j(a) + i.betweenColPadding;
  });
  const l = /* @__PURE__ */ Se(() => r.colWidths[e.col]), u = /* @__PURE__ */ Se(() => (n.dataType[e.col] ?? "string") === "number"), c = /* @__PURE__ */ Se(() => j(u) || e.col === Wi ? "number" : ""), h = /* @__PURE__ */ Se(() => r.isFirstCol(e.col)), d = /* @__PURE__ */ Se(() => r.isLastCol(e.col));
  let p = /* @__PURE__ */ Se(() => i.headerHeight ? i.headerHeight + "px" : "auto");
  var g = yCe();
  let v;
  var y = yr(g), b = yr(y);
  {
    var k = (A) => {
      gCe(A, {
        get col() {
          return e.col;
        },
        get customHeader() {
          return j(o)[e.col];
        }
      });
    };
    Xi(b, (A) => {
      j(o)[e.col] && A(k);
    });
  }
  var C = ms(b, 2), S = yr(C);
  {
    var _ = (A) => {
      var O = vCe(), M = Lo(O);
      sCe(M, {
        get col() {
          return e.col;
        }
      });
      var z = ms(M, 2);
      fCe(z, {
        get col() {
          return e.col;
        }
      }), Mt(A, O);
    }, D = (A) => {
      uCe(A);
    };
    Xi(S, (A) => {
      e.col !== Wi ? A(_) : A(D, !1);
    });
  }
  fr(C), fr(y), fr(g), Li(g, (A) => be(s, A), () => j(s)), pn(() => {
    fc(g, 1, `header-cell ${j(c) ?? ""}`, "svelte-1vl6s3u"), v = mo(g, "", v, {
      "--width": j(l) + "px",
      "--height": j(p),
      "--padding-x": i.betweenColPadding + "px",
      "--extra-padding-right": (j(d) ? i.verticalScrollbarWidth : 0) + "px",
      "--extra-padding-left": (j(h) ? i.firstColLeftPadding : 0) + "px"
    });
  }), ra(y, "clientWidth", (A) => be(a, A)), Mt(t, g), sn();
}
class wCe {
  tableModel;
  tableController;
  col;
  config;
  isDragging = !1;
  startDragX = 0;
  constructor({ tableModel: e, tableController: r, col: n }) {
    this.tableModel = e, this.tableController = r, this.col = n, this.config = xr.config;
  }
  handlePointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0, this.startDragX = e.offsetX;
  };
  handlePointerMove = (e) => {
    if (this.isDragging && this.startDragX !== null) {
      const r = e.offsetX - this.startDragX, n = this.tableModel.colWidths[this.col], i = Math.max(0, Math.round(n + r));
      this.config.columnConfigs[this.col] || (this.config.columnConfigs[this.col] = {}), this.config.columnConfigs[this.col].width = i, this.config.onColumnConfigsChange(this.col, bz(this.config.columnConfigs));
    }
  };
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.startDragX = null;
  };
}
var kCe = /* @__PURE__ */ lr('<div class="header-resize-indicator svelte-1y4d3p9"><div class="pill svelte-1y4d3p9"></div></div>');
const CCe = {
  hash: "svelte-1y4d3p9",
  code: ".header-resize-indicator.svelte-1y4d3p9 {position:absolute;z-index:2;box-sizing:border-box;width:12px;height:calc(100% - 0.25rem);margin:2px;cursor:col-resize;justify-content:center;display:flex;align-items:center;justify-content:center;transform:translateX(calc(var(--x) - 4px - 50%));}.pill.svelte-1y4d3p9 {width:2px;height:calc(100% - 4px);margin-top:2px;margin-bottom:2px;background-color:var(--secondary-text-color);opacity:0.2;border-radius:2px;}"
};
function _Ce(t, e) {
  on(e, !0), an(t, CCe);
  const r = Cr.model;
  let n = new wCe({
    tableModel: r,
    tableController: Cr.controller,
    col: e.col
  });
  const i = /* @__PURE__ */ Se(() => r.colPositions[e.col] + r.colWidths[e.col]);
  var o = kCe();
  o.__pointerdown = function(...a) {
    n.handlePointerDown?.apply(this, a);
  }, o.__pointermove = function(...a) {
    n.handlePointerMove?.apply(this, a);
  }, o.__pointerup = function(...a) {
    n.handlePointerUp?.apply(this, a);
  };
  let s;
  pn(() => s = mo(o, "", s, { "--x": j(i) + "px" })), Mt(t, o), sn();
}
pu(["pointerdown", "pointermove", "pointerup"]);
var SCe = /* @__PURE__ */ lr('<div class="table-portal svelte-i8g41o" tabindex="-1"><!></div>');
const ACe = {
  hash: "svelte-i8g41o",
  code: ".table-portal.svelte-i8g41o {position:absolute;}"
};
function ECe(t, e) {
  on(e, !0), an(t, ACe);
  const r = Cr.controller, n = Cr.tablePortalController;
  let i = /* @__PURE__ */ Ue(null);
  const o = (c) => {
    Kr(() => (n.mount(c, e.relativeTo, e.anchor, e.horizontalAlign, e.verticalAlign), c.focus(), () => {
      n.destroy(c);
    }));
  };
  let s = 0;
  Cp(() => {
    s = r.xScroll, requestAnimationFrame(a);
  });
  function a() {
    j(i) && e.stickyX && (j(i).style.transform = `translateX(${r.xScroll - s}px)`), requestAnimationFrame(a);
  }
  var l = SCe();
  l.__click = (c) => {
    c.stopPropagation();
  };
  var u = yr(l);
  S5(u, () => e.children), fr(l), Li(l, (c) => be(i, c), () => j(i)), A5(l, (c) => o?.(c)), Vd("wheel", l, (c) => {
    c.stopPropagation();
  }), Mt(t, l), sn();
}
pu(["click"]);
var DCe = /* @__PURE__ */ lr("<button> </button> <!>", 1);
const OCe = {
  hash: "svelte-3t0u29",
  code: '.dropdown.svelte-3t0u29 {all:unset;padding-left:8px;padding-right:8px;border-radius:2px;cursor:pointer;color:var(--secondary-text-color);position:relative;user-select:none;}.dropdown.svelte-3t0u29::before {content:"";position:absolute;top:0;left:0;height:100%;width:100%;background-color:var(--primary-bg);z-index:-1;}.dropdown.svelte-3t0u29:hover {background-color:var(--hover-bg);}.unclickable.svelte-3t0u29 {pointer-events:none;}'
};
function FCe(t, e) {
  an(t, OCe);
  let r = /* @__PURE__ */ Ue(!1), n = /* @__PURE__ */ Ue(null), i = /* @__PURE__ */ Ue(null);
  var o = DCe();
  Vd("click", y_, (c) => {
    j(r) && c.target !== j(n) && be(r, !1);
  });
  var s = Lo(o);
  s.__click = (c) => {
    be(r, !0);
  };
  var a = yr(s, !0);
  fr(s), Li(s, (c) => be(n, c), () => j(n));
  var l = ms(s, 2);
  {
    var u = (c) => {
      ECe(c, {
        get relativeTo() {
          return e.relativeTo;
        },
        anchor: "outside",
        horizontalAlign: "left",
        verticalAlign: "top",
        stickyX: !1,
        get element() {
          return j(i);
        },
        set element(h) {
          be(i, h, !0);
        },
        children: (h, d) => {
          var p = zc(), g = Lo(p);
          S5(g, () => e.children), Mt(h, p);
        },
        $$slots: { default: !0 }
      });
    };
    Xi(l, (c) => {
      j(r) && c(u);
    });
  }
  pn(() => {
    fc(s, 1, `dropdown ${j(r) ? "unclickable" : "clickable"}`, "svelte-3t0u29"), dl(a, e.label);
  }), Mt(t, o);
}
pu(["click"]);
var TCe = /* @__PURE__ */ lr('<li class="column-entry svelte-bmvlb6"><label class="column-label svelte-bmvlb6"> <input type="checkbox"/></label></li>'), MCe = /* @__PURE__ */ lr('<ul class="column-toggle svelte-bmvlb6"></ul>'), PCe = /* @__PURE__ */ lr("<!> <!>", 1), RCe = /* @__PURE__ */ lr('<div class="header-row svelte-bmvlb6"><div class="scroll-container svelte-bmvlb6"><div class="dropdown-label-container svelte-bmvlb6"><div class="dropdown-label svelte-bmvlb6"><!></div></div> <!></div></div>');
const NCe = {
  hash: "svelte-bmvlb6",
  code: ".header-row.svelte-bmvlb6 {flex-shrink:0;border-bottom:1px solid var(--secondary-bg);background-color:var(--primary-bg);}.scroll-container.svelte-bmvlb6 {display:flex;flex-direction:row;}.dropdown-label-container.svelte-bmvlb6 {position:absolute;z-index:20;left:0px;box-sizing:border-box;height:100%;padding:0.25em;display:flex;flex-direction:row;align-items:end;}.dropdown-label.svelte-bmvlb6 {height:1.5em;align-items:center;display:flex;}.column-toggle.svelte-bmvlb6 {margin:0;margin-top:4px;margin-left:8px;padding:12px;background-color:var(--primary-bg);border-radius:4px;box-shadow:var(--shadow);border:var(--outline);max-height:var(--max-height);max-width:var(--max-width);overflow:scroll;}.column-entry.svelte-bmvlb6 {list-style-type:none;padding:4px;user-select:none;}.column-label.svelte-bmvlb6 {display:flex;align-items:center;justify-content:space-between;gap:16px;color:var(--secondary-text-color);}"
};
function $Ce(t, e) {
  on(e, !0), an(t, NCe);
  const r = Cr.model, n = Cr.controller, i = xr.config;
  let o = /* @__PURE__ */ Ue(null), s = /* @__PURE__ */ Ue(null), a = /* @__PURE__ */ Ue(null), l = /* @__PURE__ */ Se(() => r.renderableCols), u = 0;
  Cp(() => (u = requestAnimationFrame(c), () => {
    cancelAnimationFrame(u);
  }));
  function c() {
    j(s) && (j(s).style.transform = `translate3d(${n.xScroll}px, 0, 0)`), j(a) && (j(a).style.transform = `translate3d(${-n.xScroll}px, 0, 0)`), u = requestAnimationFrame(c);
  }
  var h = RCe(), d = yr(h), p = yr(d), g = yr(p), v = yr(g);
  FCe(v, {
    label: "â‹®",
    get relativeTo() {
      return j(o);
    },
    children: (b, k) => {
      var C = MCe();
      let S;
      Um(C, 21, () => r.columns, Rke, (_, D) => {
        var A = TCe(), O = yr(A), M = yr(O), z = ms(M);
        qke(z), z.__change = (R) => {
          R.target.checked ? n.showColumn(j(D)) : n.hideColumn(j(D));
        }, mo(z, "", {}, { float: "right" }), fr(O), fr(A), pn(() => {
          dl(M, `${(j(D) === Wi ? "row #" : i.columnConfigs[j(D)]?.title ?? j(D)) ?? ""} `), Hg(z, "id", `${j(D) ?? ""}-checkbox`), Uke(z, j(D) === Wi ? i.showRowNumber !== !1 : !i.columnConfigs[j(D)]?.hidden);
        }), Mt(_, A);
      }), fr(C), pn(() => S = mo(C, "", S, {
        "--max-height": n.viewHeight - 48 + "px",
        "--max-width": n.viewWidth - 48 + "px"
      })), Mt(b, C);
    }
  }), fr(g), Li(g, (b) => be(a, b), () => j(a)), fr(p);
  var y = ms(p, 2);
  Um(y, 16, () => j(l), (b) => b, (b, k) => {
    var C = PCe(), S = Lo(C);
    xCe(S, {
      get col() {
        return k;
      }
    });
    var _ = ms(S, 2);
    _Ce(_, {
      get col() {
        return k;
      }
    }), Mt(b, C);
  }), fr(d), Li(d, (b) => be(s, b), () => j(s)), fr(h), Li(h, (b) => be(o, b), () => j(o)), Mt(t, h), sn();
}
pu(["change"]);
class ICe {
  #e = /* @__PURE__ */ Ue(null);
  get colorScheme() {
    return j(this.#e);
  }
  set colorScheme(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ Ue(li({}));
  get theme() {
    return j(this.#t);
  }
  set theme(e) {
    be(this.#t, e, !0);
  }
}
const xF = Symbol("style");
class E_ {
  static initialize() {
    cs(xF, new ICe());
  }
  static get style() {
    return Qi(xF);
  }
}
function BCe(t, e) {
  return { ...t, ...t[e] != null ? t[e] : {} };
}
var LCe = /* @__PURE__ */ lr("<div><!></div>");
const zCe = {
  hash: "svelte-c7n1rn",
  code: ".table-defaults.light.svelte-c7n1rn {--default-primary-text-color: black;--default-secondary-text-color: gray;--default-tertiary-text-color: lightgray;--default-font-family: sans-serif;--default-font-size: 1rem;--default-primary-bg: white;--default-secondary-bg: rgb(246, 246, 247);--default-tertiary-bg: rgb(234, 234, 235);--default-hover-bg: rgba(0, 0, 0, 0.05);--default-scrollbar-bg: rgba(0, 0, 0, 0.05);--default-scrollbar-pill-bg: rgba(0, 0, 0, 0.5);--default-scrollbar-label-bg: rgba(255, 255, 255, 0.9);--default-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--default-outline-color: rgb(0 0 0 / 0.2);--default-dimmed-row-color: rgb(0 0 0 / 0.2);--default-row-scroll-to-color: rgb(202 225 255);--default-row-hover-color: rgb(220, 235, 255);}.table-defaults.dark.svelte-c7n1rn {--default-primary-text-color: lightgray;--default-secondary-text-color: gray;--default-tertiary-text-color: dimgray;--default-font-family: sans-serif;--default-font-size: 1rem;--default-primary-bg: #060607;--default-secondary-bg: #161617;--default-hover-bg: rgba(255, 255, 255, 0.05);--default-scrollbar-bg: rgba(255, 255, 255, 0.05);--default-scrollbar-pill-bg: rgba(255, 255, 255, 0.5);--default-scrollbar-label-bg: rgba(0, 0, 0, 0.9);--default-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--default-outline-color: rgb(255 255 255 / 0.2);--default-dimmed-row-color: rgb(0 0 0 / 0.6);--default-row-scroll-to-color: rgb(1, 24, 106);--default-row-hover-color: rgb(0, 6, 35);}.style-wrapper.svelte-c7n1rn {width:100%;height:100%;--primary-text-color: var(--user-primary-text-color, var(--default-primary-text-color));--secondary-text-color: var(--user-secondary-text-color, var(--default-secondary-text-color));--tertiary-text-color: var(--user-tertiary-text-color, var(--default-tertiary-text-color));--font-family: var(--user-font-family, var(--default-font-family));--font-size: var(--user-font-size, var(--default-font-size));--primary-bg: var(--user-primary-bg, var(--default-primary-bg));--secondary-bg: var(--user-secondary-bg, var(--default-secondary-bg));--tertiary-bg: var(--user-tertiarty-bg, var(--default-tertiary-bg));--hover-bg: var(--user-hover-bg, var(--default-hover-bg));--header-font-family: var(--user-header-font-family, var(--font-family));--header-font-size: var(--user-header-font-size, var(--font-size));--cell-font-family: var(--user-cell-font-family, var(--font-family));--cell-font-size: var(--user-cell-font-size, var(--font-size));--scrollbar-bg: var(--user-scrollbar-bg, var(--default-scrollbar-bg));--scrollbar-pill-bg: var(--user-scrollbar-pill-bg, var(--default-scrollbar-pill-bg));--scrollbar-label-bg: var(--user-scrollbar-label-bg, var(--default-scrollbar-label-bg));--shadow: var(--user-shadow, var(--default-shadow));--outline-color: var(--user-outline-color, var(--default-outline-color));--outline: 0.5px solid var(--outline-color);--dimmed-row-color: var(--user-dimmed-row-color, var(--default-dimmed-row-color));--row-scroll-to-color: var(--user-row-scroll-to-color, var(--default-row-scroll-to-color));--row-hover-color: var(--user-row-hover-color, var(--default-row-hover-color));}"
};
function jCe(t, e) {
  on(e, !0), an(t, zCe);
  const r = E_.style;
  let n = /* @__PURE__ */ Se(() => r.colorScheme), i = /* @__PURE__ */ Se(() => r.theme), o = /* @__PURE__ */ Ue(null), s = /* @__PURE__ */ Se(() => j(n) ?? j(o) ?? "light");
  const a = (U) => {
    U.matches ? be(o, "dark") : be(o, "light");
  }, l = "(prefers-color-scheme: dark";
  Cp(() => (be(o, window.matchMedia(l).matches ? "dark" : "light", !0), window.matchMedia(l).addEventListener("change", a), () => {
    window.matchMedia(l).removeEventListener("change", a);
  }));
  let u = /* @__PURE__ */ Se(() => BCe(j(i), j(s))), c = /* @__PURE__ */ Se(() => j(u).primaryTextColor), h = /* @__PURE__ */ Se(() => j(u).secondaryTextColor), d = /* @__PURE__ */ Se(() => j(u).tertiaryTextColor), p = /* @__PURE__ */ Se(() => j(u).fontFamily), g = /* @__PURE__ */ Se(() => j(u).fontSize), v = /* @__PURE__ */ Se(() => j(u).primaryBackgroundColor), y = /* @__PURE__ */ Se(() => j(u).secondaryBackgroundColor), b = /* @__PURE__ */ Se(() => j(u).hoverBackgroundColor), k = /* @__PURE__ */ Se(() => j(u).headerFontFamily), C = /* @__PURE__ */ Se(() => j(u).headerFontSize), S = /* @__PURE__ */ Se(() => j(u).cellFontFamily), _ = /* @__PURE__ */ Se(() => j(u).cellFontSize), D = /* @__PURE__ */ Se(() => j(u).scrollbarBackgroundColor), A = /* @__PURE__ */ Se(() => j(u).scrollbarPillColor), O = /* @__PURE__ */ Se(() => j(u).scrollbarLabelBackgroundColor), M = /* @__PURE__ */ Se(() => j(u).shadow), z = /* @__PURE__ */ Se(() => j(u).outlineColor), R = /* @__PURE__ */ Se(() => j(u).dimmedRowColor), N = /* @__PURE__ */ Se(() => j(u).rowScrollToColor), I = /* @__PURE__ */ Se(() => j(u).rowHoverColor);
  Kr(() => {
  });
  var B = LCe();
  let $;
  var q = yr(B);
  S5(q, () => e.children), fr(B), pn(() => {
    fc(B, 1, `style-wrapper table-defaults ${j(s) ?? ""}`, "svelte-c7n1rn"), $ = mo(B, "", $, {
      "--user-primary-text-color": j(c),
      "--user-secondary-text-color": j(h),
      "--user-tertiary-text-color": j(d),
      "--user-font-family": j(p),
      "--user-font-size": j(g),
      "--user-primary-bg": j(v),
      "--user-secondary-bg": j(y),
      "--user-hover-bg": j(b),
      "--user-header-font-family": j(k),
      "--user-header-font-size": j(C),
      "--user-cell-font-family": j(S),
      "--user-cell-font-size": j(_),
      "--user-scrollbar-bg": j(D),
      "--user-scrollbar-pill-bg": j(A),
      "--user-scrollbar-label-bg": j(O),
      "--user-shadow": j(M),
      "--user-outline-color": j(z),
      "--user-dimmed-row-color": j(R),
      "--user-row-scroll-to-color": j(N),
      "--user-row-hover-color": j(I)
    });
  }), Mt(t, B), sn();
}
function qCe() {
  return Wi;
}
function UCe(t, e) {
  const r = new Set(t), n = new Set(e);
  return {
    left: t.filter((i) => !n.has(i)),
    right: e.filter((i) => !r.has(i))
  };
}
function HCe(t, e) {
  const r = new Set(e);
  return t.filter((n) => !r.has(n));
}
function VCe(t, e) {
  return t.concat(e);
}
var WCe = /* @__PURE__ */ lr("<div></div>"), GCe = /* @__PURE__ */ lr("<div></div> <!>", 1);
const KCe = {
  hash: "svelte-14dgpd0",
  code: ".row-background.svelte-14dgpd0 {position:absolute;width:var(--width);height:var(--height);box-sizing:border-box;z-index:-1;transform:translate3d(0, var(--y), 0);transition:background-color 100ms linear;}.odd.svelte-14dgpd0 {background-color:var(--secondary-bg);}.even.svelte-14dgpd0 {background-color:var(--primary-bg);}.dimmer.svelte-14dgpd0 {background-color:var(--dimmed-row-color);z-index:10;pointer-events:none;}.flashed.svelte-14dgpd0 {background-color:var(--row-scroll-to-color);}.hovered.svelte-14dgpd0 {background-color:var(--row-hover-color);}"
};
function QCe(t, e) {
  on(e, !0), an(t, KCe);
  const r = Cr.controller, n = Cr.model, i = Cr.overscrollModifier, o = xr.config;
  let s = /* @__PURE__ */ Se(() => n.rowHeights[e.row]), a = /* @__PURE__ */ Se(() => Math.max(n.colsRightmostPosition, r.viewWidth)), l = /* @__PURE__ */ Se(() => i.y(n.rowPositions[e.row])), u = /* @__PURE__ */ Se(() => n.getRowParity(e.row)), c = /* @__PURE__ */ Se(() => r.flashedRowId === e.row), h = /* @__PURE__ */ Se(() => r.hoveredRowId === e.row), d = /* @__PURE__ */ Se(() => o.highlightedRows ? o.highlightedRows?.has(e.row) : null);
  var p = GCe(), g = Lo(p);
  let v;
  var y = ms(g, 2);
  {
    var b = (k) => {
      var C = WCe();
      let S;
      pn(() => {
        fc(C, 1, `row-background ${j(u) ?? ""} dimmer`, "svelte-14dgpd0"), S = mo(C, "", S, {
          "--width": j(a) + "px",
          "--height": j(s) + "px",
          "--y": j(l) + "px"
        });
      }), Mt(k, C);
    };
    Xi(y, (k) => {
      j(d) !== null && !j(d) && k(b);
    });
  }
  pn(() => {
    fc(g, 1, `row-background ${j(u) ?? ""} ${(j(c) ? "flashed" : null) ?? ""} ${(j(h) && o.highlightHoveredRow ? "hovered" : null) ?? ""}`, "svelte-14dgpd0"), v = mo(g, "", v, {
      "--width": j(a) + "px",
      "--height": j(s) + "px",
      "--y": j(l) + "px"
    });
  }), Mt(t, p), sn();
}
var XCe = /* @__PURE__ */ lr("<!> <!>", 1), JCe = /* @__PURE__ */ lr('<div class="scroll-container svelte-1v3p82v"><!></div> <!> <!>', 1), YCe = /* @__PURE__ */ lr('<div class="table svelte-1v3p82v"><!> <div class="table-contents svelte-1v3p82v"><!></div></div>');
const ZCe = {
  hash: "svelte-1v3p82v",
  code: ".table.svelte-1v3p82v {width:100%;max-width:var(--max-width);height:100%;display:flex;flex-direction:column;position:relative;}.table-contents.svelte-1v3p82v {position:relative;overflow:hidden;flex-grow:1;}.scroll-container.svelte-1v3p82v {position:absolute;width:0;height:0;will-change:transform;contain:layout size;}"
};
function e_e(t, e) {
  on(e, !0), an(t, ZCe), xr.initialize(), Zy.initialize(), e1.initialize(), E_.initialize(), Cr.initialize();
  const r = Cr.controller, n = Cr.model, i = Cr.overscrollModifier, o = xr.config, s = E_.style;
  Kr(() => {
    e.scrollTo != null && r.scrollToRow(String(e.scrollTo));
  }), Kr(() => {
    e.highlightedRows && e.highlightedRows.length > 0 ? o.highlightedRows = new Set(e.highlightedRows.map((k) => String(k))) : o.highlightedRows = null;
  }), Kr(() => {
    e.onRowClick != null ? o.onRowClick = e.onRowClick : o.onRowClick = null;
  }), Kr(() => {
    e.coordinator ? A_.coordinator = e.coordinator : A_.coordinator = null;
  }), Kr(() => {
    e.numLines != null ? o.textMaxLines = e.numLines : o.textMaxLines = o.DEFAULT_TEXT_MAX_LINES, e.lineHeight != null ? o.lineHeight = e.lineHeight : o.lineHeight = o.DEFAULT_LINE_HEIGHT;
  }), Kr(() => {
    e.colorScheme != null ? s.colorScheme = e.colorScheme : s.colorScheme = null;
  }), Kr(() => {
    e.theme != null ? s.theme = e.theme : s.theme = {}, e.colorScheme != null ? s.colorScheme = e.colorScheme : s.colorScheme = null;
  }), Kr(() => {
    e.columnConfigs != null ? o.columnConfigs = e.columnConfigs : o.columnConfigs = {}, e.onColumnConfigsChange != null ? o.onColumnConfigsChange = e.onColumnConfigsChange : o.onColumnConfigsChange = () => {
    };
  }), Kr(() => {
    o.showRowNumber = e.showRowNumber ?? null;
  }), Kr(() => {
    o.onShowRowNumberChange = e.onShowRowNumberChange ?? null;
  }), Kr(() => {
    r.initialize({
      tableName: e.table,
      rowKey: e.rowKey,
      columns: [qCe(), ...e.columns],
      filterBy: e.filter ?? null
    });
  }), Kr(() => {
    e.customCells != null ? Zy.config = e.customCells : Zy.config = {};
  }), Kr(() => {
    e.additionalHeaderContents != null ? e1.config = e.additionalHeaderContents : e1.config = {};
  }), Kr(() => {
    e.headerHeight != null ? o.headerHeight = e.headerHeight : o.headerHeight = null;
  }), Kr(() => {
    e.highlightHoveredRow != null ? o.highlightHoveredRow = e.highlightHoveredRow : o.highlightHoveredRow = !1;
  });
  let a = /* @__PURE__ */ Ue([]), l = /* @__PURE__ */ Ue(0), u = /* @__PURE__ */ Ue(null), c = /* @__PURE__ */ Ue(li([])), h = /* @__PURE__ */ Ue(li([])), d = /* @__PURE__ */ Se(() => j(c).filter((k) => r.rowStillExists(k))), p = /* @__PURE__ */ Se(() => j(h)), g = 0;
  Cp(() => (g = requestAnimationFrame(b), () => {
    r.teardown(), n.teardown(), cancelAnimationFrame(g);
  }));
  function v(k, C) {
    if (C.length > 0) {
      const S = C[C.length - 1];
      return Math.abs(n.data[k][Gi] - n.data[S][Gi]);
    }
    return 0;
  }
  function y() {
    const { left: k, right: C } = UCe(j(a), n.renderableRows);
    k.length === 0 && C.length === 0 || (be(a, HCe(j(
      a
      // remove the rows that have been deleted from the model
    ), k)), be(a, VCe(j(
      a
      // add the rows that have been added by the model
    ), C.sort((S, _) => v(S, j(a)) - v(_, j(a))).slice(0, r.isJumping ? r.rowsOnScreen : o.rowRenderBatchSize))));
  }
  function b() {
    y(), be(c, j(a).filter((S) => r.rowIsVisible(S)), !0), be(h, n.renderableCols.filter((S) => r.colIsVisible(S)), !0);
    const k = r.xScroll, C = i.yScroll(r.yScroll);
    j(u) && (j(u).style.transform = `translate3d(${k}px, ${C}px, 0)`), be(l, r.updateKey, !0), g = requestAnimationFrame(b);
  }
  jCe(t, {
    children: (k, C) => {
      var S = YCe(), _ = yr(S);
      $Ce(_, {});
      var D = ms(_, 2), A = yr(D);
      {
        var O = (M) => {
          var z = JCe(), R = Lo(z), N = yr(R);
          Pke(N, () => j(l), ($) => {
            var q = XCe(), U = Lo(q);
            Um(U, 16, () => j(d), (G) => G, (G, re) => {
              var ie = zc(), se = Lo(ie);
              Um(se, 16, () => j(p), (ne) => ne, (ne, ce) => {
                nCe(ne, {
                  get row() {
                    return re;
                  },
                  get col() {
                    return ce;
                  }
                });
              }), Mt(G, ie);
            });
            var H = ms(U, 2);
            Um(H, 16, () => n.renderableRows, (G) => G, (G, re) => {
              QCe(G, {
                get row() {
                  return re;
                }
              });
            }), Mt($, q);
          }), fr(R), Li(R, ($) => be(u, $), () => j(u));
          var I = ms(R, 2);
          O3e(I, {});
          var B = ms(I, 2);
          A3e(B, {}), Mt(M, z);
        };
        Xi(A, (M) => {
          r.isReady && M(O);
        });
      }
      fr(D), fr(S), Li(S, (M) => r.element = M, () => r?.element), Vd("wheel", S, function(...M) {
        r.handleWheel?.apply(this, M);
      }), ra(D, "clientHeight", (M) => r.viewHeight = M), ra(D, "clientWidth", (M) => r.viewWidth = M), Mt(k, S);
    },
    $$slots: { default: !0 }
  }), sn();
}
class t_e {
  component;
  currentProps;
  constructor(e, r) {
    this.currentProps = { ...r }, this.component = Oke({ component: e_e, target: e, props: r });
  }
  update(e) {
    let r = {};
    for (let n in e)
      e[n] !== this.currentProps[n] && (r[n] = e[n], this.currentProps[n] = e[n]);
    this.component.$set(r);
  }
  destroy() {
    this.component.$destroy();
  }
}
var r_e = /* @__PURE__ */ me("<div></div>");
function n_e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]), n;
  Kg(() => {
    let o = new t_e(n, r);
    Vs(() => {
      o.update(r);
    }), CT(() => {
      o.destroy();
    });
  });
  var i = r_e();
  ft(i, "", {}, { width: "100%", height: "100%" }), Qs(i, (o) => n = o, () => n), X(t, i), it();
}
const i_e = {
  fontSize: "13px",
  fontFamily: "system-ui",
  light: {
    primaryBackgroundColor: "white",
    secondaryBackgroundColor: "var(--color-slate-100)",
    // bg-slate-100
    primaryTextColor: "var(--color-slate-500)",
    // text-slate-500
    secondaryTextColor: "var(--color-slate-400)",
    // text-slate-400
    tertiaryTextColor: "var(--color-slate-300)",
    // text-slate-300
    scrollbarPillColor: "var(--color-slate-400)",
    // bg-slate-400
    scrollbarLabelBackgroundColor: "white",
    rowScrollToColor: "var(--color-blue-200)",
    // bg-blue-200
    rowHoverColor: "var(--color-blue-100)"
    // bg-blue-100
  },
  dark: {
    primaryBackgroundColor: "black",
    secondaryBackgroundColor: "var(--color-slate-900)",
    // bg-slate-900
    primaryTextColor: "var(--color-slate-400)",
    // bg-slate-400
    secondaryTextColor: "var(--color-slate-500)",
    // bg-slate-500
    tertiaryTextColor: "var(--color-slate-600)",
    // bg-slate-600
    scrollbarPillColor: "var(--color-slate-500)",
    // bg-slate-500
    scrollbarLabelBackgroundColor: "var(--color-slate-900)",
    // bg-slate-900
    rowScrollToColor: "var(--color-blue-900)",
    // bg-slate-900
    rowHoverColor: "var(--color-blue-950)"
    // bg-slate-950
  }
};
function o_e(t, e) {
  nt(e, !0);
  const r = () => mi(a, "$columnStyles", i), n = () => mi(s, "$colorScheme", i), [i, o] = Xo();
  let { colorScheme: s, columnStyles: a } = e.context, l = sz(e.context.highlight), u = /* @__PURE__ */ De(null);
  mt(() => l.subscribe((d) => {
    x(u) !== d && ue(u, d, !0);
  }));
  function c(d, p, g) {
    let v = {};
    for (let y of d)
      g?.[y.name] != null && (v[y.name] = SO(g[y.name])), p[y.name]?.renderer != null && (v[y.name] = SO(p[y.name]?.renderer));
    return v;
  }
  let h = /* @__PURE__ */ K(() => c(e.context.columns, r(), e.context.tableCellRenderers));
  n_e(t, {
    get coordinator() {
      return e.context.coordinator;
    },
    get table() {
      return e.context.table;
    },
    get rowKey() {
      return e.context.id;
    },
    get columns() {
      return e.spec.columns;
    },
    get filter() {
      return e.context.filter;
    },
    get scrollTo() {
      return x(u);
    },
    onRowClick: async (d) => {
      l.set(d);
    },
    numLines: 3,
    get colorScheme() {
      return n();
    },
    get theme() {
      return i_e;
    },
    highlightHoveredRow: !0,
    get customCells() {
      return x(h);
    }
  }), it(), o();
}
const aj = {}, lj = [];
function _s(t, e) {
  aj[t] = e;
}
function mu(t) {
  lj.push(t);
}
function s_e(t) {
  return typeof t != "object" ? $k : typeof t.type == "string" ? aj[t.type] ?? $k : $k;
}
function a_e() {
  return lj;
}
_s("builder", vxe);
_s("count-plot", ebe);
_s("count-plot-list", cbe);
_s("histogram", gbe);
_s("histogram-stack", Obe);
_s("histogram-2d", kbe);
_s("box-plot", H1e);
_s("mosaic-spec", $be);
_s("line-plot", Rbe);
_s("embedding", S2e);
_s("predicates", Hbe);
_s("table", o_e);
mu({
  icon: "chart-h-bar",
  description: "Create a count plot of a categorical field",
  ui: [
    { field: { key: "x", label: "Field", types: ["number", "string", "string[]"], required: !0 } }
    //
  ],
  create: ({ x: t }) => t.type == "discrete[]" ? {
    title: t.name,
    type: "count-plot-list",
    data: { field: t.name }
  } : {
    title: t.name,
    type: "count-plot",
    data: { field: t.name }
  }
});
mu({
  icon: "chart-v-histogram",
  description: "Create a histogram of a field",
  ui: [
    { field: { key: "x", label: "Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t }) => ({
    type: "histogram",
    title: t.name,
    data: { field: t.name },
    binCount: 20
  })
});
mu({
  icon: "chart-line",
  description: "Create a line plot over time",
  ui: [
    { field: { key: "x", label: "Time Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t }, e) => ({
    type: "line-plot",
    title: `${t.name} over time`,
    data: { table: e.table, x: t.name }
  })
});
mu({
  icon: "chart-stacked",
  description: "Create a stacked histogram",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number", "string"], required: !0 } },
    //
    { field: { key: "y", label: "Group Field", types: ["number", "string"] } }
    //
  ],
  create: ({ x: t, y: e }) => e == null ? {
    type: "histogram",
    title: `${t.name}`,
    data: {
      field: t.name
    },
    binCount: 20
  } : {
    type: "histogram-stack",
    title: `${t.name} by ${e.name}`,
    data: {
      x: t.name,
      group: e.name
    },
    xBinCount: 20,
    groupBinCount: 5
  }
});
mu({
  icon: "chart-heatmap",
  description: "Create a 2D heatmap of two fields",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number", "string"], required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t, y: e }) => ({
    type: "histogram-2d",
    title: `${t.name}, ${e.name}`,
    data: { x: t.name, y: e.name },
    xBinCount: 20,
    yBinCount: 20
  })
});
mu({
  icon: "chart-boxplot",
  description: "Create a box plot",
  ui: [
    { field: { key: "x", label: "X Field", required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number"], required: !0 } }
    //
  ],
  create: ({ x: t, y: e }) => ({
    type: "box-plot",
    title: `${e.name} by ${t.name}`,
    data: { x: t.name, y: e.name },
    xBinCount: 20
  })
});
mu({
  icon: "chart-embedding",
  description: "Create an embedding view",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number"], required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number"], required: !0 } },
    //
    { field: { key: "text", label: "Text Field", types: ["string"] } },
    //
    { field: { key: "category", label: "Category Field", types: ["string", "number"] } }
    //
  ],
  preview: !1,
  create: ({ x: t, y: e, text: r, category: n }, i) => ({
    type: "embedding",
    title: "Embedding",
    data: {
      x: t.name,
      y: e.name,
      text: r?.name,
      category: n?.name
    }
  })
});
mu({
  icon: "chart-predicates",
  description: "Create a filter with custom SQL predicates",
  ui: [],
  create: () => ({
    type: "predicates",
    title: "SQL Predicates"
  })
});
mu({
  icon: "chart-spec",
  description: "Create a chart with custom spec",
  preview: !1,
  ui: [{ code: { key: "spec", language: "json" } }],
  create: ({ spec: t }) => JSON.parse(t)
});
var l_e = /* @__PURE__ */ me("<button>An occured with this chart. Click to retry.</button>"), u_e = /* @__PURE__ */ me("<div><!></div>");
function uj(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]), n = /* @__PURE__ */ K(() => s_e(e.spec)), i = /* @__PURE__ */ De(100), o = /* @__PURE__ */ De(100);
  function s(c, h) {
    console.trace("Error happened in chart with spec", h.spec, h.error);
  }
  var a = u_e();
  let l;
  var u = Y(a);
  KF(u, { failed: (c, h = zt, d = zt) => {
    var p = l_e();
    p.__click = function(...g) {
      d()?.apply(this, g);
    }, To(p, (g, v) => s?.(g, v), () => ({ spec: e.spec, error: h() })), X(c, p);
  } }, (c) => {
    var h = kr(), d = Ve(h);
    {
      let p = /* @__PURE__ */ K(() => e.width == "container" ? x(i) : e.width), g = /* @__PURE__ */ K(() => e.height == "container" ? x(o) : e.height);
      Qd(d, () => x(n), (v, y) => {
        y(v, lX(() => r, {
          get width() {
            return x(p);
          },
          get height() {
            return x(g);
          }
        }));
      });
    }
    X(c, h);
  }), J(a), Ae(() => l = ft(a, "", l, {
    width: e.width == "container" ? "100%" : e.width != null ? `${e.width}px` : "fit-content",
    height: e.height == "container" ? "100%" : e.height != null ? `${e.height}px` : "fit-content"
  })), Ks(a, "clientWidth", (c) => ue(i, c)), Ks(a, "clientHeight", (c) => ue(o, c)), X(t, a), it();
}
nn(["click"]);
function c_e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => vme(e.layout)), n = /* @__PURE__ */ K(() => e.layoutStates[e.layout] ?? {});
  function i(h, d, p = "merge") {
    _y(e.charts, h, d, p, (g) => e.onChartsChange?.(g));
  }
  function o(h, d, p = "merge") {
    _y(e.chartStates, h, d, p, (g) => e.onChartStatesChange?.(g));
  }
  function s(h, d = "merge") {
    pd(e.charts, h, d, (p) => e.onChartsChange?.(p));
  }
  function a(h, d = "merge") {
    pd(e.chartStates, h, d, (p) => e.onChartStatesChange?.(p));
  }
  function l(h, d, p = "merge") {
    _y(e.layoutStates, h, d, p, (g) => e.onLayoutStatesChange?.(g));
  }
  var u = kr(), c = Ve(u);
  {
    const h = (p, g) => {
      let v = () => g?.().id, y = () => g?.().width, b = () => g?.().height;
      {
        let k = /* @__PURE__ */ K(() => e.chartStates[v()] ?? {}), C = /* @__PURE__ */ K(() => i.bind(null, v())), S = /* @__PURE__ */ K(() => o.bind(null, v()));
        uj(p, {
          get context() {
            return e.context;
          },
          get width() {
            return y();
          },
          get height() {
            return b();
          },
          get spec() {
            return e.charts[v()];
          },
          get state() {
            return x(k);
          },
          get onSpecChange() {
            return x(C);
          },
          get onStateChange() {
            return x(S);
          }
        });
      }
    };
    let d = /* @__PURE__ */ K(() => l.bind(null, e.layout));
    Qd(c, () => x(r), (p, g) => {
      g(p, {
        get context() {
          return e.context;
        },
        get charts() {
          return e.charts;
        },
        get state() {
          return x(n);
        },
        get onStateChange() {
          return x(d);
        },
        onChartsChange: s,
        onChartStatesChange: a,
        chartView: h,
        $$slots: { chartView: !0 }
      });
    });
  }
  X(t, u), it();
}
var h_e = /* @__PURE__ */ me('<tr class="leading-10"><td class="w-full"><div class="max-w-80 whitespace-nowrap text-ellipsis overflow-x-hidden"> </div></td><td class="pr-2"><div class="flex items-center gap-2"><!> <!></div></td><td><div class="flex items-center gap-2"><!></div></td></tr>');
function f_e(t, e) {
  nt(e, !0);
  function r(v) {
    e.onChange({ ...e.style, ...v });
  }
  var n = h_e(), i = Y(n), o = Y(i), s = Y(o, !0);
  J(o), J(i);
  var a = ae(i), l = Y(a), u = Y(l);
  {
    let v = /* @__PURE__ */ K(() => e.style.renderer ?? null), y = /* @__PURE__ */ K(() => [
      { value: null, label: "(default)" },
      ...hwe.map((b) => ({ value: b.renderer, label: b.label }))
    ]);
    Dh(u, {
      get value() {
        return x(v);
      },
      onChange: (b) => r({ renderer: b }),
      get options() {
        return x(y);
      }
    });
  }
  var c = ae(u, 2);
  {
    var h = (v) => {
      var y = () => e.style.rendererOptions?.size ?? 100, b = (k) => {
        r({ rendererOptions: { size: k } });
      };
      g_(v, {
        get value() {
          return y();
        },
        set value(k) {
          b(k);
        },
        width: 80,
        min: 16,
        max: 400,
        step: 1
      });
    };
    Oe(c, (v) => {
      e.style.renderer == "image" && v(h);
    });
  }
  J(l), J(a);
  var d = ae(a), p = Y(d), g = Y(p);
  {
    let v = /* @__PURE__ */ K(() => e.style.display ?? "badge");
    Dh(g, {
      get value() {
        return x(v);
      },
      onChange: (y) => {
        r({ display: y });
      },
      options: [
        { value: "full", label: "Full" },
        { value: "badge", label: "Badge" },
        { value: "hidden", label: "Hidden" }
      ]
    });
  }
  J(p), J(d), J(n), Ae(() => ut(s, e.column.name)), X(t, n), it();
}
var d_e = /* @__PURE__ */ me('<div class="max-h-60 overflow-x-hidden overflow-y-scroll border border-slate-300 dark:border-slate-700 p-2 rounded-md"><table><thead><tr class="select-none"><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Column</th><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Format</th><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Style</th></tr></thead><tbody></tbody></table></div>');
function p_e(t, e) {
  nt(e, !0);
  var r = d_e(), n = Y(r), i = ae(Y(n));
  Nt(i, 21, () => e.columns, cr, (o, s) => {
    {
      let a = /* @__PURE__ */ K(() => e.styles[x(s).name] ?? {});
      f_e(o, {
        get column() {
          return x(s);
        },
        get style() {
          return x(a);
        },
        onChange: (l) => {
          let u = { ...e.styles };
          u[x(s).name] = l, e.onStylesChange(u);
        }
      });
    }
  }), J(i), J(n), J(r), X(t, r), it();
}
var m_e = /* @__PURE__ */ me('<div> <span class="text-slate-500"> </span></div>');
function g_e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(null), n = /* @__PURE__ */ De(null);
  Vs(() => {
    ue(r, null), ue(n, null);
    let l = il({
      coordinator: e.coordinator,
      selection: e.filter,
      prepare: async () => {
        let u = await e.coordinator.query(dd.from(e.table).select({ count: eD`COUNT(*)::INT` }));
        ue(r, u.get(0).count, !0);
      },
      query: (u) => dd.from(e.table).select({ count: eD`COUNT(*)::INT` }).where(u),
      queryResult: (u) => {
        ue(n, u.getChild("count").get(0), !0);
      }
    });
    return () => {
      l.destroy();
    };
  });
  var i = m_e(), o = Y(i), s = ae(o), a = Y(s);
  J(s), J(i), Ae(
    (l, u) => {
      ut(o, `${l ?? ""} `), ut(a, `/ ${u ?? ""} points`);
    },
    [
      () => x(n)?.toLocaleString() ?? "",
      () => x(r)?.toLocaleString() ?? ""
    ]
  ), X(t, i), it();
}
var D_ = { exports: {} }, v_e = D_.exports, wF;
function y_e() {
  return wF || (wF = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(v_e, (function() {
      var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
        return typeof u;
      } : function(u) {
        return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
      }, n = function(u, c) {
        if (!(u instanceof c))
          throw new TypeError("Cannot call a class as a function");
      }, i = /* @__PURE__ */ (function() {
        function u(c, h) {
          for (var d = 0; d < h.length; d++) {
            var p = h[d];
            p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(c, p.key, p);
          }
        }
        return function(c, h, d) {
          return h && u(c.prototype, h), d && u(c, d), c;
        };
      })(), o = Object.assign || function(u) {
        for (var c = 1; c < arguments.length; c++) {
          var h = arguments[c];
          for (var d in h)
            Object.prototype.hasOwnProperty.call(h, d) && (u[d] = h[d]);
        }
        return u;
      }, s = (function() {
        function u(c) {
          var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          n(this, u), this.ctx = c, this.iframes = h, this.exclude = d, this.iframesTimeout = p;
        }
        return i(u, [{
          key: "getContexts",
          value: function() {
            var c = void 0, h = [];
            return typeof this.ctx > "u" || !this.ctx ? c = [] : NodeList.prototype.isPrototypeOf(this.ctx) ? c = Array.prototype.slice.call(this.ctx) : Array.isArray(this.ctx) ? c = this.ctx : typeof this.ctx == "string" ? c = Array.prototype.slice.call(document.querySelectorAll(this.ctx)) : c = [this.ctx], c.forEach(function(d) {
              var p = h.filter(function(g) {
                return g.contains(d);
              }).length > 0;
              h.indexOf(d) === -1 && !p && h.push(d);
            }), h;
          }
        }, {
          key: "getIframeContents",
          value: function(c, h) {
            var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            }, p = void 0;
            try {
              var g = c.contentWindow;
              if (p = g.document, !g || !p)
                throw new Error("iframe inaccessible");
            } catch {
              d();
            }
            p && h(p);
          }
        }, {
          key: "isIframeBlank",
          value: function(c) {
            var h = "about:blank", d = c.getAttribute("src").trim(), p = c.contentWindow.location.href;
            return p === h && d !== h && d;
          }
        }, {
          key: "observeIframeLoad",
          value: function(c, h, d) {
            var p = this, g = !1, v = null, y = function b() {
              if (!g) {
                g = !0, clearTimeout(v);
                try {
                  p.isIframeBlank(c) || (c.removeEventListener("load", b), p.getIframeContents(c, h, d));
                } catch {
                  d();
                }
              }
            };
            c.addEventListener("load", y), v = setTimeout(y, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function(c, h, d) {
            try {
              c.contentWindow.document.readyState === "complete" ? this.isIframeBlank(c) ? this.observeIframeLoad(c, h, d) : this.getIframeContents(c, h, d) : this.observeIframeLoad(c, h, d);
            } catch {
              d();
            }
          }
        }, {
          key: "waitForIframes",
          value: function(c, h) {
            var d = this, p = 0;
            this.forEachIframe(c, function() {
              return !0;
            }, function(g) {
              p++, d.waitForIframes(g.querySelector("html"), function() {
                --p || h();
              });
            }, function(g) {
              g || h();
            });
          }
        }, {
          key: "forEachIframe",
          value: function(c, h, d) {
            var p = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, v = c.querySelectorAll("iframe"), y = v.length, b = 0;
            v = Array.prototype.slice.call(v);
            var k = function() {
              --y <= 0 && g(b);
            };
            y || k(), v.forEach(function(C) {
              u.matches(C, p.exclude) ? k() : p.onIframeReady(C, function(S) {
                h(C) && (b++, d(S)), k();
              }, k);
            });
          }
        }, {
          key: "createIterator",
          value: function(c, h, d) {
            return document.createNodeIterator(c, h, d, !1);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function(c) {
            return new u(c.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function(c, h, d) {
            var p = c.compareDocumentPosition(d), g = Node.DOCUMENT_POSITION_PRECEDING;
            if (p & g)
              if (h !== null) {
                var v = h.compareDocumentPosition(d), y = Node.DOCUMENT_POSITION_FOLLOWING;
                if (v & y)
                  return !0;
              } else
                return !0;
            return !1;
          }
        }, {
          key: "getIteratorNode",
          value: function(c) {
            var h = c.previousNode(), d = void 0;
            return h === null ? d = c.nextNode() : d = c.nextNode() && c.nextNode(), {
              prevNode: h,
              node: d
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function(c, h, d, p) {
            var g = !1, v = !1;
            return p.forEach(function(y, b) {
              y.val === d && (g = b, v = y.handled);
            }), this.compareNodeIframe(c, h, d) ? (g === !1 && !v ? p.push({
              val: d,
              handled: !0
            }) : g !== !1 && !v && (p[g].handled = !0), !0) : (g === !1 && p.push({
              val: d,
              handled: !1
            }), !1);
          }
        }, {
          key: "handleOpenIframes",
          value: function(c, h, d, p) {
            var g = this;
            c.forEach(function(v) {
              v.handled || g.getIframeContents(v.val, function(y) {
                g.createInstanceOnIframe(y).forEachNode(h, d, p);
              });
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function(c, h, d, p, g) {
            for (var v = this, y = this.createIterator(h, c, p), b = [], k = [], C = void 0, S = void 0, _ = function() {
              var D = v.getIteratorNode(y);
              return S = D.prevNode, C = D.node, C;
            }; _(); )
              this.iframes && this.forEachIframe(h, function(D) {
                return v.checkIframeFilter(C, S, D, b);
              }, function(D) {
                v.createInstanceOnIframe(D).forEachNode(c, function(A) {
                  return k.push(A);
                }, p);
              }), k.push(C);
            k.forEach(function(D) {
              d(D);
            }), this.iframes && this.handleOpenIframes(b, c, d, p), g();
          }
        }, {
          key: "forEachNode",
          value: function(c, h, d) {
            var p = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, v = this.getContexts(), y = v.length;
            y || g(), v.forEach(function(b) {
              var k = function() {
                p.iterateThroughNodes(c, b, h, d, function() {
                  --y <= 0 && g();
                });
              };
              p.iframes ? p.waitForIframes(b, k) : k();
            });
          }
        }], [{
          key: "matches",
          value: function(c, h) {
            var d = typeof h == "string" ? [h] : h, p = c.matches || c.matchesSelector || c.msMatchesSelector || c.mozMatchesSelector || c.oMatchesSelector || c.webkitMatchesSelector;
            if (p) {
              var g = !1;
              return d.every(function(v) {
                return p.call(c, v) ? (g = !0, !1) : !0;
              }), g;
            } else
              return !1;
          }
        }]), u;
      })(), a = (function() {
        function u(c) {
          n(this, u), this.ctx = c, this.ie = !1;
          var h = window.navigator.userAgent;
          (h.indexOf("MSIE") > -1 || h.indexOf("Trident") > -1) && (this.ie = !0);
        }
        return i(u, [{
          key: "log",
          value: function(c) {
            var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug", d = this.opt.log;
            this.opt.debug && (typeof d > "u" ? "undefined" : r(d)) === "object" && typeof d[h] == "function" && d[h]("mark.js: " + c);
          }
        }, {
          key: "escapeStr",
          value: function(c) {
            return c.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function(c) {
            return this.opt.wildcards !== "disabled" && (c = this.setupWildcardsRegExp(c)), c = this.escapeStr(c), Object.keys(this.opt.synonyms).length && (c = this.createSynonymsRegExp(c)), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (c = this.setupIgnoreJoinersRegExp(c)), this.opt.diacritics && (c = this.createDiacriticsRegExp(c)), c = this.createMergedBlanksRegExp(c), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (c = this.createJoinersRegExp(c)), this.opt.wildcards !== "disabled" && (c = this.createWildcardsRegExp(c)), c = this.createAccuracyRegExp(c), c;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function(c) {
            var h = this.opt.synonyms, d = this.opt.caseSensitive ? "" : "i", p = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var g in h)
              if (h.hasOwnProperty(g)) {
                var v = h[g], y = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(g) : this.escapeStr(g), b = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(v) : this.escapeStr(v);
                y !== "" && b !== "" && (c = c.replace(new RegExp("(" + this.escapeStr(y) + "|" + this.escapeStr(b) + ")", "gm" + d), p + ("(" + this.processSynomyms(y) + "|") + (this.processSynomyms(b) + ")") + p));
              }
            return c;
          }
        }, {
          key: "processSynomyms",
          value: function(c) {
            return (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (c = this.setupIgnoreJoinersRegExp(c)), c;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function(c) {
            return c = c.replace(/(?:\\)*\?/g, function(h) {
              return h.charAt(0) === "\\" ? "?" : "";
            }), c.replace(/(?:\\)*\*/g, function(h) {
              return h.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function(c) {
            var h = this.opt.wildcards === "withSpaces";
            return c.replace(/\u0001/g, h ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, h ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function(c) {
            return c.replace(/[^(|)\\]/g, function(h, d, p) {
              var g = p.charAt(d + 1);
              return /[(|)\\]/.test(g) || g === "" ? h : h + "\0";
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function(c) {
            var h = [], d = this.opt.ignorePunctuation;
            return Array.isArray(d) && d.length && h.push(this.escapeStr(d.join(""))), this.opt.ignoreJoiners && h.push("\\u00ad\\u200b\\u200c\\u200d"), h.length ? c.split(/\u0000+/).join("[" + h.join("") + "]*") : c;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function(c) {
            var h = this.opt.caseSensitive ? "" : "i", d = this.opt.caseSensitive ? ["aÃ Ã¡áº£Ã£áº¡Äƒáº±áº¯áº³áºµáº·Ã¢áº§áº¥áº©áº«áº­Ã¤Ã¥ÄÄ…", "AÃ€Ãáº¢Ãƒáº Ä‚áº°áº®áº²áº´áº¶Ã‚áº¦áº¤áº¨áºªáº¬Ã„Ã…Ä€Ä„", "cÃ§Ä‡Ä", "CÃ‡Ä†ÄŒ", "dÄ‘Ä", "DÄÄŽ", "eÃ¨Ã©áº»áº½áº¹Ãªá»áº¿á»ƒá»…á»‡Ã«Ä›Ä“Ä™", "EÃˆÃ‰áººáº¼áº¸ÃŠá»€áº¾á»‚á»„á»†Ã‹ÄšÄ’Ä˜", "iÃ¬Ã­á»‰Ä©á»‹Ã®Ã¯Ä«", "IÃŒÃá»ˆÄ¨á»ŠÃŽÃÄª", "lÅ‚", "LÅ", "nÃ±ÅˆÅ„", "NÃ‘Å‡Åƒ", "oÃ²Ã³á»Ãµá»Ã´á»“á»‘á»•á»—á»™Æ¡á»Ÿá»¡á»›á»á»£Ã¶Ã¸Å", "OÃ’Ã“á»ŽÃ•á»ŒÃ”á»’á»á»”á»–á»˜Æ á»žá» á»šá»œá»¢Ã–Ã˜ÅŒ", "rÅ™", "RÅ˜", "sÅ¡Å›È™ÅŸ", "SÅ ÅšÈ˜Åž", "tÅ¥È›Å£", "TÅ¤ÈšÅ¢", "uÃ¹Ãºá»§Å©á»¥Æ°á»«á»©á»­á»¯á»±Ã»Ã¼Å¯Å«", "UÃ™Ãšá»¦Å¨á»¤Æ¯á»ªá»¨á»¬á»®á»°Ã›ÃœÅ®Åª", "yÃ½á»³á»·á»¹á»µÃ¿", "YÃá»²á»¶á»¸á»´Å¸", "zÅ¾Å¼Åº", "ZÅ½Å»Å¹"] : ["aÃ Ã¡áº£Ã£áº¡Äƒáº±áº¯áº³áºµáº·Ã¢áº§áº¥áº©áº«áº­Ã¤Ã¥ÄÄ…AÃ€Ãáº¢Ãƒáº Ä‚áº°áº®áº²áº´áº¶Ã‚áº¦áº¤áº¨áºªáº¬Ã„Ã…Ä€Ä„", "cÃ§Ä‡ÄCÃ‡Ä†ÄŒ", "dÄ‘ÄDÄÄŽ", "eÃ¨Ã©áº»áº½áº¹Ãªá»áº¿á»ƒá»…á»‡Ã«Ä›Ä“Ä™EÃˆÃ‰áººáº¼áº¸ÃŠá»€áº¾á»‚á»„á»†Ã‹ÄšÄ’Ä˜", "iÃ¬Ã­á»‰Ä©á»‹Ã®Ã¯Ä«IÃŒÃá»ˆÄ¨á»ŠÃŽÃÄª", "lÅ‚LÅ", "nÃ±ÅˆÅ„NÃ‘Å‡Åƒ", "oÃ²Ã³á»Ãµá»Ã´á»“á»‘á»•á»—á»™Æ¡á»Ÿá»¡á»›á»á»£Ã¶Ã¸ÅOÃ’Ã“á»ŽÃ•á»ŒÃ”á»’á»á»”á»–á»˜Æ á»žá» á»šá»œá»¢Ã–Ã˜ÅŒ", "rÅ™RÅ˜", "sÅ¡Å›È™ÅŸSÅ ÅšÈ˜Åž", "tÅ¥È›Å£TÅ¤ÈšÅ¢", "uÃ¹Ãºá»§Å©á»¥Æ°á»«á»©á»­á»¯á»±Ã»Ã¼Å¯Å«UÃ™Ãšá»¦Å¨á»¤Æ¯á»ªá»¨á»¬á»®á»°Ã›ÃœÅ®Åª", "yÃ½á»³á»·á»¹á»µÃ¿YÃá»²á»¶á»¸á»´Å¸", "zÅ¾Å¼ÅºZÅ½Å»Å¹"], p = [];
            return c.split("").forEach(function(g) {
              d.every(function(v) {
                if (v.indexOf(g) !== -1) {
                  if (p.indexOf(v) > -1)
                    return !1;
                  c = c.replace(new RegExp("[" + v + "]", "gm" + h), "[" + v + "]"), p.push(v);
                }
                return !0;
              });
            }), c;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function(c) {
            return c.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function(c) {
            var h = this, d = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~Â¡Â¿", p = this.opt.accuracy, g = typeof p == "string" ? p : p.value, v = typeof p == "string" ? [] : p.limiters, y = "";
            switch (v.forEach(function(b) {
              y += "|" + h.escapeStr(b);
            }), g) {
              case "partially":
              default:
                return "()(" + c + ")";
              case "complementary":
                return y = "\\s" + (y || this.escapeStr(d)), "()([^" + y + "]*" + c + "[^" + y + "]*)";
              case "exactly":
                return "(^|\\s" + y + ")(" + c + ")(?=$|\\s" + y + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function(c) {
            var h = this, d = [];
            return c.forEach(function(p) {
              h.opt.separateWordSearch ? p.split(" ").forEach(function(g) {
                g.trim() && d.indexOf(g) === -1 && d.push(g);
              }) : p.trim() && d.indexOf(p) === -1 && d.push(p);
            }), {
              keywords: d.sort(function(p, g) {
                return g.length - p.length;
              }),
              length: d.length
            };
          }
        }, {
          key: "isNumeric",
          value: function(c) {
            return Number(parseFloat(c)) == c;
          }
        }, {
          key: "checkRanges",
          value: function(c) {
            var h = this;
            if (!Array.isArray(c) || Object.prototype.toString.call(c[0]) !== "[object Object]")
              return this.log("markRanges() will only accept an array of objects"), this.opt.noMatch(c), [];
            var d = [], p = 0;
            return c.sort(function(g, v) {
              return g.start - v.start;
            }).forEach(function(g) {
              var v = h.callNoMatchOnInvalidRanges(g, p), y = v.start, b = v.end, k = v.valid;
              k && (g.start = y, g.length = b - y, d.push(g), p = b);
            }), d;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function(c, h) {
            var d = void 0, p = void 0, g = !1;
            return c && typeof c.start < "u" ? (d = parseInt(c.start, 10), p = d + parseInt(c.length, 10), this.isNumeric(c.start) && this.isNumeric(c.length) && p - h > 0 && p - d > 0 ? g = !0 : (this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(c))), this.opt.noMatch(c))) : (this.log("Ignoring invalid range: " + JSON.stringify(c)), this.opt.noMatch(c)), {
              start: d,
              end: p,
              valid: g
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function(c, h, d) {
            var p = void 0, g = !0, v = d.length, y = h - v, b = parseInt(c.start, 10) - y;
            return b = b > v ? v : b, p = b + parseInt(c.length, 10), p > v && (p = v, this.log("End range automatically set to the max value of " + v)), b < 0 || p - b < 0 || b > v || p > v ? (g = !1, this.log("Invalid range: " + JSON.stringify(c)), this.opt.noMatch(c)) : d.substring(b, p).replace(/\s+/g, "") === "" && (g = !1, this.log("Skipping whitespace only range: " + JSON.stringify(c)), this.opt.noMatch(c)), {
              start: b,
              end: p,
              valid: g
            };
          }
        }, {
          key: "getTextNodes",
          value: function(c) {
            var h = this, d = "", p = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(g) {
              p.push({
                start: d.length,
                end: (d += g.textContent).length,
                node: g
              });
            }, function(g) {
              return h.matchesExclude(g.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, function() {
              c({
                value: d,
                nodes: p
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function(c) {
            return s.matches(c, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function(c, h, d) {
            var p = this.opt.element ? this.opt.element : "mark", g = c.splitText(h), v = g.splitText(d - h), y = document.createElement(p);
            return y.setAttribute("data-markjs", "true"), this.opt.className && y.setAttribute("class", this.opt.className), y.textContent = g.textContent, g.parentNode.replaceChild(y, g), v;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function(c, h, d, p, g) {
            var v = this;
            c.nodes.every(function(y, b) {
              var k = c.nodes[b + 1];
              if (typeof k > "u" || k.start > h) {
                if (!p(y.node))
                  return !1;
                var C = h - y.start, S = (d > y.end ? y.end : d) - y.start, _ = c.value.substr(0, y.start), D = c.value.substr(S + y.start);
                if (y.node = v.wrapRangeInTextNode(y.node, C, S), c.value = _ + D, c.nodes.forEach(function(A, O) {
                  O >= b && (c.nodes[O].start > 0 && O !== b && (c.nodes[O].start -= S), c.nodes[O].end -= S);
                }), d -= S, g(y.node.previousSibling, y.start), d > y.end)
                  h = y.end;
                else
                  return !1;
              }
              return !0;
            });
          }
        }, {
          key: "wrapMatches",
          value: function(c, h, d, p, g) {
            var v = this, y = h === 0 ? 0 : h + 1;
            this.getTextNodes(function(b) {
              b.nodes.forEach(function(k) {
                k = k.node;
                for (var C = void 0; (C = c.exec(k.textContent)) !== null && C[y] !== ""; )
                  if (d(C[y], k)) {
                    var S = C.index;
                    if (y !== 0)
                      for (var _ = 1; _ < y; _++)
                        S += C[_].length;
                    k = v.wrapRangeInTextNode(k, S, S + C[y].length), p(k.previousSibling), c.lastIndex = 0;
                  }
              }), g();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function(c, h, d, p, g) {
            var v = this, y = h === 0 ? 0 : h + 1;
            this.getTextNodes(function(b) {
              for (var k = void 0; (k = c.exec(b.value)) !== null && k[y] !== ""; ) {
                var C = k.index;
                if (y !== 0)
                  for (var S = 1; S < y; S++)
                    C += k[S].length;
                var _ = C + k[y].length;
                v.wrapRangeInMappedTextNode(b, C, _, function(D) {
                  return d(k[y], D);
                }, function(D, A) {
                  c.lastIndex = A, p(D);
                });
              }
              g();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function(c, h, d, p) {
            var g = this;
            this.getTextNodes(function(v) {
              var y = v.value.length;
              c.forEach(function(b, k) {
                var C = g.checkWhitespaceRanges(b, y, v.value), S = C.start, _ = C.end, D = C.valid;
                D && g.wrapRangeInMappedTextNode(v, S, _, function(A) {
                  return h(A, b, v.value.substring(S, _), k);
                }, function(A) {
                  d(A, b);
                });
              }), p();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function(c) {
            for (var h = c.parentNode, d = document.createDocumentFragment(); c.firstChild; )
              d.appendChild(c.removeChild(c.firstChild));
            h.replaceChild(d, c), this.ie ? this.normalizeTextNode(h) : h.normalize();
          }
        }, {
          key: "normalizeTextNode",
          value: function(c) {
            if (c) {
              if (c.nodeType === 3)
                for (; c.nextSibling && c.nextSibling.nodeType === 3; )
                  c.nodeValue += c.nextSibling.nodeValue, c.parentNode.removeChild(c.nextSibling);
              else
                this.normalizeTextNode(c.firstChild);
              this.normalizeTextNode(c.nextSibling);
            }
          }
        }, {
          key: "markRegExp",
          value: function(c, h) {
            var d = this;
            this.opt = h, this.log('Searching with expression "' + c + '"');
            var p = 0, g = "wrapMatches", v = function(y) {
              p++, d.opt.each(y);
            };
            this.opt.acrossElements && (g = "wrapMatchesAcrossElements"), this[g](c, this.opt.ignoreGroups, function(y, b) {
              return d.opt.filter(b, y, p);
            }, v, function() {
              p === 0 && d.opt.noMatch(c), d.opt.done(p);
            });
          }
        }, {
          key: "mark",
          value: function(c, h) {
            var d = this;
            this.opt = h;
            var p = 0, g = "wrapMatches", v = this.getSeparatedKeywords(typeof c == "string" ? [c] : c), y = v.keywords, b = v.length, k = this.opt.caseSensitive ? "" : "i", C = function S(_) {
              var D = new RegExp(d.createRegExp(_), "gm" + k), A = 0;
              d.log('Searching with expression "' + D + '"'), d[g](D, 1, function(O, M) {
                return d.opt.filter(M, _, p, A);
              }, function(O) {
                A++, p++, d.opt.each(O);
              }, function() {
                A === 0 && d.opt.noMatch(_), y[b - 1] === _ ? d.opt.done(p) : S(y[y.indexOf(_) + 1]);
              });
            };
            this.opt.acrossElements && (g = "wrapMatchesAcrossElements"), b === 0 ? this.opt.done(p) : C(y[0]);
          }
        }, {
          key: "markRanges",
          value: function(c, h) {
            var d = this;
            this.opt = h;
            var p = 0, g = this.checkRanges(c);
            g && g.length ? (this.log("Starting to mark with the following ranges: " + JSON.stringify(g)), this.wrapRangeFromIndex(g, function(v, y, b, k) {
              return d.opt.filter(v, y, b, k);
            }, function(v, y) {
              p++, d.opt.each(v, y);
            }, function() {
              d.opt.done(p);
            })) : this.opt.done(p);
          }
        }, {
          key: "unmark",
          value: function(c) {
            var h = this;
            this.opt = c;
            var d = this.opt.element ? this.opt.element : "*";
            d += "[data-markjs]", this.opt.className && (d += "." + this.opt.className), this.log('Removal selector "' + d + '"'), this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(p) {
              h.unwrapMatches(p);
            }, function(p) {
              var g = s.matches(p, d), v = h.matchesExclude(p);
              return !g || v ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function(c) {
            this._opt = o({}, {
              element: "",
              className: "",
              exclude: [],
              iframes: !1,
              iframesTimeout: 5e3,
              separateWordSearch: !0,
              diacritics: !0,
              synonyms: {},
              accuracy: "partially",
              acrossElements: !1,
              caseSensitive: !1,
              ignoreJoiners: !1,
              ignoreGroups: 0,
              ignorePunctuation: [],
              wildcards: "disabled",
              each: function() {
              },
              noMatch: function() {
              },
              filter: function() {
                return !0;
              },
              done: function() {
              },
              debug: !1,
              log: window.console
            }, c);
          },
          get: function() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function() {
            return new s(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]), u;
      })();
      function l(u) {
        var c = this, h = new a(u);
        return this.mark = function(d, p) {
          return h.mark(d, p), c;
        }, this.markRegExp = function(d, p) {
          return h.markRegExp(d, p), c;
        }, this.markRanges = function(d, p) {
          return h.markRanges(d, p), c;
        }, this.unmark = function(d) {
          return h.unmark(d), c;
        }, this;
      }
      return l;
    }));
  })(D_)), D_.exports;
}
var b_e = y_e();
const x_e = /* @__PURE__ */ Lh(b_e);
var w_e = /* @__PURE__ */ me('<div class="flex pb-1 text-sm"><span class="px-2 flex gap-2 bg-slate-200 text-slate-500 dark:bg-slate-600 dark:text-slate-300 rounded-md"><div class="text-slate-400 dark:text-slate-400 font-medium">Distance</div> <div class="text-ellipsis whitespace-nowrap overflow-hidden max-w-72"> </div></span></div>'), k_e = /* @__PURE__ */ me('<button class="m-1 p-2 text-left rounded-md hover:outline outline-slate-500"><!> <div class="overflow-hidden text-ellipsis line-clamp-4 leading-5"><!></div></button> <hr class="border-slate-300 dark:border-slate-600"/>', 1), C_e = /* @__PURE__ */ me('<div class="flex flex-col w-full h-full"><div class="ml-3 mr-2 my-1 flex items-center text-slate-400 dark:text-slate-500 items-start"><div class="flex-1"><div> </div> <div> </div></div> <div class="flex-none mt-1"><button class="block hover:text-slate-500 dark:hover:text-slate-400"><!></button></div></div> <hr class="border-slate-300 dark:border-slate-600"/> <div class="flex flex-col overflow-x-hidden overflow-y-scroll"></div></div>');
function __e(t, e) {
  nt(e, !0);
  let r = ct(e, "limit", 3, 100);
  function n(y, b) {
    new x_e(y).mark(b);
  }
  let i = /* @__PURE__ */ K(() => e.items.length == 0 ? "No result found." : e.items.length == 1 ? `${e.items.length.toLocaleString()} result.` : e.items.length >= r() ? `More than ${e.items.length.toLocaleString()} results, showing top ${r().toLocaleString()}.` : `${e.items.length.toLocaleString()} results.`);
  var o = C_e(), s = Y(o), a = Y(s), l = Y(a), u = Y(l, !0);
  J(l);
  var c = ae(l, 2), h = Y(c, !0);
  J(c), J(a);
  var d = ae(a, 2), p = Y(d);
  p.__click = () => {
    e.onClose?.();
  };
  var g = Y(p);
  mx(g, {}), J(p), J(d), J(s);
  var v = ae(s, 4);
  Nt(v, 20, () => e.items, (y) => y, (y, b) => {
    var k = k_e(), C = Ve(k);
    C.__click = () => {
      e.onClick?.(b);
    };
    var S = Y(C);
    {
      var _ = (O) => {
        var M = w_e(), z = Y(M), R = ae(Y(z), 2), N = Y(R, !0);
        J(R), J(z), J(M), Ae((I) => ut(N, I), [() => b.distance.toFixed(5)]), X(O, M);
      };
      Oe(S, (O) => {
        b.distance != null && O(_);
      });
    }
    var D = ae(S, 2), A = Y(D);
    {
      let O = /* @__PURE__ */ K(() => e.columnStyles ?? {});
      GL(A, {
        get values() {
          return b.fields;
        },
        get columnStyles() {
          return x(O);
        }
      });
    }
    J(D), To(D, (O, M) => n?.(O, M), () => e.highlight), J(C), q_(2), X(y, k);
  }), J(v), J(o), Ae(() => {
    ut(u, e.label), ut(h, x(i));
  }), X(t, o), it();
}
nn(["click"]);
var S_e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z" opacity=".25"></path><path fill="currentColor" d="M10.72,19.9a8,8,0,0,1-6.5-9.79A7.77,7.77,0,0,1,10.4,4.16a8,8,0,0,1,9.49,6.52A1.54,1.54,0,0,0,21.38,12h.13a1.37,1.37,0,0,0,1.38-1.54,11,11,0,1,0-12.7,12.39A1.54,1.54,0,0,0,12,21.34h0A1.47,1.47,0,0,0,10.72,19.9Z"><animateTransform attributeName="transform" dur="0.75s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"></animateTransform></path></svg>');
function cj(t, e) {
  const r = /* @__PURE__ */ zn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = S_e();
  Qo(n, () => ({ viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ...r })), X(t, n);
}
function kF(t, e) {
  nt(e, !0);
  let r = ct(e, "label", 3, null), n = ct(e, "icon", 3, null), i = ct(e, "title", 3, ""), o = ct(e, "order", 3, null), s = /* @__PURE__ */ De("ready");
  async function a() {
    if (e.onClick) {
      ue(s, "running");
      try {
        await e.onClick(), ue(s, "ready");
      } catch {
        ue(s, "error");
      }
    }
  }
  {
    let l = /* @__PURE__ */ K(() => x(s) == "ready" ? n() : x(s) == "running" ? cj : mx);
    Tu(t, {
      get label() {
        return r();
      },
      get icon() {
        return x(l);
      },
      get title() {
        return i();
      },
      get order() {
        return o();
      },
      get class() {
        return e.class;
      },
      onClick: a
    });
  }
  it();
}
var A_e = /* @__PURE__ */ me('<span class="pl-2 text-slate-500 dark:text-slate-500"> </span>'), E_e = /* @__PURE__ */ me('<div role="status" class="flex flex-row items-center"><!> <!></div>');
function D_e(t, e) {
  let r = ct(e, "status", 3, "Loading...");
  var n = E_e(), i = Y(n);
  cj(i, { class: "text-blue-500" });
  var o = ae(i, 2);
  {
    var s = (a) => {
      var l = A_e(), u = Y(l, !0);
      J(l), Ae(() => ut(u, r())), X(a, l);
    };
    Oe(o, (a) => {
      r() != null && a(s);
    });
  }
  J(n), X(t, n);
}
class O_e {
  contents;
  constructor() {
    this.contents = /* @__PURE__ */ new Map();
  }
  get(e) {
    return this.contents.get(e) ?? null;
  }
  set(e, r) {
    this.contents.set(e, r);
  }
  value(e, r) {
    if (this.contents.has(e))
      return this.contents.get(e);
    const n = r();
    return this.contents.set(e, n), n;
  }
}
async function F_e(t, e, r, n = {}) {
  let i = n.exclude ?? [], o = (await OL(t, e)).filter((a) => !a.name.startsWith("__")), s = [];
  n?.projection != null && s.push({
    type: "embedding",
    title: "Embedding",
    data: {
      x: n.projection.x,
      y: n.projection.y,
      text: n.projection.text
    }
  }), s.push({ type: "predicates", title: "SQL Predicates" }), s.push({ type: "table", title: "Table", columns: o.map((a) => a.name) });
  for (let a of o) {
    if (a.jsType == null || i.indexOf(a.name) >= 0)
      continue;
    let l = await FL(t, e, a.name);
    if (!(l <= 1))
      switch (a.jsType) {
        case "string":
          l <= 1e3 && s.push({
            type: "count-plot",
            title: a.name,
            data: { field: a.name }
          });
          break;
        case "string[]":
          s.push({
            type: "count-plot-list",
            title: a.name,
            data: { field: a.name }
          });
          break;
        case "number":
          l <= 10 ? s.push({
            type: "count-plot",
            title: a.name,
            data: { field: a.name }
          }) : s.push({
            type: "histogram",
            title: a.name,
            data: { field: a.name },
            binCount: 20
          });
          break;
      }
  }
  return s;
}
const CF = "0.12.0";
class T_e {
  worker;
  callbacks;
  constructor() {
    this.worker = new Worker(new URL("./search.worker.js", import.meta.url), { type: "module" }), this.callbacks = /* @__PURE__ */ new Map(), this.worker.onmessage = (e) => {
      let r = this.callbacks.get(e.data.identifier);
      r != null && (this.callbacks.delete(e.data.identifier), r(e.data));
    };
  }
  rpc(e) {
    return new Promise((r, n) => {
      let i = (/* @__PURE__ */ new Date()).getTime() + "-" + Math.random();
      this.callbacks.set(i, r), this.worker.postMessage({ ...e, identifier: i });
    });
  }
  async clear() {
    await this.rpc({ type: "clear" });
  }
  async addPoints(e) {
    await this.rpc({ type: "points", points: e });
  }
  async query(e, r) {
    return (await this.rpc({ type: "query", query: e, limit: r })).result;
  }
}
class M_e {
  coordinator;
  table;
  columns;
  backend;
  currentIndex = null;
  constructor(e, r, n) {
    this.coordinator = e, this.table = r, this.columns = n, this.currentIndex = null, this.backend = new T_e();
  }
  predicateString(e) {
    return e != null && e.toString() != "" ? e.toString() : null;
  }
  async buildIndexIfNeeded(e) {
    let r = this.predicateString(e);
    if (this.currentIndex != null && this.currentIndex.predicate == r)
      return;
    let n;
    r != null ? n = await this.coordinator.query(`
        SELECT
          ${T.column(this.columns.id)} AS id,
          ${T.column(this.columns.text)} AS text
        FROM ${this.table}
        WHERE ${r}
      `) : n = await this.coordinator.query(`
        SELECT
          ${T.column(this.columns.id)} AS id,
          ${T.column(this.columns.text)} AS text
        FROM ${this.table}
      `), await this.backend.clear(), await this.backend.addPoints(Array.from(n)), this.currentIndex = { predicate: r };
  }
  async fullTextSearch(e, r = {}) {
    let n = r.limit ?? 100, i = r.predicate;
    return await this.buildIndexIfNeeded(i), (await this.backend.query(e, n)).map((o) => ({ id: o }));
  }
}
async function P_e(t, e, r, n, i, o) {
  let s = [`${T.column(r.id, e)} AS id`];
  r.x && s.push(`${T.column(r.x, e)} AS x`), r.y && s.push(`${T.column(r.y, e)} AS y`), r.text && s.push(`${T.column(r.text, e)} AS text`);
  let a = n ?? {};
  for (let p in a) {
    let g = a[p];
    typeof g == "string" ? s.push(`${T.column(g, e)} AS "field_${p}"`) : s.push(`${T.sql(g.sql)} AS "field_${p}"`);
  }
  let l = o.map((p) => p.id), u = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
  for (let p = 0; p < l.length; p++)
    u.set(l[p], p), c.set(l[p], o[p]);
  let h = await t.query(`
    SELECT
      ${s.join(", ")}
    FROM (
      SELECT ${T.column(r.id, e)} AS __search_result_id__
      FROM ${e}
      WHERE
        ${T.column(r.id, e)} IN [${l.map((p) => T.literal(p)).join(", ")}]
        ${i ? `AND (${i})` : ""}
    )
    LEFT JOIN ${e} ON ${T.column(r.id, e)} = __search_result_id__
  `), d = Array.from(h).map((p) => {
    let g = { id: p.id, distance: c.get(p.id)?.distance, fields: {} };
    for (let v in p)
      v.startsWith("field_") ? g.fields[v.substring(6)] = p[v] : g[v] = p[v];
    return g;
  });
  return d = d.sort((p, g) => (u.get(p.id) ?? 0) - (u.get(g.id) ?? 0)), d;
}
function R_e(t) {
  let { coordinator: e, table: r, idColumn: n, searcher: i, textColumn: o, neighborsColumn: s } = t, a = {};
  if (i != null && i.fullTextSearch != null)
    a.fullTextSearch = i.fullTextSearch.bind(i);
  else if (o != null) {
    let l = new M_e(e, r, { id: n, text: o });
    a.fullTextSearch = l.fullTextSearch.bind(l);
  }
  return i != null && i.vectorSearch != null && (a.vectorSearch = i.vectorSearch.bind(i)), i != null && i.nearestNeighbors != null ? a.nearestNeighbors = i.nearestNeighbors.bind(i) : s != null && (a.nearestNeighbors = async (l) => {
    let u = T.Query.from(r).select({ knn: T.column(s) }).where(T.eq(T.column(n), T.literal(l))), c = await e.query(u), h = Array.from(c);
    if (h.length != 1)
      return [];
    let { distances: d, ids: p } = h[0].knn;
    return Array.from(p).map((g, v) => ({ id: g, distance: d[v] })).filter((g) => g.id != l);
  }), a;
}
let hj = typeof window < "u" ? window.matchMedia?.("(prefers-color-scheme: dark)") : null, fj = qf(hj?.matches ? "dark" : "light");
hj?.addEventListener("change", (t) => {
  fj.set(t.matches ? "dark" : "light");
});
function N_e() {
  let t = qf(null);
  return { colorScheme: nX([fj, t], ([e, r]) => r ?? e), userColorScheme: t };
}
var $_e = /* @__PURE__ */ me('<div class="p-2"><!></div>'), I_e = /* @__PURE__ */ me('<div class="absolute w-96 left-0 top-[32px] rounded-md right-0 z-20 border border-slate-300 dark:border-slate-600 overflow-hidden resize shadow-lg bg-white/75 dark:bg-slate-800/75 backdrop-blur-sm"><!></div>'), B_e = /* @__PURE__ */ me('<div class="relative w-full"><!> <!> <!></div>'), L_e = /* @__PURE__ */ me('<div class="text-slate-500 dark:text-slate-400">Embedding Atlas</div>'), z_e = /* @__PURE__ */ me('<h4 class="text-slate-500 dark:text-slate-400 select-none">Column Styles</h4> <!>', 1), j_e = /* @__PURE__ */ me('<div class="flex flex-row gap-2"><!> <!></div>'), q_e = /* @__PURE__ */ me('<div class="min-w-[420px] flex flex-col gap-2"><!> <h4 class="text-slate-500 dark:text-slate-400 select-none">Export</h4> <div class="flex flex-col gap-2"><!> <!></div> <h4 class="text-slate-500 dark:text-slate-400 select-none">About</h4> <div> </div></div>'), U_e = /* @__PURE__ */ me('<div class="embedding-atlas-root"><div><div class="m-2 flex flex-row items-center gap-2 flex-wrap"><div class="flex flex-row flex-1 justify-between min-w-[180px]"><!></div> <div class="flex flex-none gap-2 items-center"><!> <div class="flex flex-row gap-1 items-center"><button class="flex px-2.5 mr-1 select-none items-center justify-center text-slate-500 dark:text-slate-300 rounded-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 focus-visible:outline-2 outline-blue-600 -outline-offset-1" title="Clear filters">Clear</button></div></div> <div class="flex flex-none flex-row gap-0.5"><!> <!> <!></div></div> <div class="flex-1 overflow-hidden h-full ml-2 mr-2 mb-2"><!></div></div></div>');
function H_e(t, e) {
  nt(e, !0);
  const r = () => mi(u, "$colorScheme", i), n = () => mi(b, "$resolvedColumnStyles", i), [i, o] = Xo(), s = 500;
  let a = ct(e, "embeddingViewConfig", 3, null), l = ct(e, "embeddingViewLabels", 3, null);
  const { colorScheme: u, userColorScheme: c } = N_e();
  mt(() => {
    wD(c, e.colorScheme);
  });
  let h = /* @__PURE__ */ De(!1), d = /* @__PURE__ */ De("parquet");
  const p = vK.crossfilter();
  function g() {
    return DL(p.predicate(null));
  }
  let v = /* @__PURE__ */ De([]), y = /* @__PURE__ */ De({}), b = qf({});
  mt(() => {
    let Fe = k(x(v), x(y));
    b.set(Fe);
  });
  function k(Fe, $e) {
    let lt = {};
    for (let kt of Fe) {
      let pr = $e[kt.name];
      pr == null && (pr = { display: e.data.text == kt.name ? "full" : "badge" }), lt[kt.name] = pr;
    }
    return lt;
  }
  let C = R_e({
    coordinator: e.coordinator,
    table: e.data.table,
    idColumn: e.data.id,
    textColumn: e.data.text,
    neighborsColumn: e.data.neighbors,
    searcher: e.searcher
  }), S = [
    ...C.fullTextSearch != null ? ["full-text"] : [],
    ...C.vectorSearch != null ? ["vector"] : [],
    ...C.nearestNeighbors != null ? ["neighbors"] : []
  ];
  const _ = {
    "full-text": { value: "full-text", label: "Full Text" },
    vector: { value: "vector", label: "Vector" },
    neighbors: { value: "neighbors", label: "Neighbors" }
  };
  let D = /* @__PURE__ */ De("full-text"), A = /* @__PURE__ */ De(""), O = /* @__PURE__ */ De(""), M = /* @__PURE__ */ De(!1), z = /* @__PURE__ */ De(null), R = qf(null);
  async function N(Fe, $e) {
    if (C == null || S.indexOf($e) < 0) {
      B();
      return;
    }
    ue(M, !0), ue(O, "Searching...");
    let lt = g(), kt = [], pr = "", Zr = Fe.toString();
    $e == "full-text" && C.fullTextSearch != null ? (Fe = Fe.trim(), kt = await C.fullTextSearch(Fe, {
      limit: s,
      predicate: lt,
      onStatus: (Je) => {
        ue(O, Je, !0);
      }
    }), pr = Fe) : $e == "vector" && C.vectorSearch != null ? (Fe = Fe.trim(), kt = await C.vectorSearch(Fe, {
      limit: s,
      predicate: lt,
      onStatus: (Je) => {
        ue(O, Je, !0);
      }
    }), pr = Fe) : $e == "neighbors" && C.nearestNeighbors != null && (Zr = "Neighbors of #" + Fe.toString(), kt = await C.nearestNeighbors(Fe, {
      limit: s,
      predicate: lt,
      onStatus: (Je) => {
        ue(O, Je, !0);
      }
    }));
    let Kt = await P_e(
      e.coordinator,
      e.data.table,
      {
        id: e.data.id,
        x: e.data.projection?.x,
        y: e.data.projection?.y,
        text: e.data.text
      },
      Object.fromEntries(x(v).map((Je) => [Je.name, Je.name])),
      lt,
      kt
    );
    ue(O, ""), ue(z, { label: Zr, highlight: pr, items: Kt }), R.set({ query: Fe, mode: $e, ids: Kt.map((Je) => Je.id) });
  }
  const I = EK(N, 500);
  function B() {
    ue(z, null), R.set(null), ue(M, !1);
  }
  mt(() => {
    x(A) == "" ? B() : I(x(A), x(D));
  });
  function $() {
    for (let Fe of p.clauses)
      Fe.source?.reset?.(), p.update({ ...Fe, value: null, predicate: null });
  }
  function q(Fe) {
    typeof Fe.version == "string" && (ue(G, Fe.charts ?? {}), ue(re, Fe.chartStates ?? {}), ue(ie, Fe.layout ?? "list"), ue(se, Fe.layoutStates ?? {}));
  }
  Vs(() => {
    if (!x(h))
      return;
    let Fe = {
      version: CF,
      timestamp: (/* @__PURE__ */ new Date()).getTime() / 1e3,
      charts: x(G),
      chartStates: x(re),
      layout: x(ie),
      layoutStates: x(se),
      predicate: g()
    };
    e.onStateChange?.(Fe);
  }), Kg(async () => {
    let Fe = [e.data.projection?.x, e.data.projection?.y].filter(($e) => $e != null);
    if (ue(v, (await OL(e.coordinator, e.data.table)).filter(($e) => !$e.name.startsWith("__"))), H.columns = x(v), e.initialState && q(e.initialState), Object.keys(x(G)).length == 0) {
      let $e = await F_e(e.coordinator, e.data.table, e.data.id, {
        exclude: Fe,
        projection: e.data.projection ? {
          ...e.data.projection,
          text: e.data.text ?? void 0
        } : void 0
      });
      ue(G, Object.fromEntries($e.map((lt, kt) => [`${kt + 1}`, lt])));
    }
    ue(h, !0);
  });
  function U(Fe) {
    if (Fe.key == "Escape") {
      $(), Fe.preventDefault();
      try {
        document.activeElement?.blur?.();
      } catch {
      }
    }
  }
  let H = {
    coordinator: e.coordinator,
    filter: p,
    table: e.data.table,
    id: e.data.id,
    columns: [],
    colorScheme: u,
    columnStyles: b,
    cache: new O_e(),
    persistentCache: e.cache ?? { get: async () => null, set: async (Fe, $e) => {
    } },
    searchModes: S,
    search: N,
    searchResult: R,
    highlight: qf(null),
    embeddingViewConfig: a(),
    embeddingViewLabels: l(),
    tableCellRenderers: e.tableCellRenderers
  }, G = /* @__PURE__ */ De({}), re = /* @__PURE__ */ De({}), ie = /* @__PURE__ */ De("list"), se = /* @__PURE__ */ De({});
  var ne = U_e();
  EQ("keydown", a3, U), ft(ne, "", {}, { width: "100%", height: "100%" });
  var ce = Y(ne);
  let Ce, Pe;
  var Me = Y(ce), _e = Y(Me), he = Y(_e);
  {
    var ke = (Fe) => {
      var $e = B_e(), lt = Y($e);
      ML(lt, {
        type: "search",
        placeholder: "Search...",
        className: "w-full max-w-[400px] ",
        get value() {
          return x(A);
        },
        set value(Je) {
          ue(A, Je, !0);
        }
      });
      var kt = ae(lt, 2);
      {
        var pr = (Je) => {
          {
            let mr = /* @__PURE__ */ K(() => S.filter((en) => en != "neighbors").map((en) => _[en]));
            Dh(Je, {
              get options() {
                return x(mr);
              },
              get value() {
                return x(D);
              },
              onChange: (en) => ue(D, en, !0)
            });
          }
        };
        Oe(kt, (Je) => {
          S.filter((mr) => mr != "neighbors").length > 1 && Je(pr);
        });
      }
      var Zr = ae(kt, 2);
      {
        var Kt = (Je) => {
          var mr = I_e();
          ft(mr, "", {}, { height: "48em" });
          var en = Y(mr);
          {
            var xi = (Br) => {
              __e(Br, {
                get items() {
                  return x(z).items;
                },
                get label() {
                  return x(z).label;
                },
                get highlight() {
                  return x(z).highlight;
                },
                limit: s,
                onClick: async (qn) => {
                  H.highlight.set(qn.id);
                },
                onClose: B,
                get columnStyles() {
                  return n();
                }
              });
            }, pl = (Br) => {
              var qn = kr(), vo = Ve(qn);
              {
                var la = (Ss) => {
                  var As = $_e(), xc = Y(As);
                  D_e(xc, {
                    get status() {
                      return x(O);
                    }
                  }), J(As), X(Ss, As);
                };
                Oe(
                  vo,
                  (Ss) => {
                    x(O) != null && Ss(la);
                  },
                  !0
                );
              }
              X(Br, qn);
            };
            Oe(en, (Br) => {
              x(z) != null ? Br(xi) : Br(pl, !1);
            });
          }
          J(mr), X(Je, mr);
        };
        Oe(Zr, (Je) => {
          x(M) && Je(Kt);
        });
      }
      J($e), X(Fe, $e);
    }, ve = (Fe) => {
      var $e = L_e();
      X(Fe, $e);
    };
    Oe(he, (Fe) => {
      C ? Fe(ke) : Fe(ve, !1);
    });
  }
  J(_e);
  var We = ae(_e, 2), Qe = Y(We);
  g_e(Qe, {
    get coordinator() {
      return e.coordinator;
    },
    get filter() {
      return p;
    },
    get table() {
      return e.data.table;
    }
  });
  var ot = ae(Qe, 2), Ye = Y(ot);
  Ye.__click = $, J(ot), J(We);
  var Ht = ae(We, 2), St = Y(Ht);
  oz(St, {
    get icon() {
      return BI;
    },
    title: "Options",
    children: (Fe, $e) => {
      var lt = q_e(), kt = Y(lt);
      {
        var pr = (Br) => {
          var qn = z_e(), vo = ae(Ve(qn), 2);
          p_e(vo, {
            get columns() {
              return x(v);
            },
            get styles() {
              return n();
            },
            onStylesChange: (la) => {
              ue(y, la);
            }
          }), X(Br, qn);
        };
        Oe(kt, (Br) => {
          x(v).length > 0 && Br(pr);
        });
      }
      var Zr = ae(kt, 4), Kt = Y(Zr);
      {
        var Je = (Br) => {
          var qn = j_e(), vo = Y(qn);
          kF(vo, {
            get icon() {
              return h9;
            },
            label: "Export Selection",
            title: "Export the selected points",
            class: "w-48",
            onClick: () => e.onExportSelection(g(), x(d))
          });
          var la = ae(vo, 2);
          Dh(la, {
            label: "Format",
            get value() {
              return x(d);
            },
            onChange: (Ss) => ue(d, Ss, !0),
            options: [
              { value: "parquet", label: "Parquet" },
              { value: "jsonl", label: "JSONL" },
              { value: "json", label: "JSON" },
              { value: "csv", label: "CSV" }
            ]
          }), J(qn), X(Br, qn);
        };
        Oe(Kt, (Br) => {
          e.onExportSelection && Br(Je);
        });
      }
      var mr = ae(Kt, 2);
      {
        var en = (Br) => {
          kF(Br, {
            get icon() {
              return h9;
            },
            label: "Export Application",
            title: "Download a self-contained static web application",
            class: "w-48",
            get onClick() {
              return e.onExportApplication;
            }
          });
        };
        Oe(mr, (Br) => {
          e.onExportApplication && Br(en);
        });
      }
      J(Zr);
      var xi = ae(Zr, 4), pl = Y(xi);
      J(xi), J(lt), Ae(() => ut(pl, `Embedding Atlas, ${CF}`)), X(Fe, lt);
    },
    $$slots: { default: !0 }
  });
  var Gt = ae(St, 2);
  {
    var $t = (Fe) => {
      {
        let $e = /* @__PURE__ */ K(() => r() == "dark" ? Xpe : Kpe);
        Tu(Fe, {
          get icon() {
            return x($e);
          },
          title: "Toggle dark mode",
          onClick: () => {
            wD(c, r() == "light" ? "dark" : "light");
          }
        });
      }
    };
    Oe(Gt, (Fe) => {
      e.colorScheme == null && Fe($t);
    });
  }
  var Ge = ae(Gt, 2);
  bme(Ge, {
    get context() {
      return H;
    },
    get charts() {
      return x(G);
    },
    get chartStates() {
      return x(re);
    },
    get layout() {
      return x(ie);
    },
    get layoutStates() {
      return x(se);
    },
    onChartsChange: (Fe) => ue(G, Fe),
    onChartStatesChange: (Fe) => ue(re, Fe),
    onLayoutStatesChange: (Fe) => ue(se, Fe)
  }), J(Ht), J(Me);
  var Ze = ae(Me, 2), It = Y(Ze);
  {
    var rr = (Fe) => {
      c_e(Fe, {
        get context() {
          return H;
        },
        get layout() {
          return x(ie);
        },
        get layoutStates() {
          return x(se);
        },
        get charts() {
          return x(G);
        },
        get chartStates() {
          return x(re);
        },
        onChartsChange: ($e) => ue(G, $e),
        onChartStatesChange: ($e) => ue(re, $e),
        onLayoutStatesChange: ($e) => ue(se, $e)
      });
    };
    Oe(It, (Fe) => {
      x(h) && Fe(rr);
    });
  }
  J(Ze), J(ce), J(ne), Ae(() => {
    Ce = Yr(ce, 1, "w-full h-full flex flex-col text-slate-800 bg-slate-200 dark:text-slate-200 dark:bg-slate-800", null, Ce, { dark: r() == "dark" }), Pe = ft(ce, "", Pe, { "color-scheme": r() });
  }), X(t, ne), it(), o();
}
nn(["click"]);
const V_e = `@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-ease:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-400:oklch(70.4% .191 22.216);--color-red-600:oklch(57.7% .245 27.325);--color-orange-500:oklch(70.5% .213 47.604);--color-orange-700:oklch(55.3% .195 38.402);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-800:oklch(42.4% .199 265.638);--color-blue-900:oklch(37.9% .146 265.522);--color-blue-950:oklch(28.2% .091 267.935);--color-slate-50:oklch(98.4% .003 247.858);--color-slate-100:oklch(96.8% .007 247.896);--color-slate-200:oklch(92.9% .013 255.508);--color-slate-300:oklch(86.9% .022 252.894);--color-slate-400:oklch(70.4% .04 256.788);--color-slate-500:oklch(55.4% .046 257.417);--color-slate-600:oklch(44.6% .043 257.281);--color-slate-700:oklch(37.2% .044 257.287);--color-slate-800:oklch(27.9% .041 260.031);--color-slate-900:oklch(20.8% .042 265.755);--color-slate-950:oklch(12.9% .042 264.695);--color-gray-200:oklch(92.8% .006 264.531);--color-gray-300:oklch(87.2% .01 258.338);--color-gray-400:oklch(70.7% .022 261.325);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-black:#000;--color-white:#fff;--spacing:.25rem;--font-weight-normal:400;--font-weight-medium:500;--ease-in-out:cubic-bezier(.4,0,.2,1);--blur-sm:8px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root,:host{overscroll-behavior:none;--tw-border-style:solid;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;font-size:13px}}@layer components;@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.sticky{position:sticky}.top-0{top:calc(var(--spacing)*0)}.top-\\[32px\\]{top:32px}.right-0{right:calc(var(--spacing)*0)}.bottom-0{bottom:calc(var(--spacing)*0)}.left-0{left:calc(var(--spacing)*0)}.left-1{left:3.25px}.isolate{isolation:isolate}.z-10{z-index:10}.z-20{z-index:20}.order-1{order:1}.order-3{order:3}.container{width:100%}@media(min-width:520px){.container{max-width:520px}}@media(min-width:624px){.container{max-width:624px}}@media(min-width:832px){.container{max-width:832px}}@media(min-width:1040px){.container{max-width:1040px}}@media(min-width:1248px){.container{max-width:1248px}}.container\\!{width:100%!important}@media(min-width:520px){.container\\!{max-width:520px!important}}@media(min-width:624px){.container\\!{max-width:624px!important}}@media(min-width:832px){.container\\!{max-width:832px!important}}@media(min-width:1040px){.container\\!{max-width:1040px!important}}@media(min-width:1248px){.container\\!{max-width:1248px!important}}.-m-2{margin:-6.5px}.m-1{margin:3.25px}.m-2{margin:6.5px}.mx-1{margin-inline:3.25px}.mx-2{margin-inline:6.5px}.my-0{margin-block:calc(var(--spacing)*0)}.my-1{margin-block:3.25px}.my-2{margin-block:6.5px}.mt-1{margin-top:3.25px}.mt-2{margin-top:6.5px}.mt-4{margin-top:13px}.mr-1{margin-right:3.25px}.mr-2{margin-right:6.5px}.mb-1{margin-bottom:3.25px}.mb-2{margin-bottom:6.5px}.ml-2{margin-left:6.5px}.ml-3{margin-left:9.75px}.form-input{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-input:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-input::placeholder{color:#6a7282;opacity:1}.form-input::-webkit-datetime-edit-fields-wrapper{padding:0}.form-input::-webkit-date-and-time-value{min-height:1.5em}.form-input::-webkit-date-and-time-value{text-align:inherit}.form-input::-webkit-datetime-edit{display:inline-flex}.form-input::-webkit-datetime-edit{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-year-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-month-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-day-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-hour-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-minute-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-second-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-millisecond-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-meridiem-field{padding-top:0;padding-bottom:0}.line-clamp-4{-webkit-line-clamp:4;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.block{display:block}.contents{display:contents}.contents\\!{display:contents!important}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.list-item{display:list-item}.table{display:table}.size-fit{width:fit-content;height:fit-content}.\\!h-32{height:104px!important}.h-2{height:6.5px}.h-3{height:9.75px}.h-4{height:13px}.h-5{height:16.25px}.h-8{height:26px}.h-12{height:39px}.h-64{height:208px}.h-96{height:312px}.h-\\[28px\\]{height:28px}.h-full{height:100%}.max-h-24{max-height:78px}.max-h-60{max-height:195px}.min-h-0{min-height:calc(var(--spacing)*0)}.w-0{width:calc(var(--spacing)*0)}.w-2{width:6.5px}.w-3{width:9.75px}.w-4{width:13px}.w-5{width:16.25px}.w-7{width:22.75px}.w-12{width:39px}.w-24{width:78px}.w-40{width:130px}.w-48{width:156px}.w-64{width:208px}.w-72{width:234px}.w-96{width:312px}.w-\\[4rem\\]{width:4rem}.w-\\[40rem\\]{width:40rem}.w-\\[420px\\]{width:420px}.w-full{width:100%}.max-w-24{max-width:78px}.max-w-32{max-width:104px}.max-w-64{max-width:208px}.max-w-72{max-width:234px}.max-w-80{max-width:260px}.max-w-\\[400px\\]{max-width:400px}.min-w-\\[180px\\]{min-width:180px}.min-w-\\[420px\\]{min-width:420px}.flex-1{flex:1}.flex-none{flex:none}.flex-shrink{flex-shrink:1}.grow{flex-grow:1}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.transform\\!{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)!important}.cursor-col-resize{cursor:col-resize}.cursor-row-resize{cursor:row-resize}.resize{resize:both}.resize\\!{resize:both!important}.form-select{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-select:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-select{print-color-adjust:exact;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='oklch(55.1%25 0.027 264.364)' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");background-position:right .5rem center;background-repeat:no-repeat;background-size:1.5em 1.5em;padding-right:2.5rem}.form-select:where([size]:not([size="1"])){background-image:initial;background-position:initial;background-repeat:unset;background-size:initial;print-color-adjust:unset;padding-right:.75rem}.form-textarea{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-textarea:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-textarea::placeholder{color:#6a7282;opacity:1}.flex-col{flex-direction:column}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.place-content-center{place-content:center}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-0\\.5{gap:1.625px}.gap-1{gap:3.25px}.gap-2{gap:6.5px}.gap-4{gap:13px}.gap-\\[1px\\]{gap:1px}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(6.5px*var(--tw-space-y-reverse));margin-block-end:calc(6.5px*calc(1 - var(--tw-space-y-reverse)))}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-scroll{overflow-y:scroll}.rounded{border-radius:3.25px}.rounded-full{border-radius:3.40282e38px}.rounded-md{border-radius:4.875px}.rounded-sm{border-radius:1.625px}.rounded-ss-md{border-start-start-radius:4.875px}.rounded-ee-md{border-end-end-radius:4.875px}.border{border-style:var(--tw-border-style);border-width:1px}.border-0{border-style:var(--tw-border-style);border-width:0}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-dotted{--tw-border-style:dotted;border-style:dotted}.\\!border-blue-400{border-color:var(--color-blue-400)!important}.\\!border-slate-600{border-color:var(--color-slate-600)!important}.border-slate-200{border-color:var(--color-slate-200)}.border-slate-300{border-color:var(--color-slate-300)}.border-slate-400{border-color:var(--color-slate-400)}.border-slate-500{border-color:var(--color-slate-500)}.\\!bg-blue-100{background-color:var(--color-blue-100)!important}.\\!bg-slate-100{background-color:var(--color-slate-100)!important}.\\!bg-slate-500{background-color:var(--color-slate-500)!important}.bg-blue-100{background-color:var(--color-blue-100)}.bg-blue-200{background-color:var(--color-blue-200)}.bg-blue-500{background-color:var(--color-blue-500)}.bg-gray-300{background-color:var(--color-gray-300)}.bg-slate-50{background-color:var(--color-slate-50)}.bg-slate-100{background-color:var(--color-slate-100)}.bg-slate-100\\/25{background-color:#f1f5f940}@supports (color:color-mix(in lab,red,red)){.bg-slate-100\\/25{background-color:color-mix(in oklab,var(--color-slate-100)25%,transparent)}}.bg-slate-100\\/75{background-color:#f1f5f9bf}@supports (color:color-mix(in lab,red,red)){.bg-slate-100\\/75{background-color:color-mix(in oklab,var(--color-slate-100)75%,transparent)}}.bg-slate-200{background-color:var(--color-slate-200)}.bg-slate-400{background-color:var(--color-slate-400)}.bg-slate-500{background-color:var(--color-slate-500)}.bg-slate-600{background-color:var(--color-slate-600)}.bg-slate-900{background-color:var(--color-slate-900)}.bg-slate-950{background-color:var(--color-slate-950)}.bg-white{background-color:var(--color-white)}.bg-white\\/75{background-color:#ffffffbf}@supports (color:color-mix(in lab,red,red)){.bg-white\\/75{background-color:color-mix(in oklab,var(--color-white)75%,transparent)}}.fill-orange-500{fill:var(--color-orange-500)}.stroke-orange-500{stroke:var(--color-orange-500)}.stroke-orange-700{stroke:var(--color-orange-700)}.stroke-2{stroke-width:2px}.p-1{padding:3.25px}.p-2{padding:6.5px}.p-4{padding:13px}.px-1{padding-inline:3.25px}.px-1\\.5{padding-inline:4.875px}.px-2{padding-inline:6.5px}.px-2\\.5{padding-inline:8.125px}.px-3{padding-inline:9.75px}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\\.5{padding-block:1.625px}.py-1{padding-block:3.25px}.py-1\\.5{padding-block:4.875px}.py-2{padding-block:6.5px}.py-3{padding-block:9.75px}.py-20{padding-block:65px}.pt-2{padding-top:6.5px}.pr-0\\.5{padding-right:1.625px}.pr-1{padding-right:3.25px}.pr-2{padding-right:6.5px}.pr-\\[16px\\]{padding-right:16px}.pb-1{padding-bottom:3.25px}.pb-2{padding-bottom:6.5px}.pb-4{padding-bottom:13px}.pl-2{padding-left:6.5px}.pl-40{padding-left:130px}.pl-\\[4px\\]{padding-left:4px}.text-center{text-align:center}.text-left{text-align:left}.text-right{text-align:right}.font-mono{font-family:var(--font-mono)}.text-sm{font-size:11.375px;line-height:var(--tw-leading,16.25px)}.text-sm\\!{font-size:11.375px!important;line-height:var(--tw-leading,16.25px)!important}.text-xs{font-size:9.75px;line-height:var(--tw-leading,13px)}.leading-5{--tw-leading:16.25px;line-height:16.25px}.leading-7{--tw-leading:22.75px;line-height:22.75px}.leading-10{--tw-leading:32.5px;line-height:32.5px}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.text-nowrap{text-wrap:nowrap}.break-all{word-break:break-all}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.\\!text-gray-200{color:var(--color-gray-200)!important}.\\!text-slate-100{color:var(--color-slate-100)!important}.text-blue-500{color:var(--color-blue-500)}.text-gray-400{color:var(--color-gray-400)}.text-red-400{color:var(--color-red-400)}.text-red-600{color:var(--color-red-600)}.text-slate-300{color:var(--color-slate-300)}.text-slate-400{color:var(--color-slate-400)}.text-slate-500{color:var(--color-slate-500)}.text-slate-600{color:var(--color-slate-600)}.text-slate-700{color:var(--color-slate-700)}.text-slate-800{color:var(--color-slate-800)}.text-white{color:var(--color-white)}.capitalize{text-transform:capitalize}.italic{font-style:italic}.ordinal{--tw-ordinal:ordinal;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.tabular-nums{--tw-numeric-spacing:tabular-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.line-through{text-decoration-line:line-through}.underline{text-decoration-line:underline}.opacity-20{opacity:.2}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.-outline-offset-1{outline-offset:-1px}.outline-blue-600{outline-color:var(--color-blue-600)}.outline-slate-500{outline-color:var(--color-slate-500)}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.invert{--tw-invert:invert(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter\\!{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)!important}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.select-none{-webkit-user-select:none;user-select:none}@media(hover:hover){.group-hover\\:bg-blue-600:is(:where(.group):hover *){background-color:var(--color-blue-600)}.group-hover\\:opacity-100:is(:where(.group):hover *){opacity:1}}.first\\:rounded-tl-md:first-child{border-top-left-radius:4.875px}.first\\:rounded-bl-md:first-child{border-bottom-left-radius:4.875px}.last\\:rounded-tr-md:last-child{border-top-right-radius:4.875px}.last\\:rounded-br-md:last-child{border-bottom-right-radius:4.875px}@media(hover:hover){.hover\\:bg-slate-200:hover{background-color:var(--color-slate-200)}.hover\\:text-slate-500:hover{color:var(--color-slate-500)}.hover\\:text-slate-800:hover{color:var(--color-slate-800)}.hover\\:text-slate-900:hover{color:var(--color-slate-900)}.hover\\:outline:hover{outline-style:var(--tw-outline-style);outline-width:1px}}.focus-visible\\:outline-2:focus-visible{outline-style:var(--tw-outline-style);outline-width:2px}@media(min-width:520px){.sm\\:opacity-0{opacity:0}}.dark\\:\\!border-blue-600:where(.dark,.dark *){border-color:var(--color-blue-600)!important}.dark\\:\\!border-slate-400:where(.dark,.dark *){border-color:var(--color-slate-400)!important}.dark\\:border-slate-500:where(.dark,.dark *){border-color:var(--color-slate-500)}.dark\\:border-slate-600:where(.dark,.dark *){border-color:var(--color-slate-600)}.dark\\:border-slate-700:where(.dark,.dark *){border-color:var(--color-slate-700)}.dark\\:\\!bg-blue-800:where(.dark,.dark *){background-color:var(--color-blue-800)!important}.dark\\:\\!bg-slate-700:where(.dark,.dark *){background-color:var(--color-slate-700)!important}.dark\\:bg-black:where(.dark,.dark *){background-color:var(--color-black)}.dark\\:bg-black\\/75:where(.dark,.dark *){background-color:#000000bf}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-black\\/75:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-black)75%,transparent)}}.dark\\:bg-gray-700:where(.dark,.dark *){background-color:var(--color-gray-700)}.dark\\:bg-slate-500:where(.dark,.dark *){background-color:var(--color-slate-500)}.dark\\:bg-slate-600:where(.dark,.dark *){background-color:var(--color-slate-600)}.dark\\:bg-slate-700:where(.dark,.dark *){background-color:var(--color-slate-700)}.dark\\:bg-slate-700\\/25:where(.dark,.dark *){background-color:#31415840}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-slate-700\\/25:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-slate-700)25%,transparent)}}.dark\\:bg-slate-800:where(.dark,.dark *){background-color:var(--color-slate-800)}.dark\\:bg-slate-800\\/75:where(.dark,.dark *){background-color:#1d293dbf}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-slate-800\\/75:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-slate-800)75%,transparent)}}.dark\\:bg-slate-900:where(.dark,.dark *){background-color:var(--color-slate-900)}.dark\\:\\!text-gray-600:where(.dark,.dark *){color:var(--color-gray-600)!important}.dark\\:text-gray-400:where(.dark,.dark *){color:var(--color-gray-400)}.dark\\:text-gray-500:where(.dark,.dark *){color:var(--color-gray-500)}.dark\\:text-slate-200:where(.dark,.dark *){color:var(--color-slate-200)}.dark\\:text-slate-300:where(.dark,.dark *){color:var(--color-slate-300)}.dark\\:text-slate-400:where(.dark,.dark *){color:var(--color-slate-400)}.dark\\:text-slate-500:where(.dark,.dark *){color:var(--color-slate-500)}.dark\\:text-slate-600:where(.dark,.dark *){color:var(--color-slate-600)}@media(hover:hover){.dark\\:group-hover\\:bg-blue-400:where(.dark,.dark *):is(:where(.group):hover *){background-color:var(--color-blue-400)}.dark\\:hover\\:bg-slate-700:where(.dark,.dark *):hover{background-color:var(--color-slate-700)}.dark\\:hover\\:text-slate-100:where(.dark,.dark *):hover{color:var(--color-slate-100)}.dark\\:hover\\:text-slate-200:where(.dark,.dark *):hover{color:var(--color-slate-200)}.dark\\:hover\\:text-slate-300:where(.dark,.dark *):hover{color:var(--color-slate-300)}.dark\\:hover\\:text-slate-400:where(.dark,.dark *):hover{color:var(--color-slate-400)}}}.form-input,.form-textarea,.form-select,.form-multiselect{font-size:13px;line-height:19.5px}mark{background-color:#f9ceaf}.markdown-content{line-height:1.2em}.markdown-content a{text-decoration:underline}.markdown-content pre,.markdown-content code{font-family:Menlo,monospace;font-size:11px}.markdown-content pre{margin-bottom:.5em}.markdown-content h1,.markdown-content h2,.markdown-content h3,.markdown-content h4{margin-bottom:.5em;font-weight:700}.markdown-content p{margin-bottom:.5em;list-style:outside}.markdown-content ul{margin-bottom:.5em;margin-left:2em;list-style:outside}.markdown-content ol{margin-bottom:.5em;margin-left:2em;list-style:decimal}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-ordinal{syntax:"*";inherits:false}@property --tw-slashed-zero{syntax:"*";inherits:false}@property --tw-numeric-figure{syntax:"*";inherits:false}@property --tw-numeric-spacing{syntax:"*";inherits:false}@property --tw-numeric-fraction{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}`;
class J_e {
  component;
  container;
  currentProps;
  constructor(e, r) {
    this.currentProps = { ...r }, this.container = document.createElement("div"), this.container.style.display = "flex", this.container.style.width = "100%", this.container.style.height = "100%", e.appendChild(this.container);
    let n = this.container.attachShadow({ mode: "open" }), i = document.createElement("style");
    i.innerText = V_e, n.appendChild(i);
    let o = document.createElement("div");
    o.style.display = "flex", o.style.width = "100%", o.style.height = "100%", n.appendChild(o), this.component = kT({ component: H_e, target: o, props: r });
  }
  update(e) {
    let r = {};
    for (let n in e)
      e[n] !== this.currentProps[n] && (r[n] = e[n], this.currentProps[n] = e[n]);
    this.component.$set(r);
  }
  destroy() {
    this.component.$destroy(), this.container.remove();
  }
}
export {
  F_e as O,
  J_e as g
};
