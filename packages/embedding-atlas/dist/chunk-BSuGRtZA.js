import { i as vn } from "./chunk-DgFtVqg1.js";
import { Selection as vK, makeClient as ol, isSelection as o3, MosaicClient as F_, queryFieldInfo as yK, coordinator as SF } from "@uwdata/mosaic-core";
import * as T from "@uwdata/mosaic-sql";
import { Query as pd, sql as tD, eq as bK, column as cm, literal as xK, cast as rD, row_number as wK, desc as kK, count as CK } from "@uwdata/mosaic-sql";
import { parseSpec as _K, astToDOM as SK } from "@uwdata/mosaic-spec";
import { createAPIContext as AK } from "@uwdata/vgplot";
function EK(t, e = 1e3) {
  let r;
  return (...i) => {
    r && clearTimeout(r), r = setTimeout(() => {
      t(...i);
    }, e);
  };
}
function T_(t, e) {
  if (t === e)
    return !0;
  if (t === null || e === null || typeof t != "object" || typeof e != "object" || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (let r in t)
    if (e.hasOwnProperty(r)) {
      if (!T_(t[r], e[r]))
        return !1;
    } else
      return !1;
  return !0;
}
function nD(t) {
  let e;
  return (...r) => {
    let n = t(...r);
    return e !== void 0 && T_(n, e) ? e : (e = n, n);
  };
}
function M_(t, e) {
  if (iD(t) && iD(e)) {
    let r;
    for (let n in e)
      if (e[n] !== t[n])
        if (e[n] === void 0)
          r === void 0 && (r = { ...t }), delete r[n];
        else {
          let i = M_(t[n], e[n]);
          i !== void 0 && (r === void 0 && (r = { ...t }), r[n] = i);
        }
    return r;
  } else return T_(t, e) ? void 0 : e;
}
function md(t, e, r, n) {
  switch (r) {
    case "merge": {
      let i = M_(t, e);
      return i !== void 0 ? n(i) : void 0;
    }
    case "replace":
      return t !== e ? n(e) : void 0;
  }
}
function Ay(t, e, r, n, i) {
  switch (n) {
    case "merge": {
      let o = M_(t, { [e]: r });
      return o !== void 0 ? i(o) : void 0;
    }
    case "replace":
      if (t[e] !== r) {
        let o = { ...t };
        return o[e] = r, i(o);
      } else
        return;
  }
}
function iD(t) {
  return t != null && typeof t == "object" && !Array.isArray(t);
}
const mi = 2, kb = 4, Cb = 8, sl = 16, tu = 32, $h = 64, _b = 128, Ks = 512, oi = 1024, lo = 2048, ru = 4096, Uo = 8192, ju = 16384, Gg = 32768, Ql = 65536, oD = 1 << 17, AF = 1 << 18, Gd = 1 << 19, EF = 1 << 20, Wm = 32768, s3 = 1 << 21, P_ = 1 << 22, qu = 1 << 23, qa = Symbol("$state"), R_ = Symbol("legacy props"), DK = Symbol(""), Ff = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), Sb = 3, Ih = 8, OK = !1;
var N_ = Array.isArray, FK = Array.prototype.indexOf, $_ = Array.from, I_ = Object.defineProperty, Uu = Object.getOwnPropertyDescriptor, DF = Object.getOwnPropertyDescriptors, TK = Object.prototype, MK = Array.prototype, B_ = Object.getPrototypeOf, sD = Object.isExtensible;
function Sf(t) {
  return typeof t == "function";
}
const jt = () => {
};
function OF(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function FF() {
  var t, e, r = new Promise((n, i) => {
    t = n, e = i;
  });
  return { promise: r, resolve: t, reject: e };
}
function aD(t, e) {
  if (Array.isArray(t))
    return t;
  if (!(Symbol.iterator in t))
    return Array.from(t);
  const r = [];
  for (const n of t)
    if (r.push(n), r.length === e) break;
  return r;
}
function TF(t) {
  return t === this.v;
}
function L_(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function MF(t) {
  return !L_(t, this.v);
}
function PF(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function PK() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function RK(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function NK() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function $K(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function IK() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function BK() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function LK(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function zK() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function jK() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function qK() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function UK() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let HK = !1;
const z_ = 1, j_ = 2, RF = 4, VK = 8, WK = 16, GK = 1, KK = 4, XK = 8, QK = 16, JK = 1, YK = 2, ZK = 4, NF = 1, eX = 2, $F = "[", Ab = "[!", q_ = "]", vh = {}, Vn = Symbol(), tX = "http://www.w3.org/1999/xhtml", rX = "@attach";
let uo = null;
function gd(t) {
  uo = t;
}
function nt(t, e = !1, r) {
  uo = {
    p: uo,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: null
  };
}
function it(t) {
  var e = (
    /** @type {ComponentContext} */
    uo
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      hT(n);
  }
  return t !== void 0 && (e.x = t), e.i = !0, uo = e.p, t ?? /** @type {T} */
  {};
}
function IF() {
  return !0;
}
let qc = [];
function BF() {
  var t = qc;
  qc = [], OF(t);
}
function nu(t) {
  if (qc.length === 0 && !Sm) {
    var e = qc;
    queueMicrotask(() => {
      e === qc && BF();
    });
  }
  qc.push(t);
}
function nX() {
  for (; qc.length > 0; )
    BF();
}
function Kg(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function iX() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function oX() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let wt = !1;
function Hs(t) {
  wt = t;
}
let qt;
function ci(t) {
  if (t === null)
    throw Kg(), vh;
  return qt = t;
}
function rc() {
  return ci(
    /** @type {TemplateNode} */
    /* @__PURE__ */ ia(qt)
  );
}
function J(t) {
  if (wt) {
    if (/* @__PURE__ */ ia(qt) !== null)
      throw Kg(), vh;
    qt = t;
  }
}
function U_(t = 1) {
  if (wt) {
    for (var e = t, r = qt; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ ia(r);
    qt = r;
  }
}
function n1(t = !0) {
  for (var e = 0, r = qt; ; ) {
    if (r.nodeType === Ih) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === q_) {
        if (e === 0) return r;
        e -= 1;
      } else (n === $F || n === Ab) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ia(r)
    );
    t && r.remove(), r = i;
  }
}
function LF(t) {
  if (!t || t.nodeType !== Ih)
    throw Kg(), vh;
  return (
    /** @type {Comment} */
    t.data
  );
}
function ps(t) {
  if (typeof t != "object" || t === null || qa in t)
    return t;
  const e = B_(t);
  if (e !== TK && e !== MK)
    return t;
  var r = /* @__PURE__ */ new Map(), n = N_(t), i = /* @__PURE__ */ De(0), o = ih, s = (a) => {
    if (ih === o)
      return a();
    var l = Yt, u = ih;
    to(null), dD(o);
    var c = a();
    return to(l), dD(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ De(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && zK();
        var c = r.get(l);
        return c === void 0 ? c = s(() => {
          var h = /* @__PURE__ */ De(u.value);
          return r.set(l, h), h;
        }) : ae(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = s(() => /* @__PURE__ */ De(Vn));
            r.set(l, c), Am(i);
          }
        } else
          ae(u, Vn), Am(i);
        return !0;
      },
      get(a, l, u) {
        if (l === qa)
          return t;
        var c = r.get(l), h = l in a;
        if (c === void 0 && (!h || Uu(a, l)?.writable) && (c = s(() => {
          var p = ps(h ? a[l] : Vn), g = /* @__PURE__ */ De(p);
          return g;
        }), r.set(l, c)), c !== void 0) {
          var d = x(c);
          return d === Vn ? void 0 : d;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = x(c));
        } else if (u === void 0) {
          var h = r.get(l), d = h?.v;
          if (h !== void 0 && d !== Vn)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === qa)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== Vn || Reflect.has(a, l);
        if (u !== void 0 || Kt !== null && (!c || Uu(a, l)?.writable)) {
          u === void 0 && (u = s(() => {
            var d = c ? ps(a[l]) : Vn, p = /* @__PURE__ */ De(d);
            return p;
          }), r.set(l, u));
          var h = x(u);
          if (h === Vn)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var h = r.get(l), d = l in a;
        if (n && l === "length")
          for (var p = u; p < /** @type {Source<number>} */
          h.v; p += 1) {
            var g = r.get(p + "");
            g !== void 0 ? ae(g, Vn) : p in a && (g = s(() => /* @__PURE__ */ De(Vn)), r.set(p + "", g));
          }
        if (h === void 0)
          (!d || Uu(a, l)?.writable) && (h = s(() => /* @__PURE__ */ De(void 0)), ae(h, ps(u)), r.set(l, h));
        else {
          d = h.v !== Vn;
          var v = s(() => ps(u));
          ae(h, v);
        }
        var y = Reflect.getOwnPropertyDescriptor(a, l);
        if (y?.set && y.set.call(c, u), !d) {
          if (n && typeof l == "string") {
            var b = (
              /** @type {Source<number>} */
              r.get("length")
            ), k = Number(l);
            Number.isInteger(k) && k >= b.v && ae(b, k + 1);
          }
          Am(i);
        }
        return !0;
      },
      ownKeys(a) {
        x(i);
        var l = Reflect.ownKeys(a).filter((h) => {
          var d = r.get(h);
          return d === void 0 || d.v !== Vn;
        });
        for (var [u, c] of r)
          c.v !== Vn && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        jK();
      }
    }
  );
}
function lD(t) {
  try {
    if (t !== null && typeof t == "object" && qa in t)
      return t[qa];
  } catch {
  }
  return t;
}
function sX(t, e) {
  return Object.is(lD(t), lD(e));
}
var a3, zF, jF, qF;
function l3() {
  if (a3 === void 0) {
    a3 = window, zF = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    jF = Uu(e, "firstChild").get, qF = Uu(e, "nextSibling").get, sD(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), sD(r) && (r.__t = void 0);
  }
}
function ws(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function ni(t) {
  return jF.call(t);
}
// @__NO_SIDE_EFFECTS__
function ia(t) {
  return qF.call(t);
}
function Y(t, e) {
  if (!wt)
    return /* @__PURE__ */ ni(t);
  var r = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ ni(qt)
  );
  if (r === null)
    r = qt.appendChild(ws());
  else if (e && r.nodeType !== Sb) {
    var n = ws();
    return r?.before(n), ci(n), n;
  }
  return ci(r), r;
}
function He(t, e = !1) {
  if (!wt) {
    var r = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ ni(
        /** @type {Node} */
        t
      )
    );
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ ia(r) : r;
  }
  if (e && qt?.nodeType !== Sb) {
    var n = ws();
    return qt?.before(n), ci(n), n;
  }
  return qt;
}
function le(t, e = 1, r = !1) {
  let n = wt ? qt : t;
  for (var i; e--; )
    i = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ ia(n);
  if (!wt)
    return n;
  if (r && n?.nodeType !== Sb) {
    var o = ws();
    return n === null ? i?.after(o) : n.before(o), ci(o), o;
  }
  return ci(n), /** @type {TemplateNode} */
  n;
}
function UF(t) {
  t.textContent = "";
}
function aX() {
  return !1;
}
function HF(t) {
  var e = Kt;
  if (e === null)
    return Yt.f |= qu, t;
  if ((e.f & Gg) === 0) {
    if ((e.f & _b) === 0)
      throw t;
    e.b.error(t);
  } else
    vd(t, e);
}
function vd(t, e) {
  for (; e !== null; ) {
    if ((e.f & _b) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const wv = /* @__PURE__ */ new Set();
let Ur = null, Ey = null, $o = null, Sa = [], Eb = null, u3 = !1, Sm = !1;
class Ma {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #l = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #a = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Sa = [], Ey = null, this.apply();
    var r = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const n of e)
      this.#o(n, r);
    this.is_fork || this.#u(), this.#n > 0 || this.is_fork ? (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects)) : (Ey = this, Ur = null, uD(r.render_effects), uD(r.effects), Ey = null, this.#l?.resolve()), $o = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(e, r) {
    e.f ^= oi;
    for (var n = e.first; n !== null; ) {
      var i = n.f, o = (i & (tu | $h)) !== 0, s = o && (i & oi) !== 0, a = s || (i & Uo) !== 0 || this.skipped_effects.has(n);
      if ((n.f & _b) !== 0 && n.b?.is_pending() && (r = {
        parent: r,
        effect: n,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !a && n.fn !== null) {
        o ? n.f ^= oi : (i & kb) !== 0 ? r.effects.push(n) : Xg(n) && ((n.f & sl) !== 0 && r.block_effects.push(n), Km(n));
        var l = n.first;
        if (l !== null) {
          n = l;
          continue;
        }
      }
      var u = n.parent;
      for (n = n.next; n === null && u !== null; )
        u === r.effect && (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects), r = /** @type {EffectTarget} */
        r.parent), n = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #s(e) {
    for (const r of e)
      ((r.f & lo) !== 0 ? this.#a : this.#i).push(r), hi(r, oi);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    this.previous.has(e) || this.previous.set(e, r), (e.f & qu) === 0 && (this.current.set(e, e.v), $o?.set(e, e.v));
  }
  activate() {
    Ur = this, this.apply();
  }
  deactivate() {
    Ur = null, $o = null;
  }
  flush() {
    if (this.activate(), Sa.length > 0) {
      if (WF(), Ur !== null && Ur !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#n === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#r === 0 && this.#c();
  }
  #c() {
    if (wv.size > 1) {
      this.previous.clear();
      var e = $o, r = !0, n = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of wv) {
        if (i === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (i.current.has(a))
            if (r && l !== i.current.get(a))
              i.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const s = [...i.current.keys()].filter((a) => !this.current.has(a));
        if (s.length > 0) {
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            GF(u, s, a, l);
          if (Sa.length > 0) {
            Ur = i, i.apply();
            for (const u of Sa)
              i.#o(u, n);
            Sa = [], i.deactivate();
          }
        }
      }
      Ur = null, $o = e;
    }
    this.committed = !0, wv.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), this.revive();
  }
  revive() {
    for (const e of this.#a)
      hi(e, lo), yh(e);
    for (const e of this.#i)
      hi(e, ru), yh(e);
    this.#a = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#l ??= FF()).promise;
  }
  static ensure() {
    if (Ur === null) {
      const e = Ur = new Ma();
      wv.add(Ur), Sm || Ma.enqueue(() => {
        Ur === e && e.flush();
      });
    }
    return Ur;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    nu(e);
  }
  apply() {
  }
}
function VF(t) {
  var e = Sm;
  Sm = !0;
  try {
    for (var r; ; ) {
      if (nX(), Sa.length === 0 && (Ur?.flush(), Sa.length === 0))
        return Eb = null, /** @type {T} */
        r;
      WF();
    }
  } finally {
    Sm = e;
  }
}
function WF() {
  var t = nh;
  u3 = !0;
  try {
    var e = 0;
    for (hD(!0); Sa.length > 0; ) {
      var r = Ma.ensure();
      if (e++ > 1e3) {
        var n, i;
        lX();
      }
      r.process(Sa), Hu.clear();
    }
  } finally {
    u3 = !1, hD(t), Eb = null;
  }
}
function lX() {
  try {
    IK();
  } catch (t) {
    vd(t, Eb);
  }
}
let Ol = null;
function uD(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (ju | Uo)) === 0 && Xg(n) && (Ol = /* @__PURE__ */ new Set(), Km(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null && n.ac === null ? mT(n) : n.fn = null), Ol?.size > 0)) {
        Hu.clear();
        for (const i of Ol) {
          if ((i.f & (ju | Uo)) !== 0) continue;
          const o = [i];
          let s = i.parent;
          for (; s !== null; )
            Ol.has(s) && (Ol.delete(s), o.push(s)), s = s.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (ju | Uo)) === 0 && Km(l);
          }
        }
        Ol.clear();
      }
    }
    Ol = null;
  }
}
function GF(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const o = i.f;
      (o & mi) !== 0 ? GF(
        /** @type {Derived} */
        i,
        e,
        r,
        n
      ) : (o & (P_ | sl)) !== 0 && (o & lo) === 0 && // we may have scheduled this one already
      KF(i, e, n) && (hi(i, lo), yh(
        /** @type {Effect} */
        i
      ));
    }
}
function KF(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & mi) !== 0 && KF(
        /** @type {Derived} */
        i,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function yh(t) {
  for (var e = Eb = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (u3 && e === Kt && (r & sl) !== 0 && (r & AF) === 0)
      return;
    if ((r & ($h | tu)) !== 0) {
      if ((r & oi) === 0) return;
      e.f ^= oi;
    }
  }
  Sa.push(e);
}
function uX(t) {
  let e = 0, r = bh(0), n;
  return () => {
    Ob() && (x(r), Tb(() => (e === 0 && (n = Ko(() => t(() => Am(r)))), e += 1, () => {
      nu(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Am(r));
      });
    })));
  };
}
var cX = Ql | Gd | _b;
function XF(t, e, r) {
  new hX(t, e, r);
}
class hX {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #r = wt ? qt : null;
  /** @type {BoundaryProps} */
  #n;
  /** @type {((anchor: Node) => void)} */
  #l;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #h = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #f = null;
  #v = uX(() => (this.#f = bh(this.#d), () => {
    this.#f = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#t = e, this.#n = r, this.#l = n, this.parent = /** @type {Effect} */
    Kt.b, this.#e = !!this.#n.pending, this.#a = pc(() => {
      if (Kt.b = this, wt) {
        const o = this.#r;
        rc(), /** @type {Comment} */
        o.nodeType === Ih && /** @type {Comment} */
        o.data === Ab ? this.#b() : this.#y();
      } else {
        var i = this.#x();
        try {
          this.#i = Ro(() => n(i));
        } catch (o) {
          this.error(o);
        }
        this.#h > 0 ? this.#g() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, cX), wt && (this.#t = qt);
  }
  #y() {
    try {
      this.#i = Ro(() => this.#l(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #b() {
    const e = this.#n.pending;
    e && (this.#o = Ro(() => e(this.#t)), Ma.enqueue(() => {
      var r = this.#x();
      this.#i = this.#m(() => (Ma.ensure(), Ro(() => this.#l(r)))), this.#h > 0 ? this.#g() : (qf(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = ws(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#n.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(e) {
    var r = Kt, n = Yt, i = uo;
    Qa(this.#a), to(this.#a), gd(this.#a.ctx);
    try {
      return e();
    } catch (o) {
      return HF(o), null;
    } finally {
      Qa(r), to(n), gd(i);
    }
  }
  #g() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#n.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), yT(this.#i, this.#u)), this.#o === null && (this.#o = Ro(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#h += e, this.#h === 0 && (this.#e = !1, this.#o && qf(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#f && yd(this.#f, this.#d);
  }
  get_effect_pending() {
    return this.#v(), x(
      /** @type {Source<number>} */
      this.#f
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#n.onerror;
    let n = this.#n.failed;
    if (this.#p || !r && !n)
      throw e;
    this.#i && (zn(this.#i), this.#i = null), this.#o && (zn(this.#o), this.#o = null), this.#s && (zn(this.#s), this.#s = null), wt && (ci(
      /** @type {TemplateNode} */
      this.#r
    ), U_(), ci(n1()));
    var i = !1, o = !1;
    const s = () => {
      if (i) {
        oX();
        return;
      }
      i = !0, o && UK(), Ma.ensure(), this.#d = 0, this.#s !== null && qf(this.#s, () => {
        this.#s = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#m(() => (this.#p = !1, Ro(() => this.#l(this.#t)))), this.#h > 0 ? this.#g() : this.#e = !1;
    };
    var a = Yt;
    try {
      to(null), o = !0, r?.(e, s), o = !1;
    } catch (l) {
      vd(l, this.#a && this.#a.parent);
    } finally {
      to(a);
    }
    n && nu(() => {
      this.#s = this.#m(() => {
        Ma.ensure(), this.#p = !0;
        try {
          return Ro(() => {
            n(
              this.#t,
              () => e,
              () => s
            );
          });
        } catch (l) {
          return vd(
            l,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function QF(t, e, r, n) {
  const i = Db;
  if (r.length === 0 && t.length === 0) {
    n(e.map(i));
    return;
  }
  var o = Ur, s = (
    /** @type {Effect} */
    Kt
  ), a = fX();
  function l() {
    Promise.all(r.map((u) => /* @__PURE__ */ dX(u))).then((u) => {
      a();
      try {
        n([...e.map(i), ...u]);
      } catch (c) {
        (s.f & ju) === 0 && vd(c, s);
      }
      o?.deactivate(), i1();
    }).catch((u) => {
      vd(u, s);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    a();
    try {
      return l();
    } finally {
      o?.deactivate(), i1();
    }
  }) : l();
}
function fX() {
  var t = Kt, e = Yt, r = uo, n = Ur;
  return function(i = !0) {
    Qa(t), to(e), gd(r), i && n?.activate();
  };
}
function i1() {
  Qa(null), to(null), gd(null);
}
// @__NO_SIDE_EFFECTS__
function Db(t) {
  var e = mi | lo, r = Yt !== null && (Yt.f & mi) !== 0 ? (
    /** @type {Derived} */
    Yt
  ) : null;
  return Kt !== null && (Kt.f |= Gd), {
    ctx: uo,
    deps: null,
    effects: null,
    equals: TF,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      Vn
    ),
    wv: 0,
    parent: r ?? Kt,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function dX(t, e) {
  let r = (
    /** @type {Effect | null} */
    Kt
  );
  r === null && PK();
  var n = (
    /** @type {Boundary} */
    r.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), o = bh(
    /** @type {V} */
    Vn
  ), s = !Yt, a = /* @__PURE__ */ new Map();
  return SX(() => {
    var l = FF();
    i = l.promise;
    try {
      Promise.resolve(t()).then(l.resolve, l.reject).then(() => {
        u === Ur && u.committed && u.deactivate(), i1();
      });
    } catch (d) {
      l.reject(d), i1();
    }
    var u = (
      /** @type {Batch} */
      Ur
    );
    if (s) {
      var c = !n.is_pending();
      n.update_pending_count(1), u.increment(c), a.get(u)?.reject(Ff), a.delete(u), a.set(u, l);
    }
    const h = (d, p = void 0) => {
      if (u.activate(), p)
        p !== Ff && (o.f |= qu, yd(o, p));
      else {
        (o.f & qu) !== 0 && (o.f ^= qu), yd(o, d);
        for (const [g, v] of a) {
          if (a.delete(g), g === u) break;
          v.reject(Ff);
        }
      }
      s && (n.update_pending_count(-1), u.decrement(c));
    };
    l.promise.then(h, (d) => h(null, d || "unknown"));
  }), Fb(() => {
    for (const l of a.values())
      l.reject(Ff);
  }), new Promise((l) => {
    function u(c) {
      function h() {
        c === i ? l(o) : u(i);
      }
      c.then(h, h);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function K(t) {
  const e = /* @__PURE__ */ Db(t);
  return nT(e), e;
}
// @__NO_SIDE_EFFECTS__
function JF(t) {
  const e = /* @__PURE__ */ Db(t);
  return e.equals = MF, e;
}
function YF(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      zn(
        /** @type {Effect} */
        e[r]
      );
  }
}
function pX(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & mi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function H_(t) {
  var e, r = Kt;
  Qa(pX(t));
  try {
    t.f &= ~Wm, YF(t), e = aT(t);
  } finally {
    Qa(r);
  }
  return e;
}
function ZF(t) {
  var e = H_(t);
  if (t.equals(e) || (t.v = e, t.wv = oT()), !Bh)
    if ($o !== null)
      Ob() && $o.set(t, t.v);
    else {
      var r = (t.f & Ks) === 0 ? ru : oi;
      hi(t, r);
    }
}
let c3 = /* @__PURE__ */ new Set();
const Hu = /* @__PURE__ */ new Map();
let eT = !1;
function bh(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: TF,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function De(t, e) {
  const r = bh(t);
  return nT(r), r;
}
// @__NO_SIDE_EFFECTS__
function V_(t, e = !1, r = !0) {
  const n = bh(t);
  return e || (n.equals = MF), n;
}
function ae(t, e, r = !1) {
  Yt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Pa || (Yt.f & oD) !== 0) && IF() && (Yt.f & (mi | sl | P_ | oD)) !== 0 && !Hl?.includes(t) && qK();
  let n = r ? ps(e) : e;
  return yd(t, n);
}
function yd(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Bh ? Hu.set(t, e) : Hu.set(t, r), t.v = e;
    var n = Ma.ensure();
    n.capture(t, r), (t.f & mi) !== 0 && ((t.f & lo) !== 0 && H_(
      /** @type {Derived} */
      t
    ), hi(t, (t.f & Ks) !== 0 ? oi : ru)), t.wv = oT(), tT(t, lo), Kt !== null && (Kt.f & oi) !== 0 && (Kt.f & (tu | $h)) === 0 && (us === null ? yX([t]) : us.push(t)), !n.is_fork && c3.size > 0 && !eT && mX();
  }
  return e;
}
function mX() {
  eT = !1;
  const t = Array.from(c3);
  for (const e of t)
    (e.f & oi) !== 0 && hi(e, ru), Xg(e) && Km(e);
  c3.clear();
}
function Am(t) {
  ae(t, t.v + 1);
}
function tT(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = r.length, i = 0; i < n; i++) {
      var o = r[i], s = o.f, a = (s & lo) === 0;
      if (a && hi(o, e), (s & mi) !== 0) {
        var l = (
          /** @type {Derived} */
          o
        );
        $o?.delete(l), (s & Wm) === 0 && (s & Ks && (o.f |= Wm), tT(l, ru));
      } else a && ((s & sl) !== 0 && Ol !== null && Ol.add(
        /** @type {Effect} */
        o
      ), yh(
        /** @type {Effect} */
        o
      ));
    }
}
function gX(t, e) {
  if (e) {
    const r = document.body;
    t.autofocus = !0, nu(() => {
      document.activeElement === r && t.focus();
    });
  }
}
let cD = !1;
function rT() {
  cD || (cD = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function Kd(t) {
  var e = Yt, r = Kt;
  to(null), Qa(null);
  try {
    return t();
  } finally {
    to(e), Qa(r);
  }
}
function vX(t, e, r, n = r) {
  t.addEventListener(e, () => Kd(r));
  const i = t.__on_r;
  i ? t.__on_r = () => {
    i(), n(!0);
  } : t.__on_r = () => n(!0), rT();
}
let nh = !1;
function hD(t) {
  nh = t;
}
let Bh = !1;
function fD(t) {
  Bh = t;
}
let Yt = null, Pa = !1;
function to(t) {
  Yt = t;
}
let Kt = null;
function Qa(t) {
  Kt = t;
}
let Hl = null;
function nT(t) {
  Yt !== null && (Hl === null ? Hl = [t] : Hl.push(t));
}
let Ai = null, Oo = 0, us = null;
function yX(t) {
  us = t;
}
let iT = 1, Gm = 0, ih = Gm;
function dD(t) {
  ih = t;
}
function oT() {
  return ++iT;
}
function Xg(t) {
  var e = t.f;
  if ((e & lo) !== 0)
    return !0;
  if (e & mi && (t.f &= ~Wm), (e & ru) !== 0) {
    var r = t.deps;
    if (r !== null)
      for (var n = r.length, i = 0; i < n; i++) {
        var o = r[i];
        if (Xg(
          /** @type {Derived} */
          o
        ) && ZF(
          /** @type {Derived} */
          o
        ), o.wv > t.wv)
          return !0;
      }
    (e & Ks) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    $o === null && hi(t, oi);
  }
  return !1;
}
function sT(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !Hl?.includes(t))
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      (o.f & mi) !== 0 ? sT(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? hi(o, lo) : (o.f & oi) !== 0 && hi(o, ru), yh(
        /** @type {Effect} */
        o
      ));
    }
}
function aT(t) {
  var e = Ai, r = Oo, n = us, i = Yt, o = Hl, s = uo, a = Pa, l = ih, u = t.f;
  Ai = /** @type {null | Value[]} */
  null, Oo = 0, us = null, Yt = (u & (tu | $h)) === 0 ? t : null, Hl = null, gd(t.ctx), Pa = !1, ih = ++Gm, t.ac !== null && (Kd(() => {
    t.ac.abort(Ff);
  }), t.ac = null);
  try {
    t.f |= s3;
    var c = (
      /** @type {Function} */
      t.fn
    ), h = c(), d = t.deps;
    if (Ai !== null) {
      var p;
      if (o1(t, Oo), d !== null && Oo > 0)
        for (d.length = Oo + Ai.length, p = 0; p < Ai.length; p++)
          d[Oo + p] = Ai[p];
      else
        t.deps = d = Ai;
      if (nh && Ob() && (t.f & Ks) !== 0)
        for (p = Oo; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Oo < d.length && (o1(t, Oo), d.length = Oo);
    if (IF() && us !== null && !Pa && d !== null && (t.f & (mi | ru | lo)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      us.length; p++)
        sT(
          us[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (Gm++, us !== null && (n === null ? n = us : n.push(.../** @type {Source[]} */
    us))), (t.f & qu) !== 0 && (t.f ^= qu), h;
  } catch (g) {
    return HF(g);
  } finally {
    t.f ^= s3, Ai = e, Oo = r, us = n, Yt = i, Hl = o, gd(s), Pa = a, ih = l;
  }
}
function bX(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = FK.call(r, t);
    if (n !== -1) {
      var i = r.length - 1;
      i === 0 ? r = e.reactions = null : (r[n] = r[i], r.pop());
    }
  }
  r === null && (e.f & mi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Ai === null || !Ai.includes(e)) && (hi(e, ru), (e.f & Ks) !== 0 && (e.f ^= Ks, e.f &= ~Wm), YF(
    /** @type {Derived} **/
    e
  ), o1(
    /** @type {Derived} **/
    e,
    0
  ));
}
function o1(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      bX(t, r[n]);
}
function Km(t) {
  var e = t.f;
  if ((e & ju) === 0) {
    hi(t, oi);
    var r = Kt, n = nh;
    Kt = t, nh = !0;
    try {
      (e & sl) !== 0 ? AX(t) : dT(t), fT(t);
      var i = aT(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = iT;
      var o;
      OK && HK && (t.f & lo) !== 0 && t.deps;
    } finally {
      nh = n, Kt = r;
    }
  }
}
async function xX() {
  await Promise.resolve(), VF();
}
function x(t) {
  var e = t.f, r = (e & mi) !== 0;
  if (Yt !== null && !Pa) {
    var n = Kt !== null && (Kt.f & ju) !== 0;
    if (!n && !Hl?.includes(t)) {
      var i = Yt.deps;
      if ((Yt.f & s3) !== 0)
        t.rv < Gm && (t.rv = Gm, Ai === null && i !== null && i[Oo] === t ? Oo++ : Ai === null ? Ai = [t] : Ai.includes(t) || Ai.push(t));
      else {
        (Yt.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Yt] : o.includes(Yt) || o.push(Yt);
      }
    }
  }
  if (Bh) {
    if (Hu.has(t))
      return Hu.get(t);
    if (r) {
      var s = (
        /** @type {Derived} */
        t
      ), a = s.v;
      return ((s.f & oi) === 0 && s.reactions !== null || uT(s)) && (a = H_(s)), Hu.set(s, a), a;
    }
  } else if (r) {
    if (s = /** @type {Derived} */
    t, $o?.has(s))
      return $o.get(s);
    Xg(s) && ZF(s), nh && Ob() && (s.f & Ks) === 0 && lT(s);
  } else if ($o?.has(t))
    return $o.get(t);
  if ((t.f & qu) !== 0)
    throw t.v;
  return t.v;
}
function lT(t) {
  if (t.deps !== null) {
    t.f ^= Ks;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & mi) !== 0 && (e.f & Ks) === 0 && lT(
        /** @type {Derived} */
        e
      );
  }
}
function uT(t) {
  if (t.v === Vn) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Hu.has(e) || (e.f & mi) !== 0 && uT(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function Ko(t) {
  var e = Pa;
  try {
    return Pa = !0, t();
  } finally {
    Pa = e;
  }
}
const wX = -7169;
function hi(t, e) {
  t.f = t.f & wX | e;
}
function kX(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (qa in t)
      h3(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && qa in r && h3(r);
      }
  }
}
function h3(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        h3(t[n], e);
      } catch {
      }
    const r = B_(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = DF(r);
      for (let i in n) {
        const o = n[i].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
function cT(t) {
  Kt === null && (Yt === null && $K(), NK()), Bh && RK();
}
function CX(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function al(t, e, r, n = !0) {
  var i = Kt;
  i !== null && (i.f & Uo) !== 0 && (t |= Uo);
  var o = {
    ctx: uo,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | lo | Ks,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      Km(o), o.f |= Gg;
    } catch (l) {
      throw zn(o), l;
    }
  else e !== null && yh(o);
  if (n) {
    var s = o;
    if (r && s.deps === null && s.teardown === null && s.nodes_start === null && s.first === s.last && // either `null`, or a singular child
    (s.f & Gd) === 0 && (s = s.first, (t & sl) !== 0 && (t & Ql) !== 0 && s !== null && (s.f |= Ql)), s !== null && (s.parent = i, i !== null && CX(s, i), Yt !== null && (Yt.f & mi) !== 0 && (t & $h) === 0)) {
      var a = (
        /** @type {Derived} */
        Yt
      );
      (a.effects ??= []).push(s);
    }
  }
  return o;
}
function Ob() {
  return Yt !== null && !Pa;
}
function Fb(t) {
  const e = al(Cb, null, !1);
  return hi(e, oi), e.teardown = t, e;
}
function Ws(t) {
  cT();
  var e = (
    /** @type {Effect} */
    Kt.f
  ), r = !Yt && (e & tu) !== 0 && (e & Gg) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      uo
    );
    (n.e ??= []).push(t);
  } else
    return hT(t);
}
function hT(t) {
  return al(kb | EF, t, !1);
}
function dt(t) {
  return cT(), al(Cb | EF, t, !0);
}
function _X(t) {
  Ma.ensure();
  const e = al($h | Gd, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? qf(e, () => {
      zn(e), n(void 0);
    }) : (zn(e), n(void 0));
  });
}
function Xd(t) {
  return al(kb, t, !1);
}
function SX(t) {
  return al(P_ | Gd, t, !0);
}
function Tb(t, e = 0) {
  return al(Cb | e, t, !0);
}
function Ee(t, e = [], r = [], n = [], i = !1) {
  QF(n, e, r, (o) => {
    al(i ? kb : Cb, () => t(...o.map(x)), !0);
  });
}
function pc(t, e = 0) {
  var r = al(sl | e, t, !0);
  return r;
}
function Ro(t, e = !0) {
  return al(tu | Gd, t, !0, e);
}
function fT(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Bh, n = Yt;
    fD(!0), to(null);
    try {
      e.call(null);
    } finally {
      fD(r), to(n);
    }
  }
}
function dT(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const i = r.ac;
    i !== null && Kd(() => {
      i.abort(Ff);
    });
    var n = r.next;
    (r.f & $h) !== 0 ? r.parent = null : zn(r, e), r = n;
  }
}
function AX(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & tu) === 0 && zn(e), e = r;
  }
}
function zn(t, e = !0) {
  var r = !1;
  (e || (t.f & AF) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (pT(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), r = !0), dT(t, e && !r), o1(t, 0), hi(t, ju);
  var n = t.transitions;
  if (n !== null)
    for (const o of n)
      o.stop();
  fT(t);
  var i = t.parent;
  i !== null && i.first !== null && mT(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function pT(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ia(t)
    );
    t.remove(), t = r;
  }
}
function mT(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function qf(t, e, r = !0) {
  var n = [];
  W_(t, n, !0), gT(n, () => {
    r && zn(t), e && e();
  });
}
function gT(t, e) {
  var r = t.length;
  if (r > 0) {
    var n = () => --r || e();
    for (var i of t)
      i.out(n);
  } else
    e();
}
function W_(t, e, r) {
  if ((t.f & Uo) === 0) {
    if (t.f ^= Uo, t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || r) && e.push(s);
    for (var n = t.first; n !== null; ) {
      var i = n.next, o = (n.f & Ql) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (n.f & tu) !== 0 && (t.f & sl) !== 0;
      W_(n, e, o ? r : !1), n = i;
    }
  }
}
function G_(t) {
  vT(t, !0);
}
function vT(t, e) {
  if ((t.f & Uo) !== 0) {
    t.f ^= Uo, (t.f & oi) === 0 && (hi(t, lo), yh(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, i = (r.f & Ql) !== 0 || (r.f & tu) !== 0;
      vT(r, i ? e : !1), r = n;
    }
    if (t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || e) && o.in();
  }
}
function yT(t, e) {
  for (var r = t.nodes_start, n = t.nodes_end; r !== null; ) {
    var i = r === n ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ia(r)
    );
    e.append(r), r = i;
  }
}
const bT = /* @__PURE__ */ new Set(), f3 = /* @__PURE__ */ new Set();
function xT(t, e, r, n = {}) {
  function i(o) {
    if (n.capture || hm.call(e, o), !o.cancelBubble)
      return Kd(() => r?.call(this, o));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? nu(() => {
    e.addEventListener(t, i, n);
  }) : e.addEventListener(t, i, n), i;
}
function EX(t, e, r, n, i) {
  var o = { capture: n, passive: i }, s = xT(t, e, r, o);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && Fb(() => {
    e.removeEventListener(t, s, o);
  });
}
function nn(t) {
  for (var e = 0; e < t.length; e++)
    bT.add(t[e]);
  for (var r of f3)
    r(t);
}
let pD = null;
function hm(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, i = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  pD = t;
  var s = 0, a = pD === t && t.__root;
  if (a) {
    var l = i.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    l <= u && (s = l);
  }
  if (o = /** @type {Element} */
  i[s] || t.target, o !== e) {
    I_(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Yt, h = Kt;
    to(null), Qa(null);
    try {
      for (var d, p = []; o !== null; ) {
        var g = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var v = o["__" + n];
          v != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && v.call(o, t);
        } catch (y) {
          d ? p.push(y) : d = y;
        }
        if (t.cancelBubble || g === e || g === null)
          break;
        o = g;
      }
      if (d) {
        for (let y of p)
          queueMicrotask(() => {
            throw y;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, to(c), Qa(h);
    }
  }
}
function K_(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Ho(t, e) {
  var r = (
    /** @type {Effect} */
    Kt
  );
  r.nodes_start === null && (r.nodes_start = t, r.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function me(t, e) {
  var r = (e & NF) !== 0, n = (e & eX) !== 0, i, o = !t.startsWith("<!>");
  return () => {
    if (wt)
      return Ho(qt, null), qt;
    i === void 0 && (i = K_(o ? t : "<!>" + t), r || (i = /** @type {Node} */
    /* @__PURE__ */ ni(i)));
    var s = (
      /** @type {TemplateNode} */
      n || zF ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ni(s)
      ), l = (
        /** @type {TemplateNode} */
        s.lastChild
      );
      Ho(a, l);
    } else
      Ho(s, s);
    return s;
  };
}
// @__NO_SIDE_EFFECTS__
function DX(t, e, r = "svg") {
  var n = !t.startsWith("<!>"), i = (e & NF) !== 0, o = `<${r}>${n ? t : "<!>" + t}</${r}>`, s;
  return () => {
    if (wt)
      return Ho(qt, null), qt;
    if (!s) {
      var a = (
        /** @type {DocumentFragment} */
        K_(o)
      ), l = (
        /** @type {Element} */
        /* @__PURE__ */ ni(a)
      );
      if (i)
        for (s = document.createDocumentFragment(); /* @__PURE__ */ ni(l); )
          s.appendChild(
            /** @type {Node} */
            /* @__PURE__ */ ni(l)
          );
      else
        s = /** @type {Element} */
        /* @__PURE__ */ ni(l);
    }
    var u = (
      /** @type {TemplateNode} */
      s.cloneNode(!0)
    );
    if (i) {
      var c = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ni(u)
      ), h = (
        /** @type {TemplateNode} */
        u.lastChild
      );
      Ho(c, h);
    } else
      Ho(u, u);
    return u;
  };
}
// @__NO_SIDE_EFFECTS__
function St(t, e) {
  return /* @__PURE__ */ DX(t, e, "svg");
}
function No(t = "") {
  if (!wt) {
    var e = ws(t + "");
    return Ho(e, e), e;
  }
  var r = qt;
  return r.nodeType !== Sb && (r.before(r = ws()), ci(r)), Ho(r, r), r;
}
function kr() {
  if (wt)
    return Ho(qt, null), qt;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = ws();
  return t.append(e, r), Ho(e, r), t;
}
function Q(t, e) {
  if (wt) {
    var r = (
      /** @type {Effect} */
      Kt
    );
    ((r.f & Gg) === 0 || r.nodes_end === null) && (r.nodes_end = qt), rc();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
function OX(t) {
  return t.endsWith("capture") && t !== "gotpointercapture" && t !== "lostpointercapture";
}
const FX = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function TX(t) {
  return FX.includes(t);
}
const MX = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function PX(t) {
  return t = t.toLowerCase(), MX[t] ?? t;
}
const RX = ["touchstart", "touchmove"];
function NX(t) {
  return RX.includes(t);
}
let d3 = !0;
function at(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function wT(t, e) {
  return kT(t, e);
}
function $X(t, e) {
  l3(), e.intro = e.intro ?? !1;
  const r = e.target, n = wt, i = qt;
  try {
    for (var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ni(r)
    ); o && (o.nodeType !== Ih || /** @type {Comment} */
    o.data !== $F); )
      o = /** @type {TemplateNode} */
      /* @__PURE__ */ ia(o);
    if (!o)
      throw vh;
    Hs(!0), ci(
      /** @type {Comment} */
      o
    );
    const s = kT(t, { ...e, anchor: o });
    return Hs(!1), /**  @type {Exports} */
    s;
  } catch (s) {
    if (s instanceof Error && s.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw s;
    return s !== vh && console.warn("Failed to hydrate: ", s), e.recover === !1 && BK(), l3(), UF(r), Hs(!1), wT(t, e);
  } finally {
    Hs(n), ci(i);
  }
}
const gf = /* @__PURE__ */ new Map();
function kT(t, { target: e, anchor: r, props: n = {}, events: i, context: o, intro: s = !0 }) {
  l3();
  var a = /* @__PURE__ */ new Set(), l = (h) => {
    for (var d = 0; d < h.length; d++) {
      var p = h[d];
      if (!a.has(p)) {
        a.add(p);
        var g = NX(p);
        e.addEventListener(p, hm, { passive: g });
        var v = gf.get(p);
        v === void 0 ? (document.addEventListener(p, hm, { passive: g }), gf.set(p, 1)) : gf.set(p, v + 1);
      }
    }
  };
  l($_(bT)), f3.add(l);
  var u = void 0, c = _X(() => {
    var h = r ?? e.appendChild(ws());
    return XF(
      /** @type {TemplateNode} */
      h,
      {
        pending: () => {
        }
      },
      (d) => {
        if (o) {
          nt({});
          var p = (
            /** @type {ComponentContext} */
            uo
          );
          p.c = o;
        }
        if (i && (n.$$events = i), wt && Ho(
          /** @type {TemplateNode} */
          d,
          null
        ), d3 = s, u = t(d, n) || {}, d3 = !0, wt && (Kt.nodes_end = qt, qt === null || qt.nodeType !== Ih || /** @type {Comment} */
        qt.data !== q_))
          throw Kg(), vh;
        o && it();
      }
    ), () => {
      for (var d of a) {
        e.removeEventListener(d, hm);
        var p = (
          /** @type {number} */
          gf.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, hm), gf.delete(d)) : gf.set(d, p);
      }
      f3.delete(l), h !== r && h.parentNode?.removeChild(h);
    };
  });
  return p3.set(u, c), u;
}
let p3 = /* @__PURE__ */ new WeakMap();
function IX(t, e) {
  const r = p3.get(t);
  return r ? (p3.delete(t), r(e)) : Promise.resolve();
}
function CT(t) {
  return new BX(t);
}
class BX {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, s) => {
      var a = /* @__PURE__ */ V_(s, !1, !1);
      return r.set(o, a), a;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, s) {
          return x(r.get(s) ?? n(s, Reflect.get(o, s)));
        },
        has(o, s) {
          return s === R_ ? !0 : (x(r.get(s) ?? n(s, Reflect.get(o, s))), Reflect.has(o, s));
        },
        set(o, s, a) {
          return ae(r.get(s) ?? n(s, a), a), Reflect.set(o, s, a);
        }
      }
    );
    this.#t = (e.hydrate ? $X : wT)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && VF(), this.#e = i.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || I_(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(s) {
          this.#t[o] = s;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(i, o);
    }, this.#t.$destroy = () => {
      IX(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...i) => r.call(this, ...i);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const LX = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(LX);
class Mb {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #r = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#n = r;
  }
  #l = () => {
    var e = (
      /** @type {Batch} */
      Ur
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        G_(n);
      else {
        var i = this.#r.get(r);
        i && (this.#t.set(r, i.effect), this.#r.delete(r), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), n = i.effect);
      }
      for (const [o, s] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(s);
        a && (zn(a.effect), this.#r.delete(s));
      }
      for (const [o, s] of this.#t) {
        if (o === r) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var l = document.createDocumentFragment();
            yT(s, l), l.append(ws()), this.#r.set(o, { effect: s, fragment: l });
          } else
            zn(s);
          this.#t.delete(o);
        };
        this.#n || !n ? qf(s, a, !1) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #a = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, i] of this.#r)
      r.includes(n) || (zn(i.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      Ur
    ), i = aX();
    r && !this.#t.has(e) && !this.#r.has(e) && this.#t.set(
      e,
      Ro(() => r(this.anchor))
    ), this.#e.set(n, e), i || (wt && (this.anchor = qt), this.#l());
  }
}
function Jl(t, e, ...r) {
  var n = new Mb(t);
  pc(() => {
    const i = e() ?? null;
    n.ensure(i, i && ((o) => i(o, ...r)));
  }, Ql);
}
function Qg(t) {
  uo === null && PF(), Ws(() => {
    const e = Ko(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function _T(t) {
  uo === null && PF(), Qg(() => () => Ko(t));
}
function Fe(t, e, r = !1) {
  wt && rc();
  var n = new Mb(t), i = r ? Ql : 0;
  function o(s, a) {
    if (wt) {
      const u = LF(t) === Ab;
      if (s === u) {
        var l = n1();
        ci(l), n.anchor = l, Hs(!1), n.ensure(s, a), Hs(!0);
        return;
      }
    }
    n.ensure(s, a);
  }
  pc(() => {
    var s = !1;
    e((a, l = !0) => {
      s = !0, o(l, a);
    }), s || o(!1, null);
  }, i);
}
function ST(t, e, r) {
  wt && rc();
  var n = new Mb(t);
  pc(() => {
    var i = e();
    n.ensure(i, r);
  });
}
let Dy = null;
function hr(t, e) {
  return e;
}
function zX(t, e, r) {
  for (var n = t.items, i = [], o = e.length, s = 0; s < o; s++)
    W_(e[s].e, i, !0);
  var a = o > 0 && i.length === 0 && r !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      r.parentNode
    );
    UF(l), l.append(
      /** @type {Element} */
      r
    ), n.clear(), wa(t, e[0].prev, e[o - 1].next);
  }
  gT(i, () => {
    for (var u = 0; u < o; u++) {
      var c = e[u];
      a || (n.delete(c.k), wa(t, c.prev, c.next)), zn(c.e, !a);
    }
  });
}
function It(t, e, r, n, i, o = null) {
  var s = t, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & RF) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    s = wt ? ci(
      /** @type {Comment | Text} */
      /* @__PURE__ */ ni(u)
    ) : u.appendChild(ws());
  }
  wt && rc();
  var c = null, h = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ JF(() => {
    var b = r();
    return N_(b) ? b : b == null ? [] : $_(b);
  }), g, v;
  function y() {
    jX(
      v,
      g,
      a,
      d,
      s,
      i,
      e,
      n,
      r
    ), o !== null && (g.length === 0 ? c ? G_(c) : c = Ro(() => o(s)) : c !== null && qf(c, () => {
      c = null;
    }));
  }
  pc(() => {
    v ??= /** @type {Effect} */
    Kt, g = /** @type {V[]} */
    x(p);
    var b = g.length;
    if (h && b === 0)
      return;
    h = b === 0;
    let k = !1;
    if (wt) {
      var C = LF(s) === Ab;
      C !== (b === 0) && (s = n1(), ci(s), Hs(!1), k = !0);
    }
    if (wt) {
      for (var S = null, _, D = 0; D < b; D++) {
        if (qt.nodeType === Ih && /** @type {Comment} */
        qt.data === q_) {
          s = /** @type {Comment} */
          qt, k = !0, Hs(!1);
          break;
        }
        var A = g[D], O = n(A, D);
        _ = AT(
          qt,
          a,
          S,
          null,
          A,
          O,
          D,
          i,
          e,
          r
        ), a.items.set(O, _), S = _;
      }
      b > 0 && ci(n1());
    }
    wt ? b === 0 && o && (c = Ro(() => o(s))) : y(), k && Hs(!0), x(p);
  }), wt && (s = qt);
}
function jX(t, e, r, n, i, o, s, a, l) {
  var u = (s & VK) !== 0, c = (s & (z_ | j_)) !== 0, h = e.length, d = r.items, p = r.first, g = p, v, y = null, b, k = [], C = [], S, _, D, A;
  if (u)
    for (A = 0; A < h; A += 1)
      S = e[A], _ = a(S, A), D = d.get(_), D !== void 0 && (D.a?.measure(), (b ??= /* @__PURE__ */ new Set()).add(D));
  for (A = 0; A < h; A += 1) {
    if (S = e[A], _ = a(S, A), D = d.get(_), D === void 0) {
      var O = n.get(_);
      if (O !== void 0) {
        n.delete(_), d.set(_, O);
        var M = y ? y.next : g;
        wa(r, y, O), wa(r, O, M), h2(O, M, i), y = O;
      } else {
        var z = g ? (
          /** @type {TemplateNode} */
          g.e.nodes_start
        ) : i;
        y = AT(
          z,
          r,
          y,
          y === null ? r.first : y.next,
          S,
          _,
          A,
          o,
          s,
          l
        );
      }
      d.set(_, y), k = [], C = [], g = y.next;
      continue;
    }
    if (c && qX(D, S, A, s), (D.e.f & Uo) !== 0 && (G_(D.e), u && (D.a?.unfix(), (b ??= /* @__PURE__ */ new Set()).delete(D))), D !== g) {
      if (v !== void 0 && v.has(D)) {
        if (k.length < C.length) {
          var N = C[0], P;
          y = N.prev;
          var I = k[0], B = k[k.length - 1];
          for (P = 0; P < k.length; P += 1)
            h2(k[P], N, i);
          for (P = 0; P < C.length; P += 1)
            v.delete(C[P]);
          wa(r, I.prev, B.next), wa(r, y, I), wa(r, B, N), g = N, y = B, A -= 1, k = [], C = [];
        } else
          v.delete(D), h2(D, g, i), wa(r, D.prev, D.next), wa(r, D, y === null ? r.first : y.next), wa(r, y, D), y = D;
        continue;
      }
      for (k = [], C = []; g !== null && g.k !== _; )
        (g.e.f & Uo) === 0 && (v ??= /* @__PURE__ */ new Set()).add(g), C.push(g), g = g.next;
      if (g === null)
        continue;
      D = g;
    }
    k.push(D), y = D, g = D.next;
  }
  if (g !== null || v !== void 0) {
    for (var $ = v === void 0 ? [] : $_(v); g !== null; )
      (g.e.f & Uo) === 0 && $.push(g), g = g.next;
    var j = $.length;
    if (j > 0) {
      var U = (s & RF) !== 0 && h === 0 ? i : null;
      if (u) {
        for (A = 0; A < j; A += 1)
          $[A].a?.measure();
        for (A = 0; A < j; A += 1)
          $[A].a?.fix();
      }
      zX(r, $, U);
    }
  }
  u && nu(() => {
    if (b !== void 0)
      for (D of b)
        D.a?.apply();
  }), t.first = r.first && r.first.e, t.last = y && y.e;
  for (var H of n.values())
    zn(H.e);
  n.clear();
}
function qX(t, e, r, n) {
  (n & z_) !== 0 && yd(t.v, e), (n & j_) !== 0 ? yd(
    /** @type {Value<number>} */
    t.i,
    r
  ) : t.i = r;
}
function AT(t, e, r, n, i, o, s, a, l, u, c) {
  var h = Dy, d = (l & z_) !== 0, p = (l & WK) === 0, g = d ? p ? /* @__PURE__ */ V_(i, !1, !1) : bh(i) : i, v = (l & j_) === 0 ? s : bh(s), y = {
    i: v,
    v: g,
    k: o,
    a: null,
    // @ts-expect-error
    e: null,
    prev: r,
    next: n
  };
  Dy = y;
  try {
    if (t === null) {
      var b = document.createDocumentFragment();
      b.append(t = ws());
    }
    return y.e = Ro(() => a(
      /** @type {Node} */
      t,
      g,
      v,
      u
    ), wt), y.e.prev = r && r.e, y.e.next = n && n.e, r === null ? c || (e.first = y) : (r.next = y, r.e.next = y.e), n !== null && (n.prev = y, n.e.prev = y.e), y;
  } finally {
    Dy = h;
  }
}
function h2(t, e, r) {
  for (var n = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : r, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : r, o = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); o !== null && o !== n; ) {
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ia(o)
    );
    i.before(o), o = s;
  }
}
function wa(t, e, r) {
  e === null ? t.first = r : (e.next = r, e.e.next = r && r.e), r !== null && (r.prev = e, r.e.prev = e && e.e);
}
function UX(t, e, r = !1, n = !1, i = !1) {
  var o = t, s = "";
  Ee(() => {
    var a = (
      /** @type {Effect} */
      Kt
    );
    if (s === (s = e() ?? "")) {
      wt && rc();
      return;
    }
    if (a.nodes_start !== null && (pT(
      a.nodes_start,
      /** @type {TemplateNode} */
      a.nodes_end
    ), a.nodes_start = a.nodes_end = null), s !== "") {
      if (wt) {
        qt.data;
        for (var l = rc(), u = l; l !== null && (l.nodeType !== Ih || /** @type {Comment} */
        l.data !== ""); )
          u = l, l = /** @type {TemplateNode} */
          /* @__PURE__ */ ia(l);
        if (l === null)
          throw Kg(), vh;
        Ho(qt, u), o = ci(l);
        return;
      }
      var c = s + "";
      r ? c = `<svg>${c}</svg>` : n && (c = `<math>${c}</math>`);
      var h = K_(c);
      if ((r || n) && (h = /** @type {Element} */
      /* @__PURE__ */ ni(h)), Ho(
        /** @type {TemplateNode} */
        /* @__PURE__ */ ni(h),
        /** @type {TemplateNode} */
        h.lastChild
      ), r || n)
        for (; /* @__PURE__ */ ni(h); )
          o.before(
            /** @type {Node} */
            /* @__PURE__ */ ni(h)
          );
      else
        o.before(h);
    }
  });
}
function Qd(t, e, r) {
  wt && rc();
  var n = new Mb(t);
  pc(() => {
    var i = e() ?? null;
    n.ensure(i, i && ((o) => r(o, i)));
  }, Ql);
}
function Mo(t, e, r) {
  Xd(() => {
    var n = Ko(() => e(t, r?.()) || {});
    if (r && n?.update) {
      var i = !1, o = (
        /** @type {any} */
        {}
      );
      Tb(() => {
        var s = r();
        kX(s), i && L_(o, s) && (o = s, n.update(s));
      }), i = !0;
    }
    if (n?.destroy)
      return () => (
        /** @type {Function} */
        n.destroy()
      );
  });
}
function HX(t, e) {
  var r = void 0, n;
  pc(() => {
    r !== (r = e()) && (n && (zn(n), n = null), r && (n = Ro(() => {
      Xd(() => (
        /** @type {(node: Element) => void} */
        r(t)
      ));
    })));
  });
}
function ET(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (r = ET(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function VX() {
  for (var t, e, r = 0, n = "", i = arguments.length; r < i; r++) (t = arguments[r]) && (e = ET(t)) && (n && (n += " "), n += e);
  return n;
}
function Pb(t) {
  return typeof t == "object" ? VX(t) : t ?? "";
}
const mD = [...` 	
\r\fÂ \v\uFEFF`];
function WX(t, e, r) {
  var n = t == null ? "" : "" + t;
  if (e && (n = n ? n + " " + e : e), r) {
    for (var i in r)
      if (r[i])
        n = n ? n + " " + i : i;
      else if (n.length)
        for (var o = i.length, s = 0; (s = n.indexOf(i, s)) >= 0; ) {
          var a = s + o;
          (s === 0 || mD.includes(n[s - 1])) && (a === n.length || mD.includes(n[a])) ? n = (s === 0 ? "" : n.substring(0, s)) + n.substring(a + 1) : s = a;
        }
  }
  return n === "" ? null : n;
}
function gD(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var i in t) {
    var o = t[i];
    o != null && o !== "" && (n += " " + i + ": " + o + r);
  }
  return n;
}
function f2(t) {
  return t[0] !== "-" || t[1] !== "-" ? t.toLowerCase() : t;
}
function GX(t, e) {
  if (e) {
    var r = "", n, i;
    if (Array.isArray(e) ? (n = e[0], i = e[1]) : n = e, t) {
      t = String(t).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var o = !1, s = 0, a = !1, l = [];
      n && l.push(...Object.keys(n).map(f2)), i && l.push(...Object.keys(i).map(f2));
      var u = 0, c = -1;
      const v = t.length;
      for (var h = 0; h < v; h++) {
        var d = t[h];
        if (a ? d === "/" && t[h - 1] === "*" && (a = !1) : o ? o === d && (o = !1) : d === "/" && t[h + 1] === "*" ? a = !0 : d === '"' || d === "'" ? o = d : d === "(" ? s++ : d === ")" && s--, !a && o === !1 && s === 0) {
          if (d === ":" && c === -1)
            c = h;
          else if (d === ";" || h === v - 1) {
            if (c !== -1) {
              var p = f2(t.substring(u, c).trim());
              if (!l.includes(p)) {
                d !== ";" && h++;
                var g = t.substring(u, h).trim();
                r += " " + g + ";";
              }
            }
            u = h + 1, c = -1;
          }
        }
      }
    }
    return n && (r += gD(n)), i && (r += gD(i, !0)), r = r.trim(), r === "" ? null : r;
  }
  return t == null ? null : String(t);
}
function en(t, e, r, n, i, o) {
  var s = t.__className;
  if (wt || s !== r || s === void 0) {
    var a = WX(r, n, o);
    (!wt || a !== t.getAttribute("class")) && (a == null ? t.removeAttribute("class") : e ? t.className = a : t.setAttribute("class", a)), t.__className = r;
  } else if (o && i !== o)
    for (var l in o) {
      var u = !!o[l];
      (i == null || u !== !!i[l]) && t.classList.toggle(l, u);
    }
  return o;
}
function d2(t, e = {}, r, n) {
  for (var i in r) {
    var o = r[i];
    e[i] !== o && (r[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, o, n));
  }
}
function ct(t, e, r, n) {
  var i = t.__style;
  if (wt || i !== e) {
    var o = GX(e, n);
    (!wt || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (d2(t, r?.[0], n[0]), d2(t, r?.[1], n[1], "important")) : d2(t, r, n));
  return n;
}
function bd(t, e, r = !1) {
  if (t.multiple) {
    if (e == null)
      return;
    if (!N_(e))
      return iX();
    for (var n of t.options)
      n.selected = e.includes(vD(n));
    return;
  }
  for (n of t.options) {
    var i = vD(n);
    if (sX(i, e)) {
      n.selected = !0;
      return;
    }
  }
  (!r || e !== void 0) && (t.selectedIndex = -1);
}
function s1(t) {
  var e = new MutationObserver(() => {
    bd(t, t.__value);
  });
  e.observe(t, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), Fb(() => {
    e.disconnect();
  });
}
function vD(t) {
  return "__value" in t ? t.__value : t.value;
}
const Vp = Symbol("class"), Wp = Symbol("style"), DT = Symbol("is custom element"), OT = Symbol("is html");
function FT(t) {
  if (wt) {
    var e = !1, r = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var n = t.value;
          te(t, "value", null), t.value = n;
        }
        if (t.hasAttribute("checked")) {
          var i = t.checked;
          te(t, "checked", null), t.checked = i;
        }
      }
    };
    t.__on_r = r, nu(r), rT();
  }
}
function KX(t, e) {
  e ? t.hasAttribute("selected") || t.setAttribute("selected", "") : t.removeAttribute("selected");
}
function te(t, e, r, n) {
  var i = TT(t);
  wt && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = r) && (e === "loading" && (t[DK] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && MT(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function XX(t, e, r, n, i = !1, o = !1) {
  if (wt && i && t.tagName === "INPUT") {
    var s = (
      /** @type {HTMLInputElement} */
      t
    ), a = s.type === "checkbox" ? "defaultChecked" : "defaultValue";
    a in r || FT(s);
  }
  var l = TT(t), u = l[DT], c = !l[OT];
  let h = wt && u;
  h && Hs(!1);
  var d = e || {}, p = t.tagName === "OPTION";
  for (var g in e)
    g in r || (r[g] = null);
  r.class ? r.class = Pb(r.class) : r[Vp] && (r.class = null), r[Wp] && (r.style ??= null);
  var v = MT(t);
  for (const D in r) {
    let A = r[D];
    if (p && D === "value" && A == null) {
      t.value = t.__value = "", d[D] = A;
      continue;
    }
    if (D === "class") {
      var y = t.namespaceURI === "http://www.w3.org/1999/xhtml";
      en(t, y, A, n, e?.[Vp], r[Vp]), d[D] = A, d[Vp] = r[Vp];
      continue;
    }
    if (D === "style") {
      ct(t, A, e?.[Wp], r[Wp]), d[D] = A, d[Wp] = r[Wp];
      continue;
    }
    var b = d[D];
    if (!(A === b && !(A === void 0 && t.hasAttribute(D)))) {
      d[D] = A;
      var k = D[0] + D[1];
      if (k !== "$$")
        if (k === "on") {
          const O = {}, M = "$$" + D;
          let z = D.slice(2);
          var C = TX(z);
          if (OX(z) && (z = z.slice(0, -7), O.capture = !0), !C && b) {
            if (A != null) continue;
            t.removeEventListener(z, d[M], O), d[M] = null;
          }
          if (A != null)
            if (C)
              t[`__${z}`] = A, nn([z]);
            else {
              let N = function(P) {
                d[D].call(this, P);
              };
              d[M] = xT(z, t, N, O);
            }
          else C && (t[`__${z}`] = void 0);
        } else if (D === "style")
          te(t, D, A);
        else if (D === "autofocus")
          gX(
            /** @type {HTMLElement} */
            t,
            !!A
          );
        else if (!u && (D === "__value" || D === "value" && A != null))
          t.value = t.__value = A;
        else if (D === "selected" && p)
          KX(
            /** @type {HTMLOptionElement} */
            t,
            A
          );
        else {
          var S = D;
          c || (S = PX(S));
          var _ = S === "defaultValue" || S === "defaultChecked";
          if (A == null && !u && !_)
            if (l[D] = null, S === "value" || S === "checked") {
              let O = (
                /** @type {HTMLInputElement} */
                t
              );
              const M = e === void 0;
              if (S === "value") {
                let z = O.defaultValue;
                O.removeAttribute(S), O.defaultValue = z, O.value = O.__value = M ? z : null;
              } else {
                let z = O.defaultChecked;
                O.removeAttribute(S), O.defaultChecked = z, O.checked = M ? z : !1;
              }
            } else
              t.removeAttribute(D);
          else _ || v.includes(S) && (u || typeof A != "string") ? (t[S] = A, S in l && (l[S] = Vn)) : typeof A != "function" && te(t, S, A);
        }
    }
  }
  return h && Hs(!0), d;
}
function Qo(t, e, r = [], n = [], i = [], o, s = !1, a = !1) {
  QF(i, r, n, (l) => {
    var u = void 0, c = {}, h = t.nodeName === "SELECT", d = !1;
    if (pc(() => {
      var g = e(...l.map(x)), v = XX(
        t,
        u,
        g,
        o,
        s,
        a
      );
      d && h && "value" in g && bd(
        /** @type {HTMLSelectElement} */
        t,
        g.value
      );
      for (let b of Object.getOwnPropertySymbols(c))
        g[b] || zn(c[b]);
      for (let b of Object.getOwnPropertySymbols(g)) {
        var y = g[b];
        b.description === rX && (!u || y !== u[b]) && (c[b] && zn(c[b]), c[b] = Ro(() => HX(t, () => y))), v[b] = y;
      }
      u = v;
    }), h) {
      var p = (
        /** @type {HTMLSelectElement} */
        t
      );
      Xd(() => {
        bd(
          p,
          /** @type {Record<string | symbol, any>} */
          u.value,
          !0
        ), s1(p);
      });
    }
    d = !0;
  });
}
function TT(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [DT]: t.nodeName.includes("-"),
      [OT]: t.namespaceURI === tX
    }
  );
}
var yD = /* @__PURE__ */ new Map();
function MT(t) {
  var e = t.getAttribute("is") || t.nodeName, r = yD.get(e);
  if (r) return r;
  yD.set(e, r = []);
  for (var n, i = t, o = Element.prototype; o !== i; ) {
    n = DF(i);
    for (var s in n)
      n[s].set && r.push(s);
    i = B_(i);
  }
  return r;
}
const QX = () => performance.now(), Rl = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    ((t) => requestAnimationFrame(t))
  ),
  now: () => QX(),
  tasks: /* @__PURE__ */ new Set()
};
function PT() {
  const t = Rl.now();
  Rl.tasks.forEach((e) => {
    e.c(t) || (Rl.tasks.delete(e), e.f());
  }), Rl.tasks.size !== 0 && Rl.tick(PT);
}
function JX(t) {
  let e;
  return Rl.tasks.size === 0 && Rl.tick(PT), {
    promise: new Promise((r) => {
      Rl.tasks.add(e = { c: t, f: r });
    }),
    abort() {
      Rl.tasks.delete(e);
    }
  };
}
function kv(t, e) {
  Kd(() => {
    t.dispatchEvent(new CustomEvent(e));
  });
}
function YX(t) {
  if (t === "float") return "cssFloat";
  if (t === "offset") return "cssOffset";
  if (t.startsWith("--")) return t;
  const e = t.split("-");
  return e.length === 1 ? e[0] : e[0] + e.slice(1).map(
    /** @param {any} word */
    (r) => r[0].toUpperCase() + r.slice(1)
  ).join("");
}
function bD(t) {
  const e = {}, r = t.split(";");
  for (const n of r) {
    const [i, o] = n.split(":");
    if (!i || o === void 0) break;
    const s = YX(i.trim());
    e[s] = o.trim();
  }
  return e;
}
const ZX = (t) => t;
function xD(t, e, r) {
  var n = (
    /** @type {EachItem} */
    Dy
  ), i, o, s, a = null;
  n.a ??= {
    element: t,
    measure() {
      i = this.element.getBoundingClientRect();
    },
    apply() {
      if (s?.abort(), o = this.element.getBoundingClientRect(), i.left !== o.left || i.right !== o.right || i.top !== o.top || i.bottom !== o.bottom) {
        const l = e()(this.element, { from: i, to: o }, r?.());
        s = a1(this.element, l, void 0, 1, () => {
          s?.abort(), s = void 0;
        });
      }
    },
    fix() {
      if (!t.getAnimations().length) {
        var { position: l, width: u, height: c } = getComputedStyle(t);
        if (l !== "absolute" && l !== "fixed") {
          var h = (
            /** @type {HTMLElement | SVGElement} */
            t.style
          );
          a = {
            position: h.position,
            width: h.width,
            height: h.height,
            transform: h.transform
          }, h.position = "absolute", h.width = u, h.height = c;
          var d = t.getBoundingClientRect();
          if (i.left !== d.left || i.top !== d.top) {
            var p = `translate(${i.left - d.left}px, ${i.top - d.top}px)`;
            h.transform = h.transform ? `${h.transform} ${p}` : p;
          }
        }
      }
    },
    unfix() {
      if (a) {
        var l = (
          /** @type {HTMLElement | SVGElement} */
          t.style
        );
        l.position = a.position, l.width = a.width, l.height = a.height, l.transform = a.transform;
      }
    }
  }, n.a.element = t;
}
function fm(t, e, r, n) {
  var i = (t & JK) !== 0, o = (t & YK) !== 0, s = i && o, a = (t & ZK) !== 0, l = s ? "both" : i ? "in" : "out", u, c = e.inert, h = e.style.overflow, d, p;
  function g() {
    return Kd(() => u ??= r()(e, n?.() ?? /** @type {P} */
    {}, {
      direction: l
    }));
  }
  var v = {
    is_global: a,
    in() {
      if (e.inert = c, !i) {
        p?.abort(), p?.reset?.();
        return;
      }
      o || d?.abort(), kv(e, "introstart"), d = a1(e, g(), p, 1, () => {
        kv(e, "introend"), d?.abort(), d = u = void 0, e.style.overflow = h;
      });
    },
    out(C) {
      if (!o) {
        C?.(), u = void 0;
        return;
      }
      e.inert = !0, kv(e, "outrostart"), p = a1(e, g(), d, 0, () => {
        kv(e, "outroend"), C?.();
      });
    },
    stop: () => {
      d?.abort(), p?.abort();
    }
  }, y = (
    /** @type {Effect} */
    Kt
  );
  if ((y.transitions ??= []).push(v), i && d3) {
    var b = a;
    if (!b) {
      for (var k = (
        /** @type {Effect | null} */
        y.parent
      ); k && (k.f & Ql) !== 0; )
        for (; (k = k.parent) && (k.f & sl) === 0; )
          ;
      b = !k || (k.f & Gg) !== 0;
    }
    b && Xd(() => {
      Ko(() => v.in());
    });
  }
}
function a1(t, e, r, n, i) {
  var o = n === 1;
  if (Sf(e)) {
    var s, a = !1;
    return nu(() => {
      if (!a) {
        var y = e({ direction: o ? "in" : "out" });
        s = a1(t, y, r, n, i);
      }
    }), {
      abort: () => {
        a = !0, s?.abort();
      },
      deactivate: () => s.deactivate(),
      reset: () => s.reset(),
      t: () => s.t()
    };
  }
  if (r?.deactivate(), !e?.duration)
    return i(), {
      abort: jt,
      deactivate: jt,
      reset: jt,
      t: () => n
    };
  const { delay: l = 0, css: u, tick: c, easing: h = ZX } = e;
  var d = [];
  if (o && r === void 0 && (c && c(0, 1), u)) {
    var p = bD(u(0, 1));
    d.push(p, p);
  }
  var g = () => 1 - n, v = t.animate(d, { duration: l, fill: "forwards" });
  return v.onfinish = () => {
    v.cancel();
    var y = r?.t() ?? 1 - n;
    r?.abort();
    var b = n - y, k = (
      /** @type {number} */
      e.duration * Math.abs(b)
    ), C = [];
    if (k > 0) {
      var S = !1;
      if (u)
        for (var _ = Math.ceil(k / 16.666666666666668), D = 0; D <= _; D += 1) {
          var A = y + b * h(D / _), O = bD(u(A, 1 - A));
          C.push(O), S ||= O.overflow === "hidden";
        }
      S && (t.style.overflow = "hidden"), g = () => {
        var M = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          v.currentTime
        );
        return y + b * h(M / k);
      }, c && JX(() => {
        if (v.playState !== "running") return !1;
        var M = g();
        return c(M, 1 - M), !0;
      });
    }
    v = t.animate(C, { duration: k, fill: "forwards" }), v.onfinish = () => {
      g = () => n, c?.(n, 1 - n), i();
    };
  }, {
    abort: () => {
      v && (v.cancel(), v.effect = null, v.onfinish = jt);
    },
    deactivate: () => {
      i = jt;
    },
    reset: () => {
      n === 0 && c?.(1, 0);
    },
    t: () => g()
  };
}
function eQ(t, e, r = e) {
  var n = /* @__PURE__ */ new WeakSet();
  vX(t, "input", async (i) => {
    var o = i ? t.defaultValue : t.value;
    if (o = p2(t) ? m2(o) : o, r(o), Ur !== null && n.add(Ur), await xX(), o !== (o = e())) {
      var s = t.selectionStart, a = t.selectionEnd, l = t.value.length;
      if (t.value = o ?? "", a !== null) {
        var u = t.value.length;
        s === a && a === l && u > l ? (t.selectionStart = u, t.selectionEnd = u) : (t.selectionStart = s, t.selectionEnd = Math.min(a, u));
      }
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (wt && t.defaultValue !== t.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  Ko(e) == null && t.value) && (r(p2(t) ? m2(t.value) : t.value), Ur !== null && n.add(Ur)), Tb(() => {
    var i = e();
    if (t === document.activeElement) {
      var o = (
        /** @type {Batch} */
        Ey ?? Ur
      );
      if (n.has(o))
        return;
    }
    p2(t) && i === m2(t.value) || t.type === "date" && !i && !t.value || i !== t.value && (t.value = i ?? "");
  });
}
function p2(t) {
  var e = t.type;
  return e === "number" || e === "range";
}
function m2(t) {
  return t === "" ? null : +t;
}
class X_ {
  /** */
  #e = /* @__PURE__ */ new WeakMap();
  /** @type {ResizeObserver | undefined} */
  #t;
  /** @type {ResizeObserverOptions} */
  #r;
  /** @static */
  static entries = /* @__PURE__ */ new WeakMap();
  /** @param {ResizeObserverOptions} options */
  constructor(e) {
    this.#r = e;
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(e, r) {
    var n = this.#e.get(e) || /* @__PURE__ */ new Set();
    return n.add(r), this.#e.set(e, n), this.#n().observe(e, this.#r), () => {
      var i = this.#e.get(e);
      i.delete(r), i.size === 0 && (this.#e.delete(e), this.#t.unobserve(e));
    };
  }
  #n() {
    return this.#t ?? (this.#t = new ResizeObserver(
      /** @param {any} entries */
      (e) => {
        for (var r of e) {
          X_.entries.set(r.target, r);
          for (var n of this.#e.get(r.target) || [])
            n(r);
        }
      }
    ));
  }
}
var tQ = /* @__PURE__ */ new X_({
  box: "border-box"
});
function Xs(t, e, r) {
  var n = tQ.observe(t, () => r(t[e]));
  Xd(() => (Ko(() => r(t[e])), n));
}
function wD(t, e) {
  return t === e || t?.[qa] === e;
}
function Qs(t = {}, e, r, n) {
  return Xd(() => {
    var i, o;
    return Tb(() => {
      i = o, o = [], Ko(() => {
        t !== r(...o) && (e(t, ...o), i && wD(r(...i), t) && e(null, ...i));
      });
    }), () => {
      nu(() => {
        o && wD(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
function Q_(t, e, r) {
  if (t == null)
    return e(void 0), r && r(void 0), jt;
  const n = Ko(
    () => t.subscribe(
      e,
      // @ts-expect-error
      r
    )
  );
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
const vf = [];
function rQ(t, e) {
  return {
    subscribe: Uf(t, e).subscribe
  };
}
function Uf(t, e = jt) {
  let r = null;
  const n = /* @__PURE__ */ new Set();
  function i(a) {
    if (L_(t, a) && (t = a, r)) {
      const l = !vf.length;
      for (const u of n)
        u[1](), vf.push(u, t);
      if (l) {
        for (let u = 0; u < vf.length; u += 2)
          vf[u][0](vf[u + 1]);
        vf.length = 0;
      }
    }
  }
  function o(a) {
    i(a(
      /** @type {T} */
      t
    ));
  }
  function s(a, l = jt) {
    const u = [a, l];
    return n.add(u), n.size === 1 && (r = e(i, o) || jt), a(
      /** @type {T} */
      t
    ), () => {
      n.delete(u), n.size === 0 && r && (r(), r = null);
    };
  }
  return { set: i, update: o, subscribe: s };
}
function nQ(t, e, r) {
  const n = !Array.isArray(t), i = n ? [t] : t;
  if (!i.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const o = e.length < 2;
  return rQ(r, (s, a) => {
    let l = !1;
    const u = [];
    let c = 0, h = jt;
    const d = () => {
      if (c)
        return;
      h();
      const g = e(n ? u[0] : u, s, a);
      o ? s(g) : h = typeof g == "function" ? g : jt;
    }, p = i.map(
      (g, v) => Q_(
        g,
        (y) => {
          u[v] = y, c &= ~(1 << v), l && d();
        },
        () => {
          c |= 1 << v;
        }
      )
    );
    return l = !0, d(), function() {
      OF(p), h(), l = !1;
    };
  });
}
function iQ(t) {
  let e;
  return Q_(t, (r) => e = r)(), e;
}
let Cv = !1, m3 = Symbol();
function gi(t, e, r) {
  const n = r[e] ??= {
    store: null,
    source: /* @__PURE__ */ V_(void 0),
    unsubscribe: jt
  };
  if (n.store !== t && !(m3 in r))
    if (n.unsubscribe(), n.store = t ?? null, t == null)
      n.source.v = void 0, n.unsubscribe = jt;
    else {
      var i = !0;
      n.unsubscribe = Q_(t, (o) => {
        i ? n.source.v = o : ae(n.source, o);
      }), i = !1;
    }
  return t && m3 in r ? iQ(t) : x(n.source);
}
function kD(t, e) {
  return t.set(e), e;
}
function Jo() {
  const t = {};
  function e() {
    Fb(() => {
      for (var r in t)
        t[r].unsubscribe();
      I_(t, m3, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [t, e];
}
function oQ(t) {
  var e = Cv;
  try {
    return Cv = !1, [t(), Cv];
  } finally {
    Cv = e;
  }
}
const sQ = {
  get(t, e) {
    if (!t.exclude.includes(e))
      return t.props[e];
  },
  set(t, e) {
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    if (!t.exclude.includes(e) && e in t.props)
      return {
        enumerable: !0,
        configurable: !0,
        value: t.props[e]
      };
  },
  has(t, e) {
    return t.exclude.includes(e) ? !1 : e in t.props;
  },
  ownKeys(t) {
    return Reflect.ownKeys(t.props).filter((e) => !t.exclude.includes(e));
  }
};
// @__NO_SIDE_EFFECTS__
function jn(t, e, r) {
  return new Proxy(
    { props: t, exclude: e },
    sQ
  );
}
const aQ = {
  get(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Sf(n) && (n = n()), typeof n == "object" && n !== null && e in n) return n[e];
    }
  },
  set(t, e, r) {
    let n = t.props.length;
    for (; n--; ) {
      let i = t.props[n];
      Sf(i) && (i = i());
      const o = Uu(i, e);
      if (o && o.set)
        return o.set(r), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Sf(n) && (n = n()), typeof n == "object" && n !== null && e in n) {
        const i = Uu(n, e);
        return i && !i.configurable && (i.configurable = !0), i;
      }
    }
  },
  has(t, e) {
    if (e === qa || e === R_) return !1;
    for (let r of t.props)
      if (Sf(r) && (r = r()), r != null && e in r) return !0;
    return !1;
  },
  ownKeys(t) {
    const e = [];
    for (let r of t.props)
      if (Sf(r) && (r = r()), !!r) {
        for (const n in r)
          e.includes(n) || e.push(n);
        for (const n of Object.getOwnPropertySymbols(r))
          e.includes(n) || e.push(n);
      }
    return e;
  }
};
function lQ(...t) {
  return new Proxy({ props: t }, aQ);
}
function lt(t, e, r, n) {
  var i = (r & XK) !== 0, o = (r & QK) !== 0, s = (
    /** @type {V} */
    n
  ), a = !0, l = () => (a && (a = !1, s = o ? Ko(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), s), u;
  if (i) {
    var c = qa in t || R_ in t;
    u = Uu(t, e)?.set ?? (c && e in t ? (k) => t[e] = k : void 0);
  }
  var h, d = !1;
  i ? [h, d] = oQ(() => (
    /** @type {V} */
    t[e]
  )) : h = /** @type {V} */
  t[e], h === void 0 && n !== void 0 && (h = l(), u && (LK(), u(h)));
  var p;
  if (p = () => {
    var k = (
      /** @type {V} */
      t[e]
    );
    return k === void 0 ? l() : (a = !0, k);
  }, (r & KK) === 0)
    return p;
  if (u) {
    var g = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(k, C) {
        return arguments.length > 0 ? ((!C || g || d) && u(C ? p() : k), k) : p();
      })
    );
  }
  var v = !1, y = ((r & GK) !== 0 ? Db : JF)(() => (v = !1, p()));
  i && x(y);
  var b = (
    /** @type {Effect} */
    Kt
  );
  return (
    /** @type {() => V} */
    (function(k, C) {
      if (arguments.length > 0) {
        const S = C ? x(y) : i ? ps(k) : k;
        return ae(y, S), v = !0, s !== void 0 && (s = S), k;
      }
      return Bh && v || (b.f & ju) !== 0 ? y.v : x(y);
    })
  );
}
var uQ = /* @__PURE__ */ me('<div class="bg-white dark:bg-black rounded-md flex flex-col overflow-hidden"><div class="p-2 bg-slate-100"> </div> <!></div>'), cQ = /* @__PURE__ */ me('<div class="w-full h-full flex flex-row flex-wrap gap-2 overflow-y-scroll"></div>');
function hQ(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(100), n = /* @__PURE__ */ De(100), i = /* @__PURE__ */ K(() => Object.keys(e.charts)), o = /* @__PURE__ */ K(() => x(r) / 3 - 10), s = 300;
  var a = cQ();
  It(a, 20, () => x(i), (l) => l, (l, u) => {
    var c = uQ();
    let h;
    var d = Y(c), p = Y(d, !0);
    J(d);
    var g = le(d, 2);
    Jl(g, () => e.chartView, () => ({ id: u, width: x(o), height: s })), J(c), Ee(() => {
      h = ct(c, "", h, { width: `${x(o) ?? ""}px` }), at(p, e.charts[u].title);
    }), Q(l, c);
  }), J(a), Xs(a, "clientWidth", (l) => ae(r, l)), Xs(a, "clientHeight", (l) => ae(n, l)), Q(t, a), it();
}
function RT(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function CD(t, { from: e, to: r }, n = {}) {
  var { delay: i = 0, duration: o = (D) => Math.sqrt(D) * 120, easing: s = RT } = n, a = getComputedStyle(t), l = a.transform === "none" ? "" : a.transform, [u, c] = a.transformOrigin.split(" ").map(parseFloat);
  u /= t.clientWidth, c /= t.clientHeight;
  var h = fQ(t), d = t.clientWidth / r.width / h, p = t.clientHeight / r.height / h, g = e.left + e.width * u, v = e.top + e.height * c, y = r.left + r.width * u, b = r.top + r.height * c, k = (g - y) * d, C = (v - b) * p, S = e.width / r.width, _ = e.height / r.height;
  return {
    delay: i,
    duration: typeof o == "function" ? o(Math.sqrt(k * k + C * C)) : o,
    easing: s,
    css: (D, A) => {
      var O = A * k, M = A * C, z = D + A * S, N = D + A * _;
      return `transform: ${l} translate(${O}px, ${M}px) scale(${z}, ${N});`;
    }
  };
}
function fQ(t) {
  if ("currentCSSZoom" in t)
    return (
      /** @type {number} */
      t.currentCSSZoom
    );
  for (var e = t, r = 1; e !== null; )
    r *= +getComputedStyle(e).zoom, e = /** @type {Element | null} */
    e.parentElement;
  return r;
}
function dQ(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function dm(t, { delay: e = 0, duration: r = 400, easing: n = dQ, axis: i = "y" } = {}) {
  const o = getComputedStyle(t), s = +o.opacity, a = i === "y" ? "height" : "width", l = parseFloat(o[a]), u = i === "y" ? ["top", "bottom"] : ["left", "right"], c = u.map(
    (b) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${b[0].toUpperCase()}${b.slice(1)}`
    )
  ), h = parseFloat(o[`padding${c[0]}`]), d = parseFloat(o[`padding${c[1]}`]), p = parseFloat(o[`margin${c[0]}`]), g = parseFloat(o[`margin${c[1]}`]), v = parseFloat(
    o[`border${c[0]}Width`]
  ), y = parseFloat(
    o[`border${c[1]}Width`]
  );
  return {
    delay: e,
    duration: r,
    easing: n,
    css: (b) => `overflow: hidden;opacity: ${Math.min(b * 20, 1) * s};${a}: ${b * l}px;padding-${u[0]}: ${b * h}px;padding-${u[1]}: ${b * d}px;margin-${u[0]}: ${b * p}px;margin-${u[1]}: ${b * g}px;border-${u[0]}-width: ${b * v}px;border-${u[1]}-width: ${b * y}px;min-${a}: 0`
  };
}
var pQ = /* @__PURE__ */ me("<div></div>");
function _D(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  function n(o, s) {
    o.preventDefault();
    let a = o.pageX, l = o.pageY, u = (h) => {
      h.preventDefault();
      let d = h.pageX - a, p = h.pageY - l;
      s(d, p);
    }, c = () => {
      window.removeEventListener("mousemove", u), window.removeEventListener("mouseup", c);
    };
    window.addEventListener("mousemove", u), window.addEventListener("mouseup", c);
  }
  var i = pQ();
  i.__mousedown = (o) => {
    let s = e.value;
    n(o, (a, l) => {
      let u = s + (e.axis == "x" ? a : l) * e.scaler;
      u < e.min && (u = r.min), u > e.max && (u = r.max), e.onChange(u);
    });
  }, Ee(() => en(i, 1, `${e.class ?? ""} ${e.axis == "x" ? "cursor-col-resize" : "cursor-row-resize"}`)), Q(t, i), it();
}
nn(["mousedown"]);
function SD(t, e = "") {
  let r = 1, n;
  do
    n = e + r, r++;
  while (n in t);
  return n;
}
let g3 = [], NT = [];
(() => {
  let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, r = 0; e < t.length; e++)
    (e % 2 ? NT : g3).push(r = r + t[e]);
})();
function mQ(t) {
  if (t < 768) return !1;
  for (let e = 0, r = g3.length; ; ) {
    let n = e + r >> 1;
    if (t < g3[n]) r = n;
    else if (t >= NT[n]) e = n + 1;
    else return !0;
    if (e == r) return !1;
  }
}
function AD(t) {
  return t >= 127462 && t <= 127487;
}
const ED = 8205;
function gQ(t, e, r = !0, n = !0) {
  return (r ? $T : vQ)(t, e, n);
}
function $T(t, e, r) {
  if (e == t.length) return e;
  e && IT(t.charCodeAt(e)) && BT(t.charCodeAt(e - 1)) && e--;
  let n = g2(t, e);
  for (e += DD(n); e < t.length; ) {
    let i = g2(t, e);
    if (n == ED || i == ED || r && mQ(i))
      e += DD(i), n = i;
    else if (AD(i)) {
      let o = 0, s = e - 2;
      for (; s >= 0 && AD(g2(t, s)); )
        o++, s -= 2;
      if (o % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function vQ(t, e, r) {
  for (; e > 0; ) {
    let n = $T(t, e - 2, r);
    if (n < e) return n;
    e--;
  }
  return 0;
}
function g2(t, e) {
  let r = t.charCodeAt(e);
  if (!BT(r) || e + 1 == t.length) return r;
  let n = t.charCodeAt(e + 1);
  return IT(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function IT(t) {
  return t >= 56320 && t < 57344;
}
function BT(t) {
  return t >= 55296 && t < 56320;
}
function DD(t) {
  return t < 65536 ? 1 : 2;
}
let or = class LT {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, n) {
    [e, r] = xd(this, e, r);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      i,
      1
      /* Open.From */
    ), Aa.from(i, this.length - (r - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = xd(this, e, r);
    let n = [];
    return this.decompose(e, r, n, 0), Aa.from(n, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), i = new Em(this), o = new Em(e);
    for (let s = r, a = r; ; ) {
      if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
        return !1;
      if (a += i.value.length, i.done || a >= n)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Em(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new zT(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      n = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new jT(n);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? LT.empty : e.length <= 32 ? new dn(e) : Aa.from(dn.split(e, []));
  }
};
class dn extends or {
  constructor(e, r = yQ(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, n, i) {
    for (let o = 0; ; o++) {
      let s = this.text[o], a = i + s.length;
      if ((r ? n : a) >= e)
        return new bQ(i, a, n, s);
      i = a + 1, n++;
    }
  }
  decompose(e, r, n, i) {
    let o = e <= 0 && r >= this.length ? this : new dn(OD(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let s = n.pop(), a = Oy(o.text, s.text.slice(), 0, o.length);
      if (a.length <= 32)
        n.push(new dn(a, s.length + o.length));
      else {
        let l = a.length >> 1;
        n.push(new dn(a.slice(0, l)), new dn(a.slice(l)));
      }
    } else
      n.push(o);
  }
  replace(e, r, n) {
    if (!(n instanceof dn))
      return super.replace(e, r, n);
    [e, r] = xd(this, e, r);
    let i = Oy(this.text, Oy(n.text, OD(this.text, 0, e)), r), o = this.length + n.length - (r - e);
    return i.length <= 32 ? new dn(i, o) : Aa.from(dn.split(i, []), o);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = xd(this, e, r);
    let i = "";
    for (let o = 0, s = 0; o <= r && s < this.text.length; s++) {
      let a = this.text[s], l = o + a.length;
      o > e && s && (i += n), e < l && r > o && (i += a.slice(Math.max(0, e - o), r - o)), o = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let n = [], i = -1;
    for (let o of e)
      n.push(o), i += o.length + 1, n.length == 32 && (r.push(new dn(n, i)), n = [], i = -1);
    return i > -1 && r.push(new dn(n, i)), r;
  }
}
class Aa extends or {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, r, n, i) {
    for (let o = 0; ; o++) {
      let s = this.children[o], a = i + s.length, l = n + s.lines - 1;
      if ((r ? l : a) >= e)
        return s.lineInner(e, r, n, i);
      i = a + 1, n = l + 1;
    }
  }
  decompose(e, r, n, i) {
    for (let o = 0, s = 0; s <= r && o < this.children.length; o++) {
      let a = this.children[o], l = s + a.length;
      if (e <= l && r >= s) {
        let u = i & ((s <= e ? 1 : 0) | (l >= r ? 2 : 0));
        s >= e && l <= r && !u ? n.push(a) : a.decompose(e - s, r - s, n, u);
      }
      s = l + 1;
    }
  }
  replace(e, r, n) {
    if ([e, r] = xd(this, e, r), n.lines < this.lines)
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let s = this.children[i], a = o + s.length;
        if (e >= o && r <= a) {
          let l = s.replace(e - o, r - o, n), u = this.lines - s.lines + l.lines;
          if (l.lines < u >> 4 && l.lines > u >> 6) {
            let c = this.children.slice();
            return c[i] = l, new Aa(c, this.length - (r - e) + n.length);
          }
          return super.replace(o, a, l);
        }
        o = a + 1;
      }
    return super.replace(e, r, n);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = xd(this, e, r);
    let i = "";
    for (let o = 0, s = 0; o < this.children.length && s <= r; o++) {
      let a = this.children[o], l = s + a.length;
      s > e && o && (i += n), e < l && r > s && (i += a.sliceString(e - s, r - s, n)), s = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof Aa))
      return 0;
    let n = 0, [i, o, s, a] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, o += r) {
      if (i == s || o == a)
        return n;
      let l = this.children[i], u = e.children[o];
      if (l != u)
        return n + l.scanIdentical(u, r);
      n += l.length + 1;
    }
  }
  static from(e, r = e.reduce((n, i) => n + i.length + 1, -1)) {
    let n = 0;
    for (let p of e)
      n += p.lines;
    if (n < 32) {
      let p = [];
      for (let g of e)
        g.flatten(p);
      return new dn(p, r);
    }
    let i = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), o = i << 1, s = i >> 1, a = [], l = 0, u = -1, c = [];
    function h(p) {
      let g;
      if (p.lines > o && p instanceof Aa)
        for (let v of p.children)
          h(v);
      else p.lines > s && (l > s || !l) ? (d(), a.push(p)) : p instanceof dn && l && (g = c[c.length - 1]) instanceof dn && p.lines + g.lines <= 32 ? (l += p.lines, u += p.length + 1, c[c.length - 1] = new dn(g.text.concat(p.text), g.length + 1 + p.length)) : (l + p.lines > i && d(), l += p.lines, u += p.length + 1, c.push(p));
    }
    function d() {
      l != 0 && (a.push(c.length == 1 ? c[0] : Aa.from(c, u)), u = -1, l = c.length = 0);
    }
    for (let p of e)
      h(p);
    return d(), a.length == 1 ? a[0] : new Aa(a, r);
  }
}
or.empty = /* @__PURE__ */ new dn([""], 0);
function yQ(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function Oy(t, e, r = 0, n = 1e9) {
  for (let i = 0, o = 0, s = !0; o < t.length && i <= n; o++) {
    let a = t[o], l = i + a.length;
    l >= r && (l > n && (a = a.slice(0, n - i)), i < r && (a = a.slice(r - i)), s ? (e[e.length - 1] += a, s = !1) : e.push(a)), i = l + 1;
  }
  return e;
}
function OD(t, e, r) {
  return Oy(t, [""], e, r);
}
class Em {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof dn ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1, i = this.nodes[n], o = this.offsets[n], s = o >> 1, a = i instanceof dn ? i.text.length : i.children.length;
      if (s == (r > 0 ? a : 0)) {
        if (n == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[n] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof dn) {
        let l = i.text[s + (r < 0 ? -1 : 0)];
        if (this.offsets[n] += r, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : r > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = i.children[s + (r < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[n] += r) : (r < 0 && this.offsets[n]--, this.nodes.push(l), this.offsets.push(r > 0 ? 1 : (l instanceof dn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class zT {
  constructor(e, r, n) {
    this.value = "", this.done = !1, this.cursor = new Em(e, r > n ? -1 : 1), this.pos = r > n ? e.length : 0, this.from = Math.min(r, n), this.to = Math.max(r, n);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let n = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * r, this.value = i.length <= n ? i : r < 0 ? i.slice(i.length - n) : i.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class jT {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: n, value: i } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (or.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Em.prototype[Symbol.iterator] = zT.prototype[Symbol.iterator] = jT.prototype[Symbol.iterator] = function() {
  return this;
});
class bQ {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.number = n, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function xd(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
function Xn(t, e, r = !0, n = !0) {
  return gQ(t, e, r, n);
}
function xQ(t) {
  return t >= 56320 && t < 57344;
}
function wQ(t) {
  return t >= 55296 && t < 56320;
}
function Yi(t, e) {
  let r = t.charCodeAt(e);
  if (!wQ(r) || e + 1 == t.length)
    return r;
  let n = t.charCodeAt(e + 1);
  return xQ(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function J_(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Ea(t) {
  return t < 65536 ? 1 : 2;
}
const v3 = /\r\n?|\n/;
var Kn = /* @__PURE__ */ (function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
})(Kn || (Kn = {}));
class Ua {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r + 1];
      e += n < 0 ? this.sections[r] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, n = 0, i = 0; r < this.sections.length; ) {
      let o = this.sections[r++], s = this.sections[r++];
      s < 0 ? (e(n, i, o), i += o) : i += s, n += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    y3(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      i < 0 ? e.push(n, i) : e.push(i, n);
    }
    return new Ua(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : qT(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : b3(this, e, r);
  }
  mapPos(e, r = -1, n = Kn.Simple) {
    let i = 0, o = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], l = this.sections[s++], u = i + a;
      if (l < 0) {
        if (u > e)
          return o + (e - i);
        o += a;
      } else {
        if (n != Kn.Simple && u >= e && (n == Kn.TrackDel && i < e && u > e || n == Kn.TrackBefore && i < e || n == Kn.TrackAfter && u > e))
          return null;
        if (u > e || u == e && r < 0 && !a)
          return e == i || r < 0 ? o : o + l;
        o += l;
      }
      i = u;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let n = 0, i = 0; n < this.sections.length && i <= r; ) {
      let o = this.sections[n++], s = this.sections[n++], a = i + o;
      if (s >= 0 && i <= r && a >= e)
        return i < e && a > r ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      e += (e ? " " : "") + n + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Ua(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Ua(e);
  }
}
class Dn extends Ua {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return y3(this, (r, n, i, o, s) => e = e.replace(i, i + (n - r), s), !1), e;
  }
  mapDesc(e, r = !1) {
    return b3(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), n = [];
    for (let i = 0, o = 0; i < r.length; i += 2) {
      let s = r[i], a = r[i + 1];
      if (a >= 0) {
        r[i] = a, r[i + 1] = s;
        let l = i >> 1;
        for (; n.length < l; )
          n.push(or.empty);
        n.push(s ? e.slice(o, o + s) : or.empty);
      }
      o += s;
    }
    return new Dn(r, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the
  returned value will represent the change `docA` â†’ `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : qT(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : b3(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    y3(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Ua.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], n = [], i = [], o = new Xm(this);
    e: for (let s = 0, a = 0; ; ) {
      let l = s == e.length ? 1e9 : e[s++];
      for (; a < l || a == l && o.len == 0; ) {
        if (o.done)
          break e;
        let c = Math.min(o.len, l - a);
        ri(i, c, -1);
        let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
        ri(r, c, h), h > 0 && Pu(n, r, o.text), o.forward(c), a += c;
      }
      let u = e[s++];
      for (; a < u; ) {
        if (o.done)
          break e;
        let c = Math.min(o.len, u - a);
        ri(r, c, -1), ri(i, c, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(c), a += c;
      }
    }
    return {
      changes: new Dn(r, n),
      filtered: Ua.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r], i = this.sections[r + 1];
      i < 0 ? e.push(n) : i == 0 ? e.push([n]) : e.push([n].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, n) {
    let i = [], o = [], s = 0, a = null;
    function l(c = !1) {
      if (!c && !i.length)
        return;
      s < r && ri(i, r - s, -1);
      let h = new Dn(i, o);
      a = a ? a.compose(h.map(a)) : h, i = [], o = [], s = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let h of c)
          u(h);
      else if (c instanceof Dn) {
        if (c.length != r)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${r})`);
        l(), a = a ? a.compose(c.map(a)) : c;
      } else {
        let { from: h, to: d = h, insert: p } = c;
        if (h > d || h < 0 || d > r)
          throw new RangeError(`Invalid change range ${h} to ${d} (in doc of length ${r})`);
        let g = p ? typeof p == "string" ? or.of(p.split(n || v3)) : p : or.empty, v = g.length;
        if (h == d && v == 0)
          return;
        h < s && l(), h > s && ri(i, h - s, -1), ri(i, d - h, v), Pu(o, i, g), s = d;
      }
    }
    return u(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Dn(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], n = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (typeof o == "number")
        r.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          r.push(o[0], 0);
        else {
          for (; n.length < i; )
            n.push(or.empty);
          n[i] = or.of(o.slice(1)), r.push(o[0], n[i].length);
        }
      }
    }
    return new Dn(r, n);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new Dn(e, r);
  }
}
function ri(t, e, r, n = !1) {
  if (e == 0 && r <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += r : n ? (t[i] += e, t[i + 1] += r) : t.push(e, r);
}
function Pu(t, e, r) {
  if (r.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < n; )
      t.push(or.empty);
    t.push(r);
  }
}
function y3(t, e, r) {
  let n = t.inserted;
  for (let i = 0, o = 0, s = 0; s < t.sections.length; ) {
    let a = t.sections[s++], l = t.sections[s++];
    if (l < 0)
      i += a, o += a;
    else {
      let u = i, c = o, h = or.empty;
      for (; u += a, c += l, l && n && (h = h.append(n[s - 2 >> 1])), !(r || s == t.sections.length || t.sections[s + 1] < 0); )
        a = t.sections[s++], l = t.sections[s++];
      e(i, u, o, c, h), i = u, o = c;
    }
  }
}
function b3(t, e, r, n = !1) {
  let i = [], o = n ? [] : null, s = new Xm(t), a = new Xm(e);
  for (let l = -1; ; ) {
    if (s.done && a.len || a.done && s.len)
      throw new Error("Mismatched change set lengths");
    if (s.ins == -1 && a.ins == -1) {
      let u = Math.min(s.len, a.len);
      ri(i, u, -1), s.forward(u), a.forward(u);
    } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !r))) {
      let u = a.len;
      for (ri(i, a.ins, -1); u; ) {
        let c = Math.min(s.len, u);
        s.ins >= 0 && l < s.i && s.len <= c && (ri(i, 0, s.ins), o && Pu(o, i, s.text), l = s.i), s.forward(c), u -= c;
      }
      a.next();
    } else if (s.ins >= 0) {
      let u = 0, c = s.len;
      for (; c; )
        if (a.ins == -1) {
          let h = Math.min(c, a.len);
          u += h, c -= h, a.forward(h);
        } else if (a.ins == 0 && a.len < c)
          c -= a.len, a.next();
        else
          break;
      ri(i, u, l < s.i ? s.ins : 0), o && l < s.i && Pu(o, i, s.text), l = s.i, s.forward(s.len - c);
    } else {
      if (s.done && a.done)
        return o ? Dn.createSet(i, o) : Ua.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function qT(t, e, r = !1) {
  let n = [], i = r ? [] : null, o = new Xm(t), s = new Xm(e);
  for (let a = !1; ; ) {
    if (o.done && s.done)
      return i ? Dn.createSet(n, i) : Ua.create(n);
    if (o.ins == 0)
      ri(n, o.len, 0, a), o.next();
    else if (s.len == 0 && !s.done)
      ri(n, 0, s.ins, a), i && Pu(i, n, s.text), s.next();
    else {
      if (o.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(o.len2, s.len), u = n.length;
        if (o.ins == -1) {
          let c = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          ri(n, l, c, a), i && c && Pu(i, n, s.text);
        } else s.ins == -1 ? (ri(n, o.off ? 0 : o.len, l, a), i && Pu(i, n, o.textBit(l))) : (ri(n, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && Pu(i, n, s.text));
        a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || n.length > u), o.forward2(l), s.forward(l);
      }
    }
  }
}
class Xm {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? or.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, n = this.i - 2 >> 1;
    return n >= r.length && !e ? or.empty : r[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class Uc {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.flags = n;
  }
  /**
  The anchor of the rangeâ€”the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let n, i;
    return this.empty ? n = i = e.mapPos(this.from, r) : (n = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), n == this.from && i == this.to ? this : new Uc(n, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return de.range(e, r);
    let n = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return de.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return de.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new Uc(e, r, n);
  }
}
class de {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : de.create(this.ranges.map((n) => n.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new de([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return de.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let n = this.ranges.slice();
    return n[r] = e, de.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new de(e.ranges.map((r) => Uc.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new de([de.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, i = 0; i < e.length; i++) {
      let o = e[i];
      if (o.empty ? o.from <= n : o.from < n)
        return de.normalized(e.slice(), r);
      n = o.to;
    }
    return new de(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, n, i) {
    return Uc.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, n, i) {
    let o = (n ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return r < e ? Uc.create(r, e, 48 | o) : Uc.create(e, r, (r > e ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let n = e[r];
    e.sort((i, o) => i.from - o.from), r = e.indexOf(n);
    for (let i = 1; i < e.length; i++) {
      let o = e[i], s = e[i - 1];
      if (o.empty ? o.from <= s.to : o.from < s.to) {
        let a = s.from, l = Math.max(o.to, s.to);
        i <= r && r--, e.splice(--i, 2, o.anchor > o.head ? de.range(l, a) : de.range(a, l));
      }
    }
    return new de(e, r);
  }
}
function UT(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let Y_ = 0;
class Be {
  constructor(e, r, n, i, o) {
    this.combine = e, this.compareInput = r, this.compare = n, this.isStatic = i, this.id = Y_++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Be(e.combine || ((r) => r), e.compareInput || ((r, n) => r === n), e.compare || (e.combine ? (r, n) => r === n : Z_), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Fy([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Fy(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Fy(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (n) => n), this.compute([e], (n) => r(n.field(e)));
  }
}
function Z_(t, e) {
  return t == e || t.length == e.length && t.every((r, n) => r === e[n]);
}
class Fy {
  constructor(e, r, n, i) {
    this.dependencies = e, this.facet = r, this.type = n, this.value = i, this.id = Y_++;
  }
  dynamicSlot(e) {
    var r;
    let n = this.value, i = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, l = !1, u = !1, c = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? u = !0 : (((r = e[h.id]) !== null && r !== void 0 ? r : 1) & 1) == 0 && c.push(e[h.id]);
    return {
      create(h) {
        return h.values[s] = n(h), 1;
      },
      update(h, d) {
        if (l && d.docChanged || u && (d.docChanged || d.selection) || x3(h, c)) {
          let p = n(h);
          if (a ? !FD(p, h.values[s], i) : !i(p, h.values[s]))
            return h.values[s] = p, 1;
        }
        return 0;
      },
      reconfigure: (h, d) => {
        let p, g = d.config.address[o];
        if (g != null) {
          let v = u1(d, g);
          if (this.dependencies.every((y) => y instanceof Be ? d.facet(y) === h.facet(y) : y instanceof qn ? d.field(y, !1) == h.field(y, !1) : !0) || (a ? FD(p = n(h), v, i) : i(p = n(h), v)))
            return h.values[s] = v, 0;
        } else
          p = n(h);
        return h.values[s] = p, 1;
      }
    };
  }
}
function FD(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!r(t[n], e[n]))
      return !1;
  return !0;
}
function x3(t, e) {
  let r = !1;
  for (let n of e)
    Dm(t, n) & 1 && (r = !0);
  return r;
}
function kQ(t, e, r) {
  let n = r.map((l) => t[l.id]), i = r.map((l) => l.type), o = n.filter((l) => !(l & 1)), s = t[e.id] >> 1;
  function a(l) {
    let u = [];
    for (let c = 0; c < n.length; c++) {
      let h = u1(l, n[c]);
      if (i[c] == 2)
        for (let d of h)
          u.push(d);
      else
        u.push(h);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of n)
        Dm(l, u);
      return l.values[s] = a(l), 1;
    },
    update(l, u) {
      if (!x3(l, o))
        return 0;
      let c = a(l);
      return e.compare(c, l.values[s]) ? 0 : (l.values[s] = c, 1);
    },
    reconfigure(l, u) {
      let c = x3(l, n), h = u.config.facets[e.id], d = u.facet(e);
      if (h && !c && Z_(r, h))
        return l.values[s] = d, 0;
      let p = a(l);
      return e.compare(p, d) ? (l.values[s] = d, 0) : (l.values[s] = p, 1);
    }
  };
}
const _v = /* @__PURE__ */ Be.define({ static: !0 });
class qn {
  constructor(e, r, n, i, o) {
    this.id = e, this.createF = r, this.updateF = n, this.compareF = i, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new qn(Y_++, e.create, e.update, e.compare || ((n, i) => n === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    return (e.facet(_v).find((n) => n.field == this)?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (n) => (n.values[r] = this.create(n), 1),
      update: (n, i) => {
        let o = n.values[r], s = this.updateF(o, i);
        return this.compareF(o, s) ? 0 : (n.values[r] = s, 1);
      },
      reconfigure: (n, i) => {
        let o = n.facet(_v), s = i.facet(_v), a;
        return (a = o.find((l) => l.field == this)) && a != s.find((l) => l.field == this) ? (n.values[r] = a.create(n), 1) : i.config.address[this.id] != null ? (n.values[r] = i.field(this), 0) : (n.values[r] = this.create(n), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, _v.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Lc = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Gp(t) {
  return (e) => new HT(e, t);
}
const mc = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Gp(Lc.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Gp(Lc.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Gp(Lc.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Gp(Lc.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Gp(Lc.lowest)
};
class HT {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class Rb {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new w3(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Rb.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class w3 {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class l1 {
  constructor(e, r, n, i, o, s) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = n, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, n) {
    let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let d of CQ(e, r, s))
      d instanceof qn ? i.push(d) : (o[d.facet.id] || (o[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let d of i)
      a[d.id] = u.length << 1, u.push((p) => d.slot(p));
    let c = n?.config.facets;
    for (let d in o) {
      let p = o[d], g = p[0].facet, v = c && c[d] || [];
      if (p.every(
        (y) => y.type == 0
        /* Provider.Static */
      ))
        if (a[g.id] = l.length << 1 | 1, Z_(v, p))
          l.push(n.facet(g));
        else {
          let y = g.combine(p.map((b) => b.value));
          l.push(n && g.compare(y, n.facet(g)) ? n.facet(g) : y);
        }
      else {
        for (let y of p)
          y.type == 0 ? (a[y.id] = l.length << 1 | 1, l.push(y.value)) : (a[y.id] = u.length << 1, u.push((b) => y.dynamicSlot(b)));
        a[g.id] = u.length << 1, u.push((y) => kQ(y, g, p));
      }
    }
    let h = u.map((d) => d(a));
    return new l1(e, s, h, a, l, o);
  }
}
function CQ(t, e, r) {
  let n = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function o(s, a) {
    let l = i.get(s);
    if (l != null) {
      if (l <= a)
        return;
      let u = n[l].indexOf(s);
      u > -1 && n[l].splice(u, 1), s instanceof w3 && r.delete(s.compartment);
    }
    if (i.set(s, a), Array.isArray(s))
      for (let u of s)
        o(u, a);
    else if (s instanceof w3) {
      if (r.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(s.compartment) || s.inner;
      r.set(s.compartment, u), o(u, a);
    } else if (s instanceof HT)
      o(s.inner, s.prec);
    else if (s instanceof qn)
      n[a].push(s), s.provides && o(s.provides, a);
    else if (s instanceof Fy)
      n[a].push(s), s.facet.extensions && o(s.facet.extensions, Lc.default);
    else {
      let u = s.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(u, a);
    }
  }
  return o(t, Lc.default), n.reduce((s, a) => s.concat(a));
}
function Dm(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, n = t.status[r];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | i;
}
function u1(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const VT = /* @__PURE__ */ Be.define(), k3 = /* @__PURE__ */ Be.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), WT = /* @__PURE__ */ Be.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), GT = /* @__PURE__ */ Be.define(), KT = /* @__PURE__ */ Be.define(), XT = /* @__PURE__ */ Be.define(), QT = /* @__PURE__ */ Be.define({
  combine: (t) => t.length ? t[0] : !1
});
class iu {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new _Q();
  }
}
class _Q {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new iu(this, e);
  }
}
class SQ {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new kt(this, e);
  }
}
class kt {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new kt(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new SQ(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let n = [];
    for (let i of e) {
      let o = i.map(r);
      o && n.push(o);
    }
    return n;
  }
}
kt.reconfigure = /* @__PURE__ */ kt.define();
kt.appendConfig = /* @__PURE__ */ kt.define();
class xn {
  constructor(e, r, n, i, o, s) {
    this.startState = e, this.changes = r, this.selection = n, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, n && UT(n, r.newLength), o.some((a) => a.type == xn.time) || (this.annotations = o.concat(xn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, n, i, o, s) {
    return new xn(e, r, n, i, o, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(xn.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
xn.time = /* @__PURE__ */ iu.define();
xn.userEvent = /* @__PURE__ */ iu.define();
xn.addToHistory = /* @__PURE__ */ iu.define();
xn.remote = /* @__PURE__ */ iu.define();
function AQ(t, e) {
  let r = [];
  for (let n = 0, i = 0; ; ) {
    let o, s;
    if (n < t.length && (i == e.length || e[i] >= t[n]))
      o = t[n++], s = t[n++];
    else if (i < e.length)
      o = e[i++], s = e[i++];
    else
      return r;
    !r.length || r[r.length - 1] < o ? r.push(o, s) : r[r.length - 1] < s && (r[r.length - 1] = s);
  }
}
function JT(t, e, r) {
  var n;
  let i, o, s;
  return r ? (i = e.changes, o = Dn.empty(e.changes.length), s = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, !0), s = t.changes.compose(i)), {
    changes: s,
    selection: e.selection ? e.selection.map(o) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(i),
    effects: kt.mapEffects(t.effects, i).concat(kt.mapEffects(e.effects, o)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function C3(t, e, r) {
  let n = e.selection, i = Hf(e.annotations);
  return e.userEvent && (i = i.concat(xn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Dn ? e.changes : Dn.of(e.changes || [], r, t.facet(WT)),
    selection: n && (n instanceof de ? n : de.single(n.anchor, n.head)),
    effects: Hf(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function YT(t, e, r) {
  let n = C3(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (r = !1);
    let s = !!e[o].sequential;
    n = JT(n, C3(t, e[o], s ? n.changes.newLength : t.doc.length), s);
  }
  let i = xn.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return DQ(r ? EQ(i) : i);
}
function EQ(t) {
  let e = t.startState, r = !0;
  for (let i of e.facet(GT)) {
    let o = i(t);
    if (o === !1) {
      r = !1;
      break;
    }
    Array.isArray(o) && (r = r === !0 ? o : AQ(r, o));
  }
  if (r !== !0) {
    let i, o;
    if (r === !1)
      o = t.changes.invertedDesc, i = Dn.empty(e.doc.length);
    else {
      let s = t.changes.filter(r);
      i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    t = xn.create(e, i, t.selection && t.selection.map(o), kt.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
  }
  let n = e.facet(KT);
  for (let i = n.length - 1; i >= 0; i--) {
    let o = n[i](t);
    o instanceof xn ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof xn ? t = o[0] : t = YT(e, Hf(o), !1);
  }
  return t;
}
function DQ(t) {
  let e = t.startState, r = e.facet(XT), n = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let o = r[i](t);
    o && Object.keys(o).length && (n = JT(n, C3(e, o, t.changes.newLength), !0));
  }
  return n == t ? t : xn.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
const OQ = [];
function Hf(t) {
  return t == null ? OQ : Array.isArray(t) ? t : [t];
}
var Wr = /* @__PURE__ */ (function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
})(Wr || (Wr = {}));
const FQ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let _3;
try {
  _3 = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function TQ(t) {
  if (_3)
    return _3.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "Â€" && (r.toUpperCase() != r.toLowerCase() || FQ.test(r)))
      return !0;
  }
  return !1;
}
function MQ(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Wr.Space;
    if (TQ(e))
      return Wr.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return Wr.Word;
    return Wr.Other;
  };
}
class ir {
  constructor(e, r, n, i, o, s) {
    this.config = e, this.doc = r, this.selection = n, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Dm(this, a << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Dm(this, n), u1(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return YT(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: n, compartments: i } = r;
    for (let a of e.effects)
      a.is(Rb.reconfigure) ? (r && (i = /* @__PURE__ */ new Map(), r.compartments.forEach((l, u) => i.set(u, l)), r = null), i.set(a.value.compartment, a.value.extension)) : a.is(kt.reconfigure) ? (r = null, n = a.value) : a.is(kt.appendConfig) && (r = null, n = Hf(n).concat(a.value));
    let o;
    r ? o = e.startState.values.slice() : (r = l1.resolve(n, i, this), o = new ir(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (a, l) => l.reconfigure(a, this), null).values);
    let s = e.startState.facet(k3) ? e.newSelection : e.newSelection.asSingle();
    new ir(r, e.newDoc, s, o, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: de.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, n = e(r.ranges[0]), i = this.changes(n.changes), o = [n.range], s = Hf(n.effects);
    for (let a = 1; a < r.ranges.length; a++) {
      let l = e(r.ranges[a]), u = this.changes(l.changes), c = u.map(i);
      for (let d = 0; d < a; d++)
        o[d] = o[d].map(c);
      let h = i.mapDesc(u, !0);
      o.push(l.range.map(h)), i = i.compose(c), s = kt.mapEffects(s, c).concat(kt.mapEffects(Hf(l.effects), h));
    }
    return {
      changes: i,
      selection: de.create(o, r.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Dn ? e : Dn.of(e, this.doc.length, this.facet(ir.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return or.of(e.split(this.facet(ir.lineSeparator) || v3));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Dm(this, r), u1(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let i = e[n];
        i instanceof qn && this.config.address[i.id] != null && (r[n] = i.spec.toJSON(this.field(e[n]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (n) {
      for (let o in n)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let s = n[o], a = e[o];
          i.push(s.init((l) => s.spec.fromJSON(a, l)));
        }
    }
    return ir.create({
      doc: e.doc,
      selection: de.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorâ€”updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = l1.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof or ? e.doc : or.of((e.doc || "").split(r.staticFacet(ir.lineSeparator) || v3)), i = e.selection ? e.selection instanceof de ? e.selection : de.single(e.selection.anchor, e.selection.head) : de.single(0);
    return UT(i, n.length), r.staticFacet(k3) || (i = i.asSingle()), new ir(r, n, i, r.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ir.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ir.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(QT);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let n of this.facet(ir.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (n, i) => {
      if (i == "$")
        return "$";
      let o = +(i || 1);
      return !o || o > r.length ? n : r[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, n = -1) {
    let i = [];
    for (let o of this.facet(VT))
      for (let s of o(this, r, n))
        Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return MQ(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: n, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - n, a = e - n;
    for (; s > 0; ) {
      let l = Xn(r, s, !1);
      if (o(r.slice(l, s)) != Wr.Word)
        break;
      s = l;
    }
    for (; a < i; ) {
      let l = Xn(r, a);
      if (o(r.slice(a, l)) != Wr.Word)
        break;
      a = l;
    }
    return s == a ? null : de.range(s + n, a + n);
  }
}
ir.allowMultipleSelections = k3;
ir.tabSize = /* @__PURE__ */ Be.define({
  combine: (t) => t.length ? t[0] : 4
});
ir.lineSeparator = WT;
ir.readOnly = QT;
ir.phrases = /* @__PURE__ */ Be.define({
  compare(t, e) {
    let r = Object.keys(t), n = Object.keys(e);
    return r.length == n.length && r.every((i) => t[i] == e[i]);
  }
});
ir.languageData = VT;
ir.changeFilter = GT;
ir.transactionFilter = KT;
ir.transactionExtender = XT;
Rb.reconfigure = /* @__PURE__ */ kt.define();
function ou(t, e, r = {}) {
  let n = {};
  for (let i of t)
    for (let o of Object.keys(i)) {
      let s = i[o], a = n[o];
      if (a === void 0)
        n[o] = s;
      else if (!(a === s || s === void 0)) if (Object.hasOwnProperty.call(r, o))
        n[o] = r[o](a, s);
      else
        throw new Error("Config merge conflict for field " + o);
    }
  for (let i in e)
    n[i] === void 0 && (n[i] = e[i]);
  return n;
}
class xh {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return S3.create(e, r, this);
  }
}
xh.prototype.startSide = xh.prototype.endSide = 0;
xh.prototype.point = !1;
xh.prototype.mapMode = Kn.TrackDel;
let S3 = class ZT {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.value = n;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new ZT(e, r, n);
  }
};
function A3(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class e4 {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.value = n, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, n, i = 0) {
    let o = n ? this.to : this.from;
    for (let s = i, a = o.length; ; ) {
      if (s == a)
        return s;
      let l = s + a >> 1, u = o[l] - e || (n ? this.value[l].endSide : this.value[l].startSide) - r;
      if (l == s)
        return u >= 0 ? s : a;
      u >= 0 ? a = l : s = l + 1;
    }
  }
  between(e, r, n, i) {
    for (let o = this.findIndex(r, -1e9, !0), s = this.findIndex(n, 1e9, !1, o); o < s; o++)
      if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === !1)
        return !1;
  }
  map(e, r) {
    let n = [], i = [], o = [], s = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], c = this.from[l] + e, h = this.to[l] + e, d, p;
      if (c == h) {
        let g = r.mapPos(c, u.startSide, u.mapMode);
        if (g == null || (d = p = g, u.startSide != u.endSide && (p = r.mapPos(c, u.endSide), p < d)))
          continue;
      } else if (d = r.mapPos(c, u.startSide), p = r.mapPos(h, u.endSide), d > p || d == p && u.startSide > 0 && u.endSide <= 0)
        continue;
      (p - d || u.endSide - u.startSide) < 0 || (s < 0 && (s = d), u.point && (a = Math.max(a, p - d)), n.push(u), i.push(d - s), o.push(p - s));
    }
    return { mapped: n.length ? new e4(i, o, n, a) : null, pos: s };
  }
}
class fr {
  constructor(e, r, n, i) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = n, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, r, n, i) {
    return new fr(e, r, n, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: n = !1, filterFrom: i = 0, filterTo: o = this.length } = e, s = e.filter;
    if (r.length == 0 && !s)
      return this;
    if (n && (r = r.slice().sort(A3)), this.isEmpty)
      return r.length ? fr.of(r) : this;
    let a = new eM(this, null, -1).goto(0), l = 0, u = [], c = new nc();
    for (; a.value || l < r.length; )
      if (l < r.length && (a.from - r[l].from || a.startSide - r[l].value.startSide) >= 0) {
        let h = r[l++];
        c.addInner(h.from, h.to, h.value) || u.push(h);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == r.length || this.chunkEnd(a.chunkIndex) < r[l].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && c.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (c.addInner(a.from, a.to, a.value) || u.push(S3.create(a.from, a.to, a.value))), a.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? fr.empty : this.nextLayer.update({ add: u, filter: s, filterFrom: i, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], n = [], i = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], l = this.chunk[s], u = e.touchesRange(a, a + l.length);
      if (u === !1)
        i = Math.max(i, l.maxPoint), r.push(l), n.push(e.mapPos(a));
      else if (u === !0) {
        let { mapped: c, pos: h } = l.map(a, e);
        c && (i = Math.max(i, c.maxPoint), r.push(c), n.push(h));
      }
    }
    let o = this.nextLayer.map(e);
    return r.length == 0 ? o : new fr(n, r, o || fr.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, n) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i], s = this.chunk[i];
        if (r >= o && e <= o + s.length && s.between(o, e - o, r - o, n) === !1)
          return;
      }
      this.nextLayer.between(e, r, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Qm.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return Qm.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, n, i, o = -1) {
    let s = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), a = r.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), l = TD(s, a, n), u = new Kp(s, l, o), c = new Kp(a, l, o);
    n.iterGaps((h, d, p) => MD(u, h, c, d, p, i)), n.empty && n.length == 0 && MD(u, 0, c, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, n = 0, i) {
    i == null && (i = 999999999);
    let o = e.filter((c) => !c.isEmpty && r.indexOf(c) < 0), s = r.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (o.length != s.length)
      return !1;
    if (!o.length)
      return !0;
    let a = TD(o, s), l = new Kp(o, a, 0).goto(n), u = new Kp(s, a, 0).goto(n);
    for (; ; ) {
      if (l.to != u.to || !E3(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, n, i, o = -1) {
    let s = new Kp(e, null, o).goto(r), a = r, l = s.openStart;
    for (; ; ) {
      let u = Math.min(s.to, n);
      if (s.point) {
        let c = s.activeForPoint(s.to), h = s.pointFrom < r ? c.length + 1 : s.point.startSide < 0 ? c.length : Math.min(c.length, l);
        i.point(a, u, s.point, c, h, s.pointRank), l = Math.min(s.openEnd(u), c.length);
      } else u > a && (i.span(a, u, s.active, l), l = s.openEnd(u));
      if (s.to > n)
        return l + (s.point && s.to > n ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let n = new nc();
    for (let i of e instanceof S3 ? [e] : r ? PQ(e) : e)
      n.add(i.from, i.to, i.value);
    return n.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return fr.empty;
    let r = e[e.length - 1];
    for (let n = e.length - 2; n >= 0; n--)
      for (let i = e[n]; i != fr.empty; i = i.nextLayer)
        r = new fr(i.chunkPos, i.chunk, r, Math.max(i.maxPoint, r.maxPoint));
    return r;
  }
}
fr.empty = /* @__PURE__ */ new fr([], [], null, -1);
function PQ(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let n = t[r];
      if (A3(e, n) > 0)
        return t.slice().sort(A3);
      e = n;
    }
  return t;
}
fr.empty.nextLayer = fr.empty;
class nc {
  finishChunk(e) {
    this.chunks.push(new e4(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, n) {
    this.addInner(e, r, n) || (this.nextLayer || (this.nextLayer = new nc())).add(e, r, n);
  }
  /**
  @internal
  */
  addInner(e, r, n) {
    let i = e - this.lastTo || n.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = r, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let n = r.value.length - 1;
    return this.last = r.value[n], this.lastFrom = r.from[n] + e, this.lastTo = r.to[n] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(fr.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = fr.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function TD(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  for (let o of t)
    for (let s = 0; s < o.chunk.length; s++)
      o.chunk[s].maxPoint <= 0 && n.set(o.chunk[s], o.chunkPos[s]);
  let i = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let s = 0; s < o.chunk.length; s++) {
      let a = n.get(o.chunk[s]);
      a != null && (r ? r.mapPos(a) : a) == o.chunkPos[s] && !r?.touchesRange(a, a + o.chunk[s].length) && i.add(o.chunk[s]);
    }
  return i;
}
class eM {
  constructor(e, r, n, i = 0) {
    this.layer = e, this.skip = r, this.minPoint = n, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!n || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], n = e + r.from[this.rangeIndex];
        if (this.from = n, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Qm {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, n = -1) {
    let i = [];
    for (let o = 0; o < e.length; o++)
      for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= n && i.push(new eM(s, r, n, o));
    return i.length == 1 ? i[0] : new Qm(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let n of this.heap)
      n.goto(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      v2(this.heap, n);
    return this.next(), this;
  }
  forward(e, r) {
    for (let n of this.heap)
      n.forward(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      v2(this.heap, n);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), v2(this.heap, 0);
    }
  }
}
function v2(t, e) {
  for (let r = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length)
      break;
    let i = t[n];
    if (n + 1 < t.length && i.compare(t[n + 1]) >= 0 && (i = t[n + 1], n++), r.compare(i) < 0)
      break;
    t[n] = r, t[e] = i, e = n;
  }
}
class Kp {
  constructor(e, r, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Qm.from(e, r, n);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    Sv(this.active, e), Sv(this.activeTo, e), Sv(this.activeRank, e), this.minActive = PD(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: n, to: i, rank: o } = this.cursor;
    for (; r < this.activeRank.length && (o - this.activeRank[r] || i - this.activeTo[r]) > 0; )
      r++;
    Av(this.active, r, n), Av(this.activeTo, r, i), Av(this.activeRank, r, o), e && Av(e, r, this.cursor.from), this.minActive = PD(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), n && Sv(n, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(n), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let i = n.length - 1; i >= 0 && n[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && r.push(this.active[n]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      r++;
    return r;
  }
}
function MD(t, e, r, n, i, o) {
  t.goto(e), r.goto(n);
  let s = n + i, a = n, l = n - e;
  for (; ; ) {
    let u = t.to + l - r.to, c = u || t.endSide - r.endSide, h = c < 0 ? t.to + l : r.to, d = Math.min(h, s);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && E3(t.activeForPoint(t.to), r.activeForPoint(r.to)) || o.comparePoint(a, d, t.point, r.point) : d > a && !E3(t.active, r.active) && o.compareRange(a, d, t.active, r.active), h > s)
      break;
    (u || t.openEnd != r.openEnd) && o.boundChange && o.boundChange(h), a = h, c <= 0 && t.next(), c >= 0 && r.next();
  }
}
function E3(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function Sv(t, e) {
  for (let r = e, n = t.length - 1; r < n; r++)
    t[r] = t[r + 1];
  t.pop();
}
function Av(t, e, r) {
  for (let n = t.length - 1; n >= e; n--)
    t[n + 1] = t[n];
  t[e] = r;
}
function PD(t, e) {
  let r = -1, n = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - n || t[i].endSide - t[r].endSide) < 0 && (r = i, n = e[i]);
  return r;
}
function Jd(t, e, r = t.length) {
  let n = 0;
  for (let i = 0; i < r && i < t.length; )
    t.charCodeAt(i) == 9 ? (n += e - n % e, i++) : (n++, i = Xn(t, i));
  return n;
}
function D3(t, e, r, n) {
  for (let i = 0, o = 0; ; ) {
    if (o >= e)
      return i;
    if (i == t.length)
      break;
    o += t.charCodeAt(i) == 9 ? r - o % r : 1, i = Xn(t, i);
  }
  return n === !0 ? -1 : t.length;
}
const O3 = "Í¼", RD = typeof Symbol > "u" ? "__" + O3 : Symbol.for(O3), F3 = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), ND = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class ic {
  // :: (Object<Style>, ?{finish: ?(string) â†’ string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: n } = r || {};
    function i(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function o(s, a, l, u) {
      let c = [], h = /^@(\w+)\b/.exec(s[0]), d = h && h[1] == "keyframes";
      if (h && a == null) return l.push(s[0] + ";");
      for (let p in a) {
        let g = a[p];
        if (/&/.test(p))
          o(
            p.split(/,\s*/).map((v) => s.map((y) => v.replace(/&/, y))).reduce((v, y) => v.concat(y)),
            g,
            l
          );
        else if (g && typeof g == "object") {
          if (!h) throw new RangeError("The value of a property (" + p + ") should be a primitive value.");
          o(i(p), g, c, d);
        } else g != null && c.push(p.replace(/_.*/, "").replace(/[A-Z]/g, (v) => "-" + v.toLowerCase()) + ": " + g + ";");
      }
      (c.length || d) && l.push((n && !h && !u ? s.map(n) : s).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let s in e) o(i(s), e[s], this.rules);
  }
  // :: () â†’ string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () â†’ string
  // Generate a new unique CSS class name.
  static newName() {
    let e = ND[RD] || 1;
    return ND[RD] = e + 1, O3 + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, n) {
    let i = e[F3], o = n && n.nonce;
    i ? o && i.setNonce(o) : i = new RQ(e, o), i.mount(Array.isArray(r) ? r : [r], e);
  }
}
let $D = /* @__PURE__ */ new Map();
class RQ {
  constructor(e, r) {
    let n = e.ownerDocument || e, i = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = $D.get(n);
      if (o) return e[F3] = o;
      this.sheet = new i.CSSStyleSheet(), $D.set(n, this);
    } else
      this.styleTag = n.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
    this.modules = [], e[F3] = this;
  }
  mount(e, r) {
    let n = this.sheet, i = 0, o = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = this.modules.indexOf(a);
      if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
        if (this.modules.splice(o++, 0, a), n) for (let u = 0; u < a.rules.length; u++)
          n.insertRule(a.rules[u], i++);
      } else {
        for (; o < l; ) i += this.modules[o++].rules.length;
        i += a.rules.length, o++;
      }
    }
    if (n)
      r.adoptedStyleSheets.indexOf(this.sheet) < 0 && (r.adoptedStyleSheets = [this.sheet, ...r.adoptedStyleSheets]);
    else {
      let s = "";
      for (let l = 0; l < this.modules.length; l++)
        s += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = s;
      let a = r.head || r;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var oc = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Jm = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, NQ = typeof navigator < "u" && /Mac/.test(navigator.platform), $Q = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Gn = 0; Gn < 10; Gn++) oc[48 + Gn] = oc[96 + Gn] = String(Gn);
for (var Gn = 1; Gn <= 24; Gn++) oc[Gn + 111] = "F" + Gn;
for (var Gn = 65; Gn <= 90; Gn++)
  oc[Gn] = String.fromCharCode(Gn + 32), Jm[Gn] = String.fromCharCode(Gn);
for (var y2 in oc) Jm.hasOwnProperty(y2) || (Jm[y2] = oc[y2]);
function IQ(t) {
  var e = NQ && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || $Q && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? Jm : oc)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function Or() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var n in r) if (Object.prototype.hasOwnProperty.call(r, n)) {
      var i = r[n];
      typeof i == "string" ? t.setAttribute(n, i) : i != null && (t[n] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) tM(t, arguments[e]);
  return t;
}
function tM(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var r = 0; r < e.length; r++) tM(t, e[r]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
let Fi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, T3 = typeof document < "u" ? document : { documentElement: { style: {} } };
const M3 = /* @__PURE__ */ /Edge\/(\d+)/.exec(Fi.userAgent), rM = /* @__PURE__ */ /MSIE \d/.test(Fi.userAgent), P3 = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Fi.userAgent), Nb = !!(rM || P3 || M3), ID = !Nb && /* @__PURE__ */ /gecko\/(\d+)/i.test(Fi.userAgent), b2 = !Nb && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Fi.userAgent), BQ = "webkitFontSmoothing" in T3.documentElement.style, R3 = !Nb && /* @__PURE__ */ /Apple Computer/.test(Fi.vendor), BD = R3 && (/* @__PURE__ */ /Mobile\/\w+/.test(Fi.userAgent) || Fi.maxTouchPoints > 2);
var $e = {
  mac: BD || /* @__PURE__ */ /Mac/.test(Fi.platform),
  windows: /* @__PURE__ */ /Win/.test(Fi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Fi.platform),
  ie: Nb,
  ie_version: rM ? T3.documentMode || 6 : P3 ? +P3[1] : M3 ? +M3[1] : 0,
  gecko: ID,
  gecko_version: ID ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Fi.userAgent) || [0, 0])[1] : 0,
  chrome: !!b2,
  chrome_version: b2 ? +b2[1] : 0,
  ios: BD,
  android: /* @__PURE__ */ /Android\b/.test(Fi.userAgent),
  webkit_version: BQ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Fi.userAgent) || [0, 0])[1] : 0,
  safari: R3,
  safari_version: R3 ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(Fi.userAgent) || [0, 0])[1] : 0,
  tabSize: T3.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function Ym(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function N3(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Ty(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return N3(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Zm(t) {
  return t.nodeType == 3 ? kh(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Om(t, e, r, n) {
  return r ? LD(t, e, r, n, -1) || LD(t, e, r, n, 1) : !1;
}
function wh(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function c1(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function LD(t, e, r, n, i) {
  for (; ; ) {
    if (t == r && e == n)
      return !0;
    if (e == (i < 0 ? 0 : Ja(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let o = t.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      e = wh(t) + (i < 0 ? 0 : 1), t = o;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? Ja(t) : 0;
    } else
      return !1;
  }
}
function Ja(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function $b(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function LQ(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function nM(t, e) {
  let r = e.width / t.offsetWidth, n = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.height - t.offsetHeight) < 1) && (n = 1), { scaleX: r, scaleY: n };
}
function zQ(t, e, r, n, i, o, s, a) {
  let l = t.ownerDocument, u = l.defaultView || window;
  for (let c = t, h = !1; c && !h; )
    if (c.nodeType == 1) {
      let d, p = c == l.body, g = 1, v = 1;
      if (p)
        d = LQ(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (h = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let k = c.getBoundingClientRect();
        ({ scaleX: g, scaleY: v } = nM(c, k)), d = {
          left: k.left,
          right: k.left + c.clientWidth * g,
          top: k.top,
          bottom: k.top + c.clientHeight * v
        };
      }
      let y = 0, b = 0;
      if (i == "nearest")
        e.top < d.top ? (b = e.top - (d.top + s), r > 0 && e.bottom > d.bottom + b && (b = e.bottom - d.bottom + s)) : e.bottom > d.bottom && (b = e.bottom - d.bottom + s, r < 0 && e.top - b < d.top && (b = e.top - (d.top + s)));
      else {
        let k = e.bottom - e.top, C = d.bottom - d.top;
        b = (i == "center" && k <= C ? e.top + k / 2 - C / 2 : i == "start" || i == "center" && r < 0 ? e.top - s : e.bottom - C + s) - d.top;
      }
      if (n == "nearest" ? e.left < d.left ? (y = e.left - (d.left + o), r > 0 && e.right > d.right + y && (y = e.right - d.right + o)) : e.right > d.right && (y = e.right - d.right + o, r < 0 && e.left < d.left + y && (y = e.left - (d.left + o))) : y = (n == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : n == "start" == a ? e.left - o : e.right - (d.right - d.left) + o) - d.left, y || b)
        if (p)
          u.scrollBy(y, b);
        else {
          let k = 0, C = 0;
          if (b) {
            let S = c.scrollTop;
            c.scrollTop += b / v, C = (c.scrollTop - S) * v;
          }
          if (y) {
            let S = c.scrollLeft;
            c.scrollLeft += y / g, k = (c.scrollLeft - S) * g;
          }
          e = {
            left: e.left - k,
            top: e.top - C,
            right: e.right - k,
            bottom: e.bottom - C
          }, k && Math.abs(k - y) < 1 && (n = "nearest"), C && Math.abs(C - b) < 1 && (i = "nearest");
        }
      if (p)
        break;
      (e.top < d.top || e.bottom > d.bottom || e.left < d.left || e.right > d.right) && (e = {
        left: Math.max(e.left, d.left),
        right: Math.min(e.right, d.right),
        top: Math.max(e.top, d.top),
        bottom: Math.min(e.bottom, d.bottom)
      }), c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function jQ(t) {
  let e = t.ownerDocument, r, n;
  for (let i = t.parentNode; i && !(i == e.body || r && n); )
    if (i.nodeType == 1)
      !n && i.scrollHeight > i.clientHeight && (n = i), !r && i.scrollWidth > i.clientWidth && (r = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: r, y: n };
}
class qQ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: n } = e;
    this.set(r, Math.min(e.anchorOffset, r ? Ja(r) : 0), n, Math.min(e.focusOffset, n ? Ja(n) : 0));
  }
  set(e, r, n, i) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = n, this.focusOffset = i;
  }
}
let Nc = null;
$e.safari && $e.safari_version >= 26 && (Nc = !1);
function iM(t) {
  if (t.setActive)
    return t.setActive();
  if (Nc)
    return t.focus(Nc);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(Nc == null ? {
    get preventScroll() {
      return Nc = { preventScroll: !0 }, !0;
    }
  } : void 0), !Nc) {
    Nc = !1;
    for (let r = 0; r < e.length; ) {
      let n = e[r++], i = e[r++], o = e[r++];
      n.scrollTop != i && (n.scrollTop = i), n.scrollLeft != o && (n.scrollLeft = o);
    }
  }
}
let zD;
function kh(t, e, r = e) {
  let n = zD || (zD = document.createRange());
  return n.setEnd(t, r), n.setStart(t, e), n;
}
function Vf(t, e, r, n) {
  let i = { key: e, code: e, keyCode: r, which: r, cancelable: !0 };
  n && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = n);
  let o = new KeyboardEvent("keydown", i);
  o.synthetic = !0, t.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function UQ(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function oM(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function HQ(t, e) {
  let r = e.focusNode, n = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != n)
    return !1;
  for (n = Math.min(n, Ja(r)); ; )
    if (n) {
      if (r.nodeType != 1)
        return !1;
      let i = r.childNodes[n - 1];
      i.contentEditable == "false" ? n-- : (r = i, n = Ja(r));
    } else {
      if (r == t)
        return !0;
      n = wh(r), r = r.parentNode;
    }
}
function sM(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function aM(t, e) {
  for (let r = t, n = e; ; ) {
    if (r.nodeType == 3 && n > 0)
      return { node: r, offset: n };
    if (r.nodeType == 1 && n > 0) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[n - 1], n = Ja(r);
    } else if (r.parentNode && !c1(r))
      n = wh(r), r = r.parentNode;
    else
      return null;
  }
}
function lM(t, e) {
  for (let r = t, n = e; ; ) {
    if (r.nodeType == 3 && n < r.nodeValue.length)
      return { node: r, offset: n };
    if (r.nodeType == 1 && n < r.childNodes.length) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[n], n = 0;
    } else if (r.parentNode && !c1(r))
      n = wh(r) + 1, r = r.parentNode;
    else
      return null;
  }
}
class ii {
  constructor(e, r, n = !0) {
    this.node = e, this.offset = r, this.precise = n;
  }
  static before(e, r) {
    return new ii(e.parentNode, wh(e), r);
  }
  static after(e, r) {
    return new ii(e.parentNode, wh(e) + 1, r);
  }
}
const t4 = [];
class _r {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return r;
      r += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let n = this.dom, i = null, o;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (o = i ? i.nextSibling : n.firstChild)) {
            let a = _r.get(o);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
          }
          s.sync(e, r), s.flags &= -8;
        }
        if (o = i ? i.nextSibling : n.firstChild, r && !r.written && r.node == n && o != s.dom && (r.written = !0), s.dom.parentNode == n)
          for (; o && o != s.dom; )
            o = jD(o);
        else
          n.insertBefore(s.dom, o);
        i = s.dom;
      }
      for (o = i ? i.nextSibling : n.firstChild, o && r && r.node == n && (r.written = !0); o; )
        o = jD(o);
    } else if (this.flags & 1)
      for (let n of this.children)
        n.flags & 7 && (n.sync(e, r), n.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[r];
    else {
      let i = Ja(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
      }
      i < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !_r.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let i = 0, o = 0; ; i++) {
      let s = this.children[i];
      if (s.dom == n)
        return o;
      o += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, r, n = 0) {
    let i = -1, o = -1, s = -1, a = -1;
    for (let l = 0, u = n, c = n; l < this.children.length; l++) {
      let h = this.children[l], d = u + h.length;
      if (u < e && d > r)
        return h.domBoundsAround(e, r, u);
      if (d >= e && i == -1 && (i = l, o = u), u > r && h.dom.parentNode == this.dom) {
        s = l, a = c;
        break;
      }
      c = d, u = d + h.breakAfter;
    }
    return {
      from: o,
      to: a < 0 ? n + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, n = t4) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let o = this.children[i];
      o.parent == this && n.indexOf(o) < 0 && o.destroy();
    }
    n.length < 250 ? this.children.splice(e, r - e, ...n) : this.children = [].concat(this.children.slice(0, e), n, this.children.slice(r));
    for (let i = 0; i < n.length; i++)
      n[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new uM(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, n, i, o, s) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
_r.prototype.breakAfter = 0;
function jD(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class uM {
  constructor(e, r, n) {
    this.children = e, this.pos = r, this.i = n, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function cM(t, e, r, n, i, o, s, a, l) {
  let { children: u } = t, c = u.length ? u[e] : null, h = o.length ? o[o.length - 1] : null, d = h ? h.breakAfter : s;
  if (!(e == n && c && !s && !d && o.length < 2 && c.merge(r, i, o.length ? h : null, r == 0, a, l))) {
    if (n < u.length) {
      let p = u[n];
      p && (i < p.length || p.breakAfter && h?.breakAfter) ? (e == n && (p = p.split(i), i = 0), !d && h && p.merge(0, i, h, !0, 0, l) ? o[o.length - 1] = p : ((i || p.children.length && !p.children[0].length) && p.merge(0, i, null, !1, 0, l), o.push(p))) : p?.breakAfter && (h ? h.breakAfter = 1 : s = 1), n++;
    }
    for (c && (c.breakAfter = s, r > 0 && (!s && o.length && c.merge(r, c.length, o[0], !1, a, 0) ? c.breakAfter = o.shift().breakAfter : (r < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(r, c.length, null, !1, a, 0), e++)); e < n && o.length; )
      if (u[n - 1].become(o[o.length - 1]))
        n--, o.pop(), l = o.length ? 0 : a;
      else if (u[e].become(o[0]))
        e++, o.shift(), a = o.length ? 0 : l;
      else
        break;
    !o.length && e && n < u.length && !u[e - 1].breakAfter && u[n].merge(0, 0, u[e - 1], !1, a, l) && e--, (e < n || o.length) && t.replaceChildren(e, n, o);
  }
}
function hM(t, e, r, n, i, o) {
  let s = t.childCursor(), { i: a, off: l } = s.findPos(r, 1), { i: u, off: c } = s.findPos(e, -1), h = e - r;
  for (let d of n)
    h += d.length;
  t.length += h, cM(t, u, c, a, l, n, 0, i, o);
}
const VQ = 256;
class Js extends _r {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, n) {
    return this.flags & 8 || n && (!(n instanceof Js) || this.length - (r - e) + n.length > VQ || n.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new Js(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new ii(this.dom, e);
  }
  domBoundsAround(e, r, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return WQ(this.dom, e, r);
  }
}
class Yl extends _r {
  constructor(e, r = [], n = 0) {
    super(), this.mark = e, this.children = r, this.length = n;
    for (let i of r)
      i.setParent(this);
  }
  setAttrs(e) {
    if (oM(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, n, i, o, s) {
    return n && (!(n instanceof Yl && n.mark.eq(this.mark)) || e && o <= 0 || r < this.length && s <= 0) ? !1 : (hM(this, e, r, n ? n.children.slice() : [], o - 1, s - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], n = 0, i = -1, o = 0;
    for (let a of this.children) {
      let l = n + a.length;
      l > e && r.push(n < e ? a.split(e - n) : a), i < 0 && n >= e && (i = o), n = l, o++;
    }
    let s = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Yl(this.mark, r, s);
  }
  domAtPos(e) {
    return fM(this, e);
  }
  coordsAt(e, r) {
    return pM(this, e, r);
  }
}
function WQ(t, e, r) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let i = e, o = e, s = 0;
  e == 0 && r < 0 || e == n && r >= 0 ? $e.chrome || $e.gecko || (e ? (i--, s = 1) : o < n && (o++, s = -1)) : r < 0 ? i-- : o < n && o++;
  let a = kh(t, i, o).getClientRects();
  if (!a.length)
    return null;
  let l = a[(s ? s < 0 : r >= 0) ? 0 : a.length - 1];
  return $e.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (u) => u.width) || l), s ? $b(l, s < 0) : l || null;
}
class Ru extends _r {
  static create(e, r, n) {
    return new Ru(e, r, n);
  }
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.side = n, this.prevWidget = null;
  }
  split(e) {
    let r = Ru.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, n, i, o, s) {
    return n && (!(n instanceof Ru) || !this.widget.compare(n.widget) || e > 0 && o <= 0 || r < this.length && s <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof Ru && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return or.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, n = r && r.state.doc, i = this.posAtStart;
    return n ? n.slice(i, i + this.length) : or.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? ii.before(this.dom) : ii.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let n = this.widget.coordsAt(this.dom, e, r);
    if (n)
      return n;
    let i = this.dom.getClientRects(), o = null;
    if (!i.length)
      return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let a = s ? i.length - 1 : 0; o = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
      ;
    return $b(o, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class wd extends _r {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof wd && e.side == this.side;
  }
  split() {
    return new wd(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? ii.before(this.dom) : ii.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return or.empty;
  }
  get isHidden() {
    return !0;
  }
}
Js.prototype.children = Ru.prototype.children = wd.prototype.children = t4;
function fM(t, e) {
  let r = t.dom, { children: n } = t, i = 0;
  for (let o = 0; i < n.length; i++) {
    let s = n[i], a = o + s.length;
    if (!(a == o && s.getSide() <= 0)) {
      if (e > o && e < a && s.dom.parentNode == r)
        return s.domAtPos(e - o);
      if (e <= o)
        break;
      o = a;
    }
  }
  for (let o = i; o > 0; o--) {
    let s = n[o - 1];
    if (s.dom.parentNode == r)
      return s.domAtPos(s.length);
  }
  for (let o = i; o < n.length; o++) {
    let s = n[o];
    if (s.dom.parentNode == r)
      return s.domAtPos(0);
  }
  return new ii(r, 0);
}
function dM(t, e, r) {
  let n, { children: i } = t;
  r > 0 && e instanceof Yl && i.length && (n = i[i.length - 1]) instanceof Yl && n.mark.eq(e.mark) ? dM(n, e.children[0], r - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function pM(t, e, r) {
  let n = null, i = -1, o = null, s = -1;
  function a(u, c) {
    for (let h = 0, d = 0; h < u.children.length && d <= c; h++) {
      let p = u.children[h], g = d + p.length;
      g >= c && (p.children.length ? a(p, c - d) : (!o || o.isHidden && (r > 0 || KQ(o, p))) && (g > c || d == g && p.getSide() > 0) ? (o = p, s = c - d) : (d < c || d == g && p.getSide() < 0 && !p.isHidden) && (n = p, i = c - d)), d = g;
    }
  }
  a(t, e);
  let l = (r < 0 ? n : o) || n || o;
  return l ? l.coordsAt(Math.max(0, l == n ? i : s), r) : GQ(t);
}
function GQ(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = Zm(e);
  return r[r.length - 1] || null;
}
function KQ(t, e) {
  let r = t.coordsAt(0, 1), n = e.coordsAt(0, 1);
  return r && n && n.top < r.bottom;
}
function $3(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const qD = /* @__PURE__ */ Object.create(null);
function h1(t, e, r) {
  if (t == e)
    return !0;
  t || (t = qD), e || (e = qD);
  let n = Object.keys(t), i = Object.keys(e);
  if (n.length - (r && n.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let o of n)
    if (o != r && (i.indexOf(o) == -1 || t[o] !== e[o]))
      return !1;
  return !0;
}
function I3(t, e, r) {
  let n = !1;
  if (e)
    for (let i in e)
      r && i in r || (n = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (r)
    for (let i in r)
      e && e[i] == r[i] || (n = !0, i == "style" ? t.style.cssText = r[i] : t.setAttribute(i, r[i]));
  return n;
}
function XQ(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let n = t.attributes[r];
    e[n.name] = n.value;
  }
  return e;
}
class Lh {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, n) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var $i = /* @__PURE__ */ (function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
})($i || ($i = {}));
class ft extends xh {
  constructor(e, r, n, i) {
    super(), this.startSide = e, this.endSide = r, this.widget = n, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Jg(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), n = !!e.block;
    return r += n && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new sc(e, r, r, n, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, n, i;
    if (e.isBlockGap)
      n = -5e8, i = 4e8;
    else {
      let { start: o, end: s } = mM(e, r);
      n = (o ? r ? -3e8 : -1 : 5e8) - 1, i = (s ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new sc(e, n, i, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Yg(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return fr.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ft.none = fr.empty;
class Jg extends ft {
  constructor(e) {
    let { start: r, end: n } = mM(e);
    super(r ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, n;
    return this == e || e instanceof Jg && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) && h1(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
Jg.prototype.point = !1;
class Yg extends ft {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Yg && this.spec.class == e.spec.class && h1(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Yg.prototype.mapMode = Kn.TrackBefore;
Yg.prototype.point = !0;
class sc extends ft {
  constructor(e, r, n, i, o, s) {
    super(r, n, o, e), this.block = i, this.isReplace = s, this.mapMode = i ? r <= 0 ? Kn.TrackBefore : Kn.TrackAfter : Kn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? $i.WidgetRange : this.startSide <= 0 ? $i.WidgetBefore : $i.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof sc && QQ(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
sc.prototype.point = !0;
function mM(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: n } = t;
  return r == null && (r = t.inclusive), n == null && (n = t.inclusive), { start: r ?? e, end: n ?? e };
}
function QQ(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function My(t, e, r, n = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + n >= t ? r[i] = Math.max(r[i], e) : r.push(t, e);
}
class yn extends _r {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, n, i, o, s) {
    if (n) {
      if (!(n instanceof yn))
        return !1;
      this.dom || n.transferDOM(this);
    }
    return i && this.setDeco(n ? n.attrs : null), hM(this, e, r, n ? n.children.slice() : [], o, s), !0;
  }
  split(e) {
    let r = new yn();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i: n, off: i } = this.childPos(e);
    i && (r.append(this.children[n].split(i), 0), this.children[n].merge(i, this.children[n].length, null, !1, 0, 0), n++);
    for (let o = n; o < this.children.length; o++)
      r.append(this.children[o], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    h1(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    dM(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, n = e.spec.class;
    r && (this.attrs = $3(r, this.attrs || {})), n && (this.attrs = $3({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return fM(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var n;
    this.dom ? this.flags & 4 && (oM(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (I3(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && _r.get(i) instanceof Yl; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((n = _r.get(i)) === null || n === void 0 ? void 0 : n.isEditable) == !1 && (!$e.ios || !this.children.some((o) => o instanceof Js))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let n of this.children) {
      if (!(n instanceof Js) || /[^ -~]/.test(n.text))
        return null;
      let i = Zm(n.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, r = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let n = pM(this, e, r);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, o = n.bottom - n.top;
      if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
        let s = (o - i.textHeight) / 2;
        return { top: n.top + s, bottom: n.bottom - s, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return e instanceof yn && this.children.length == 0 && e.children.length == 0 && h1(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let n = 0, i = 0; n < e.children.length; n++) {
      let o = e.children[n], s = i + o.length;
      if (s >= r) {
        if (o instanceof yn)
          return o;
        if (s > r)
          break;
      }
      i = s + o.breakAfter;
    }
    return null;
  }
}
class Vl extends _r {
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.deco = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, n, i, o, s) {
    return n && (!(n instanceof Vl) || !this.widget.compare(n.widget) || e > 0 && o <= 0 || r < this.length && s <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? ii.before(this.dom) : ii.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let n = new Vl(this.widget, r, this.deco);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return t4;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : or.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Vl && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r) || (this.widget instanceof B3 ? null : $b(this.dom.getBoundingClientRect(), this.length ? e == 0 : r <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: n } = this.deco;
    return r == n ? !1 : e < 0 ? r < 0 : n > 0;
  }
}
class B3 extends Lh {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Fm {
  constructor(e, r, n, i) {
    this.doc = e, this.pos = r, this.end = n, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Vl && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new yn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Ev(new wd(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Vl) && this.getLine();
  }
  buildText(e, r, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: a, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(this.text.length - this.textOff, e), o = Math.min(
        i,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - n)), this.getLine().append(Ev(new Js(this.text.slice(this.textOff, this.textOff + o)), r), n), this.atCursorPos = !0, this.textOff += o, e -= o, n = i <= o ? 0 : r.length;
    }
  }
  span(e, r, n, i) {
    this.buildText(r - e, n, i), this.pos = r, this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, n, i, o, s) {
    if (this.disallowBlockEffectsFor[s] && n instanceof sc) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = r - e;
    if (n instanceof sc)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Vl(n.widget || kd.block, a, n));
      else {
        let l = Ru.create(n.widget || kd.inline, a, a ? 0 : n.startSide), u = this.atCursorPos && !l.isEditable && o <= i.length && (e < r || n.startSide > 0), c = !l.isEditable && (e < r || o > i.length || n.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), u && (h.append(Ev(new wd(1), i), o), o = i.length + Math.max(0, o - i.length)), h.append(Ev(l, i), o), this.atCursorPos = c, this.pendingBuffer = c ? e < r || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, r, n, i, o) {
    let s = new Fm(e, r, n, o);
    return s.openEnd = fr.spans(i, r, n, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function Ev(t, e) {
  for (let r of e)
    t = new Yl(r, [t], t.length);
  return t;
}
class kd extends Lh {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
kd.inline = /* @__PURE__ */ new kd("span");
kd.block = /* @__PURE__ */ new kd("div");
var zr = /* @__PURE__ */ (function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
})(zr || (zr = {}));
const Ch = zr.LTR, r4 = zr.RTL;
function gM(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const JQ = /* @__PURE__ */ gM("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), YQ = /* @__PURE__ */ gM("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), L3 = /* @__PURE__ */ Object.create(null), pa = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  L3[e] = r, L3[r] = -e;
}
function vM(t) {
  return t <= 247 ? JQ[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? YQ[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const ZQ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Nu {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? r4 : Ch;
  }
  /**
  @internal
  */
  constructor(e, r, n) {
    this.from = e, this.to = r, this.level = n;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, n, i) {
    let o = -1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      if (a.from <= r && a.to >= r) {
        if (a.level == n)
          return s;
        (o < 0 || (i != 0 ? i < 0 ? a.from < r : a.to > r : e[o].level > a.level)) && (o = s);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function yM(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], i = e[r];
    if (n.from != i.from || n.to != i.to || n.direction != i.direction || !yM(n.inner, i.inner))
      return !1;
  }
  return !0;
}
const Fr = [];
function eJ(t, e, r, n, i) {
  for (let o = 0; o <= n.length; o++) {
    let s = o ? n[o - 1].to : e, a = o < n.length ? n[o].from : r, l = o ? 256 : i;
    for (let u = s, c = l, h = l; u < a; u++) {
      let d = vM(t.charCodeAt(u));
      d == 512 ? d = c : d == 8 && h == 4 && (d = 16), Fr[u] = d == 4 ? 2 : d, d & 7 && (h = d), c = d;
    }
    for (let u = s, c = l, h = l; u < a; u++) {
      let d = Fr[u];
      if (d == 128)
        u < a - 1 && c == Fr[u + 1] && c & 24 ? d = Fr[u] = c : Fr[u] = 256;
      else if (d == 64) {
        let p = u + 1;
        for (; p < a && Fr[p] == 64; )
          p++;
        let g = u && c == 8 || p < r && Fr[p] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let v = u; v < p; v++)
          Fr[v] = g;
        u = p - 1;
      } else d == 8 && h == 1 && (Fr[u] = 1);
      c = d, d & 7 && (h = d);
    }
  }
}
function tJ(t, e, r, n, i) {
  let o = i == 1 ? 2 : 1;
  for (let s = 0, a = 0, l = 0; s <= n.length; s++) {
    let u = s ? n[s - 1].to : e, c = s < n.length ? n[s].from : r;
    for (let h = u, d, p, g; h < c; h++)
      if (p = L3[d = t.charCodeAt(h)])
        if (p < 0) {
          for (let v = a - 3; v >= 0; v -= 3)
            if (pa[v + 1] == -p) {
              let y = pa[v + 2], b = y & 2 ? i : y & 4 ? y & 1 ? o : i : 0;
              b && (Fr[h] = Fr[pa[v]] = b), a = v;
              break;
            }
        } else {
          if (pa.length == 189)
            break;
          pa[a++] = h, pa[a++] = d, pa[a++] = l;
        }
      else if ((g = Fr[h]) == 2 || g == 1) {
        let v = g == i;
        l = v ? 0 : 1;
        for (let y = a - 3; y >= 0; y -= 3) {
          let b = pa[y + 2];
          if (b & 2)
            break;
          if (v)
            pa[y + 2] |= 2;
          else {
            if (b & 4)
              break;
            pa[y + 2] |= 4;
          }
        }
      }
  }
}
function rJ(t, e, r, n) {
  for (let i = 0, o = n; i <= r.length; i++) {
    let s = i ? r[i - 1].to : t, a = i < r.length ? r[i].from : e;
    for (let l = s; l < a; ) {
      let u = Fr[l];
      if (u == 256) {
        let c = l + 1;
        for (; ; )
          if (c == a) {
            if (i == r.length)
              break;
            c = r[i++].to, a = i < r.length ? r[i].from : e;
          } else if (Fr[c] == 256)
            c++;
          else
            break;
        let h = o == 1, d = (c < e ? Fr[c] : n) == 1, p = h == d ? h ? 1 : 2 : n;
        for (let g = c, v = i, y = v ? r[v - 1].to : t; g > l; )
          g == y && (g = r[--v].from, y = v ? r[v - 1].to : t), Fr[--g] = p;
        l = c;
      } else
        o = u, l++;
    }
  }
}
function z3(t, e, r, n, i, o, s) {
  let a = n % 2 ? 2 : 1;
  if (n % 2 == i % 2)
    for (let l = e, u = 0; l < r; ) {
      let c = !0, h = !1;
      if (u == o.length || l < o[u].from) {
        let v = Fr[l];
        v != a && (c = !1, h = v == 16);
      }
      let d = !c && a == 1 ? [] : null, p = c ? n : n + 1, g = l;
      e: for (; ; )
        if (u < o.length && g == o[u].from) {
          if (h)
            break e;
          let v = o[u];
          if (!c)
            for (let y = v.to, b = u + 1; ; ) {
              if (y == r)
                break e;
              if (b < o.length && o[b].from == y)
                y = o[b++].to;
              else {
                if (Fr[y] == a)
                  break e;
                break;
              }
            }
          if (u++, d)
            d.push(v);
          else {
            v.from > l && s.push(new Nu(l, v.from, p));
            let y = v.direction == Ch != !(p % 2);
            j3(t, y ? n + 1 : n, i, v.inner, v.from, v.to, s), l = v.to;
          }
          g = v.to;
        } else {
          if (g == r || (c ? Fr[g] != a : Fr[g] == a))
            break;
          g++;
        }
      d ? z3(t, l, g, n + 1, i, d, s) : l < g && s.push(new Nu(l, g, p)), l = g;
    }
  else
    for (let l = r, u = o.length; l > e; ) {
      let c = !0, h = !1;
      if (!u || l > o[u - 1].to) {
        let v = Fr[l - 1];
        v != a && (c = !1, h = v == 16);
      }
      let d = !c && a == 1 ? [] : null, p = c ? n : n + 1, g = l;
      e: for (; ; )
        if (u && g == o[u - 1].to) {
          if (h)
            break e;
          let v = o[--u];
          if (!c)
            for (let y = v.from, b = u; ; ) {
              if (y == e)
                break e;
              if (b && o[b - 1].to == y)
                y = o[--b].from;
              else {
                if (Fr[y - 1] == a)
                  break e;
                break;
              }
            }
          if (d)
            d.push(v);
          else {
            v.to < l && s.push(new Nu(v.to, l, p));
            let y = v.direction == Ch != !(p % 2);
            j3(t, y ? n + 1 : n, i, v.inner, v.from, v.to, s), l = v.from;
          }
          g = v.from;
        } else {
          if (g == e || (c ? Fr[g - 1] != a : Fr[g - 1] == a))
            break;
          g--;
        }
      d ? z3(t, g, l, n + 1, i, d, s) : g < l && s.push(new Nu(g, l, p)), l = g;
    }
}
function j3(t, e, r, n, i, o, s) {
  let a = e % 2 ? 2 : 1;
  eJ(t, i, o, n, a), tJ(t, i, o, n, a), rJ(i, o, n, a), z3(t, i, o, e, r, n, s);
}
function nJ(t, e, r) {
  if (!t)
    return [new Nu(0, 0, e == r4 ? 1 : 0)];
  if (e == Ch && !r.length && !ZQ.test(t))
    return bM(t.length);
  if (r.length)
    for (; t.length > Fr.length; )
      Fr[Fr.length] = 256;
  let n = [], i = e == Ch ? 0 : 1;
  return j3(t, i, i, r, 0, t.length, n), n;
}
function bM(t) {
  return [new Nu(0, t, 0)];
}
let xM = "";
function iJ(t, e, r, n, i) {
  var o;
  let s = n.head - t.from, a = Nu.find(e, s, (o = n.bidiLevel) !== null && o !== void 0 ? o : -1, n.assoc), l = e[a], u = l.side(i, r);
  if (s == u) {
    let d = a += i ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    l = e[a = d], s = l.side(!i, r), u = l.side(i, r);
  }
  let c = Xn(t.text, s, l.forward(i, r));
  (c < l.from || c > l.to) && (c = u), xM = t.text.slice(Math.min(s, c), Math.max(s, c));
  let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return h && c == u && h.level + (i ? 0 : 1) < l.level ? de.cursor(h.side(!i, r) + t.from, h.forward(i, r) ? 1 : -1, h.level) : de.cursor(c + t.from, l.forward(i, r) ? -1 : 1, l.level);
}
function oJ(t, e, r) {
  for (let n = e; n < r; n++) {
    let i = vM(t.charCodeAt(n));
    if (i == 1)
      return Ch;
    if (i == 2 || i == 4)
      return r4;
  }
  return Ch;
}
const wM = /* @__PURE__ */ Be.define(), kM = /* @__PURE__ */ Be.define(), CM = /* @__PURE__ */ Be.define(), _M = /* @__PURE__ */ Be.define(), q3 = /* @__PURE__ */ Be.define(), SM = /* @__PURE__ */ Be.define(), AM = /* @__PURE__ */ Be.define(), n4 = /* @__PURE__ */ Be.define(), i4 = /* @__PURE__ */ Be.define(), EM = /* @__PURE__ */ Be.define({
  combine: (t) => t.some((e) => e)
}), DM = /* @__PURE__ */ Be.define({
  combine: (t) => t.some((e) => e)
}), OM = /* @__PURE__ */ Be.define();
class Wf {
  constructor(e, r = "nearest", n = "nearest", i = 5, o = 5, s = !1) {
    this.range = e, this.y = r, this.x = n, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
  }
  map(e) {
    return e.empty ? this : new Wf(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Wf(de.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Dv = /* @__PURE__ */ kt.define({ map: (t, e) => t.map(e) }), FM = /* @__PURE__ */ kt.define();
function Ri(t, e, r) {
  let n = t.facet(_M);
  n.length ? n[0](e) : window.onerror && window.onerror(String(e), r, void 0, void 0, e) || (r ? console.error(r + ":", e) : console.error(e));
}
const Nl = /* @__PURE__ */ Be.define({ combine: (t) => t.length ? t[0] : !0 });
let sJ = 0;
const Tf = /* @__PURE__ */ Be.define({
  combine(t) {
    return t.filter((e, r) => {
      for (let n = 0; n < r; n++)
        if (t[n].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class kn {
  constructor(e, r, n, i, o) {
    this.id = e, this.create = r, this.domEventHandlers = n, this.domEventObservers = i, this.baseExtensions = o(this), this.extension = this.baseExtensions.concat(Tf.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(Tf.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: n, eventObservers: i, provide: o, decorations: s } = r || {};
    return new kn(sJ++, e, n, i, (a) => {
      let l = [];
      return s && l.push(eg.of((u) => {
        let c = u.plugin(a);
        return c ? s(c) : ft.none;
      })), o && l.push(o(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return kn.define((n, i) => new e(n, i), r);
  }
}
class x2 {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (n) {
            if (Ri(r.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (r) {
        Ri(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        Ri(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const TM = /* @__PURE__ */ Be.define(), o4 = /* @__PURE__ */ Be.define(), eg = /* @__PURE__ */ Be.define(), MM = /* @__PURE__ */ Be.define(), Zg = /* @__PURE__ */ Be.define(), PM = /* @__PURE__ */ Be.define();
function UD(t, e) {
  let r = t.state.facet(PM);
  if (!r.length)
    return r;
  let n = r.map((o) => o instanceof Function ? o(t) : o), i = [];
  return fr.spans(n, e.from, e.to, {
    point() {
    },
    span(o, s, a, l) {
      let u = o - e.from, c = s - e.from, h = i;
      for (let d = a.length - 1; d >= 0; d--, l--) {
        let p = a[d].spec.bidiIsolate, g;
        if (p == null && (p = oJ(e.text, u, c)), l > 0 && h.length && (g = h[h.length - 1]).to == u && g.direction == p)
          g.to = c, h = g.inner;
        else {
          let v = { from: u, to: c, direction: p, inner: [] };
          h.push(v), h = v.inner;
        }
      }
    }
  }), i;
}
const RM = /* @__PURE__ */ Be.define();
function s4(t) {
  let e = 0, r = 0, n = 0, i = 0;
  for (let o of t.state.facet(RM)) {
    let s = o(t);
    s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (r = Math.max(r, s.right)), s.top != null && (n = Math.max(n, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
  }
  return { left: e, right: r, top: n, bottom: i };
}
const pm = /* @__PURE__ */ Be.define();
class ys {
  constructor(e, r, n, i) {
    this.fromA = e, this.toA = r, this.fromB = n, this.toB = i;
  }
  join(e) {
    return new ys(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, n = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > n.toA)) {
        if (i.toA < n.fromA)
          break;
        n = n.join(i), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, n), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let n = [];
    for (let i = 0, o = 0, s = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i], u = s - a, c = l ? l.fromB : 1e9;
      for (; o < r.length && r[o] < c; ) {
        let h = r[o], d = r[o + 1], p = Math.max(a, h), g = Math.min(c, d);
        if (p <= g && new ys(p + u, g + u, p, g).addToSet(n), d > c)
          break;
        o += 2;
      }
      if (!l)
        return n;
      new ys(l.fromA, l.toA, l.fromB, l.toB).addToSet(n), s = l.toA, a = l.toB;
    }
  }
}
class f1 {
  constructor(e, r, n) {
    this.view = e, this.state = r, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = Dn.empty(this.startState.doc.length);
    for (let o of n)
      this.changes = this.changes.compose(o.changes);
    let i = [];
    this.changes.iterChangedRanges((o, s, a, l) => i.push(new ys(o, s, a, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new f1(e, r, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class HD extends _r {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = ft.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new yn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new ys(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let n = e.changedRanges;
    this.minWidth > 0 && n.length && (n.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? i = this.domChanged.newSel.head : !dJ(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let o = i > -1 ? lJ(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      n = new ys(u, c, e.changes.mapPos(u, -1), e.changes.mapPos(c, 1)).addToSet(n.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, ($e.ie || $e.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let s = this.decorations, a = this.updateDeco(), l = hJ(s, a, e.changes);
    return n = ys.extendWithRanges(n, l), !(this.flags & 7) && n.length == 0 ? !1 : (this.updateInner(n, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, n) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, n);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = $e.chrome || $e.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s), this.flags &= -8, s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s) => s.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof Vl && s.widget instanceof B3 && o.push(s.dom);
    i.updateGaps(o);
  }
  updateChildren(e, r, n) {
    let i = n ? n.range.addToSet(e.slice()) : e, o = this.childCursor(r);
    for (let s = i.length - 1; ; s--) {
      let a = s >= 0 ? i[s] : null;
      if (!a)
        break;
      let { fromA: l, toA: u, fromB: c, toB: h } = a, d, p, g, v;
      if (n && n.range.fromB < h && n.range.toB > c) {
        let S = Fm.build(this.view.state.doc, c, n.range.fromB, this.decorations, this.dynamicDecorationMap), _ = Fm.build(this.view.state.doc, n.range.toB, h, this.decorations, this.dynamicDecorationMap);
        p = S.breakAtStart, g = S.openStart, v = _.openEnd;
        let D = this.compositionView(n);
        _.breakAtStart ? D.breakAfter = 1 : _.content.length && D.merge(D.length, D.length, _.content[0], !1, _.openStart, 0) && (D.breakAfter = _.content[0].breakAfter, _.content.shift()), S.content.length && D.merge(0, 0, S.content[S.content.length - 1], !0, 0, S.openEnd) && S.content.pop(), d = S.content.concat(D).concat(_.content);
      } else
        ({ content: d, breakAtStart: p, openStart: g, openEnd: v } = Fm.build(this.view.state.doc, c, h, this.decorations, this.dynamicDecorationMap));
      let { i: y, off: b } = o.findPos(u, 1), { i: k, off: C } = o.findPos(l, -1);
      cM(this, k, C, y, b, d, p, g, v);
    }
    n && this.fixCompositionDOM(n);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(FM) && (this.editContextFormatting = n.value);
  }
  compositionView(e) {
    let r = new Js(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks)
      r = new Yl(i, [r], r.length);
    let n = new yn();
    return n.append(r, 0), n;
  }
  fixCompositionDOM(e) {
    let r = (o, s) => {
      s.flags |= 8 | (s.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s);
      let a = _r.get(o);
      a && a != s && (a.dom = null), s.setDOM(o);
    }, n = this.childPos(e.range.fromB, 1), i = this.children[n.i];
    r(e.line, i);
    for (let o = e.marks.length - 1; o >= -1; o--)
      n = i.childPos(n.off, 1), i = i.children[n.i], r(o >= 0 ? e.marks[o].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement, i = n == this.dom, o = !i && !(this.view.state.facet(Nl) || this.dom.tabIndex > -1) && Ty(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(i || r || o))
      return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), u = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if ($e.gecko && a.empty && !this.hasComposition && aJ(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = u = new ii(h, 0), s = !0;
    }
    let c = this.view.observer.selectionRange;
    (s || !c.focusNode || (!Om(l.node, l.offset, c.anchorNode, c.anchorOffset) || !Om(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, a)) && (this.view.observer.ignore(() => {
      $e.android && $e.chrome && this.dom.contains(c.focusNode) && fJ(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Ym(this.view.root);
      if (h) if (a.empty) {
        if ($e.gecko) {
          let d = uJ(l.node, l.offset);
          if (d && d != 3) {
            let p = (d == 1 ? aM : lM)(l.node, l.offset);
            p && (l = new ii(p.node, p.offset));
          }
        }
        h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
      } else if (h.extend) {
        h.collapse(l.node, l.offset);
        try {
          h.extend(u.node, u.offset);
        } catch {
        }
      } else {
        let d = document.createRange();
        a.anchor > a.head && ([l, u] = [u, l]), d.setEnd(u.node, u.offset), d.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(d);
      }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new ii(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new ii(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Om(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, n = Ym(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
    if (!n || !r.empty || !r.assoc || !n.modify)
      return;
    let s = yn.find(this, r.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (r.head == a || r.head == a + s.length)
      return;
    let l = this.coordsAt(r.head, -1), u = this.coordsAt(r.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let c = this.domAtPos(r.head + r.assoc);
    n.collapse(c.node, c.offset), n.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != r.from && n.collapse(i, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, n;
    if (e.node != r)
      return e;
    for (let i = e.offset; !n && i < r.childNodes.length; i++) {
      let o = _r.get(r.childNodes[i]);
      o instanceof yn && (n = o.domAtPos(0));
    }
    for (let i = e.offset - 1; !n && i >= 0; i--) {
      let o = _r.get(r.childNodes[i]);
      o instanceof yn && (n = o.domAtPos(o.length));
    }
    return n ? new ii(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let n = _r.get(r);
      if (n && n.rootView == this)
        return n;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, r) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: n } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (n < i.length || i instanceof yn)
        break;
      r++, n = 0;
    }
    return this.children[r].domAtPos(n);
  }
  coordsAt(e, r) {
    let n = null, i = 0;
    for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
      let a = this.children[s], l = o - a.breakAfter, u = l - a.length;
      if (l < e)
        break;
      if (u <= e && (u < e || a.covers(-1)) && (l > e || a.covers(1)) && (!n || a instanceof yn && !(n instanceof yn && r >= 0)))
        n = a, i = u;
      else if (n && u == e && l == e && a instanceof Vl && Math.abs(r) < 2) {
        if (a.deco.startSide < 0)
          break;
        s && (n = null);
      }
      o = u;
    }
    return n ? n.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: n } = this.childPos(e, 1), i = this.children[r];
    if (!(i instanceof yn))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(n, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      n = l;
    }
    if (!(i instanceof Js))
      return null;
    let o = Xn(i.text, n);
    if (o == n)
      return null;
    let s = kh(i.dom, n, o).getClientRects();
    for (let a = 0; a < s.length; a++) {
      let l = s[a];
      if (a == s.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: n, to: i } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == zr.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let h = this.children[c], d = u + h.length;
      if (d > i)
        break;
      if (u >= n) {
        let p = h.dom.getBoundingClientRect();
        if (r.push(p.height), s) {
          let g = h.dom.lastChild, v = g ? Zm(g) : [];
          if (v.length) {
            let y = v[v.length - 1], b = l ? y.right - p.left : p.right - y.left;
            b > a && (a = b, this.minWidth = o, this.minWidthFrom = u, this.minWidthTo = d);
          }
        }
      }
      u = d + h.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? zr.RTL : zr.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof yn) {
        let s = o.measureTextSize();
        if (s)
          return s;
      }
    let e = document.createElement("div"), r, n, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let o = Zm(e.firstChild)[0];
      r = e.getBoundingClientRect().height, n = o ? o.width / 27 : 7, i = o ? o.height : r, e.remove();
    }), { lineHeight: r, charWidth: n, textHeight: i };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new uM(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let n = 0, i = 0; ; i++) {
      let o = i == r.viewports.length ? null : r.viewports[i], s = o ? o.from - 1 : this.length;
      if (s > n) {
        let a = (r.lineBlockAt(s).bottom - r.lineBlockAt(n).top) / this.view.scaleY;
        e.push(ft.replace({
          widget: new B3(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(n, s));
      }
      if (!o)
        break;
      n = o.to + 1;
    }
    return ft.set(e);
  }
  updateDeco() {
    let e = 1, r = this.view.state.facet(eg).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), n = !1, i = this.view.state.facet(MM).map((o, s) => {
      let a = typeof o == "function";
      return a && (n = !0), a ? o(this.view) : o;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = n, r.push(fr.join(i))), this.decorations = [
      this.editContextFormatting,
      ...r,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = u.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let u of this.view.state.facet(OM))
      try {
        if (u(this.view, e.range, e))
          return !0;
      } catch (c) {
        Ri(this.view.state, c, "scroll handler");
      }
    let { range: r } = e, n = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), i;
    if (!n)
      return;
    !r.empty && (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, i.left),
      top: Math.min(n.top, i.top),
      right: Math.max(n.right, i.right),
      bottom: Math.max(n.bottom, i.bottom)
    });
    let o = s4(this.view), s = {
      left: n.left - o.left,
      top: n.top - o.top,
      right: n.right + o.right,
      bottom: n.bottom + o.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    zQ(this.view.scrollDOM, s, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == zr.LTR);
  }
}
function aJ(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
function NM(t, e) {
  let r = t.observer.selectionRange;
  if (!r.focusNode)
    return null;
  let n = aM(r.focusNode, r.focusOffset), i = lM(r.focusNode, r.focusOffset), o = n || i;
  if (i && n && i.node != n.node) {
    let a = _r.get(i.node);
    if (!a || a instanceof Js && a.text != i.node.nodeValue)
      o = i;
    else if (t.docView.lastCompositionAfterCursor) {
      let l = _r.get(n.node);
      !l || l instanceof Js && l.text != n.node.nodeValue || (o = i);
    }
  }
  if (t.docView.lastCompositionAfterCursor = o != n, !o)
    return null;
  let s = e - o.offset;
  return { from: s, to: s + o.node.nodeValue.length, node: o.node };
}
function lJ(t, e, r) {
  let n = NM(t, r);
  if (!n)
    return null;
  let { node: i, from: o, to: s } = n, a = i.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(n.from, n.to) != a)
    return null;
  let l = e.invertedDesc, u = new ys(l.mapPos(o), l.mapPos(s), o, s), c = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let d = _r.get(h);
    if (d instanceof Yl)
      c.push({ node: h, deco: d.mark });
    else {
      if (d instanceof yn || h.nodeName == "DIV" && h.parentNode == t.contentDOM)
        return { range: u, text: i, marks: c, line: h };
      if (h != t.contentDOM)
        c.push({ node: h, deco: new Jg({
          inclusive: !0,
          attributes: XQ(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function uJ(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let cJ = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    My(t, e, this.changes);
  }
  comparePoint(t, e) {
    My(t, e, this.changes);
  }
  boundChange(t) {
    My(t, t, this.changes);
  }
};
function hJ(t, e, r) {
  let n = new cJ();
  return fr.compare(t, e, r, n), n.changes;
}
function fJ(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function dJ(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((n, i) => {
    n < e.to && i > e.from && (r = !0);
  }), r;
}
function pJ(t, e, r = 1) {
  let n = t.charCategorizer(e), i = t.doc.lineAt(e), o = e - i.from;
  if (i.length == 0)
    return de.cursor(e);
  o == 0 ? r = 1 : o == i.length && (r = -1);
  let s = o, a = o;
  r < 0 ? s = Xn(i.text, o, !1) : a = Xn(i.text, o);
  let l = n(i.text.slice(s, a));
  for (; s > 0; ) {
    let u = Xn(i.text, s, !1);
    if (n(i.text.slice(u, s)) != l)
      break;
    s = u;
  }
  for (; a < i.length; ) {
    let u = Xn(i.text, a);
    if (n(i.text.slice(a, u)) != l)
      break;
    a = u;
  }
  return de.range(s + i.from, a + i.from);
}
function mJ(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function gJ(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function w2(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function VD(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function WD(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function U3(t, e, r) {
  let n, i, o, s, a = !1, l, u, c, h;
  for (let g = t.firstChild; g; g = g.nextSibling) {
    let v = Zm(g);
    for (let y = 0; y < v.length; y++) {
      let b = v[y];
      i && w2(i, b) && (b = VD(WD(b, i.bottom), i.top));
      let k = mJ(e, b), C = gJ(r, b);
      if (k == 0 && C == 0)
        return g.nodeType == 3 ? GD(g, e, r) : U3(g, e, r);
      (!n || s > C || s == C && o > k) && (n = g, i = b, o = k, s = C, a = k ? e < b.left ? y > 0 : y < v.length - 1 : !0), k == 0 ? r > b.bottom && (!c || c.bottom < b.bottom) ? (l = g, c = b) : r < b.top && (!h || h.top > b.top) && (u = g, h = b) : c && w2(c, b) ? c = WD(c, b.bottom) : h && w2(h, b) && (h = VD(h, b.top));
    }
  }
  if (c && c.bottom >= r ? (n = l, i = c) : h && h.top <= r && (n = u, i = h), !n)
    return { node: t, offset: 0 };
  let d = Math.max(i.left, Math.min(i.right, e));
  if (n.nodeType == 3)
    return GD(n, d, r);
  if (a && n.contentEditable != "false")
    return U3(n, d, r);
  let p = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: p };
}
function GD(t, e, r) {
  let n = t.nodeValue.length, i = -1, o = 1e9, s = 0;
  for (let a = 0; a < n; a++) {
    let l = kh(t, a, a + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let c = l[u];
      if (c.top == c.bottom)
        continue;
      s || (s = e - c.left);
      let h = (c.top > r ? c.top - r : r - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && h < o) {
        let d = e >= (c.left + c.right) / 2, p = d;
        if (($e.chrome || $e.gecko) && kh(t, a).getBoundingClientRect().left == c.right && (p = !d), h <= 0)
          return { node: t, offset: a + (p ? 1 : 0) };
        i = a + (p ? 1 : 0), o = h;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : s > 0 ? t.nodeValue.length : 0 };
}
function $M(t, e, r, n = -1) {
  var i, o;
  let s = t.contentDOM.getBoundingClientRect(), a = s.top + t.viewState.paddingTop, l, { docHeight: u } = t.viewState, { x: c, y: h } = e, d = h - a;
  if (d < 0)
    return 0;
  if (d > u)
    return t.state.doc.length;
  for (let S = t.viewState.heightOracle.textHeight / 2, _ = !1; l = t.elementAtHeight(d), l.type != $i.Text; )
    for (; d = n > 0 ? l.bottom + S : l.top - S, !(d >= 0 && d <= u); ) {
      if (_)
        return r ? null : 0;
      _ = !0, n = -n;
    }
  h = a + d;
  let p = l.from;
  if (p < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : KD(t, s, l, c, h);
  if (p > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : KD(t, s, l, c, h);
  let g = t.dom.ownerDocument, v = t.root.elementFromPoint ? t.root : g, y = v.elementFromPoint(c, h);
  y && !t.contentDOM.contains(y) && (y = null), y || (c = Math.max(s.left + 1, Math.min(s.right - 1, c)), y = v.elementFromPoint(c, h), y && !t.contentDOM.contains(y) && (y = null));
  let b, k = -1;
  if (y && ((i = t.docView.nearest(y)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (g.caretPositionFromPoint) {
      let S = g.caretPositionFromPoint(c, h);
      S && ({ offsetNode: b, offset: k } = S);
    } else if (g.caretRangeFromPoint) {
      let S = g.caretRangeFromPoint(c, h);
      S && ({ startContainer: b, startOffset: k } = S);
    }
    b && (!t.contentDOM.contains(b) || $e.safari && vJ(b, k, c) || $e.chrome && yJ(b, k, c)) && (b = void 0), b && (k = Math.min(Ja(b), k));
  }
  if (!b || !t.docView.dom.contains(b)) {
    let S = yn.find(t.docView, p);
    if (!S)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: b, offset: k } = U3(S.dom, c, h));
  }
  let C = t.docView.nearest(b);
  if (!C)
    return null;
  if (C.isWidget && ((o = C.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let S = C.dom.getBoundingClientRect();
    return e.y < S.top || e.y <= S.bottom && e.x <= (S.left + S.right) / 2 ? C.posAtStart : C.posAtEnd;
  } else
    return C.localPosFromDOM(b, k) + C.posAtStart;
}
function KD(t, e, r, n, i) {
  let o = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - r.top - (t.defaultLineHeight - a) * 0.5) / a);
    o += l * t.viewState.heightOracle.lineLength;
  }
  let s = t.state.sliceDoc(r.from, r.to);
  return r.from + D3(s, o, t.state.tabSize);
}
function IM(t, e, r) {
  let n, i = t;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length))
    return !1;
  for (; ; ) {
    let o = i.nextSibling;
    if (o) {
      if (o.nodeName == "BR")
        break;
      return !1;
    } else {
      let s = i.parentNode;
      if (!s || s.nodeName == "DIV")
        break;
      i = s;
    }
  }
  return kh(t, n - 1, n).getBoundingClientRect().right > r;
}
function vJ(t, e, r) {
  return IM(t, e, r);
}
function yJ(t, e, r) {
  if (e != 0)
    return IM(t, e, r);
  for (let i = t; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    i = o;
  }
  let n = t.nodeType == 1 ? t.getBoundingClientRect() : kh(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - n.left > 5;
}
function H3(t, e, r) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    let i;
    for (let o of n.type) {
      if (o.from > e)
        break;
      if (!(o.to < e)) {
        if (o.from < e && o.to > e)
          return o;
        (!i || o.type == $i.Text && (i.type != o.type || (r < 0 ? o.from < e : o.to > e))) && (i = o);
      }
    }
    return i || n;
  }
  return n;
}
function bJ(t, e, r, n) {
  let i = H3(t, e.head, e.assoc || -1), o = !n || i.type != $i.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (o) {
    let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({
      x: r == (a == zr.LTR) ? s.right - 1 : s.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (l != null)
      return de.cursor(l, r ? -1 : 1);
  }
  return de.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function XD(t, e, r, n) {
  let i = t.state.doc.lineAt(e.head), o = t.bidiSpans(i), s = t.textDirectionAt(i.from);
  for (let a = e, l = null; ; ) {
    let u = iJ(i, o, s, a, r), c = xM;
    if (!u) {
      if (i.number == (r ? t.state.doc.lines : 1))
        return a;
      c = `
`, i = t.state.doc.line(i.number + (r ? 1 : -1)), o = t.bidiSpans(i), u = t.visualLineSide(i, !r);
    }
    if (l) {
      if (!l(c))
        return a;
    } else {
      if (!n)
        return u;
      l = n(c);
    }
    a = u;
  }
}
function xJ(t, e, r) {
  let n = t.state.charCategorizer(e), i = n(r);
  return (o) => {
    let s = n(o);
    return i == Wr.Space && (i = s), i == s;
  };
}
function wJ(t, e, r, n) {
  let i = e.head, o = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0))
    return de.cursor(i, e.assoc);
  let s = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), u = t.coordsAtPos(i, e.assoc || -1), c = t.documentTop;
  if (u)
    s == null && (s = u.left - l.left), a = o < 0 ? u.top : u.bottom;
  else {
    let p = t.viewState.lineBlockAt(i);
    s == null && (s = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - p.from))), a = (o < 0 ? p.top : p.bottom) + c;
  }
  let h = l.left + s, d = n ?? t.viewState.heightOracle.textHeight >> 1;
  for (let p = 0; ; p += 10) {
    let g = a + (d + p) * o, v = $M(t, { x: h, y: g }, !1, o);
    if (g < l.top || g > l.bottom || (o < 0 ? v < i : v > i)) {
      let y = t.docView.coordsForChar(v), b = !y || g < y.top ? -1 : 1;
      return de.cursor(v, b, void 0, s);
    }
  }
}
function Tm(t, e, r) {
  for (; ; ) {
    let n = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (o, s, a) => {
        if (e > o && e < s) {
          let l = n || r || (e - o < s - e ? -1 : 1);
          e = l < 0 ? o : s, n = l;
        }
      });
    if (!n)
      return e;
  }
}
function BM(t, e) {
  let r = null;
  for (let n = 0; n < e.ranges.length; n++) {
    let i = e.ranges[n], o = null;
    if (i.empty) {
      let s = Tm(t, i.from, 0);
      s != i.from && (o = de.cursor(s, -1));
    } else {
      let s = Tm(t, i.from, -1), a = Tm(t, i.to, 1);
      (s != i.from || a != i.to) && (o = de.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
    }
    o && (r || (r = e.ranges.slice()), r[n] = o);
  }
  return r ? de.create(r, e.mainIndex) : e;
}
function k2(t, e, r) {
  let n = Tm(t.state.facet(Zg).map((i) => i(t)), r.from, e.head > r.from ? -1 : 1);
  return n == r.from ? r : de.cursor(n, n < r.from ? 1 : -1);
}
const mm = "ï¿¿";
class kJ {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(ir.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += mm;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(n, i);
      let o = this.text.length;
      this.readNode(i);
      let s = i.nextSibling;
      if (s == r)
        break;
      let a = _r.get(i), l = _r.get(s);
      (a && l ? a.breakAfter : (a ? a.breakAfter : c1(i)) || c1(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && !_J(s, r) && this.lineBreak(), i = s;
    }
    return this.findPointBefore(n, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, r.length));
    for (let n = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, s = 1, a;
      if (this.lineSeparator ? (o = r.indexOf(this.lineSeparator, n), s = this.lineSeparator.length) : (a = i.exec(r)) && (o = a.index, s = a[0].length), this.append(r.slice(n, o < 0 ? r.length : o)), o < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
      n = o + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = _r.get(e), n = r && r.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let i = n.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == r && (n.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (CJ(e, n.node, n.offset) ? r : 0));
  }
}
function CJ(t, e, r) {
  for (; ; ) {
    if (!e || r < Ja(e))
      return !1;
    if (e == t)
      return !0;
    r = wh(e) + 1, e = e.parentNode;
  }
}
function _J(t, e) {
  let r;
  for (; !(t == e || !t); t = t.nextSibling) {
    let n = _r.get(t);
    if (!(n?.isWidget || t.cmIgnore))
      return !1;
    n && (r || (r = [])).push(n);
  }
  if (r) {
    for (let n of r)
      if (n.overrideDOMText?.length)
        return !1;
  }
  return !0;
}
class QD {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class SJ {
  constructor(e, r, n, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = r > -1;
    let { impreciseHead: o, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, n, 0))) {
      let a = o || s ? [] : EJ(e), l = new kJ(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = DJ(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !N3(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), u = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !N3(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), c = e.viewport;
      if (($e.ios || $e.chrome) && e.state.selection.main.empty && l != u && (c.from > 0 || c.to < e.state.doc.length)) {
        let h = Math.min(l, u), d = Math.max(l, u), p = c.from - h, g = c.to - d;
        (p == 0 || p == 1 || h == 0) && (g == 0 || g == -1 || d == e.state.doc.length) && (l = 0, u = e.state.doc.length);
      }
      this.newSel = de.single(u, l);
    }
  }
}
function LM(t, e) {
  let r, { newSel: n } = e, i = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: a } = e.bounds, l = i.from, u = null;
    (o === 8 || $e.android && e.text.length < a - s) && (l = i.to, u = "end");
    let c = zM(t.state.doc.sliceString(s, a, mm), e.text, l - s, u);
    c && ($e.chrome && o == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == mm + mm && c.toB--, r = {
      from: s + c.from,
      to: s + c.toA,
      insert: or.of(e.text.slice(c.from, c.toB).split(mm))
    });
  } else n && (!t.hasFocus && t.state.facet(Nl) || n.main.eq(i)) && (n = null);
  if (!r && !n)
    return !1;
  if (!r && e.typeOver && !i.empty && n && n.main.empty ? r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : ($e.mac || $e.android) && r && r.from == r.to && r.from == i.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (n && r.insert.length == 2 && (n = de.single(n.main.anchor - 1, n.main.head - 1)), r = { from: r.from, to: r.to, insert: or.of([r.insert.toString().replace(".", " ")]) }) : r && r.from >= i.from && r.to <= i.to && (r.from != i.from || r.to != i.to) && i.to - i.from - (r.to - r.from) <= 4 ? r = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to))
  } : $e.chrome && r && r.from == r.to && r.from == i.head && r.insert.toString() == `
 ` && t.lineWrapping && (n && (n = de.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: or.of([" "]) }), r)
    return a4(t, r, n, o);
  if (n && !n.main.eq(i)) {
    let s = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = !0), a = t.inputState.lastSelectionOrigin, a == "select.pointer" && (n = BM(t.state.facet(Zg).map((l) => l(t)), n))), t.dispatch({ selection: n, scrollIntoView: s, userEvent: a }), !0;
  } else
    return !1;
}
function a4(t, e, r, n = -1) {
  if ($e.ios && t.inputState.flushIOSKey(e))
    return !0;
  let i = t.state.selection.main;
  if ($e.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Vf(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || n == 8 && e.insert.length < e.to - e.from && e.to > i.head) && Vf(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Vf(t.contentDOM, "Delete", 46)))
    return !0;
  let o = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let s, a = () => s || (s = AJ(t, e, r));
  return t.state.facet(SM).some((l) => l(t, e.from, e.to, o, a)) || t.dispatch(a()), !0;
}
function AJ(t, e, r) {
  let n, i = t.state, o = i.selection.main, s = -1;
  if (e.from == e.to && e.from < o.from || e.from > o.to) {
    let l = e.from < o.from ? -1 : 1, u = l < 0 ? o.from : o.to, c = Tm(i.facet(Zg).map((h) => h(t)), u, l);
    e.from == c && (s = c);
  }
  if (s > -1)
    n = {
      changes: e,
      selection: de.cursor(e.from + e.insert.length, -1)
    };
  else if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let l = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", u = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
    n = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + u));
  } else {
    let l = i.changes(e), u = r && r.main.to <= l.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), h, d = r && NM(t, r.main.head);
      if (d) {
        let v = e.insert.length - (e.to - e.from);
        h = { from: d.from, to: d.to - v };
      } else
        h = t.state.doc.lineAt(o.head);
      let p = o.to - e.to, g = o.to - o.from;
      n = i.changeByRange((v) => {
        if (v.from == o.from && v.to == o.to)
          return { changes: l, range: u || v.map(l) };
        let y = v.to - p, b = y - c.length;
        if (v.to - v.from != g || t.state.sliceDoc(b, y) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        v.to >= h.from && v.from <= h.to)
          return { range: v };
        let k = i.changes({ from: b, to: y, insert: e.insert }), C = v.to - o.to;
        return {
          changes: k,
          range: u ? de.range(Math.max(0, u.anchor + C), Math.max(0, u.head + C)) : v.map(k)
        };
      });
    } else
      n = {
        changes: l,
        selection: u && i.selection.replaceRange(u)
      };
  }
  let a = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = !1)), i.update(n, { userEvent: a, scrollIntoView: !0 });
}
function zM(t, e, r, n) {
  let i = Math.min(t.length, e.length), o = 0;
  for (; o < i && t.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == i && t.length == e.length)
    return null;
  let s = t.length, a = e.length;
  for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
    s--, a--;
  if (n == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    r -= s + l - o;
  }
  if (s < o && t.length < e.length) {
    let l = r <= o && r >= s ? o - r : 0;
    o -= l, a = o + (a - s), s = o;
  } else if (a < o) {
    let l = r <= o && r >= a ? o - r : 0;
    o -= l, s = o + (s - a), a = o;
  }
  return { from: o, toA: s, toB: a };
}
function EJ(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: o } = t.observer.selectionRange;
  return r && (e.push(new QD(r, n)), (i != r || o != n) && e.push(new QD(i, o))), e;
}
function DJ(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, n = t.length == 2 ? t[1].pos : r;
  return r > -1 && n > -1 ? de.single(r + e, n + e) : null;
}
class OJ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, $e.safari && e.contentDOM.addEventListener("input", () => null), $e.gecko && VJ(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !IJ(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, r) {
    let n = this.handlers[e];
    if (n) {
      for (let i of n.observers)
        i(this.view, r);
      for (let i of n.handlers) {
        if (r.defaultPrevented)
          break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = FJ(e), n = this.handlers, i = this.view.contentDOM;
    for (let o in r)
      if (o != "scroll") {
        let s = !r[o].handlers.length, a = n[o];
        a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, { passive: s });
      }
    for (let o in n)
      o != "scroll" && !r[o] && i.removeEventListener(o, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && qM.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), $e.android && $e.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return $e.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = jM.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || TJ.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let r = this.pendingIOSKey;
    return !r || r.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Vf(this.view.contentDOM, r.key, r.keyCode, r instanceof KeyboardEvent ? r : void 0));
  }
  ignoreDuringComposition(e) {
    return !/^key/.test(e.type) || e.synthetic ? !1 : this.composing > 0 ? !0 : $e.safari && !$e.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function JD(t, e) {
  return (r, n) => {
    try {
      return e.call(t, n, r);
    } catch (i) {
      Ri(r.state, i);
    }
  };
}
function FJ(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of t) {
    let i = n.spec, o = i && i.plugin.domEventHandlers, s = i && i.plugin.domEventObservers;
    if (o)
      for (let a in o) {
        let l = o[a];
        l && r(a).handlers.push(JD(n.value, l));
      }
    if (s)
      for (let a in s) {
        let l = s[a];
        l && r(a).observers.push(JD(n.value, l));
      }
  }
  for (let n in Ys)
    r(n).handlers.push(Ys[n]);
  for (let n in ks)
    r(n).observers.push(ks[n]);
  return e;
}
const jM = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], TJ = "dthko", qM = [16, 17, 18, 20, 91, 92, 224, 225], Ov = 6;
function Fv(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function MJ(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class PJ {
  constructor(e, r, n, i) {
    this.view = e, this.startEvent = r, this.style = n, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParents = jQ(e.contentDOM), this.atoms = e.state.facet(Zg).map((s) => s(e));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(ir.allowMultipleSelections) && RJ(e, r), this.dragging = $J(e, r) && VM(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && MJ(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let r = 0, n = 0, i = 0, o = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = s4(this.view);
    e.clientX - l.left <= i + Ov ? r = -Fv(i - e.clientX) : e.clientX + l.right >= s - Ov && (r = Fv(e.clientX - s)), e.clientY - l.top <= o + Ov ? n = -Fv(o - e.clientY) : e.clientY + l.bottom >= a - Ov && (n = Fv(e.clientY - a)), this.setScrollSpeed(r, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: r } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), r && this.scrollParents.y && (this.scrollParents.y.scrollTop += r, r = 0), (e || r) && this.view.win.scrollBy(e, r), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: r } = this, n = BM(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !n.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: n,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((r) => r.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function RJ(t, e) {
  let r = t.state.facet(wM);
  return r.length ? r[0](e) : $e.mac ? e.metaKey : e.ctrlKey;
}
function NJ(t, e) {
  let r = t.state.facet(kM);
  return r.length ? r[0](e) : $e.mac ? !e.altKey : !e.ctrlKey;
}
function $J(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let n = Ym(t.root);
  if (!n || n.rangeCount == 0)
    return !0;
  let i = n.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let s = i[o];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function IJ(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, n; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (n = _r.get(r)) && n.ignoreEvent(e))
      return !1;
  return !0;
}
const Ys = /* @__PURE__ */ Object.create(null), ks = /* @__PURE__ */ Object.create(null), UM = $e.ie && $e.ie_version < 15 || $e.ios && $e.webkit_version < 604;
function BJ(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), HM(t, r.value);
  }, 50);
}
function Ib(t, e, r) {
  for (let n of t.facet(e))
    r = n(r, t);
  return r;
}
function HM(t, e) {
  e = Ib(t.state, n4, e);
  let { state: r } = t, n, i = 1, o = r.toText(e), s = o.lines == r.selection.ranges.length;
  if (V3 != null && r.selection.ranges.every((a) => a.empty) && V3 == o.toString()) {
    let a = -1;
    n = r.changeByRange((l) => {
      let u = r.doc.lineAt(l.from);
      if (u.from == a)
        return { range: l };
      a = u.from;
      let c = r.toText((s ? o.line(i++).text : e) + r.lineBreak);
      return {
        changes: { from: u.from, insert: c },
        range: de.cursor(l.from + c.length)
      };
    });
  } else s ? n = r.changeByRange((a) => {
    let l = o.line(i++);
    return {
      changes: { from: a.from, to: a.to, insert: l.text },
      range: de.cursor(a.from + l.length)
    };
  }) : n = r.replaceSelection(o);
  t.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
ks.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
Ys.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
ks.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
ks.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Ys.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let n of t.state.facet(CM))
    if (r = n(t, e), r)
      break;
  if (!r && e.button == 0 && (r = jJ(t, e)), r) {
    let n = !t.hasFocus;
    t.inputState.startMouseSelection(new PJ(t, e, r, n)), n && t.observer.ignore(() => {
      iM(t.contentDOM);
      let o = t.root.activeElement;
      o && !o.contains(t.contentDOM) && o.blur();
    });
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    t.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function YD(t, e, r, n) {
  if (n == 1)
    return de.cursor(e, r);
  if (n == 2)
    return pJ(t.state, e, r);
  {
    let i = yn.find(t.docView, e), o = t.state.doc.lineAt(i ? i.posAtEnd : e), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
    return a < t.state.doc.length && a == o.to && a++, de.range(s, a);
  }
}
let ZD = (t, e, r) => e >= r.top && e <= r.bottom && t >= r.left && t <= r.right;
function LJ(t, e, r, n) {
  let i = yn.find(t.docView, e);
  if (!i)
    return 1;
  let o = e - i.posAtStart;
  if (o == 0)
    return 1;
  if (o == i.length)
    return -1;
  let s = i.coordsAt(o, -1);
  if (s && ZD(r, n, s))
    return -1;
  let a = i.coordsAt(o, 1);
  return a && ZD(r, n, a) ? 1 : s && s.bottom >= n ? -1 : 1;
}
function e6(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: LJ(t, r, e.clientX, e.clientY) };
}
const zJ = $e.ie && $e.ie_version <= 11;
let t6 = null, r6 = 0, n6 = 0;
function VM(t) {
  if (!zJ)
    return t.detail;
  let e = t6, r = n6;
  return t6 = t, n6 = Date.now(), r6 = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (r6 + 1) % 3 : 1;
}
function jJ(t, e) {
  let r = e6(t, e), n = VM(e), i = t.state.selection;
  return {
    update(o) {
      o.docChanged && (r.pos = o.changes.mapPos(r.pos), i = i.map(o.changes));
    },
    get(o, s, a) {
      let l = e6(t, o), u, c = YD(t, l.pos, l.bias, n);
      if (r.pos != l.pos && !s) {
        let h = YD(t, r.pos, r.bias, n), d = Math.min(h.from, c.from), p = Math.max(h.to, c.to);
        c = d < c.from ? de.range(d, p) : de.range(p, d);
      }
      return s ? i.replaceRange(i.main.extend(c.from, c.to)) : a && n == 1 && i.ranges.length > 1 && (u = qJ(i, l.pos)) ? u : a ? i.addRange(c) : de.create([c]);
    }
  };
}
function qJ(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: n, to: i } = t.ranges[r];
    if (n <= e && i >= e)
      return de.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
Ys.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let o = i.posAtStart, s = o + i.length;
      (o >= r.to || s <= r.from) && (r = de.range(o, s));
    }
  }
  let { inputState: n } = t;
  return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", Ib(t.state, i4, t.state.sliceDoc(r.from, r.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Ys.dragend = (t) => (t.inputState.draggedContent = null, !1);
function i6(t, e, r, n) {
  if (r = Ib(t.state, n4, r), !r)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: o } = t.inputState, s = n && o && NJ(t, e) ? { from: o.from, to: o.to } : null, a = { from: i, insert: r }, l = t.state.changes(s ? [s, a] : a);
  t.focus(), t.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
Ys.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let n = Array(r.length), i = 0, o = () => {
      ++i == r.length && i6(t, e, n.filter((s) => s != null).join(t.state.lineBreak), !1);
    };
    for (let s = 0; s < r.length; s++) {
      let a = new FileReader();
      a.onerror = o, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (n[s] = a.result), o();
      }, a.readAsText(r[s]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData("Text");
    if (n)
      return i6(t, e, n, !0), !0;
  }
  return !1;
};
Ys.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = UM ? null : e.clipboardData;
  return r ? (HM(t, r.getData("text/plain") || r.getData("text/uri-list")), !0) : (BJ(t), !1);
};
function UJ(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let n = r.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), t.focus();
  }, 50);
}
function HJ(t) {
  let e = [], r = [], n = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: o } of t.selection.ranges) {
      let s = t.doc.lineAt(o);
      s.number > i && (e.push(s.text), r.push({ from: s.from, to: Math.min(t.doc.length, s.to + 1) })), i = s.number;
    }
    n = !0;
  }
  return { text: Ib(t, i4, e.join(t.lineBreak)), ranges: r, linewise: n };
}
let V3 = null;
Ys.copy = Ys.cut = (t, e) => {
  let { text: r, ranges: n, linewise: i } = HJ(t.state);
  if (!r && !i)
    return !1;
  V3 = i ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: n,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = UM ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", r), !0) : (UJ(t, r), !1);
};
const WM = /* @__PURE__ */ iu.define();
function GM(t, e) {
  let r = [];
  for (let n of t.facet(AM)) {
    let i = n(t, e);
    i && r.push(i);
  }
  return r.length ? t.update({ effects: r, annotations: WM.of(!0) }) : null;
}
function KM(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = GM(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
ks.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), KM(t);
};
ks.blur = (t) => {
  t.observer.clearSelectionRange(), KM(t);
};
ks.compositionstart = ks.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
ks.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, $e.chrome && $e.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
ks.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Ys.beforeinput = (t, e) => {
  var r, n;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let o = (r = e.dataTransfer) === null || r === void 0 ? void 0 : r.getData("text/plain"), s = e.getTargetRanges();
    if (o && s.length) {
      let a = s[0], l = t.posAtDOM(a.startContainer, a.startOffset), u = t.posAtDOM(a.endContainer, a.endOffset);
      return a4(t, { from: l, to: u, insert: t.state.toText(o) }, null), !0;
    }
  }
  let i;
  if ($e.chrome && $e.android && (i = jM.find((o) => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let o = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return $e.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), $e.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => ks.compositionend(t, e), 20), !1;
};
const o6 = /* @__PURE__ */ new Set();
function VJ(t) {
  o6.has(t) || (o6.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const s6 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Cd = !1;
function a6() {
  Cd = !1;
}
class WJ {
  constructor(e) {
    this.lineWrapping = e, this.doc = or.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, r) {
    let n = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((r - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return s6.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      i < 0 ? n++ : this.heightSamples[Math.floor(i * 10)] || (r = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, n, i, o, s) {
    let a = s6.indexOf(e) > -1, l = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = r, this.charWidth = n, this.textHeight = i, this.lineLength = o, l) {
      this.heightSamples = {};
      for (let u = 0; u < s.length; u++) {
        let c = s[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return l;
  }
}
class GJ {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Da {
  /**
  @internal
  */
  constructor(e, r, n, i, o) {
    this.from = e, this.length = r, this.top = n, this.height = i, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? $i.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof sc ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Da(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var Lr = /* @__PURE__ */ (function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
})(Lr || (Lr = {}));
const Py = 1e-3;
class Ii {
  constructor(e, r, n = 2) {
    this.length = e, this.height = r, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Py && (Cd = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, n) {
    return Ii.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, n, i) {
    let o = this, s = n.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: u, fromB: c, toB: h } = i[a], d = o.lineAt(l, Lr.ByPosNoHeight, n.setDoc(r), 0, 0), p = d.to >= u ? d : o.lineAt(u, Lr.ByPosNoHeight, n, 0, 0);
      for (h += p.to - u, u = p.to; a > 0 && d.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, c = i[a - 1].fromB, a--, l < d.from && (d = o.lineAt(l, Lr.ByPosNoHeight, n, 0, 0));
      c += d.from - l, l = d.from;
      let g = l4.build(n.setDoc(s), e, c, h);
      o = d1(o, o.replace(l, u, g));
    }
    return o.updateHeight(n, 0);
  }
  static empty() {
    return new Po(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, n = e.length, i = 0, o = 0;
    for (; ; )
      if (r == n)
        if (i > o * 2) {
          let a = e[r - 1];
          a.break ? e.splice(--r, 1, a.left, null, a.right) : e.splice(--r, 1, a.left, a.right), n += 1 + a.break, i -= a.size;
        } else if (o > i * 2) {
          let a = e[n];
          a.break ? e.splice(n, 1, a.left, null, a.right) : e.splice(n, 1, a.left, a.right), n += 2 + a.break, o -= a.size;
        } else
          break;
      else if (i < o) {
        let a = e[r++];
        a && (i += a.size);
      } else {
        let a = e[--n];
        a && (o += a.size);
      }
    let s = 0;
    return e[r - 1] == null ? (s = 1, r--) : e[r] == null && (s = 1, n++), new KJ(Ii.of(e.slice(0, r)), s, Ii.of(e.slice(n)));
  }
}
function d1(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (Cd = !0), e);
}
Ii.prototype.size = 1;
class XM extends Ii {
  constructor(e, r, n) {
    super(e, r), this.deco = n;
  }
  blockAt(e, r, n, i) {
    return new Da(i, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, r, n, i, o) {
    return this.blockAt(0, n, i, o);
  }
  forEachLine(e, r, n, i, o, s) {
    e <= o + this.length && r >= o && s(this.blockAt(0, n, i, o));
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Po extends XM {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, n, i) {
    return new Da(i, this.length, n, this.height, this.breaks);
  }
  replace(e, r, n) {
    let i = n[0];
    return n.length == 1 && (i instanceof Po || i instanceof Wn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Wn ? i = new Po(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Ii.of(n);
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more ? this.setHeight(i.heights[i.index++]) : (n || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Wn extends Ii {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let n = e.doc.lineAt(r).number, i = e.doc.lineAt(r + this.length).number, o = i - n + 1, s, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * o);
      s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
    } else
      s = this.height / o;
    return { firstLine: n, lastLine: i, perLine: s, perChar: a };
  }
  blockAt(e, r, n, i) {
    let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let u = i + (e < r.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length)), c = r.doc.lineAt(u), h = a + c.length * l, d = Math.max(n, e - h / 2);
      return new Da(c.from, c.length, d, h, 0);
    } else {
      let u = Math.max(0, Math.min(s - o, Math.floor((e - n) / a))), { from: c, length: h } = r.doc.line(o + u);
      return new Da(c, h, n + a * u, a, 0);
    }
  }
  lineAt(e, r, n, i, o) {
    if (r == Lr.ByHeight)
      return this.blockAt(e, n, i, o);
    if (r == Lr.ByPosNoHeight) {
      let { from: p, to: g } = n.doc.lineAt(e);
      return new Da(p, g - p, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(n, o), u = n.doc.lineAt(e), c = a + u.length * l, h = u.number - s, d = i + a * h + l * (u.from - o - h);
    return new Da(u.from, u.length, Math.max(i, Math.min(d, i + this.height - c)), c, 0);
  }
  forEachLine(e, r, n, i, o, s) {
    e = Math.max(e, o), r = Math.min(r, o + this.length);
    let { firstLine: a, perLine: l, perChar: u } = this.heightMetrics(n, o);
    for (let c = e, h = i; c <= r; ) {
      let d = n.doc.lineAt(c);
      if (c == e) {
        let g = d.number - a;
        h += l * g + u * (e - o - g);
      }
      let p = l + u * d.length;
      s(new Da(d.from, d.length, h, p, 0)), h += p, c = d.to + 1;
    }
  }
  replace(e, r, n) {
    let i = this.length - r;
    if (i > 0) {
      let o = n[n.length - 1];
      o instanceof Wn ? n[n.length - 1] = new Wn(o.length + i) : n.push(null, new Wn(i - 1));
    }
    if (e > 0) {
      let o = n[0];
      o instanceof Wn ? n[0] = new Wn(e + o.length) : n.unshift(new Wn(e - 1), null);
    }
    return Ii.of(n);
  }
  decomposeLeft(e, r) {
    r.push(new Wn(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new Wn(this.length - e - 1));
  }
  updateHeight(e, r = 0, n = !1, i) {
    let o = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let s = [], a = Math.max(r, i.from), l = -1;
      for (i.from > r && s.push(new Wn(i.from - r - 1).updateHeight(e, r)); a <= o && i.more; ) {
        let c = e.doc.lineAt(a).length;
        s.length && s.push(null);
        let h = i.heights[i.index++];
        l == -1 ? l = h : Math.abs(h - l) >= Py && (l = -2);
        let d = new Po(c, h);
        d.outdated = !1, s.push(d), a += c + 1;
      }
      a <= o && s.push(null, new Wn(o - a).updateHeight(e, a));
      let u = Ii.of(s);
      return (l < 0 || Math.abs(u.height - this.height) >= Py || Math.abs(l - this.heightMetrics(e, r).perLine) >= Py) && (Cd = !0), d1(this, u);
    } else (n || this.outdated) && (this.setHeight(e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class KJ extends Ii {
  constructor(e, r, n) {
    super(e.length + r + n.length, e.height + n.height, r | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, n, i) {
    let o = n + this.left.height;
    return e < o ? this.left.blockAt(e, r, n, i) : this.right.blockAt(e, r, o, i + this.left.length + this.break);
  }
  lineAt(e, r, n, i, o) {
    let s = i + this.left.height, a = o + this.left.length + this.break, l = r == Lr.ByHeight ? e < s : e < a, u = l ? this.left.lineAt(e, r, n, i, o) : this.right.lineAt(e, r, n, s, a);
    if (this.break || (l ? u.to < a : u.from > a))
      return u;
    let c = r == Lr.ByPosNoHeight ? Lr.ByPosNoHeight : Lr.ByPos;
    return l ? u.join(this.right.lineAt(a, c, n, s, a)) : this.left.lineAt(a, c, n, i, o).join(u);
  }
  forEachLine(e, r, n, i, o, s) {
    let a = i + this.left.height, l = o + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, r, n, i, o, s), r >= l && this.right.forEachLine(e, r, n, a, l, s);
    else {
      let u = this.lineAt(l, Lr.ByPos, n, i, o);
      e < u.from && this.left.forEachLine(e, u.from - 1, n, i, o, s), u.to >= e && u.from <= r && s(u), r > u.to && this.right.forEachLine(u.to + 1, r, n, a, l, s);
    }
  }
  replace(e, r, n) {
    let i = this.left.length + this.break;
    if (r < i)
      return this.balanced(this.left.replace(e, r, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, r - i, n));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let s = o.length;
    for (let a of n)
      o.push(a);
    if (e > 0 && l6(o, s - 1), r < this.length) {
      let a = o.length;
      this.decomposeRight(r, o), l6(o, a);
    }
    return Ii.of(o);
  }
  decomposeLeft(e, r) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (n++, e >= n && r.push(null)), e > n && this.right.decomposeLeft(e - n, r);
  }
  decomposeRight(e, r) {
    let n = this.left.length, i = n + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, r);
    e < n && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? Ii.of(this.break ? [e, null, r] : [e, r]) : (this.left = d1(this.left, e), this.right = d1(this.right, r), this.setHeight(e.height + r.height), this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, n = !1, i) {
    let { left: o, right: s } = this, a = r + o.length + this.break, l = null;
    return i && i.from <= r + o.length && i.more ? l = o = o.updateHeight(e, r, n, i) : o.updateHeight(e, r, n), i && i.from <= a + s.length && i.more ? l = s = s.updateHeight(e, a, n, i) : s.updateHeight(e, a, n), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function l6(t, e) {
  let r, n;
  t[e] == null && (r = t[e - 1]) instanceof Wn && (n = t[e + 1]) instanceof Wn && t.splice(e - 1, 3, new Wn(r.length + 1 + n.length));
}
const XJ = 5;
class l4 {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let n = Math.min(r, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Po ? i.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new Po(n - this.pos, -1)), this.writtenTo = n, r > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, n) {
    if (e < r || n.heightRelevant) {
      let i = n.widget ? n.widget.estimatedHeight : 0, o = n.widget ? n.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let s = r - e;
      n.block ? this.addBlock(new XM(s, i, n)) : (s || o || i >= XJ) && this.addLineDeco(i, o, s);
    } else r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Po(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let n = new Wn(r - e);
    return this.oracle.doc.lineAt(e).to == r && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Po)
      return e;
    let r = new Po(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, n) {
    let i = this.ensureLine();
    i.length += n, i.collapsed += n, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += r, this.writtenTo = this.pos = this.pos + n;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof Po) && !this.isCovered ? this.nodes.push(new Po(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let i of this.nodes)
      i instanceof Po && i.updateHeight(this.oracle, n), n += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, n, i) {
    let o = new l4(n, e);
    return fr.spans(r, n, i, o, 0), o.finish(n);
  }
}
function QJ(t, e, r) {
  let n = new JJ();
  return fr.compare(t, e, r, n, 0), n.changes;
}
class JJ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, n, i) {
    (e < r || n && n.heightRelevant || i && i.heightRelevant) && My(e, r, this.changes, 5);
  }
}
function YJ(t, e) {
  let r = t.getBoundingClientRect(), n = t.ownerDocument, i = n.defaultView || window, o = Math.max(0, r.left), s = Math.min(i.innerWidth, r.right), a = Math.max(0, r.top), l = Math.min(i.innerHeight, r.bottom);
  for (let u = t.parentNode; u && u != n.body; )
    if (u.nodeType == 1) {
      let c = u, h = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && h.overflow != "visible") {
        let d = c.getBoundingClientRect();
        o = Math.max(o, d.left), s = Math.min(s, d.right), a = Math.max(a, d.top), l = Math.min(u == t.parentNode ? i.innerHeight : l, d.bottom);
      }
      u = h.position == "absolute" || h.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: o - r.left,
    right: Math.max(o, s) - r.left,
    top: a - (r.top + e),
    bottom: Math.max(a, l) - (r.top + e)
  };
}
function ZJ(t) {
  let e = t.getBoundingClientRect(), r = t.ownerDocument.defaultView || window;
  return e.left < r.innerWidth && e.right > 0 && e.top < r.innerHeight && e.bottom > 0;
}
function eY(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class C2 {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.size = n, this.displaySize = i;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n], o = r[n];
      if (i.from != o.from || i.to != o.to || i.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return ft.replace({
      widget: new tY(this.displaySize * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class tY extends Lh {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class u6 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = c6, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = zr.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(o4).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new WJ(r), this.stateDeco = e.facet(eg).filter((n) => typeof n != "function"), this.heightMap = Ii.empty().applyChanges(this.stateDeco, or.empty, this.heightOracle.setDoc(e.doc), [new ys(0, 0, 0, e.doc.length)]);
    for (let n = 0; n < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); n++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ft.set(this.lineGaps.map((n) => n.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let i = n ? r.head : r.anchor;
      if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
        let { from: o, to: s } = this.lineBlockAt(i);
        e.push(new Tv(o, s));
      }
    }
    return this.viewports = e.sort((n, i) => n.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? c6 : new u4(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(gm(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(eg).filter((c) => typeof c != "function");
    let i = e.changedRanges, o = ys.extendWithRanges(i, QJ(n, this.stateDeco, e ? e.changes : Dn.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    a6(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || Cd) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = s);
    let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < l.from || r.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, r));
    let u = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (u || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(DM) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, n = window.getComputedStyle(r), i = this.heightOracle, o = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? zr.RTL : zr.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(o), a = r.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (a.width && a.height) {
      let { scaleX: S, scaleY: _ } = nM(r, a);
      (S > 5e-3 && Math.abs(this.scaleX - S) > 5e-3 || _ > 5e-3 && Math.abs(this.scaleY - _) > 5e-3) && (this.scaleX = S, this.scaleY = _, u |= 16, s = l = !0);
    }
    let h = (parseInt(n.paddingTop) || 0) * this.scaleY, d = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != d) && (this.paddingTop = h, this.paddingBottom = d, u |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 16);
    let p = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != p && (this.scrollAnchorHeight = -1, this.scrollTop = p), this.scrolledToBottom = sM(e.scrollDOM);
    let g = (this.printing ? eY : YJ)(r, this.paddingTop), v = g.top - this.pixelViewport.top, y = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (l = !0)), !this.inView && !this.scrollTarget && !ZJ(e.dom))
      return 0;
    let k = a.width;
    if ((this.contentDOMWidth != k || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 16), l) {
      let S = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(S) && (s = !0), s || i.lineWrapping && Math.abs(k - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: _, charWidth: D, textHeight: A } = e.docView.measureTextSize();
        s = _ > 0 && i.refresh(o, _, D, A, Math.max(5, k / D), S), s && (e.docView.minWidth = 0, u |= 16);
      }
      v > 0 && y > 0 ? c = Math.max(v, y) : v < 0 && y < 0 && (c = Math.min(v, y)), a6();
      for (let _ of this.viewports) {
        let D = _.from == this.viewport.from ? S : e.docView.measureVisibleLineHeights(_);
        this.heightMap = (s ? Ii.empty().applyChanges(this.stateDeco, or.empty, this.heightOracle, [new ys(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, s, new GJ(_.from, D));
      }
      Cd && (u |= 2);
    }
    let C = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return C && (u & 2 && (u |= this.updateScaler()), this.viewport = this.getViewport(c, this.scrollTarget), u |= this.updateForViewport()), (u & 2 || C) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new Tv(i.lineAt(s - n * 1e3, Lr.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - n) * 1e3, Lr.ByHeight, o, 0, 0).to);
    if (r) {
      let { head: u } = r.range;
      if (u < l.from || u > l.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(u, Lr.ByPos, o, 0, 0), d;
        r.y == "center" ? d = (h.top + h.bottom) / 2 - c / 2 : r.y == "start" || r.y == "nearest" && u < l.from ? d = h.top : d = h.bottom - c, l = new Tv(i.lineAt(d - 1e3 / 2, Lr.ByHeight, o, 0, 0).from, i.lineAt(d + c + 1e3 / 2, Lr.ByHeight, o, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, r) {
    let n = r.mapPos(e.from, -1), i = r.mapPos(e.to, 1);
    return new Tv(this.heightMap.lineAt(n, Lr.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Lr.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, n = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Lr.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(r, Lr.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (e == 0 || i <= s - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || o >= a + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let n = [];
    for (let i of e)
      r.touchesRange(i.from, i.to) || n.push(new C2(r.mapPos(i.from), r.mapPos(i.to), i.size, i.displaySize));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let n = this.heightOracle.lineWrapping, i = n ? 1e4 : 2e3, o = i >> 1, s = i << 1;
    if (this.defaultTextDirection != zr.LTR && !n)
      return [];
    let a = [], l = (c, h, d, p) => {
      if (h - c < o)
        return;
      let g = this.state.selection.main, v = [g.from];
      g.empty || v.push(g.to);
      for (let b of v)
        if (b > c && b < h) {
          l(c, b - 10, d, p), l(b + 10, h, d, p);
          return;
        }
      let y = nY(e, (b) => b.from >= d.from && b.to <= d.to && Math.abs(b.from - c) < o && Math.abs(b.to - h) < o && !v.some((k) => b.from < k && b.to > k));
      if (!y) {
        if (h < d.to && r && n && r.visibleRanges.some((C) => C.from <= h && C.to >= h)) {
          let C = r.moveToLineBoundary(de.cursor(h), !1, !0).head;
          C > c && (h = C);
        }
        let b = this.gapSize(d, c, h, p), k = n || b < 2e6 ? b : 2e6;
        y = new C2(c, h, b, k);
      }
      a.push(y);
    }, u = (c) => {
      if (c.length < s || c.type != $i.Text)
        return;
      let h = rY(c.from, c.to, this.stateDeco);
      if (h.total < s)
        return;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, p, g;
      if (n) {
        let v = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, y, b;
        if (d != null) {
          let k = Pv(h, d), C = ((this.visibleBottom - this.visibleTop) / 2 + v) / c.height;
          y = k - C, b = k + C;
        } else
          y = (this.visibleTop - c.top - v) / c.height, b = (this.visibleBottom - c.top + v) / c.height;
        p = Mv(h, y), g = Mv(h, b);
      } else {
        let v = h.total * this.heightOracle.charWidth, y = i * this.heightOracle.charWidth, b = 0;
        if (v > 2e6)
          for (let D of e)
            D.from >= c.from && D.from < c.to && D.size != D.displaySize && D.from * this.heightOracle.charWidth + b < this.pixelViewport.left && (b = D.size - D.displaySize);
        let k = this.pixelViewport.left + b, C = this.pixelViewport.right + b, S, _;
        if (d != null) {
          let D = Pv(h, d), A = ((C - k) / 2 + y) / v;
          S = D - A, _ = D + A;
        } else
          S = (k - y) / v, _ = (C + y) / v;
        p = Mv(h, S), g = Mv(h, _);
      }
      p > c.from && l(c.from, p, c, h), g < c.to && l(g, c.to, c, h);
    };
    for (let c of this.viewportLines)
      Array.isArray(c.type) ? c.type.forEach(u) : u(c);
    return a;
  }
  gapSize(e, r, n, i) {
    let o = Pv(i, n) - Pv(i, r);
    return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    C2.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = ft.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let r = this.stateDeco;
    this.lineGaps.length && (r = r.concat(this.lineGapDeco));
    let n = [];
    fr.spans(r, this.viewport.from, this.viewport.to, {
      span(o, s) {
        n.push({ from: o, to: s });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (n.length != this.visibleRanges.length)
      i = 12;
    else
      for (let o = 0; o < n.length && !(i & 8); o++) {
        let s = this.visibleRanges[o], a = n[o];
        (s.from != a.from || s.to != a.to) && (i |= 4, e && e.mapPos(s.from, -1) == a.from && e.mapPos(s.to, 1) == a.to || (i |= 8));
      }
    return this.visibleRanges = n, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || gm(this.heightMap.lineAt(e, Lr.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((r) => r.top <= e && r.bottom >= e) || gm(this.heightMap.lineAt(this.scaler.fromDOM(e), Lr.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return gm(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Tv {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function rY(t, e, r) {
  let n = [], i = t, o = 0;
  return fr.spans(r, t, e, {
    span() {
    },
    point(s, a) {
      s > i && (n.push({ from: i, to: s }), o += s - i), i = a;
    }
  }, 20), i < e && (n.push({ from: i, to: e }), o += e - i), { total: o, ranges: n };
}
function Mv({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: o, to: s } = e[i], a = s - o;
    if (n <= a)
      return o + n;
    n -= a;
  }
}
function Pv(t, e) {
  let r = 0;
  for (let { from: n, to: i } of t.ranges) {
    if (e <= i) {
      r += e - n;
      break;
    }
    r += i - n;
  }
  return r / t.total;
}
function nY(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const c6 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class u4 {
  constructor(e, r, n) {
    let i = 0, o = 0, s = 0;
    this.viewports = n.map(({ from: a, to: l }) => {
      let u = r.lineAt(a, Lr.ByPos, e, 0, 0).top, c = r.lineAt(l, Lr.ByPos, e, 0, 0).bottom;
      return i += c - u, { from: a, to: l, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (r.height - i);
    for (let a of this.viewports)
      a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
  }
  toDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let o = r < this.viewports.length ? this.viewports[r] : null;
      if (!o || e < o.top)
        return i + (e - n) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      n = o.bottom, i = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let o = r < this.viewports.length ? this.viewports[r] : null;
      if (!o || e < o.domTop)
        return n + (e - i) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      n = o.bottom, i = o.domBottom;
    }
  }
  eq(e) {
    return e instanceof u4 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((r, n) => r.from == e.viewports[n].from && r.to == e.viewports[n].to) : !1;
  }
}
function gm(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), n = e.toDOM(t.bottom);
  return new Da(t.from, t.length, r, n - r, Array.isArray(t._content) ? t._content.map((i) => gm(i, e)) : t._content);
}
const Rv = /* @__PURE__ */ Be.define({ combine: (t) => t.join(" ") }), W3 = /* @__PURE__ */ Be.define({ combine: (t) => t.indexOf(!0) > -1 }), G3 = /* @__PURE__ */ ic.newName(), QM = /* @__PURE__ */ ic.newName(), JM = /* @__PURE__ */ ic.newName(), YM = { "&light": "." + QM, "&dark": "." + JM };
function K3(t, e, r) {
  return new ic(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!r || !r[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return r[i];
      }) : t + " " + n;
    }
  });
}
const iY = /* @__PURE__ */ K3("." + G3, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, YM), oY = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, _2 = $e.ie && $e.ie_version <= 11;
class sY {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new qQ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let n of r)
        this.queue.push(n);
      ($e.ie && $e.ie_version <= 11 || $e.ios && e.composing) && r.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && $e.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !($e.chrome && $e.chrome_version < 126) && (this.editContext = new lY(e), e.state.facet(Nl) && (e.contentDOM.editContext = this.editContext.editContext)), _2 && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, n) => r != e[n]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, i = this.selectionRange;
    if (n.state.facet(Nl) ? n.root.activeElement != this.dom : !Ty(this.dom, i))
      return;
    let o = i.anchorNode && n.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    ($e.ie && $e.ie_version <= 11 || $e.android && $e.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Om(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = Ym(e.root);
    if (!r)
      return !1;
    let n = $e.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && aY(this.view, r) || r;
    if (!n || this.selectionRange.eq(n))
      return !1;
    let i = Ty(this.dom, n);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && HQ(this.dom, n) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(n), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = r)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, oY), _2 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), _2 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var n;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Vf(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, n = -1, i = !1;
    for (let o of e) {
      let s = this.readMutation(o);
      s && (s.typeOver && (i = !0), r == -1 ? { from: r, to: n } = s : (r = Math.min(s.from, r), n = Math.max(s.to, n)));
    }
    return { from: r, to: n, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: n } = this.processRecords(), i = this.selectionChanged && Ty(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new SJ(this.view, e, r, n);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let n = this.view.state, i = LM(this.view, r);
    return this.view.state == n && (r.domChanged || r.newSel && !r.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let n = h6(r, e.previousSibling || e.target.previousSibling, -1), i = h6(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? r.posAfter(n) : r.posAtStart,
        to: i ? r.posBefore(i) : r.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Nl) != e.state.facet(Nl) && (e.view.contentDOM.editContext = e.state.facet(Nl) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, r, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function h6(t, e, r) {
  for (; e; ) {
    let n = _r.get(e);
    if (n && n.parent == t)
      return n;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function f6(t, e) {
  let r = e.startContainer, n = e.startOffset, i = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor);
  return Om(s.node, s.offset, i, o) && ([r, n, i, o] = [i, o, r, n]), { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: o };
}
function aY(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return f6(t, i);
  }
  let r = null;
  function n(i) {
    i.preventDefault(), i.stopImmediatePropagation(), r = i.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", n, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", n, !0), r ? f6(t, r) : null;
}
class lY {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let r = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (n) => {
      let i = e.state.selection.main, { anchor: o, head: s } = i, a = this.toEditorPos(n.updateRangeStart), l = this.toEditorPos(n.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: n.updateRangeStart, editorBase: a, drifted: !1 });
      let u = l - a > n.text.length;
      a == this.from && o < this.from ? a = o : l == this.to && o > this.to && (l = o);
      let c = zM(e.state.sliceDoc(a, l), n.text, (u ? i.from : i.to) - a, u ? "end" : null);
      if (!c) {
        let d = de.single(this.toEditorPos(n.selectionStart), this.toEditorPos(n.selectionEnd));
        d.main.eq(i) || e.dispatch({ selection: d, userEvent: "select" });
        return;
      }
      let h = {
        from: c.from + a,
        to: c.toA + a,
        insert: or.of(n.text.slice(c.from, c.toB).split(`
`))
      };
      if (($e.mac || $e.android) && h.from == s - 1 && /^\. ?$/.test(n.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (h = { from: a, to: l, insert: or.of([n.text.replace(".", " ")]) }), this.pendingContextChange = h, !e.state.readOnly) {
        let d = this.to - this.from + (h.to - h.from + h.insert.length);
        a4(e, h, de.single(this.toEditorPos(n.selectionStart, d), this.toEditorPos(n.selectionEnd, d)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), h.from < h.to && !h.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(r.text.slice(Math.max(0, n.updateRangeStart - 1), Math.min(r.text.length, n.updateRangeStart + 1))) && this.handlers.compositionend(n);
    }, this.handlers.characterboundsupdate = (n) => {
      let i = [], o = null;
      for (let s = this.toEditorPos(n.rangeStart), a = this.toEditorPos(n.rangeEnd); s < a; s++) {
        let l = e.coordsForChar(s);
        o = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || o || new DOMRect(), i.push(o);
      }
      r.updateCharacterBounds(n.rangeStart, i);
    }, this.handlers.textformatupdate = (n) => {
      let i = [];
      for (let o of n.getTextFormats()) {
        let s = o.underlineStyle, a = o.underlineThickness;
        if (!/none/i.test(s) && !/none/i.test(a)) {
          let l = this.toEditorPos(o.rangeStart), u = this.toEditorPos(o.rangeEnd);
          if (l < u) {
            let c = `text-decoration: underline ${/^[a-z]/.test(s) ? s + " " : s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${/thin/i.test(a) ? 1 : 2}px`;
            i.push(ft.mark({ attributes: { style: c } }).range(l, u));
          }
        }
      }
      e.dispatch({ effects: FM.of(ft.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: n } = this.composing;
        this.composing = null, n && this.reset(e.state);
      }
    };
    for (let n in this.handlers)
      r.addEventListener(n, this.handlers[n]);
    this.measureReq = { read: (n) => {
      this.editContext.updateControlBounds(n.contentDOM.getBoundingClientRect());
      let i = Ym(n.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let r = 0, n = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((o, s, a, l, u) => {
      if (n)
        return;
      let c = u.length - (s - o);
      if (i && s >= i.to)
        if (i.from == o && i.to == s && i.insert.eq(u)) {
          i = this.pendingContextChange = null, r += c, this.to += c;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (o += r, s += r, s <= this.from)
        this.from += c, this.to += c;
      else if (o < this.to) {
        if (o < this.from || s > this.to || this.to - this.from + u.length > 3e4) {
          n = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), u.toString()), this.to += c;
      }
      r += c;
    }), i && !n && this.revertPending(e.state), !n;
  }
  update(e) {
    let r = this.pendingContextChange, n = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(n.from, n.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || r) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: r } = e.selection.main;
    this.from = Math.max(
      0,
      r - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      r + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let r = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(r.from), this.toContextPos(r.from + r.insert.length), e.doc.sliceString(r.from, r.to));
  }
  setSelection(e) {
    let { main: r } = e.selection, n = this.toContextPos(Math.max(this.from, Math.min(this.to, r.anchor))), i = this.toContextPos(r.head);
    (this.editContext.selectionStart != n || this.editContext.selectionEnd != i) && this.editContext.updateSelection(n, i);
  }
  rangeIsValid(e) {
    let { head: r } = e.selection.main;
    return !(this.from > 0 && r - this.from < 500 || this.to < e.doc.length && this.to - r < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, r = this.to - this.from) {
    e = Math.min(e, r);
    let n = this.composing;
    return n && n.drifted ? n.editorBase + (e - n.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let r = this.composing;
    return r && r.drifted ? r.contextBase + (e - r.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class Ie {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var r;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    this.dispatchTransactions = e.dispatchTransactions || n && ((i) => i.forEach((o) => n(o, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || UQ(e.parent) || document, this.viewState = new u6(e.state || ir.create(e)), e.scrollTo && e.scrollTo.is(Dv) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Tf).map((i) => new x2(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new sY(this), this.inputState = new OJ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new HD(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((r = document.fonts) === null || r === void 0) && r.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof xn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, n = !1, i, o = this.state;
    for (let d of e) {
      if (d.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let s = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(WM)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = GM(o, s), l || (a = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (c = null)) : this.observer.clear(), o.facet(ir.phrases) != this.state.facet(ir.phrases))
      return this.setState(o);
    i = f1.create(this, o, e), i.flags |= a;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (h && (h = h.map(d.changes)), d.scrollIntoView) {
          let { main: p } = d.state.selection;
          h = new Wf(p.empty ? p : de.cursor(p.head, p.head > p.anchor ? -1 : 1));
        }
        for (let p of d.effects)
          p.is(Dv) && (h = p.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = p1.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), r = this.docView.update(i), this.state.facet(pm) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(Rv) != i.state.facet(Rv) && (this.viewState.mustMeasureContent = !0), (r || n || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), r && this.docViewUpdate(), !i.empty)
      for (let d of this.state.facet(q3))
        try {
          d(i);
        } catch (p) {
          Ri(this.state, p, "update listener");
        }
    (l || c) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), c && !LM(this, c) && u.force && Vf(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new u6(e), this.plugins = e.facet(Tf).map((n) => new x2(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView.destroy(), this.docView = new HD(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(Tf), n = e.state.facet(Tf);
    if (r != n) {
      let i = [];
      for (let o of n) {
        let s = r.indexOf(o);
        if (s < 0)
          i.push(new x2(o));
        else {
          let a = this.plugins[s];
          a.mustUpdate = e, i.push(a);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    r != n && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let r = e.value;
      if (r && r.docViewUpdate)
        try {
          r.docViewUpdate(this);
        } catch (n) {
          Ri(this.state, n, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, n = this.scrollDOM, i = n.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (s < 0)
          if (sM(n))
            o = -1, s = this.viewState.heightMap.height;
          else {
            let p = this.viewState.scrollAnchorAt(i);
            o = p.from, s = p.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        l & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((p) => {
          try {
            return p.read(this);
          } catch (g) {
            return Ri(this.state, g), d6;
          }
        }), h = f1.create(this, this.state, []), d = !1;
        h.flags |= l, r ? r.flags |= l : r = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), d = this.docView.update(h), d && this.docViewUpdate());
        for (let p = 0; p < u.length; p++)
          if (c[p] != d6)
            try {
              let g = u[p];
              g.write && g.write(c[p], this);
            } catch (g) {
              Ri(this.state, g);
            }
        if (d && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
              if (p > 1 || p < -1) {
                i = i + p, n.scrollTop = i / this.scaleY, s = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let a of this.state.facet(q3))
        a(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return G3 + " " + (this.state.facet(W3) ? JM : QM) + " " + this.state.facet(Rv);
  }
  updateAttrs() {
    let e = p6(this, TM, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Nl) ? "true" : "false",
      class: "cm-content",
      style: `${$e.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), p6(this, o4, r);
    let n = this.observer.ignore(() => {
      let i = I3(this.contentDOM, this.contentAttrs, r), o = I3(this.dom, this.editorAttrs, e);
      return i || o;
    });
    return this.editorAttrs = e, this.contentAttrs = r, n;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let n of e)
      for (let i of n.effects)
        if (i.is(Ie.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(pm);
    let e = this.state.facet(Ie.cspNonce);
    ic.mount(this.root, this.styleModules.concat(iY).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.plugin != e) && this.pluginMap.set(e, r = this.plugins.find((n) => n.plugin == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, n) {
    return k2(this, e, XD(this, e, r, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return k2(this, e, XD(this, e, r, (n) => xJ(this, e.head, n)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let n = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = n[r ? n.length - 1 : 0];
    return de.cursor(o.side(r, i) + e.from, o.forward(!r, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, n = !0) {
    return bJ(this, e, r, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, n) {
    return k2(this, e, wJ(this, e, r, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), $M(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, r);
    if (!n || n.left == n.right)
      return n;
    let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), s = o[Nu.find(o, e - i.from, -1, r)];
    return $b(n, s.dir == zr.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(EM) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > uY)
      return bM(e.length);
    let r = this.textDirectionAt(e.from), n;
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == r && (o.fresh || yM(o.isolates, n = UD(this, e))))
        return o.order;
    n || (n = UD(this, e));
    let i = nJ(e.text, r, n);
    return this.bidiCache.push(new p1(e.from, e.to, r, n, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || $e.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      iM(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return Dv.of(new Wf(typeof e == "number" ? de.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
    return Dv.of(new Wf(de.cursor(n.from), "start", "start", n.top - e, r, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return kn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return kn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let n = ic.newName(), i = [Rv.of(n), pm.of(K3(`.${n}`, e))];
    return r && r.dark && i.push(W3.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return mc.lowest(pm.of(K3("." + G3, e, YM)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let n = e.querySelector(".cm-content");
    return ((r = (n && _r.get(n) || _r.get(e))?.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
Ie.styleModule = pm;
Ie.inputHandler = SM;
Ie.clipboardInputFilter = n4;
Ie.clipboardOutputFilter = i4;
Ie.scrollHandler = OM;
Ie.focusChangeEffect = AM;
Ie.perLineTextDirection = EM;
Ie.exceptionSink = _M;
Ie.updateListener = q3;
Ie.editable = Nl;
Ie.mouseSelectionStyle = CM;
Ie.dragMovesSelection = kM;
Ie.clickAddsSelectionRange = wM;
Ie.decorations = eg;
Ie.outerDecorations = MM;
Ie.atomicRanges = Zg;
Ie.bidiIsolatedRanges = PM;
Ie.scrollMargins = RM;
Ie.darkTheme = W3;
Ie.cspNonce = /* @__PURE__ */ Be.define({ combine: (t) => t.length ? t[0] : "" });
Ie.contentAttributes = o4;
Ie.editorAttributes = TM;
Ie.lineWrapping = /* @__PURE__ */ Ie.contentAttributes.of({ class: "cm-lineWrapping" });
Ie.announce = /* @__PURE__ */ kt.define();
const uY = 4096, d6 = {};
class p1 {
  constructor(e, r, n, i, o, s) {
    this.from = e, this.to = r, this.dir = n, this.isolates = i, this.fresh = o, this.order = s;
  }
  static update(e, r) {
    if (r.empty && !e.some((o) => o.fresh))
      return e;
    let n = [], i = e.length ? e[e.length - 1].dir : zr.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let s = e[o];
      s.dir == i && !r.touchesRange(s.from, s.to) && n.push(new p1(r.mapPos(s.from, 1), r.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order));
    }
    return n;
  }
}
function p6(t, e, r) {
  for (let n = t.state.facet(e), i = n.length - 1; i >= 0; i--) {
    let o = n[i], s = typeof o == "function" ? o(t) : o;
    s && $3(s, r);
  }
  return r;
}
const cY = $e.mac ? "mac" : $e.windows ? "win" : $e.linux ? "linux" : "key";
function hY(t, e) {
  const r = t.split(/-(?!$)/);
  let n = r[r.length - 1];
  n == "Space" && (n = " ");
  let i, o, s, a;
  for (let l = 0; l < r.length - 1; ++l) {
    const u = r[l];
    if (/^(cmd|meta|m)$/i.test(u))
      a = !0;
    else if (/^a(lt)?$/i.test(u))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      o = !0;
    else if (/^s(hift)?$/i.test(u))
      s = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? a = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return i && (n = "Alt-" + n), o && (n = "Ctrl-" + n), a && (n = "Meta-" + n), s && (n = "Shift-" + n), n;
}
function Nv(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const fY = /* @__PURE__ */ mc.default(/* @__PURE__ */ Ie.domEventHandlers({
  keydown(t, e) {
    return eP(ZM(e.state), t, e, "editor");
  }
})), Bb = /* @__PURE__ */ Be.define({ enables: fY }), m6 = /* @__PURE__ */ new WeakMap();
function ZM(t) {
  let e = t.facet(Bb), r = m6.get(e);
  return r || m6.set(e, r = mY(e.reduce((n, i) => n.concat(i), []))), r;
}
function dY(t, e, r) {
  return eP(ZM(t.state), e, t, r);
}
let Fu = null;
const pY = 4e3;
function mY(t, e = cY) {
  let r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = (s, a) => {
    let l = n[s];
    if (l == null)
      n[s] = a;
    else if (l != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (s, a, l, u, c) => {
    var h, d;
    let p = r[s] || (r[s] = /* @__PURE__ */ Object.create(null)), g = a.split(/ (?!$)/).map((b) => hY(b, e));
    for (let b = 1; b < g.length; b++) {
      let k = g.slice(0, b).join(" ");
      i(k, !0), p[k] || (p[k] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(C) => {
          let S = Fu = { view: C, prefix: k, scope: s };
          return setTimeout(() => {
            Fu == S && (Fu = null);
          }, pY), !0;
        }]
      });
    }
    let v = g.join(" ");
    i(v, !1);
    let y = p[v] || (p[v] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (h = p._any) === null || h === void 0 ? void 0 : h.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && y.run.push(l), u && (y.preventDefault = !0), c && (y.stopPropagation = !0);
  };
  for (let s of t) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let u of a) {
        let c = r[u] || (r[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = s;
        for (let d in c)
          c[d].run.push((p) => h(p, X3));
      }
    let l = s[e] || s.key;
    if (l)
      for (let u of a)
        o(u, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(u, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
  }
  return r;
}
let X3 = null;
function eP(t, e, r, n) {
  X3 = e;
  let i = IQ(e), o = Yi(i, 0), s = Ea(o) == i.length && i != " ", a = "", l = !1, u = !1, c = !1;
  Fu && Fu.view == r && Fu.scope == n && (a = Fu.prefix + " ", qM.indexOf(e.keyCode) < 0 && (u = !0, Fu = null));
  let h = /* @__PURE__ */ new Set(), d = (y) => {
    if (y) {
      for (let b of y.run)
        if (!h.has(b) && (h.add(b), b(r)))
          return y.stopPropagation && (c = !0), !0;
      y.preventDefault && (y.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, p = t[n], g, v;
  return p && (d(p[a + Nv(i, e, !s)]) ? l = !0 : s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !($e.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !($e.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (g = oc[e.keyCode]) && g != i ? (d(p[a + Nv(g, e, !0)]) || e.shiftKey && (v = Jm[e.keyCode]) != i && v != g && d(p[a + Nv(v, e, !1)])) && (l = !0) : s && e.shiftKey && d(p[a + Nv(i, e, !0)]) && (l = !0), !l && d(p._any) && (l = !0)), u && (l = !0), l && c && e.stopPropagation(), X3 = null, l;
}
class e0 {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, n, i, o) {
    this.className = e, this.left = r, this.top = n, this.width = i, this.height = o;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, n) {
    if (n.empty) {
      let i = e.coordsAtPos(n.head, n.assoc || 1);
      if (!i)
        return [];
      let o = tP(e);
      return [new e0(r, i.left - o.left, i.top - o.top, null, i.bottom - i.top)];
    } else
      return gY(e, r, n);
  }
}
function tP(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == zr.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function g6(t, e, r, n) {
  let i = t.coordsAtPos(e, r * 2);
  if (!i)
    return n;
  let o = t.dom.getBoundingClientRect(), s = (i.top + i.bottom) / 2, a = t.posAtCoords({ x: o.left + 1, y: s }), l = t.posAtCoords({ x: o.right - 1, y: s });
  return a == null || l == null ? n : { from: Math.max(n.from, Math.min(a, l)), to: Math.min(n.to, Math.max(a, l)) };
}
function gY(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let n = Math.max(r.from, t.viewport.from), i = Math.min(r.to, t.viewport.to), o = t.textDirection == zr.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), l = tP(t), u = s.querySelector(".cm-line"), c = u && window.getComputedStyle(u), h = a.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), d = a.right - (c ? parseInt(c.paddingRight) : 0), p = H3(t, n, 1), g = H3(t, i, -1), v = p.type == $i.Text ? p : null, y = g.type == $i.Text ? g : null;
  if (v && (t.lineWrapping || p.widgetLineBreaks) && (v = g6(t, n, 1, v)), y && (t.lineWrapping || g.widgetLineBreaks) && (y = g6(t, i, -1, y)), v && y && v.from == y.from && v.to == y.to)
    return k(C(r.from, r.to, v));
  {
    let _ = v ? C(r.from, null, v) : S(p, !1), D = y ? C(null, r.to, y) : S(g, !0), A = [];
    return (v || p).to < (y || g).from - (v && y ? 1 : 0) || p.widgetLineBreaks > 1 && _.bottom + t.defaultLineHeight / 2 < D.top ? A.push(b(h, _.bottom, d, D.top)) : _.bottom < D.top && t.elementAtHeight((_.bottom + D.top) / 2).type == $i.Text && (_.bottom = D.top = (_.bottom + D.top) / 2), k(_).concat(A).concat(k(D));
  }
  function b(_, D, A, O) {
    return new e0(e, _ - l.left, D - l.top, A - _, O - D);
  }
  function k({ top: _, bottom: D, horizontal: A }) {
    let O = [];
    for (let M = 0; M < A.length; M += 2)
      O.push(b(A[M], _, A[M + 1], D));
    return O;
  }
  function C(_, D, A) {
    let O = 1e9, M = -1e9, z = [];
    function N(B, $, j, U, H) {
      let G = t.coordsAtPos(B, B == A.to ? -2 : 2), re = t.coordsAtPos(j, j == A.from ? 2 : -2);
      !G || !re || (O = Math.min(G.top, re.top, O), M = Math.max(G.bottom, re.bottom, M), H == zr.LTR ? z.push(o && $ ? h : G.left, o && U ? d : re.right) : z.push(!o && U ? h : re.left, !o && $ ? d : G.right));
    }
    let P = _ ?? A.from, I = D ?? A.to;
    for (let B of t.visibleRanges)
      if (B.to > P && B.from < I)
        for (let $ = Math.max(B.from, P), j = Math.min(B.to, I); ; ) {
          let U = t.state.doc.lineAt($);
          for (let H of t.bidiSpans(U)) {
            let G = H.from + U.from, re = H.to + U.from;
            if (G >= j)
              break;
            re > $ && N(Math.max(G, $), _ == null && G <= P, Math.min(re, j), D == null && re >= I, H.dir);
          }
          if ($ = U.to + 1, $ >= j)
            break;
        }
    return z.length == 0 && N(P, _ == null, I, D == null, t.textDirection), { top: O, bottom: M, horizontal: z };
  }
  function S(_, D) {
    let A = a.top + (D ? _.top : _.bottom);
    return { top: A, bottom: A, horizontal: [] };
  }
}
function vY(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class yY {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Ry) != e.state.facet(Ry) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let r = 0, n = e.facet(Ry);
    for (; r < n.length && n[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, n) => !vY(r, this.drawn[n]))) {
      let r = this.dom.firstChild, n = 0;
      for (let i of e)
        i.update && r && i.constructor && this.drawn[n].constructor && i.update(r, this.drawn[n]) ? (r = r.nextSibling, n++) : this.dom.insertBefore(i.draw(), r);
      for (; r; ) {
        let i = r.nextSibling;
        r.remove(), r = i;
      }
      this.drawn = e, $e.safari && $e.safari_version >= 26 && (this.dom.style.display = this.dom.firstChild ? "" : "none");
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Ry = /* @__PURE__ */ Be.define();
function rP(t) {
  return [
    kn.define((e) => new yY(e, t)),
    Ry.of(t)
  ];
}
const tg = /* @__PURE__ */ Be.define({
  combine(t) {
    return ou(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function bY(t = {}) {
  return [
    tg.of(t),
    xY,
    wY,
    kY,
    DM.of(!0)
  ];
}
function nP(t) {
  return t.startState.facet(tg) != t.state.facet(tg);
}
const xY = /* @__PURE__ */ rP({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(tg), n = [];
    for (let i of e.selection.ranges) {
      let o = i == e.selection.main;
      if (i.empty || r.drawRangeCursor) {
        let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : de.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of e0.forRange(t, s, a))
          n.push(l);
      }
    }
    return n;
  },
  update(t, e) {
    t.transactions.some((n) => n.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = nP(t);
    return r && v6(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    v6(e.state, t);
  },
  class: "cm-cursorLayer"
});
function v6(t, e) {
  e.style.animationDuration = t.facet(tg).cursorBlinkRate + "ms";
}
const wY = /* @__PURE__ */ rP({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : e0.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || nP(t);
  },
  class: "cm-selectionLayer"
}), kY = /* @__PURE__ */ mc.highest(/* @__PURE__ */ Ie.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), iP = /* @__PURE__ */ kt.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), vm = /* @__PURE__ */ qn.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, n) => n.is(iP) ? n.value : r, t);
  }
}), CY = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(vm);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(vm) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(vm), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let n = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - n.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - n.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(vm) != t && this.view.dispatch({ effects: iP.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function _Y() {
  return [vm, CY];
}
function y6(t, e, r, n, i) {
  e.lastIndex = 0;
  for (let o = t.iterRange(r, n), s = r, a; !o.next().done; s += o.value.length)
    if (!o.lineBreak)
      for (; a = e.exec(o.value); )
        i(s + a.index, a);
}
function SY(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let n = [];
  for (let { from: i, to: o } of r)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), n.length && n[n.length - 1].to >= i ? n[n.length - 1].to = o : n.push({ from: i, to: o });
  return n;
}
class AY {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: n, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, i)
      this.addMatch = (a, l, u, c) => i(c, u, u + a[0].length, a, l);
    else if (typeof n == "function")
      this.addMatch = (a, l, u, c) => {
        let h = n(a, l, u);
        h && c(u, u + a[0].length, h);
      };
    else if (n)
      this.addMatch = (a, l, u, c) => c(u, u + a[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new nc(), n = r.add.bind(r);
    for (let { from: i, to: o } of SY(e, this.maxLength))
      y6(e.state.doc, this.regexp, i, o, (s, a) => this.addMatch(a, e, s, n));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let n = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((o, s, a, l) => {
      l >= e.view.viewport.from && a <= e.view.viewport.to && (n = Math.min(a, n), i = Math.max(l, i));
    }), e.viewportMoved || i - n > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, r.map(e.changes), n, i) : r;
  }
  updateRange(e, r, n, i) {
    for (let o of e.visibleRanges) {
      let s = Math.max(o.from, n), a = Math.min(o.to, i);
      if (a >= s) {
        let l = e.state.doc.lineAt(s), u = l.to < a ? e.state.doc.lineAt(a) : l, c = Math.max(o.from, l.from), h = Math.min(o.to, u.to);
        if (this.boundary) {
          for (; s > l.from; s--)
            if (this.boundary.test(l.text[s - 1 - l.from])) {
              c = s;
              break;
            }
          for (; a < u.to; a++)
            if (this.boundary.test(u.text[a - u.from])) {
              h = a;
              break;
            }
        }
        let d = [], p, g = (v, y, b) => d.push(b.range(v, y));
        if (l == u)
          for (this.regexp.lastIndex = c - l.from; (p = this.regexp.exec(l.text)) && p.index < h - l.from; )
            this.addMatch(p, e, p.index + l.from, g);
        else
          y6(e.state.doc, this.regexp, c, h, (v, y) => this.addMatch(y, e, v, g));
        r = r.update({ filterFrom: c, filterTo: h, filter: (v, y) => v < c || y > h, add: d });
      }
    }
    return r;
  }
}
const Q3 = /x/.unicode != null ? "gu" : "g", EY = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, Q3), DY = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let S2 = null;
function OY() {
  var t;
  if (S2 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    S2 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return S2 || !1;
}
const Ny = /* @__PURE__ */ Be.define({
  combine(t) {
    let e = ou(t, {
      render: null,
      specialChars: EY,
      addSpecialChars: null
    });
    return (e.replaceTabs = !OY()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Q3)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Q3)), e;
  }
});
function FY(t = {}) {
  return [Ny.of(t), TY()];
}
let b6 = null;
function TY() {
  return b6 || (b6 = kn.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = ft.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Ny)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new AY({
        regexp: t.specialChars,
        decoration: (e, r, n) => {
          let { doc: i } = r.state, o = Yi(e[0], 0);
          if (o == 9) {
            let s = i.lineAt(n), a = r.state.tabSize, l = Jd(s.text, a, n - s.from);
            return ft.replace({
              widget: new NY((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = ft.replace({ widget: new RY(t, o) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Ny);
      t.startState.facet(Ny) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const MY = "â€¢";
function PY(t) {
  return t >= 32 ? MY : t == 10 ? "â¤" : String.fromCharCode(9216 + t);
}
class RY extends Lh {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = PY(this.code), n = e.state.phrase("Control character") + " " + (DY[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, n, r);
    if (i)
      return i;
    let o = document.createElement("span");
    return o.textContent = r, o.title = n, o.setAttribute("aria-label", n), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class NY extends Lh {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function $Y() {
  return BY;
}
const IY = /* @__PURE__ */ ft.line({ class: "cm-activeLine" }), BY = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let n of t.state.selection.ranges) {
      let i = t.lineBlockAt(n.head);
      i.from > e && (r.push(IY.range(i.from)), e = i.from);
    }
    return ft.set(r);
  }
}, {
  decorations: (t) => t.decorations
}), J3 = 2e3;
function LY(t, e, r) {
  let n = Math.min(e.line, r.line), i = Math.max(e.line, r.line), o = [];
  if (e.off > J3 || r.off > J3 || e.col < 0 || r.col < 0) {
    let s = Math.min(e.off, r.off), a = Math.max(e.off, r.off);
    for (let l = n; l <= i; l++) {
      let u = t.doc.line(l);
      u.length <= a && o.push(de.range(u.from + s, u.to + a));
    }
  } else {
    let s = Math.min(e.col, r.col), a = Math.max(e.col, r.col);
    for (let l = n; l <= i; l++) {
      let u = t.doc.line(l), c = D3(u.text, s, t.tabSize, !0);
      if (c < 0)
        o.push(de.cursor(u.to));
      else {
        let h = D3(u.text, a, t.tabSize);
        o.push(de.range(u.from + c, u.from + h));
      }
    }
  }
  return o;
}
function zY(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function x6(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = t.state.doc.lineAt(r), i = r - n.from, o = i > J3 ? -1 : i == n.length ? zY(t, e.clientX) : Jd(n.text, t.state.tabSize, r - n.from);
  return { line: n.number, col: o, off: i };
}
function jY(t, e) {
  let r = x6(t, e), n = t.state.selection;
  return r ? {
    update(i) {
      if (i.docChanged) {
        let o = i.changes.mapPos(i.startState.doc.line(r.line).from), s = i.state.doc.lineAt(o);
        r = { line: s.number, col: r.col, off: Math.min(r.off, s.length) }, n = n.map(i.changes);
      }
    },
    get(i, o, s) {
      let a = x6(t, i);
      if (!a)
        return n;
      let l = LY(t.state, r, a);
      return l.length ? s ? de.create(l.concat(n.ranges)) : de.create(l) : n;
    }
  } : null;
}
function qY(t) {
  let e = ((r) => r.altKey && r.button == 0);
  return Ie.mouseSelectionStyle.of((r, n) => e(n) ? jY(r, n) : null);
}
const UY = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, HY = { style: "cursor: crosshair" };
function VY(t = {}) {
  let [e, r] = UY[t.key || "Alt"], n = kn.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || r(i));
      },
      keyup(i) {
        (i.keyCode == e || !r(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(r(i));
      }
    }
  });
  return [
    n,
    Ie.contentAttributes.of((i) => {
      var o;
      return !((o = i.plugin(n)) === null || o === void 0) && o.isDown ? HY : null;
    })
  ];
}
const Xp = "-10000px";
class oP {
  constructor(e, r, n, i) {
    this.facet = r, this.createTooltipView = n, this.removeTooltipView = i, this.input = e.state.facet(r), this.tooltips = this.input.filter((s) => s);
    let o = null;
    this.tooltipViews = this.tooltips.map((s) => o = n(s, o));
  }
  update(e, r) {
    var n;
    let i = e.state.facet(this.facet), o = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let s = [], a = r ? [] : null;
    for (let l = 0; l < o.length; l++) {
      let u = o[l], c = -1;
      if (u) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let d = this.tooltips[h];
          d && d.create == u.create && (c = h);
        }
        if (c < 0)
          s[l] = this.createTooltipView(u, l ? s[l - 1] : null), a && (a[l] = !!u.above);
        else {
          let h = s[l] = this.tooltipViews[c];
          a && (a[l] = r[c]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      s.indexOf(l) < 0 && (this.removeTooltipView(l), (n = l.destroy) === null || n === void 0 || n.call(l));
    return r && (a.forEach((l, u) => r[u] = l), r.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, !0;
  }
}
function WY(t = {}) {
  return $y.of(t);
}
function GY(t) {
  let e = t.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const $y = /* @__PURE__ */ Be.define({
  combine: (t) => {
    var e, r, n;
    return {
      position: $e.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((n = t.find((i) => i.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || GY
    };
  }
}), w6 = /* @__PURE__ */ new WeakMap(), c4 = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet($y);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new oP(t, h4, (r, n) => this.createTooltip(r, n), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, n = t.state.facet($y);
    if (n.position != this.position && !this.madeAbsolute) {
      this.position = n.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      r = !0;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      r = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), n = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", r.dom.appendChild(i);
    }
    return r.dom.style.position = this.position, r.dom.style.top = Xp, r.dom.style.left = "0px", this.container.insertBefore(r.dom, n), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = 1, e = 1, r = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: o } = this.manager.tooltipViews[0];
      if ($e.gecko)
        r = o.offsetParent != this.container.ownerDocument.body;
      else if (o.style.top == Xp && o.style.left == "0px") {
        let s = o.getBoundingClientRect();
        r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let o = this.parent.getBoundingClientRect();
        o.width && o.height && (t = o.width / this.parent.offsetWidth, e = o.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    let n = this.view.scrollDOM.getBoundingClientRect(), i = s4(this.view);
    return {
      visible: {
        left: n.left + i.left,
        top: n.top + i.top,
        right: n.right - i.right,
        bottom: n.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((o, s) => {
        let a = this.manager.tooltipViews[s];
        return a.getCoords ? a.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
      space: this.view.state.facet($y).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: r
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: r, space: n, scaleX: i, scaleY: o } = t, s = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], u = this.manager.tooltipViews[a], { dom: c } = u, h = t.pos[a], d = t.size[a];
      if (!h || l.clip !== !1 && (h.bottom <= Math.max(r.top, n.top) || h.top >= Math.min(r.bottom, n.bottom) || h.right < Math.max(r.left, n.left) - 0.1 || h.left > Math.min(r.right, n.right) + 0.1)) {
        c.style.top = Xp;
        continue;
      }
      let p = l.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, g = p ? 7 : 0, v = d.right - d.left, y = (e = w6.get(u)) !== null && e !== void 0 ? e : d.bottom - d.top, b = u.offset || XY, k = this.view.textDirection == zr.LTR, C = d.width > n.right - n.left ? k ? n.left : n.right - d.width : k ? Math.max(n.left, Math.min(h.left - (p ? 14 : 0) + b.x, n.right - v)) : Math.min(Math.max(n.left, h.left - v + (p ? 14 : 0) - b.x), n.right - v), S = this.above[a];
      !l.strictSide && (S ? h.top - y - g - b.y < n.top : h.bottom + y + g + b.y > n.bottom) && S == n.bottom - h.bottom > h.top - n.top && (S = this.above[a] = !S);
      let _ = (S ? h.top - n.top : n.bottom - h.bottom) - g;
      if (_ < y && u.resize !== !1) {
        if (_ < this.view.defaultLineHeight) {
          c.style.top = Xp;
          continue;
        }
        w6.set(u, y), c.style.height = (y = _) / o + "px";
      } else c.style.height && (c.style.height = "");
      let D = S ? h.top - y - g - b.y : h.bottom + g + b.y, A = C + v;
      if (u.overlap !== !0)
        for (let O of s)
          O.left < A && O.right > C && O.top < D + y && O.bottom > D && (D = S ? O.top - y - 2 - g : O.bottom + g + 2);
      if (this.position == "absolute" ? (c.style.top = (D - t.parent.top) / o + "px", k6(c, (C - t.parent.left) / i)) : (c.style.top = D / o + "px", k6(c, C / i)), p) {
        let O = h.left + (k ? b.x : -b.x) - (C + 14 - 7);
        p.style.left = O / i + "px";
      }
      u.overlap !== !0 && s.push({ left: C, top: D, right: A, bottom: D + y }), c.classList.toggle("cm-tooltip-above", S), c.classList.toggle("cm-tooltip-below", !S), u.positioned && u.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = Xp;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function k6(t, e) {
  let r = parseInt(t.style.left, 10);
  (isNaN(r) || Math.abs(e - r) > 1) && (t.style.left = e + "px");
}
const KY = /* @__PURE__ */ Ie.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), XY = { x: 0, y: 0 }, h4 = /* @__PURE__ */ Be.define({
  enables: [c4, KY]
}), m1 = /* @__PURE__ */ Be.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class Lb {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Lb(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new oP(e, m1, (r, n) => this.createHostedView(r, n), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let n = e.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(n.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let n of this.manager.tooltipViews) {
      let i = n[e];
      if (i !== void 0) {
        if (r === void 0)
          r = i;
        else if (r !== i)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const QY = /* @__PURE__ */ h4.compute([m1], (t) => {
  let e = t.facet(m1);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var n;
      return (n = r.end) !== null && n !== void 0 ? n : r.pos;
    })),
    create: Lb.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class JY {
  constructor(e, r, n, i, o) {
    this.view = e, this.source = r, this.field = n, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, n = e.docView.nearest(r.target);
    if (!n)
      return;
    let i, o = 1;
    if (n instanceof Ru)
      i = n.posAtStart;
    else {
      if (i = e.posAtCoords(r), i == null)
        return;
      let a = e.coordsAtPos(i);
      if (!a || r.y < a.top || r.y > a.bottom || r.x < a.left - e.defaultCharacterWidth || r.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(i)).find((c) => c.from <= i && c.to >= i), u = l && l.dir == zr.RTL ? -1 : 1;
      o = r.x < a.left ? -u : u;
    }
    let s = this.source(e, i, o);
    if (s?.then) {
      let a = this.pending = { pos: i };
      s.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => Ri(e.state, l, "hover tooltip"));
    } else s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let e = this.view.plugin(c4), r = e ? e.manager.tooltips.findIndex((n) => n.create == Lb.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, n;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: o } = this;
    if (i.length && o && !YY(o.dom, e) || this.pending) {
      let { pos: s } = i[0] || this.pending, a = (n = (r = i[0]) === null || r === void 0 ? void 0 : r.end) !== null && n !== void 0 ? n : s;
      (s == a ? this.view.posAtCoords(this.lastMove) != s : !ZY(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: n } = this;
      n && n.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(n.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (n) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(n.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const $v = 4;
function YY(t, e) {
  let { left: r, right: n, top: i, bottom: o } = t.getBoundingClientRect(), s;
  if (s = t.querySelector(".cm-tooltip-arrow")) {
    let a = s.getBoundingClientRect();
    i = Math.min(a.top, i), o = Math.max(a.bottom, o);
  }
  return e.clientX >= r - $v && e.clientX <= n + $v && e.clientY >= i - $v && e.clientY <= o + $v;
}
function ZY(t, e, r, n, i, o) {
  let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (s.left > n || s.right < n || s.top > i || Math.min(s.bottom, a) < i)
    return !1;
  let l = t.posAtCoords({ x: n, y: i }, !1);
  return l >= e && l <= r;
}
function sP(t, e = {}) {
  let r = kt.define(), n = qn.define({
    create() {
      return [];
    },
    update(i, o) {
      if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
        let s = [];
        for (let a of i) {
          let l = o.changes.mapPos(a.pos, -1, Kn.TrackDel);
          if (l != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), a);
            u.pos = l, u.end != null && (u.end = o.changes.mapPos(u.end)), s.push(u);
          }
        }
        i = s;
      }
      for (let s of o.effects)
        s.is(r) && (i = s.value), s.is(eZ) && (i = []);
      return i;
    },
    provide: (i) => m1.from(i)
  });
  return {
    active: n,
    extension: [
      n,
      kn.define((i) => new JY(
        i,
        t,
        n,
        r,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      QY
    ]
  };
}
function aP(t, e) {
  let r = t.plugin(c4);
  if (!r)
    return null;
  let n = r.manager.tooltips.indexOf(e);
  return n < 0 ? null : r.manager.tooltipViews[n];
}
const eZ = /* @__PURE__ */ kt.define(), C6 = /* @__PURE__ */ Be.define({
  combine(t) {
    let e, r;
    for (let n of t)
      e = e || n.topContainer, r = r || n.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function rg(t, e) {
  let r = t.plugin(lP), n = r ? r.specs.indexOf(e) : -1;
  return n > -1 ? r.panels[n] : null;
}
const lP = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(ng), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(C6);
    this.top = new Iv(t, !0, e.topContainer), this.bottom = new Iv(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(C6);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Iv(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Iv(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(ng);
    if (r != this.input) {
      let n = r.filter((l) => l), i = [], o = [], s = [], a = [];
      for (let l of n) {
        let u = this.specs.indexOf(l), c;
        u < 0 ? (c = l(t.view), a.push(c)) : (c = this.panels[u], c.update && c.update(t)), i.push(c), (c.top ? o : s).push(c);
      }
      this.specs = n, this.panels = i, this.top.sync(o), this.bottom.sync(s);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let n of this.panels)
        n.update && n.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => Ie.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class Iv {
  constructor(e, r, n) {
    this.view = e, this.top = r, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = _6(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = _6(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function _6(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const ng = /* @__PURE__ */ Be.define({
  enables: lP
});
class ac extends xh {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
ac.prototype.elementClass = "";
ac.prototype.toDOM = void 0;
ac.prototype.mapMode = Kn.TrackBefore;
ac.prototype.startSide = ac.prototype.endSide = -1;
ac.prototype.point = !0;
const Iy = /* @__PURE__ */ Be.define(), tZ = /* @__PURE__ */ Be.define(), By = /* @__PURE__ */ Be.define(), S6 = /* @__PURE__ */ Be.define({
  combine: (t) => t.some((e) => e)
});
function rZ(t) {
  return [
    nZ
  ];
}
const nZ = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.view = t, this.domAfter = null, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(By).map((e) => new E6(t, e)), this.fixed = !t.state.facet(S6);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, n = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(n < (r.to - r.from) * 0.8);
    }
    if (t.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(S6) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let r = fr.iter(this.view.state.facet(Iy), this.view.viewport.from), n = [], i = this.gutters.map((o) => new iZ(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (n.length && (n = []), Array.isArray(o.type)) {
        let s = !0;
        for (let a of o.type)
          if (a.type == $i.Text && s) {
            Y3(r, n, a.from);
            for (let l of i)
              l.line(this.view, a, n);
            s = !1;
          } else if (a.widget)
            for (let l of i)
              l.widget(this.view, a);
      } else if (o.type == $i.Text) {
        Y3(r, n, o.from);
        for (let s of i)
          s.line(this.view, o, n);
      } else if (o.widget)
        for (let s of i)
          s.widget(this.view, o);
    for (let o of i)
      o.finish();
    t && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(t) {
    let e = t.startState.facet(By), r = t.state.facet(By), n = t.docChanged || t.heightChanged || t.viewportChanged || !fr.eq(t.startState.facet(Iy), t.state.facet(Iy), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let i of this.gutters)
        i.update(t) && (n = !0);
    else {
      n = !0;
      let i = [];
      for (let o of r) {
        let s = e.indexOf(o);
        s < 0 ? i.push(new E6(this.view, o)) : (this.gutters[s].update(t), i.push(this.gutters[s]));
      }
      for (let o of this.gutters)
        o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
      for (let o of i)
        o.config.side == "after" ? this.getDOMAfter().appendChild(o.dom) : this.dom.appendChild(o.dom);
      this.gutters = i;
    }
    return n;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (t) => Ie.scrollMargins.of((e) => {
    let r = e.plugin(t);
    if (!r || r.gutters.length == 0 || !r.fixed)
      return null;
    let n = r.dom.offsetWidth * e.scaleX, i = r.domAfter ? r.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == zr.LTR ? { left: n, right: i } : { right: n, left: i };
  })
});
function A6(t) {
  return Array.isArray(t) ? t : [t];
}
function Y3(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class iZ {
  constructor(e, r, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = fr.iter(e.markers, r.from);
  }
  addElement(e, r, n) {
    let { gutter: i } = this, o = (r.top - this.height) / e.scaleY, s = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new uP(e, s, o, n);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(e, s, o, n);
    this.height = r.bottom, this.i++;
  }
  line(e, r, n) {
    let i = [];
    Y3(this.cursor, i, r.from), n.length && (i = i.concat(n));
    let o = this.gutter.config.lineMarker(e, r, i);
    o && i.unshift(o);
    let s = this.gutter;
    i.length == 0 && !s.config.renderEmptyElements || this.addElement(e, r, i);
  }
  widget(e, r) {
    let n = this.gutter.config.widgetMarker(e, r.widget, r), i = n ? [n] : null;
    for (let o of e.state.facet(tZ)) {
      let s = o(e, r.widget, r);
      s && (i || (i = [])).push(s);
    }
    i && this.addElement(e, r, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class E6 {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in r.domEventHandlers)
      this.dom.addEventListener(n, (i) => {
        let o = i.target, s;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let l = o.getBoundingClientRect();
          s = (l.top + l.bottom) / 2;
        } else
          s = i.clientY;
        let a = e.lineBlockAtHeight(s - e.documentTop);
        r.domEventHandlers[n](e, a, i) && i.preventDefault();
      });
    this.markers = A6(r.markers(e)), r.initialSpacer && (this.spacer = new uP(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = A6(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let n = e.view.viewport;
    return !fr.eq(this.markers, r, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class uP {
  constructor(e, r, n, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, n, i);
  }
  update(e, r, n, i) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), oZ(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let n = "cm-gutterElement", i = this.dom.firstChild;
    for (let o = 0, s = 0; ; ) {
      let a = s, l = o < r.length ? r[o++] : null, u = !1;
      if (l) {
        let c = l.elementClass;
        c && (n += " " + c);
        for (let h = s; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            a = h, u = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; s < a; ) {
        let c = this.markers[s++];
        if (c.toDOM) {
          c.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), u && s++;
    }
    this.dom.className = n, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function oZ(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const sZ = /* @__PURE__ */ Be.define(), aZ = /* @__PURE__ */ Be.define(), Mf = /* @__PURE__ */ Be.define({
  combine(t) {
    return ou(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let n = Object.assign({}, e);
        for (let i in r) {
          let o = n[i], s = r[i];
          n[i] = o ? (a, l, u) => o(a, l, u) || s(a, l, u) : s;
        }
        return n;
      }
    });
  }
});
class A2 extends ac {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function E2(t, e) {
  return t.state.facet(Mf).formatNumber(e, t.state);
}
const lZ = /* @__PURE__ */ By.compute([Mf], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(sZ);
  },
  lineMarker(e, r, n) {
    return n.some((i) => i.toDOM) ? null : new A2(E2(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: (e, r, n) => {
    for (let i of e.state.facet(aZ)) {
      let o = i(e, r, n);
      if (o)
        return o;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Mf) != e.state.facet(Mf),
  initialSpacer(e) {
    return new A2(E2(e, D6(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let n = E2(r.view, D6(r.view.state.doc.lines));
    return n == e.number ? e : new A2(n);
  },
  domEventHandlers: t.facet(Mf).domEventHandlers,
  side: "before"
}));
function uZ(t = {}) {
  return [
    Mf.of(t),
    rZ(),
    lZ
  ];
}
function D6(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const cZ = /* @__PURE__ */ new class extends ac {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), hZ = /* @__PURE__ */ Iy.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.head).from;
    i > r && (r = i, e.push(cZ.range(i)));
  }
  return fr.of(e);
});
function fZ() {
  return hZ;
}
const cP = 1024;
let dZ = 0;
class D2 {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class Rt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = dZ++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    }), this.combine = e.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = co.match(e)), (r) => {
      let n = e(r);
      return n === void 0 ? null : [this, n];
    };
  }
}
Rt.closedBy = new Rt({ deserialize: (t) => t.split(" ") });
Rt.openedBy = new Rt({ deserialize: (t) => t.split(" ") });
Rt.group = new Rt({ deserialize: (t) => t.split(" ") });
Rt.isolate = new Rt({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Rt.contextHash = new Rt({ perNode: !0 });
Rt.lookAhead = new Rt({ perNode: !0 });
Rt.mounted = new Rt({ perNode: !0 });
class g1 {
  constructor(e, r, n) {
    this.tree = e, this.overlay = r, this.parser = n;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Rt.mounted.id];
  }
}
const pZ = /* @__PURE__ */ Object.create(null);
class co {
  /**
  @internal
  */
  constructor(e, r, n, i = 0) {
    this.name = e, this.props = r, this.id = n, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : pZ, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new co(e.name || "", r, e.id, n);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(i)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[o[0].id] = o[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(Rt.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let i of n.split(" "))
        r[i] = e[n];
    return (n) => {
      for (let i = n.prop(Rt.group), o = -1; o < (i ? i.length : 0); o++) {
        let s = r[o < 0 ? n.name : i[o]];
        if (s)
          return s;
      }
    };
  }
}
co.none = new co(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class f4 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let r = [];
    for (let n of this.types) {
      let i = null;
      for (let o of e) {
        let s = o(n);
        if (s) {
          i || (i = Object.assign({}, n.props));
          let a = s[1], l = s[0];
          l.combine && l.id in i && (a = l.combine(i[l.id], a)), i[l.id] = a;
        }
      }
      r.push(i ? new co(n.name, i, n.id, n.flags) : n);
    }
    return new f4(r);
  }
}
const Bv = /* @__PURE__ */ new WeakMap(), O6 = /* @__PURE__ */ new WeakMap();
var $n;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})($n || ($n = {}));
class wn {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, n, i, o) {
    if (this.type = e, this.children = r, this.positions = n, this.length = i, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of o)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = g1.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let n of this.children) {
      let i = n.toString();
      i && (r && (r += ","), r += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new eC(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, n = 0) {
    let i = Bv.get(this) || this.topNode, o = new eC(i);
    return o.moveTo(e, r), Bv.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new bs(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let n = ig(Bv.get(this) || this.topNode, e, r, !1);
    return Bv.set(this, n), n;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let n = ig(O6.get(this) || this.topNode, e, r, !0);
    return O6.set(this, n), n;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return vZ(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: n, from: i = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & $n.IncludeAnonymous) > 0;
    for (let l = this.cursor(s | $n.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= o && l.to >= i && (!a && l.type.isAnonymous || r(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && n && (a || !l.type.isAnonymous) && n(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : m4(co.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, n, i) => new wn(this.type, r, n, i, this.propValues), e.makeTree || ((r, n, i) => new wn(co.none, r, n, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return yZ(e);
  }
}
wn.empty = new wn(co.none, [], [], 0);
class d4 {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new d4(this.buffer, this.index);
  }
}
class lc {
  /**
  Create a tree buffer.
  */
  constructor(e, r, n) {
    this.buffer = e, this.length = r, this.set = n;
  }
  /**
  @internal
  */
  get type() {
    return co.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], n = this.buffer[e + 3], i = this.set.types[r], o = i.name;
    if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, n == e)
      return o;
    let s = [];
    for (; e < n; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, n, i, o) {
    let { buffer: s } = this, a = -1;
    for (let l = e; l != r && !(hP(o, i, s[l + 1], s[l + 2]) && (a = l, n > 0)); l = s[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, r, n) {
    let i = this.buffer, o = new Uint16Array(r - e), s = 0;
    for (let a = e, l = 0; a < r; ) {
      o[l++] = i[a++], o[l++] = i[a++] - n;
      let u = o[l++] = i[a++] - n;
      o[l++] = i[a++] - e, s = Math.max(s, u);
    }
    return new lc(o, s, this.set);
  }
}
function hP(t, e, r, n) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return n >= e && r < e;
    case 0:
      return r < e && n > e;
    case 1:
      return r <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function ig(t, e, r, n) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let s = !n && t instanceof bs && t.index < 0 ? null : t.parent;
    if (!s)
      return t;
    t = s;
  }
  let o = n ? 0 : $n.IgnoreOverlays;
  if (n)
    for (let s = t, a = s.parent; a; s = a, a = s.parent)
      s instanceof bs && s.index < 0 && ((i = a.enter(e, r, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t = a);
  for (; ; ) {
    let s = t.enter(e, r, o);
    if (!s)
      return t;
    t = s;
  }
}
class fP {
  cursor(e = 0) {
    return new eC(this, e);
  }
  getChild(e, r = null, n = null) {
    let i = F6(this, e, r, n);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, n = null) {
    return F6(this, e, r, n);
  }
  resolve(e, r = 0) {
    return ig(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return ig(this, e, r, !0);
  }
  matchContext(e) {
    return Z3(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), n = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to)
        break;
      i.type.isError && i.from == i.to ? (n = r, r = i.prevSibling) : r = i;
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class bs extends fP {
  constructor(e, r, n, i) {
    super(), this._tree = e, this.from = r, this.index = n, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, n, i, o = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: l } = s._tree, u = r > 0 ? a.length : -1; e != u; e += r) {
        let c = a[e], h = l[e] + s.from;
        if (hP(i, n, h, h + c.length)) {
          if (c instanceof lc) {
            if (o & $n.ExcludeBuffers)
              continue;
            let d = c.findChild(0, c.buffer.length, r, n - h, i);
            if (d > -1)
              return new $u(new mZ(s, c, e, h), null, d);
          } else if (o & $n.IncludeAnonymous || !c.type.isAnonymous || p4(c)) {
            let d;
            if (!(o & $n.IgnoreMounts) && (d = g1.get(c)) && !d.overlay)
              return new bs(d.tree, h, e, s);
            let p = new bs(c, h, e, s);
            return o & $n.IncludeAnonymous || !p.type.isAnonymous ? p : p.nextChild(r < 0 ? c.children.length - 1 : 0, r, n, i);
          }
        }
      }
      if (o & $n.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + r : e = r < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    let i;
    if (!(n & $n.IgnoreOverlays) && (i = g1.get(this._tree)) && i.overlay) {
      let o = e - this.from;
      for (let { from: s, to: a } of i.overlay)
        if ((r > 0 ? s <= o : s < o) && (r < 0 ? a >= o : a > o))
          return new bs(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function F6(t, e, r, n) {
  let i = t.cursor(), o = [];
  if (!i.firstChild())
    return o;
  if (r != null) {
    for (let s = !1; !s; )
      if (s = i.type.is(r), !i.nextSibling())
        return o;
  }
  for (; ; ) {
    if (n != null && i.type.is(n))
      return o;
    if (i.type.is(e) && o.push(i.node), !i.nextSibling())
      return n == null ? o : [];
  }
}
function Z3(t, e, r = e.length - 1) {
  for (let n = t; r >= 0; n = n.parent) {
    if (!n)
      return !1;
    if (!n.type.isAnonymous) {
      if (e[r] && e[r] != n.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class mZ {
  constructor(e, r, n, i) {
    this.parent = e, this.buffer = r, this.index = n, this.start = i;
  }
}
class $u extends fP {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, n) {
    super(), this.context = e, this._parent = r, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, r, n) {
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, n);
    return o < 0 ? null : new $u(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    if (n & $n.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return o < 0 ? null : new $u(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new $u(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new $u(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: n } = this.context, i = this.index + 4, o = n.buffer[this.index + 3];
    if (o > i) {
      let s = n.buffer[this.index + 1];
      e.push(n.slice(i, o, s)), r.push(0);
    }
    return new wn(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function dP(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let o = 1; o < t.length; o++) {
    let s = t[o];
    (s.from > r.from || s.to < r.to) && (r = s, e = o);
  }
  let n = r instanceof bs && r.index < 0 ? null : r.parent, i = t.slice();
  return n ? i[e] = n : i.splice(e, 1), new gZ(i, r);
}
class gZ {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return dP(this.heads);
  }
}
function vZ(t, e, r) {
  let n = t.resolveInner(e, r), i = null;
  for (let o = n instanceof bs ? n : n.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let s = o.parent;
      (i || (i = [n])).push(s.resolve(e, r)), o = s;
    } else {
      let s = g1.get(o.tree);
      if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
        let a = new bs(s.tree, s.overlay[0].from + o.from, -1, o);
        (i || (i = [n])).push(ig(a, e, r, !1));
      }
    }
  return i ? dP(i) : n;
}
class eC {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof bs)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: n, buffer: i } = this.buffer;
    return this.type = r || i.set.types[i.buffer[e]], this.from = n + i.buffer[e + 1], this.to = n + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof bs ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, n, this.mode));
    let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, n);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, n = this.mode) {
    return this.buffer ? n & $n.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, n));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & $n.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & $n.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let i = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != i)
        return this.yieldBuf(r.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (n < 0 ? r.buffer.length : r.buffer[this.stack[n] + 3]))
        return this.yieldBuf(i);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, n, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (i.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: r, parent: n } = i);
    } else
      ({ index: r, _parent: n } = this._tree);
    for (; n; { index: r, _parent: n } = n)
      if (r > -1)
        for (let o = r + e, s = e < 0 ? -1 : n._tree.children.length; o != s; o += e) {
          let a = n._tree.children[o];
          if (this.mode & $n.IncludeAnonymous || a instanceof lc || !a.type.isAnonymous || p4(a))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, n = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, o = this.stack.length; o >= 0; ) {
        for (let s = e; s; s = s._parent)
          if (s.index == i) {
            if (i == this.index)
              return s;
            r = s, n = o + 1;
            break e;
          }
        i = this.stack[--o];
      }
    for (let i = n; i < this.stack.length; i++)
      r = new $u(this.buffer, r, this.stack[i]);
    return this.bufferNode = new $u(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let n = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && r && r(this), i = this.type.isAnonymous, !n)
          return;
        if (this.nextSibling())
          break;
        this.parent(), n--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contextâ€”a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Z3(this.node.parent, e);
    let { buffer: r } = this.buffer, { types: n } = r.set;
    for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0)
        return Z3(this._tree, e, i);
      let s = n[r.buffer[this.stack[o]]];
      if (!s.isAnonymous) {
        if (e[i] && e[i] != s.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function p4(t) {
  return t.children.some((e) => e instanceof lc || !e.type.isAnonymous || p4(e));
}
function yZ(t) {
  var e;
  let { buffer: r, nodeSet: n, maxBufferLength: i = cP, reused: o = [], minRepeatType: s = n.types.length } = t, a = Array.isArray(r) ? new d4(r, r.length) : r, l = n.types, u = 0, c = 0;
  function h(_, D, A, O, M, z) {
    let { id: N, start: P, end: I, size: B } = a, $ = c, j = u;
    if (B < 0)
      if (a.next(), B == -1) {
        let ne = o[N];
        A.push(ne), O.push(P - _);
        return;
      } else if (B == -3) {
        u = N;
        return;
      } else if (B == -4) {
        c = N;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${B}`);
    let U = l[N], H, G, re = P - _;
    if (I - P <= i && (G = y(a.pos - D, M))) {
      let ne = new Uint16Array(G.size - G.skip), se = a.pos - G.size, ie = ne.length;
      for (; a.pos > se; )
        ie = b(G.start, ne, ie);
      H = new lc(ne, I - G.start, n), re = G.start - _;
    } else {
      let ne = a.pos - B;
      a.next();
      let se = [], ie = [], ce = N >= s ? N : -1, Ce = 0, Me = I;
      for (; a.pos > ne; )
        ce >= 0 && a.id == ce && a.size >= 0 ? (a.end <= Me - i && (g(se, ie, P, Ce, a.end, Me, ce, $, j), Ce = se.length, Me = a.end), a.next()) : z > 2500 ? d(P, ne, se, ie) : h(P, ne, se, ie, ce, z + 1);
      if (ce >= 0 && Ce > 0 && Ce < se.length && g(se, ie, P, Ce, P, Me, ce, $, j), se.reverse(), ie.reverse(), ce > -1 && Ce > 0) {
        let Pe = p(U, j);
        H = m4(U, se, ie, 0, se.length, 0, I - P, Pe, Pe);
      } else
        H = v(U, se, ie, I - P, $ - I, j);
    }
    A.push(H), O.push(re);
  }
  function d(_, D, A, O) {
    let M = [], z = 0, N = -1;
    for (; a.pos > D; ) {
      let { id: P, start: I, end: B, size: $ } = a;
      if ($ > 4)
        a.next();
      else {
        if (N > -1 && I < N)
          break;
        N < 0 && (N = B - i), M.push(P, I, B), z++, a.next();
      }
    }
    if (z) {
      let P = new Uint16Array(z * 4), I = M[M.length - 2];
      for (let B = M.length - 3, $ = 0; B >= 0; B -= 3)
        P[$++] = M[B], P[$++] = M[B + 1] - I, P[$++] = M[B + 2] - I, P[$++] = $;
      A.push(new lc(P, M[2] - I, n)), O.push(I - _);
    }
  }
  function p(_, D) {
    return (A, O, M) => {
      let z = 0, N = A.length - 1, P, I;
      if (N >= 0 && (P = A[N]) instanceof wn) {
        if (!N && P.type == _ && P.length == M)
          return P;
        (I = P.prop(Rt.lookAhead)) && (z = O[N] + P.length + I);
      }
      return v(_, A, O, M, z, D);
    };
  }
  function g(_, D, A, O, M, z, N, P, I) {
    let B = [], $ = [];
    for (; _.length > O; )
      B.push(_.pop()), $.push(D.pop() + A - M);
    _.push(v(n.types[N], B, $, z - M, P - z, I)), D.push(M - A);
  }
  function v(_, D, A, O, M, z, N) {
    if (z) {
      let P = [Rt.contextHash, z];
      N = N ? [P].concat(N) : [P];
    }
    if (M > 25) {
      let P = [Rt.lookAhead, M];
      N = N ? [P].concat(N) : [P];
    }
    return new wn(_, D, A, O, N);
  }
  function y(_, D) {
    let A = a.fork(), O = 0, M = 0, z = 0, N = A.end - i, P = { size: 0, start: 0, skip: 0 };
    e: for (let I = A.pos - _; A.pos > I; ) {
      let B = A.size;
      if (A.id == D && B >= 0) {
        P.size = O, P.start = M, P.skip = z, z += 4, O += 4, A.next();
        continue;
      }
      let $ = A.pos - B;
      if (B < 0 || $ < I || A.start < N)
        break;
      let j = A.id >= s ? 4 : 0, U = A.start;
      for (A.next(); A.pos > $; ) {
        if (A.size < 0)
          if (A.size == -3)
            j += 4;
          else
            break e;
        else A.id >= s && (j += 4);
        A.next();
      }
      M = U, O += B, z += j;
    }
    return (D < 0 || O == _) && (P.size = O, P.start = M, P.skip = z), P.size > 4 ? P : void 0;
  }
  function b(_, D, A) {
    let { id: O, start: M, end: z, size: N } = a;
    if (a.next(), N >= 0 && O < s) {
      let P = A;
      if (N > 4) {
        let I = a.pos - (N - 4);
        for (; a.pos > I; )
          A = b(_, D, A);
      }
      D[--A] = P, D[--A] = z - _, D[--A] = M - _, D[--A] = O;
    } else N == -3 ? u = O : N == -4 && (c = O);
    return A;
  }
  let k = [], C = [];
  for (; a.pos > 0; )
    h(t.start || 0, t.bufferStart || 0, k, C, -1, 0);
  let S = (e = t.length) !== null && e !== void 0 ? e : k.length ? C[0] + k[0].length : 0;
  return new wn(l[t.topID], k.reverse(), C.reverse(), S);
}
const T6 = /* @__PURE__ */ new WeakMap();
function Ly(t, e) {
  if (!t.isAnonymous || e instanceof lc || e.type != t)
    return 1;
  let r = T6.get(e);
  if (r == null) {
    r = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof wn)) {
        r = 1;
        break;
      }
      r += Ly(t, n);
    }
    T6.set(e, r);
  }
  return r;
}
function m4(t, e, r, n, i, o, s, a, l) {
  let u = 0;
  for (let g = n; g < i; g++)
    u += Ly(t, e[g]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], d = [];
  function p(g, v, y, b, k) {
    for (let C = y; C < b; ) {
      let S = C, _ = v[C], D = Ly(t, g[C]);
      for (C++; C < b; C++) {
        let A = Ly(t, g[C]);
        if (D + A >= c)
          break;
        D += A;
      }
      if (C == S + 1) {
        if (D > c) {
          let A = g[S];
          p(A.children, A.positions, 0, A.children.length, v[S] + k);
          continue;
        }
        h.push(g[S]);
      } else {
        let A = v[C - 1] + g[C - 1].length - _;
        h.push(m4(t, g, v, S, C, _, A, null, l));
      }
      d.push(_ + k - o);
    }
  }
  return p(e, r, n, i, 0), (a || l)(h, d, s);
}
class oh {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, n, i, o = !1, s = !1) {
    this.from = e, this.to = r, this.tree = n, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], n = !1) {
    let i = [new oh(0, e.length, e, 0, !1, n)];
    for (let o of r)
      o.to > e.length && i.push(o);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, n = 128) {
    if (!r.length)
      return e;
    let i = [], o = 1, s = e.length ? e[0] : null;
    for (let a = 0, l = 0, u = 0; ; a++) {
      let c = a < r.length ? r[a] : null, h = c ? c.fromA : 1e9;
      if (h - l >= n)
        for (; s && s.from < h; ) {
          let d = s;
          if (l >= d.from || h <= d.to || u) {
            let p = Math.max(d.from, l) - u, g = Math.min(d.to, h) - u;
            d = p >= g ? null : new oh(p, g, d.tree, d.offset + u, a > 0, !!c);
          }
          if (d && i.push(d), s.to > h)
            break;
          s = o < e.length ? e[o++] : null;
        }
      if (!c)
        break;
      l = c.toA, u = c.toA - c.toB;
    }
    return i;
  }
}
let pP = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, r) {
    return typeof t == "string" && (t = new bZ(t)), r = r ? r.length ? r.map((n) => new D2(n.from, n.to)) : [new D2(0, 0)] : [new D2(0, t.length)], this.createParse(t, e || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, r) {
    let n = this.startParse(t, e, r);
    for (; ; ) {
      let i = n.advance();
      if (i)
        return i;
    }
  }
};
class bZ {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
new Rt({ perNode: !0 });
let xZ = 0;
class ds {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.name = e, this.set = r, this.base = n, this.modified = i, this.id = xZ++;
  }
  toString() {
    let { name: e } = this;
    for (let r of this.modified)
      r.name && (e = `${r.name}(${e})`);
    return e;
  }
  static define(e, r) {
    let n = typeof e == "string" ? e : "?";
    if (e instanceof ds && (r = e), r?.base)
      throw new Error("Can not derive from a modified tag");
    let i = new ds(n, [], null, []);
    if (i.set.push(i), r)
      for (let o of r.set)
        i.set.push(o);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let r = new v1(e);
    return (n) => n.modified.indexOf(r) > -1 ? n : v1.get(n.base || n, n.modified.concat(r).sort((i, o) => i.id - o.id));
  }
}
let wZ = 0;
class v1 {
  constructor(e) {
    this.name = e, this.instances = [], this.id = wZ++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let n = r[0].instances.find((a) => a.base == e && kZ(r, a.modified));
    if (n)
      return n;
    let i = [], o = new ds(e.name, i, e, r);
    for (let a of r)
      a.instances.push(o);
    let s = CZ(r);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of s)
          i.push(v1.get(a, l));
    return o;
  }
}
function kZ(t, e) {
  return t.length == e.length && t.every((r, n) => r == e[n]);
}
function CZ(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let n = 0, i = e.length; n < i; n++)
      e.push(e[n].concat(t[r]));
  return e.sort((r, n) => n.length - r.length);
}
function g4(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let n = t[r];
    Array.isArray(n) || (n = [n]);
    for (let i of r.split(" "))
      if (i) {
        let o = [], s = 2, a = i;
        for (let h = 0; ; ) {
          if (a == "..." && h > 0 && h + 3 == i.length) {
            s = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + i);
          if (o.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), h += d[0].length, h == i.length)
            break;
          let p = i[h++];
          if (h == i.length && p == "!") {
            s = 0;
            break;
          }
          if (p != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(h);
        }
        let l = o.length - 1, u = o[l];
        if (!u)
          throw new RangeError("Invalid path: " + i);
        let c = new og(n, s, l > 0 ? o.slice(0, l) : null);
        e[u] = c.sort(e[u]);
      }
  }
  return mP.add(e);
}
const mP = new Rt({
  combine(t, e) {
    let r, n, i;
    for (; t || e; ) {
      if (!t || e && t.depth >= e.depth ? (i = e, e = e.next) : (i = t, t = t.next), r && r.mode == i.mode && !i.context && !r.context)
        continue;
      let o = new og(i.tags, i.mode, i.context);
      r ? r.next = o : n = o, r = o;
    }
    return n;
  }
});
let og = class {
  constructor(t, e, r, n) {
    this.tags = t, this.mode = e, this.context = r, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
og.empty = new og([], 2, null);
function gP(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let o of t)
    if (!Array.isArray(o.tag))
      r[o.tag.id] = o.class;
    else
      for (let s of o.tag)
        r[s.id] = o.class;
  let { scope: n, all: i = null } = e || {};
  return {
    style: (o) => {
      let s = i;
      for (let a of o)
        for (let l of a.set) {
          let u = r[l.id];
          if (u) {
            s = s ? s + " " + u : u;
            break;
          }
        }
      return s;
    },
    scope: n
  };
}
function _Z(t, e) {
  let r = null;
  for (let n of t) {
    let i = n.style(e);
    i && (r = r ? r + " " + i : i);
  }
  return r;
}
function SZ(t, e, r, n = 0, i = t.length) {
  let o = new AZ(n, Array.isArray(e) ? e : [e], r);
  o.highlightRange(t.cursor(), n, i, "", o.highlighters), o.flush(i);
}
class AZ {
  constructor(e, r, n) {
    this.at = e, this.highlighters = r, this.span = n, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, n, i, o) {
    let { type: s, from: a, to: l } = e;
    if (a >= n || l <= r)
      return;
    s.isTop && (o = this.highlighters.filter((p) => !p.scope || p.scope(s)));
    let u = i, c = EZ(e) || og.empty, h = _Z(o, c.tags);
    if (h && (u && (u += " "), u += h, c.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(r, a), u), c.opaque)
      return;
    let d = e.tree && e.tree.prop(Rt.mounted);
    if (d && d.overlay) {
      let p = e.node.enter(d.overlay[0].from + a, 1), g = this.highlighters.filter((y) => !y.scope || y.scope(d.tree.type)), v = e.firstChild();
      for (let y = 0, b = a; ; y++) {
        let k = y < d.overlay.length ? d.overlay[y] : null, C = k ? k.from + a : l, S = Math.max(r, b), _ = Math.min(n, C);
        if (S < _ && v)
          for (; e.from < _ && (this.highlightRange(e, S, _, i, o), this.startSpan(Math.min(_, e.to), u), !(e.to >= C || !e.nextSibling())); )
            ;
        if (!k || C > n)
          break;
        b = k.to + a, b > r && (this.highlightRange(p.cursor(), Math.max(r, k.from + a), Math.min(n, b), "", g), this.startSpan(Math.min(n, b), u));
      }
      v && e.parent();
    } else if (e.firstChild()) {
      d && (i = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, r, n, i, o), this.startSpan(Math.min(n, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function EZ(t) {
  let e = t.type.prop(mP);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const Re = ds.define, Lv = Re(), Au = Re(), M6 = Re(Au), P6 = Re(Au), Eu = Re(), zv = Re(Eu), O2 = Re(Eu), va = Re(), Tc = Re(va), ma = Re(), ga = Re(), tC = Re(), Qp = Re(tC), jv = Re(), oe = {
  /**
  A comment.
  */
  comment: Lv,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Re(Lv),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Re(Lv),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Re(Lv),
  /**
  Any kind of identifier.
  */
  name: Au,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Re(Au),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: M6,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Re(M6),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: P6,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Re(P6),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Re(Au),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Re(Au),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Re(Au),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Re(Au),
  /**
  A literal value.
  */
  literal: Eu,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: zv,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Re(zv),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Re(zv),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Re(zv),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: O2,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Re(O2),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Re(O2),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Re(Eu),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Re(Eu),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Re(Eu),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Re(Eu),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Re(Eu),
  /**
  A language keyword.
  */
  keyword: ma,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Re(ma),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Re(ma),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Re(ma),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Re(ma),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Re(ma),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Re(ma),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Re(ma),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Re(ma),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Re(ma),
  /**
  An operator.
  */
  operator: ga,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Re(ga),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Re(ga),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Re(ga),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Re(ga),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Re(ga),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Re(ga),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Re(ga),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Re(ga),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Re(ga),
  /**
  Program or markup punctuation.
  */
  punctuation: tC,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Re(tC),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Qp,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Re(Qp),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Re(Qp),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Re(Qp),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Re(Qp),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: va,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Tc,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Re(Tc),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Re(Tc),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Re(Tc),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Re(Tc),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Re(Tc),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Re(Tc),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: Re(va),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Re(va),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Re(va),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Re(va),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Re(va),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Re(va),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Re(va),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Re(va),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Re(),
  /**
  Deleted text.
  */
  deleted: Re(),
  /**
  Changed text.
  */
  changed: Re(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Re(),
  /**
  Metadata or meta-instruction.
  */
  meta: jv,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Re(jv),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Re(jv),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Re(jv),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: ds.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: ds.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: ds.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: ds.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: ds.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: ds.defineModifier("special")
};
for (let t in oe) {
  let e = oe[t];
  e instanceof ds && (e.name = t);
}
gP([
  { tag: oe.link, class: "tok-link" },
  { tag: oe.heading, class: "tok-heading" },
  { tag: oe.emphasis, class: "tok-emphasis" },
  { tag: oe.strong, class: "tok-strong" },
  { tag: oe.keyword, class: "tok-keyword" },
  { tag: oe.atom, class: "tok-atom" },
  { tag: oe.bool, class: "tok-bool" },
  { tag: oe.url, class: "tok-url" },
  { tag: oe.labelName, class: "tok-labelName" },
  { tag: oe.inserted, class: "tok-inserted" },
  { tag: oe.deleted, class: "tok-deleted" },
  { tag: oe.literal, class: "tok-literal" },
  { tag: oe.string, class: "tok-string" },
  { tag: oe.number, class: "tok-number" },
  { tag: [oe.regexp, oe.escape, oe.special(oe.string)], class: "tok-string2" },
  { tag: oe.variableName, class: "tok-variableName" },
  { tag: oe.local(oe.variableName), class: "tok-variableName tok-local" },
  { tag: oe.definition(oe.variableName), class: "tok-variableName tok-definition" },
  { tag: oe.special(oe.variableName), class: "tok-variableName2" },
  { tag: oe.definition(oe.propertyName), class: "tok-propertyName tok-definition" },
  { tag: oe.typeName, class: "tok-typeName" },
  { tag: oe.namespace, class: "tok-namespace" },
  { tag: oe.className, class: "tok-className" },
  { tag: oe.macroName, class: "tok-macroName" },
  { tag: oe.propertyName, class: "tok-propertyName" },
  { tag: oe.operator, class: "tok-operator" },
  { tag: oe.comment, class: "tok-comment" },
  { tag: oe.meta, class: "tok-meta" },
  { tag: oe.invalid, class: "tok-invalid" },
  { tag: oe.punctuation, class: "tok-punctuation" }
]);
var F2;
const Pf = /* @__PURE__ */ new Rt();
function DZ(t) {
  return Be.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const OZ = /* @__PURE__ */ new Rt();
class Vs {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, n = [], i = "") {
    this.data = e, this.name = i, ir.prototype.hasOwnProperty("tree") || Object.defineProperty(ir.prototype, "tree", { get() {
      return On(this);
    } }), this.parser = r, this.extension = [
      Sd.of(this),
      ir.languageData.of((o, s, a) => {
        let l = R6(o, s, a), u = l.type.prop(Pf);
        if (!u)
          return [];
        let c = o.facet(u), h = l.type.prop(OZ);
        if (h) {
          let d = l.resolve(s - l.from, a);
          for (let p of h)
            if (p.test(d, o)) {
              let g = o.facet(p.facet);
              return p.type == "replace" ? g : g.concat(c);
            }
        }
        return c;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, n = -1) {
    return R6(e, r, n).type.prop(Pf) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(Sd);
    if (r?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let n = [], i = (o, s) => {
      if (o.prop(Pf) == this.data) {
        n.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(Rt.mounted);
      if (a) {
        if (a.tree.prop(Pf) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              n.push({ from: l.from + s, to: l.to + s });
          else
            n.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let l = n.length;
          if (i(a.tree, a.overlay[0].from + s), n.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let u = o.children[l];
        u instanceof wn && i(u, o.positions[l] + s);
      }
    };
    return i(On(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Vs.setState = /* @__PURE__ */ kt.define();
function R6(t, e, r) {
  let n = t.facet(Sd), i = On(t).topNode;
  if (!n || n.allowsNesting)
    for (let o = i; o; o = o.enter(e, r, $n.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
class sg extends Vs {
  constructor(e, r, n) {
    super(e, r, [], n), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let r = DZ(e.languageData);
    return new sg(r, e.parser.configure({
      props: [Pf.add((n) => n.isTop ? r : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, r) {
    return new sg(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function On(t) {
  let e = t.field(Vs.state, !1);
  return e ? e.tree : wn.empty;
}
class FZ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let n = this.cursorPos - this.string.length;
    return e < n || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - n, r - n);
  }
}
let Jp = null;
class y1 {
  constructor(e, r, n = [], i, o, s, a, l) {
    this.parser = e, this.state = r, this.fragments = n, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new y1(e, r, [], wn.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new FZ(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != wn.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(oh.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(oh.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = Jp;
    Jp = this;
    try {
      return e();
    } finally {
      Jp = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = N6(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: n, tree: i, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, c, h, d) => l.push({ fromA: u, toA: c, fromB: h, toB: d })), n = oh.applyChanges(n, l), i = wn.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let u of this.skipped) {
          let c = e.mapPos(u.from, 1), h = e.mapPos(u.to, -1);
          c < h && a.push({ from: c, to: h });
        }
      }
    }
    return new y1(this.parser, r, n, i, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: i, to: o } = this.skipped[n];
      i < e.to && o > e.from && (this.fragments = N6(this.fragments, i, o), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends pP {
      createParse(r, n, i) {
        let o = i[0].from, s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let a = Jp;
            if (a) {
              for (let l of i)
                a.tempSkipped.push(l);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new wn(co.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Jp;
  }
}
function N6(t, e, r) {
  return oh.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class _d {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, n) || r.takeTree(), new _d(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), n = y1.create(e.facet(Sd).parser, e, { from: 0, to: r });
    return n.work(20, r) || n.takeTree(), new _d(n);
  }
}
Vs.state = /* @__PURE__ */ qn.define({
  create: _d.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(Vs.setState))
        return r.value;
    return e.startState.facet(Sd) != e.state.facet(Sd) ? _d.init(e.state) : t.apply(e);
  }
});
let vP = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (vP = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const T2 = typeof navigator < "u" && !((F2 = navigator.scheduling) === null || F2 === void 0) && F2.isInputPending ? () => navigator.scheduling.isInputPending() : null, TZ = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Vs.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Vs.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = vP(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: n } } = this.view, i = r.field(Vs.state);
    if (i.tree == i.context.tree && i.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, t && !T2 ? Math.max(25, t.timeRemaining() - 5) : 1e9), s = i.context.treeLen < n && r.doc.length > n + 1e3, a = i.context.work(() => T2 && T2() || Date.now() > o, n + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (a || this.chunkBudget <= 0) && (i.context.takeTree(), this.view.dispatch({ effects: Vs.setState.of(new _d(i.context)) })), this.chunkBudget > 0 && !(a && !s) && this.scheduleWork(), this.checkAsyncSchedule(i.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Ri(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Sd = /* @__PURE__ */ Be.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    Vs.state,
    TZ,
    Ie.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
class yP {
  /**
  Create a language support object.
  */
  constructor(e, r = []) {
    this.language = e, this.support = r, this.extension = [e, r];
  }
}
const MZ = /* @__PURE__ */ Be.define(), zb = /* @__PURE__ */ Be.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function b1(t) {
  let e = t.facet(zb);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function ag(t, e) {
  let r = "", n = t.tabSize, i = t.facet(zb)[0];
  if (i == "	") {
    for (; e >= n; )
      r += "	", e -= n;
    i = " ";
  }
  for (let o = 0; o < e; o++)
    r += i;
  return r;
}
function v4(t, e) {
  t instanceof ir && (t = new jb(t));
  for (let n of t.state.facet(MZ)) {
    let i = n(t, e);
    if (i !== void 0)
      return i;
  }
  let r = On(t.state);
  return r.length >= e ? PZ(t, r, e) : null;
}
class jb {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = b1(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= n.from && i <= n.to ? o && i == e ? { text: "", from: e } : (r < 0 ? i < e : i <= e) ? { text: n.text.slice(i - n.from), from: i } : { text: n.text.slice(0, i - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: i } = this.lineAt(e, r);
    return n.slice(e - i, Math.min(n.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), o = this.countColumn(n, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return s > -1 && (o += s - this.countColumn(n, n.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return Jd(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), o = this.options.overrideIndentation;
    if (o) {
      let s = o(i);
      if (s > -1)
        return s;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const y4 = /* @__PURE__ */ new Rt();
function PZ(t, e, r) {
  let n = e.resolveStack(r), i = e.resolveInner(r, -1).resolve(r, 0).enterUnfinishedNodesBefore(r);
  if (i != n.node) {
    let o = [];
    for (let s = i; s && !(s.from < n.node.from || s.to > n.node.to || s.from == n.node.from && s.type == n.node.type); s = s.parent)
      o.push(s);
    for (let s = o.length - 1; s >= 0; s--)
      n = { node: o[s], next: n };
  }
  return bP(n, t, r);
}
function bP(t, e, r) {
  for (let n = t; n; n = n.next) {
    let i = NZ(n.node);
    if (i)
      return i(b4.create(e, r, n));
  }
  return 0;
}
function RZ(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function NZ(t) {
  let e = t.type.prop(y4);
  if (e)
    return e;
  let r = t.firstChild, n;
  if (r && (n = r.type.prop(Rt.closedBy))) {
    let i = t.lastChild, o = i && n.indexOf(i.name) > -1;
    return (s) => LZ(s, !0, 1, void 0, o && !RZ(s) ? i.from : void 0);
  }
  return t.parent == null ? $Z : null;
}
function $Z() {
  return 0;
}
class b4 extends jb {
  constructor(e, r, n) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = n;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new b4(e, r, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let n = e.resolve(r.from);
      for (; n.parent && n.parent.from == n.from; )
        n = n.parent;
      if (IZ(n, e))
        break;
      r = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return bP(this.context.next, this.base, this.pos);
  }
}
function IZ(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function BZ(t) {
  let e = t.node, r = e.childAfter(e.from), n = e.lastChild;
  if (!r)
    return null;
  let i = t.options.simulateBreak, o = t.state.doc.lineAt(r.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let a = r.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == n)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= s)
        return null;
      let u = /^ */.exec(o.text.slice(r.to - o.from))[0].length;
      return { from: r.from, to: r.to + u };
    }
    a = l.to;
  }
}
function LZ(t, e, r, n, i) {
  let o = t.textAfter, s = o.match(/^\s*/)[0].length, a = i == t.pos + s, l = BZ(t);
  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * r);
}
function rC({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let n = t && t.test(r.textAfter);
    return r.baseIndent + (n ? 0 : e * r.unit);
  };
}
const zZ = 200;
function jZ() {
  return ir.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: n } = t.newSelection.main, i = r.lineAt(n);
    if (n > i.from + zZ)
      return t;
    let o = r.sliceString(i.from, n);
    if (!e.some((u) => u.test(o)))
      return t;
    let { state: s } = t, a = -1, l = [];
    for (let { head: u } of s.selection.ranges) {
      let c = s.doc.lineAt(u);
      if (c.from == a)
        continue;
      a = c.from;
      let h = v4(s, c.from);
      if (h == null)
        continue;
      let d = /^\s*/.exec(c.text)[0], p = ag(s, h);
      d != p && l.push({ from: c.from, to: c.from + d.length, insert: p });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const xP = /* @__PURE__ */ new Rt();
function qZ(t) {
  let e = t.firstChild, r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
class t0 {
  constructor(e, r) {
    this.specs = e;
    let n;
    function i(a) {
      let l = ic.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof r.all == "string" ? r.all : r.all ? i(r.all) : void 0, s = r.scope;
    this.scope = s instanceof Vs ? (a) => a.prop(Pf) == s.data : s ? (a) => a == s : void 0, this.style = gP(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = n ? new ic(n) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new t0(e, r || {});
  }
}
const nC = /* @__PURE__ */ Be.define(), wP = /* @__PURE__ */ Be.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function M2(t) {
  let e = t.facet(nC);
  return e.length ? e : t.facet(wP);
}
function kP(t, e) {
  let r = [HZ], n;
  return t instanceof t0 && (t.module && r.push(Ie.styleModule.of(t.module)), n = t.themeType), e?.fallback ? r.push(wP.of(t)) : n ? r.push(nC.computeN([Ie.darkTheme], (i) => i.facet(Ie.darkTheme) == (n == "dark") ? [t] : [])) : r.push(nC.of(t)), r;
}
class UZ {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = On(e.state), this.decorations = this.buildDeco(e, M2(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = On(e.state), n = M2(e.state), i = n != M2(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    r.length < o.to && !i && r.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (r != this.tree || e.viewportChanged || i) && (this.tree = r, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = o.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return ft.none;
    let n = new nc();
    for (let { from: i, to: o } of e.visibleRanges)
      SZ(this.tree, r, (s, a, l) => {
        n.add(s, a, this.markCache[l] || (this.markCache[l] = ft.mark({ class: l })));
      }, i, o);
    return n.finish();
  }
}
const HZ = /* @__PURE__ */ mc.high(/* @__PURE__ */ kn.fromClass(UZ, {
  decorations: (t) => t.decorations
})), VZ = /* @__PURE__ */ t0.define([
  {
    tag: oe.meta,
    color: "#404740"
  },
  {
    tag: oe.link,
    textDecoration: "underline"
  },
  {
    tag: oe.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: oe.emphasis,
    fontStyle: "italic"
  },
  {
    tag: oe.strong,
    fontWeight: "bold"
  },
  {
    tag: oe.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: oe.keyword,
    color: "#708"
  },
  {
    tag: [oe.atom, oe.bool, oe.url, oe.contentSeparator, oe.labelName],
    color: "#219"
  },
  {
    tag: [oe.literal, oe.inserted],
    color: "#164"
  },
  {
    tag: [oe.string, oe.deleted],
    color: "#a11"
  },
  {
    tag: [oe.regexp, oe.escape, /* @__PURE__ */ oe.special(oe.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ oe.definition(oe.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ oe.local(oe.variableName),
    color: "#30a"
  },
  {
    tag: [oe.typeName, oe.namespace],
    color: "#085"
  },
  {
    tag: oe.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ oe.special(oe.variableName), oe.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ oe.definition(oe.propertyName),
    color: "#00c"
  },
  {
    tag: oe.comment,
    color: "#940"
  },
  {
    tag: oe.invalid,
    color: "#f00"
  }
]), WZ = /* @__PURE__ */ Ie.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), CP = 1e4, _P = "()[]{}", SP = /* @__PURE__ */ Be.define({
  combine(t) {
    return ou(t, {
      afterCursor: !0,
      brackets: _P,
      maxScanDistance: CP,
      renderMatch: XZ
    });
  }
}), GZ = /* @__PURE__ */ ft.mark({ class: "cm-matchingBracket" }), KZ = /* @__PURE__ */ ft.mark({ class: "cm-nonmatchingBracket" });
function XZ(t) {
  let e = [], r = t.matched ? GZ : KZ;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const QZ = /* @__PURE__ */ qn.define({
  create() {
    return ft.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], n = e.state.facet(SP);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = Ra(e.state, i.head, -1, n) || i.head > 0 && Ra(e.state, i.head - 1, 1, n) || n.afterCursor && (Ra(e.state, i.head, 1, n) || i.head < e.state.doc.length && Ra(e.state, i.head + 1, -1, n));
      o && (r = r.concat(n.renderMatch(o, e.state)));
    }
    return ft.set(r, !0);
  },
  provide: (t) => Ie.decorations.from(t)
}), JZ = [
  QZ,
  WZ
];
function YZ(t = {}) {
  return [SP.of(t), JZ];
}
const ZZ = /* @__PURE__ */ new Rt();
function iC(t, e, r) {
  let n = t.prop(e < 0 ? Rt.openedBy : Rt.closedBy);
  if (n)
    return n;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [r[i + e]];
  }
  return null;
}
function oC(t) {
  let e = t.type.prop(ZZ);
  return e ? e(t.node) : t;
}
function Ra(t, e, r, n = {}) {
  let i = n.maxScanDistance || CP, o = n.brackets || _P, s = On(t), a = s.resolveInner(e, r);
  for (let l = a; l; l = l.parent) {
    let u = iC(l.type, r, o);
    if (u && l.from < l.to) {
      let c = oC(l);
      if (c && (r > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return eee(t, e, r, l, c, u, o);
    }
  }
  return tee(t, e, r, s, a.type, i, o);
}
function eee(t, e, r, n, i, o, s) {
  let a = n.parent, l = { from: i.from, to: i.to }, u = 0, c = a?.cursor();
  if (c && (r < 0 ? c.childBefore(n.from) : c.childAfter(n.to)))
    do
      if (r < 0 ? c.to <= n.from : c.from >= n.to) {
        if (u == 0 && o.indexOf(c.type.name) > -1 && c.from < c.to) {
          let h = oC(c);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (iC(c.type, r, s))
          u++;
        else if (iC(c.type, -r, s)) {
          if (u == 0) {
            let h = oC(c);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (r < 0 ? c.prevSibling() : c.nextSibling());
  return { start: l, matched: !1 };
}
function tee(t, e, r, n, i, o, s) {
  let a = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = s.indexOf(a);
  if (l < 0 || l % 2 == 0 != r > 0)
    return null;
  let u = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, c = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), h = 0;
  for (let d = 0; !c.next().done && d <= o; ) {
    let p = c.value;
    r < 0 && (d += p.length);
    let g = e + d * r;
    for (let v = r > 0 ? 0 : p.length - 1, y = r > 0 ? p.length : -1; v != y; v += r) {
      let b = s.indexOf(p[v]);
      if (!(b < 0 || n.resolveInner(g + v, 1).type != i))
        if (b % 2 == 0 == r > 0)
          h++;
        else {
          if (h == 1)
            return { start: u, end: { from: g + v, to: g + v + 1 }, matched: b >> 1 == l >> 1 };
          h--;
        }
    }
    r > 0 && (d += p.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const ree = /* @__PURE__ */ Object.create(null), $6 = [co.none], I6 = [], B6 = /* @__PURE__ */ Object.create(null), nee = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  nee[t] = /* @__PURE__ */ iee(ree, e);
function P2(t, e) {
  I6.indexOf(t) > -1 || (I6.push(t), console.warn(e));
}
function iee(t, e) {
  let r = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let u of a.split(".")) {
      let c = t[u] || oe[u];
      c ? typeof c == "function" ? l.length ? l = l.map(c) : P2(u, `Modifier ${u} used at start of tag`) : l.length ? P2(u, `Tag ${u} used as modifier`) : l = Array.isArray(c) ? c : [c] : P2(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of l)
      r.push(u);
  }
  if (!r.length)
    return 0;
  let n = e.replace(/ /g, "_"), i = n + " " + r.map((a) => a.id), o = B6[i];
  if (o)
    return o.id;
  let s = B6[i] = co.define({
    id: $6.length,
    name: n,
    props: [g4({ [n]: r })]
  });
  return $6.push(s), s.id;
}
zr.RTL, zr.LTR;
class AP {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesâ€”in the editor, the extension will create
  these for you.)
  */
  constructor(e, r, n, i) {
    this.state = e, this.pos = r, this.explicit = n, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = On(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), n = Math.max(r.from, this.pos - 250), i = r.text.slice(n - r.from, this.pos - r.from), o = i.search(DP(e, !1));
    return o < 0 ? null : { from: n + o, to: this.pos, text: i.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, r, n) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(r), n && n.onDocChange && (this.abortOnDocChange = !0));
  }
}
function L6(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function oee(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let o = 1; o < i.length; o++)
      r[i[o]] = !0;
  }
  let n = L6(e) + L6(r) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function EP(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [r, n] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : oee(e);
  return (i) => {
    let o = i.matchBefore(n);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: e, validFor: r } : null;
  };
}
function see(t, e) {
  return (r) => {
    for (let n = On(r.state).resolveInner(r.pos, -1); n; n = n.parent) {
      if (t.indexOf(n.name) > -1)
        return null;
      if (n.type.isTop)
        break;
    }
    return e(r);
  };
}
class z6 {
  constructor(e, r, n, i) {
    this.completion = e, this.source = r, this.match = n, this.score = i;
  }
}
function sh(t) {
  return t.selection.main.from;
}
function DP(t, e) {
  var r;
  let { source: n } = t, i = e && n[0] != "^", o = n[n.length - 1] != "$";
  return !i && !o ? t : new RegExp(`${i ? "^" : ""}(?:${n})${o ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const x4 = /* @__PURE__ */ iu.define();
function aee(t, e, r, n) {
  let { main: i } = t.selection, o = r - i.from, s = n - i.from;
  return {
    ...t.changeByRange((a) => {
      if (a != i && r != n && t.sliceDoc(a.from + o, a.from + s) != t.sliceDoc(r, n))
        return { range: a };
      let l = t.toText(e);
      return {
        changes: { from: a.from + o, to: n == i.from ? a.to : a.from + s, insert: l },
        range: de.cursor(a.from + o + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const j6 = /* @__PURE__ */ new WeakMap();
function lee(t) {
  if (!Array.isArray(t))
    return t;
  let e = j6.get(t);
  return e || j6.set(t, e = EP(t)), e;
}
const x1 = /* @__PURE__ */ kt.define(), lg = /* @__PURE__ */ kt.define();
class uee {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let n = Yi(e, r), i = Ea(n);
      this.chars.push(n);
      let o = e.slice(r, r + i), s = o.toUpperCase();
      this.folded.push(Yi(s == o ? o.toLowerCase() : s, 0)), r += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: r, folded: n, any: i, precise: o, byWord: s } = this;
    if (r.length == 1) {
      let k = Yi(e, 0), C = Ea(k), S = C == e.length ? 0 : -100;
      if (k != r[0]) if (k == n[0])
        S += -200;
      else
        return null;
      return this.ret(S, [0, C]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = r.length, u = 0;
    if (a < 0) {
      for (let k = 0, C = Math.min(e.length, 200); k < C && u < l; ) {
        let S = Yi(e, k);
        (S == r[u] || S == n[u]) && (i[u++] = k), k += Ea(S);
      }
      if (u < l)
        return null;
    }
    let c = 0, h = 0, d = !1, p = 0, g = -1, v = -1, y = /[a-z]/.test(e), b = !0;
    for (let k = 0, C = Math.min(e.length, 200), S = 0; k < C && h < l; ) {
      let _ = Yi(e, k);
      a < 0 && (c < l && _ == r[c] && (o[c++] = k), p < l && (_ == r[p] || _ == n[p] ? (p == 0 && (g = k), v = k + 1, p++) : p = 0));
      let D, A = _ < 255 ? _ >= 48 && _ <= 57 || _ >= 97 && _ <= 122 ? 2 : _ >= 65 && _ <= 90 ? 1 : 0 : (D = J_(_)) != D.toLowerCase() ? 1 : D != D.toUpperCase() ? 2 : 0;
      (!k || A == 1 && y || S == 0 && A != 0) && (r[h] == _ || n[h] == _ && (d = !0) ? s[h++] = k : s.length && (b = !1)), S = A, k += Ea(_);
    }
    return h == l && s[0] == 0 && b ? this.result(-100 + (d ? -200 : 0), s, e) : p == l && g == 0 ? this.ret(-200 - e.length + (v == e.length ? 0 : -100), [0, v]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : p == l ? this.ret(-900 - e.length, [g, v]) : h == l ? this.result(-100 + (d ? -200 : 0) + -700 + (b ? 0 : -1100), s, e) : r.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, n) {
    let i = [], o = 0;
    for (let s of r) {
      let a = s + (this.astral ? Ea(Yi(n, s)) : 1);
      o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
    }
    return this.ret(e - n.length, i);
  }
}
class cee {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let r = e.slice(0, this.pattern.length), n = r == this.pattern ? 0 : r.toLowerCase() == this.folded ? -200 : null;
    return n == null ? null : (this.matched = [0, r.length], this.score = n + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Bn = /* @__PURE__ */ Be.define({
  combine(t) {
    return ou(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: hee,
      filterStrict: !1,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (n) => q6(e(n), r(n)),
      optionClass: (e, r) => (n) => q6(e(n), r(n)),
      addToOptions: (e, r) => e.concat(r),
      filterStrict: (e, r) => e || r
    });
  }
});
function q6(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function hee(t, e, r, n, i, o) {
  let s = t.textDirection == zr.RTL, a = s, l = !1, u = "top", c, h, d = e.left - i.left, p = i.right - e.right, g = n.right - n.left, v = n.bottom - n.top;
  if (a && d < Math.min(g, p) ? a = !1 : !a && p < Math.min(g, d) && (a = !0), g <= (a ? d : p))
    c = Math.max(i.top, Math.min(r.top, i.bottom - v)) - e.top, h = Math.min(400, a ? d : p);
  else {
    l = !0, h = Math.min(
      400,
      (s ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let k = i.bottom - e.bottom;
    k >= v || k > e.top ? c = r.bottom - e.top : (u = "bottom", c = e.bottom - r.top);
  }
  let y = (e.bottom - e.top) / o.offsetHeight, b = (e.right - e.left) / o.offsetWidth;
  return {
    style: `${u}: ${c / y}px; max-width: ${h / b}px`,
    class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function fee(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), r.type && n.classList.add(...r.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(r, n, i, o) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let a = r.displayLabel || r.label, l = 0;
      for (let u = 0; u < o.length; ) {
        let c = o[u++], h = o[u++];
        c > l && s.appendChild(document.createTextNode(a.slice(l, c)));
        let d = s.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(a.slice(c, h))), d.className = "cm-completionMatchedText", l = h;
      }
      return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = r.detail, n;
    },
    position: 80
  }), e.sort((r, n) => r.position - n.position).map((r) => r.render);
}
function R2(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let n = Math.floor((t - e) / r);
  return { from: t - (n + 1) * r, to: t - n * r };
}
class dee {
  constructor(e, r, n) {
    this.view = e, this.stateField = r, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(r), { options: o, selected: s } = i.open, a = e.state.facet(Bn);
    this.optionContent = fee(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = R2(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: u } = e.state.field(r).open;
      for (let c = l.target, h; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (h = /-(\d+)$/.exec(c.id)) && +h[1] < u.length) {
          this.applyCompletion(e, u[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(Bn).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: lg.of(null) });
    }), this.showOptions(o, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let n = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), n != i) {
      let { options: o, selected: s, disabled: a } = n.open;
      (!i.open || i.open.options != o) && (this.range = R2(o.length, s, e.state.facet(Bn).maxRenderedOptions), this.showOptions(o, n.id)), this.updateSel(), a != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of r.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    (r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = R2(r.options.length, r.selected, this.view.state.facet(Bn).maxRenderedOptions), this.showOptions(r.options, e.id));
    let n = this.updateSelectedOption(r.selected);
    if (n) {
      this.destroyInfo();
      let { completion: i } = r.options[r.selected], { info: o } = i;
      if (!o)
        return;
      let s = typeof o == "string" ? document.createTextNode(o) : o(i);
      if (!s)
        return;
      "then" in s ? s.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, i);
      }).catch((a) => Ri(this.view.state, a, "completion info")) : (this.addInfoPane(s, i), n.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let n = this.info = document.createElement("div");
    if (n.className = "cm-tooltip cm-completionInfo", n.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), e.nodeType != null)
      n.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: o } = e;
      n.appendChild(i), this.infoDestroy = o || null;
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let n = this.list.firstChild, i = this.range.from; n; n = n.nextSibling, i++)
      n.nodeName != "LI" || !n.id ? i-- : i == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), r = n) : n.hasAttribute("aria-selected") && (n.removeAttribute("aria-selected"), n.removeAttribute("aria-describedby"));
    return r && mee(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
    if (!o) {
      let s = this.dom.ownerDocument.documentElement;
      o = { left: 0, top: 0, right: s.clientWidth, bottom: s.clientHeight };
    }
    return i.top > Math.min(o.bottom, r.bottom) - 10 || i.bottom < Math.max(o.top, r.top) + 10 ? null : this.view.state.facet(Bn).positionInfo(this.view, r, i, n, o, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, n) {
    const i = document.createElement("ul");
    i.id = r, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (s) => {
      s.target == i && s.preventDefault();
    });
    let o = null;
    for (let s = n.from; s < n.to; s++) {
      let { completion: a, match: l } = e[s], { section: u } = a;
      if (u) {
        let d = typeof u == "string" ? u : u.name;
        if (d != o && (s > n.from || n.from == 0))
          if (o = d, typeof u != "string" && u.header)
            i.appendChild(u.header(u));
          else {
            let p = i.appendChild(document.createElement("completion-section"));
            p.textContent = d;
          }
      }
      const c = i.appendChild(document.createElement("li"));
      c.id = r + "-" + s, c.setAttribute("role", "option");
      let h = this.optionClass(a);
      h && (c.className = h);
      for (let d of this.optionContent) {
        let p = d(a, this.view.state, this.view, l);
        p && c.appendChild(p);
      }
    }
    return n.from && i.classList.add("cm-completionListIncompleteTop"), n.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function pee(t, e) {
  return (r) => new dee(r, t, e);
}
function mee(t, e) {
  let r = t.getBoundingClientRect(), n = e.getBoundingClientRect(), i = r.height / t.offsetHeight;
  n.top < r.top ? t.scrollTop -= (r.top - n.top) / i : n.bottom > r.bottom && (t.scrollTop += (n.bottom - r.bottom) / i);
}
function U6(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function gee(t, e) {
  let r = [], n = null, i = null, o = (c) => {
    r.push(c);
    let { section: h } = c.completion;
    if (h) {
      n || (n = []);
      let d = typeof h == "string" ? h : h.name;
      n.some((p) => p.name == d) || n.push(typeof h == "string" ? { name: d } : h);
    }
  }, s = e.facet(Bn);
  for (let c of t)
    if (c.hasResult()) {
      let h = c.result.getMatch;
      if (c.result.filter === !1)
        for (let d of c.result.options)
          o(new z6(d, c.source, h ? h(d) : [], 1e9 - r.length));
      else {
        let d = e.sliceDoc(c.from, c.to), p, g = s.filterStrict ? new cee(d) : new uee(d);
        for (let v of c.result.options)
          if (p = g.match(v.label)) {
            let y = v.displayLabel ? h ? h(v, p.matched) : [] : p.matched, b = p.score + (v.boost || 0);
            if (o(new z6(v, c.source, y, b)), typeof v.section == "object" && v.section.rank === "dynamic") {
              let { name: k } = v.section;
              i || (i = /* @__PURE__ */ Object.create(null)), i[k] = Math.max(b, i[k] || -1e9);
            }
          }
      }
    }
  if (n) {
    let c = /* @__PURE__ */ Object.create(null), h = 0, d = (p, g) => (p.rank === "dynamic" && g.rank === "dynamic" ? i[g.name] - i[p.name] : 0) || (typeof p.rank == "number" ? p.rank : 1e9) - (typeof g.rank == "number" ? g.rank : 1e9) || (p.name < g.name ? -1 : 1);
    for (let p of n.sort(d))
      h -= 1e5, c[p.name] = h;
    for (let p of r) {
      let { section: g } = p.completion;
      g && (p.score += c[typeof g == "string" ? g : g.name]);
    }
  }
  let a = [], l = null, u = s.compareCompletions;
  for (let c of r.sort((h, d) => d.score - h.score || u(h.completion, d.completion))) {
    let h = c.completion;
    !l || l.label != h.label || l.detail != h.detail || l.type != null && h.type != null && l.type != h.type || l.apply != h.apply || l.boost != h.boost ? a.push(c) : U6(c.completion) > U6(l) && (a[a.length - 1] = c), l = c.completion;
  }
  return a;
}
class Rf {
  constructor(e, r, n, i, o, s) {
    this.options = e, this.attrs = r, this.tooltip = n, this.timestamp = i, this.selected = o, this.disabled = s;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new Rf(this.options, H6(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, n, i, o, s) {
    if (i && !s && e.some((u) => u.isPending))
      return i.setDisabled();
    let a = gee(e, r);
    if (!a.length)
      return i && e.some((u) => u.isPending) ? i.setDisabled() : null;
    let l = r.facet(Bn).selectOnOpen ? 0 : -1;
    if (i && i.selected != l && i.selected != -1) {
      let u = i.options[i.selected].completion;
      for (let c = 0; c < a.length; c++)
        if (a[c].completion == u) {
          l = c;
          break;
        }
    }
    return new Rf(a, H6(n, l), {
      pos: e.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: kee,
      above: o.aboveCursor
    }, i ? i.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Rf(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Rf(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class w1 {
  constructor(e, r, n) {
    this.active = e, this.id = r, this.open = n;
  }
  static start() {
    return new w1(xee, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, n = r.facet(Bn), i = (n.override || r.languageDataAt("autocomplete", sh(r)).map(lee)).map((a) => (this.active.find((l) => l.source == a) || new ms(
      a,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    i.length == this.active.length && i.every((a, l) => a == this.active[l]) && (i = this.active);
    let o = this.open, s = e.effects.some((a) => a.is(w4));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || i.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !vee(i, this.active) || s ? o = Rf.build(i, r, this.id, o, n, s) : o && o.disabled && !i.some((a) => a.isPending) && (o = null), !o && i.every((a) => !a.isPending) && i.some((a) => a.hasResult()) && (i = i.map((a) => a.hasResult() ? new ms(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(FP) && (o = o && o.setSelected(a.value, this.id));
    return i == this.active && o == this.open ? this : new w1(i, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? yee : bee;
  }
}
function vee(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, n = 0; ; ) {
    for (; r < t.length && !t[r].hasResult(); )
      r++;
    for (; n < e.length && !e[n].hasResult(); )
      n++;
    let i = r == t.length, o = n == e.length;
    if (i || o)
      return i == o;
    if (t[r++].result != e[n++].result)
      return !1;
  }
}
const yee = {
  "aria-autocomplete": "list"
}, bee = {};
function H6(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const xee = [];
function OP(t, e) {
  if (t.isUserEvent("input.complete")) {
    let n = t.annotation(x4);
    if (n && e.activateOnCompletion(n))
      return 12;
  }
  let r = t.isUserEvent("input.type");
  return r && e.activateOnTyping ? 5 : r ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class ms {
  constructor(e, r, n = !1) {
    this.source = e, this.state = r, this.explicit = n;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, r) {
    let n = OP(e, r), i = this;
    (n & 8 || n & 16 && this.touches(e)) && (i = new ms(
      i.source,
      0
      /* State.Inactive */
    )), n & 4 && i.state == 0 && (i = new ms(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, n);
    for (let o of e.effects)
      if (o.is(x1))
        i = new ms(i.source, 1, o.value);
      else if (o.is(lg))
        i = new ms(
          i.source,
          0
          /* State.Inactive */
        );
      else if (o.is(w4))
        for (let s of o.value)
          s.source == i.source && (i = s);
    return i;
  }
  updateFor(e, r) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(sh(e.state));
  }
}
class Gf extends ms {
  constructor(e, r, n, i, o, s) {
    super(e, 3, r), this.limit = n, this.result = i, this.from = o, this.to = s;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, r) {
    var n;
    if (!(r & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = sh(e.state);
    if (a > s || !i || r & 2 && (sh(e.startState) == this.from || a < this.limit))
      return new ms(
        this.source,
        r & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return wee(i.validFor, e.state, o, s) ? new Gf(this.source, this.explicit, l, i, o, s) : i.update && (i = i.update(i, o, s, new AP(e.state, a, !1))) ? new Gf(this.source, this.explicit, l, i, i.from, (n = i.to) !== null && n !== void 0 ? n : sh(e.state)) : new ms(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Gf(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new ms(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function wee(t, e, r, n) {
  if (!t)
    return !1;
  let i = e.sliceDoc(r, n);
  return typeof t == "function" ? t(i, r, n, e) : DP(t, !0).test(i);
}
const w4 = /* @__PURE__ */ kt.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), FP = /* @__PURE__ */ kt.define(), Zi = /* @__PURE__ */ qn.define({
  create() {
    return w1.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    h4.from(t, (e) => e.tooltip),
    Ie.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function k4(t, e) {
  const r = e.completion.apply || e.completion.label;
  let n = t.state.field(Zi).active.find((i) => i.source == e.source);
  return n instanceof Gf ? (typeof r == "string" ? t.dispatch({
    ...aee(t.state, r, n.from, n.to),
    annotations: x4.of(e.completion)
  }) : r(t, e.completion, n.from, n.to), !0) : !1;
}
const kee = /* @__PURE__ */ pee(Zi, k4);
function qv(t, e = "option") {
  return (r) => {
    let n = r.state.field(Zi, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < r.state.facet(Bn).interactionDelay)
      return !1;
    let i = 1, o;
    e == "page" && (o = aP(r, n.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = n.open.options, a = n.open.selected > -1 ? n.open.selected + i * (t ? 1 : -1) : t ? 0 : s - 1;
    return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), r.dispatch({ effects: FP.of(a) }), !0;
  };
}
const Cee = (t) => {
  let e = t.state.field(Zi, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Bn).interactionDelay ? !1 : k4(t, e.open.options[e.open.selected]);
}, N2 = (t) => t.state.field(Zi, !1) ? (t.dispatch({ effects: x1.of(!0) }), !0) : !1, _ee = (t) => {
  let e = t.state.field(Zi, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: lg.of(null) }), !0);
};
class See {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Aee = 50, Eee = 1e3, Dee = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(Zi).active)
      e.isPending && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(Zi), r = t.state.facet(Bn);
    if (!t.selectionSet && !t.docChanged && t.startState.field(Zi) == e)
      return;
    let n = t.transactions.some((o) => {
      let s = OP(o, r);
      return s & 8 || (o.selection || o.docChanged) && !(s & 3);
    });
    for (let o = 0; o < this.running.length; o++) {
      let s = this.running[o];
      if (n || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > Aee && Date.now() - s.time > Eee) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (l) {
            Ri(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(o--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((o) => o.effects.some((s) => s.is(x1))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : r.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((o) => o.isPending && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let o of t.transactions)
        o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(Zi);
    for (let r of e.active)
      r.isPending && !this.running.some((n) => n.active.source == r.source) && this.startQuery(r);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Bn).updateSyncTime));
  }
  startQuery(t) {
    let { state: e } = this.view, r = sh(e), n = new AP(e, r, t.explicit, this.view), i = new See(t, n);
    this.running.push(i), Promise.resolve(t.source(n)).then((o) => {
      i.context.aborted || (i.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: lg.of(null) }), Ri(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Bn).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(Bn), n = this.view.state.field(Zi);
    for (let i = 0; i < this.running.length; i++) {
      let o = this.running[i];
      if (o.done === void 0)
        continue;
      if (this.running.splice(i--, 1), o.done) {
        let a = sh(o.updates.length ? o.updates[0].startState : this.view.state), l = Math.min(a, o.done.from + (o.active.explicit ? 0 : 1)), u = new Gf(o.active.source, o.active.explicit, l, o.done, o.done.from, (t = o.done.to) !== null && t !== void 0 ? t : a);
        for (let c of o.updates)
          u = u.update(c, r);
        if (u.hasResult()) {
          e.push(u);
          continue;
        }
      }
      let s = n.active.find((a) => a.source == o.active.source);
      if (s && s.isPending)
        if (o.done == null) {
          let a = new ms(
            o.active.source,
            0
            /* State.Inactive */
          );
          for (let l of o.updates)
            a = a.update(l, r);
          a.isPending || e.push(a);
        } else
          this.startQuery(s);
    }
    (e.length || n.open && n.open.disabled) && this.view.dispatch({ effects: w4.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(Zi, !1);
      if (e && e.tooltip && this.view.state.facet(Bn).closeOnBlur) {
        let r = e.open && aP(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: lg.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: x1.of(!1) }), 20), this.composing = 0;
    }
  }
}), Oee = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Fee = /* @__PURE__ */ mc.highest(/* @__PURE__ */ Ie.domEventHandlers({
  keydown(t, e) {
    let r = e.state.field(Zi, !1);
    if (!r || !r.open || r.open.disabled || r.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(Oee && t.altKey) || t.metaKey)
      return !1;
    let n = r.open.options[r.open.selected], i = r.active.find((s) => s.source == n.source), o = n.completion.commitCharacters || i.result.commitCharacters;
    return o && o.indexOf(t.key) > -1 && k4(e, n), !1;
  }
})), TP = /* @__PURE__ */ Ie.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"Â·Â·Â·"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'Æ’'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'â—‹'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'â—Œ'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'ð‘¥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'ð¶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'ð‘¡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'âˆª'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'â–¡'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'ðŸ”‘ï¸Ž'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'â–¢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Tee {
  constructor(e, r, n, i) {
    this.field = e, this.line = r, this.from = n, this.to = i;
  }
}
class C4 {
  constructor(e, r, n) {
    this.field = e, this.from = r, this.to = n;
  }
  map(e) {
    let r = e.mapPos(this.from, -1, Kn.TrackDel), n = e.mapPos(this.to, 1, Kn.TrackDel);
    return r == null || n == null ? null : new C4(this.field, r, n);
  }
}
class _4 {
  constructor(e, r) {
    this.lines = e, this.fieldPositions = r;
  }
  instantiate(e, r) {
    let n = [], i = [r], o = e.doc.lineAt(r), s = /^\s*/.exec(o.text)[0];
    for (let l of this.lines) {
      if (n.length) {
        let u = s, c = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < c; h++)
          u += e.facet(zb);
        i.push(r + u.length - c), l = u + l.slice(c);
      }
      n.push(l), r += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new C4(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: n, ranges: a };
  }
  static parse(e) {
    let r = [], n = [], i = [], o;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; o = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(s); ) {
        let a = o[1] ? +o[1] : null, l = o[2] || o[3] || "", u = -1, c = l.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < r.length; h++)
          (a != null ? r[h].seq == a : c && r[h].name == c) && (u = h);
        if (u < 0) {
          let h = 0;
          for (; h < r.length && (a == null || r[h].seq != null && r[h].seq < a); )
            h++;
          r.splice(h, 0, { seq: a, name: c }), u = h;
          for (let d of i)
            d.field >= u && d.field++;
        }
        for (let h of i)
          if (h.line == n.length && h.from > o.index) {
            let d = o[2] ? 3 + (o[1] || "").length : 2;
            h.from -= d, h.to -= d;
          }
        i.push(new Tee(u, n.length, o.index, o.index + c.length)), s = s.slice(0, o.index) + l + s.slice(o.index + o[0].length);
      }
      s = s.replace(/\\([{}])/g, (a, l, u) => {
        for (let c of i)
          c.line == n.length && c.from > u && (c.from--, c.to--);
        return l;
      }), n.push(s);
    }
    return new _4(n, i);
  }
}
let Mee = /* @__PURE__ */ ft.widget({ widget: /* @__PURE__ */ new class extends Lh {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Pee = /* @__PURE__ */ ft.mark({ class: "cm-snippetField" });
class Yd {
  constructor(e, r) {
    this.ranges = e, this.active = r, this.deco = ft.set(e.map((n) => (n.from == n.to ? Mee : Pee).range(n.from, n.to)), !0);
  }
  map(e) {
    let r = [];
    for (let n of this.ranges) {
      let i = n.map(e);
      if (!i)
        return null;
      r.push(i);
    }
    return new Yd(r, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((r) => this.ranges.some((n) => n.field == this.active && n.from <= r.from && n.to >= r.to));
  }
}
const r0 = /* @__PURE__ */ kt.define({
  map(t, e) {
    return t && t.map(e);
  }
}), Ree = /* @__PURE__ */ kt.define(), ug = /* @__PURE__ */ qn.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let r of e.effects) {
      if (r.is(r0))
        return r.value;
      if (r.is(Ree) && t)
        return new Yd(t.ranges, r.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => Ie.decorations.from(t, (e) => e ? e.deco : ft.none)
});
function S4(t, e) {
  return de.create(t.filter((r) => r.field == e).map((r) => de.range(r.from, r.to)));
}
function Nee(t) {
  let e = _4.parse(t);
  return (r, n, i, o) => {
    let { text: s, ranges: a } = e.instantiate(r.state, i), { main: l } = r.state.selection, u = {
      changes: { from: i, to: o == l.from ? l.to : o, insert: or.of(s) },
      scrollIntoView: !0,
      annotations: n ? [x4.of(n), xn.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (u.selection = S4(a, 0)), a.some((c) => c.field > 0)) {
      let c = new Yd(a, 0), h = u.effects = [r0.of(c)];
      r.state.field(ug, !1) === void 0 && h.push(kt.appendConfig.of([ug, zee, qee, TP]));
    }
    r.dispatch(r.state.update(u));
  };
}
function MP(t) {
  return ({ state: e, dispatch: r }) => {
    let n = e.field(ug, !1);
    if (!n || t < 0 && n.active == 0)
      return !1;
    let i = n.active + t, o = t > 0 && !n.ranges.some((s) => s.field == i + t);
    return r(e.update({
      selection: S4(n.ranges, i),
      effects: r0.of(o ? null : new Yd(n.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const $ee = ({ state: t, dispatch: e }) => t.field(ug, !1) ? (e(t.update({ effects: r0.of(null) })), !0) : !1, Iee = /* @__PURE__ */ MP(1), Bee = /* @__PURE__ */ MP(-1), Lee = [
  { key: "Tab", run: Iee, shift: Bee },
  { key: "Escape", run: $ee }
], V6 = /* @__PURE__ */ Be.define({
  combine(t) {
    return t.length ? t[0] : Lee;
  }
}), zee = /* @__PURE__ */ mc.highest(/* @__PURE__ */ Bb.compute([V6], (t) => t.facet(V6)));
function jee(t, e) {
  return { ...e, apply: Nee(t) };
}
const qee = /* @__PURE__ */ Ie.domEventHandlers({
  mousedown(t, e) {
    let r = e.state.field(ug, !1), n;
    if (!r || (n = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let i = r.ranges.find((o) => o.from <= n && o.to >= n);
    return !i || i.field == r.active ? !1 : (e.dispatch({
      selection: S4(r.ranges, i.field),
      effects: r0.of(r.ranges.some((o) => o.field > i.field) ? new Yd(r.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), cg = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Hc = /* @__PURE__ */ kt.define({
  map(t, e) {
    return e.mapPos(t, -1, Kn.TrackAfter) ?? void 0;
  }
}), A4 = /* @__PURE__ */ new class extends xh {
}();
A4.startSide = 1;
A4.endSide = -1;
const PP = /* @__PURE__ */ qn.define({
  create() {
    return fr.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (n) => n >= r.from && n <= r.to });
    }
    for (let r of e.effects)
      r.is(Hc) && (t = t.update({ add: [A4.range(r.value, r.value + 1)] }));
    return t;
  }
});
function Uee() {
  return [Vee, PP];
}
const $2 = "()[]{}<>Â«Â»Â»Â«ï¼»ï¼½ï½›ï½";
function RP(t) {
  for (let e = 0; e < $2.length; e += 2)
    if ($2.charCodeAt(e) == t)
      return $2.charAt(e + 1);
  return J_(t < 128 ? t : t + 1);
}
function NP(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || cg;
}
const Hee = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Vee = /* @__PURE__ */ Ie.inputHandler.of((t, e, r, n) => {
  if ((Hee ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (n.length > 2 || n.length == 2 && Ea(Yi(n, 0)) == 1 || e != i.from || r != i.to)
    return !1;
  let o = Kee(t.state, n);
  return o ? (t.dispatch(o), !0) : !1;
}), Wee = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = NP(t, t.selection.main.head).brackets || cg.brackets, n = null, i = t.changeByRange((o) => {
    if (o.empty) {
      let s = Xee(t.doc, o.head);
      for (let a of r)
        if (a == s && qb(t.doc, o.head) == RP(Yi(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: de.cursor(o.head - a.length)
          };
    }
    return { range: n = o };
  });
  return n || e(t.update(i, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, Gee = [
  { key: "Backspace", run: Wee }
];
function Kee(t, e) {
  let r = NP(t, t.selection.main.head), n = r.brackets || cg.brackets;
  for (let i of n) {
    let o = RP(Yi(i, 0));
    if (e == i)
      return o == i ? Yee(t, i, n.indexOf(i + i + i) > -1, r) : Qee(t, i, o, r.before || cg.before);
    if (e == o && $P(t, t.selection.main.from))
      return Jee(t, i, o);
  }
  return null;
}
function $P(t, e) {
  let r = !1;
  return t.field(PP).between(0, t.doc.length, (n) => {
    n == e && (r = !0);
  }), r;
}
function qb(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, Ea(Yi(r, 0)));
}
function Xee(t, e) {
  let r = t.sliceString(e - 2, e);
  return Ea(Yi(r, 0)) == r.length ? r : r.slice(1);
}
function Qee(t, e, r, n) {
  let i = null, o = t.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: r, from: s.to }],
        effects: Hc.of(s.to + e.length),
        range: de.range(s.anchor + e.length, s.head + e.length)
      };
    let a = qb(t.doc, s.head);
    return !a || /\s/.test(a) || n.indexOf(a) > -1 ? {
      changes: { insert: e + r, from: s.head },
      effects: Hc.of(s.head + e.length),
      range: de.cursor(s.head + e.length)
    } : { range: i = s };
  });
  return i ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Jee(t, e, r) {
  let n = null, i = t.changeByRange((o) => o.empty && qb(t.doc, o.head) == r ? {
    changes: { from: o.head, to: o.head + r.length, insert: r },
    range: de.cursor(o.head + r.length)
  } : n = { range: o });
  return n ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Yee(t, e, r, n) {
  let i = n.stringPrefixes || cg.stringPrefixes, o = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Hc.of(a.to + e.length),
        range: de.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, u = qb(t.doc, l), c;
    if (u == e) {
      if (W6(t, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Hc.of(l + e.length),
          range: de.cursor(l + e.length)
        };
      if ($P(t, l)) {
        let h = r && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + h.length, insert: h },
          range: de.cursor(l + h.length)
        };
      }
    } else {
      if (r && t.sliceDoc(l - 2 * e.length, l) == e + e && (c = G6(t, l - 2 * e.length, i)) > -1 && W6(t, c))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Hc.of(l + e.length),
          range: de.cursor(l + e.length)
        };
      if (t.charCategorizer(l)(u) != Wr.Word && G6(t, l, i) > -1 && !Zee(t, l, e, i))
        return {
          changes: { insert: e + e, from: l },
          effects: Hc.of(l + e.length),
          range: de.cursor(l + e.length)
        };
    }
    return { range: o = a };
  });
  return o ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function W6(t, e) {
  let r = On(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function Zee(t, e, r, n) {
  let i = On(t).resolveInner(e, -1), o = n.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + o)), l = a.indexOf(r);
    if (!l || l > -1 && n.indexOf(a.slice(0, l)) > -1) {
      let c = i.firstChild;
      for (; c && c.from == i.from && c.to - c.from > r.length + l; ) {
        if (t.sliceDoc(c.to - r.length, c.to) == r)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = i.to == e && i.parent;
    if (!u)
      break;
    i = u;
  }
  return !1;
}
function G6(t, e, r) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != Wr.Word)
    return e;
  for (let i of r) {
    let o = e - i.length;
    if (t.sliceDoc(o, e) == i && n(t.sliceDoc(o - 1, o)) != Wr.Word)
      return o;
  }
  return -1;
}
function ete(t = {}) {
  return [
    Fee,
    Zi,
    Bn.of(t),
    Dee,
    tte,
    TP
  ];
}
const IP = [
  { key: "Ctrl-Space", run: N2 },
  { mac: "Alt-`", run: N2 },
  { mac: "Alt-i", run: N2 },
  { key: "Escape", run: _ee },
  { key: "ArrowDown", run: /* @__PURE__ */ qv(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ qv(!1) },
  { key: "PageDown", run: /* @__PURE__ */ qv(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ qv(!1, "page") },
  { key: "Enter", run: Cee }
], tte = /* @__PURE__ */ mc.highest(/* @__PURE__ */ Bb.computeN([Bn], (t) => t.facet(Bn).defaultKeymap ? [IP] : [])), rte = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), n = D4(t.state, r.from);
  return n.line ? nte(t) : n.block ? ote(t) : !1;
};
function E4(t, e) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly)
      return !1;
    let i = t(e, r);
    return i ? (n(r.update(i)), !0) : !1;
  };
}
const nte = /* @__PURE__ */ E4(
  lte,
  0
  /* CommentOption.Toggle */
), ite = /* @__PURE__ */ E4(
  BP,
  0
  /* CommentOption.Toggle */
), ote = /* @__PURE__ */ E4(
  (t, e) => BP(t, e, ate(e)),
  0
  /* CommentOption.Toggle */
);
function D4(t, e) {
  let r = t.languageDataAt("commentTokens", e, 1);
  return r.length ? r[0] : {};
}
const Yp = 50;
function ste(t, { open: e, close: r }, n, i) {
  let o = t.sliceDoc(n - Yp, n), s = t.sliceDoc(i, i + Yp), a = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(s)[0].length, u = o.length - a;
  if (o.slice(u - e.length, u) == e && s.slice(l, l + r.length) == r)
    return {
      open: { pos: n - a, margin: a && 1 },
      close: { pos: i + l, margin: l && 1 }
    };
  let c, h;
  i - n <= 2 * Yp ? c = h = t.sliceDoc(n, i) : (c = t.sliceDoc(n, n + Yp), h = t.sliceDoc(i - Yp, i));
  let d = /^\s*/.exec(c)[0].length, p = /\s*$/.exec(h)[0].length, g = h.length - p - r.length;
  return c.slice(d, d + e.length) == e && h.slice(g, g + r.length) == r ? {
    open: {
      pos: n + d + e.length,
      margin: /\s/.test(c.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: i - p - r.length,
      margin: /\s/.test(h.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
function ate(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let n = t.doc.lineAt(r.from), i = r.to <= n.to ? n : t.doc.lineAt(r.to);
    i.from > n.from && i.from == r.to && (i = r.to == n.to + 1 ? n : t.doc.lineAt(r.to - 1));
    let o = e.length - 1;
    o >= 0 && e[o].to > n.from ? e[o].to = i.to : e.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: i.to });
  }
  return e;
}
function BP(t, e, r = e.selection.ranges) {
  let n = r.map((o) => D4(e, o.from).block);
  if (!n.every((o) => o))
    return null;
  let i = r.map((o, s) => ste(e, n[s], o.from, o.to));
  if (t != 2 && !i.every((o) => o))
    return { changes: e.changes(r.map((o, s) => i[s] ? [] : [{ from: o.from, insert: n[s].open + " " }, { from: o.to, insert: " " + n[s].close }])) };
  if (t != 1 && i.some((o) => o)) {
    let o = [];
    for (let s = 0, a; s < i.length; s++)
      if (a = i[s]) {
        let l = n[s], { open: u, close: c } = a;
        o.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + l.close.length });
      }
    return { changes: o };
  }
  return null;
}
function lte(t, e, r = e.selection.ranges) {
  let n = [], i = -1;
  for (let { from: o, to: s } of r) {
    let a = n.length, l = 1e9, u = D4(e, o).line;
    if (u) {
      for (let c = o; c <= s; ) {
        let h = e.doc.lineAt(c);
        if (h.from > i && (o == s || s > h.from)) {
          i = h.from;
          let d = /^\s*/.exec(h.text)[0].length, p = d == h.length, g = h.text.slice(d, d + u.length) == u ? d : -1;
          d < h.text.length && d < l && (l = d), n.push({ line: h, comment: g, token: u, indent: d, empty: p, single: !1 });
        }
        c = h.to + 1;
      }
      if (l < 1e9)
        for (let c = a; c < n.length; c++)
          n[c].indent < n[c].line.text.length && (n[c].indent = l);
      n.length == a + 1 && (n[a].single = !0);
    }
  }
  if (t != 2 && n.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: a, token: l, indent: u, empty: c, single: h } of n)
      (h || !c) && o.push({ from: a.from + u, insert: l + " " });
    let s = e.changes(o);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (t != 1 && n.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: s, comment: a, token: l } of n)
      if (a >= 0) {
        let u = s.from + a, c = u + l.length;
        s.text[c - s.from] == " " && c++, o.push({ from: u, to: c });
      }
    return { changes: o };
  }
  return null;
}
const sC = /* @__PURE__ */ iu.define(), ute = /* @__PURE__ */ iu.define(), cte = /* @__PURE__ */ Be.define(), LP = /* @__PURE__ */ Be.define({
  combine(t) {
    return ou(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (n, i) => e(n, i) || r(n, i)
    });
  }
}), zP = /* @__PURE__ */ qn.define({
  create() {
    return Na.empty;
  },
  update(t, e) {
    let r = e.state.facet(LP), n = e.annotation(sC);
    if (n) {
      let l = ro.fromTransaction(e, n.selection), u = n.side, c = u == 0 ? t.undone : t.done;
      return l ? c = k1(c, c.length, r.minDepth, l) : c = UP(c, e.startState.selection), new Na(u == 0 ? n.rest : c, u == 0 ? c : n.rest);
    }
    let i = e.annotation(ute);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(xn.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let o = ro.fromTransaction(e), s = e.annotation(xn.time), a = e.annotation(xn.userEvent);
    return o ? t = t.addChanges(o, s, a, r, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, r.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Na(t.done.map(ro.fromJSON), t.undone.map(ro.fromJSON));
  }
});
function hte(t = {}) {
  return [
    zP,
    LP.of(t),
    Ie.domEventHandlers({
      beforeinput(e, r) {
        let n = e.inputType == "historyUndo" ? jP : e.inputType == "historyRedo" ? aC : null;
        return n ? (e.preventDefault(), n(r)) : !1;
      }
    })
  ];
}
function Ub(t, e) {
  return function({ state: r, dispatch: n }) {
    if (!e && r.readOnly)
      return !1;
    let i = r.field(zP, !1);
    if (!i)
      return !1;
    let o = i.pop(t, r, e);
    return o ? (n(o), !0) : !1;
  };
}
const jP = /* @__PURE__ */ Ub(0, !1), aC = /* @__PURE__ */ Ub(1, !1), fte = /* @__PURE__ */ Ub(0, !0), dte = /* @__PURE__ */ Ub(1, !0);
class ro {
  constructor(e, r, n, i, o) {
    this.changes = e, this.effects = r, this.mapped = n, this.startSelection = i, this.selectionsAfter = o;
  }
  setSelAfter(e) {
    return new ro(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new ro(e.changes && Dn.fromJSON(e.changes), [], e.mapped && Ua.fromJSON(e.mapped), e.startSelection && de.fromJSON(e.startSelection), e.selectionsAfter.map(de.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let n = gs;
    for (let i of e.startState.facet(cte)) {
      let o = i(e);
      o.length && (n = n.concat(o));
    }
    return !n.length && e.changes.empty ? null : new ro(e.changes.invert(e.startState.doc), n, void 0, r || e.startState.selection, gs);
  }
  static selection(e) {
    return new ro(void 0, gs, void 0, void 0, e);
  }
}
function k1(t, e, r, n) {
  let i = e + 1 > r + 20 ? e - r - 1 : 0, o = t.slice(i, e);
  return o.push(n), o;
}
function pte(t, e) {
  let r = [], n = !1;
  return t.iterChangedRanges((i, o) => r.push(i, o)), e.iterChangedRanges((i, o, s, a) => {
    for (let l = 0; l < r.length; ) {
      let u = r[l++], c = r[l++];
      a >= u && s <= c && (n = !0);
    }
  }), n;
}
function mte(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, n) => r.empty != e.ranges[n].empty).length === 0;
}
function qP(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const gs = [], gte = 200;
function UP(t, e) {
  if (t.length) {
    let r = t[t.length - 1], n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - gte));
    return n.length && n[n.length - 1].eq(e) ? t : (n.push(e), k1(t, t.length - 1, 1e9, r.setSelAfter(n)));
  } else
    return [ro.selection([e])];
}
function vte(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function I2(t, e) {
  if (!t.length)
    return t;
  let r = t.length, n = gs;
  for (; r; ) {
    let i = yte(t[r - 1], e, n);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let o = t.slice(0, r);
      return o[r - 1] = i, o;
    } else
      e = i.mapped, r--, n = i.selectionsAfter;
  }
  return n.length ? [ro.selection(n)] : gs;
}
function yte(t, e, r) {
  let n = qP(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : gs, r);
  if (!t.changes)
    return ro.selection(n);
  let i = t.changes.map(e), o = e.mapDesc(t.changes, !0), s = t.mapped ? t.mapped.composeDesc(o) : o;
  return new ro(i, kt.mapEffects(t.effects, e), s, t.startSelection.map(o), n);
}
const bte = /^(input\.type|delete)($|\.)/;
class Na {
  constructor(e, r, n = 0, i = void 0) {
    this.done = e, this.undone = r, this.prevTime = n, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new Na(this.done, this.undone) : this;
  }
  addChanges(e, r, n, i, o) {
    let s = this.done, a = s[s.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!n || bte.test(n)) && (!a.selectionsAfter.length && r - this.prevTime < i.newGroupDelay && i.joinToEvent(o, pte(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? s = k1(s, s.length - 1, i.minDepth, new ro(e.changes.compose(a.changes), qP(kt.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, gs)) : s = k1(s, s.length, i.minDepth, e), new Na(s, gs, r, n);
  }
  addSelection(e, r, n, i) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : gs;
    return o.length > 0 && r - this.prevTime < i && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && mte(o[o.length - 1], e) ? this : new Na(UP(this.done, e), this.undone, r, n);
  }
  addMapping(e) {
    return new Na(I2(this.done, e), I2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, n) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let o = i[i.length - 1], s = o.selectionsAfter[0] || r.selection;
    if (n && o.selectionsAfter.length)
      return r.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: sC.of({ side: e, rest: vte(i), selection: s }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let a = i.length == 1 ? gs : i.slice(0, i.length - 1);
      return o.mapped && (a = I2(a, o.mapped)), r.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: sC.of({ side: e, rest: a, selection: s }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Na.empty = /* @__PURE__ */ new Na(gs, gs);
const xte = [
  { key: "Mod-z", run: jP, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: aC, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: aC, preventDefault: !0 },
  { key: "Mod-u", run: fte, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: dte, preventDefault: !0 }
];
function Zd(t, e) {
  return de.create(t.ranges.map(e), t.mainIndex);
}
function oa(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function sa({ state: t, dispatch: e }, r) {
  let n = Zd(t.selection, r);
  return n.eq(t.selection, !0) ? !1 : (e(oa(t, n)), !0);
}
function Hb(t, e) {
  return de.cursor(e ? t.to : t.from);
}
function HP(t, e) {
  return sa(t, (r) => r.empty ? t.moveByChar(r, e) : Hb(r, e));
}
function xi(t) {
  return t.textDirectionAt(t.state.selection.main.head) == zr.LTR;
}
const VP = (t) => HP(t, !xi(t)), WP = (t) => HP(t, xi(t));
function GP(t, e) {
  return sa(t, (r) => r.empty ? t.moveByGroup(r, e) : Hb(r, e));
}
const wte = (t) => GP(t, !xi(t)), kte = (t) => GP(t, xi(t));
function Cte(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let n = e.to - e.from;
  return n && (n > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Vb(t, e, r) {
  let n = On(t).resolveInner(e.head), i = r ? Rt.closedBy : Rt.openedBy;
  for (let l = e.head; ; ) {
    let u = r ? n.childAfter(l) : n.childBefore(l);
    if (!u)
      break;
    Cte(t, u, i) ? n = u : l = r ? u.to : u.from;
  }
  let o = n.type.prop(i), s, a;
  return o && (s = r ? Ra(t, n.from, 1) : Ra(t, n.to, -1)) && s.matched ? a = r ? s.end.to : s.end.from : a = r ? n.to : n.from, de.cursor(a, r ? -1 : 1);
}
const _te = (t) => sa(t, (e) => Vb(t.state, e, !xi(t))), Ste = (t) => sa(t, (e) => Vb(t.state, e, xi(t)));
function KP(t, e) {
  return sa(t, (r) => {
    if (!r.empty)
      return Hb(r, e);
    let n = t.moveVertically(r, e);
    return n.head != r.head ? n : t.moveToLineBoundary(r, e);
  });
}
const XP = (t) => KP(t, !1), QP = (t) => KP(t, !0);
function JP(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, n = 0, i;
  if (e) {
    for (let o of t.state.facet(Ie.scrollMargins)) {
      let s = o(t);
      s?.top && (r = Math.max(s?.top, r)), s?.bottom && (n = Math.max(s?.bottom, n));
    }
    i = t.scrollDOM.clientHeight - r - n;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: n,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function YP(t, e) {
  let r = JP(t), { state: n } = t, i = Zd(n.selection, (s) => s.empty ? t.moveVertically(s, e, r.height) : Hb(s, e));
  if (i.eq(n.selection))
    return !1;
  let o;
  if (r.selfScroll) {
    let s = t.coordsAtPos(n.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + r.marginTop, u = a.bottom - r.marginBottom;
    s && s.top > l && s.bottom < u && (o = Ie.scrollIntoView(i.main.head, { y: "start", yMargin: s.top - l }));
  }
  return t.dispatch(oa(n, i), { effects: o }), !0;
}
const K6 = (t) => YP(t, !1), lC = (t) => YP(t, !0);
function gc(t, e, r) {
  let n = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, r);
  if (i.head == e.head && i.head != (r ? n.to : n.from) && (i = t.moveToLineBoundary(e, r, !1)), !r && i.head == n.from && n.length) {
    let o = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    o && e.head != n.from + o && (i = de.cursor(n.from + o));
  }
  return i;
}
const Ate = (t) => sa(t, (e) => gc(t, e, !0)), Ete = (t) => sa(t, (e) => gc(t, e, !1)), Dte = (t) => sa(t, (e) => gc(t, e, !xi(t))), Ote = (t) => sa(t, (e) => gc(t, e, xi(t))), Fte = (t) => sa(t, (e) => de.cursor(t.lineBlockAt(e.head).from, 1)), Tte = (t) => sa(t, (e) => de.cursor(t.lineBlockAt(e.head).to, -1));
function Mte(t, e, r) {
  let n = !1, i = Zd(t.selection, (o) => {
    let s = Ra(t, o.head, -1) || Ra(t, o.head, 1) || o.head > 0 && Ra(t, o.head - 1, 1) || o.head < t.doc.length && Ra(t, o.head + 1, -1);
    if (!s || !s.end)
      return o;
    n = !0;
    let a = s.start.from == o.head ? s.end.to : s.end.from;
    return de.cursor(a);
  });
  return n ? (e(oa(t, i)), !0) : !1;
}
const Pte = ({ state: t, dispatch: e }) => Mte(t, e);
function Ss(t, e) {
  let r = Zd(t.state.selection, (n) => {
    let i = e(n);
    return de.range(n.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(oa(t.state, r)), !0);
}
function ZP(t, e) {
  return Ss(t, (r) => t.moveByChar(r, e));
}
const eR = (t) => ZP(t, !xi(t)), tR = (t) => ZP(t, xi(t));
function rR(t, e) {
  return Ss(t, (r) => t.moveByGroup(r, e));
}
const Rte = (t) => rR(t, !xi(t)), Nte = (t) => rR(t, xi(t)), $te = (t) => Ss(t, (e) => Vb(t.state, e, !xi(t))), Ite = (t) => Ss(t, (e) => Vb(t.state, e, xi(t)));
function nR(t, e) {
  return Ss(t, (r) => t.moveVertically(r, e));
}
const iR = (t) => nR(t, !1), oR = (t) => nR(t, !0);
function sR(t, e) {
  return Ss(t, (r) => t.moveVertically(r, e, JP(t).height));
}
const X6 = (t) => sR(t, !1), Q6 = (t) => sR(t, !0), Bte = (t) => Ss(t, (e) => gc(t, e, !0)), Lte = (t) => Ss(t, (e) => gc(t, e, !1)), zte = (t) => Ss(t, (e) => gc(t, e, !xi(t))), jte = (t) => Ss(t, (e) => gc(t, e, xi(t))), qte = (t) => Ss(t, (e) => de.cursor(t.lineBlockAt(e.head).from)), Ute = (t) => Ss(t, (e) => de.cursor(t.lineBlockAt(e.head).to)), J6 = ({ state: t, dispatch: e }) => (e(oa(t, { anchor: 0 })), !0), Y6 = ({ state: t, dispatch: e }) => (e(oa(t, { anchor: t.doc.length })), !0), Z6 = ({ state: t, dispatch: e }) => (e(oa(t, { anchor: t.selection.main.anchor, head: 0 })), !0), e8 = ({ state: t, dispatch: e }) => (e(oa(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), Hte = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), Vte = ({ state: t, dispatch: e }) => {
  let r = Wb(t).map(({ from: n, to: i }) => de.range(n, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: de.create(r), userEvent: "select" })), !0;
}, Wte = ({ state: t, dispatch: e }) => {
  let r = Zd(t.selection, (n) => {
    let i = On(t), o = i.resolveStack(n.from, 1);
    if (n.empty) {
      let s = i.resolveStack(n.from, -1);
      s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s);
    }
    for (let s = o; s; s = s.next) {
      let { node: a } = s;
      if ((a.from < n.from && a.to >= n.to || a.to > n.to && a.from <= n.from) && s.next)
        return de.range(a.to, a.from);
    }
    return n;
  });
  return r.eq(t.selection) ? !1 : (e(oa(t, r)), !0);
};
function aR(t, e) {
  let { state: r } = t, n = r.selection, i = r.selection.ranges.slice();
  for (let o of r.selection.ranges) {
    let s = r.doc.lineAt(o.head);
    if (e ? s.to < t.state.doc.length : s.from > 0)
      for (let a = o; ; ) {
        let l = t.moveVertically(a, e);
        if (l.head < s.from || l.head > s.to) {
          i.some((u) => u.head == l.head) || i.push(l);
          break;
        } else {
          if (l.head == a.head)
            break;
          a = l;
        }
      }
  }
  return i.length == n.ranges.length ? !1 : (t.dispatch(oa(r, de.create(i, i.length - 1))), !0);
}
const Gte = (t) => aR(t, !1), Kte = (t) => aR(t, !0), Xte = ({ state: t, dispatch: e }) => {
  let r = t.selection, n = null;
  return r.ranges.length > 1 ? n = de.create([r.main]) : r.main.empty || (n = de.create([de.cursor(r.main.head)])), n ? (e(oa(t, n)), !0) : !1;
};
function n0(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: n } = t, i = n.changeByRange((o) => {
    let { from: s, to: a } = o;
    if (s == a) {
      let l = e(o);
      l < s ? (r = "delete.backward", l = Uv(t, l, !1)) : l > s && (r = "delete.forward", l = Uv(t, l, !0)), s = Math.min(s, l), a = Math.max(a, l);
    } else
      s = Uv(t, s, !1), a = Uv(t, a, !0);
    return s == a ? { range: o } : { changes: { from: s, to: a }, range: de.cursor(s, s < o.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(n.update(i, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? Ie.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function Uv(t, e, r) {
  if (t instanceof Ie)
    for (let n of t.state.facet(Ie.atomicRanges).map((i) => i(t)))
      n.between(e, e, (i, o) => {
        i < e && o > e && (e = r ? o : i);
      });
  return e;
}
const lR = (t, e, r) => n0(t, (n) => {
  let i = n.from, { state: o } = t, s = o.doc.lineAt(i), a, l;
  if (r && !e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
    if (a[a.length - 1] == "	")
      return i - 1;
    let u = Jd(a, o.tabSize), c = u % b1(o) || b1(o);
    for (let h = 0; h < c && a[a.length - 1 - h] == " "; h++)
      i--;
    l = i;
  } else
    l = Xn(s.text, i - s.from, e, e) + s.from, l == i && s.number != (e ? o.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, i - s.from)) && (l = Xn(s.text, l - s.from, !1, !1) + s.from);
  return l;
}), uC = (t) => lR(t, !1, !0), uR = (t) => lR(t, !0, !1), cR = (t, e) => n0(t, (r) => {
  let n = r.head, { state: i } = t, o = i.doc.lineAt(n), s = i.charCategorizer(n);
  for (let a = null; ; ) {
    if (n == (e ? o.to : o.from)) {
      n == r.head && o.number != (e ? i.doc.lines : 1) && (n += e ? 1 : -1);
      break;
    }
    let l = Xn(o.text, n - o.from, e) + o.from, u = o.text.slice(Math.min(n, l) - o.from, Math.max(n, l) - o.from), c = s(u);
    if (a != null && c != a)
      break;
    (u != " " || n != r.head) && (a = c), n = l;
  }
  return n;
}), hR = (t) => cR(t, !1), Qte = (t) => cR(t, !0), Jte = (t) => n0(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), Yte = (t) => n0(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), Zte = (t) => n0(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), ere = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: or.of(["", ""]) },
    range: de.cursor(n.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, tre = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == t.doc.length)
      return { range: n };
    let i = n.from, o = t.doc.lineAt(i), s = i == o.from ? i - 1 : Xn(o.text, i - o.from, !1) + o.from, a = i == o.to ? i + 1 : Xn(o.text, i - o.from, !0) + o.from;
    return {
      changes: { from: s, to: a, insert: t.doc.slice(i, a).append(t.doc.slice(s, i)) },
      range: de.cursor(a)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Wb(t) {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from), o = t.doc.lineAt(n.to);
    if (!n.empty && n.to == o.from && (o = t.doc.lineAt(n.to - 1)), r >= i.number) {
      let s = e[e.length - 1];
      s.to = o.to, s.ranges.push(n);
    } else
      e.push({ from: i.from, to: o.to, ranges: [n] });
    r = o.number + 1;
  }
  return e;
}
function fR(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [], i = [];
  for (let o of Wb(t)) {
    if (r ? o.to == t.doc.length : o.from == 0)
      continue;
    let s = t.doc.lineAt(r ? o.to + 1 : o.from - 1), a = s.length + 1;
    if (r) {
      n.push({ from: o.to, to: s.to }, { from: o.from, insert: s.text + t.lineBreak });
      for (let l of o.ranges)
        i.push(de.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
    } else {
      n.push({ from: s.from, to: o.from }, { from: o.to, insert: t.lineBreak + s.text });
      for (let l of o.ranges)
        i.push(de.range(l.anchor - a, l.head - a));
    }
  }
  return n.length ? (e(t.update({
    changes: n,
    scrollIntoView: !0,
    selection: de.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const rre = ({ state: t, dispatch: e }) => fR(t, e, !1), nre = ({ state: t, dispatch: e }) => fR(t, e, !0);
function dR(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [];
  for (let i of Wb(t))
    r ? n.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : n.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const ire = ({ state: t, dispatch: e }) => dR(t, e, !1), ore = ({ state: t, dispatch: e }) => dR(t, e, !0), sre = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(Wb(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, { from: i, to: o }))), n = Zd(e.selection, (i) => {
    let o;
    if (t.lineWrapping) {
      let s = t.lineBlockAt(i.head), a = t.coordsAtPos(i.head, i.assoc || 1);
      a && (o = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(i, !0, o);
  }).map(r);
  return t.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function are(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = On(t).resolveInner(e), n = r.childBefore(e), i = r.childAfter(e), o;
  return n && i && n.to <= e && i.from >= e && (o = n.type.prop(Rt.closedBy)) && o.indexOf(i.name) > -1 && t.doc.lineAt(n.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(n.to, i.from)) ? { from: n.to, to: i.from } : null;
}
const t8 = /* @__PURE__ */ pR(!1), lre = /* @__PURE__ */ pR(!0);
function pR(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let n = e.changeByRange((i) => {
      let { from: o, to: s } = i, a = e.doc.lineAt(o), l = !t && o == s && are(e, o);
      t && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
      let u = new jb(e, { simulateBreak: o, simulateDoubleBreak: !!l }), c = v4(u, o);
      for (c == null && (c = Jd(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
        s++;
      l ? { from: o, to: s } = l : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
      let h = ["", ag(e, c)];
      return l && h.push(ag(e, u.lineIndent(a.from, -1))), {
        changes: { from: o, to: s, insert: or.of(h) },
        range: de.cursor(o + 1 + h[1].length)
      };
    });
    return r(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function O4(t, e) {
  let r = -1;
  return t.changeByRange((n) => {
    let i = [];
    for (let s = n.from; s <= n.to; ) {
      let a = t.doc.lineAt(s);
      a.number > r && (n.empty || n.to > a.from) && (e(a, i, n), r = a.number), s = a.to + 1;
    }
    let o = t.changes(i);
    return {
      changes: i,
      range: de.range(o.mapPos(n.anchor, 1), o.mapPos(n.head, 1))
    };
  });
}
const ure = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), n = new jb(t, { overrideIndentation: (o) => r[o] ?? -1 }), i = O4(t, (o, s, a) => {
    let l = v4(n, o.from);
    if (l == null)
      return;
    /\S/.test(o.text) || (l = 0);
    let u = /^\s*/.exec(o.text)[0], c = ag(t, l);
    (u != c || a.from < o.from + u.length) && (r[o.from] = l, s.push({ from: o.from, to: o.from + u.length, insert: c }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, mR = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(O4(t, (r, n) => {
  n.push({ from: r.from, insert: t.facet(zb) });
}), { userEvent: "input.indent" })), !0), gR = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(O4(t, (r, n) => {
  let i = /^\s*/.exec(r.text)[0];
  if (!i)
    return;
  let o = Jd(i, t.tabSize), s = 0, a = ag(t, Math.max(0, o - b1(t)));
  for (; s < i.length && s < a.length && i.charCodeAt(s) == a.charCodeAt(s); )
    s++;
  n.push({ from: r.from + s, to: r.from + i.length, insert: a.slice(s) });
}), { userEvent: "delete.dedent" })), !0), cre = (t) => (t.setTabFocusMode(), !0), hre = ({ state: t, dispatch: e }) => t.selection.ranges.some((r) => !r.empty) ? mR({ state: t, dispatch: e }) : (e(t.update(t.replaceSelection("	"), { scrollIntoView: !0, userEvent: "input" })), !0), fre = [
  { key: "Ctrl-b", run: VP, shift: eR, preventDefault: !0 },
  { key: "Ctrl-f", run: WP, shift: tR },
  { key: "Ctrl-p", run: XP, shift: iR },
  { key: "Ctrl-n", run: QP, shift: oR },
  { key: "Ctrl-a", run: Fte, shift: qte },
  { key: "Ctrl-e", run: Tte, shift: Ute },
  { key: "Ctrl-d", run: uR },
  { key: "Ctrl-h", run: uC },
  { key: "Ctrl-k", run: Jte },
  { key: "Ctrl-Alt-h", run: hR },
  { key: "Ctrl-o", run: ere },
  { key: "Ctrl-t", run: tre },
  { key: "Ctrl-v", run: lC }
], dre = /* @__PURE__ */ [
  { key: "ArrowLeft", run: VP, shift: eR, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: wte, shift: Rte, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: Dte, shift: zte, preventDefault: !0 },
  { key: "ArrowRight", run: WP, shift: tR, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: kte, shift: Nte, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: Ote, shift: jte, preventDefault: !0 },
  { key: "ArrowUp", run: XP, shift: iR, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: J6, shift: Z6 },
  { mac: "Ctrl-ArrowUp", run: K6, shift: X6 },
  { key: "ArrowDown", run: QP, shift: oR, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Y6, shift: e8 },
  { mac: "Ctrl-ArrowDown", run: lC, shift: Q6 },
  { key: "PageUp", run: K6, shift: X6 },
  { key: "PageDown", run: lC, shift: Q6 },
  { key: "Home", run: Ete, shift: Lte, preventDefault: !0 },
  { key: "Mod-Home", run: J6, shift: Z6 },
  { key: "End", run: Ate, shift: Bte, preventDefault: !0 },
  { key: "Mod-End", run: Y6, shift: e8 },
  { key: "Enter", run: t8, shift: t8 },
  { key: "Mod-a", run: Hte },
  { key: "Backspace", run: uC, shift: uC, preventDefault: !0 },
  { key: "Delete", run: uR, preventDefault: !0 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: hR, preventDefault: !0 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Qte, preventDefault: !0 },
  { mac: "Mod-Backspace", run: Yte, preventDefault: !0 },
  { mac: "Mod-Delete", run: Zte, preventDefault: !0 }
].concat(/* @__PURE__ */ fre.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), pre = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: _te, shift: $te },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: Ste, shift: Ite },
  { key: "Alt-ArrowUp", run: rre },
  { key: "Shift-Alt-ArrowUp", run: ire },
  { key: "Alt-ArrowDown", run: nre },
  { key: "Shift-Alt-ArrowDown", run: ore },
  { key: "Mod-Alt-ArrowUp", run: Gte },
  { key: "Mod-Alt-ArrowDown", run: Kte },
  { key: "Escape", run: Xte },
  { key: "Mod-Enter", run: lre },
  { key: "Alt-l", mac: "Ctrl-l", run: Vte },
  { key: "Mod-i", run: Wte, preventDefault: !0 },
  { key: "Mod-[", run: gR },
  { key: "Mod-]", run: mR },
  { key: "Mod-Alt-\\", run: ure },
  { key: "Shift-Mod-k", run: sre },
  { key: "Shift-Mod-\\", run: Pte },
  { key: "Mod-/", run: rte },
  { key: "Alt-A", run: ite },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: cre }
].concat(dre);
class C1 {
  /**
  @internal
  */
  constructor(e, r, n, i, o, s, a, l, u, c = 0, h) {
    this.p = e, this.stack = r, this.state = n, this.reducePos = i, this.pos = o, this.score = s, this.buffer = a, this.bufferBase = l, this.curContext = u, this.lookAhead = c, this.parent = h;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, r, n = 0) {
    let i = e.parser.context;
    return new C1(e, [], r, n, n, 0, [], 0, i ? new r8(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var r;
    let n = e >> 19, i = e & 65535, { parser: o } = this.p, s = this.reducePos < this.pos - 25;
    s && this.setLookAhead(this.pos);
    let a = o.dynamicPrecedence(i);
    if (a && (this.score += a), n == 0) {
      this.pushState(o.getGoto(this.state, i, !0), this.reducePos), i < o.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, s ? 8 : 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let l = this.stack.length - (n - 1) * 3 - (e & 262144 ? 6 : 0), u = l ? this.stack[l - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((r = this.p.parser.nodeSet.types[i]) === null || r === void 0) && r.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let h = l ? this.stack[l - 1] : 0, d = this.bufferBase + this.buffer.length - h;
    if (i < o.minRepeatTerm || e & 131072) {
      let p = o.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, u, p, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let p = this.stack[l - 3];
      this.state = o.getGoto(p, i, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(i, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, r, n, i = 4, o = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (r == n)
          return;
        if (s.buffer[a - 2] >= r) {
          s.buffer[a - 2] = n;
          return;
        }
      }
    }
    if (!o || this.pos == n)
      this.buffer.push(e, r, n, i);
    else {
      let s = this.buffer.length;
      if (s > 0 && (this.buffer[s - 4] != 0 || this.buffer[s - 1] < 0)) {
        let a = !1;
        for (let l = s; l > 0 && this.buffer[l - 2] > n; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; s > 0 && this.buffer[s - 2] > n; )
            this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, i > 4 && (i -= 4);
      }
      this.buffer[s] = e, this.buffer[s + 1] = r, this.buffer[s + 2] = n, this.buffer[s + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, r, n, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let o = e, { parser: s } = this.p;
      (i > this.pos || r <= s.maxNode) && (this.pos = i, s.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(o, n), this.shiftContext(r, n), r <= s.maxNode && this.buffer.push(r, n, i, 4);
    } else
      this.pos = i, this.shiftContext(r, n), r <= this.p.parser.maxNode && this.buffer.push(r, n, i, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, r, n, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, n, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, r) {
    let n = this.p.reused.length - 1;
    (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(r, i), this.buffer.push(
      n,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; )
      r -= 4;
    let n = e.buffer.slice(r), i = e.bufferBase + r;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new C1(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, r) {
    let n = e <= this.p.parser.maxNode;
    n && this.storeNode(e, this.pos, r, 4), this.storeNode(0, this.pos, r, n ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let r = new mre(this); ; ) {
      let n = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, e);
      if (n == 0)
        return !1;
      if ((n & 65536) == 0)
        return !0;
      r.reduce(n);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, s; o < r.length; o += 2)
        (s = r[o + 1]) != this.state && this.p.parser.hasAction(s, e) && i.push(r[o], s);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 8 && o < r.length; o += 2) {
          let s = r[o + 1];
          i.some((a, l) => l & 1 && a == s) || i.push(r[o], s);
        }
      r = i;
    }
    let n = [];
    for (let i = 0; i < r.length && n.length < 4; i += 2) {
      let o = r[i + 1];
      if (o == this.state)
        continue;
      let s = this.split();
      s.pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(r[i], this.pos), s.reducePos = this.pos, s.score -= 200, n.push(s);
    }
    return n;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, r = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((r & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, r)) {
      let n = r >> 19, i = r & 65535, o = this.stack.length - n * 3;
      if (o < 0 || e.getGoto(this.stack[o], i, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return !1;
        r = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, r = [], n = (i, o) => {
      if (!r.includes(i))
        return r.push(i), e.allActions(i, (s) => {
          if (!(s & 393216)) if (s & 65536) {
            let a = (s >> 19) - o;
            if (a > 1) {
              let l = s & 65535, u = this.stack.length - a * 3;
              if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                return a << 19 | 65536 | l;
            }
          } else {
            let a = n(s, o + 1);
            if (a != null)
              return a;
          }
        });
    };
    return n(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != e.stack[r])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new r8(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class r8 {
  constructor(e, r) {
    this.tracker = e, this.context = r, this.hash = e.strict ? e.hash(r) : 0;
  }
}
class mre {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let r = e & 65535, n = e >> 19;
    n == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (n - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = i;
  }
}
class _1 {
  constructor(e, r, n) {
    this.stack = e, this.pos = r, this.index = n, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new _1(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new _1(this.stack, this.pos, this.index);
  }
}
function Hv(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let r = null;
  for (let n = 0, i = 0; n < t.length; ) {
    let o = 0;
    for (; ; ) {
      let s = t.charCodeAt(n++), a = !1;
      if (s == 126) {
        o = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let l = s - 32;
      if (l >= 46 && (l -= 46, a = !0), o += l, a)
        break;
      o *= 46;
    }
    r ? r[i++] = o : r = new e(o);
  }
  return r;
}
class zy {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const n8 = new zy();
class gre {
  /**
  @internal
  */
  constructor(e, r) {
    this.input = e, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = n8, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, r) {
    let n = this.range, i = this.rangeIndex, o = this.pos + e;
    for (; o < n.from; ) {
      if (!i)
        return null;
      let s = this.ranges[--i];
      o -= n.from - s.to, n = s;
    }
    for (; r < 0 ? o > n.to : o >= n.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let s = this.ranges[++i];
      o += s.from - n.to, n = s;
    }
    return o;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let r of this.ranges)
      if (r.to > e)
        return Math.max(e, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingâ€”when looking forwardâ€”or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let r = this.chunkOff + e, n, i;
    if (r >= 0 && r < this.chunk.length)
      n = this.pos + e, i = this.chunk.charCodeAt(r);
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null)
        return -1;
      if (n = o, n >= this.chunk2Pos && n < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(n - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= n; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = n), n + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - n)), i = this.chunk2.charCodeAt(0);
      }
    }
    return n >= this.token.lookAhead && (this.token.lookAhead = n + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, r = 0) {
    let n = r ? this.resolveOffset(r, -1) : this.pos;
    if (n == null || n < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = n;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, r) {
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), r = this.pos + e.length;
      this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, r) {
    if (r ? (this.token = r, r.start = e, r.lookAhead = e + 1, r.value = r.extended = -1) : this.token = n8, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to)
      return this.input.read(e, r);
    let n = "";
    for (let i of this.ranges) {
      if (i.from >= r)
        break;
      i.to > e && (n += this.input.read(Math.max(i.from, e), Math.min(i.to, r)));
    }
    return n;
  }
}
class Kf {
  constructor(e, r) {
    this.data = e, this.id = r;
  }
  token(e, r) {
    let { parser: n } = r.p;
    yre(this.data, e, r, this.id, n.data, n.tokenPrecTable);
  }
}
Kf.prototype.contextual = Kf.prototype.fallback = Kf.prototype.extend = !1;
Kf.prototype.fallback = Kf.prototype.extend = !1;
class vre {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, r = {}) {
    this.token = e, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
}
function yre(t, e, r, n, i, o) {
  let s = 0, a = 1 << n, { dialect: l } = r.p.parser;
  e: for (; (a & t[s]) != 0; ) {
    let u = t[s + 1];
    for (let p = s + 3; p < u; p += 2)
      if ((t[p + 1] & a) > 0) {
        let g = t[p];
        if (l.allows(g) && (e.token.value == -1 || e.token.value == g || bre(g, e.token.value, i, o))) {
          e.acceptToken(g);
          break;
        }
      }
    let c = e.next, h = 0, d = t[s + 2];
    if (e.next < 0 && d > h && t[u + d * 3 - 3] == 65535) {
      s = t[u + d * 3 - 1];
      continue e;
    }
    for (; h < d; ) {
      let p = h + d >> 1, g = u + p + (p << 1), v = t[g], y = t[g + 1] || 65536;
      if (c < v)
        d = p;
      else if (c >= y)
        h = p + 1;
      else {
        s = t[g + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function i8(t, e, r) {
  for (let n = e, i; (i = t[n]) != 65535; n++)
    if (i == r)
      return n - e;
  return -1;
}
function bre(t, e, r, n) {
  let i = i8(r, n, e);
  return i < 0 || i8(r, n, t) < i;
}
const Ao = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let B2 = null;
function o8(t, e, r) {
  let n = t.cursor($n.IncludeAnonymous);
  for (n.moveTo(e); ; )
    if (!(r < 0 ? n.childBefore(e) : n.childAfter(e)))
      for (; ; ) {
        if ((r < 0 ? n.to < e : n.from > e) && !n.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            n.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            n.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (r < 0 ? n.prevSibling() : n.nextSibling())
          break;
        if (!n.parent())
          return r < 0 ? 0 : t.length;
      }
}
class xre {
  constructor(e, r) {
    this.fragments = e, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? o8(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? o8(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let n = this.trees[r], i = this.index[r];
      if (i == n.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = n.children[i], s = this.start[r] + n.positions[i];
      if (s > e)
        return this.nextStart = s, null;
      if (o instanceof wn) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let a = s + o.length;
          if (a <= this.safeTo) {
            let l = o.prop(Rt.lookAhead);
            if (!l || a + l < this.fragment.to)
              return o;
          }
        }
        this.index[r]++, s + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(s), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = s + o.length;
    }
  }
}
class wre {
  constructor(e, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((n) => new zy());
  }
  getActions(e) {
    let r = 0, n = null, { parser: i } = e.p, { tokenizers: o } = i, s = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < o.length; u++) {
      if ((1 << u & s) == 0)
        continue;
      let c = o[u], h = this.tokens[u];
      if (!(n && !c.fallback) && ((c.contextual || h.start != e.pos || h.mask != s || h.context != a) && (this.updateCachedToken(h, c, e), h.mask = s, h.context = a), h.lookAhead > h.end + 25 && (l = Math.max(h.lookAhead, l)), h.value != 0)) {
        let d = r;
        if (h.extended > -1 && (r = this.addActions(e, h.extended, h.end, r)), r = this.addActions(e, h.value, h.end, r), !c.extend && (n = h, r > d))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return l && e.setLookAhead(l), !n && e.pos == this.stream.end && (n = new zy(), n.value = e.p.parser.eofTerm, n.start = n.end = e.pos, r = this.addActions(e, n.value, n.end, r)), this.mainToken = n, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let r = new zy(), { pos: n, p: i } = e;
    return r.start = n, r.end = Math.min(n + 1, i.stream.end), r.value = n == i.stream.end ? i.parser.eofTerm : 0, r;
  }
  updateCachedToken(e, r, n) {
    let i = this.stream.clipPos(n.pos);
    if (r.token(this.stream.reset(i, e), n), e.value > -1) {
      let { parser: o } = n.p;
      for (let s = 0; s < o.specialized.length; s++)
        if (o.specialized[s] == e.value) {
          let a = o.specializers[s](this.stream.read(e.start, e.end), n);
          if (a >= 0 && n.p.parser.dialect.allows(a >> 1)) {
            (a & 1) == 0 ? e.value = a >> 1 : e.extended = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, r, n, i) {
    for (let o = 0; o < i; o += 3)
      if (this.actions[o] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = r, this.actions[i++] = n, i;
  }
  addActions(e, r, n, i) {
    let { state: o } = e, { parser: s } = e.p, { data: a } = s;
    for (let l = 0; l < 2; l++)
      for (let u = s.stateSlot(
        o,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (a[u] == 65535)
          if (a[u + 1] == 1)
            u = Pl(a, u + 2);
          else {
            i == 0 && a[u + 1] == 2 && (i = this.putAction(Pl(a, u + 2), r, n, i));
            break;
          }
        a[u] == r && (i = this.putAction(Pl(a, u + 1), r, n, i));
      }
    return i;
  }
}
class kre {
  constructor(e, r, n, i) {
    this.parser = e, this.input = r, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new gre(r, i), this.tokens = new wre(e, this.stream), this.topTerm = e.top[1];
    let { from: o } = i[0];
    this.stacks = [C1.start(this, e.top[0], o)], this.fragments = n.length && this.stream.end - o > e.bufferLength * 4 ? new xre(n, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, r = this.minStackPos, n = this.stacks = [], i, o;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > r)
          n.push(a);
        else {
          if (this.advanceStack(a, n, e))
            continue;
          {
            i || (i = [], o = []), i.push(a);
            let l = this.tokens.getMainToken(a);
            o.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!n.length) {
      let s = i && _re(i);
      if (s)
        return Ao && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw Ao && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let s = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, n);
      if (s)
        return Ao && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n.length > s)
        for (n.sort((a, l) => l.score - a.score); n.length > s; )
          n.pop();
      n.some((a) => a.reducePos > r) && this.recovering--;
    } else if (n.length > 1) {
      e: for (let s = 0; s < n.length - 1; s++) {
        let a = n[s];
        for (let l = s + 1; l < n.length; l++) {
          let u = n[l];
          if (a.sameState(u) || a.buffer.length > 500 && u.buffer.length > 500)
            if ((a.score - u.score || a.buffer.length - u.buffer.length) > 0)
              n.splice(l--, 1);
            else {
              n.splice(s--, 1);
              continue e;
            }
        }
      }
      n.length > 12 && n.splice(
        12,
        n.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = n[0].pos;
    for (let s = 1; s < n.length; s++)
      n[s].pos < this.minStackPos && (this.minStackPos = n[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, r, n) {
    let i = e.pos, { parser: o } = this, s = Ao ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, c = u ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(i); h; ) {
        let d = this.parser.nodeSet.types[h.type.id] == h.type ? o.getGoto(e.state, h.type.id) : -1;
        if (d > -1 && h.length && (!u || (h.prop(Rt.contextHash) || 0) == c))
          return e.useNode(h, d), Ao && console.log(s + this.stackID(e) + ` (via reuse of ${o.getName(h.type.id)})`), !0;
        if (!(h instanceof wn) || h.children.length == 0 || h.positions[0] > 0)
          break;
        let p = h.children[0];
        if (p instanceof wn && h.positions[0] == 0)
          h = p;
        else
          break;
      }
    }
    let a = o.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), Ao && console.log(s + this.stackID(e) + ` (via always-reduce ${o.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let c = l[u++], h = l[u++], d = l[u++], p = u == l.length || !n, g = p ? e : e.split(), v = this.tokens.mainToken;
      if (g.apply(c, h, v ? v.start : g.pos, d), Ao && console.log(s + this.stackID(g) + ` (via ${(c & 65536) == 0 ? "shift" : `reduce of ${o.getName(
        c & 65535
        /* Action.ValueMask */
      )}`} for ${o.getName(h)} @ ${i}${g == e ? "" : ", split"})`), p)
        return !0;
      g.pos > i ? r.push(g) : n.push(g);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, r) {
    let n = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > n)
        return s8(e, r), !0;
    }
  }
  runRecovery(e, r, n) {
    let i = null, o = !1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = r[s << 1], u = r[(s << 1) + 1], c = Ao ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (o || (o = !0, a.restart(), Ao && console.log(c + this.stackID(a) + " (restarted)"), this.advanceFully(a, n))))
        continue;
      let h = a.split(), d = c;
      for (let p = 0; p < 10 && h.forceReduce() && (Ao && console.log(d + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, n)); p++)
        Ao && (d = this.stackID(h) + " -> ");
      for (let p of a.recoverByInsert(l))
        Ao && console.log(c + this.stackID(p) + " (via recover-insert)"), this.advanceFully(p, n);
      this.stream.end > a.pos ? (u == a.pos && (u++, l = 0), a.recoverByDelete(l, u), Ao && console.log(c + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), s8(a, n)) : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), wn.build({
      buffer: _1.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let r = (B2 || (B2 = /* @__PURE__ */ new WeakMap())).get(e);
    return r || B2.set(e, r = String.fromCodePoint(this.nextStackID++)), r + e;
  }
}
function s8(t, e) {
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    if (n.pos == t.pos && n.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class Cre {
  constructor(e, r, n) {
    this.source = e, this.flags = r, this.disabled = n;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
class hg extends pP {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      r.push("");
    let n = Object.keys(e.topRules).map((a) => e.topRules[a][1]), i = [];
    for (let a = 0; a < r.length; a++)
      i.push([]);
    function o(a, l, u) {
      i[a].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = Rt[l]);
        for (let u = 1; u < a.length; ) {
          let c = a[u++];
          if (c >= 0)
            o(c, l, a[u++]);
          else {
            let h = a[u + -c];
            for (let d = -c; d > 0; d--)
              o(a[u++], l, h);
            u++;
          }
        }
      }
    this.nodeSet = new f4(r.map((a, l) => co.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: i[l],
      top: n.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = cP;
    let s = Hv(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(a8), this.states = Hv(e.states, Uint32Array), this.data = Hv(e.stateData), this.goto = Hv(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new Kf(s, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, r, n) {
    let i = new kre(this, e, r, n);
    for (let o of this.wrappers)
      i = o(i, e, r, n);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, r, n = !1) {
    let i = this.goto;
    if (r >= i[0])
      return -1;
    for (let o = i[r + 1]; ; ) {
      let s = i[o++], a = s & 1, l = i[o++];
      if (a && n)
        return l;
      for (let u = o + (s >> 1); o < u; o++)
        if (i[o] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, r) {
    let n = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), s; ; o += 3) {
        if ((s = n[o]) == 65535)
          if (n[o + 1] == 1)
            s = n[o = Pl(n, o + 2)];
          else {
            if (n[o + 1] == 2)
              return Pl(n, o + 2);
            break;
          }
        if (s == r || s == 0)
          return Pl(n, o + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(e, r) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(e, r) {
    return !!this.allActions(e, (n) => n == r ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, r) {
    let n = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = n ? r(n) : void 0;
    for (let o = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1)
          o = Pl(this.data, o + 2);
        else
          break;
      i = r(Pl(this.data, o + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let r = [];
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = Pl(this.data, n + 2);
        else
          break;
      if ((this.data[n + 2] & 1) == 0) {
        let i = this.data[n + 1];
        r.some((o, s) => s & 1 && o == i) || r.push(this.data[n], i);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let r = Object.assign(Object.create(hg.prototype), this);
    if (e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let n = this.topRules[e.top];
      if (!n)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = n;
    }
    return e.tokenizers && (r.tokenizers = this.tokenizers.map((n) => {
      let i = e.tokenizers.find((o) => o.from == n);
      return i ? i.to : n;
    })), e.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((n, i) => {
      let o = e.specializers.find((a) => a.from == n.external);
      if (!o)
        return n;
      let s = Object.assign(Object.assign({}, n), { external: o.to });
      return r.specializers[i] = a8(s), s;
    })), e.contextTracker && (r.context = e.contextTracker), e.dialect && (r.dialect = this.parseDialect(e.dialect)), e.strict != null && (r.strict = e.strict), e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)), e.bufferLength != null && (r.bufferLength = e.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let r = Object.keys(this.dialects), n = r.map(() => !1);
    if (e)
      for (let o of e.split(" ")) {
        let s = r.indexOf(o);
        s >= 0 && (n[s] = !0);
      }
    let i = null;
    for (let o = 0; o < r.length; o++)
      if (!n[o])
        for (let s = this.dialects[r[o]], a; (a = this.data[s++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new Cre(e, n, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new hg(e);
  }
}
function Pl(t, e) {
  return t[e] | t[e + 1] << 16;
}
function _re(t) {
  let e = null;
  for (let r of t) {
    let n = r.p.stoppedAt;
    (r.pos == r.p.stream.end || n != null && r.pos > n) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < r.score) && (e = r);
  }
  return e;
}
function a8(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, n) => t.external(r, n) << 1 | e;
  }
  return t.get;
}
const Sre = 36, l8 = 1, Are = 2, yf = 3, L2 = 4, Ere = 5, Dre = 6, Ore = 7, Fre = 8, Tre = 9, Mre = 10, Pre = 11, Rre = 12, Nre = 13, $re = 14, Ire = 15, Bre = 16, Lre = 17, u8 = 18, zre = 19, vR = 20, yR = 21, c8 = 22, jre = 23, qre = 24;
function cC(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57;
}
function Ure(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function $c(t, e, r) {
  for (let n = !1; ; ) {
    if (t.next < 0)
      return;
    if (t.next == e && !n) {
      t.advance();
      return;
    }
    n = r && !n && t.next == 92, t.advance();
  }
}
function Hre(t, e) {
  e: for (; ; ) {
    if (t.next < 0)
      return;
    if (t.next == 36) {
      t.advance();
      for (let r = 0; r < e.length; r++) {
        if (t.next != e.charCodeAt(r))
          continue e;
        t.advance();
      }
      if (t.next == 36) {
        t.advance();
        return;
      }
    } else
      t.advance();
  }
}
function Vre(t, e) {
  let r = "[{<(".indexOf(String.fromCharCode(e)), n = r < 0 ? e : "]}>)".charCodeAt(r);
  for (; ; ) {
    if (t.next < 0)
      return;
    if (t.next == n && t.peek(1) == 39) {
      t.advance(2);
      return;
    }
    t.advance();
  }
}
function hC(t, e) {
  for (; !(t.next != 95 && !cC(t.next)); )
    e != null && (e += String.fromCharCode(t.next)), t.advance();
  return e;
}
function Wre(t) {
  if (t.next == 39 || t.next == 34 || t.next == 96) {
    let e = t.next;
    t.advance(), $c(t, e, !1);
  } else
    hC(t);
}
function h8(t, e) {
  for (; t.next == 48 || t.next == 49; )
    t.advance();
  e && t.next == e && t.advance();
}
function f8(t, e) {
  for (; ; ) {
    if (t.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (t.next < 48 || t.next > 57)
      break;
    t.advance();
  }
  if (t.next == 69 || t.next == 101)
    for (t.advance(), (t.next == 43 || t.next == 45) && t.advance(); t.next >= 48 && t.next <= 57; )
      t.advance();
}
function d8(t) {
  for (; !(t.next < 0 || t.next == 10); )
    t.advance();
}
function Mc(t, e) {
  for (let r = 0; r < e.length; r++)
    if (e.charCodeAt(r) == t)
      return !0;
  return !1;
}
const z2 = ` 	\r
`;
function bR(t, e, r) {
  let n = /* @__PURE__ */ Object.create(null);
  n.true = n.false = Ere, n.null = n.unknown = Dre;
  for (let i of t.split(" "))
    i && (n[i] = vR);
  for (let i of e.split(" "))
    i && (n[i] = yR);
  for (let i of (r || "").split(" "))
    i && (n[i] = qre);
  return n;
}
const xR = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", wR = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", fC = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: !1,
  words: /* @__PURE__ */ bR(wR, xR)
};
function Gre(t, e, r, n) {
  let i = {};
  for (let o in fC)
    i[o] = (t.hasOwnProperty(o) ? t : fC)[o];
  return e && (i.words = bR(e, r || "", n)), i;
}
function kR(t) {
  return new vre((e) => {
    var r;
    let { next: n } = e;
    if (e.advance(), Mc(n, z2)) {
      for (; Mc(e.next, z2); )
        e.advance();
      e.acceptToken(Sre);
    } else if (n == 36 && t.doubleDollarQuotedStrings) {
      let i = hC(e, "");
      e.next == 36 && (e.advance(), Hre(e, i), e.acceptToken(yf));
    } else if (n == 39 || n == 34 && t.doubleQuotedStrings)
      $c(e, n, t.backslashEscapes), e.acceptToken(yf);
    else if (n == 35 && t.hashComments || n == 47 && e.next == 47 && t.slashComments)
      d8(e), e.acceptToken(l8);
    else if (n == 45 && e.next == 45 && (!t.spaceAfterDashes || e.peek(1) == 32))
      d8(e), e.acceptToken(l8);
    else if (n == 47 && e.next == 42) {
      e.advance();
      for (let i = 1; ; ) {
        let o = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), o == 42 && e.next == 47) {
          if (i--, e.advance(), !i)
            break;
        } else o == 47 && e.next == 42 && (i++, e.advance());
      }
      e.acceptToken(Are);
    } else if ((n == 101 || n == 69) && e.next == 39)
      e.advance(), $c(e, 39, !0), e.acceptToken(yf);
    else if ((n == 110 || n == 78) && e.next == 39 && t.charSetCasts)
      e.advance(), $c(e, 39, t.backslashEscapes), e.acceptToken(yf);
    else if (n == 95 && t.charSetCasts)
      for (let i = 0; ; i++) {
        if (e.next == 39 && i > 1) {
          e.advance(), $c(e, 39, t.backslashEscapes), e.acceptToken(yf);
          break;
        }
        if (!cC(e.next))
          break;
        e.advance();
      }
    else if (t.plsqlQuotingMechanism && (n == 113 || n == 81) && e.next == 39 && e.peek(1) > 0 && !Mc(e.peek(1), z2)) {
      let i = e.peek(1);
      e.advance(2), Vre(e, i), e.acceptToken(yf);
    } else if (Mc(n, t.identifierQuotes)) {
      const i = n == 91 ? 93 : n;
      $c(e, i, !1), e.acceptToken(zre);
    } else if (n == 40)
      e.acceptToken(Ore);
    else if (n == 41)
      e.acceptToken(Fre);
    else if (n == 123)
      e.acceptToken(Tre);
    else if (n == 125)
      e.acceptToken(Mre);
    else if (n == 91)
      e.acceptToken(Pre);
    else if (n == 93)
      e.acceptToken(Rre);
    else if (n == 59)
      e.acceptToken(Nre);
    else if (t.unquotedBitLiterals && n == 48 && e.next == 98)
      e.advance(), h8(e), e.acceptToken(c8);
    else if ((n == 98 || n == 66) && (e.next == 39 || e.next == 34)) {
      const i = e.next;
      e.advance(), t.treatBitsAsBytes ? ($c(e, i, t.backslashEscapes), e.acceptToken(jre)) : (h8(e, i), e.acceptToken(c8));
    } else if (n == 48 && (e.next == 120 || e.next == 88) || (n == 120 || n == 88) && e.next == 39) {
      let i = e.next == 39;
      for (e.advance(); Ure(e.next); )
        e.advance();
      i && e.next == 39 && e.advance(), e.acceptToken(L2);
    } else if (n == 46 && e.next >= 48 && e.next <= 57)
      f8(e, !0), e.acceptToken(L2);
    else if (n == 46)
      e.acceptToken($re);
    else if (n >= 48 && n <= 57)
      f8(e, !1), e.acceptToken(L2);
    else if (Mc(n, t.operatorChars)) {
      for (; Mc(e.next, t.operatorChars); )
        e.advance();
      e.acceptToken(Ire);
    } else if (Mc(n, t.specialVar))
      e.next == n && e.advance(), Wre(e), e.acceptToken(Lre);
    else if (n == 58 || n == 44)
      e.acceptToken(Bre);
    else if (cC(n)) {
      let i = hC(e, String.fromCharCode(n));
      e.acceptToken(e.next == 46 || e.peek(-i.length - 1) == 46 ? u8 : (r = t.words[i.toLowerCase()]) !== null && r !== void 0 ? r : u8);
    }
  });
}
const CR = /* @__PURE__ */ kR(fC), Kre = /* @__PURE__ */ hg.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "âš  LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, CR],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function dC(t) {
  let e = t.cursor().moveTo(t.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function fg(t, e) {
  let r = t.sliceString(e.from, e.to), n = /^([`'"\[])(.*)([`'"\]])$/.exec(r);
  return n ? n[2] : r;
}
function S1(t) {
  return t && (t.name == "Identifier" || t.name == "QuotedIdentifier");
}
function Xre(t, e) {
  if (e.name == "CompositeIdentifier") {
    let r = [];
    for (let n = e.firstChild; n; n = n.nextSibling)
      S1(n) && r.push(fg(t, n));
    return r;
  }
  return [fg(t, e)];
}
function p8(t, e) {
  for (let r = []; ; ) {
    if (!e || e.name != ".")
      return r;
    let n = dC(e);
    if (!S1(n))
      return r;
    r.unshift(fg(t, n)), e = dC(n);
  }
}
function Qre(t, e) {
  let r = On(t).resolveInner(e, -1), n = Yre(t.doc, r);
  return r.name == "Identifier" || r.name == "QuotedIdentifier" || r.name == "Keyword" ? {
    from: r.from,
    quoted: r.name == "QuotedIdentifier" ? t.doc.sliceString(r.from, r.from + 1) : null,
    parents: p8(t.doc, dC(r)),
    aliases: n
  } : r.name == "." ? { from: e, quoted: null, parents: p8(t.doc, r), aliases: n } : { from: e, quoted: null, parents: [], empty: !0, aliases: n };
}
const Jre = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function Yre(t, e) {
  let r;
  for (let i = e; !r; i = i.parent) {
    if (!i)
      return null;
    i.name == "Statement" && (r = i);
  }
  let n = null;
  for (let i = r.firstChild, o = !1, s = null; i; i = i.nextSibling) {
    let a = i.name == "Keyword" ? t.sliceString(i.from, i.to).toLowerCase() : null, l = null;
    if (!o)
      o = a == "from";
    else if (a == "as" && s && S1(i.nextSibling))
      l = fg(t, i.nextSibling);
    else {
      if (a && Jre.has(a))
        break;
      s && S1(i) && (l = fg(t, i));
    }
    l && (n || (n = /* @__PURE__ */ Object.create(null)), n[l] = Xre(t, s)), s = /Identifier$/.test(i.name) ? i : null;
  }
  return n;
}
function Zre(t, e, r) {
  return r.map((n) => ({ ...n, label: n.label[0] == t ? n.label : t + n.label + e, apply: void 0 }));
}
const ene = /^\w*$/, tne = /^[`'"\[]?\w*[`'"\]]?$/;
function m8(t) {
  return t.self && typeof t.self.label == "string";
}
class F4 {
  constructor(e, r) {
    this.idQuote = e, this.idCaseInsensitive = r, this.list = [], this.children = void 0;
  }
  child(e) {
    let r = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return r[e] || (e && !this.list.some((i) => i.label == e) && this.list.push(g8(e, "type", this.idQuote, this.idCaseInsensitive)), r[e] = new F4(this.idQuote, this.idCaseInsensitive));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let r = this.list.findIndex((n) => n.label == e.label);
    r > -1 ? this.list[r] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let r of e)
      this.addCompletion(typeof r == "string" ? g8(r, "property", this.idQuote, this.idCaseInsensitive) : r);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : m8(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let r of Object.keys(e)) {
      let n = e[r], i = null, o = r.replace(/\\?\./g, (a) => a == "." ? "\0" : a).split("\0"), s = this;
      m8(n) && (i = n.self, n = n.children);
      for (let a = 0; a < o.length; a++)
        i && a == o.length - 1 && s.addCompletion(i), s = s.child(o[a].replace(/\\\./g, "."));
      s.addNamespace(n);
    }
  }
}
function g8(t, e, r, n) {
  return new RegExp("^[a-z_][a-z_\\d]*$", n ? "i" : "").test(t) ? { label: t, type: e } : { label: t, type: e, apply: r + t + _R(r) };
}
function _R(t) {
  return t === "[" ? "]" : t;
}
function rne(t, e, r, n, i, o) {
  var s;
  let a = ((s = o?.spec.identifierQuotes) === null || s === void 0 ? void 0 : s[0]) || '"', l = new F4(a, !!o?.spec.caseInsensitiveIdentifiers), u = i ? l.child(i) : null;
  return l.addNamespace(t), e && (u || l).addCompletions(e), r && l.addCompletions(r), u && l.addCompletions(u.list), n && l.addCompletions((u || l).child(n).list), (c) => {
    let { parents: h, from: d, quoted: p, empty: g, aliases: v } = Qre(c.state, c.pos);
    if (g && !c.explicit)
      return null;
    v && h.length == 1 && (h = v[h[0]] || h);
    let y = l;
    for (let k of h) {
      for (; !y.children || !y.children[k]; )
        if (y == l && u)
          y = u;
        else if (y == u && n)
          y = y.child(n);
        else
          return null;
      let C = y.maybeChild(k);
      if (!C)
        return null;
      y = C;
    }
    let b = y.list;
    if (y == l && v && (b = b.concat(Object.keys(v).map((k) => ({ label: k, type: "constant" })))), p) {
      let k = p[0], C = _R(k), S = c.state.sliceDoc(c.pos, c.pos + 1) == C;
      return {
        from: d,
        to: S ? c.pos + 1 : void 0,
        options: Zre(k, C, b),
        validFor: tne
      };
    } else
      return {
        from: d,
        options: b,
        validFor: ene
      };
  };
}
function nne(t) {
  return t == yR ? "type" : t == vR ? "keyword" : "variable";
}
function ine(t, e, r) {
  let n = Object.keys(t).map((i) => r(e ? i.toUpperCase() : i, nne(t[i])));
  return see(["QuotedIdentifier", "String", "LineComment", "BlockComment", "."], EP(n));
}
let one = /* @__PURE__ */ Kre.configure({
  props: [
    /* @__PURE__ */ y4.add({
      Statement: /* @__PURE__ */ rC()
    }),
    /* @__PURE__ */ xP.add({
      Statement(t, e) {
        return { from: Math.min(t.from + 100, e.doc.lineAt(t.from).to), to: t.to };
      },
      BlockComment(t) {
        return { from: t.from + 2, to: t.to - 2 };
      }
    }),
    /* @__PURE__ */ g4({
      Keyword: oe.keyword,
      Type: oe.typeName,
      Builtin: /* @__PURE__ */ oe.standard(oe.name),
      Bits: oe.number,
      Bytes: oe.string,
      Bool: oe.bool,
      Null: oe.null,
      Number: oe.number,
      String: oe.string,
      Identifier: oe.name,
      QuotedIdentifier: /* @__PURE__ */ oe.special(oe.string),
      SpecialVar: /* @__PURE__ */ oe.special(oe.name),
      LineComment: oe.lineComment,
      BlockComment: oe.blockComment,
      Operator: oe.operator,
      "Semi Punctuation": oe.punctuation,
      "( )": oe.paren,
      "{ }": oe.brace,
      "[ ]": oe.squareBracket
    })
  ]
});
class dg {
  constructor(e, r, n) {
    this.dialect = e, this.language = r, this.spec = n;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Reconfigure the parser used by this dialect. Returns a new
  dialect object.
  */
  configureLanguage(e, r) {
    return new dg(this.dialect, this.language.configure(e, r), this.spec);
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let r = Gre(e, e.keywords, e.types, e.builtin), n = sg.define({
      name: "sql",
      parser: one.configure({
        tokenizers: [{ from: CR, to: kR(r) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new dg(r, n, e);
  }
}
function sne(t, e) {
  return { label: t, type: e, boost: -1 };
}
function ane(t, e = !1, r) {
  return ine(t.dialect.words, e, r || sne);
}
function lne(t) {
  return t.schema ? rne(t.schema, t.tables, t.schemas, t.defaultTable, t.defaultSchema, t.dialect || T4) : () => null;
}
function une(t) {
  return t.schema ? (t.dialect || T4).language.data.of({
    autocomplete: lne(t)
  }) : [];
}
function cne(t = {}) {
  let e = t.dialect || T4;
  return new yP(e.language, [
    une(t),
    e.language.data.of({
      autocomplete: ane(e, t.upperCaseKeywords, t.keywordCompletion)
    })
  ]);
}
const T4 = /* @__PURE__ */ dg.define({}), hne = /* @__PURE__ */ dg.define({
  charSetCasts: !0,
  doubleDollarQuotedStrings: !0,
  operatorChars: "+-*/<>=~!@#%^&|`?",
  specialVar: "",
  keywords: wR + "abort abs absent access according ada admin aggregate alias also always analyse analyze array_agg array_max_cardinality asensitive assert assignment asymmetric atomic attach attribute attributes avg backward base64 begin_frame begin_partition bernoulli bit_length blocked bom cache called cardinality catalog_name ceil ceiling chain char_length character_length character_set_catalog character_set_name character_set_schema characteristics characters checkpoint class class_origin cluster coalesce cobol collation_catalog collation_name collation_schema collect column_name columns command_function command_function_code comment comments committed concurrently condition_number configuration conflict connection_name constant constraint_catalog constraint_name constraint_schema contains content control conversion convert copy corr cost covar_pop covar_samp csv cume_dist current_catalog current_row current_schema cursor_name database datalink datatype datetime_interval_code datetime_interval_precision db debug defaults defined definer degree delimiter delimiters dense_rank depends derived detach detail dictionary disable discard dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue document dump dynamic_function dynamic_function_code element elsif empty enable encoding encrypted end_frame end_partition endexec enforced enum errcode error event every exclude excluding exclusive exp explain expression extension extract family file filter final first_value flag floor following force foreach fortran forward frame_row freeze fs functions fusion generated granted greatest groups handler header hex hierarchy hint id ignore ilike immediately immutable implementation implicit import include including increment indent index indexes info inherit inherits inline insensitive instance instantiable instead integrity intersection invoker isnull key_member key_type label lag last_value lead leakproof least length library like_regex link listen ln load location lock locked log logged lower mapping matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text min minvalue mod mode more move multiset mumps name namespace nfc nfd nfkc nfkd nil normalize normalized nothing notice notify notnull nowait nth_value ntile nullable nullif nulls number occurrences_regex octet_length octets off offset oids operator options ordering others over overlay overriding owned owner parallel parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partition pascal passing passthrough password percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding prepared print_strict_params procedural procedures program publication query quote raise range rank reassign recheck recovery refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex rename repeatable replace replica requiring reset respect restart restore result_oid returned_cardinality returned_length returned_octet_length returned_sqlstate returning reverse routine_catalog routine_name routine_schema routines row_count row_number rowtype rule scale schema_name schemas scope scope_catalog scope_name scope_schema security selective self sensitive sequence sequences serializable server server_name setof share show simple skip slice snapshot source specific_name sqlcode sqlerror sqrt stable stacked standalone statement statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time table_name tables tablesample tablespace temp template ties token top_level_count transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex trigger_catalog trigger_name trigger_schema trim trim_array truncate trusted type types uescape unbounded uncommitted unencrypted unlink unlisten unlogged unnamed untyped upper uri use_column use_variable user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema vacuum valid validate validator value_of var_pop var_samp varbinary variable_conflict variadic verbose version versioning views volatile warning whitespace width_bucket window within wrapper xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate yes",
  types: xR + "bigint int8 bigserial serial8 varbit bool box bytea cidr circle precision float8 inet int4 json jsonb line lseg macaddr macaddr8 money numeric pg_lsn point polygon float4 int2 smallserial serial2 serial serial4 text timetz timestamptz tsquery tsvector txid_snapshot uuid xml"
});
class v8 {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.diagnostic = n;
  }
}
class zc {
  constructor(e, r, n) {
    this.diagnostics = e, this.panel = r, this.selected = n;
  }
  static init(e, r, n) {
    let i = n.facet($a).markerFilter;
    i && (e = i(e, n));
    let o = e.slice().sort((p, g) => p.from - g.from || p.to - g.to), s = new nc(), a = [], l = 0, u = n.doc.iter(), c = 0, h = n.doc.length;
    for (let p = 0; ; ) {
      let g = p == o.length ? null : o[p];
      if (!g && !a.length)
        break;
      let v, y;
      if (a.length)
        v = l, y = a.reduce((C, S) => Math.min(C, S.to), g && g.from > v ? g.from : 1e8);
      else {
        if (v = g.from, v > h)
          break;
        y = g.to, a.push(g), p++;
      }
      for (; p < o.length; ) {
        let C = o[p];
        if (C.from == v && (C.to > C.from || C.to == v))
          a.push(C), p++, y = Math.min(C.to, y);
        else {
          y = Math.min(C.from, y);
          break;
        }
      }
      y = Math.min(y, h);
      let b = !1;
      if (a.some((C) => C.from == v && (C.to == y || y == h)) && (b = v == y, !b && y - v < 10)) {
        let C = v - (c + u.value.length);
        C > 0 && (u.next(C), c = v);
        for (let S = v; ; ) {
          if (S >= y) {
            b = !0;
            break;
          }
          if (!u.lineBreak && c + u.value.length > S)
            break;
          S = c + u.value.length, c += u.value.length, u.next();
        }
      }
      let k = Ane(a);
      if (b)
        s.add(v, v, ft.widget({
          widget: new kne(k),
          diagnostics: a.slice()
        }));
      else {
        let C = a.reduce((S, _) => _.markClass ? S + " " + _.markClass : S, "");
        s.add(v, y, ft.mark({
          class: "cm-lintRange cm-lintRange-" + k + C,
          diagnostics: a.slice(),
          inclusiveEnd: a.some((S) => S.to > y)
        }));
      }
      if (l = y, l == h)
        break;
      for (let C = 0; C < a.length; C++)
        a[C].to <= l && a.splice(C--, 1);
    }
    let d = s.finish();
    return new zc(d, r, Ad(d));
  }
}
function Ad(t, e = null, r = 0) {
  let n = null;
  return t.between(r, 1e9, (i, o, { spec: s }) => {
    if (!(e && s.diagnostics.indexOf(e) < 0))
      if (!n)
        n = new v8(i, o, e || s.diagnostics[0]);
      else {
        if (s.diagnostics.indexOf(n.diagnostic) < 0)
          return !1;
        n = new v8(n.from, o, n.diagnostic);
      }
  }), n;
}
function fne(t, e) {
  let r = e.pos, n = e.end || r, i = t.state.facet($a).hideOn(t, r, n);
  if (i != null)
    return i;
  let o = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((s) => s.is(M4)) || t.changes.touchesRange(o.from, Math.max(o.to, n)));
}
function SR(t, e) {
  return t.field(qo, !1) ? e : e.concat(kt.appendConfig.of(OR));
}
function dne(t, e) {
  return {
    effects: SR(t, [M4.of(e)])
  };
}
const M4 = /* @__PURE__ */ kt.define(), P4 = /* @__PURE__ */ kt.define(), AR = /* @__PURE__ */ kt.define(), qo = /* @__PURE__ */ qn.define({
  create() {
    return new zc(ft.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let r = t.diagnostics.map(e.changes), n = null, i = t.panel;
      if (t.selected) {
        let o = e.changes.mapPos(t.selected.from, 1);
        n = Ad(r, t.selected.diagnostic, o) || Ad(r, null, o);
      }
      !r.size && i && e.state.facet($a).autoPanel && (i = null), t = new zc(r, i, n);
    }
    for (let r of e.effects)
      if (r.is(M4)) {
        let n = e.state.facet($a).autoPanel ? r.value.length ? pg.open : null : t.panel;
        t = zc.init(r.value, n, e.state);
      } else r.is(P4) ? t = new zc(t.diagnostics, r.value ? pg.open : null, t.selected) : r.is(AR) && (t = new zc(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    ng.from(t, (e) => e.panel),
    Ie.decorations.from(t, (e) => e.diagnostics)
  ]
}), pne = /* @__PURE__ */ ft.mark({ class: "cm-lintRange cm-lintRange-active" });
function mne(t, e, r) {
  let { diagnostics: n } = t.state.field(qo), i, o = -1, s = -1;
  n.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (l, u, { spec: c }) => {
    if (e >= l && e <= u && (l == u || (e > l || r > 0) && (e < u || r < 0)))
      return i = c.diagnostics, o = l, s = u, !1;
  });
  let a = t.state.facet($a).tooltipFilter;
  return i && a && (i = a(i, t.state)), i ? {
    pos: o,
    end: s,
    above: t.state.doc.lineAt(o).to < s,
    create() {
      return { dom: gne(t, i) };
    }
  } : null;
}
function gne(t, e) {
  return Or("ul", { class: "cm-tooltip-lint" }, e.map((r) => DR(t, r, !1)));
}
const vne = (t) => {
  let e = t.state.field(qo, !1);
  (!e || !e.panel) && t.dispatch({ effects: SR(t.state, [P4.of(!0)]) });
  let r = rg(t, pg.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, y8 = (t) => {
  let e = t.state.field(qo, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: P4.of(!1) }), !0);
}, yne = (t) => {
  let e = t.state.field(qo, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, n = e.diagnostics.iter(r.to + 1);
  return !n.value && (n = e.diagnostics.iter(0), !n.value || n.from == r.from && n.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0 }), !0);
}, bne = [
  { key: "Mod-Shift-m", run: vne, preventDefault: !0 },
  { key: "F8", run: yne }
], xne = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.view = t, this.timeout = -1, this.set = !0;
    let { delay: e } = t.state.facet($a);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    clearTimeout(this.timeout);
    let t = Date.now();
    if (t < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - t);
    else {
      this.set = !1;
      let { state: e } = this.view, { sources: r } = e.facet($a);
      r.length && wne(r.map((n) => Promise.resolve(n(this.view))), (n) => {
        this.view.state.doc == e.doc && this.view.dispatch(dne(this.view.state, n.reduce((i, o) => i.concat(o))));
      }, (n) => {
        Ri(this.view.state, n);
      });
    }
  }
  update(t) {
    let e = t.state.facet($a);
    (t.docChanged || e != t.startState.facet($a) || e.needsRefresh && e.needsRefresh(t)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function wne(t, e, r) {
  let n = [], i = -1;
  for (let o of t)
    o.then((s) => {
      n.push(s), clearTimeout(i), n.length == t.length ? e(n) : i = setTimeout(() => e(n), 200);
    }, r);
}
const $a = /* @__PURE__ */ Be.define({
  combine(t) {
    return {
      sources: t.map((e) => e.source).filter((e) => e != null),
      ...ou(t.map((e) => e.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        delay: Math.max,
        markerFilter: b8,
        tooltipFilter: b8,
        needsRefresh: (e, r) => e ? r ? (n) => e(n) || r(n) : e : r,
        hideOn: (e, r) => e ? r ? (n, i, o) => e(n, i, o) || r(n, i, o) : e : r,
        autoPanel: (e, r) => e || r
      })
    };
  }
});
function b8(t, e) {
  return t ? e ? (r, n) => e(t(r, n), n) : t : e;
}
function x8(t, e = {}) {
  return [
    $a.of({ source: t, config: e }),
    xne,
    OR
  ];
}
function ER(t) {
  let e = [];
  if (t)
    e: for (let { name: r } of t) {
      for (let n = 0; n < r.length; n++) {
        let i = r[n];
        if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function DR(t, e, r) {
  var n;
  let i = r ? ER(e.actions) : [];
  return Or("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Or("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (n = e.actions) === null || n === void 0 ? void 0 : n.map((o, s) => {
    let a = !1, l = (p) => {
      if (p.preventDefault(), a)
        return;
      a = !0;
      let g = Ad(t.state.field(qo).diagnostics, e);
      g && o.apply(t, g.from, g.to);
    }, { name: u } = o, c = i[s] ? u.indexOf(i[s]) : -1, h = c < 0 ? u : [
      u.slice(0, c),
      Or("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ], d = o.markClass ? " " + o.markClass : "";
    return Or("button", {
      type: "button",
      class: "cm-diagnosticAction" + d,
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${i[s]})"`}.`
    }, h);
  }), e.source && Or("div", { class: "cm-diagnosticSource" }, e.source));
}
class kne extends Lh {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Or("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class w8 {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = DR(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class pg {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (i) => {
      if (i.keyCode == 27)
        y8(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: o } = this.items[this.selectedIndex], s = ER(o.actions);
        for (let a = 0; a < s.length; a++)
          if (s[a].toUpperCase().charCodeAt(0) == i.keyCode) {
            let l = Ad(this.view.state.field(qo).diagnostics, o);
            l && o.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      i.preventDefault();
    }, n = (i) => {
      for (let o = 0; o < this.items.length; o++)
        this.items[o].dom.contains(i.target) && this.moveSelection(o);
    };
    this.list = Or("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: n
    }), this.dom = Or("div", { class: "cm-panel-lint" }, this.list, Or("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => y8(this.view)
    }, "Ã—")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(qo).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(qo), n = 0, i = !1, o = null, s = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: u }) => {
      for (let c of u.diagnostics) {
        if (s.has(c))
          continue;
        s.add(c);
        let h = -1, d;
        for (let p = n; p < this.items.length; p++)
          if (this.items[p].diagnostic == c) {
            h = p;
            break;
          }
        h < 0 ? (d = new w8(this.view, c), this.items.splice(n, 0, d), i = !0) : (d = this.items[h], h > n && (this.items.splice(n, h - n), i = !0)), r && d.diagnostic == r.diagnostic ? d.dom.hasAttribute("aria-selected") || (d.dom.setAttribute("aria-selected", "true"), o = d) : d.dom.hasAttribute("aria-selected") && d.dom.removeAttribute("aria-selected"), n++;
      }
    }); n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new w8(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let u = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / u : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let n = e;
      e = n.nextSibling, n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; )
          r();
        e = n.dom.nextSibling;
      } else
        this.list.insertBefore(n.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(qo), n = Ad(r.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({
      selection: { anchor: n.from, head: n.to },
      scrollIntoView: !0,
      effects: AR.of(n)
    });
  }
  static open(e) {
    return new pg(e);
  }
}
function Cne(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Vv(t) {
  return Cne(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const _ne = /* @__PURE__ */ Ie.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Vv("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Vv("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Vv("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Vv("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function Sne(t) {
  return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
}
function Ane(t) {
  let e = "hint", r = 1;
  for (let n of t) {
    let i = Sne(n.severity);
    i > r && (r = i, e = n.severity);
  }
  return e;
}
const OR = [
  qo,
  /* @__PURE__ */ Ie.decorations.compute([qo], (t) => {
    let { selected: e, panel: r } = t.field(qo);
    return !e || !r || e.from == e.to ? ft.none : ft.set([
      pne.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ sP(mne, { hideOn: fne }),
  _ne
], k8 = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class Ed {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, n = 0, i = e.length, o, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, i), this.bufferStart = n, this.normalize = o ? (a) => o(k8(a)) : k8, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Yi(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = J_(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += Ea(e);
      let i = this.normalize(r);
      if (i.length)
        for (let o = 0, s = n; ; o++) {
          let a = i.charCodeAt(o), l = this.match(a, s, this.bufferPos + this.bufferStart);
          if (o == i.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          s == n && o < r.length && r.charCodeAt(o) == a && s++;
        }
    }
  }
  match(e, r, n) {
    let i = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let s = this.matches[o], a = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = { from: this.matches[o + 1], to: n } : (this.matches[o]++, a = !0)), a || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: r, to: n } : this.matches.push(1, r)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Ed.prototype[Symbol.iterator] = function() {
  return this;
});
const FR = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, R4 = "gm" + (/x/.unicode == null ? "" : "u");
class TR {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, n, i = 0, o = e.length) {
    if (this.text = e, this.to = o, this.curLine = "", this.done = !1, this.value = FR, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new MR(e, r, n, i, o);
    this.re = new RegExp(r, R4 + (n?.ignoreCase ? "i" : "")), this.test = n?.test, this.iter = e.iter();
    let s = e.lineAt(i);
    this.curLineStart = s.from, this.matchPos = A1(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let n = this.curLineStart + r.index, i = n + r[0].length;
        if (this.matchPos = A1(this.text, i + (n == i ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < i || n > this.value.to) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const j2 = /* @__PURE__ */ new WeakMap();
class Xf {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, n) {
    let i = j2.get(e);
    if (!i || i.from >= n || i.to <= r) {
      let a = new Xf(r, e.sliceString(r, n));
      return j2.set(e, a), a;
    }
    if (i.from == r && i.to == n)
      return i;
    let { text: o, from: s } = i;
    return s > r && (o = e.sliceString(r, s) + o, s = r), i.to < n && (o += e.sliceString(i.to, n)), j2.set(e, new Xf(s, o)), new Xf(r, o.slice(r - s, n - s));
  }
}
class MR {
  constructor(e, r, n, i, o) {
    this.text = e, this.to = o, this.done = !1, this.value = FR, this.matchPos = A1(e, i), this.re = new RegExp(r, R4 + (n?.ignoreCase ? "i" : "")), this.test = n?.test, this.flat = Xf.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let n = this.flat.from + r.index, i = n + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this.matchPos = A1(this.text, i + (n == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Xf.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (TR.prototype[Symbol.iterator] = MR.prototype[Symbol.iterator] = function() {
  return this;
});
function Ene(t) {
  try {
    return new RegExp(t, R4), !0;
  } catch {
    return !1;
  }
}
function A1(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), n;
  for (; e < r.to && (n = r.text.charCodeAt(e - r.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function pC(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = Or("input", { class: "cm-textfield", name: "line", value: e }), n = Or("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), t.dispatch({ effects: Mm.of(!1) }), t.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
    },
    onsubmit: (o) => {
      o.preventDefault(), i();
    }
  }, Or("label", t.state.phrase("Go to line"), ": ", r), " ", Or("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")), Or("button", {
    name: "close",
    onclick: () => {
      t.dispatch({ effects: Mm.of(!1) }), t.focus();
    },
    "aria-label": t.state.phrase("close"),
    type: "button"
  }, ["Ã—"]));
  function i() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!o)
      return;
    let { state: s } = t, a = s.doc.lineAt(s.selection.main.head), [, l, u, c, h] = o, d = c ? +c.slice(1) : 0, p = u ? +u : a.number;
    if (u && h) {
      let y = p / 100;
      l && (y = y * (l == "-" ? -1 : 1) + a.number / s.doc.lines), p = Math.round(s.doc.lines * y);
    } else u && l && (p = p * (l == "-" ? -1 : 1) + a.number);
    let g = s.doc.line(Math.max(1, Math.min(s.doc.lines, p))), v = de.cursor(g.from + Math.max(0, Math.min(d, g.length)));
    t.dispatch({
      effects: [Mm.of(!1), Ie.scrollIntoView(v.from, { y: "center" })],
      selection: v
    }), t.focus();
  }
  return { dom: n };
}
const Mm = /* @__PURE__ */ kt.define(), C8 = /* @__PURE__ */ qn.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(Mm) && (t = r.value);
    return t;
  },
  provide: (t) => ng.from(t, (e) => e ? pC : null)
}), Dne = (t) => {
  let e = rg(t, pC);
  if (!e) {
    let r = [Mm.of(!0)];
    t.state.field(C8, !1) == null && r.push(kt.appendConfig.of([C8, One])), t.dispatch({ effects: r }), e = rg(t, pC);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, One = /* @__PURE__ */ Ie.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), Fne = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Tne = /* @__PURE__ */ Be.define({
  combine(t) {
    return ou(t, Fne, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Mne(t) {
  return [Ine, $ne];
}
const Pne = /* @__PURE__ */ ft.mark({ class: "cm-selectionMatch" }), Rne = /* @__PURE__ */ ft.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function _8(t, e, r, n) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != Wr.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != Wr.Word);
}
function Nne(t, e, r, n) {
  return t(e.sliceDoc(r, r + 1)) == Wr.Word && t(e.sliceDoc(n - 1, n)) == Wr.Word;
}
const $ne = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(Tne), { state: r } = t, n = r.selection;
    if (n.ranges.length > 1)
      return ft.none;
    let i = n.main, o, s = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return ft.none;
      let l = r.wordAt(i.head);
      if (!l)
        return ft.none;
      s = r.charCategorizer(i.head), o = r.sliceDoc(l.from, l.to);
    } else {
      let l = i.to - i.from;
      if (l < e.minSelectionLength || l > 200)
        return ft.none;
      if (e.wholeWords) {
        if (o = r.sliceDoc(i.from, i.to), s = r.charCategorizer(i.head), !(_8(s, r, i.from, i.to) && Nne(s, r, i.from, i.to)))
          return ft.none;
      } else if (o = r.sliceDoc(i.from, i.to), !o)
        return ft.none;
    }
    let a = [];
    for (let l of t.visibleRanges) {
      let u = new Ed(r.doc, o, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: c, to: h } = u.value;
        if ((!s || _8(s, r, c, h)) && (i.empty && c <= i.from && h >= i.to ? a.push(Rne.range(c, h)) : (c >= i.to || h <= i.from) && a.push(Pne.range(c, h)), a.length > e.maxMatches))
          return ft.none;
      }
    }
    return ft.set(a);
  }
}, {
  decorations: (t) => t.decorations
}), Ine = /* @__PURE__ */ Ie.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Bne = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, n = de.create(r.ranges.map((i) => t.wordAt(i.head) || de.cursor(i.head)), r.mainIndex);
  return n.eq(r) ? !1 : (e(t.update({ selection: n })), !0);
};
function Lne(t, e) {
  let { main: r, ranges: n } = t.selection, i = t.wordAt(r.head), o = i && i.from == r.from && i.to == r.to;
  for (let s = !1, a = new Ed(t.doc, e, n[n.length - 1].to); ; )
    if (a.next(), a.done) {
      if (s)
        return null;
      a = new Ed(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), s = !0;
    } else {
      if (s && n.some((l) => l.from == a.value.from))
        continue;
      if (o) {
        let l = t.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const zne = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((o) => o.from === o.to))
    return Bne({ state: t, dispatch: e });
  let n = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != n))
    return !1;
  let i = Lne(t, n);
  return i ? (e(t.update({
    selection: t.selection.addRange(de.range(i.from, i.to), !1),
    effects: Ie.scrollIntoView(i.to)
  })), !0) : !1;
}, ep = /* @__PURE__ */ Be.define({
  combine(t) {
    return ou(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Yne(e),
      scrollToMatch: (e) => Ie.scrollIntoView(e)
    });
  }
});
class PR {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Ene(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Hne(this) : new qne(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, n) {
    let i = e.doc ? e : ir.create({ doc: e });
    return n == null && (n = i.doc.length), this.regexp ? Ef(this, i, r, n) : Af(this, i, r, n);
  }
}
class RR {
  constructor(e) {
    this.spec = e;
  }
}
function Af(t, e, r, n) {
  return new Ed(e.doc, t.unquoted, r, n, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? jne(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function jne(t, e) {
  return (r, n, i, o) => ((o > r || o + i.length < n) && (o = Math.max(0, r - 2), i = t.sliceString(o, Math.min(t.length, n + 2))), (e(E1(i, r - o)) != Wr.Word || e(D1(i, r - o)) != Wr.Word) && (e(D1(i, n - o)) != Wr.Word || e(E1(i, n - o)) != Wr.Word));
}
class qne extends RR {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, n) {
    let i = Af(this.spec, e, n, e.doc.length).nextOverlapping();
    if (i.done) {
      let o = Math.min(e.doc.length, r + this.spec.unquoted.length);
      i = Af(this.spec, e, 0, o).nextOverlapping();
    }
    return i.done || i.value.from == r && i.value.to == n ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, n) {
    for (let i = n; ; ) {
      let o = Math.max(r, i - 1e4 - this.spec.unquoted.length), s = Af(this.spec, e, o, i), a = null;
      for (; !s.nextOverlapping().done; )
        a = s.value;
      if (a)
        return a;
      if (o == r)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, n) {
    let i = this.prevMatchInRange(e, 0, r);
    return i || (i = this.prevMatchInRange(e, Math.max(0, n - this.spec.unquoted.length), e.doc.length)), i && (i.from != r || i.to != n) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let n = Af(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let o = Af(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
function Ef(t, e, r, n) {
  return new TR(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? Une(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, n);
}
function E1(t, e) {
  return t.slice(Xn(t, e, !1), e);
}
function D1(t, e) {
  return t.slice(e, Xn(t, e));
}
function Une(t) {
  return (e, r, n) => !n[0].length || (t(E1(n.input, n.index)) != Wr.Word || t(D1(n.input, n.index)) != Wr.Word) && (t(D1(n.input, n.index + n[0].length)) != Wr.Word || t(E1(n.input, n.index + n[0].length)) != Wr.Word);
}
class Hne extends RR {
  nextMatch(e, r, n) {
    let i = Ef(this.spec, e, n, e.doc.length).next();
    return i.done && (i = Ef(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = 1; ; i++) {
      let o = Math.max(
        r,
        n - i * 1e4
        /* FindPrev.ChunkSize */
      ), s = Ef(this.spec, e, o, n), a = null;
      for (; !s.next().done; )
        a = s.value;
      if (a && (o == r || a.from > o + 10))
        return a;
      if (o == r)
        return null;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (r, n) => {
      if (n == "&")
        return e.match[0];
      if (n == "$")
        return "$";
      for (let i = n.length; i > 0; i--) {
        let o = +n.slice(0, i);
        if (o > 0 && o < e.match.length)
          return e.match[o] + n.slice(i);
      }
      return r;
    });
  }
  matchAll(e, r) {
    let n = Ef(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let o = Ef(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
const mg = /* @__PURE__ */ kt.define(), N4 = /* @__PURE__ */ kt.define(), Vu = /* @__PURE__ */ qn.define({
  create(t) {
    return new q2(mC(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(mg) ? t = new q2(r.value.create(), t.panel) : r.is(N4) && (t = new q2(t.query, r.value ? $4 : null));
    return t;
  },
  provide: (t) => ng.from(t, (e) => e.panel)
});
class q2 {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const Vne = /* @__PURE__ */ ft.mark({ class: "cm-searchMatch" }), Wne = /* @__PURE__ */ ft.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Gne = /* @__PURE__ */ kn.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Vu));
  }
  update(t) {
    let e = t.state.field(Vu);
    (e != t.startState.field(Vu) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return ft.none;
    let { view: r } = this, n = new nc();
    for (let i = 0, o = r.visibleRanges, s = o.length; i < s; i++) {
      let { from: a, to: l } = o[i];
      for (; i < s - 1 && l > o[i + 1].from - 500; )
        l = o[++i].to;
      t.highlight(r.state, a, l, (u, c) => {
        let h = r.state.selection.ranges.some((d) => d.from == u && d.to == c);
        n.add(u, c, h ? Wne : Vne);
      });
    }
    return n.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function i0(t) {
  return (e) => {
    let r = e.state.field(Vu, !1);
    return r && r.query.spec.valid ? t(e, r) : IR(e);
  };
}
const O1 = /* @__PURE__ */ i0((t, { query: e }) => {
  let { to: r } = t.state.selection.main, n = e.nextMatch(t.state, r, r);
  if (!n)
    return !1;
  let i = de.single(n.from, n.to), o = t.state.facet(ep);
  return t.dispatch({
    selection: i,
    effects: [I4(t, n), o.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), $R(t), !0;
}), F1 = /* @__PURE__ */ i0((t, { query: e }) => {
  let { state: r } = t, { from: n } = r.selection.main, i = e.prevMatch(r, n, n);
  if (!i)
    return !1;
  let o = de.single(i.from, i.to), s = t.state.facet(ep);
  return t.dispatch({
    selection: o,
    effects: [I4(t, i), s.scrollToMatch(o.main, t)],
    userEvent: "select.search"
  }), $R(t), !0;
}), Kne = /* @__PURE__ */ i0((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: de.create(r.map((n) => de.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Xne = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: n, to: i } = r.main, o = [], s = 0;
  for (let a = new Ed(t.doc, t.sliceDoc(n, i)); !a.next().done; ) {
    if (o.length > 1e3)
      return !1;
    a.value.from == n && (s = o.length), o.push(de.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: de.create(o, s),
    userEvent: "select.search.matches"
  })), !0;
}, S8 = /* @__PURE__ */ i0((t, { query: e }) => {
  let { state: r } = t, { from: n, to: i } = r.selection.main;
  if (r.readOnly)
    return !1;
  let o = e.nextMatch(r, n, n);
  if (!o)
    return !1;
  let s = o, a = [], l, u, c = [];
  s.from == n && s.to == i && (u = r.toText(e.getReplacement(s)), a.push({ from: s.from, to: s.to, insert: u }), s = e.nextMatch(r, s.from, s.to), c.push(Ie.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(n).number) + ".")));
  let h = t.state.changes(a);
  return s && (l = de.single(s.from, s.to).map(h), c.push(I4(t, s)), c.push(r.facet(ep).scrollToMatch(l.main, t))), t.dispatch({
    changes: h,
    selection: l,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), Qne = /* @__PURE__ */ i0((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((i) => {
    let { from: o, to: s } = i;
    return { from: o, to: s, insert: e.getReplacement(i) };
  });
  if (!r.length)
    return !1;
  let n = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: Ie.announce.of(n),
    userEvent: "input.replace.all"
  }), !0;
});
function $4(t) {
  return t.state.facet(ep).createPanel(t);
}
function mC(t, e) {
  var r, n, i, o, s;
  let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let u = t.facet(ep);
  return new PR({
    search: ((r = e?.literal) !== null && r !== void 0 ? r : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (n = e?.caseSensitive) !== null && n !== void 0 ? n : u.caseSensitive,
    literal: (i = e?.literal) !== null && i !== void 0 ? i : u.literal,
    regexp: (o = e?.regexp) !== null && o !== void 0 ? o : u.regexp,
    wholeWord: (s = e?.wholeWord) !== null && s !== void 0 ? s : u.wholeWord
  });
}
function NR(t) {
  let e = rg(t, $4);
  return e && e.dom.querySelector("[main-field]");
}
function $R(t) {
  let e = NR(t);
  e && e == t.root.activeElement && e.select();
}
const IR = (t) => {
  let e = t.state.field(Vu, !1);
  if (e && e.panel) {
    let r = NR(t);
    if (r && r != t.root.activeElement) {
      let n = mC(t.state, e.query.spec);
      n.valid && t.dispatch({ effects: mg.of(n) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      N4.of(!0),
      e ? mg.of(mC(t.state, e.query.spec)) : kt.appendConfig.of(eie)
    ] });
  return !0;
}, BR = (t) => {
  let e = t.state.field(Vu, !1);
  if (!e || !e.panel)
    return !1;
  let r = rg(t, $4);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: N4.of(!1) }), !0;
}, Jne = [
  { key: "Mod-f", run: IR, scope: "editor search-panel" },
  { key: "F3", run: O1, shift: F1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: O1, shift: F1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: BR, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Xne },
  { key: "Mod-Alt-g", run: Dne },
  { key: "Mod-d", run: zne, preventDefault: !0 }
];
class Yne {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(Vu).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Or("input", {
      value: r.search,
      placeholder: Eo(e, "Find"),
      "aria-label": Eo(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Or("input", {
      value: r.replace,
      placeholder: Eo(e, "Replace"),
      "aria-label": Eo(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Or("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = Or("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = Or("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function n(i, o, s) {
      return Or("button", { class: "cm-button", name: i, onclick: o, type: "button" }, s);
    }
    this.dom = Or("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      n("next", () => O1(e), [Eo(e, "next")]),
      n("prev", () => F1(e), [Eo(e, "previous")]),
      n("select", () => Kne(e), [Eo(e, "all")]),
      Or("label", null, [this.caseField, Eo(e, "match case")]),
      Or("label", null, [this.reField, Eo(e, "regexp")]),
      Or("label", null, [this.wordField, Eo(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Or("br"),
        this.replaceField,
        n("replace", () => S8(e), [Eo(e, "replace")]),
        n("replaceAll", () => Qne(e), [Eo(e, "replace all")])
      ],
      Or("button", {
        name: "close",
        onclick: () => BR(e),
        "aria-label": Eo(e, "close"),
        type: "button"
      }, ["Ã—"])
    ]);
  }
  commit() {
    let e = new PR({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: mg.of(e) }));
  }
  keydown(e) {
    dY(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? F1 : O1)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), S8(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(mg) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(ep).top;
  }
}
function Eo(t, e) {
  return t.state.phrase(e);
}
const Wv = 30, Gv = /[\s\.,:;?!]/;
function I4(t, { from: e, to: r }) {
  let n = t.state.doc.lineAt(e), i = t.state.doc.lineAt(r).to, o = Math.max(n.from, e - Wv), s = Math.min(i, r + Wv), a = t.state.sliceDoc(o, s);
  if (o != n.from) {
    for (let l = 0; l < Wv; l++)
      if (!Gv.test(a[l + 1]) && Gv.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (s != i) {
    for (let l = a.length - 1; l > a.length - Wv; l--)
      if (!Gv.test(a[l - 1]) && Gv.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return Ie.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${n.number}.`);
}
const Zne = /* @__PURE__ */ Ie.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), eie = [
  Vu,
  /* @__PURE__ */ mc.low(Gne),
  Zne
], tie = "#e5c07b", A8 = "#e06c75", rie = "#56b6c2", nie = "#ffffff", jy = "#abb2bf", gC = "#7d8799", iie = "#61afef", oie = "#98c379", E8 = "#d19a66", sie = "#c678dd", aie = "#21252b", D8 = "#2c313a", O8 = "#282c34", U2 = "#353a42", lie = "#3E4451", F8 = "#528bff", uie = /* @__PURE__ */ Ie.theme({
  "&": {
    color: jy,
    backgroundColor: O8
  },
  ".cm-content": {
    caretColor: F8
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: F8 },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: lie },
  ".cm-panels": { backgroundColor: aie, color: jy },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: O8,
    color: gC,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: D8
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: U2
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: U2,
    borderBottomColor: U2
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: D8,
      color: jy
    }
  }
}, { dark: !0 }), cie = /* @__PURE__ */ t0.define([
  {
    tag: oe.keyword,
    color: sie
  },
  {
    tag: [oe.name, oe.deleted, oe.character, oe.propertyName, oe.macroName],
    color: A8
  },
  {
    tag: [/* @__PURE__ */ oe.function(oe.variableName), oe.labelName],
    color: iie
  },
  {
    tag: [oe.color, /* @__PURE__ */ oe.constant(oe.name), /* @__PURE__ */ oe.standard(oe.name)],
    color: E8
  },
  {
    tag: [/* @__PURE__ */ oe.definition(oe.name), oe.separator],
    color: jy
  },
  {
    tag: [oe.typeName, oe.className, oe.number, oe.changed, oe.annotation, oe.modifier, oe.self, oe.namespace],
    color: tie
  },
  {
    tag: [oe.operator, oe.operatorKeyword, oe.url, oe.escape, oe.regexp, oe.link, /* @__PURE__ */ oe.special(oe.string)],
    color: rie
  },
  {
    tag: [oe.meta, oe.comment],
    color: gC
  },
  {
    tag: oe.strong,
    fontWeight: "bold"
  },
  {
    tag: oe.emphasis,
    fontStyle: "italic"
  },
  {
    tag: oe.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: oe.link,
    color: gC,
    textDecoration: "underline"
  },
  {
    tag: oe.heading,
    fontWeight: "bold",
    color: A8
  },
  {
    tag: [oe.atom, oe.bool, /* @__PURE__ */ oe.special(oe.variableName)],
    color: E8
  },
  {
    tag: [oe.processingInstruction, oe.string, oe.inserted],
    color: oie
  },
  {
    tag: oe.invalid,
    color: nie
  }
]), hie = [uie, /* @__PURE__ */ kP(cie)];
function zh(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var vC = { exports: {} }, fie = vC.exports, T8;
function die() {
  return T8 || (T8 = 1, (function(t) {
    (function(e, r) {
      t.exports ? t.exports = r() : e.log = r();
    })(fie, function() {
      var e = function() {
      }, r = "undefined", n = typeof window !== r && typeof window.navigator !== r && /Trident\/|MSIE /.test(window.navigator.userAgent), i = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], o = {}, s = null;
      function a(v, y) {
        var b = v[y];
        if (typeof b.bind == "function")
          return b.bind(v);
        try {
          return Function.prototype.bind.call(b, v);
        } catch {
          return function() {
            return Function.prototype.apply.apply(b, [v, arguments]);
          };
        }
      }
      function l() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function u(v) {
        return v === "debug" && (v = "log"), typeof console === r ? !1 : v === "trace" && n ? l : console[v] !== void 0 ? a(console, v) : console.log !== void 0 ? a(console, "log") : e;
      }
      function c() {
        for (var v = this.getLevel(), y = 0; y < i.length; y++) {
          var b = i[y];
          this[b] = y < v ? e : this.methodFactory(b, v, this.name);
        }
        if (this.log = this.debug, typeof console === r && v < this.levels.SILENT)
          return "No console available for logging";
      }
      function h(v) {
        return function() {
          typeof console !== r && (c.call(this), this[v].apply(this, arguments));
        };
      }
      function d(v, y, b) {
        return u(v) || h.apply(this, arguments);
      }
      function p(v, y) {
        var b = this, k, C, S, _ = "loglevel";
        typeof v == "string" ? _ += ":" + v : typeof v == "symbol" && (_ = void 0);
        function D(N) {
          var P = (i[N] || "silent").toUpperCase();
          if (!(typeof window === r || !_)) {
            try {
              window.localStorage[_] = P;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(_) + "=" + P + ";";
            } catch {
            }
          }
        }
        function A() {
          var N;
          if (!(typeof window === r || !_)) {
            try {
              N = window.localStorage[_];
            } catch {
            }
            if (typeof N === r)
              try {
                var P = window.document.cookie, I = encodeURIComponent(_), B = P.indexOf(I + "=");
                B !== -1 && (N = /^([^;]+)/.exec(
                  P.slice(B + I.length + 1)
                )[1]);
              } catch {
              }
            return b.levels[N] === void 0 && (N = void 0), N;
          }
        }
        function O() {
          if (!(typeof window === r || !_)) {
            try {
              window.localStorage.removeItem(_);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(_) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function M(N) {
          var P = N;
          if (typeof P == "string" && b.levels[P.toUpperCase()] !== void 0 && (P = b.levels[P.toUpperCase()]), typeof P == "number" && P >= 0 && P <= b.levels.SILENT)
            return P;
          throw new TypeError("log.setLevel() called with invalid level: " + N);
        }
        b.name = v, b.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, b.methodFactory = y || d, b.getLevel = function() {
          return S ?? C ?? k;
        }, b.setLevel = function(N, P) {
          return S = M(N), P !== !1 && D(S), c.call(b);
        }, b.setDefaultLevel = function(N) {
          C = M(N), A() || b.setLevel(N, !1);
        }, b.resetLevel = function() {
          S = null, O(), c.call(b);
        }, b.enableAll = function(N) {
          b.setLevel(b.levels.TRACE, N);
        }, b.disableAll = function(N) {
          b.setLevel(b.levels.SILENT, N);
        }, b.rebuild = function() {
          if (s !== b && (k = M(s.getLevel())), c.call(b), s === b)
            for (var N in o)
              o[N].rebuild();
        }, k = M(
          s ? s.getLevel() : "WARN"
        );
        var z = A();
        z != null && (S = M(z)), c.call(b);
      }
      s = new p(), s.getLogger = function(v) {
        if (typeof v != "symbol" && typeof v != "string" || v === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var y = o[v];
        return y || (y = o[v] = new p(
          v,
          s.methodFactory
        )), y;
      };
      var g = typeof window !== r ? window.log : void 0;
      return s.noConflict = function() {
        return typeof window !== r && window.log === s && (window.log = g), s;
      }, s.getLoggers = function() {
        return o;
      }, s.default = s, s;
    });
  })(vC)), vC.exports;
}
var pie = die();
const LR = /* @__PURE__ */ zh(pie);
LR.setLevel("silent");
const Xr = LR, xt = {
  STRING: "String",
  NUMBER: "Number",
  TRUE: "True",
  FALSE: "False",
  NULL: "Null",
  OBJECT: "Object",
  ARRAY: "Array",
  PROPERTY: "Property",
  PROPERTY_NAME: "PropertyName",
  PROPERTY_COLON: "PropertyColon",
  // used in json5 grammar
  ITEM: "Item",
  // used in yaml grammar
  JSON_TEXT: "JsonText",
  INVALID: "âš "
}, mie = {
  Pair: xt.PROPERTY,
  Key: xt.PROPERTY_NAME,
  BlockSequence: xt.ARRAY,
  BlockMapping: xt.OBJECT,
  FlowSequence: xt.ARRAY,
  FlowMapping: xt.OBJECT,
  QuotedLiteral: xt.STRING,
  Literal: xt.STRING,
  // best guess
  Stream: xt.JSON_TEXT,
  Document: xt.OBJECT
}, gie = {
  File: xt.JSON_TEXT
}, B4 = [
  xt.STRING,
  xt.NUMBER,
  xt.TRUE,
  xt.FALSE,
  xt.NULL
], zR = [xt.OBJECT, xt.ARRAY, xt.ITEM], Hr = {
  JSON5: "json5",
  JSON: "json4",
  YAML: "yaml"
}, pn = (t, e) => {
  var r, n;
  switch (e) {
    case Hr.YAML:
      return (r = mie[t]) !== null && r !== void 0 ? r : t;
    case Hr.JSON5:
      return (n = gie[t]) !== null && n !== void 0 ? n : t;
    default:
      return t;
  }
};
function jR(t, e, r) {
  const n = [];
  for (let i = e; i?.parent; i = i.parent)
    switch (pn(i.parent.name, r)) {
      case xt.PROPERTY: {
        const o = yC(i.parent, xt.PROPERTY_NAME, r);
        if (o) {
          let s = Df(t, o).replace(/[/~]/g, (a) => a === "~" ? "~0" : "~1");
          n.unshift(s);
        }
        break;
      }
      case xt.ARRAY: {
        if (yie(i, r)) {
          const o = HR(i.parent, i, r);
          n.unshift(`${o}`);
        }
        break;
      }
    }
  return n.length === 0 ? "" : "/" + n.join("/");
}
const qR = (t, e, r = -1, n) => jR(t.doc, On(t).resolve(e, r), n), L4 = (t, e) => {
  const r = On(t), n = /* @__PURE__ */ new Map();
  return r.iterate({
    enter: (i) => {
      var o, s, a, l, u, c, h, d;
      if ([xt.PROPERTY_NAME, xt.OBJECT].includes(pn(i.name, e))) {
        const p = jR(t.doc, i.node, e), { from: g, to: v } = i.node;
        if (!(!((s = (o = i.node) === null || o === void 0 ? void 0 : o.nextSibling) === null || s === void 0) && s.node))
          return n.set(p, { keyFrom: g, keyTo: v }), !0;
        const y = e === Hr.JSON ? (l = (a = i.node) === null || a === void 0 ? void 0 : a.nextSibling) === null || l === void 0 ? void 0 : l.node : (d = (h = (c = (u = i.node) === null || u === void 0 ? void 0 : u.nextSibling) === null || c === void 0 ? void 0 : c.node) === null || h === void 0 ? void 0 : h.nextSibling) === null || d === void 0 ? void 0 : d.node;
        if (!y)
          return n.set(p, { keyFrom: g, keyTo: v }), !0;
        const { from: b, to: k } = y;
        return n.set(p, { keyFrom: g, keyTo: v, valueFrom: b, valueTo: k }), !0;
      }
    }
  }), n;
}, H2 = (t, e, r = -1) => On(t).resolveInner(e, r), qy = (t) => t.replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1"), vie = (t) => t.replace(/^"(.*)"$/, "'$1'"), Df = (t, e, r = !0, n = !0) => {
  const i = e ? t.sliceString(e.from, e.to) : "";
  return r ? n ? qy(i) : i.replace(/(^["'])|(["']$)/g, "") : i;
}, UR = (t, e) => {
  var r, n, i, o;
  return pn(t.name, e) === xt.INVALID && (pn((n = (r = t.prevSibling) === null || r === void 0 ? void 0 : r.name) !== null && n !== void 0 ? n : "", e) === xt.PROPERTY_NAME || pn((o = (i = t.prevSibling) === null || i === void 0 ? void 0 : i.name) !== null && o !== void 0 ? o : "", e) === xt.PROPERTY_COLON);
}, Uy = (t, e) => B4.includes(pn(t.name, e)) || UR(t, e), yie = (t, e) => [...B4, ...zR].includes(pn(t.name, e)) || UR(t, e), Kv = (t, e) => {
  var r, n, i, o, s, a;
  return pn(t.name, e) === xt.PROPERTY_NAME || pn(t.name, e) === xt.INVALID && (pn((n = (r = t.prevSibling) === null || r === void 0 ? void 0 : r.name) !== null && n !== void 0 ? n : "", e) === xt.PROPERTY || pn((o = (i = t.prevSibling) === null || i === void 0 ? void 0 : i.name) !== null && o !== void 0 ? o : "", e) === "{") || // TODO: Can we make this work without checking for the mode?
  e === Hr.YAML && pn((a = (s = t.parent) === null || s === void 0 ? void 0 : s.name) !== null && a !== void 0 ? a : "", e) === xt.OBJECT;
}, o0 = (t) => {
  const e = [];
  let r = t.firstChild;
  for (; r; )
    r && e.push(r), r = r?.nextSibling;
  return e;
}, bie = (t, e, r) => o0(t).filter((n) => pn(n.name, r) === e), yC = (t, e, r) => {
  var n;
  return (n = o0(t).find((i) => pn(i.name, r) === e)) !== null && n !== void 0 ? n : null;
}, M8 = (t, e) => o0(t).find((r) => Uy(r, e)), xie = (t, e) => o0(t).filter((r) => B4.includes(pn(r.name, e)) || zR.includes(pn(r.name, e))), HR = (t, e, r) => xie(t, r).findIndex((n) => n.from === e.from && n.to === e.to), P8 = (t, e, r, n = 1 / 0) => {
  let i = t;
  for (; i && n > 0; ) {
    if (pn(i.name, r) === e)
      return i;
    i = i.parent, n--;
  }
  return null;
}, wie = kt.define(), T1 = qn.define({
  create() {
  },
  update(t, e) {
    for (const r of e.effects)
      if (r.is(wie))
        return r.value;
    return t;
  }
}), z4 = (t) => t.field(T1), kie = (t) => [
  T1.init(() => t)
], Cie = {
  // validation errors
  AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",
  AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",
  AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",
  AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",
  ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",
  containsAnyError: "The array at `{{pointer}}` must contain at least one item",
  ContainsArrayError: "The property at `{{pointer}}` must not be an array",
  ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",
  EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",
  ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",
  FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",
  FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",
  FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",
  FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",
  FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",
  FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",
  FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",
  FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",
  FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",
  FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",
  FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",
  FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",
  FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",
  InvalidDataError: "No value may be specified in `{{pointer}}`",
  InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",
  MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",
  MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",
  MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",
  MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`",
  MinItemsOneError: "At least one item is required in `{{pointer}}`",
  MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",
  MinLengthOneError: "A value is required in `{{pointer}}`",
  MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`",
  MissingDependencyError: "The required propery '{{missingProperty}}' in `{{pointer}}` is missing",
  MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",
  MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",
  MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",
  NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",
  NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",
  OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",
  OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",
  PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",
  PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",
  RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",
  SchemaWarning: "Failed retrieving a schema from '{{pointer}}' to key '{{key}}'",
  TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",
  UndefinedValueError: "Value must not be undefined in `{{pointer}}`",
  UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",
  UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",
  ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"
}, _ie = Object.prototype.toString;
function rr(t) {
  const e = _ie.call(t).match(/\s([^\]]+)\]/).pop().toLowerCase();
  return e === "file" ? "object" : e;
}
const Sie = "object", Aie = "array";
function Eie(t, e = {}) {
  return t.replace(/\{\{\w+\}\}/g, (r) => {
    const n = r.replace(/[{}]/g, ""), i = e[n], o = rr(i);
    return o === Sie || o === Aie ? JSON.stringify(i) : i;
  });
}
function Die(t, e, r = t) {
  var n;
  const i = (n = Cie[t]) !== null && n !== void 0 ? n : r;
  return Eie(i, e);
}
function Oie(t) {
  return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function Fie(t, e) {
  return {
    type: "error",
    name: t,
    code: Oie(t),
    message: Die(t, e),
    data: e
  };
}
function Ke(t) {
  return Fie.bind(null, t);
}
function gg(t, e = []) {
  for (let r = 0; r < t.length; r += 1) {
    const n = t[r];
    Array.isArray(n) ? gg(n, e) : e.push(n);
  }
  return e;
}
const tp = {
  DECLARATOR_ONEOF: "oneOfProperty",
  GET_TEMPLATE_RECURSION_LIMIT: 1,
  propertyBlacklist: ["_id"],
  templateDefaultOptions: {
    addOptionalProps: !1,
    removeInvalidData: !1,
    extendDefaults: !0
  }
};
function Pm(t, e, r) {
  const n = { ...e };
  return Object.defineProperty(n, "getOneOfOrigin", {
    enumerable: !1,
    value: () => ({
      index: r,
      schema: t
    })
  }), n;
}
function vi(t) {
  return t?.type === "error";
}
function Tie(t) {
  return t instanceof Promise;
}
function M1(t) {
  return vi(t) || Tie(t);
}
const { DECLARATOR_ONEOF: Qf } = tp;
function VR(t, e, r = t.rootSchema, n = "#") {
  if (e != null && r[Qf]) {
    const s = [], a = r[Qf], l = e[r[Qf]];
    if (l === void 0)
      return t.errors.missingOneOfPropertyError({
        property: a,
        pointer: n,
        schema: r,
        value: e
      });
    for (let u = 0; u < r.oneOf.length; u += 1) {
      const c = t.resolveRef(r.oneOf[u]), h = t.step(a, c, e, n);
      if (vi(h))
        return h;
      let d = gg(t.validate(l, h, n));
      if (d = d.filter(M1), d.length > 0)
        s.push(...d);
      else
        return Pm(r, c, u);
    }
    return t.errors.oneOfPropertyError({
      property: a,
      value: l,
      pointer: n,
      schema: r,
      errors: s
    });
  }
  const i = [], o = [];
  for (let s = 0; s < r.oneOf.length; s += 1) {
    const a = t.resolveRef(r.oneOf[s]);
    let l = gg(t.validate(e, a, n));
    l = l.filter(M1), l.length > 0 ? o.push(...l) : i.push({ index: s, schema: a });
  }
  return i.length === 1 ? Pm(r, i[0].schema, i[0].index) : i.length > 1 ? t.errors.multipleOneOfError({
    value: e,
    pointer: n,
    schema: r,
    matches: i
  }) : t.errors.oneOfError({
    value: JSON.stringify(e),
    pointer: n,
    schema: r,
    oneOf: r.oneOf,
    errors: o
  });
}
function Mie(t, e, r, n) {
  if (r == null || e.properties == null)
    return -1;
  let i = 0;
  const o = Object.keys(e.properties);
  for (let s = 0; s < o.length; s += 1) {
    const a = o[s];
    r[a] != null && t.isValid(r[a], e.properties[a], n) && (i += 1);
  }
  return i;
}
function j4(t, e, r = t.rootSchema, n = "#") {
  if (e != null && r[Qf]) {
    const o = [], s = r[Qf], a = e[r[Qf]];
    if (a === void 0)
      return t.errors.missingOneOfPropertyError({
        property: s,
        pointer: n,
        schema: r,
        value: e
      });
    for (let l = 0; l < r.oneOf.length; l += 1) {
      const u = t.resolveRef(r.oneOf[l]), c = t.step(s, u, e, n);
      if (vi(c))
        return c;
      let h = gg(t.validate(a, c, n));
      if (h = h.filter(M1), h.length > 0)
        o.push(...h);
      else
        return Pm(r, u, l);
    }
    return t.errors.oneOfPropertyError({
      property: s,
      value: a,
      pointer: n,
      schema: r,
      errors: o
    });
  }
  const i = [];
  for (let o = 0; o < r.oneOf.length; o += 1) {
    const s = t.resolveRef(r.oneOf[o]);
    t.isValid(e, s, n) && i.push({ schema: s, index: o });
  }
  if (i.length === 1)
    return Pm(r, i[0].schema, i[0].index);
  if (rr(e) === "object") {
    let o, s = -1, a = 0;
    for (let l = 0; l < r.oneOf.length; l += 1) {
      const u = t.resolveRef(r.oneOf[l]), c = Mie(t, u, e);
      a < c && (a = c, o = r.oneOf[l], s = l);
    }
    return o === void 0 ? t.errors.oneOfError({
      value: JSON.stringify(e),
      pointer: n,
      schema: r,
      oneOf: r.oneOf
    }) : Pm(r, o, s);
  }
  return i.length > 1 ? t.errors.multipleOneOfError({ matches: i, pointer: n, schema: r, value: e }) : t.errors.oneOfError({
    value: JSON.stringify(e),
    pointer: n,
    schema: r,
    oneOf: r.oneOf
  });
}
const Pie = (t, e, r, n) => {
  if (Array.isArray(e.oneOf)) {
    const i = t.resolveOneOf(r, e, n);
    if (vi(i))
      return i;
  }
};
var V2, R8;
function Rie() {
  if (R8) return V2;
  R8 = 1;
  var t = function(b) {
    return e(b) && !r(b);
  };
  function e(b) {
    return !!b && typeof b == "object";
  }
  function r(b) {
    var k = Object.prototype.toString.call(b);
    return k === "[object RegExp]" || k === "[object Date]" || o(b);
  }
  var n = typeof Symbol == "function" && Symbol.for, i = n ? Symbol.for("react.element") : 60103;
  function o(b) {
    return b.$$typeof === i;
  }
  function s(b) {
    return Array.isArray(b) ? [] : {};
  }
  function a(b, k) {
    return k.clone !== !1 && k.isMergeableObject(b) ? v(s(b), b, k) : b;
  }
  function l(b, k, C) {
    return b.concat(k).map(function(S) {
      return a(S, C);
    });
  }
  function u(b, k) {
    if (!k.customMerge)
      return v;
    var C = k.customMerge(b);
    return typeof C == "function" ? C : v;
  }
  function c(b) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(b).filter(function(k) {
      return Object.propertyIsEnumerable.call(b, k);
    }) : [];
  }
  function h(b) {
    return Object.keys(b).concat(c(b));
  }
  function d(b, k) {
    try {
      return k in b;
    } catch {
      return !1;
    }
  }
  function p(b, k) {
    return d(b, k) && !(Object.hasOwnProperty.call(b, k) && Object.propertyIsEnumerable.call(b, k));
  }
  function g(b, k, C) {
    var S = {};
    return C.isMergeableObject(b) && h(b).forEach(function(_) {
      S[_] = a(b[_], C);
    }), h(k).forEach(function(_) {
      p(b, _) || (d(b, _) && C.isMergeableObject(k[_]) ? S[_] = u(_, C)(b[_], k[_], C) : S[_] = a(k[_], C));
    }), S;
  }
  function v(b, k, C) {
    C = C || {}, C.arrayMerge = C.arrayMerge || l, C.isMergeableObject = C.isMergeableObject || t, C.cloneUnlessOtherwiseSpecified = a;
    var S = Array.isArray(k), _ = Array.isArray(b), D = S === _;
    return D ? S ? C.arrayMerge(b, k, C) : g(b, k, C) : a(k, C);
  }
  v.all = function(b, k) {
    if (!Array.isArray(b))
      throw new Error("first argument should be an array");
    return b.reduce(function(C, S) {
      return v(C, S, k);
    }, {});
  };
  var y = v;
  return V2 = y, V2;
}
var Nie = Rie();
const WR = /* @__PURE__ */ zh(Nie), $ie = (t, e) => e, q4 = (t, e) => WR(t, e, { arrayMerge: $ie }), Iie = (t, e) => {
  const r = t.concat(e);
  return r.filter((n, i) => r.indexOf(n) === i);
}, Bie = (t, e) => WR(t, e, { arrayMerge: Iie });
function Ti(t, e) {
  const r = rr(t), n = rr(e);
  if (r !== n)
    return t;
  const i = Bie(t, e);
  return t.getOneOfOrigin ? Object.defineProperty(i, "getOneOfOrigin", {
    enumerable: !1,
    value: t.getOneOfOrigin
  }) : e.getOneOfOrigin && Object.defineProperty(i, "getOneOfOrigin", {
    enumerable: !1,
    value: e.getOneOfOrigin
  }), i;
}
function vg(t, ...e) {
  const r = {};
  return Object.keys(t).forEach((n) => {
    e.includes(n) || (r[n] = t[n]);
  }), t.getOneOfOrigin && Object.defineProperty(r, "getOneOfOrigin", {
    enumerable: !1,
    value: t.getOneOfOrigin
  }), r;
}
var Lie = Function.prototype.toString, W2 = Object.create, zie = Object.prototype.toString, jie = (
  /** @class */
  (function() {
    function t() {
      this._keys = [], this._values = [];
    }
    return t.prototype.has = function(e) {
      return !!~this._keys.indexOf(e);
    }, t.prototype.get = function(e) {
      return this._values[this._keys.indexOf(e)];
    }, t.prototype.set = function(e, r) {
      this._keys.push(e), this._values.push(r);
    }, t;
  })()
);
function qie() {
  return new jie();
}
function Uie() {
  return /* @__PURE__ */ new WeakMap();
}
var Hie = typeof WeakMap < "u" ? Uie : qie;
function U4(t) {
  if (!t)
    return W2(null);
  var e = t.constructor;
  if (e === Object)
    return t === Object.prototype ? {} : W2(t);
  if (e && ~Lie.call(e).indexOf("[native code]"))
    try {
      return new e();
    } catch {
    }
  return W2(t);
}
function Vie(t) {
  var e = "";
  return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.unicode && (e += "u"), t.sticky && (e += "y"), e;
}
function Wie(t) {
  return t.flags;
}
var Gie = /test/g.flags === "g" ? Wie : Vie;
function GR(t) {
  var e = zie.call(t);
  return e.substring(8, e.length - 1);
}
function Kie(t) {
  return t[Symbol.toStringTag] || GR(t);
}
var Xie = typeof Symbol < "u" ? Kie : GR, Qie = Object.defineProperty, Jie = Object.getOwnPropertyDescriptor, KR = Object.getOwnPropertyNames, H4 = Object.getOwnPropertySymbols, XR = Object.prototype, QR = XR.hasOwnProperty, Yie = XR.propertyIsEnumerable, JR = typeof H4 == "function";
function Zie(t) {
  return KR(t).concat(H4(t));
}
var eoe = JR ? Zie : KR;
function Gb(t, e, r) {
  for (var n = eoe(t), i = 0, o = n.length, s = void 0, a = void 0; i < o; ++i)
    if (s = n[i], !(s === "callee" || s === "caller")) {
      if (a = Jie(t, s), !a) {
        e[s] = r.copier(t[s], r);
        continue;
      }
      !a.get && !a.set && (a.value = r.copier(a.value, r));
      try {
        Qie(e, s, a);
      } catch {
        e[s] = a.value;
      }
    }
  return e;
}
function toe(t, e) {
  var r = new e.Constructor();
  e.cache.set(t, r);
  for (var n = 0, i = t.length; n < i; ++n)
    r[n] = e.copier(t[n], e);
  return r;
}
function roe(t, e) {
  var r = new e.Constructor();
  return e.cache.set(t, r), Gb(t, r, e);
}
function YR(t, e) {
  return t.slice(0);
}
function noe(t, e) {
  return t.slice(0, t.size, t.type);
}
function ioe(t, e) {
  return new e.Constructor(YR(t.buffer));
}
function ooe(t, e) {
  return new e.Constructor(t.getTime());
}
function ZR(t, e) {
  var r = new e.Constructor();
  return e.cache.set(t, r), t.forEach(function(n, i) {
    r.set(i, e.copier(n, e));
  }), r;
}
function soe(t, e) {
  return Gb(t, ZR(t, e), e);
}
function aoe(t, e) {
  var r = U4(e.prototype);
  e.cache.set(t, r);
  for (var n in t)
    QR.call(t, n) && (r[n] = e.copier(t[n], e));
  return r;
}
function loe(t, e) {
  var r = U4(e.prototype);
  e.cache.set(t, r);
  for (var n in t)
    QR.call(t, n) && (r[n] = e.copier(t[n], e));
  for (var i = H4(t), o = 0, s = i.length, a = void 0; o < s; ++o)
    a = i[o], Yie.call(t, a) && (r[a] = e.copier(t[a], e));
  return r;
}
var uoe = JR ? loe : aoe;
function coe(t, e) {
  var r = U4(e.prototype);
  return e.cache.set(t, r), Gb(t, r, e);
}
function G2(t, e) {
  return new e.Constructor(t.valueOf());
}
function hoe(t, e) {
  var r = new e.Constructor(t.source, Gie(t));
  return r.lastIndex = t.lastIndex, r;
}
function Hy(t, e) {
  return t;
}
function eN(t, e) {
  var r = new e.Constructor();
  return e.cache.set(t, r), t.forEach(function(n) {
    r.add(e.copier(n, e));
  }), r;
}
function foe(t, e) {
  return Gb(t, eN(t, e), e);
}
var doe = Array.isArray, V4 = Object.assign, poe = Object.getPrototypeOf || (function(t) {
  return t.__proto__;
}), tN = {
  array: toe,
  arrayBuffer: YR,
  blob: noe,
  dataView: ioe,
  date: ooe,
  error: Hy,
  map: ZR,
  object: uoe,
  regExp: hoe,
  set: eN
}, moe = V4({}, tN, {
  array: roe,
  map: soe,
  object: coe,
  set: foe
});
function goe(t) {
  return {
    Arguments: t.object,
    Array: t.array,
    ArrayBuffer: t.arrayBuffer,
    Blob: t.blob,
    Boolean: G2,
    DataView: t.dataView,
    Date: t.date,
    Error: t.error,
    Float32Array: t.arrayBuffer,
    Float64Array: t.arrayBuffer,
    Int8Array: t.arrayBuffer,
    Int16Array: t.arrayBuffer,
    Int32Array: t.arrayBuffer,
    Map: t.map,
    Number: G2,
    Object: t.object,
    Promise: Hy,
    RegExp: t.regExp,
    Set: t.set,
    String: G2,
    WeakMap: Hy,
    WeakSet: Hy,
    Uint8Array: t.arrayBuffer,
    Uint8ClampedArray: t.arrayBuffer,
    Uint16Array: t.arrayBuffer,
    Uint32Array: t.arrayBuffer,
    Uint64Array: t.arrayBuffer
  };
}
function rN(t) {
  var e = V4({}, tN, t), r = goe(e), n = r.Array, i = r.Object;
  function o(s, a) {
    if (a.prototype = a.Constructor = void 0, !s || typeof s != "object")
      return s;
    if (a.cache.has(s))
      return a.cache.get(s);
    if (a.prototype = poe(s), a.Constructor = a.prototype && a.prototype.constructor, !a.Constructor || a.Constructor === Object)
      return i(s, a);
    if (doe(s))
      return n(s, a);
    var l = r[Xie(s)];
    return l ? l(s, a) : typeof s.then == "function" ? s : i(s, a);
  }
  return function(s) {
    return o(s, {
      Constructor: void 0,
      cache: Hie(),
      copier: o,
      prototype: void 0
    });
  };
}
function voe(t) {
  return rN(V4({}, moe, t));
}
voe({});
var P1 = rN({});
function Kb(t, e, r) {
  if (e.if != null) {
    if (e.if === !1)
      return e.else;
    if (e.if && (e.then || e.else)) {
      const n = t.validate(r, t.resolveRef(e.if));
      if (n.length === 0 && e.then)
        return t.resolveRef(e.then);
      if (n.length !== 0 && e.else)
        return t.resolveRef(e.else);
    }
  }
}
const yoe = (t, e, r, n) => {
  const i = Kb(t, e, r);
  if (i)
    return t.validate(r, i, n);
};
function nN(t, e, r) {
  var n;
  const i = { ...(n = t.resolveRef(e)) !== null && n !== void 0 ? n : {} };
  return Kb(t, i, r) || vg(i, "if", "then", "else");
}
function iN(t, e, r = t.rootSchema) {
  let n = P1(r);
  for (let i = 0; i < r.allOf.length; i += 1) {
    const o = nN(t, r.allOf[i], e);
    n = Ti(n, o);
  }
  return delete n.allOf, n;
}
function oN(t, e) {
  const { allOf: r } = e;
  if (!Array.isArray(r) || r.length === 0)
    return;
  let n = {};
  return r.forEach((i) => {
    n = Ti(n, t.resolveRef(i));
  }), n;
}
const boe = (t, e, r, n) => {
  const { allOf: i } = e;
  if (!Array.isArray(i) || i.length === 0)
    return;
  const o = [];
  return e.allOf.forEach((s) => {
    o.push(...t.validate(r, s, n));
  }), o;
};
function sN(t, e) {
  return t == null || t.$ref == null ? t : t.getRoot ? t.getRoot().getRef(t) : e.getRef(t);
}
function xoe(t) {
  return t.filter((e, r) => t.indexOf(e) === r);
}
function Wu(t) {
  return rr(t) === "object";
}
function aN(t, e, r) {
  const { dependencies: n } = e;
  if (!Wu(n) || !Wu(r))
    return;
  let i = !1, o = { required: [] };
  if (Object.keys(n).forEach((s) => {
    var a, l;
    if (r[s] == null && !(!((a = e.required) === null || a === void 0) && a.includes(s) || !((l = o.required) === null || l === void 0) && l.includes(s)))
      return;
    const u = n[s];
    if (Array.isArray(u)) {
      i = !0, o.required.push(...u);
      return;
    }
    if (Wu(u)) {
      i = !0, o = Ti(o, t.resolveRef(u));
      return;
    }
  }), i)
    return o.required = xoe(o.required), o;
}
const woe = (t, e, r, n) => {
  if (rr(e.dependencies) !== "object")
    return;
  const i = [];
  return Object.keys(r).forEach((o) => {
    if (e.dependencies[o] === void 0 || e.dependencies[o] === !0)
      return;
    if (e.dependencies[o] === !1) {
      i.push(t.errors.missingDependencyError({ pointer: n, schema: e, value: r }));
      return;
    }
    let s;
    const a = rr(e.dependencies[o]);
    if (a === "array")
      s = e.dependencies[o].filter((l) => r[l] === void 0).map((l) => t.errors.missingDependencyError({ missingProperty: l, pointer: n, schema: e, value: r }));
    else if (a === "object")
      s = t.validate(r, e.dependencies[o], n);
    else
      throw new Error(`Invalid dependency definition for ${n}/${o}. Must be string[] or schema`);
    i.push(...s);
  }), i.length > 0 ? i : void 0;
};
function lN(t, e, r) {
  if (!Array.isArray(e.anyOf) || e.anyOf.length === 0)
    return;
  let n;
  return e.anyOf.forEach((i) => {
    i = t.resolveRef(i), t.isValid(r, i) && (n = n ? Ti(n, i) : i);
  }), n;
}
function uN(t, e, r = t.rootSchema, n = "#") {
  const { anyOf: i } = r;
  if (!Array.isArray(i) || i.length === 0)
    return r;
  const o = lN(t, r, e);
  if (o == null)
    return t.errors.anyOfError({ pointer: n, schema: r, value: e, anyOf: JSON.stringify(i) });
  const s = Ti(r, o);
  return vg(s, "anyOf");
}
const koe = (t, e, r, n) => {
  if (!(!Array.isArray(e.anyOf) || e.anyOf.length === 0)) {
    for (let i = 0; i < e.anyOf.length; i += 1)
      if (t.isValid(r, e.anyOf[i]))
        return;
    return t.errors.anyOfError({ pointer: n, schema: e, value: r, anyOf: e.anyOf });
  }
}, N8 = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"], Coe = ["allOf", "anyOf", "oneOf", "dependencies", "if"];
function _oe(t) {
  const e = Object.keys(t);
  return Coe.findIndex((r) => e.includes(r)) !== -1;
}
function bC(t, e, r, n) {
  let i, o;
  if (e = t.resolveRef(e), e.oneOf) {
    const c = j4(t, r, e, n);
    vi(c) ? o = c : c && (i = Ti(i ?? {}, c));
  }
  if (Array.isArray(e.allOf)) {
    const c = e.allOf.map((h) => {
      if (_oe(h)) {
        let d = bC(t, h, r, n);
        return d ? (d = Ti(h, d), vg(d, ...N8)) : void 0;
      }
      return h;
    });
    if (c.length > 0) {
      const h = oN(t, { allOf: c });
      i = Ti(i ?? {}, h);
    }
  }
  const s = lN(t, e, r);
  s && (i = Ti(i ?? {}, s));
  const a = aN(t, e, r);
  a && (i = Ti(i ?? {}, a));
  const l = Kb(t, e, r);
  if (l && (i = Ti(i ?? {}, l)), i == null)
    return o;
  const u = bC(t, i, r, n);
  return u && (i = Ti(i, u)), vg(i, ...N8);
}
const Soe = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
function $8(t, e, r, n) {
  let i = bC(t, e, r, n);
  return i ? (i = Ti(e, i), vg(i, ...Soe)) : e;
}
class cN {
  constructor(e, r) {
    this.remotes = {}, this.errors = {}, this.typeKeywords = {}, this.validateKeyword = {}, this.validateType = {}, this.validateFormat = {}, this.config = e, this.typeKeywords = P1(e.typeKeywords), this.validateKeyword = Object.assign({}, e.validateKeyword), this.validateType = Object.assign({}, e.validateType), this.validateFormat = Object.assign({}, e.validateFormat), this.errors = Object.assign({}, e.errors), this.setSchema(r);
  }
  get rootSchema() {
    return this.__rootSchema;
  }
  set rootSchema(e) {
    e != null && (this.__rootSchema = this.config.compileSchema(this, e));
  }
  /**
   * register a json-schema to be referenced from another json-schema
   * @param url - base-url of json-schema (aka id)
   * @param schema - json-schema root
   */
  addRemoteSchema(e, r) {
    this.config.addRemoteSchema(this, e, r);
  }
  compileSchema(e) {
    var r;
    return this.config.compileSchema(this, e, (r = this.rootSchema) !== null && r !== void 0 ? r : e);
  }
  createSchemaOf(e) {
    return this.config.createSchemaOf(e);
  }
  /**
   * Iterates over data, retrieving its schema
   *
   * @param data - the data to iterate
   * @param callback - will be called with (schema, data, pointer) on each item
   * @param [schema] - the schema matching the data. Defaults to rootSchema
   * @param [pointer] - pointer to current data. Default to rootPointer
   */
  each(e, r, n, i) {
    return this.config.each(this, e, r, n, i);
  }
  eachSchema(e, r = this.rootSchema) {
    return this.config.eachSchema(r, e);
  }
  getChildSchemaSelection(e, r) {
    return this.config.getChildSchemaSelection(this, e, r);
  }
  /**
   * Returns the json-schema of a data-json-pointer.
   *
   * To resolve dynamic schema where the type of json-schema is evaluated by
   * its value, a data object has to be passed in options.
   *
   * Per default this function will return `undefined` for valid properties that
   * do not have a defined schema. Use the option `withSchemaWarning: true` to
   * receive an error with `code: schema-warning` containing the location of its
   * last evaluated json-schema.
   *
   * Notes
   *      - uses draft.step to walk through data and schema
   *
   * @param draft
   * @param pointer - json pointer in data to get the json schema for
   * @param [options.data] - the data object, which includes the json pointers value. This is optional, as
   *    long as no oneOf, anyOf, etc statement is part of the pointers schema
   * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema
   * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition
   * @return resolved json-schema object of requested json-pointer location
   */
  getSchema(e) {
    return this.config.getSchema(this, e);
  }
  /**
   * Create data object matching the given schema
   *
   * @param [data] - optional template data
   * @param [schema] - json schema, defaults to rootSchema
   * @return created template data
   */
  getTemplate(e, r, n = this.config.templateDefaultOptions) {
    return this.config.getTemplate(this, e, r, n);
  }
  isValid(e, r, n) {
    return this.config.isValid(this, e, r, n);
  }
  resolveAnyOf(e, r, n) {
    return this.config.resolveAnyOf(this, e, r, n);
  }
  resolveAllOf(e, r) {
    return this.config.resolveAllOf(this, e, r);
  }
  resolveRef(e) {
    return this.config.resolveRef(e, this.rootSchema);
  }
  resolveOneOf(e, r, n) {
    return this.config.resolveOneOf(this, e, r, n);
  }
  setSchema(e) {
    this.rootSchema = e;
  }
  /**
   * Returns the json-schema of the given object property or array item.
   * e.g. it steps by one key into the data
   *
   *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and
   *  returns the correct schema.
   *
   * @param  key       - property-name or array-index
   * @param  schema    - json schema of current data
   * @param  data      - parent of key
   * @param  [pointer] - pointer to schema and data (parent of key)
   * @return Schema or Error if failed resolving key
   */
  step(e, r, n, i) {
    return this.config.step(this, e, r, n, i);
  }
  /**
   * Validate data by a json schema
   *
   * @param value - value to validate
   * @param [schema] - json schema, defaults to rootSchema
   * @param [pointer] - json pointer pointing to value (used for error-messages only)
   * @return list of errors or empty
   */
  validate(e, r, n) {
    return this.config.validate(this, e, r, n);
  }
}
function hN(t, e, r) {
  r.id = r.id || e, t.remotes[e] = t.compileSchema(r);
}
var xC = { exports: {} }, Aoe = xC.exports, I8;
function Eoe() {
  return I8 || (I8 = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(typeof self < "u" ? self : Aoe, (() => (() => {
      var r = { d: (I, B) => {
        for (var $ in B) r.o(B, $) && !r.o(I, $) && Object.defineProperty(I, $, { enumerable: !0, get: B[$] });
      }, o: (I, B) => Object.prototype.hasOwnProperty.call(I, B), r: (I) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(I, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(I, "__esModule", { value: !0 });
      } }, n = {};
      function i(I) {
        return I === "#" || I === "" || Array.isArray(I) && I.length === 0 || !1;
      }
      r.r(n), r.d(n, { default: () => P, get: () => d, isRoot: () => i, join: () => z, remove: () => _, removeUndefinedItems: () => S, set: () => b, split: () => h, splitLast: () => N });
      const o = /~1/g, s = /~0/g, a = /\/+/g, l = /(^[#/]*|\/+$)/g;
      function u(I) {
        return I.replace(o, "/").replace(s, "~");
      }
      function c(I) {
        return u(decodeURIComponent(I));
      }
      function h(I) {
        if (I == null || typeof I != "string" || i(I)) return Array.isArray(I) ? I : [];
        const B = I.indexOf("#") >= 0 ? c : u, $ = (I = (I = I.replace(a, "/")).replace(l, "")).split("/");
        for (let j = 0, U = $.length; j < U; j += 1) $[j] = B($[j]);
        return $;
      }
      function d(I, B, $ = void 0) {
        if (B == null || I == null) return $;
        if (i(B)) return I;
        const j = p(I, h(B));
        return j === void 0 ? $ : j;
      }
      function p(I, B) {
        const $ = B.shift();
        if (I !== void 0) return $ !== void 0 ? p(I[$], B) : I;
      }
      const g = /^\[.*\]$/, v = /^\[(.+)\]$/;
      function y(I, B) {
        return I === "__proto__" || I == "constructor" && B.length > 0 && B[0] == "prototype";
      }
      function b(I, B, $) {
        if (B == null) return I;
        const j = h(B);
        if (j.length === 0) return I;
        I == null && (I = g.test(j[0]) ? [] : {});
        let U, H, G = I;
        for (; j.length > 1; ) U = j.shift(), H = g.test(j[0]), y(U, j) || (G = C(G, U, H));
        return U = j.pop(), k(G, U, $), I;
      }
      function k(I, B, $) {
        let j;
        const U = B.match(v);
        B === "[]" && Array.isArray(I) ? I.push($) : U ? (j = U.pop(), I[j] = $) : I[B] = $;
      }
      function C(I, B, $) {
        if (I[B] != null) return I[B];
        const j = $ ? [] : {};
        return k(I, B, j), j;
      }
      function S(I) {
        let B = 0, $ = 0;
        for (; B + $ < I.length; ) I[B + $] === void 0 && ($ += 1), I[B] = I[B + $], B += 1;
        return I.length = I.length - $, I;
      }
      function _(I, B, $) {
        const j = h(B), U = j.pop(), H = d(I, j);
        return H && delete H[U], Array.isArray(H) && $ !== !0 && S(H), I;
      }
      const D = /\/+/g, A = /~/g, O = /\//g;
      function M(I, B) {
        if (I.length === 0) return B ? "#" : "";
        for (let $ = 0, j = I.length; $ < j; $ += 1) I[$] = I[$].replace(A, "~0").replace(O, "~1"), B && (I[$] = encodeURIComponent(I[$]));
        return ((B ? "#/" : "/") + I.join("/")).replace(D, "/");
      }
      function z(I, ...B) {
        const $ = [];
        if (Array.isArray(I)) return M(I, arguments[1] === !0);
        const j = arguments[arguments.length - 1], U = typeof j == "boolean" ? j : I && I[0] === "#";
        for (let G = 0, re = arguments.length; G < re; G += 1) $.push.apply($, h(arguments[G]));
        const H = [];
        for (let G = 0, re = $.length; G < re; G += 1) if ($[G] === "..") {
          if (H.length === 0) return U ? "#" : "";
          H.pop();
        } else H.push($[G]);
        return M(H, U);
      }
      function N(I) {
        const B = h(I);
        if (B.length === 0) return typeof I == "string" && I[0] === "#" ? ["#", B[0]] : ["", void 0];
        if (B.length === 1) return I[0] === "#" ? ["#", B[0]] : ["", B[0]];
        const $ = B.pop();
        return [z(B, I[0] === "#"), $];
      }
      const P = { get: d, set: b, remove: _, join: z, split: h, splitLast: N, isRoot: i, removeUndefinedItems: S };
      return n;
    })()));
  })(xC)), xC.exports;
}
var Vc = Eoe();
const yg = /* @__PURE__ */ zh(Vc);
var Xv = {}, Vi = {}, Zp = {}, B8;
function Doe() {
  if (B8) return Zp;
  B8 = 1, Object.defineProperty(Zp, "__esModule", { value: !0 }), Zp.TokenError = void 0;
  let t = class extends Error {
    constructor(e, r) {
      if (super(e), this.message = e, this.token = r, r && r.errors)
        r.errors.push(this);
      else
        throw this;
    }
    inspect() {
      return "SyntaxError: " + this.message;
    }
  };
  return Zp.TokenError = t, Zp;
}
var L8;
function Ooe() {
  if (L8) return Vi;
  L8 = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.Parser = Vi.findRuleByName = Vi.parseRuleName = Vi.escapeRegExp = Vi.readToken = void 0;
  const t = /^[A-Z0-9_]+$/, e = /(\?|\+|\*)$/, r = /^(@|&|!)/, n = "WS", i = Doe();
  function o(v, y) {
    let b = y.exec(v);
    return b && b.index == 0 ? b[0].length == 0 && y.source.length > 0 ? null : {
      type: null,
      text: b[0],
      rest: v.substr(b[0].length),
      start: 0,
      end: b[0].length - 1,
      fullText: b[0],
      errors: [],
      children: [],
      parent: null
    } : null;
  }
  Vi.readToken = o;
  function s(v) {
    return v.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  Vi.escapeRegExp = s;
  function a(v) {
    v.rest = "", v.children && v.children.forEach((y) => a(y));
  }
  function l(v, y) {
    v.start += y, v.end += y, v.children && v.children.forEach((b) => l(b, v.start));
  }
  function u(v, y) {
    y.errors && y.errors.length && y.errors.forEach((b) => v.push(b)), y.children && y.children.forEach((b) => u(v, b));
  }
  function c(v) {
    let y = e.exec(v), b = r.exec(v), k = y && y[0] || "", C = b && b[0] || "", S = {
      raw: v,
      name: v.replace(e, "").replace(r, ""),
      isOptional: k == "?" || k == "*",
      allowRepetition: k == "+" || k == "*",
      atLeastOne: k == "+",
      lookupPositive: C == "&",
      lookupNegative: C == "!",
      pinned: C == "@",
      lookup: !1,
      isLiteral: !1
    };
    return S.isLiteral = S.name[0] == "'" || S.name[0] == '"', S.lookup = S.lookupNegative || S.lookupPositive, S;
  }
  Vi.parseRuleName = c;
  function h(v, y) {
    let b = c(v);
    return y.cachedRules[b.name] || null;
  }
  Vi.findRuleByName = h;
  function d(v, y) {
    if (v.children) {
      let b = v.children.filter((k) => k.type && y.test(k.type));
      for (let k = 0; k < b.length; k++) {
        let C = v.children.indexOf(b[k]);
        C != -1 && v.children.splice(C, 1);
      }
      v.children.forEach((k) => d(k, y));
    }
  }
  const p = ["EOF"];
  class g {
    constructor(y, b) {
      this.grammarRules = y, this.options = b, this.cachedRules = {}, this.debug = b ? b.debug === !0 : !1;
      let k = [], C = [];
      if (y.forEach((S) => {
        let _ = c(S.name);
        if (_.name in this.cachedRules) {
          k.push("Duplicated rule " + _.name);
          return;
        } else
          this.cachedRules[_.name] = S;
        if (!S.bnf || !S.bnf.length) {
          let D = "Missing rule content, rule: " + S.name;
          k.indexOf(D) == -1 && k.push(D);
        } else
          S.bnf.forEach((D) => {
            if (typeof D[0] == "string" && c(D[0]).name == S.name) {
              let A = "Left recursion is not allowed, rule: " + S.name;
              k.indexOf(A) == -1 && k.push(A);
            }
            D.forEach((A) => {
              if (typeof A == "string") {
                let O = c(A);
                !O.isLiteral && C.indexOf(O.name) == -1 && p.indexOf(O.name) == -1 && C.push(O.name);
              }
            });
          });
        n == S.name && (S.implicitWs = !1), S.implicitWs && C.indexOf(n) == -1 && C.push(n), S.recover && C.indexOf(S.recover) == -1 && C.push(S.recover);
      }), C.forEach((S) => {
        S in this.cachedRules || k.push("Missing rule " + S);
      }), k.length)
        throw new Error(k.join(`
`));
    }
    getAST(y, b) {
      b || (b = this.grammarRules.filter((C) => !C.fragment && C.name.indexOf("%") != 0)[0].name);
      let k = this.parse(y, b);
      if (k) {
        u(k.errors, k), l(k, 0), d(k, /^%/), (!this.options || !this.options.keepUpperRules) && d(k, t);
        let C = k.rest;
        C && new i.TokenError(`Unexpected end of input: 
` + C, k), a(k), k.rest = C;
      }
      return k;
    }
    emitSource() {
      return "CANNOT EMIT SOURCE FROM BASE Parser";
    }
    parse(y, b, k = 0) {
      let C = null, S = c(b), _, D = this.debug && /*!isLiteral &*/
      !t.test(S.name);
      D && console.log(new Array(k).join("â”‚  ") + "Trying to get " + b + " from " + JSON.stringify(y.split(`
`)[0]));
      let A = S.name, O = h(S.name, this);
      if (S.name == "EOF") {
        if (y.length)
          return null;
        if (y.length == 0)
          return {
            type: "EOF",
            text: "",
            rest: "",
            start: 0,
            end: 0,
            fullText: "",
            errors: [],
            children: [],
            parent: null
          };
      }
      try {
        if (!O && S.isLiteral) {
          let M = S.name.trim();
          if (M.startsWith('"') ? M = JSON.parse(M) : M.startsWith("'") && (M = M.replace(/^'(.+)'$/, "$1").replace(/\\'/g, "'")), M === "")
            return {
              type: "%%EMPTY%%",
              text: "",
              rest: y,
              start: 0,
              end: 0,
              fullText: "",
              errors: [],
              children: [],
              parent: null
            };
          _ = new RegExp(s(M)), A = null;
        }
      } catch (M) {
        return M instanceof ReferenceError && console.error(M), null;
      }
      if (_) {
        let M = o(y, _);
        if (M)
          return M.type = A, M;
      } else {
        let M = O.bnf;
        M instanceof Array && M.forEach((z) => {
          if (C)
            return;
          let N = null, P = {
            type: S.name,
            text: "",
            children: [],
            end: 0,
            errors: [],
            fullText: "",
            parent: null,
            start: 0,
            rest: y
          };
          O.fragment && (P.fragment = !0);
          let I = y, B = 0, $ = z.length > 0, j = !1;
          for (let U = 0; U < z.length; U++)
            if (typeof z[U] == "string") {
              let H = c(z[U]);
              $ = $ && H.isOptional;
              let G, re = !1;
              do {
                if (G = null, O.implicitWs && (G = this.parse(I, H.name, k + 1), !G)) {
                  let ne;
                  do
                    if (ne = this.parse(I, n, k + 1), ne)
                      P.text = P.text + ne.text, P.end = P.text.length, ne.parent = P, P.children.push(ne), I = I.substr(ne.text.length), B += ne.text.length;
                    else
                      break;
                  while (ne && ne.text.length);
                }
                if (G = G || this.parse(I, H.name, k + 1), H.lookupNegative) {
                  if (G)
                    return;
                  break;
                }
                if (H.lookupPositive && !G)
                  return;
                if (!G && (H.isOptional || H.atLeastOne && re))
                  break;
                if (G && O.pinned == U + 1 && (N = G, D && console.log(new Array(k + 1).join("â”‚  ") + "â””â”€ " + G.type + " PINNED")), G || (G = this.parseRecovery(O, I, k + 1)), !G)
                  if (N)
                    C = P, G = {
                      type: "SyntaxError",
                      text: I,
                      children: [],
                      end: I.length,
                      errors: [],
                      fullText: "",
                      parent: null,
                      start: 0,
                      rest: ""
                    }, I.length ? new i.TokenError(`Unexpected end of input. Expecting ${H.name} Got: ${I}`, G) : new i.TokenError(`Unexpected end of input. Missing ${H.name}`, G), D && console.log(new Array(k + 1).join("â”‚  ") + "â””â”€ " + G.type + " " + JSON.stringify(G.text));
                  else
                    return;
                if (re = !0, j = !0, G.type == "%%EMPTY%%")
                  break;
                G.start += B, G.end += B, !H.lookupPositive && G.type && (G.fragment ? G.children && G.children.forEach((ne) => {
                  ne.start += B, ne.end += B, ne.parent = P, P.children.push(ne);
                }) : (G.parent = P, P.children.push(G))), H.lookup && (G.lookup = !0), D && console.log(new Array(k + 1).join("â”‚  ") + "â””â”€ " + G.type + " " + JSON.stringify(G.text)), !H.lookup && !G.lookup && (P.text = P.text + G.text, P.end = P.text.length, I = I.substr(G.text.length), B += G.text.length), P.rest = I;
              } while (G && H.allowRepetition && I.length && !G.lookup);
            } else {
              let H = o(I, z[U]);
              if (!H)
                return;
              D && console.log(new Array(k + 1).join("â”‚  ") + "â””> " + JSON.stringify(H.text) + z[U].source), j = !0, H.start += B, H.end += B, P.text = P.text + H.text, P.end = P.text.length, I = I.substr(H.text.length), B += H.text.length, P.rest = I;
            }
          j && (C = P, D && console.log(new Array(k).join("â”‚  ") + "â”œ<â”€â”´< PUSHING " + C.type + " " + JSON.stringify(C.text)));
        }), C && O.simplifyWhenOneChildren && C.children.length == 1 && (C = C.children[0]);
      }
      return C || D && console.log(b + " NOT RESOLVED FROM " + y), C;
    }
    parseRecovery(y, b, k) {
      if (y.recover && b.length) {
        let C = this.debug;
        C && console.log(new Array(k + 1).join("â”‚  ") + "Trying to recover until token " + y.recover + " from " + JSON.stringify(b.split(`
`)[0] + b.split(`
`)[1]));
        let S = {
          type: "SyntaxError",
          text: "",
          children: [],
          end: 0,
          errors: [],
          fullText: "",
          parent: null,
          start: 0,
          rest: ""
        }, _;
        do
          if (_ = this.parse(b, y.recover, k + 1), _) {
            new i.TokenError('Unexpected input: "' + S.text + `" Expecting: ${y.name}`, S);
            break;
          } else
            S.text = S.text + b[0], S.end = S.text.length, b = b.substr(1);
        while (!_ && b.length > 0);
        if (S.text.length > 0 && _)
          return C && console.log(new Array(k + 1).join("â”‚  ") + "Recovered text: " + JSON.stringify(S.text)), S;
      }
      return null;
    }
  }
  return Vi.Parser = g, Vi.default = g, Vi;
}
var z8;
function Foe() {
  if (z8) return Xv;
  z8 = 1, Object.defineProperty(Xv, "__esModule", { value: !0 });
  const t = Ooe();
  var e;
  return (function(r) {
    r.RULES = [
      {
        name: "Grammar",
        bnf: [["RULE_S*", "%Atomic*", "EOF"]]
      },
      {
        name: "%Atomic",
        bnf: [["Production", "RULE_S*"]],
        fragment: !0
      },
      {
        name: "Production",
        bnf: [["NCName", "RULE_S*", '"::="', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", "RULE_EOL+", "RULE_S*"]]
      },
      {
        name: "NCName",
        bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]
      },
      {
        name: "Choice",
        bnf: [["SequenceOrDifference", "%_Choice_1*"]],
        fragment: !0
      },
      {
        name: "%_Choice_1",
        bnf: [["RULE_WHITESPACE*", '"|"', "RULE_WHITESPACE*", "SequenceOrDifference"]],
        fragment: !0
      },
      {
        name: "SequenceOrDifference",
        bnf: [["Item", "RULE_WHITESPACE*", "%_Item_1?"]]
      },
      {
        name: "%_Item_1",
        bnf: [["Minus", "Item"], ["Item*"]],
        fragment: !0
      },
      {
        name: "Minus",
        bnf: [['"-"']]
      },
      {
        name: "Item",
        bnf: [["RULE_WHITESPACE*", "%Primary", "PrimaryDecoration?"]],
        fragment: !0
      },
      {
        name: "PrimaryDecoration",
        bnf: [['"?"'], ['"*"'], ['"+"']]
      },
      {
        name: "DecorationName",
        bnf: [['"ebnf://"', /[^\x5D#]+/]]
      },
      {
        name: "%Primary",
        bnf: [["NCName"], ["StringLiteral"], ["CharCode"], ["CharClass"], ["SubItem"]],
        fragment: !0
      },
      {
        name: "SubItem",
        bnf: [['"("', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", '")"']]
      },
      {
        name: "StringLiteral",
        bnf: [[`'"'`, /[^"]*/, `'"'`], [`"'"`, /[^']*/, `"'"`]],
        pinned: 1
      },
      {
        name: "CharCode",
        bnf: [['"#x"', /[0-9a-zA-Z]+/]]
      },
      {
        name: "CharClass",
        bnf: [["'['", "'^'?", "%RULE_CharClass_1+", '"]"']]
      },
      {
        name: "%RULE_CharClass_1",
        bnf: [["CharCodeRange"], ["CharRange"], ["CharCode"], ["RULE_Char"]],
        fragment: !0
      },
      {
        name: "RULE_Char",
        bnf: [[/\x09/], [/\x0A/], [/\x0D/], [/[\x20-\x5c]/], [/[\x5e-\uD7FF]/], [/[\uE000-\uFFFD]/]]
      },
      {
        name: "CharRange",
        bnf: [["RULE_Char", '"-"', "RULE_Char"]]
      },
      {
        name: "CharCodeRange",
        bnf: [["CharCode", '"-"', "CharCode"]]
      },
      {
        name: "RULE_WHITESPACE",
        bnf: [["%RULE_WHITESPACE_CHAR*"], ["Comment", "RULE_WHITESPACE*"]]
      },
      {
        name: "RULE_S",
        bnf: [["RULE_WHITESPACE", "RULE_S*"], ["RULE_EOL", "RULE_S*"]]
      },
      {
        name: "%RULE_WHITESPACE_CHAR",
        bnf: [[/\x09/], [/\x20/]],
        fragment: !0
      },
      {
        name: "Comment",
        bnf: [['"/*"', "%RULE_Comment_Body*", '"*/"']]
      },
      {
        name: "%RULE_Comment_Body",
        bnf: [['!"*/"', /[^*]/]],
        fragment: !0
      },
      {
        name: "RULE_EOL",
        bnf: [[/\x0D/, /\x0A/], [/\x0A/], [/\x0D/]]
      },
      {
        name: "Link",
        bnf: [["'['", "Url", "']'"]]
      },
      {
        name: "Url",
        bnf: [[/[^\x5D:/?#]/, '"://"', /[^\x5D#]+/, "%Url1?"]]
      },
      {
        name: "%Url1",
        bnf: [['"#"', "NCName"]],
        fragment: !0
      }
    ], r.defaultParser = new t.Parser(r.RULES, { debug: !1 });
    const n = /^(!|&)/, i = /(\?|\+|\*)$/, o = /^%/;
    function s(C, S) {
      if (typeof C == "string") {
        if (n.test(C))
          return "";
        if (o.test(C)) {
          let _ = i.exec(C), D = _ ? _[0] + " " : "";
          return a(C, S) ? u(C, S) + D : "(" + u(C, S) + ")" + D;
        }
        return C;
      } else
        return C.source.replace(/\\(?:x|u)([a-zA-Z0-9]+)/g, "#x$1").replace(/\[\\(?:x|u)([a-zA-Z0-9]+)-\\(?:x|u)([a-zA-Z0-9]+)\]/g, "[#x$1-#x$2]");
    }
    function a(C, S) {
      let _ = t.findRuleByName(C, S);
      return _ && _.bnf.length == 1 && _.bnf[0].length == 1 && (_.bnf[0][0] instanceof RegExp || _.bnf[0][0][0] == '"' || _.bnf[0][0][0] == "'");
    }
    function l(C, S) {
      return C.map((_) => s(_, S)).join(" ");
    }
    function u(C, S) {
      let _ = t.findRuleByName(C, S);
      return _ ? _.bnf.map((D) => l(D, S)).join(" | ") : "RULE_NOT_FOUND {" + C + "}";
    }
    function c(C) {
      let S = [];
      return C.grammarRules.forEach((_) => {
        if (!/^%/.test(_.name)) {
          let D = _.recover ? " /* { recoverUntil=" + _.recover + " } */" : "";
          S.push(_.name + " ::= " + u(_.name, C) + D);
        }
      }), S.join(`
`);
    }
    r.emit = c;
    let h = 0;
    function d(C, S) {
      throw console.log("reberia restar " + S + " a " + C), new Error("Difference not supported yet");
    }
    function p(C) {
      return new RegExp(C.replace(/#x([a-zA-Z0-9]{4})/g, "\\u$1").replace(/#x([a-zA-Z0-9]{3})/g, "\\u0$1").replace(/#x([a-zA-Z0-9]{2})/g, "\\x$1").replace(/#x([a-zA-Z0-9]{1})/g, "\\x0$1"));
    }
    function g(C, S, _) {
      let D = null, A = [];
      return S.children.forEach((O, M) => {
        O.type == "Minus" && d(D, O);
        let z = S.children[M + 1];
        z = z && z.type == "PrimaryDecoration" && z.text || "";
        let N = "";
        switch (O.type) {
          case "SubItem":
            let P = "%" + (_ + h++);
            v(C, O, P), A.push(N + P + z);
            break;
          case "NCName":
          case "StringLiteral":
            A.push(N + O.text + z);
            break;
          case "CharCode":
          case "CharClass":
            if (z || N) {
              let I = {
                name: "%" + (_ + h++),
                bnf: [[p(O.text)]]
              };
              C.push(I), A.push(N + I.name + z);
            } else
              A.push(p(O.text));
            break;
          case "PrimaryDecoration":
            break;
          default:
            throw new Error(" HOW SHOULD I PARSE THIS? " + O.type + " -> " + JSON.stringify(O.text));
        }
        D = O;
      }), A;
    }
    function v(C, S, _) {
      let D = S.children.filter((M) => M.type == "SequenceOrDifference").map((M) => g(C, M, _)), A = {
        name: _,
        bnf: D
      }, O = null;
      D.forEach((M) => {
        O = O || M.recover, delete M.recover;
      }), _.indexOf("%") == 0 && (A.fragment = !0), O && (A.recover = O), C.push(A);
    }
    function y(C, S = r.defaultParser) {
      let _ = S.getAST(C);
      if (!_)
        throw new Error("Could not parse " + C);
      if (_.errors && _.errors.length)
        throw _.errors[0];
      let D = [];
      return _.children.filter((A) => A.type == "Production").map((A) => {
        let O = A.children.filter((M) => M.type == "NCName")[0].text;
        v(D, A, O);
      }), D;
    }
    r.getRules = y;
    function b(C, S = r.defaultParser) {
      return y(C.join(""), S);
    }
    r.Transform = b;
    class k extends t.Parser {
      constructor(S, _) {
        const D = _ && _.debugRulesParser === !0 ? new t.Parser(r.RULES, { debug: !0 }) : r.defaultParser;
        super(y(S, D), _);
      }
      emitSource() {
        return c(this);
      }
    }
    r.Parser = k;
  })(e || (e = {})), Xv.default = e, Xv;
}
var Toe = Foe();
const Moe = /* @__PURE__ */ zh(Toe), Poe = "[^?/{}*,()#]+", Roe = `
root ::= ("#" recursion | recursion | (query | pattern) recursion* | "#" SEP? | SEP)
recursion ::= (SEP query | pattern)*

query ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?
property ::= ${Poe}
regex ::= "{" [^}]+ "}"
SEP ::= "/"
all ::= "**"
any ::= "*"

typecheck ::= "?:" ("value" | "boolean" | "string" | "number" | "object" | "array")
lookahead ::= "?" expression ((andExpr | orExpr) expression)*
andExpr ::= S? "&&" S?
orExpr ::= S? "||" S?

expression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*
exprProperty ::= [a-zA-Z0-9-_ $]+
escaped ::= [^"]+
is ::= ":"
isnot ::= ":!"
ESC ::= '"'

pattern ::= S? "(" (SEP query | pattern (orPattern? pattern)*)* ")" quantifier? S? lookahead?
quantifier ::= "+" | "*" | [0-9]+
orPattern ::= S? "," S?

S ::= [ ]*
`, Noe = new Moe.Parser(Roe), $oe = (t) => Noe.getAST(t), Xi = 0, Dd = 3, R1 = (t, e) => `${t}/${e}`, fN = Object.prototype.toString, Ioe = /Object|Array/, wC = (t) => Ioe.test(fN.call(t)), Boe = (t) => fN.call(t).match(/\s([^\]]+)\]/).pop().toLowerCase();
function dN(t) {
  return new RegExp(t.text.replace(/(^{|}$)/g, ""));
}
function Loe(t, e) {
  Array.isArray(t) ? t.forEach(e) : Object.prototype.toString.call(t) === "[object Object]" && Object.keys(t).forEach(function(r) {
    e(t[r], r, t);
  });
}
function j8(t) {
  return Array.isArray(t) ? t.map(function(e, r) {
    return `${r}`;
  }) : Object.prototype.toString.call(t) === "[object Object]" ? Object.keys(t) : [];
}
const Gu = {
  mem: [],
  get(t, e) {
    const r = t[Xi][e];
    if (!Gu.mem.includes(r))
      return wC(r) && Gu.mem.push(r), [r, e, t[Xi], R1(t[Dd], e)];
  },
  reset() {
    Gu.mem.length = 0;
  }
}, kC = {
  any(t, e) {
    const r = e[Xi];
    return j8(r).map((n) => [
      r[n],
      n,
      r,
      R1(e[Dd], n)
    ]);
  },
  all(t, e) {
    const r = [e];
    return Loe(e[Xi], (n, i) => {
      const o = Gu.get(e, i);
      o && r.push(...kC.all(t, o));
    }), r;
  },
  regex(t, e) {
    const r = dN(t), n = e[Xi];
    return j8(n).filter((i) => r.test(i)).map((i) => [
      n[i],
      i,
      n,
      R1(e[Dd], i)
    ]);
  }
}, N1 = {
  // alias to property (but escaped)
  escaped: (t, e) => N1.property(t, e),
  property: (t, e) => {
    const r = t.text;
    if (e[Xi] && e[Xi][r] !== void 0)
      return [
        e[Xi][r],
        r,
        e[Xi],
        R1(e[Dd], r)
      ];
  },
  typecheck: (t, e) => {
    const r = t.text.replace(/^\?:/, "");
    if (r === "value")
      return wC(e[Xi]) ? void 0 : e;
    if (Boe(e[Xi]) === r)
      return e;
  },
  lookahead: (t, e) => {
    let r = !0, n = !1;
    return t.children.forEach((i) => {
      if (i.type === "expression") {
        const o = N1.expression(i, e) !== void 0;
        r = n === !0 ? r || o : r && o;
      } else
        n = i.type === "orExpr";
    }), r ? e : void 0;
  },
  expression: (t, e) => {
    const r = t.children[0].text, n = t.children[1], i = t.children[2], o = e[Xi];
    if (wC(o) !== !1)
      return zoe(o[r], n, i) ? e : void 0;
  }
};
function zoe(t, e, r) {
  if (e === void 0)
    return t !== void 0;
  let n;
  const i = `${t}`;
  return r.type === "regex" ? n = dN(r).test(i) : n = i === r.text, e.type === "isnot" && (n = n === !1 && t !== void 0), n;
}
function joe(t, e, r, n) {
  const i = [];
  for (let o = 0, s = e.length; o < s; o += 1)
    i.push(...t(r, e[o], r, n));
  return i;
}
function qoe(t, e, r, n) {
  const i = [];
  for (let o = 0, s = e.length; o < s; o += 1) {
    const a = t(r, e[o], n);
    a && i.push(a);
  }
  return i;
}
function Uoe(t, e, r) {
  let n = t;
  return e.children.forEach((i) => {
    if (kC[i.type])
      n = joe(kC[i.type], n, i, r);
    else if (N1[i.type])
      n = qoe(N1[i.type], n, i, r);
    else
      throw new Error(`Unknown filter ${i.type}`);
  }), n;
}
function Hoe(t, e, r) {
  const n = [];
  let i = t;
  return e.children.forEach((o) => {
    if (o.type === "orPattern") {
      n.push(...i), i = t;
      return;
    }
    i = W4(i, o, r);
  }), n.push(...i), n;
}
function Voe(t) {
  if (t == null)
    return 1;
  if (t === "*" || t === "+")
    return 1 / 0;
  const e = parseInt(t);
  return isNaN(e) ? 1 : e;
}
function Woe(t, e, r) {
  const n = [], i = e.children.find((l) => l.type === "quantifier"), o = Voe(i && i.text);
  let s = t;
  i && i.text === "*" && n.push(...s);
  let a = 0;
  for (; s.length > 0 && a < o; )
    s = Hoe(s, e, r), n.push(...s), a += 1;
  return n;
}
function Goe(t, e, r) {
  let n = t;
  return e.children.forEach((i) => n = W4(n, i, r)), n;
}
function W4(t, e, r) {
  let n;
  return e.type === "query" ? n = Uoe(t, e, r) : e.type === "pattern" ? n = Woe(t, e, r) : n = Goe(t, e, r), Gu.reset(), Gu.mem.push(t), n;
}
function Koe(t, e) {
  return Gu.reset(), Gu.mem.push(t), W4([[t, null, null, "#"]], e);
}
const q8 = {
  value: (t) => t.map((e) => e[Xi]),
  pointer: (t) => t.map((e) => e[Dd]),
  all: (t) => t,
  map: (t) => {
    const e = {};
    return t.forEach((r) => e[r[Dd]] = r[Xi]), e;
  }
};
var _h;
(function(t) {
  t.POINTER = "pointer", t.VALUE = "value", t.ALL = "all", t.MAP = "map";
})(_h || (_h = {}));
s0.POINTER = _h.POINTER;
s0.VALUE = _h.VALUE;
s0.ALL = _h.ALL;
s0.MAP = _h.MAP;
function s0(t, e, r = _h.VALUE) {
  if (e == null)
    return [];
  e = e.replace(/(\/$)/g, ""), e === "" && (e = "#");
  const n = $oe(e);
  if (n == null)
    throw new Error(`empty ast for '${e}'`);
  if (n.rest !== "")
    throw new Error(`Failed parsing queryString from: '${n.rest}'`);
  const i = Koe(t, n);
  return typeof r == "function" ? i.map((o) => r(...o)) : q8[r] ? q8[r](i) : i;
}
var $1;
(function(t) {
  t.REPLACE_ITEMS = "replace", t.INSERT_ITEMS = "insert";
})($1 || ($1 = {}));
$1.REPLACE_ITEMS;
$1.INSERT_ITEMS;
const $l = {
  $ref: {
    type: !1
  },
  allOf: {
    type: !1,
    definitions: ["allOf/*"]
  },
  anyOf: {
    type: !1,
    definitions: ["anyOf/*"]
  },
  array: {
    type: !0,
    // ignore additionalItems:TypeDef, when items:TypeDef
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "items",
      "items/*",
      "additionalItems"
    ],
    validationKeywords: ["minItems", "maxItems", "uniqueItems"],
    keywords: ["items", "additionalItems", "minItems", "maxItems", "uniqueItems"]
  },
  boolean: {
    type: !0
  },
  enum: {
    type: !1
  },
  integer: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  not: {
    type: !1,
    definitions: ["not"]
  },
  number: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  null: {
    type: !0
  },
  object: {
    type: !0,
    // patternProperties also validate properties
    // dependencies:(string, TypeDef) extend current TypeDef
    // additional Properties validate only remaining properties (after properties & pattern)
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "properties/*",
      "additionalProperties",
      "patternProperties/*",
      "dependencies/*"
    ],
    validationKeywords: ["minProperties", "maxProperties", "required"],
    keywords: [
      "properties",
      "additionalProperties",
      "patternProperties",
      "dependencies",
      "minProperties",
      "maxProperties",
      "required"
    ]
  },
  oneOf: {
    type: !1,
    definitions: ["oneOf/*"]
  },
  string: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minLength", "maxLength", "pattern"]
  }
}, Xoe = Object.keys($l).filter((t) => $l[t].type === !1), U8 = Object.prototype.hasOwnProperty;
function H8(t) {
  if (Wu(t) === !1)
    return;
  if (t.enum)
    return "enum";
  const e = t.type;
  if (Array.isArray(e) || $l[e])
    return e;
  const r = Xoe.filter((n) => t[n]);
  if (r.length === 1)
    return r[0];
  if (r.length === 0) {
    for (let n = 0, i = $l.object.keywords.length; n < i; n += 1) {
      const o = $l.object.keywords[n];
      if (U8.call(t, o))
        return "object";
    }
    for (let n = 0, i = $l.array.keywords.length; n < i; n += 1) {
      const o = $l.array.keywords[n];
      if (U8.call(t, o))
        return "array";
    }
    return;
  }
  throw new Error(`Mutiple typeIds [${r.join(", ")}] matched in ${JSON.stringify(t)}`);
}
function Qoe(t) {
  const e = [], r = H8(t);
  if (r == null)
    return e;
  let n;
  if (Array.isArray(r)) {
    n = {};
    for (let i = 0, o = r.length; i < o; i += 1)
      Object.assign(n, $l[r[i]]);
  } else
    n = $l[r];
  return n.definitions == null || n.definitions.forEach((i) => {
    s0(t, i, (o, s, a, l) => {
      Wu(o) && H8(o) && e.push({ pointer: yg.join(yg.split(l), !1), def: o });
    });
  }), e;
}
function Joe(t, e) {
  this.callback(t, e) !== !0 && Qoe(t).forEach((r) => this.nextTypeDefs(r.def, yg.join(e, r.pointer, !1)));
}
function Qv(t, e, r, n = "definitions") {
  const i = e[n];
  Object.keys(i).forEach((o) => {
    if (i[o] === !1 || Wu(i[o])) {
      t.nextTypeDefs(i[o], yg.join(r, n, o, !1));
      return;
    }
  });
}
function Xb(t, e, r = "#") {
  const n = { callback: e, nextTypeDefs: Joe };
  n.nextTypeDefs(t, r), t.definitions != null && (n.callback = (i, o) => {
    e(i, o), i.definitions != null && Qv(n, i, o);
  }, Qv(n, t, r)), t.$defs != null && (n.callback = (i, o) => {
    e(i, o), i.definitions != null && Qv(n, i, o);
  }, Qv(n, t, r, "$defs"));
}
const Yoe = /(#|\/)+$/, Jv = /#$/, Zoe = /^[^:]+:\/\/[^/]+\//, ese = /\/[^/]*$/, tse = /#.*$/;
function I1(t, e) {
  return t == null && e == null ? "#" : e == null ? t.replace(Jv, "") : t == null ? e.replace(Jv, "") : e[0] === "#" ? `${t.replace(tse, "")}${e.replace(Yoe, "")}` : Zoe.test(e) ? e.replace(Jv, "") : `${t.replace(ese, "")}/${e.replace(Jv, "")}`;
}
const em = /(#|\/)+$/g, rse = ["", null, "#"];
function nse(t) {
  if (rse.includes(t))
    return [];
  if (t = t.replace(em, ""), t.indexOf("#") === -1)
    return [t.replace(em, "")];
  if (t.indexOf("#") === 0)
    return [t.replace(em, "")];
  const e = t.split("#");
  return e[0] = e[0].replace(em, ""), e[1] = `#${e[1].replace(em, "")}`, e;
}
const ise = /(#|\/)+$/g, ose = (t) => rr(t) === "object";
function Fl(t, e, r) {
  if (ose(r) && (r = r.__ref || r.$ref), r == null)
    return e;
  let n;
  const i = r.replace(ise, "");
  if (t.remotes[i])
    return n = t.remotes[i], n && n.$ref ? Fl(t, e, n.$ref) : n;
  if (t.ids[r])
    return n = Vc.get(e, t.ids[r]), n && n.$ref ? Fl(t, e, n.$ref) : n;
  const o = nse(r);
  if (o.length === 0)
    return e;
  if (o.length === 1) {
    if (r = o[0], t.remotes[r])
      return n = t.remotes[r], Fl(t, e, n.$ref);
    if (t.ids[r])
      return n = Vc.get(e, t.ids[r]), n && n.$ref ? Fl(t, e, n.$ref) : n;
  }
  if (o.length === 2) {
    const s = o[0];
    if (r = o[1], t.remotes[s])
      return t.remotes[s].getRef ? t.remotes[s].getRef(r) : Fl(t, t.remotes[s], r);
    if (t.ids[s])
      return Fl(t, Vc.get(e, t.ids[s]), r);
  }
  return n = Vc.get(e, t.ids[r] || r), n && n.$ref ? Fl(t, e, n.$ref) : n;
}
const V8 = "__compiled", W8 = "__ref", sse = "getRef", ase = "getRoot", lse = /(#|\/)+$/g;
function use(t, e, r = e, n = !1) {
  if (!e || e[V8] !== void 0)
    return e;
  const i = { ids: {}, remotes: t.remotes }, o = JSON.stringify(e), s = JSON.parse(o);
  if (Object.defineProperty(s, V8, { enumerable: !1, value: !0 }), Object.defineProperty(s, sse, {
    enumerable: !1,
    value: Fl.bind(null, i, s)
  }), n === !1 && o.includes("$ref") === !1)
    return s;
  e !== r && Object.defineProperty(s, "definitions", {
    enumerable: !1,
    value: Object.assign({}, r.definitions, r.$defs, e.definitions, e.$defs)
  });
  const a = {}, l = () => s;
  return Xb(s, (u, c) => {
    var h;
    if (u.id) {
      if (u.id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(c)) {
        const y = c.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, ""), b = Vc.get(s, y);
        u.id = (h = b.id) !== null && h !== void 0 ? h : u.id;
      }
      i.ids[u.id.replace(lse, "")] = c;
    }
    c = `#${c}`.replace(/##+/, "#");
    const d = c.replace(/\/[^/]+$/, ""), p = c.replace(/\/[^/]+\/[^/]+$/, ""), g = a[d] || a[p], v = I1(g, u.id);
    a[c] = v, i.ids[v] == null && (i.ids[v] = c), u.$ref && !u[W8] && (Object.defineProperty(u, W8, {
      enumerable: !1,
      value: I1(v, u.$ref)
    }), Object.defineProperty(u, ase, { enumerable: !1, value: l }));
  }), s;
}
function pN(t, e, r, n = t.rootSchema, i = "#") {
  n = t.resolveRef(n), r(n, e, i);
  const o = rr(e);
  o === "object" ? Object.keys(e).forEach((s) => {
    const a = t.step(s, n, e, i), l = e[s];
    t.each(l, r, a, `${i}/${s}`);
  }) : o === "array" && e.forEach((s, a) => {
    const l = t.step(a, n, e, i);
    t.each(s, r, l, `${i}/${a}`);
  });
}
const mN = {
  additionalItemsError: Ke("AdditionalItemsError"),
  additionalPropertiesError: Ke("AdditionalPropertiesError"),
  anyOfError: Ke("AnyOfError"),
  allOfError: Ke("AllOfError"),
  constError: Ke("ConstError"),
  containsError: Ke("ContainsError"),
  containsArrayError: Ke("ContainsArrayError"),
  containsAnyError: Ke("ContainsAnyError"),
  enumError: Ke("EnumError"),
  forbiddenPropertyError: Ke("ForbiddenPropertyError"),
  formatURLError: Ke("FormatURLError"),
  formatURIError: Ke("FormatURIError"),
  formatURIReferenceError: Ke("FormatURIReferenceError"),
  formatURITemplateError: Ke("FormatURITemplateError"),
  formatDateError: Ke("FormatDateError"),
  formatDateTimeError: Ke("FormatDateTimeError"),
  formatEmailError: Ke("FormatEmailError"),
  formatHostnameError: Ke("FormatHostnameError"),
  formatIPV4Error: Ke("FormatIPV4Error"),
  formatIPV4LeadingZeroError: Ke("FormatIPV4LeadingZeroError"),
  formatIPV6Error: Ke("FormatIPV6Error"),
  formatIPV6LeadingZeroError: Ke("FormatIPV6LeadingZeroError"),
  formatJsonPointerError: Ke("FormatJsonPointerError"),
  formatRegExError: Ke("FormatRegExError"),
  formatTimeError: Ke("FormatTimeError"),
  invalidSchemaError: Ke("InvalidSchemaError"),
  invalidDataError: Ke("InvalidDataError"),
  invalidTypeError: Ke("InvalidTypeError"),
  invalidPropertyNameError: Ke("InvalidPropertyNameError"),
  maximumError: Ke("MaximumError"),
  maxItemsError: Ke("MaxItemsError"),
  maxLengthError: Ke("MaxLengthError"),
  maxPropertiesError: Ke("MaxPropertiesError"),
  minimumError: Ke("MinimumError"),
  minItemsError: Ke("MinItemsError"),
  minItemsOneError: Ke("MinItemsOneError"),
  minLengthError: Ke("MinLengthError"),
  minLengthOneError: Ke("MinLengthOneError"),
  minPropertiesError: Ke("MinPropertiesError"),
  missingDependencyError: Ke("MissingDependencyError"),
  missingOneOfPropertyError: Ke("MissingOneOfPropertyError"),
  multipleOfError: Ke("MultipleOfError"),
  multipleOneOfError: Ke("MultipleOneOfError"),
  noAdditionalPropertiesError: Ke("NoAdditionalPropertiesError"),
  notError: Ke("NotError"),
  oneOfError: Ke("OneOfError"),
  oneOfPropertyError: Ke("OneOfPropertyError"),
  patternError: Ke("PatternError"),
  patternPropertiesError: Ke("PatternPropertiesError"),
  requiredPropertyError: Ke("RequiredPropertyError"),
  schemaWarning: Ke("SchemaWarning"),
  typeError: Ke("TypeError"),
  undefinedValueError: Ke("UndefinedValueError"),
  uniqueItemsError: Ke("UniqueItemsError"),
  unknownPropertyError: Ke("UnknownPropertyError"),
  valueNotEmptyError: Ke("ValueNotEmptyError")
};
var G8 = { exports: {} }, K8;
function cse() {
  return K8 || (K8 = 1, (function(t) {
    (function(e) {
      e.exports.is_uri = n, e.exports.is_http_uri = i, e.exports.is_https_uri = o, e.exports.is_web_uri = s, e.exports.isUri = n, e.exports.isHttpUri = i, e.exports.isHttpsUri = o, e.exports.isWebUri = s;
      var r = function(a) {
        var l = a.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return l;
      };
      function n(a) {
        if (a && !/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(a) && !/%[^0-9a-f]/i.test(a) && !/%[0-9a-f](:?[^0-9a-f]|$)/i.test(a)) {
          var l = [], u = "", c = "", h = "", d = "", p = "", g = "";
          if (l = r(a), u = l[1], c = l[2], h = l[3], d = l[4], p = l[5], !!(u && u.length && h.length >= 0)) {
            if (c && c.length) {
              if (!(h.length === 0 || /^\//.test(h))) return;
            } else if (/^\/\//.test(h)) return;
            if (/^[a-z][a-z0-9\+\-\.]*$/.test(u.toLowerCase()))
              return g += u + ":", c && c.length && (g += "//" + c), g += h, d && d.length && (g += "?" + d), p && p.length && (g += "#" + p), g;
          }
        }
      }
      function i(a, l) {
        if (n(a)) {
          var u = [], c = "", h = "", d = "", p = "", g = "", v = "", y = "";
          if (u = r(a), c = u[1], h = u[2], d = u[3], g = u[4], v = u[5], !!c) {
            if (l) {
              if (c.toLowerCase() != "https") return;
            } else if (c.toLowerCase() != "http") return;
            if (h)
              return /:(\d+)$/.test(h) && (p = h.match(/:(\d+)$/)[0], h = h.replace(/:\d+$/, "")), y += c + ":", y += "//" + h, p && (y += p), y += d, g && g.length && (y += "?" + g), v && v.length && (y += "#" + v), y;
          }
        }
      }
      function o(a) {
        return i(a, !0);
      }
      function s(a) {
        return i(a) || o(a);
      }
    })(t);
  })(G8)), G8.exports;
}
var hse = cse();
const X8 = /* @__PURE__ */ zh(hse);
var Si = {}, CC = { exports: {} }, fse = CC.exports, Q8;
function dse() {
  return Q8 || (Q8 = 1, (function(t) {
    (function(e, r) {
      t.exports ? t.exports = r() : e.nearley = r();
    })(fse, function() {
      function e(u, c, h) {
        return this.id = ++e.highestId, this.name = u, this.symbols = c, this.postprocess = h, this;
      }
      e.highestId = 0, e.prototype.toString = function(u) {
        var c = typeof u > "u" ? this.symbols.map(l).join(" ") : this.symbols.slice(0, u).map(l).join(" ") + " â— " + this.symbols.slice(u).map(l).join(" ");
        return this.name + " â†’ " + c;
      };
      function r(u, c, h, d) {
        this.rule = u, this.dot = c, this.reference = h, this.data = [], this.wantedBy = d, this.isComplete = this.dot === u.symbols.length;
      }
      r.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      }, r.prototype.nextState = function(u) {
        var c = new r(this.rule, this.dot + 1, this.reference, this.wantedBy);
        return c.left = this, c.right = u, c.isComplete && (c.data = c.build(), c.right = void 0), c;
      }, r.prototype.build = function() {
        var u = [], c = this;
        do
          u.push(c.right.data), c = c.left;
        while (c.left);
        return u.reverse(), u;
      }, r.prototype.finish = function() {
        this.rule.postprocess && (this.data = this.rule.postprocess(this.data, this.reference, s.fail));
      };
      function n(u, c) {
        this.grammar = u, this.index = c, this.states = [], this.wants = {}, this.scannable = [], this.completed = {};
      }
      n.prototype.process = function(u) {
        for (var c = this.states, h = this.wants, d = this.completed, p = 0; p < c.length; p++) {
          var g = c[p];
          if (g.isComplete) {
            if (g.finish(), g.data !== s.fail) {
              for (var v = g.wantedBy, y = v.length; y--; ) {
                var b = v[y];
                this.complete(b, g);
              }
              if (g.reference === this.index) {
                var k = g.rule.name;
                (this.completed[k] = this.completed[k] || []).push(g);
              }
            }
          } else {
            var k = g.rule.symbols[g.dot];
            if (typeof k != "string") {
              this.scannable.push(g);
              continue;
            }
            if (h[k]) {
              if (h[k].push(g), d.hasOwnProperty(k))
                for (var C = d[k], y = 0; y < C.length; y++) {
                  var S = C[y];
                  this.complete(g, S);
                }
            } else
              h[k] = [g], this.predict(k);
          }
        }
      }, n.prototype.predict = function(u) {
        for (var c = this.grammar.byName[u] || [], h = 0; h < c.length; h++) {
          var d = c[h], p = this.wants[u], g = new r(d, 0, this.index, p);
          this.states.push(g);
        }
      }, n.prototype.complete = function(u, c) {
        var h = u.nextState(c);
        this.states.push(h);
      };
      function i(u, c) {
        this.rules = u, this.start = c || this.rules[0].name;
        var h = this.byName = {};
        this.rules.forEach(function(d) {
          h.hasOwnProperty(d.name) || (h[d.name] = []), h[d.name].push(d);
        });
      }
      i.fromCompiled = function(d, c) {
        var h = d.Lexer;
        d.ParserStart && (c = d.ParserStart, d = d.ParserRules);
        var d = d.map(function(g) {
          return new e(g.name, g.symbols, g.postprocess);
        }), p = new i(d, c);
        return p.lexer = h, p;
      };
      function o() {
        this.reset("");
      }
      o.prototype.reset = function(u, c) {
        this.buffer = u, this.index = 0, this.line = c ? c.line : 1, this.lastLineBreak = c ? -c.col : 0;
      }, o.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var u = this.buffer[this.index++];
          return u === `
` && (this.line += 1, this.lastLineBreak = this.index), { value: u };
        }
      }, o.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      }, o.prototype.formatError = function(u, c) {
        var h = this.buffer;
        if (typeof h == "string") {
          var d = h.split(`
`).slice(
            Math.max(0, this.line - 5),
            this.line
          ), p = h.indexOf(`
`, this.index);
          p === -1 && (p = h.length);
          var g = this.index - this.lastLineBreak, v = String(this.line).length;
          return c += " at line " + this.line + " col " + g + `:

`, c += d.map(function(b, k) {
            return y(this.line - d.length + k + 1, v) + " " + b;
          }, this).join(`
`), c += `
` + y("", v + g) + `^
`, c;
        } else
          return c + " at index " + (this.index - 1);
        function y(b, k) {
          var C = String(b);
          return Array(k - C.length + 1).join(" ") + C;
        }
      };
      function s(u, c, d) {
        if (u instanceof i)
          var p = u, d = c;
        else
          var p = i.fromCompiled(u, c);
        this.grammar = p, this.options = {
          keepHistory: !1,
          lexer: p.lexer || new o()
        };
        for (var g in d || {})
          this.options[g] = d[g];
        this.lexer = this.options.lexer, this.lexerState = void 0;
        var v = new n(p, 0);
        this.table = [v], v.wants[p.start] = [], v.predict(p.start), v.process(), this.current = 0;
      }
      s.fail = {}, s.prototype.feed = function(u) {
        var c = this.lexer;
        c.reset(u, this.lexerState);
        for (var h; ; ) {
          try {
            if (h = c.next(), !h)
              break;
          } catch (A) {
            var v = new n(this.grammar, this.current + 1);
            this.table.push(v);
            var d = new Error(this.reportLexerError(A));
            throw d.offset = this.current, d.token = A.token, d;
          }
          var p = this.table[this.current];
          this.options.keepHistory || delete this.table[this.current - 1];
          var g = this.current + 1, v = new n(this.grammar, g);
          this.table.push(v);
          for (var y = h.text !== void 0 ? h.text : h.value, b = c.constructor === o ? h.value : h, k = p.scannable, C = k.length; C--; ) {
            var S = k[C], _ = S.rule.symbols[S.dot];
            if (_.test ? _.test(b) : _.type ? _.type === h.type : _.literal === y) {
              var D = S.nextState({ data: b, token: h, isToken: !0, reference: g - 1 });
              v.states.push(D);
            }
          }
          if (v.process(), v.states.length === 0) {
            var d = new Error(this.reportError(h));
            throw d.offset = this.current, d.token = h, d;
          }
          this.options.keepHistory && (p.lexerState = c.save()), this.current++;
        }
        return p && (this.lexerState = c.save()), this.results = this.finish(), this;
      }, s.prototype.reportLexerError = function(u) {
        var c, h, d = u.token;
        return d ? (c = "input " + JSON.stringify(d.text[0]) + " (lexer error)", h = this.lexer.formatError(d, "Syntax error")) : (c = "input (lexer error)", h = u.message), this.reportErrorCommon(h, c);
      }, s.prototype.reportError = function(u) {
        var c = (u.type ? u.type + " token: " : "") + JSON.stringify(u.value !== void 0 ? u.value : u), h = this.lexer.formatError(u, "Syntax error");
        return this.reportErrorCommon(h, c);
      }, s.prototype.reportErrorCommon = function(u, c) {
        var h = [];
        h.push(u);
        var d = this.table.length - 2, p = this.table[d], g = p.states.filter(function(y) {
          var b = y.rule.symbols[y.dot];
          return b && typeof b != "string";
        });
        if (g.length === 0)
          h.push("Unexpected " + c + `. I did not expect any more input. Here is the state of my parse table:
`), this.displayStateStack(p.states, h);
        else {
          h.push("Unexpected " + c + `. Instead, I was expecting to see one of the following:
`);
          var v = g.map(function(y) {
            return this.buildFirstStateStack(y, []) || [y];
          }, this);
          v.forEach(function(y) {
            var b = y[0], k = b.rule.symbols[b.dot], C = this.getSymbolDisplay(k);
            h.push("A " + C + " based on:"), this.displayStateStack(y, h);
          }, this);
        }
        return h.push(""), h.join(`
`);
      }, s.prototype.displayStateStack = function(u, c) {
        for (var h, d = 0, p = 0; p < u.length; p++) {
          var g = u[p], v = g.rule.toString(g.dot);
          v === h ? d++ : (d > 0 && c.push("    ^ " + d + " more lines identical to this"), d = 0, c.push("    " + v)), h = v;
        }
      }, s.prototype.getSymbolDisplay = function(u) {
        return a(u);
      }, s.prototype.buildFirstStateStack = function(u, c) {
        if (c.indexOf(u) !== -1)
          return null;
        if (u.wantedBy.length === 0)
          return [u];
        var h = u.wantedBy[0], d = [u].concat(c), p = this.buildFirstStateStack(h, d);
        return p === null ? null : [u].concat(p);
      }, s.prototype.save = function() {
        var u = this.table[this.current];
        return u.lexerState = this.lexerState, u;
      }, s.prototype.restore = function(u) {
        var c = u.index;
        this.current = c, this.table[c] = u, this.table.splice(c + 1), this.lexerState = u.lexerState, this.results = this.finish();
      }, s.prototype.rewind = function(u) {
        if (!this.options.keepHistory)
          throw new Error("set option `keepHistory` to enable rewinding");
        this.restore(this.table[u]);
      }, s.prototype.finish = function() {
        var u = [], c = this.grammar.start, h = this.table[this.table.length - 1];
        return h.states.forEach(function(d) {
          d.rule.name === c && d.dot === d.rule.symbols.length && d.reference === 0 && d.data !== s.fail && u.push(d);
        }), u.map(function(d) {
          return d.data;
        });
      };
      function a(u) {
        var c = typeof u;
        if (c === "string")
          return u;
        if (c === "object") {
          if (u.literal)
            return JSON.stringify(u.literal);
          if (u instanceof RegExp)
            return "character matching " + u;
          if (u.type)
            return u.type + " token";
          if (u.test)
            return "token matching " + String(u.test);
          throw new Error("Unknown symbol type: " + u);
        }
      }
      function l(u) {
        var c = typeof u;
        if (c === "string")
          return u;
        if (c === "object") {
          if (u.literal)
            return JSON.stringify(u.literal);
          if (u instanceof RegExp)
            return u.toString();
          if (u.type)
            return "%" + u.type;
          if (u.test)
            return "<" + String(u.test) + ">";
          throw new Error("Unknown symbol type: " + u);
        }
      }
      return {
        Parser: s,
        Grammar: i,
        Rule: e
      };
    });
  })(CC)), CC.exports;
}
var Yv = {}, J8;
function pse() {
  if (J8) return Yv;
  J8 = 1, Object.defineProperty(Yv, "__esModule", { value: !0 });
  function t(i) {
    return i[0];
  }
  const e = (i) => [].concat(...i.map((o) => Array.isArray(o) ? e(o) : o));
  function r(i) {
    return i ? Array.isArray(i) ? e(i).join("") : i : "";
  }
  const n = {
    Lexer: void 0,
    ParserRules: [
      { name: "Reverse_path", symbols: ["Path"] },
      { name: "Reverse_path$string$1", symbols: [{ literal: "<" }, { literal: ">" }], postprocess: (i) => i.join("") },
      { name: "Reverse_path", symbols: ["Reverse_path$string$1"] },
      { name: "Forward_path$subexpression$1$subexpression$1", symbols: [{ literal: "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { literal: "@" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "Forward_path$subexpression$1", symbols: ["Forward_path$subexpression$1$subexpression$1", "Domain", { literal: ">" }] },
      { name: "Forward_path", symbols: ["Forward_path$subexpression$1"] },
      { name: "Forward_path$subexpression$2", symbols: [{ literal: "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { literal: ">" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "Forward_path", symbols: ["Forward_path$subexpression$2"] },
      { name: "Forward_path", symbols: ["Path"] },
      { name: "Path$ebnf$1$subexpression$1", symbols: ["A_d_l", { literal: ":" }] },
      { name: "Path$ebnf$1", symbols: ["Path$ebnf$1$subexpression$1"], postprocess: t },
      { name: "Path$ebnf$1", symbols: [], postprocess: () => null },
      { name: "Path", symbols: [{ literal: "<" }, "Path$ebnf$1", "Mailbox", { literal: ">" }] },
      { name: "A_d_l$ebnf$1", symbols: [] },
      { name: "A_d_l$ebnf$1$subexpression$1", symbols: [{ literal: "," }, "At_domain"] },
      { name: "A_d_l$ebnf$1", symbols: ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "A_d_l", symbols: ["At_domain", "A_d_l$ebnf$1"] },
      { name: "At_domain", symbols: [{ literal: "@" }, "Domain"] },
      { name: "Domain$ebnf$1", symbols: [] },
      { name: "Domain$ebnf$1$subexpression$1", symbols: [{ literal: "." }, "sub_domain"] },
      { name: "Domain$ebnf$1", symbols: ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Domain", symbols: ["sub_domain", "Domain$ebnf$1"] },
      { name: "sub_domain", symbols: ["U_label"] },
      { name: "Let_dig", symbols: ["ALPHA_DIGIT"], postprocess: t },
      { name: "Ldh_str$ebnf$1", symbols: [] },
      { name: "Ldh_str$ebnf$1", symbols: ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Ldh_str", symbols: ["Ldh_str$ebnf$1", "Let_dig"] },
      { name: "U_Let_dig", symbols: ["ALPHA_DIGIT_U"], postprocess: t },
      { name: "U_Ldh_str$ebnf$1", symbols: [] },
      { name: "U_Ldh_str$ebnf$1", symbols: ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "U_Ldh_str", symbols: ["U_Ldh_str$ebnf$1", "U_Let_dig"] },
      { name: "U_label$ebnf$1$subexpression$1", symbols: ["U_Ldh_str"] },
      { name: "U_label$ebnf$1", symbols: ["U_label$ebnf$1$subexpression$1"], postprocess: t },
      { name: "U_label$ebnf$1", symbols: [], postprocess: () => null },
      { name: "U_label", symbols: ["U_Let_dig", "U_label$ebnf$1"] },
      { name: "address_literal$subexpression$1", symbols: ["IPv4_address_literal"] },
      { name: "address_literal$subexpression$1", symbols: ["IPv6_address_literal"] },
      { name: "address_literal$subexpression$1", symbols: ["General_address_literal"] },
      { name: "address_literal", symbols: [{ literal: "[" }, "address_literal$subexpression$1", { literal: "]" }] },
      {
        name: "non_local_part",
        symbols: ["Domain"],
        postprocess: function(i) {
          return { DomainName: r(i[0]) };
        }
      },
      {
        name: "non_local_part",
        symbols: ["address_literal"],
        postprocess: function(i) {
          return { AddressLiteral: r(i[0]) };
        }
      },
      {
        name: "Mailbox",
        symbols: ["Local_part", { literal: "@" }, "non_local_part"],
        postprocess: function(i) {
          return { localPart: r(i[0]), domainPart: r(i[2]) };
        }
      },
      {
        name: "Local_part",
        symbols: ["Dot_string"],
        postprocess: function(i) {
          return { DotString: r(i[0]) };
        }
      },
      {
        name: "Local_part",
        symbols: ["Quoted_string"],
        postprocess: function(i) {
          return { QuotedString: r(i[0]) };
        }
      },
      { name: "Dot_string$ebnf$1", symbols: [] },
      { name: "Dot_string$ebnf$1$subexpression$1", symbols: [{ literal: "." }, "Atom"] },
      { name: "Dot_string$ebnf$1", symbols: ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Dot_string", symbols: ["Atom", "Dot_string$ebnf$1"] },
      { name: "Atom$ebnf$1", symbols: [/[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/] },
      { name: "Atom$ebnf$1", symbols: ["Atom$ebnf$1", /[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Atom", symbols: ["Atom$ebnf$1"] },
      { name: "Quoted_string$ebnf$1", symbols: [] },
      { name: "Quoted_string$ebnf$1", symbols: ["Quoted_string$ebnf$1", "QcontentSMTP"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Quoted_string", symbols: ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },
      { name: "QcontentSMTP", symbols: ["qtextSMTP"] },
      { name: "QcontentSMTP", symbols: ["quoted_pairSMTP"] },
      { name: "quoted_pairSMTP", symbols: [{ literal: "\\" }, /[\x20-\x7e]/] },
      { name: "qtextSMTP", symbols: [/[\x20-\x21\x23-\x5b\x5d-\x7e\u0080-\uFFFF]/], postprocess: t },
      { name: "IPv4_address_literal$macrocall$2", symbols: [{ literal: "." }, "Snum"] },
      { name: "IPv4_address_literal$macrocall$1", symbols: ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },
      { name: "IPv4_address_literal", symbols: ["Snum", "IPv4_address_literal$macrocall$1"] },
      { name: "IPv6_address_literal$subexpression$1", symbols: [/[iI]/, /[pP]/, /[vV]/, { literal: "6" }, { literal: ":" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "IPv6_address_literal", symbols: ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },
      { name: "General_address_literal$ebnf$1", symbols: ["dcontent"] },
      { name: "General_address_literal$ebnf$1", symbols: ["General_address_literal$ebnf$1", "dcontent"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "General_address_literal", symbols: ["Standardized_tag", { literal: ":" }, "General_address_literal$ebnf$1"] },
      { name: "Standardized_tag", symbols: ["Ldh_str"] },
      { name: "dcontent", symbols: [/[\x21-\x5a\x5e-\x7e]/], postprocess: t },
      { name: "Snum", symbols: ["DIGIT"] },
      { name: "Snum$subexpression$1", symbols: [/[1-9]/, "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$1"] },
      { name: "Snum$subexpression$2", symbols: [{ literal: "1" }, "DIGIT", "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$2"] },
      { name: "Snum$subexpression$3", symbols: [{ literal: "2" }, /[0-4]/, "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$3"] },
      { name: "Snum$subexpression$4", symbols: [{ literal: "2" }, { literal: "5" }, /[0-5]/] },
      { name: "Snum", symbols: ["Snum$subexpression$4"] },
      { name: "IPv6_addr", symbols: ["IPv6_full"] },
      { name: "IPv6_addr", symbols: ["IPv6_comp"] },
      { name: "IPv6_addr", symbols: ["IPv6v4_full"] },
      { name: "IPv6_addr", symbols: ["IPv6v4_comp"] },
      { name: "IPv6_hex", symbols: ["HEXDIG"] },
      { name: "IPv6_hex$subexpression$1", symbols: ["HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$1"] },
      { name: "IPv6_hex$subexpression$2", symbols: ["HEXDIG", "HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$2"] },
      { name: "IPv6_hex$subexpression$3", symbols: ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$3"] },
      { name: "IPv6_full$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_full$macrocall$1", symbols: ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },
      { name: "IPv6_full", symbols: ["IPv6_hex", "IPv6_full$macrocall$1"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", symbols: ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1", symbols: ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },
      { name: "IPv6_comp$ebnf$1", symbols: ["IPv6_comp$ebnf$1$subexpression$1"], postprocess: t },
      { name: "IPv6_comp$ebnf$1", symbols: [], postprocess: () => null },
      { name: "IPv6_comp$string$1", symbols: [{ literal: ":" }, { literal: ":" }], postprocess: (i) => i.join("") },
      { name: "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", symbols: ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },
      { name: "IPv6_comp$ebnf$2$subexpression$1", symbols: ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },
      { name: "IPv6_comp$ebnf$2", symbols: ["IPv6_comp$ebnf$2$subexpression$1"], postprocess: t },
      { name: "IPv6_comp$ebnf$2", symbols: [], postprocess: () => null },
      { name: "IPv6_comp", symbols: ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },
      { name: "IPv6v4_full$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_full$macrocall$1", symbols: ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },
      { name: "IPv6v4_full", symbols: ["IPv6_hex", "IPv6v4_full$macrocall$1", { literal: ":" }, "IPv4_address_literal"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", symbols: ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1", symbols: ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },
      { name: "IPv6v4_comp$ebnf$1", symbols: ["IPv6v4_comp$ebnf$1$subexpression$1"], postprocess: t },
      { name: "IPv6v4_comp$ebnf$1", symbols: [], postprocess: () => null },
      { name: "IPv6v4_comp$string$1", symbols: [{ literal: ":" }, { literal: ":" }], postprocess: (i) => i.join("") },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", symbols: ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1", symbols: ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { literal: ":" }] },
      { name: "IPv6v4_comp$ebnf$2", symbols: ["IPv6v4_comp$ebnf$2$subexpression$1"], postprocess: t },
      { name: "IPv6v4_comp$ebnf$2", symbols: [], postprocess: () => null },
      { name: "IPv6v4_comp", symbols: ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },
      { name: "DIGIT", symbols: [/[0-9]/], postprocess: t },
      { name: "ALPHA_DIGIT_U", symbols: [/[0-9A-Za-z\u0080-\uFFFF]/], postprocess: t },
      { name: "ALPHA_DIGIT", symbols: [/[0-9A-Za-z]/], postprocess: t },
      { name: "ALPHA_DIG_DASH", symbols: [/[-0-9A-Za-z]/], postprocess: t },
      { name: "ALPHA_DIG_DASH_U", symbols: [/[-0-9A-Za-z\u0080-\uFFFF]/], postprocess: t },
      { name: "HEXDIG", symbols: [/[0-9A-Fa-f]/], postprocess: t },
      { name: "DQUOTE", symbols: [{ literal: '"' }], postprocess: t }
    ],
    ParserStart: "Reverse_path"
  };
  return Yv.default = n, Yv;
}
var Y8;
function mse() {
  if (Y8) return Si;
  Y8 = 1;
  var t = Si && Si.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  };
  Object.defineProperty(Si, "__esModule", { value: !0 }), Si.canonicalize = Si.canonicalize_quoted_string = Si.normalize = Si.normalize_dot_string = Si.parse = void 0;
  const e = dse(), r = t(pse());
  r.default.ParserStart = "Mailbox";
  const n = e.Grammar.fromCompiled(r.default);
  function i(u) {
    const c = new e.Parser(n);
    if (c.feed(u), c.results.length !== 1)
      throw new Error("address parsing failed: ambiguous grammar");
    return c.results[0];
  }
  Si.parse = i;
  function o(u) {
    return (function() {
      const c = u.indexOf("+");
      return c === -1 ? u : u.substr(0, c);
    })().replace(/\./g, "").toLowerCase();
  }
  Si.normalize_dot_string = o;
  function s(u) {
    var c, h;
    const d = i(u), p = (c = d.domainPart.AddressLiteral) !== null && c !== void 0 ? c : d.domainPart.DomainName.toLowerCase();
    return `${(h = d.localPart.QuotedString) !== null && h !== void 0 ? h : o(d.localPart.DotString)}@${p}`;
  }
  Si.normalize = s;
  function a(u) {
    return `"${u.substr(1).substr(0, u.length - 2).replace(/(?:\\(.))/g, "$1").replace(/(?:(["\\]))/g, "\\$1")}"`;
  }
  Si.canonicalize_quoted_string = a;
  function l(u) {
    var c;
    const h = i(u), d = (c = h.domainPart.AddressLiteral) !== null && c !== void 0 ? c : h.domainPart.DomainName.toLowerCase();
    return `${h.localPart.QuotedString ? a(h.localPart.QuotedString) : h.localPart.DotString}@${d}`;
  }
  return Si.canonicalize = l, Si;
}
var gse = mse();
const vse = new RegExp("^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$"), yse = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, bse = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, xse = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/, wse = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, kse = /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Cse = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], _se = /^(?:\/(?:[^~/]|~0|~1)*)*$/, Sse = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, Ase = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, Ese = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, gN = {
  date: (t, e, r, n) => {
    if (typeof r != "string" || r === "")
      return;
    const i = r.match(wse);
    if (!i)
      return t.errors.formatDateTimeError({ value: r, pointer: n, schema: e });
    const o = +i[1], s = +i[2], a = +i[3], l = o % 4 === 0 && (o % 100 !== 0 || o % 400 === 0);
    if (!(s >= 1 && s <= 12 && a >= 1 && a <= (s == 2 && l ? 29 : Cse[s])))
      return t.errors.formatDateError({ value: r, pointer: n, schema: e });
  },
  "date-time": (t, e, r, n) => {
    if (!(typeof r != "string" || r === ""))
      return r === "" || vse.test(r) ? new Date(r).toString() === "Invalid Date" ? t.errors.formatDateTimeError({ value: r, pointer: n, schema: e }) : void 0 : t.errors.formatDateTimeError({ value: r, pointer: n, schema: e });
  },
  email: (t, e, r, n) => {
    if (typeof r != "string" || r === "")
      return;
    if (r[0] === '"')
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    const [i, o, ...s] = r.split("@");
    if (!i || !o || s.length !== 0 || i.length > 64 || o.length > 253)
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    if (i[0] === "." || i.endsWith(".") || i.includes(".."))
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    if (!/^[a-z0-9.-]+$/i.test(o) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(i))
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
    if (!o.split(".").every((a) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(a)))
      return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
  },
  /**
   * @draft 7
   * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531
   */
  "idn-email": (t, e, r, n) => {
    if (!(typeof r != "string" || r === ""))
      try {
        gse.parse(r);
        return;
      } catch {
        return t.errors.formatEmailError({ value: r, pointer: n, schema: e });
      }
  },
  hostname: (t, e, r, n) => {
    if (typeof r == "string" && !(r === "" || xse.test(r)))
      return t.errors.formatHostnameError({ value: r, pointer: n, schema: e });
  },
  ipv4: (t, e, r, n) => {
    if (!(typeof r != "string" || r === "")) {
      if (r && r[0] === "0")
        return t.errors.formatIPV4LeadingZeroError({ value: r, pointer: n, schema: e });
      if (!(r.length <= 15 && yse.test(r)))
        return t.errors.formatIPV4Error({ value: r, pointer: n, schema: e });
    }
  },
  ipv6: (t, e, r, n) => {
    if (!(typeof r != "string" || r === "")) {
      if (r && r[0] === "0")
        return t.errors.formatIPV6LeadingZeroError({ value: r, pointer: n, schema: e });
      if (!(r.length <= 45 && bse.test(r)))
        return t.errors.formatIPV6Error({ value: r, pointer: n, schema: e });
    }
  },
  "json-pointer": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !_se.test(r))
      return t.errors.formatJsonPointerError({ value: r, pointer: n, schema: e });
  },
  "relative-json-pointer": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !Sse.test(r))
      return t.errors.formatJsonPointerError({ value: r, pointer: n, schema: e });
  },
  regex: (t, e, r, n) => {
    if (typeof r == "string" && /\\Z$/.test(r) === !1) {
      try {
        new RegExp(r);
        return;
      } catch {
      }
      return t.errors.formatRegExError({ value: r, pointer: n, schema: e });
    }
    if (!(typeof r == "object" || typeof r == "number" || Array.isArray(r)))
      return t.errors.formatRegExError({ value: r, pointer: n, schema: e });
  },
  // hh:mm:ss.sTZD
  // https://opis.io/json-schema/2.x/formats.html
  // regex https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html
  time: (t, e, r, n) => typeof r != "string" || r === "" || r.match(kse) ? void 0 : t.errors.formatDateTimeError({ value: r, pointer: n, schema: e }),
  uri: (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !X8.isUri(r))
      return t.errors.formatURIError({ value: r, pointer: n, schema: e });
  },
  "uri-reference": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !Ase.test(r))
      return t.errors.formatURIReferenceError({ value: r, pointer: n, schema: e });
  },
  "uri-template": (t, e, r, n) => {
    if (!(typeof r != "string" || r === "") && !Ese.test(r))
      return t.errors.formatURITemplateError({ value: r, pointer: n, schema: e });
  },
  url: (t, e, r, n) => {
    if (!(r === "" || X8.isWebUri(r)))
      return t.errors.formatURLError({ value: r, pointer: n, schema: e });
  }
}, vN = {};
function yN(t, e = vN) {
  const { pointer: r = "#", data: n, schema: i = t.rootSchema, withSchemaWarning: o = !1 } = e, s = yg.split(r), a = bN(t, t.resolveRef(i), s, "#", n);
  if (!(!o && a?.code === "schema-warning"))
    return a;
}
function bN(t, e, r, n, i = vN) {
  if (r.length === 0)
    return t.resolveRef(e);
  const o = r.shift();
  return e = t.step(o, e, i, n), vi(e) ? e : (i = i[o], bN(t, e, r, `${n}/${o}`, i));
}
function Dse(t) {
  switch (rr(t)) {
    case "string":
    case "array":
      return t?.length === 0;
    case "null":
    case "undefined":
      return !0;
    case "object":
      return Object.keys(t).length === 0;
    default:
      return !1;
  }
}
const Z8 = tp.templateDefaultOptions;
let Il;
function K2(t, e) {
  const { $ref: r } = t;
  return r == null ? !0 : (Il[e] == null || Il[e][r] == null ? 0 : Il[e][r]) < tp.GET_TEMPLATE_RECURSION_LIMIT;
}
function e7(t, e, r) {
  const { $ref: n } = e;
  return n == null ? e : (Il[r] = Il[r] || {}, Il[r][n] = Il[r][n] || 0, Il[r][n] += 1, t.resolveRef(e));
}
function Ose(t, e) {
  if (t === "string")
    return JSON.stringify(e);
  if (typeof e != "string")
    return null;
  try {
    if (e = JSON.parse(e), typeof e === t)
      return e;
  } catch {
  }
  return null;
}
function xN(t, e, r, n, i) {
  if (rr(e) !== "object")
    return Object.assign({ pointer: n }, e);
  if (K2(e, n) === !1 && r == null)
    return !1;
  let o = P1(e7(t, e, n));
  if (Array.isArray(e.anyOf) && e.anyOf.length > 0) {
    if (K2(e.anyOf[0], `${n}/anyOf/0`)) {
      const s = e7(t, e.anyOf[0], `${n}/anyOf/0`);
      o = q4(o, s), o.pointer = e.anyOf[0].$ref || o.pointer;
    }
    delete o.anyOf;
  }
  if (Array.isArray(e.allOf) && e.allOf.map((s, a) => K2(s, `${n}/allOf/${a}`)).reduceRight((s, a) => s && a, !0)) {
    const s = [];
    let a = P1(r);
    for (let u = 0; u < e.allOf.length; u += 1)
      s.push(nN(t, e.allOf[u], a)), a = $s(t, a, { type: e.type, ...s[u] }, `${n}/allOf/${u}`, i);
    const l = oN(t, { allOf: s });
    l && (o = Ti(o, l));
  }
  return o.pointer = o.pointer || e.$ref || n, o;
}
const t7 = (t) => t && typeof t == "object";
function $s(t, e, r, n, i) {
  var o;
  if (r == null)
    throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(e)}`);
  if (n == null)
    throw new Error("Missing pointer");
  let s = xN(t, r, e, n, i);
  if (!t7(s))
    return;
  if (n = s.pointer, s?.const)
    return s.const;
  if (Array.isArray(s.oneOf))
    if (Dse(e)) {
      const u = s.oneOf[0].type || s.type || s.const && typeof s.const || rr(e);
      s = { ...s.oneOf[0], type: u };
    } else {
      const u = j4(t, e, s);
      if (vi(u)) {
        if (e != null && i.removeInvalidData !== !0)
          return e;
        s = s.oneOf[0], e = void 0;
      } else
        u.type = (o = u.type) !== null && o !== void 0 ? o : s.type, s = u;
    }
  if (!t7(s) || s.type == null)
    return;
  if (e instanceof File)
    return e;
  const a = Array.isArray(s.type) ? Fse(s.type, e, s.default) : s.type, l = rr(e);
  return e != null && l !== a && !(l === "number" && a === "integer") && (e = Ose(a, e)), r7[a] == null ? i.removeInvalidData ? void 0 : e : r7[a](t, s, e, n, i);
}
function Fse(t, e, r) {
  if (e == null) {
    if (r != null) {
      const i = rr(r);
      if (t.includes(i))
        return i;
    }
    return t[0];
  }
  const n = rr(e);
  return t.includes(n) ? n : t[0];
}
const r7 = {
  null: (t, e, r) => tm(e, r, null),
  string: (t, e, r) => tm(e, r, ""),
  number: (t, e, r) => tm(e, r, 0),
  integer: (t, e, r) => tm(e, r, 0),
  boolean: (t, e, r) => tm(e, r, !1),
  object: (t, e, r, n, i) => {
    var o;
    const s = e.default === void 0 ? {} : e.default, a = {}, l = i.extendDefaults === !1 && e.default !== void 0 ? [] : (o = e.required) !== null && o !== void 0 ? o : [];
    e.properties && Object.keys(e.properties).forEach((h) => {
      const d = r == null || r[h] == null ? s[h] : r[h], p = l.includes(h);
      (d != null || p || i.addOptionalProps) && (a[h] = $s(t, d, e.properties[h], `${n}/properties/${h}`, i));
    });
    let u = aN(t, e, a);
    if (u) {
      u = Ti(e, u), delete u.dependencies;
      const h = $s(t, r, u, `${n}/dependencies`, i);
      Object.assign(a, h);
    }
    r && (i.removeInvalidData === !0 && (e.additionalProperties === !1 || rr(e.additionalProperties) === "object") ? rr(e.additionalProperties) === "object" && Object.keys(r).forEach((h) => {
      a[h] == null && t.isValid(r[h], e.additionalProperties) && (a[h] = r[h]);
    }) : Object.keys(r).forEach((h) => a[h] == null && (a[h] = r[h])));
    const c = Kb(t, e, a);
    if (c) {
      const h = $s(t, a, { type: "object", ...c }, n, i);
      Object.assign(a, h);
    }
    return a;
  },
  // build array type of items, ignores additionalItems
  array: (t, e, r, n, i) => {
    var o, s;
    if (e.items == null)
      return r || [];
    const a = e.default === void 0 ? [] : e.default, l = r || a, u = i.extendDefaults === !1 && e.default !== void 0 ? 0 : e.minItems || 0;
    if (Array.isArray(e.items)) {
      for (let h = 0, d = Math.max(u ?? 0, (s = (o = e.items) === null || o === void 0 ? void 0 : o.length) !== null && s !== void 0 ? s : 0); h < d; h += 1)
        l[h] = $s(t, l[h] == null ? a[h] : l[h], e.items[h], `${n}/items/${h}`, i);
      return l;
    }
    if (rr(e.items) !== "object")
      return l;
    const c = xN(t, e.items, r, n, i);
    if (c === !1)
      return l;
    if (n = c.pointer || n, c.oneOf && l.length === 0) {
      const h = c.oneOf[0];
      for (let d = 0; d < u; d += 1)
        l[d] = $s(t, l[d] == null ? a[d] : l[d], h, `${n}/oneOf/0`, i);
      return l;
    }
    if (c.oneOf && l.length > 0) {
      const h = Math.max(u, l.length);
      for (let d = 0; d < h; d += 1) {
        let p = l[d] == null ? a[d] : l[d], g = j4(t, p, c);
        g == null || vi(g) ? p != null && i.removeInvalidData !== !0 ? l[d] = p : (p = void 0, g = c.oneOf[0], l[d] = $s(t, p, g, `${n}/oneOf/${d}`, i)) : l[d] = $s(t, p, g, `${n}/oneOf/${d}`, i);
      }
      return l;
    }
    if (c.type) {
      for (let h = 0, d = Math.max(u, l.length); h < d; h += 1)
        l[h] = $s(t, l[h] == null ? a[h] : l[h], c, `${n}/items`, i);
      return l;
    }
    return l;
  }
};
function tm(t, e, r) {
  return e ?? (t.const ? t.const : t.default === void 0 && Array.isArray(t.enum) ? t.enum[0] : t.default === void 0 ? r : t.default);
}
const wN = (t, e, r = t.rootSchema, n) => (Il = {}, n ? $s(t, e, r, "#", { ...Z8, ...n }) : $s(t, e, r, "#", Z8));
function kN(t, e, r = t.rootSchema, n = "#") {
  return t.validate(e, r, n).length === 0;
}
function n7(t) {
  const e = [];
  let r = 0;
  const n = t.length;
  for (; r < n; ) {
    const i = t.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      const o = t.charCodeAt(r++);
      (o & 64512) == 56320 ? e.push(((i & 1023) << 10) + (o & 1023) + 65536) : (e.push(i), r--);
    } else
      e.push(i);
  }
  return e;
}
function i7(t) {
  const e = `${t}`, r = e.indexOf(".");
  return r === -1 ? 0 : e.length - (r + 1);
}
var o7, s7;
function Tse() {
  return s7 || (s7 = 1, o7 = function t(e, r) {
    if (e === r) return !0;
    if (e && r && typeof e == "object" && typeof r == "object") {
      if (e.constructor !== r.constructor) return !1;
      var n, i, o;
      if (Array.isArray(e)) {
        if (n = e.length, n != r.length) return !1;
        for (i = n; i-- !== 0; )
          if (!t(e[i], r[i])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === r.source && e.flags === r.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === r.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === r.toString();
      if (o = Object.keys(e), n = o.length, n !== Object.keys(r).length) return !1;
      for (i = n; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, o[i])) return !1;
      for (i = n; i-- !== 0; ) {
        var s = o[i];
        if (!t(e[s], r[s])) return !1;
      }
      return !0;
    }
    return e !== e && r !== r;
  }), o7;
}
var Mse = Tse();
const CN = /* @__PURE__ */ zh(Mse), Pse = Object.prototype.hasOwnProperty, a7 = (t, e) => !(t[e] === void 0 || !Pse.call(t, e)), _N = {
  additionalProperties: (t, e, r, n) => {
    if (e.additionalProperties === !0 || e.additionalProperties == null || rr(e.patternProperties) === "object" && e.additionalProperties === !1)
      return;
    const i = [];
    let o = Object.keys(r).filter((a) => tp.propertyBlacklist.includes(a) === !1);
    const s = Object.keys(e.properties || {});
    if (rr(e.patternProperties) === "object") {
      const a = Object.keys(e.patternProperties).map((l) => new RegExp(l));
      o = o.filter((l) => {
        for (let u = 0; u < a.length; u += 1)
          if (a[u].test(l))
            return !1;
        return !0;
      });
    }
    for (let a = 0, l = o.length; a < l; a += 1) {
      const u = o[a];
      if (s.indexOf(u) === -1) {
        const c = Wu(e.additionalProperties);
        if (c && Array.isArray(e.additionalProperties.oneOf)) {
          const h = t.resolveOneOf(r[u], e.additionalProperties, `${n}/${u}`);
          vi(h) ? i.push(t.errors.additionalPropertiesError({
            pointer: n,
            schema: e.additionalProperties,
            value: r,
            property: o[a],
            properties: s,
            // pass all validation errors
            errors: h.data.errors
          })) : i.push(...t.validate(r[u], h, n));
        } else c ? i.push(...t.validate(r[u], e.additionalProperties, `${n}/${u}`)) : i.push(t.errors.noAdditionalPropertiesError({
          pointer: n,
          schema: e,
          value: r,
          property: o[a],
          properties: s
        }));
      }
    }
    return i;
  },
  allOf: boe,
  anyOf: koe,
  dependencies: woe,
  enum: (t, e, r, n) => {
    const i = rr(r);
    if (i === "object" || i === "array") {
      const o = JSON.stringify(r);
      for (let s = 0; s < e.enum.length; s += 1)
        if (JSON.stringify(e.enum[s]) === o)
          return;
    } else if (e.enum.includes(r))
      return;
    return t.errors.enumError({ pointer: n, schema: e, value: r, values: e.enum });
  },
  format: (t, e, r, n) => {
    if (t.validateFormat[e.format])
      return t.validateFormat[e.format](t, e, r, n);
  },
  items: (t, e, r, n) => {
    if (e.items === !1)
      return Array.isArray(r) && r.length === 0 ? void 0 : t.errors.invalidDataError({ pointer: n, value: r, schema: e });
    const i = [];
    for (let o = 0; o < r.length; o += 1) {
      const s = r[o], a = t.step(o, e, r, n);
      if (vi(a))
        return [a];
      const l = t.validate(s, a, `${n}/${o}`);
      i.push(...l);
    }
    return i;
  },
  maximum: (t, e, r, n) => {
    if (!isNaN(e.maximum)) {
      if (e.maximum && e.maximum < r)
        return t.errors.maximumError({
          maximum: e.maximum,
          length: r,
          value: r,
          pointer: n,
          schema: e
        });
      if (e.maximum && e.exclusiveMaximum === !0 && e.maximum === r)
        return t.errors.maximumError({
          maximum: e.maximum,
          length: r,
          pointer: n,
          schema: e,
          value: r
        });
    }
  },
  maxItems: (t, e, r, n) => {
    if (!isNaN(e.maxItems) && e.maxItems < r.length)
      return t.errors.maxItemsError({
        maximum: e.maxItems,
        length: r.length,
        schema: e,
        value: r,
        pointer: n
      });
  },
  maxLength: (t, e, r, n) => {
    if (isNaN(e.maxLength))
      return;
    const i = n7(r).length;
    if (e.maxLength < i)
      return t.errors.maxLengthError({
        maxLength: e.maxLength,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  maxProperties: (t, e, r, n) => {
    const i = Object.keys(r).length;
    if (isNaN(e.maxProperties) === !1 && e.maxProperties < i)
      return t.errors.maxPropertiesError({
        maxProperties: e.maxProperties,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minLength: (t, e, r, n) => {
    if (isNaN(e.minLength))
      return;
    const i = n7(r).length;
    if (e.minLength > i)
      return e.minLength === 1 ? t.errors.minLengthOneError({
        minLength: e.minLength,
        length: i,
        pointer: n,
        schema: e,
        value: r
      }) : t.errors.minLengthError({
        minLength: e.minLength,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minimum: (t, e, r, n) => {
    if (!isNaN(e.minimum)) {
      if (e.minimum > r)
        return t.errors.minimumError({
          minimum: e.minimum,
          length: r,
          pointer: n,
          schema: e,
          value: r
        });
      if (e.exclusiveMinimum === !0 && e.minimum === r)
        return t.errors.minimumError({
          minimum: e.minimum,
          length: r,
          pointer: n,
          schema: e,
          value: r
        });
    }
  },
  minItems: (t, e, r, n) => {
    if (!isNaN(e.minItems) && e.minItems > r.length)
      return e.minItems === 1 ? t.errors.minItemsOneError({
        minItems: e.minItems,
        length: r.length,
        pointer: n,
        schema: e,
        value: r
      }) : t.errors.minItemsError({
        minItems: e.minItems,
        length: r.length,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minProperties: (t, e, r, n) => {
    if (isNaN(e.minProperties))
      return;
    const i = Object.keys(r).length;
    if (e.minProperties > i)
      return t.errors.minPropertiesError({
        minProperties: e.minProperties,
        length: i,
        pointer: n,
        schema: e,
        value: r
      });
  },
  multipleOf: (t, e, r, n) => {
    if (isNaN(e.multipleOf) || typeof r != "number")
      return;
    const i = i7(r), o = i7(e.multipleOf);
    if (i > o)
      return t.errors.multipleOfError({
        multipleOf: e.multipleOf,
        value: r,
        pointer: n,
        schema: e
      });
    const s = Math.pow(10, o), a = Math.round(r * s), l = Math.round(e.multipleOf * s);
    if (a % l / s !== 0)
      return t.errors.multipleOfError({
        multipleOf: e.multipleOf,
        value: r,
        pointer: n,
        schema: e
      });
  },
  not: (t, e, r, n) => {
    const i = [];
    return t.validate(r, e.not, n).length === 0 && i.push(t.errors.notError({ value: r, not: e.not, pointer: n, schema: e })), i;
  },
  oneOf: Pie,
  pattern: (t, e, r, n) => {
    if (new RegExp(e.pattern, "u").test(r) === !1)
      return t.errors.patternError({
        pattern: e.pattern,
        description: e.patternExample || e.pattern,
        received: r,
        schema: e,
        value: r,
        pointer: n
      });
  },
  patternProperties: (t, e, r, n) => {
    const i = e.properties || {}, o = e.patternProperties;
    if (rr(o) !== "object")
      return;
    const s = [], a = Object.keys(r), l = Object.keys(o).map((u) => ({
      regex: new RegExp(u),
      patternSchema: o[u]
    }));
    return a.forEach((u) => {
      let c = !1;
      for (let h = 0, d = l.length; h < d; h += 1)
        if (l[h].regex.test(u)) {
          c = !0;
          const p = t.validate(r[u], l[h].patternSchema, `${n}/${u}`);
          p && p.length > 0 && s.push(...p);
        }
      i[u] || c === !1 && e.additionalProperties === !1 && s.push(t.errors.patternPropertiesError({
        key: u,
        pointer: n,
        schema: e,
        value: r,
        patterns: Object.keys(o).join(",")
      }));
    }), s;
  },
  properties: (t, e, r, n) => {
    const i = [], o = Object.keys(e.properties || {});
    for (let s = 0; s < o.length; s += 1) {
      const a = o[s];
      if (a7(r, a)) {
        const l = t.step(a, e, r, n), u = t.validate(r[a], l, `${n}/${a}`);
        i.push(...u);
      }
    }
    return i;
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword
  propertiesRequired: (t, e, r, n) => {
    const i = [], o = Object.keys(e.properties || {});
    for (let s = 0; s < o.length; s += 1) {
      const a = o[s];
      if (r[a] === void 0)
        i.push(t.errors.requiredPropertyError({ key: a, pointer: n, schema: e, value: r }));
      else {
        const l = t.step(a, e, r, n), u = t.validate(r[a], l, `${n}/${a}`);
        i.push(...u);
      }
    }
    return i;
  },
  required: (t, e, r, n) => {
    if (Array.isArray(e.required) !== !1)
      return e.required.map((i) => {
        if (!a7(r, i))
          return t.errors.requiredPropertyError({
            key: i,
            pointer: n,
            schema: e,
            value: r
          });
      });
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword
  requiredNotEmpty: (t, e, r, n) => {
    if (Array.isArray(e.required) !== !1)
      return e.required.map((i) => {
        if (r[i] == null || r[i] === "")
          return t.errors.valueNotEmptyError({
            property: i,
            pointer: `${n}/${i}`,
            schema: e,
            value: r
          });
      });
  },
  uniqueItems: (t, e, r, n) => {
    if ((Array.isArray(r) && e.uniqueItems) === !1)
      return;
    const i = [], o = [];
    return r.forEach((s, a) => {
      for (let l = a + 1; l < r.length; l += 1)
        CN(s, r[l]) && !i.includes(l) && (o.push(t.errors.uniqueItemsError({
          pointer: `${n}/${l}`,
          duplicatePointer: `${n}/${a}`,
          arrayPointer: n,
          value: JSON.stringify(s),
          schema: e
        })), i.push(l));
    }), o;
  }
};
function Oa(t) {
  if (t === void 0)
    return;
  const e = {
    type: rr(t)
  };
  return e.type === "object" && Wu(t) && (e.properties = {}, Object.keys(t).forEach((r) => e.properties[r] = Oa(t[r]))), e.type === "array" && Array.isArray(t) && (t.length === 1 ? e.items = Oa(t[0]) : e.items = t.map(Oa)), e;
}
const Rse = {
  array: (t, e, r, n, i) => {
    const o = n?.[e], s = rr(r.items);
    if (s === "object")
      return $8(t, r.items, o, `${i}/${e}`) || t.resolveRef(r.items);
    if (s === "array") {
      if (r.items[e] === !0)
        return Oa(o);
      if (r.items[e] === !1)
        return t.errors.invalidDataError({
          key: e,
          value: o,
          pointer: i,
          schema: r
        });
      if (r.items[e])
        return t.resolveRef(r.items[e]);
      if (r.additionalItems === !1)
        return t.errors.additionalItemsError({
          key: e,
          value: o,
          pointer: i,
          schema: r
        });
      if (r.additionalItems === !0 || r.additionalItems === void 0)
        return Oa(o);
      if (rr(r.additionalItems) === "object")
        return r.additionalItems;
      throw new Error(`Invalid schema ${JSON.stringify(r, null, 2)} for ${JSON.stringify(n, null, 2)}`);
    }
    return r.additionalItems !== !1 && o ? Oa(o) : new Error(`Invalid array schema for ${e} at ${i}`);
  },
  object: (t, e, r, n, i) => {
    var o;
    r = $8(t, r, n, i);
    const s = (o = r?.properties) === null || o === void 0 ? void 0 : o[e];
    if (s !== void 0) {
      if (s === !1)
        return t.errors.forbiddenPropertyError({
          property: e,
          value: n,
          pointer: i,
          schema: r
        });
      if (s === !0)
        return Oa(n?.[e]);
      const u = t.resolveRef(s);
      if (vi(u))
        return u;
      if (u && Array.isArray(u.oneOf)) {
        const c = t.resolveOneOf(n[e], u, `${i}/${e}`);
        for (const h in u)
          h !== "oneOf" && c[h] === void 0 && (c[h] = u[h]);
        return c;
      }
      if (u)
        return u;
    }
    const { patternProperties: a } = r;
    if (rr(a) === "object") {
      let u;
      const c = Object.keys(a);
      for (let h = 0, d = c.length; h < d; h += 1)
        if (u = new RegExp(c[h]), u.test(e))
          return a[c[h]];
    }
    const { additionalProperties: l } = r;
    return rr(l) === "object" ? r.additionalProperties : n && (l === void 0 || l === !0) ? Oa(n[e]) : t.errors.unknownPropertyError({
      property: e,
      value: n,
      pointer: `${i}`,
      schema: r
    });
  }
};
function SN(t, e, r, n, i = "#") {
  var o;
  const s = rr(n);
  let a = (o = r.type) !== null && o !== void 0 ? o : s;
  if (Array.isArray(a)) {
    if (!a.includes(s))
      return t.errors.typeError({
        value: n,
        pointer: i,
        expected: r.type,
        received: s,
        schema: r
      });
    a = s;
  }
  const l = Rse[a];
  if (l) {
    const u = l(t, `${e}`, r, n, i);
    return u === void 0 ? t.errors.schemaWarning({
      pointer: i,
      value: n,
      schema: r,
      key: e
    }) : u;
  }
  return new Error(`Unsupported schema type ${r.type} for key ${e}`);
}
function AN(t, e, r = t.rootSchema) {
  var n;
  if (r.oneOf)
    return r.oneOf.map((o) => t.resolveRef(o));
  if (!((n = r.items) === null || n === void 0) && n.oneOf)
    return r.items.oneOf.map((o) => t.resolveRef(o));
  const i = t.step(e, r, {}, "#");
  return vi(i) ? i : [i];
}
const Nse = {
  array: (t, e, r, n) => t.typeKeywords.array.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  object: (t, e, r, n) => t.typeKeywords.object.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  string: (t, e, r, n) => t.typeKeywords.string.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  integer: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  number: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  boolean: (t, e, r, n) => t.typeKeywords.boolean.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  null: (t, e, r, n) => t.typeKeywords.null.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n))
};
function $se(t, e) {
  const r = rr(t);
  return r === "number" && (e === "integer" || Array.isArray(e) && e.includes("integer")) ? Number.isInteger(t) || isNaN(t) ? "integer" : "number" : r;
}
function EN(t, e, r = t.rootSchema, n = "#") {
  if (r = t.resolveRef(r), rr(r) === "boolean")
    return r ? [] : [t.errors.invalidDataError({ pointer: n, schema: r, value: e })];
  if (vi(r))
    return [r];
  if (r.const !== void 0)
    return CN(r.const, e) ? [] : [t.errors.constError({ pointer: n, schema: r, value: e, expected: r.const })];
  const i = $se(e, r.type), o = r.type || i;
  return i !== o && (!Array.isArray(o) || !o.includes(i)) ? [
    t.errors.typeError({
      pointer: n,
      schema: r,
      value: e,
      received: i,
      expected: o
    })
  ] : t.validateType[i] == null ? [t.errors.invalidTypeError({ pointer: n, schema: r, value: e, receivedType: i })] : gg(t.validateType[i](t, r, e, n)).filter(M1);
}
const Ise = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "enum",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],
    object: [
      "additionalProperties",
      "dependencies",
      "enum",
      "format",
      "minProperties",
      "maxProperties",
      "patternProperties",
      "properties",
      "required",
      "not",
      "oneOf",
      "allOf",
      "anyOf"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: _N,
  validateType: Nse,
  validateFormat: gN,
  errors: mN,
  addRemoteSchema: hN,
  compileSchema: use,
  createSchemaOf: Oa,
  each: pN,
  eachSchema: Xb,
  getChildSchemaSelection: AN,
  getSchema: yN,
  getTemplate: wN,
  isValid: kN,
  resolveAllOf: iN,
  resolveAnyOf: uN,
  resolveOneOf: VR,
  resolveRef: sN,
  step: SN,
  validate: EN,
  templateDefaultOptions: tp.templateDefaultOptions
};
class DN extends cN {
  constructor(e, r = {}) {
    super(q4(Ise, r), e);
  }
}
const l7 = "__compiled", u7 = "__ref", Bse = "getRef", Lse = "getRoot", zse = /(#|\/)+$/g;
function jse(t, e, r = e, n = !1) {
  if (e === !0 || e === !1 || e === void 0 || e[l7] !== void 0)
    return e;
  const i = { ids: {}, remotes: t.remotes }, o = JSON.stringify(e), s = JSON.parse(o);
  if (Object.defineProperty(s, l7, { enumerable: !1, value: !0 }), Object.defineProperty(s, Bse, {
    enumerable: !1,
    value: Fl.bind(null, i, s)
  }), n === !1 && o.includes("$ref") === !1)
    return s;
  s !== r && Object.defineProperty(s, "$defs", {
    enumerable: !0,
    value: Object.assign({}, r.definitions, r.$defs, s.definitions, s.$defs)
  });
  const a = {}, l = () => s;
  return Xb(s, (u, c) => {
    var h;
    if (u.$id) {
      if (u.$id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(c)) {
        const y = c.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, ""), b = Vc.get(s, y);
        u.$id = (h = b.$id) !== null && h !== void 0 ? h : u.$id;
      }
      i.ids[u.$id.replace(zse, "")] = c;
    }
    c = `#${c}`.replace(/##+/, "#");
    const d = c.replace(/\/[^/]+$/, ""), p = c.replace(/\/[^/]+\/[^/]+$/, ""), g = a[d] || a[p], v = I1(g, u.$id);
    a[c] = v, i.ids[v] == null && (i.ids[v] = c), u.$ref && !u[u7] && (Object.defineProperty(u, u7, {
      enumerable: !1,
      value: I1(v, u.$ref)
    }), Object.defineProperty(u, Lse, { enumerable: !1, value: l }));
  }), s;
}
const qse = {
  ..._N,
  // @draft >= 6
  contains: (t, e, r, n) => {
    if (e.contains === !1)
      return t.errors.containsArrayError({ pointer: n, value: r, schema: e });
    if (e.contains === !0)
      return Array.isArray(r) && r.length === 0 ? t.errors.containsAnyError({ pointer: n, value: r, schema: e }) : void 0;
    if (rr(e.contains) === "object") {
      for (let i = 0; i < r.length; i += 1)
        if (t.isValid(r[i], e.contains))
          return;
      return t.errors.containsError({ pointer: n, schema: e, value: r });
    }
  },
  exclusiveMaximum: (t, e, r, n) => {
    if (!isNaN(e.exclusiveMaximum) && e.exclusiveMaximum <= r)
      return t.errors.maximumError({
        maximum: e.exclusiveMaximum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  exclusiveMinimum: (t, e, r, n) => {
    if (!isNaN(e.exclusiveMinimum) && e.exclusiveMinimum >= r)
      return t.errors.minimumError({
        minimum: e.exclusiveMinimum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  // @feature if-then-else
  if: yoe,
  maximum: (t, e, r, n) => {
    if (!isNaN(e.maximum) && e.maximum && e.maximum < r)
      return t.errors.maximumError({
        maximum: e.maximum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  minimum: (t, e, r, n) => {
    if (!isNaN(e.minimum) && e.minimum > r)
      return t.errors.minimumError({
        minimum: e.minimum,
        length: r,
        pointer: n,
        schema: e,
        value: r
      });
  },
  patternProperties: (t, e, r, n) => {
    const i = e.properties || {}, o = e.patternProperties;
    if (rr(o) !== "object")
      return;
    const s = [], a = Object.keys(r), l = Object.keys(o).map((u) => ({
      regex: new RegExp(u),
      patternSchema: o[u]
    }));
    return a.forEach((u) => {
      let c = !1;
      for (let h = 0, d = l.length; h < d; h += 1)
        if (l[h].regex.test(u)) {
          if (c = !0, l[h].patternSchema === !1) {
            s.push(t.errors.patternPropertiesError({
              key: u,
              pointer: n,
              patterns: Object.keys(o).join(","),
              schema: e,
              value: r
            }));
            return;
          }
          const p = t.validate(r[u], l[h].patternSchema, `${n}/${u}`);
          p && p.length > 0 && s.push(...p);
        }
      i[u] || c === !1 && e.additionalProperties === !1 && s.push(t.errors.patternPropertiesError({
        key: u,
        pointer: n,
        patterns: Object.keys(o).join(","),
        schema: e,
        value: r
      }));
    }), s;
  },
  // @draft >= 6
  propertyNames: (t, e, r, n) => {
    if (e.propertyNames === !1)
      return Object.keys(r).length === 0 ? void 0 : t.errors.invalidPropertyNameError({
        property: Object.keys(r),
        pointer: n,
        value: r,
        schema: e
      });
    if (e.propertyNames === !0 || rr(e.propertyNames) !== "object")
      return;
    const i = [], o = Object.keys(r), s = { ...e.propertyNames, type: "string" };
    return o.forEach((a) => {
      const l = t.validate(a, s, `${n}/${a}`);
      l.length > 0 && i.push(t.errors.invalidPropertyNameError({
        property: a,
        pointer: n,
        validationError: l[0],
        value: r[a],
        schema: e
      }));
    }), i;
  }
}, Use = {
  array: (t, e, r, n) => t.typeKeywords.array.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  object: (t, e, r, n) => t.typeKeywords.object.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  string: (t, e, r, n) => t.typeKeywords.string.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  integer: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  number: (t, e, r, n) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  boolean: (t, e, r, n) => t.typeKeywords.boolean.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n)),
  null: (t, e, r, n) => t.typeKeywords.null.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, r, n))
}, ON = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: qse,
  validateType: Use,
  validateFormat: gN,
  errors: mN,
  addRemoteSchema: hN,
  compileSchema: jse,
  createSchemaOf: Oa,
  each: pN,
  eachSchema: Xb,
  getChildSchemaSelection: AN,
  getSchema: yN,
  getTemplate: wN,
  isValid: kN,
  resolveAllOf: iN,
  resolveAnyOf: uN,
  resolveOneOf: VR,
  resolveRef: sN,
  step: SN,
  validate: EN,
  templateDefaultOptions: tp.templateDefaultOptions
};
class FN extends cN {
  constructor(e, r = {}) {
    super(q4(ON, r), e);
  }
}
({
  ...ON
});
function _a(t, e, r = []) {
  const n = document.createElement(t);
  return Object.entries(e).forEach(([i, o]) => {
    if (i === "text") {
      n.innerText = o;
      return;
    }
    if (i === "inner") {
      n.innerHTML = o;
      return;
    }
    n.setAttribute(i, o);
  }), r.forEach((i) => n.appendChild(i)), n;
}
const c7 = {};
function Hse(t) {
  let e = c7[t];
  if (e)
    return e;
  e = c7[t] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    e.push(n);
  }
  for (let r = 0; r < t.length; r++) {
    const n = t.charCodeAt(r);
    e[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2);
  }
  return e;
}
function Od(t, e) {
  typeof e != "string" && (e = Od.defaultChars);
  const r = Hse(e);
  return t.replace(/(%[a-f0-9]{2})+/gi, function(n) {
    let i = "";
    for (let o = 0, s = n.length; o < s; o += 3) {
      const a = parseInt(n.slice(o + 1, o + 3), 16);
      if (a < 128) {
        i += r[a];
        continue;
      }
      if ((a & 224) === 192 && o + 3 < s) {
        const l = parseInt(n.slice(o + 4, o + 6), 16);
        if ((l & 192) === 128) {
          const u = a << 6 & 1984 | l & 63;
          u < 128 ? i += "ï¿½ï¿½" : i += String.fromCharCode(u), o += 3;
          continue;
        }
      }
      if ((a & 240) === 224 && o + 6 < s) {
        const l = parseInt(n.slice(o + 4, o + 6), 16), u = parseInt(n.slice(o + 7, o + 9), 16);
        if ((l & 192) === 128 && (u & 192) === 128) {
          const c = a << 12 & 61440 | l << 6 & 4032 | u & 63;
          c < 2048 || c >= 55296 && c <= 57343 ? i += "ï¿½ï¿½ï¿½" : i += String.fromCharCode(c), o += 6;
          continue;
        }
      }
      if ((a & 248) === 240 && o + 9 < s) {
        const l = parseInt(n.slice(o + 4, o + 6), 16), u = parseInt(n.slice(o + 7, o + 9), 16), c = parseInt(n.slice(o + 10, o + 12), 16);
        if ((l & 192) === 128 && (u & 192) === 128 && (c & 192) === 128) {
          let h = a << 18 & 1835008 | l << 12 & 258048 | u << 6 & 4032 | c & 63;
          h < 65536 || h > 1114111 ? i += "ï¿½ï¿½ï¿½ï¿½" : (h -= 65536, i += String.fromCharCode(55296 + (h >> 10), 56320 + (h & 1023))), o += 9;
          continue;
        }
      }
      i += "ï¿½";
    }
    return i;
  });
}
Od.defaultChars = ";/?:@&=+$,#";
Od.componentChars = "";
const h7 = {};
function Vse(t) {
  let e = h7[t];
  if (e)
    return e;
  e = h7[t] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    /^[0-9a-z]$/i.test(n) ? e.push(n) : e.push("%" + ("0" + r.toString(16).toUpperCase()).slice(-2));
  }
  for (let r = 0; r < t.length; r++)
    e[t.charCodeAt(r)] = t[r];
  return e;
}
function a0(t, e, r) {
  typeof e != "string" && (r = e, e = a0.defaultChars), typeof r > "u" && (r = !0);
  const n = Vse(e);
  let i = "";
  for (let o = 0, s = t.length; o < s; o++) {
    const a = t.charCodeAt(o);
    if (r && a === 37 && o + 2 < s && /^[0-9a-f]{2}$/i.test(t.slice(o + 1, o + 3))) {
      i += t.slice(o, o + 3), o += 2;
      continue;
    }
    if (a < 128) {
      i += n[a];
      continue;
    }
    if (a >= 55296 && a <= 57343) {
      if (a >= 55296 && a <= 56319 && o + 1 < s) {
        const l = t.charCodeAt(o + 1);
        if (l >= 56320 && l <= 57343) {
          i += encodeURIComponent(t[o] + t[o + 1]), o++;
          continue;
        }
      }
      i += "%EF%BF%BD";
      continue;
    }
    i += encodeURIComponent(t[o]);
  }
  return i;
}
a0.defaultChars = ";/?:@&=+$,-_.!~*'()#";
a0.componentChars = "-_.!~*'()";
function G4(t) {
  let e = "";
  return e += t.protocol || "", e += t.slashes ? "//" : "", e += t.auth ? t.auth + "@" : "", t.hostname && t.hostname.indexOf(":") !== -1 ? e += "[" + t.hostname + "]" : e += t.hostname || "", e += t.port ? ":" + t.port : "", e += t.pathname || "", e += t.search || "", e += t.hash || "", e;
}
function B1() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const Wse = /^([a-z0-9.+-]+:)/i, Gse = /:[0-9]*$/, Kse = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Xse = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Qse = ["{", "}", "|", "\\", "^", "`"].concat(Xse), Jse = ["'"].concat(Qse), f7 = ["%", "/", "?", ";", "#"].concat(Jse), d7 = ["/", "?", "#"], Yse = 255, p7 = /^[+a-z0-9A-Z_-]{0,63}$/, Zse = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m7 = {
  javascript: !0,
  "javascript:": !0
}, g7 = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function K4(t, e) {
  if (t && t instanceof B1) return t;
  const r = new B1();
  return r.parse(t, e), r;
}
B1.prototype.parse = function(t, e) {
  let r, n, i, o = t;
  if (o = o.trim(), !e && t.split("#").length === 1) {
    const u = Kse.exec(o);
    if (u)
      return this.pathname = u[1], u[2] && (this.search = u[2]), this;
  }
  let s = Wse.exec(o);
  if (s && (s = s[0], r = s.toLowerCase(), this.protocol = s, o = o.substr(s.length)), (e || s || o.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = o.substr(0, 2) === "//", i && !(s && m7[s]) && (o = o.substr(2), this.slashes = !0)), !m7[s] && (i || s && !g7[s])) {
    let u = -1;
    for (let g = 0; g < d7.length; g++)
      n = o.indexOf(d7[g]), n !== -1 && (u === -1 || n < u) && (u = n);
    let c, h;
    u === -1 ? h = o.lastIndexOf("@") : h = o.lastIndexOf("@", u), h !== -1 && (c = o.slice(0, h), o = o.slice(h + 1), this.auth = c), u = -1;
    for (let g = 0; g < f7.length; g++)
      n = o.indexOf(f7[g]), n !== -1 && (u === -1 || n < u) && (u = n);
    u === -1 && (u = o.length), o[u - 1] === ":" && u--;
    const d = o.slice(0, u);
    o = o.slice(u), this.parseHost(d), this.hostname = this.hostname || "";
    const p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      const g = this.hostname.split(/\./);
      for (let v = 0, y = g.length; v < y; v++) {
        const b = g[v];
        if (b && !b.match(p7)) {
          let k = "";
          for (let C = 0, S = b.length; C < S; C++)
            b.charCodeAt(C) > 127 ? k += "x" : k += b[C];
          if (!k.match(p7)) {
            const C = g.slice(0, v), S = g.slice(v + 1), _ = b.match(Zse);
            _ && (C.push(_[1]), S.unshift(_[2])), S.length && (o = S.join(".") + o), this.hostname = C.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > Yse && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const a = o.indexOf("#");
  a !== -1 && (this.hash = o.substr(a), o = o.slice(0, a));
  const l = o.indexOf("?");
  return l !== -1 && (this.search = o.substr(l), o = o.slice(0, l)), o && (this.pathname = o), g7[r] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
B1.prototype.parseHost = function(t) {
  let e = Gse.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
const eae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Od,
  encode: a0,
  format: G4,
  parse: K4
}, Symbol.toStringTag, { value: "Module" })), TN = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, MN = /[\0-\x1F\x7F-\x9F]/, tae = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, X4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, PN = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, RN = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, rae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any: TN,
  Cc: MN,
  Cf: tae,
  P: X4,
  S: PN,
  Z: RN
}, Symbol.toStringTag, { value: "Module" })), nae = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛžÞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿Žã€–ãŠºã˜¹ãž¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ð”„raveè€»Ã€äƒ€pha;äŽ‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ð”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ð’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ð€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;äŽ’r;ì€€ð”…pf;ì€€ð”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰ŽÜ€HOacdefhilorsuÅÅ‘Å–Æ€ÆžÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆŽÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;äŽ§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈžÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉŽ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ð’žpÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„Ž;ä”lÄ€;tËËžæˆ‡a;äŽ”r;ì€€ð”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ð…f;ì€€ð”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïžrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaÐ’ÐªÐ°ÑžÑ¿Í¼rrowÆ€;BUÐÐžÐ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ðº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥žectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ð’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓžÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ð”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ð”¼silon;äŽ•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;äŽ—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ð”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ð”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸äŽ“;äœreve;ä„žÆ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ð”Š;æ‹™pf;ì€€ð”¾eaterÌ€EFGLSTØµÙ„ÙŽÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ð’¢;æ‰«Ð€AacfiosuÚ…Ú‹Ú–Ú›ÚžÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äžirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜŽÜšÜžÜ¡Ü¨Ý„Ý¸Þ‹ÞÞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»ÃŽäƒŽ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´Ý‰\0Ý¢Ä€;eÝÝŽæˆ¬Ä€grÝ“Ý˜ral;æˆ«section;æ‹‚isibleÄ€CTÝ¬Ý²omma;æ£imes;æ¢Æ€gptÝ¿ÞƒÞˆon;ä„®f;ì€€ð•€a;äŽ™cr;æ„ilde;ä„¨Ç«Þš\0Þžcy;ä†lè€»ÃäƒÊ€cfosuÞ¬Þ·Þ¼ß‚ßÄ€iyÞ±Þµrc;ä„´;ä™r;ì€€ð”pf;ì€€ð•Ç£ß‡\0ßŒr;ì€€ð’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äŽšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ð”Žpf;ì€€ð•‚cr;ì€€ð’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;äŽ›g;æŸªlacetrf;æ„’r;æ†žÆ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢žæ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥ŽÄ€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ð”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§žà§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ð•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªÐ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªŽp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ð”nusPlus;æˆ“pf;ì€€ð•„cÃ²à©¶;äŽœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶žcy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ŽativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ð”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±žà²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰ŽÌ¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµŽsetÄ€;Eà´›à´žì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ð’©ildeè€»Ã‘äƒ‘;äŽÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·Žà·“rcè€»Ã”äƒ”;äžblac;ä…r;ì€€ð”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;äŽ©cron;äŽŸpf;ì€€ð•†enCurlyÄ€DQà¸Žà¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ð’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æžet;æŽ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ð”“i;äŽ¦;äŽ usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ð’«;äŽ¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ð””pf;æ„šcr;ì€€ð’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½Žà½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾Žement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;äŽ¡ghtÐ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€žæ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚žf;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„žá…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„Žá„“á„—æª¼ron;ä… dil;ä…žrc;ä…œ;ä¡r;ì€€ð”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ÐžeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;äŽ£allCircle;æˆ˜pf;ì€€ð•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†žsetÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ð’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡Žæ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰žá‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃžäƒžADE;æ„¢Ä€Hcá‰Žá‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;äŽ¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ð”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;äŽ˜Ä€cnáŠŽáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ð•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ð’¯rok;ä…¦à«¡á‹·áŒŽáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·áŽ…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äŽve;ä…¬Ä€iyáŒžáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ð”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æŽµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠŽÄ€gpá»á¿on;ä…²f;ì€€ð•ŒÐ€ADETadpsáŽ•áŽ®áŽ¸á„Ï¨á’á—á³rrowÆ€;BDá…áŽ áŽ¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRážá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;äŽ¥ing;ä…®cr;ì€€ð’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ð”™pf;ì€€ð•cr;ì€€ð’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ð”špf;ì€€ð•Žcr;ì€€ð’²È€fiosá“‹á“á“’á“˜r;ì€€ð”›;äŽžpf;ì€€ð•cr;ì€€ð’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ð”œpf;ì€€ð•cr;ì€€ð’´ml;ä…¸Ð€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;äŽ–r;æ„¨pf;æ„¤cr;ì€€ð’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ð”žraveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;äŽ±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜žá˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ð•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ð’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœžkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æŽ¶Ä€oyáœá;ä±quo;æ€žÊ€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;äŽ²;æ„¶een;æ‰¬r;ì€€ð”ŸgÎ€costuvwážážáž³áŸáŸ•áŸ›áŸžÆ€aiuáž”áž–ážšÃ°Ý rc;æ—¯pÂ»á±Æ€dptáž¤áž¨áž­ot;æ¨€lus;æ¨imes;æ¨‚É±áž¹\0\0áž¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡žá¡§á¡¬f;ì€€ð•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢Žá¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠžimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•ž;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ð’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ð” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«Žä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«žá«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ð•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ð’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹žc;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®žp;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯žá¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯Ž\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹Žedge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²žá²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;äŽ´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ð”¡arÄ€lrá²³á²µÂ»à£œÂ»á€žÊ€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒžop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ð••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶Žrn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ð’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ð©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½Žá½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸Žá¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ð”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ð•–Æ€alsá»„á»Žá»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäŽµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;äŽ·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾ž\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ð”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ð•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0âŽ;æ…š;æ…8;æ…žl;æ„wn;æŒ¢cr;ì€€ð’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†žÄ€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šäŽ³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ð”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„Žâ„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ð•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…Žâ…;æªŽ;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†ŽproÃ¸â‚žr;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆŽâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ð”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰žâ‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ð•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ð’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹Ž\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0âŽ†âŽªâŽ´cuteè€»Ã­äƒ­Æ€;iyÝ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ð”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ÞŽarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆžie;æ§doÃ´âŒ™Ê€;celpÝ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ð•ša;äŽ¹uestè€»Â¿ä‚¿Ä€ciâŽŠâŽr;ì€€ð’¾nÊ€;EdsvÓ´âŽ›âŽâŽ¡Ó³;æ‹¹ot;æ‹µÄ€;vâŽ¦âŽ§æ‹´;æ‹³Ä€;iÝ·âŽ®lde;ä„©Ç«âŽ¸\0âŽ¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ð”§ath;äˆ·pf;ì€€ð•›Ç£â¬\0â±r;ì€€ð’¿rcy;ä‘˜kcy;ä‘”Ð€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äŽº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ð”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ð•œcr;ì€€ð“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”Žâ”½â•šâ–€â™Žâ™žâ™¥â™¹â™½âššâš²â›˜ââ¨âž‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤ŽÄ€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;äŽ»gÆ€;dlà¢Žâ“â“ƒ;æ¦‘Ã¥à¢Ž;æª…uoè€»Â«ä‚«rÐ€;bfhlpstà¢™â“žâ“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—žrrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ð”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æŽ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›Žâ›æª‡Ä€;qâ›Žâš»im;æ‹¦Ð€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ð•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áŽÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼âž…âž‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âžƒ;æ¥­;æ€Žri;æŠ¿Ì€achiqtâž˜âžà©€âž¢âž®âž»quo;æ€¹r;ì€€ð“mÆ€;egà¦²âžªâž¬;æª;æªÄ€buâ”ªâž³oÄ€;rà¸Ÿâž¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â žÜ€Dacdefhilnopsuâ¡€â¡…â¢‚â¢Žâ¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡Žâ¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡žâ¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ð”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£žâ£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ð•žÄ€ctâ£¸â£½r;ì€€ð“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤äŽ¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡Ž;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦Žâ¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëžute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©Žar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ð”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«Žâ«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ð•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ð“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­äŽ½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²žâ²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§žÆ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·Ž\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªžâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ð”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;äŽ¿;æ¦¶pf;ì€€ð• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹ž\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astÐƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ÐƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ð”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜ŽÆ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„ŽÃ¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼Žä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ð•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»Žâ½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»ŽÆ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ð“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ð”®pf;ì€€ð•¢rime;æ—cr;ì€€ð“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„Žã„«ã…‡ã…¢ã…²ã†Žãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤žÃ«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼žÆ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦Ž;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈŽÈh;æ†³Æ€acgã…Žã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ð”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆžãˆŸæŽ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰Žr;æ¦†;ì€€ð•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ð“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§Žluhar;æ¥¨;æ„žàµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºãŽ¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âžºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãžã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ð”°È€acoyãŽ‚ãŽ†ãŽ‘ãŽ rp;æ™¯Ä€hyãŽ‹ãŽcy;ä‘‰;ä‘ˆrtÉ­ãŽ™\0\0ãŽœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmãŽ¨ãŽ´maÆ€;fvãŽ±ãŽ²ãŽ²äƒ;ä‚Ð€;deglnpráŠ«ã…ã‰ãŽã–ãžã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æªž;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ð•¤aÄ€drã‘Ð‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ð“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“Žã“•rÄ€;fã“”áž¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•žáˆ‰ã–‹ã–ŽÒ€;Edemnprsã”Žã”ã”‘ã”•ã”žã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”Žã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹Žã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ãž‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ð”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›äŽ¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠžÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ð•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãžÄ€ryã·ã»;ì€€ð“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioãž‹ãžŽxÃ´á·headÄ€lrãž—ãž eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã Žã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘žve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²áŽ­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ð”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ð•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡áŽ³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒŽng;ä…¯ri;æ—¹cr;ì€€ð“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Þ€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;háŽ·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ãŽ³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ð”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ð•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ð“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨žÂ»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ð”´pf;ì€€ð•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ð“Œà«£ážŽãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«Ž\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ð”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;äŽ¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptáž¤ãªµãª¾Ä€flãªºáž©;ì€€ð•©imÃ¥áž²Ä€Aaã«‡ã«ŠrÃ²ÏŽrÃ²à¨Ä€cqã«’áž¸r;ì€€ð“Ä€ptáŸ–ã«œrÃ©áŸ”Ð€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ð”¶cy;ä‘—pf;ì€€ð•ªcr;ì€€ð“ŽÄ€cmã¬¦ã¬©y;ä‘Žlè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;äŽ¶r;ì€€ð”·cy;ä¶grarr;æ‡pf;ì€€ð•«cr;ì€€ð“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((t) => t.charCodeAt(0))
), iae = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((t) => t.charCodeAt(0))
);
var X2;
const oae = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), sae = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (X2 = String.fromCodePoint) !== null && X2 !== void 0 ? X2 : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function aae(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = oae.get(t)) !== null && e !== void 0 ? e : t;
}
var Ln;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(Ln || (Ln = {}));
const lae = 32;
var Iu;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Iu || (Iu = {}));
function _C(t) {
  return t >= Ln.ZERO && t <= Ln.NINE;
}
function uae(t) {
  return t >= Ln.UPPER_A && t <= Ln.UPPER_F || t >= Ln.LOWER_A && t <= Ln.LOWER_F;
}
function cae(t) {
  return t >= Ln.UPPER_A && t <= Ln.UPPER_Z || t >= Ln.LOWER_A && t <= Ln.LOWER_Z || _C(t);
}
function hae(t) {
  return t === Ln.EQUALS || cae(t);
}
var Pn;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(Pn || (Pn = {}));
var Tu;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(Tu || (Tu = {}));
class fae {
  constructor(e, r, n) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = n, this.state = Pn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Tu.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = Pn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case Pn.EntityStart:
        return e.charCodeAt(r) === Ln.NUM ? (this.state = Pn.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = Pn.NamedEntity, this.stateNamedEntity(e, r));
      case Pn.NumericStart:
        return this.stateNumericStart(e, r);
      case Pn.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case Pn.NumericHex:
        return this.stateNumericHex(e, r);
      case Pn.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | lae) === Ln.LOWER_X ? (this.state = Pn.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = Pn.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, n, i) {
    if (r !== n) {
      const o = n - r;
      this.result = this.result * Math.pow(i, o) + parseInt(e.substr(r, o), i), this.consumed += o;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (_C(i) || uae(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, n, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (_C(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, n, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var n;
    if (this.consumed <= r)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === Ln.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Tu.Strict)
      return 0;
    return this.emitCodePoint(aae(this.result), this.consumed), this.errors && (e !== Ln.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: n } = this;
    let i = n[this.treeIndex], o = (i & Iu.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const s = e.charCodeAt(r);
      if (this.treeIndex = dae(n, i, this.treeIndex + Math.max(1, o), s), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Tu.Attribute && // We shouldn't have consumed any characters after the entity,
        (o === 0 || // And there should be no invalid characters.
        hae(s)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = n[this.treeIndex], o = (i & Iu.VALUE_LENGTH) >> 14, o !== 0) {
        if (s === Ln.SEMI)
          return this.emitNamedEntityData(this.treeIndex, o, this.consumed + this.excess);
        this.decodeMode !== Tu.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: n } = this, i = (n[r] & Iu.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, n) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(r === 1 ? i[e] & ~Iu.VALUE_LENGTH : i[e + 1], n), r === 3 && this.emitCodePoint(i[e + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case Pn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Tu.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case Pn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Pn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Pn.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Pn.EntityStart:
        return 0;
    }
  }
}
function NN(t) {
  let e = "";
  const r = new fae(t, (n) => e += sae(n));
  return function(n, i) {
    let o = 0, s = 0;
    for (; (s = n.indexOf("&", s)) >= 0; ) {
      e += n.slice(o, s), r.startEntity(i);
      const l = r.write(
        n,
        // Skip the "&"
        s + 1
      );
      if (l < 0) {
        o = s + r.end();
        break;
      }
      o = s + l, s = l === 0 ? o + 1 : o;
    }
    const a = e + n.slice(o);
    return e = "", a;
  };
}
function dae(t, e, r, n) {
  const i = (e & Iu.BRANCH_LENGTH) >> 7, o = e & Iu.JUMP_TABLE;
  if (i === 0)
    return o !== 0 && n === o ? r : -1;
  if (o) {
    const l = n - o;
    return l < 0 || l >= i ? -1 : t[r + l] - 1;
  }
  let s = r, a = s + i - 1;
  for (; s <= a; ) {
    const l = s + a >>> 1, u = t[l];
    if (u < n)
      s = l + 1;
    else if (u > n)
      a = l - 1;
    else
      return t[l + i];
  }
  return -1;
}
const pae = NN(nae);
NN(iae);
function $N(t, e = Tu.Legacy) {
  return pae(t, e);
}
function mae(t) {
  return Object.prototype.toString.call(t);
}
function Q4(t) {
  return mae(t) === "[object String]";
}
const gae = Object.prototype.hasOwnProperty;
function vae(t, e) {
  return gae.call(t, e);
}
function Qb(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    if (e) {
      if (typeof e != "object")
        throw new TypeError(e + "must be object");
      Object.keys(e).forEach(function(r) {
        t[r] = e[r];
      });
    }
  }), t;
}
function IN(t, e, r) {
  return [].concat(t.slice(0, e), r, t.slice(e + 1));
}
function J4(t) {
  return !(t >= 55296 && t <= 57343 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534 || t >= 0 && t <= 8 || t === 11 || t >= 14 && t <= 31 || t >= 127 && t <= 159 || t > 1114111);
}
function L1(t) {
  if (t > 65535) {
    t -= 65536;
    const e = 55296 + (t >> 10), r = 56320 + (t & 1023);
    return String.fromCharCode(e, r);
  }
  return String.fromCharCode(t);
}
const BN = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, yae = /&([a-z#][a-z0-9]{1,31});/gi, bae = new RegExp(BN.source + "|" + yae.source, "gi"), xae = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function wae(t, e) {
  if (e.charCodeAt(0) === 35 && xae.test(e)) {
    const n = e[1].toLowerCase() === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10);
    return J4(n) ? L1(n) : t;
  }
  const r = $N(t);
  return r !== t ? r : t;
}
function kae(t) {
  return t.indexOf("\\") < 0 ? t : t.replace(BN, "$1");
}
function Fd(t) {
  return t.indexOf("\\") < 0 && t.indexOf("&") < 0 ? t : t.replace(bae, function(e, r, n) {
    return r || wae(e, n);
  });
}
const Cae = /[&<>"]/, _ae = /[&<>"]/g, Sae = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function Aae(t) {
  return Sae[t];
}
function uc(t) {
  return Cae.test(t) ? t.replace(_ae, Aae) : t;
}
const Eae = /[.?*+^$[\]\\(){}|-]/g;
function Dae(t) {
  return t.replace(Eae, "\\$&");
}
function Nr(t) {
  switch (t) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function bg(t) {
  if (t >= 8192 && t <= 8202)
    return !0;
  switch (t) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function xg(t) {
  return X4.test(t) || PN.test(t);
}
function wg(t) {
  switch (t) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function Jb(t) {
  return t = t.trim().replace(/\s+/g, " "), "áºž".toLowerCase() === "á¹¾" && (t = t.replace(/áºž/g, "ÃŸ")), t.toLowerCase().toUpperCase();
}
const Oae = { mdurl: eae, ucmicro: rae }, Fae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: IN,
  assign: Qb,
  escapeHtml: uc,
  escapeRE: Dae,
  fromCodePoint: L1,
  has: vae,
  isMdAsciiPunct: wg,
  isPunctChar: xg,
  isSpace: Nr,
  isString: Q4,
  isValidEntityCode: J4,
  isWhiteSpace: bg,
  lib: Oae,
  normalizeReference: Jb,
  unescapeAll: Fd,
  unescapeMd: kae
}, Symbol.toStringTag, { value: "Module" }));
function Tae(t, e, r) {
  let n, i, o, s;
  const a = t.posMax, l = t.pos;
  for (t.pos = e + 1, n = 1; t.pos < a; ) {
    if (o = t.src.charCodeAt(t.pos), o === 93 && (n--, n === 0)) {
      i = !0;
      break;
    }
    if (s = t.pos, t.md.inline.skipToken(t), o === 91) {
      if (s === t.pos - 1)
        n++;
      else if (r)
        return t.pos = l, -1;
    }
  }
  let u = -1;
  return i && (u = t.pos), t.pos = l, u;
}
function Mae(t, e, r) {
  let n, i = e;
  const o = {
    ok: !1,
    pos: 0,
    str: ""
  };
  if (t.charCodeAt(i) === 60) {
    for (i++; i < r; ) {
      if (n = t.charCodeAt(i), n === 10 || n === 60)
        return o;
      if (n === 62)
        return o.pos = i + 1, o.str = Fd(t.slice(e + 1, i)), o.ok = !0, o;
      if (n === 92 && i + 1 < r) {
        i += 2;
        continue;
      }
      i++;
    }
    return o;
  }
  let s = 0;
  for (; i < r && (n = t.charCodeAt(i), !(n === 32 || n < 32 || n === 127)); ) {
    if (n === 92 && i + 1 < r) {
      if (t.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (n === 40 && (s++, s > 32))
      return o;
    if (n === 41) {
      if (s === 0)
        break;
      s--;
    }
    i++;
  }
  return e === i || s !== 0 || (o.str = Fd(t.slice(e, i)), o.pos = i, o.ok = !0), o;
}
function Pae(t, e, r, n) {
  let i, o = e;
  const s = {
    // if `true`, this is a valid link title
    ok: !1,
    // if `true`, this link can be continued on the next line
    can_continue: !1,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (n)
    s.str = n.str, s.marker = n.marker;
  else {
    if (o >= r)
      return s;
    let a = t.charCodeAt(o);
    if (a !== 34 && a !== 39 && a !== 40)
      return s;
    e++, o++, a === 40 && (a = 41), s.marker = a;
  }
  for (; o < r; ) {
    if (i = t.charCodeAt(o), i === s.marker)
      return s.pos = o + 1, s.str += Fd(t.slice(e, o)), s.ok = !0, s;
    if (i === 40 && s.marker === 41)
      return s;
    i === 92 && o + 1 < r && o++, o++;
  }
  return s.can_continue = !0, s.str += Fd(t.slice(e, o)), s;
}
const Rae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination: Mae,
  parseLinkLabel: Tae,
  parseLinkTitle: Pae
}, Symbol.toStringTag, { value: "Module" })), ll = {};
ll.code_inline = function(t, e, r, n, i) {
  const o = t[e];
  return "<code" + i.renderAttrs(o) + ">" + uc(o.content) + "</code>";
};
ll.code_block = function(t, e, r, n, i) {
  const o = t[e];
  return "<pre" + i.renderAttrs(o) + "><code>" + uc(t[e].content) + `</code></pre>
`;
};
ll.fence = function(t, e, r, n, i) {
  const o = t[e], s = o.info ? Fd(o.info).trim() : "";
  let a = "", l = "";
  if (s) {
    const c = s.split(/(\s+)/g);
    a = c[0], l = c.slice(2).join("");
  }
  let u;
  if (r.highlight ? u = r.highlight(o.content, a, l) || uc(o.content) : u = uc(o.content), u.indexOf("<pre") === 0)
    return u + `
`;
  if (s) {
    const c = o.attrIndex("class"), h = o.attrs ? o.attrs.slice() : [];
    c < 0 ? h.push(["class", r.langPrefix + a]) : (h[c] = h[c].slice(), h[c][1] += " " + r.langPrefix + a);
    const d = {
      attrs: h
    };
    return `<pre><code${i.renderAttrs(d)}>${u}</code></pre>
`;
  }
  return `<pre><code${i.renderAttrs(o)}>${u}</code></pre>
`;
};
ll.image = function(t, e, r, n, i) {
  const o = t[e];
  return o.attrs[o.attrIndex("alt")][1] = i.renderInlineAsText(o.children, r, n), i.renderToken(t, e, r);
};
ll.hardbreak = function(t, e, r) {
  return r.xhtmlOut ? `<br />
` : `<br>
`;
};
ll.softbreak = function(t, e, r) {
  return r.breaks ? r.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ll.text = function(t, e) {
  return uc(t[e].content);
};
ll.html_block = function(t, e) {
  return t[e].content;
};
ll.html_inline = function(t, e) {
  return t[e].content;
};
function rp() {
  this.rules = Qb({}, ll);
}
rp.prototype.renderAttrs = function(t) {
  let e, r, n;
  if (!t.attrs)
    return "";
  for (n = "", e = 0, r = t.attrs.length; e < r; e++)
    n += " " + uc(t.attrs[e][0]) + '="' + uc(t.attrs[e][1]) + '"';
  return n;
};
rp.prototype.renderToken = function(t, e, r) {
  const n = t[e];
  let i = "";
  if (n.hidden)
    return "";
  n.block && n.nesting !== -1 && e && t[e - 1].hidden && (i += `
`), i += (n.nesting === -1 ? "</" : "<") + n.tag, i += this.renderAttrs(n), n.nesting === 0 && r.xhtmlOut && (i += " /");
  let o = !1;
  if (n.block && (o = !0, n.nesting === 1 && e + 1 < t.length)) {
    const s = t[e + 1];
    (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === n.tag) && (o = !1);
  }
  return i += o ? `>
` : ">", i;
};
rp.prototype.renderInline = function(t, e, r) {
  let n = "";
  const i = this.rules;
  for (let o = 0, s = t.length; o < s; o++) {
    const a = t[o].type;
    typeof i[a] < "u" ? n += i[a](t, o, e, r, this) : n += this.renderToken(t, o, e);
  }
  return n;
};
rp.prototype.renderInlineAsText = function(t, e, r) {
  let n = "";
  for (let i = 0, o = t.length; i < o; i++)
    switch (t[i].type) {
      case "text":
        n += t[i].content;
        break;
      case "image":
        n += this.renderInlineAsText(t[i].children, e, r);
        break;
      case "html_inline":
      case "html_block":
        n += t[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        n += `
`;
        break;
    }
  return n;
};
rp.prototype.render = function(t, e, r) {
  let n = "";
  const i = this.rules;
  for (let o = 0, s = t.length; o < s; o++) {
    const a = t[o].type;
    a === "inline" ? n += this.renderInline(t[o].children, e, r) : typeof i[a] < "u" ? n += i[a](t, o, e, r, this) : n += this.renderToken(t, o, e, r);
  }
  return n;
};
function ho() {
  this.__rules__ = [], this.__cache__ = null;
}
ho.prototype.__find__ = function(t) {
  for (let e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t)
      return e;
  return -1;
};
ho.prototype.__compile__ = function() {
  const t = this, e = [""];
  t.__rules__.forEach(function(r) {
    r.enabled && r.alt.forEach(function(n) {
      e.indexOf(n) < 0 && e.push(n);
    });
  }), t.__cache__ = {}, e.forEach(function(r) {
    t.__cache__[r] = [], t.__rules__.forEach(function(n) {
      n.enabled && (r && n.alt.indexOf(r) < 0 || t.__cache__[r].push(n.fn));
    });
  });
};
ho.prototype.at = function(t, e, r) {
  const n = this.__find__(t), i = r || {};
  if (n === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__[n].fn = e, this.__rules__[n].alt = i.alt || [], this.__cache__ = null;
};
ho.prototype.before = function(t, e, r, n) {
  const i = this.__find__(t), o = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i, 0, {
    name: e,
    enabled: !0,
    fn: r,
    alt: o.alt || []
  }), this.__cache__ = null;
};
ho.prototype.after = function(t, e, r, n) {
  const i = this.__find__(t), o = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i + 1, 0, {
    name: e,
    enabled: !0,
    fn: r,
    alt: o.alt || []
  }), this.__cache__ = null;
};
ho.prototype.push = function(t, e, r) {
  const n = r || {};
  this.__rules__.push({
    name: t,
    enabled: !0,
    fn: e,
    alt: n.alt || []
  }), this.__cache__ = null;
};
ho.prototype.enable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const r = [];
  return t.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = !0, r.push(n);
  }, this), this.__cache__ = null, r;
};
ho.prototype.enableOnly = function(t, e) {
  Array.isArray(t) || (t = [t]), this.__rules__.forEach(function(r) {
    r.enabled = !1;
  }), this.enable(t, e);
};
ho.prototype.disable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const r = [];
  return t.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = !1, r.push(n);
  }, this), this.__cache__ = null, r;
};
ho.prototype.getRules = function(t) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [];
};
function aa(t, e, r) {
  this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = r, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
aa.prototype.attrIndex = function(t) {
  if (!this.attrs)
    return -1;
  const e = this.attrs;
  for (let r = 0, n = e.length; r < n; r++)
    if (e[r][0] === t)
      return r;
  return -1;
};
aa.prototype.attrPush = function(t) {
  this.attrs ? this.attrs.push(t) : this.attrs = [t];
};
aa.prototype.attrSet = function(t, e) {
  const r = this.attrIndex(t), n = [t, e];
  r < 0 ? this.attrPush(n) : this.attrs[r] = n;
};
aa.prototype.attrGet = function(t) {
  const e = this.attrIndex(t);
  let r = null;
  return e >= 0 && (r = this.attrs[e][1]), r;
};
aa.prototype.attrJoin = function(t, e) {
  const r = this.attrIndex(t);
  r < 0 ? this.attrPush([t, e]) : this.attrs[r][1] = this.attrs[r][1] + " " + e;
};
function LN(t, e, r) {
  this.src = t, this.env = r, this.tokens = [], this.inlineMode = !1, this.md = e;
}
LN.prototype.Token = aa;
const Nae = /\r\n?|\n/g, $ae = /\0/g;
function Iae(t) {
  let e;
  e = t.src.replace(Nae, `
`), e = e.replace($ae, "ï¿½"), t.src = e;
}
function Bae(t) {
  let e;
  t.inlineMode ? (e = new t.Token("inline", "", 0), e.content = t.src, e.map = [0, 1], e.children = [], t.tokens.push(e)) : t.md.block.parse(t.src, t.md, t.env, t.tokens);
}
function Lae(t) {
  const e = t.tokens;
  for (let r = 0, n = e.length; r < n; r++) {
    const i = e[r];
    i.type === "inline" && t.md.inline.parse(i.content, t.md, t.env, i.children);
  }
}
function zae(t) {
  return /^<a[>\s]/i.test(t);
}
function jae(t) {
  return /^<\/a\s*>/i.test(t);
}
function qae(t) {
  const e = t.tokens;
  if (t.md.options.linkify)
    for (let r = 0, n = e.length; r < n; r++) {
      if (e[r].type !== "inline" || !t.md.linkify.pretest(e[r].content))
        continue;
      let i = e[r].children, o = 0;
      for (let s = i.length - 1; s >= 0; s--) {
        const a = i[s];
        if (a.type === "link_close") {
          for (s--; i[s].level !== a.level && i[s].type !== "link_open"; )
            s--;
          continue;
        }
        if (a.type === "html_inline" && (zae(a.content) && o > 0 && o--, jae(a.content) && o++), !(o > 0) && a.type === "text" && t.md.linkify.test(a.content)) {
          const l = a.content;
          let u = t.md.linkify.match(l);
          const c = [];
          let h = a.level, d = 0;
          u.length > 0 && u[0].index === 0 && s > 0 && i[s - 1].type === "text_special" && (u = u.slice(1));
          for (let p = 0; p < u.length; p++) {
            const g = u[p].url, v = t.md.normalizeLink(g);
            if (!t.md.validateLink(v))
              continue;
            let y = u[p].text;
            u[p].schema ? u[p].schema === "mailto:" && !/^mailto:/i.test(y) ? y = t.md.normalizeLinkText("mailto:" + y).replace(/^mailto:/, "") : y = t.md.normalizeLinkText(y) : y = t.md.normalizeLinkText("http://" + y).replace(/^http:\/\//, "");
            const b = u[p].index;
            if (b > d) {
              const _ = new t.Token("text", "", 0);
              _.content = l.slice(d, b), _.level = h, c.push(_);
            }
            const k = new t.Token("link_open", "a", 1);
            k.attrs = [["href", v]], k.level = h++, k.markup = "linkify", k.info = "auto", c.push(k);
            const C = new t.Token("text", "", 0);
            C.content = y, C.level = h, c.push(C);
            const S = new t.Token("link_close", "a", -1);
            S.level = --h, S.markup = "linkify", S.info = "auto", c.push(S), d = u[p].lastIndex;
          }
          if (d < l.length) {
            const p = new t.Token("text", "", 0);
            p.content = l.slice(d), p.level = h, c.push(p);
          }
          e[r].children = i = IN(i, s, c);
        }
      }
    }
}
const zN = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, Uae = /\((c|tm|r)\)/i, Hae = /\((c|tm|r)\)/ig, Vae = {
  c: "Â©",
  r: "Â®",
  tm: "â„¢"
};
function Wae(t, e) {
  return Vae[e.toLowerCase()];
}
function Gae(t) {
  let e = 0;
  for (let r = t.length - 1; r >= 0; r--) {
    const n = t[r];
    n.type === "text" && !e && (n.content = n.content.replace(Hae, Wae)), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function Kae(t) {
  let e = 0;
  for (let r = t.length - 1; r >= 0; r--) {
    const n = t[r];
    n.type === "text" && !e && zN.test(n.content) && (n.content = n.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“")), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function Xae(t) {
  let e;
  if (t.md.options.typographer)
    for (e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type === "inline" && (Uae.test(t.tokens[e].content) && Gae(t.tokens[e].children), zN.test(t.tokens[e].content) && Kae(t.tokens[e].children));
}
const Qae = /['"]/, v7 = /['"]/g, y7 = "â€™";
function Zv(t, e, r) {
  return t.slice(0, e) + r + t.slice(e + 1);
}
function Jae(t, e) {
  let r;
  const n = [];
  for (let i = 0; i < t.length; i++) {
    const o = t[i], s = t[i].level;
    for (r = n.length - 1; r >= 0 && !(n[r].level <= s); r--)
      ;
    if (n.length = r + 1, o.type !== "text")
      continue;
    let a = o.content, l = 0, u = a.length;
    e:
      for (; l < u; ) {
        v7.lastIndex = l;
        const c = v7.exec(a);
        if (!c)
          break;
        let h = !0, d = !0;
        l = c.index + 1;
        const p = c[0] === "'";
        let g = 32;
        if (c.index - 1 >= 0)
          g = a.charCodeAt(c.index - 1);
        else
          for (r = i - 1; r >= 0 && !(t[r].type === "softbreak" || t[r].type === "hardbreak"); r--)
            if (t[r].content) {
              g = t[r].content.charCodeAt(t[r].content.length - 1);
              break;
            }
        let v = 32;
        if (l < u)
          v = a.charCodeAt(l);
        else
          for (r = i + 1; r < t.length && !(t[r].type === "softbreak" || t[r].type === "hardbreak"); r++)
            if (t[r].content) {
              v = t[r].content.charCodeAt(0);
              break;
            }
        const y = wg(g) || xg(String.fromCharCode(g)), b = wg(v) || xg(String.fromCharCode(v)), k = bg(g), C = bg(v);
        if (C ? h = !1 : b && (k || y || (h = !1)), k ? d = !1 : y && (C || b || (d = !1)), v === 34 && c[0] === '"' && g >= 48 && g <= 57 && (d = h = !1), h && d && (h = y, d = b), !h && !d) {
          p && (o.content = Zv(o.content, c.index, y7));
          continue;
        }
        if (d)
          for (r = n.length - 1; r >= 0; r--) {
            let S = n[r];
            if (n[r].level < s)
              break;
            if (S.single === p && n[r].level === s) {
              S = n[r];
              let _, D;
              p ? (_ = e.md.options.quotes[2], D = e.md.options.quotes[3]) : (_ = e.md.options.quotes[0], D = e.md.options.quotes[1]), o.content = Zv(o.content, c.index, D), t[S.token].content = Zv(
                t[S.token].content,
                S.pos,
                _
              ), l += D.length - 1, S.token === i && (l += _.length - 1), a = o.content, u = a.length, n.length = r;
              continue e;
            }
          }
        h ? n.push({
          token: i,
          pos: c.index,
          single: p,
          level: s
        }) : d && p && (o.content = Zv(o.content, c.index, y7));
      }
  }
}
function Yae(t) {
  if (t.md.options.typographer)
    for (let e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type !== "inline" || !Qae.test(t.tokens[e].content) || Jae(t.tokens[e].children, t);
}
function Zae(t) {
  let e, r;
  const n = t.tokens, i = n.length;
  for (let o = 0; o < i; o++) {
    if (n[o].type !== "inline") continue;
    const s = n[o].children, a = s.length;
    for (e = 0; e < a; e++)
      s[e].type === "text_special" && (s[e].type = "text");
    for (e = r = 0; e < a; e++)
      s[e].type === "text" && e + 1 < a && s[e + 1].type === "text" ? s[e + 1].content = s[e].content + s[e + 1].content : (e !== r && (s[r] = s[e]), r++);
    e !== r && (s.length = r);
  }
}
const Q2 = [
  ["normalize", Iae],
  ["block", Bae],
  ["inline", Lae],
  ["linkify", qae],
  ["replacements", Xae],
  ["smartquotes", Yae],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", Zae]
];
function Y4() {
  this.ruler = new ho();
  for (let t = 0; t < Q2.length; t++)
    this.ruler.push(Q2[t][0], Q2[t][1]);
}
Y4.prototype.process = function(t) {
  const e = this.ruler.getRules("");
  for (let r = 0, n = e.length; r < n; r++)
    e[r](t);
};
Y4.prototype.State = LN;
function ul(t, e, r, n) {
  this.src = t, this.md = e, this.env = r, this.tokens = n, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const i = this.src;
  for (let o = 0, s = 0, a = 0, l = 0, u = i.length, c = !1; s < u; s++) {
    const h = i.charCodeAt(s);
    if (!c)
      if (Nr(h)) {
        a++, h === 9 ? l += 4 - l % 4 : l++;
        continue;
      } else
        c = !0;
    (h === 10 || s === u - 1) && (h !== 10 && s++, this.bMarks.push(o), this.eMarks.push(s), this.tShift.push(a), this.sCount.push(l), this.bsCount.push(0), c = !1, a = 0, l = 0, o = s + 1);
  }
  this.bMarks.push(i.length), this.eMarks.push(i.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
ul.prototype.push = function(t, e, r) {
  const n = new aa(t, e, r);
  return n.block = !0, r < 0 && this.level--, n.level = this.level, r > 0 && this.level++, this.tokens.push(n), n;
};
ul.prototype.isEmpty = function(t) {
  return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
};
ul.prototype.skipEmptyLines = function(t) {
  for (let e = this.lineMax; t < e && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
    ;
  return t;
};
ul.prototype.skipSpaces = function(t) {
  for (let e = this.src.length; t < e; t++) {
    const r = this.src.charCodeAt(t);
    if (!Nr(r))
      break;
  }
  return t;
};
ul.prototype.skipSpacesBack = function(t, e) {
  if (t <= e)
    return t;
  for (; t > e; )
    if (!Nr(this.src.charCodeAt(--t)))
      return t + 1;
  return t;
};
ul.prototype.skipChars = function(t, e) {
  for (let r = this.src.length; t < r && this.src.charCodeAt(t) === e; t++)
    ;
  return t;
};
ul.prototype.skipCharsBack = function(t, e, r) {
  if (t <= r)
    return t;
  for (; t > r; )
    if (e !== this.src.charCodeAt(--t))
      return t + 1;
  return t;
};
ul.prototype.getLines = function(t, e, r, n) {
  if (t >= e)
    return "";
  const i = new Array(e - t);
  for (let o = 0, s = t; s < e; s++, o++) {
    let a = 0;
    const l = this.bMarks[s];
    let u = l, c;
    for (s + 1 < e || n ? c = this.eMarks[s] + 1 : c = this.eMarks[s]; u < c && a < r; ) {
      const h = this.src.charCodeAt(u);
      if (Nr(h))
        h === 9 ? a += 4 - (a + this.bsCount[s]) % 4 : a++;
      else if (u - l < this.tShift[s])
        a++;
      else
        break;
      u++;
    }
    a > r ? i[o] = new Array(a - r + 1).join(" ") + this.src.slice(u, c) : i[o] = this.src.slice(u, c);
  }
  return i.join("");
};
ul.prototype.Token = aa;
const ele = 65536;
function J2(t, e) {
  const r = t.bMarks[e] + t.tShift[e], n = t.eMarks[e];
  return t.src.slice(r, n);
}
function b7(t) {
  const e = [], r = t.length;
  let n = 0, i = t.charCodeAt(n), o = !1, s = 0, a = "";
  for (; n < r; )
    i === 124 && (o ? (a += t.substring(s, n - 1), s = n) : (e.push(a + t.substring(s, n)), a = "", s = n + 1)), o = i === 92, n++, i = t.charCodeAt(n);
  return e.push(a + t.substring(s)), e;
}
function tle(t, e, r, n) {
  if (e + 2 > r)
    return !1;
  let i = e + 1;
  if (t.sCount[i] < t.blkIndent || t.sCount[i] - t.blkIndent >= 4)
    return !1;
  let o = t.bMarks[i] + t.tShift[i];
  if (o >= t.eMarks[i])
    return !1;
  const s = t.src.charCodeAt(o++);
  if (s !== 124 && s !== 45 && s !== 58 || o >= t.eMarks[i])
    return !1;
  const a = t.src.charCodeAt(o++);
  if (a !== 124 && a !== 45 && a !== 58 && !Nr(a) || s === 45 && Nr(a))
    return !1;
  for (; o < t.eMarks[i]; ) {
    const S = t.src.charCodeAt(o);
    if (S !== 124 && S !== 45 && S !== 58 && !Nr(S))
      return !1;
    o++;
  }
  let l = J2(t, e + 1), u = l.split("|");
  const c = [];
  for (let S = 0; S < u.length; S++) {
    const _ = u[S].trim();
    if (!_) {
      if (S === 0 || S === u.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(_))
      return !1;
    _.charCodeAt(_.length - 1) === 58 ? c.push(_.charCodeAt(0) === 58 ? "center" : "right") : _.charCodeAt(0) === 58 ? c.push("left") : c.push("");
  }
  if (l = J2(t, e).trim(), l.indexOf("|") === -1 || t.sCount[e] - t.blkIndent >= 4)
    return !1;
  u = b7(l), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop();
  const h = u.length;
  if (h === 0 || h !== c.length)
    return !1;
  if (n)
    return !0;
  const d = t.parentType;
  t.parentType = "table";
  const p = t.md.block.ruler.getRules("blockquote"), g = t.push("table_open", "table", 1), v = [e, 0];
  g.map = v;
  const y = t.push("thead_open", "thead", 1);
  y.map = [e, e + 1];
  const b = t.push("tr_open", "tr", 1);
  b.map = [e, e + 1];
  for (let S = 0; S < u.length; S++) {
    const _ = t.push("th_open", "th", 1);
    c[S] && (_.attrs = [["style", "text-align:" + c[S]]]);
    const D = t.push("inline", "", 0);
    D.content = u[S].trim(), D.children = [], t.push("th_close", "th", -1);
  }
  t.push("tr_close", "tr", -1), t.push("thead_close", "thead", -1);
  let k, C = 0;
  for (i = e + 2; i < r && !(t.sCount[i] < t.blkIndent); i++) {
    let S = !1;
    for (let D = 0, A = p.length; D < A; D++)
      if (p[D](t, i, r, !0)) {
        S = !0;
        break;
      }
    if (S || (l = J2(t, i).trim(), !l) || t.sCount[i] - t.blkIndent >= 4 || (u = b7(l), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), C += h - u.length, C > ele))
      break;
    if (i === e + 2) {
      const D = t.push("tbody_open", "tbody", 1);
      D.map = k = [e + 2, 0];
    }
    const _ = t.push("tr_open", "tr", 1);
    _.map = [i, i + 1];
    for (let D = 0; D < h; D++) {
      const A = t.push("td_open", "td", 1);
      c[D] && (A.attrs = [["style", "text-align:" + c[D]]]);
      const O = t.push("inline", "", 0);
      O.content = u[D] ? u[D].trim() : "", O.children = [], t.push("td_close", "td", -1);
    }
    t.push("tr_close", "tr", -1);
  }
  return k && (t.push("tbody_close", "tbody", -1), k[1] = i), t.push("table_close", "table", -1), v[1] = i, t.parentType = d, t.line = i, !0;
}
function rle(t, e, r) {
  if (t.sCount[e] - t.blkIndent < 4)
    return !1;
  let n = e + 1, i = n;
  for (; n < r; ) {
    if (t.isEmpty(n)) {
      n++;
      continue;
    }
    if (t.sCount[n] - t.blkIndent >= 4) {
      n++, i = n;
      continue;
    }
    break;
  }
  t.line = i;
  const o = t.push("code_block", "code", 0);
  return o.content = t.getLines(e, i, 4 + t.blkIndent, !1) + `
`, o.map = [e, t.line], !0;
}
function nle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || i + 3 > o)
    return !1;
  const s = t.src.charCodeAt(i);
  if (s !== 126 && s !== 96)
    return !1;
  let a = i;
  i = t.skipChars(i, s);
  let l = i - a;
  if (l < 3)
    return !1;
  const u = t.src.slice(a, i), c = t.src.slice(i, o);
  if (s === 96 && c.indexOf(String.fromCharCode(s)) >= 0)
    return !1;
  if (n)
    return !0;
  let h = e, d = !1;
  for (; h++, !(h >= r || (i = a = t.bMarks[h] + t.tShift[h], o = t.eMarks[h], i < o && t.sCount[h] < t.blkIndent)); )
    if (t.src.charCodeAt(i) === s && !(t.sCount[h] - t.blkIndent >= 4) && (i = t.skipChars(i, s), !(i - a < l) && (i = t.skipSpaces(i), !(i < o)))) {
      d = !0;
      break;
    }
  l = t.sCount[e], t.line = h + (d ? 1 : 0);
  const p = t.push("fence", "code", 0);
  return p.info = c, p.content = t.getLines(e + 1, h, l, !0), p.markup = u, p.map = [e, t.line], !0;
}
function ile(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  const s = t.lineMax;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 62)
    return !1;
  if (n)
    return !0;
  const a = [], l = [], u = [], c = [], h = t.md.block.ruler.getRules("blockquote"), d = t.parentType;
  t.parentType = "blockquote";
  let p = !1, g;
  for (g = e; g < r; g++) {
    const C = t.sCount[g] < t.blkIndent;
    if (i = t.bMarks[g] + t.tShift[g], o = t.eMarks[g], i >= o)
      break;
    if (t.src.charCodeAt(i++) === 62 && !C) {
      let _ = t.sCount[g] + 1, D, A;
      t.src.charCodeAt(i) === 32 ? (i++, _++, A = !1, D = !0) : t.src.charCodeAt(i) === 9 ? (D = !0, (t.bsCount[g] + _) % 4 === 3 ? (i++, _++, A = !1) : A = !0) : D = !1;
      let O = _;
      for (a.push(t.bMarks[g]), t.bMarks[g] = i; i < o; ) {
        const M = t.src.charCodeAt(i);
        if (Nr(M))
          M === 9 ? O += 4 - (O + t.bsCount[g] + (A ? 1 : 0)) % 4 : O++;
        else
          break;
        i++;
      }
      p = i >= o, l.push(t.bsCount[g]), t.bsCount[g] = t.sCount[g] + 1 + (D ? 1 : 0), u.push(t.sCount[g]), t.sCount[g] = O - _, c.push(t.tShift[g]), t.tShift[g] = i - t.bMarks[g];
      continue;
    }
    if (p)
      break;
    let S = !1;
    for (let _ = 0, D = h.length; _ < D; _++)
      if (h[_](t, g, r, !0)) {
        S = !0;
        break;
      }
    if (S) {
      t.lineMax = g, t.blkIndent !== 0 && (a.push(t.bMarks[g]), l.push(t.bsCount[g]), c.push(t.tShift[g]), u.push(t.sCount[g]), t.sCount[g] -= t.blkIndent);
      break;
    }
    a.push(t.bMarks[g]), l.push(t.bsCount[g]), c.push(t.tShift[g]), u.push(t.sCount[g]), t.sCount[g] = -1;
  }
  const v = t.blkIndent;
  t.blkIndent = 0;
  const y = t.push("blockquote_open", "blockquote", 1);
  y.markup = ">";
  const b = [e, 0];
  y.map = b, t.md.block.tokenize(t, e, g);
  const k = t.push("blockquote_close", "blockquote", -1);
  k.markup = ">", t.lineMax = s, t.parentType = d, b[1] = t.line;
  for (let C = 0; C < c.length; C++)
    t.bMarks[C + e] = a[C], t.tShift[C + e] = c[C], t.sCount[C + e] = u[C], t.bsCount[C + e] = l[C];
  return t.blkIndent = v, !0;
}
function ole(t, e, r, n) {
  const i = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let o = t.bMarks[e] + t.tShift[e];
  const s = t.src.charCodeAt(o++);
  if (s !== 42 && s !== 45 && s !== 95)
    return !1;
  let a = 1;
  for (; o < i; ) {
    const u = t.src.charCodeAt(o++);
    if (u !== s && !Nr(u))
      return !1;
    u === s && a++;
  }
  if (a < 3)
    return !1;
  if (n)
    return !0;
  t.line = e + 1;
  const l = t.push("hr", "hr", 0);
  return l.map = [e, t.line], l.markup = Array(a + 1).join(String.fromCharCode(s)), !0;
}
function x7(t, e) {
  const r = t.eMarks[e];
  let n = t.bMarks[e] + t.tShift[e];
  const i = t.src.charCodeAt(n++);
  if (i !== 42 && i !== 45 && i !== 43)
    return -1;
  if (n < r) {
    const o = t.src.charCodeAt(n);
    if (!Nr(o))
      return -1;
  }
  return n;
}
function w7(t, e) {
  const r = t.bMarks[e] + t.tShift[e], n = t.eMarks[e];
  let i = r;
  if (i + 1 >= n)
    return -1;
  let o = t.src.charCodeAt(i++);
  if (o < 48 || o > 57)
    return -1;
  for (; ; ) {
    if (i >= n)
      return -1;
    if (o = t.src.charCodeAt(i++), o >= 48 && o <= 57) {
      if (i - r >= 10)
        return -1;
      continue;
    }
    if (o === 41 || o === 46)
      break;
    return -1;
  }
  return i < n && (o = t.src.charCodeAt(i), !Nr(o)) ? -1 : i;
}
function sle(t, e) {
  const r = t.level + 2;
  for (let n = e + 2, i = t.tokens.length - 2; n < i; n++)
    t.tokens[n].level === r && t.tokens[n].type === "paragraph_open" && (t.tokens[n + 2].hidden = !0, t.tokens[n].hidden = !0, n += 2);
}
function ale(t, e, r, n) {
  let i, o, s, a, l = e, u = !0;
  if (t.sCount[l] - t.blkIndent >= 4 || t.listIndent >= 0 && t.sCount[l] - t.listIndent >= 4 && t.sCount[l] < t.blkIndent)
    return !1;
  let c = !1;
  n && t.parentType === "paragraph" && t.sCount[l] >= t.blkIndent && (c = !0);
  let h, d, p;
  if ((p = w7(t, l)) >= 0) {
    if (h = !0, s = t.bMarks[l] + t.tShift[l], d = Number(t.src.slice(s, p - 1)), c && d !== 1) return !1;
  } else if ((p = x7(t, l)) >= 0)
    h = !1;
  else
    return !1;
  if (c && t.skipSpaces(p) >= t.eMarks[l])
    return !1;
  if (n)
    return !0;
  const g = t.src.charCodeAt(p - 1), v = t.tokens.length;
  h ? (a = t.push("ordered_list_open", "ol", 1), d !== 1 && (a.attrs = [["start", d]])) : a = t.push("bullet_list_open", "ul", 1);
  const y = [l, 0];
  a.map = y, a.markup = String.fromCharCode(g);
  let b = !1;
  const k = t.md.block.ruler.getRules("list"), C = t.parentType;
  for (t.parentType = "list"; l < r; ) {
    o = p, i = t.eMarks[l];
    const S = t.sCount[l] + p - (t.bMarks[l] + t.tShift[l]);
    let _ = S;
    for (; o < i; ) {
      const $ = t.src.charCodeAt(o);
      if ($ === 9)
        _ += 4 - (_ + t.bsCount[l]) % 4;
      else if ($ === 32)
        _++;
      else
        break;
      o++;
    }
    const D = o;
    let A;
    D >= i ? A = 1 : A = _ - S, A > 4 && (A = 1);
    const O = S + A;
    a = t.push("list_item_open", "li", 1), a.markup = String.fromCharCode(g);
    const M = [l, 0];
    a.map = M, h && (a.info = t.src.slice(s, p - 1));
    const z = t.tight, N = t.tShift[l], P = t.sCount[l], I = t.listIndent;
    if (t.listIndent = t.blkIndent, t.blkIndent = O, t.tight = !0, t.tShift[l] = D - t.bMarks[l], t.sCount[l] = _, D >= i && t.isEmpty(l + 1) ? t.line = Math.min(t.line + 2, r) : t.md.block.tokenize(t, l, r, !0), (!t.tight || b) && (u = !1), b = t.line - l > 1 && t.isEmpty(t.line - 1), t.blkIndent = t.listIndent, t.listIndent = I, t.tShift[l] = N, t.sCount[l] = P, t.tight = z, a = t.push("list_item_close", "li", -1), a.markup = String.fromCharCode(g), l = t.line, M[1] = l, l >= r || t.sCount[l] < t.blkIndent || t.sCount[l] - t.blkIndent >= 4)
      break;
    let B = !1;
    for (let $ = 0, j = k.length; $ < j; $++)
      if (k[$](t, l, r, !0)) {
        B = !0;
        break;
      }
    if (B)
      break;
    if (h) {
      if (p = w7(t, l), p < 0)
        break;
      s = t.bMarks[l] + t.tShift[l];
    } else if (p = x7(t, l), p < 0)
      break;
    if (g !== t.src.charCodeAt(p - 1))
      break;
  }
  return h ? a = t.push("ordered_list_close", "ol", -1) : a = t.push("bullet_list_close", "ul", -1), a.markup = String.fromCharCode(g), y[1] = l, t.line = l, t.parentType = C, u && sle(t, v), !0;
}
function lle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e], s = e + 1;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 91)
    return !1;
  function a(k) {
    const C = t.lineMax;
    if (k >= C || t.isEmpty(k))
      return null;
    let S = !1;
    if (t.sCount[k] - t.blkIndent > 3 && (S = !0), t.sCount[k] < 0 && (S = !0), !S) {
      const A = t.md.block.ruler.getRules("reference"), O = t.parentType;
      t.parentType = "reference";
      let M = !1;
      for (let z = 0, N = A.length; z < N; z++)
        if (A[z](t, k, C, !0)) {
          M = !0;
          break;
        }
      if (t.parentType = O, M)
        return null;
    }
    const _ = t.bMarks[k] + t.tShift[k], D = t.eMarks[k];
    return t.src.slice(_, D + 1);
  }
  let l = t.src.slice(i, o + 1);
  o = l.length;
  let u = -1;
  for (i = 1; i < o; i++) {
    const k = l.charCodeAt(i);
    if (k === 91)
      return !1;
    if (k === 93) {
      u = i;
      break;
    } else if (k === 10) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    } else if (k === 92 && (i++, i < o && l.charCodeAt(i) === 10)) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    }
  }
  if (u < 0 || l.charCodeAt(u + 1) !== 58)
    return !1;
  for (i = u + 2; i < o; i++) {
    const k = l.charCodeAt(i);
    if (k === 10) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    } else if (!Nr(k)) break;
  }
  const c = t.md.helpers.parseLinkDestination(l, i, o);
  if (!c.ok)
    return !1;
  const h = t.md.normalizeLink(c.str);
  if (!t.md.validateLink(h))
    return !1;
  i = c.pos;
  const d = i, p = s, g = i;
  for (; i < o; i++) {
    const k = l.charCodeAt(i);
    if (k === 10) {
      const C = a(s);
      C !== null && (l += C, o = l.length, s++);
    } else if (!Nr(k)) break;
  }
  let v = t.md.helpers.parseLinkTitle(l, i, o);
  for (; v.can_continue; ) {
    const k = a(s);
    if (k === null) break;
    l += k, i = o, o = l.length, s++, v = t.md.helpers.parseLinkTitle(l, i, o, v);
  }
  let y;
  for (i < o && g !== i && v.ok ? (y = v.str, i = v.pos) : (y = "", i = d, s = p); i < o; ) {
    const k = l.charCodeAt(i);
    if (!Nr(k))
      break;
    i++;
  }
  if (i < o && l.charCodeAt(i) !== 10 && y)
    for (y = "", i = d, s = p; i < o; ) {
      const k = l.charCodeAt(i);
      if (!Nr(k))
        break;
      i++;
    }
  if (i < o && l.charCodeAt(i) !== 10)
    return !1;
  const b = Jb(l.slice(1, u));
  return b ? (n || (typeof t.env.references > "u" && (t.env.references = {}), typeof t.env.references[b] > "u" && (t.env.references[b] = { title: y, href: h }), t.line = s), !0) : !1;
}
const ule = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], cle = "[a-zA-Z_:][a-zA-Z0-9:._-]*", hle = "[^\"'=<>`\\x00-\\x20]+", fle = "'[^']*'", dle = '"[^"]*"', ple = "(?:" + hle + "|" + fle + "|" + dle + ")", mle = "(?:\\s+" + cle + "(?:\\s*=\\s*" + ple + ")?)", jN = "<[A-Za-z][A-Za-z0-9\\-]*" + mle + "*\\s*\\/?>", qN = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", gle = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", vle = "<[?][\\s\\S]*?[?]>", yle = "<![A-Za-z][^>]*>", ble = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", xle = new RegExp("^(?:" + jN + "|" + qN + "|" + gle + "|" + vle + "|" + yle + "|" + ble + ")"), wle = new RegExp("^(?:" + jN + "|" + qN + ")"), bf = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + ule.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(wle.source + "\\s*$"), /^$/, !1]
];
function kle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || !t.md.options.html || t.src.charCodeAt(i) !== 60)
    return !1;
  let s = t.src.slice(i, o), a = 0;
  for (; a < bf.length && !bf[a][0].test(s); a++)
    ;
  if (a === bf.length)
    return !1;
  if (n)
    return bf[a][2];
  let l = e + 1;
  if (!bf[a][1].test(s)) {
    for (; l < r && !(t.sCount[l] < t.blkIndent); l++)
      if (i = t.bMarks[l] + t.tShift[l], o = t.eMarks[l], s = t.src.slice(i, o), bf[a][1].test(s)) {
        s.length !== 0 && l++;
        break;
      }
  }
  t.line = l;
  const u = t.push("html_block", "", 0);
  return u.map = [e, l], u.content = t.getLines(e, l, t.blkIndent, !0), !0;
}
function Cle(t, e, r, n) {
  let i = t.bMarks[e] + t.tShift[e], o = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let s = t.src.charCodeAt(i);
  if (s !== 35 || i >= o)
    return !1;
  let a = 1;
  for (s = t.src.charCodeAt(++i); s === 35 && i < o && a <= 6; )
    a++, s = t.src.charCodeAt(++i);
  if (a > 6 || i < o && !Nr(s))
    return !1;
  if (n)
    return !0;
  o = t.skipSpacesBack(o, i);
  const l = t.skipCharsBack(o, 35, i);
  l > i && Nr(t.src.charCodeAt(l - 1)) && (o = l), t.line = e + 1;
  const u = t.push("heading_open", "h" + String(a), 1);
  u.markup = "########".slice(0, a), u.map = [e, t.line];
  const c = t.push("inline", "", 0);
  c.content = t.src.slice(i, o).trim(), c.map = [e, t.line], c.children = [];
  const h = t.push("heading_close", "h" + String(a), -1);
  return h.markup = "########".slice(0, a), !0;
}
function _le(t, e, r) {
  const n = t.md.block.ruler.getRules("paragraph");
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  const i = t.parentType;
  t.parentType = "paragraph";
  let o = 0, s, a = e + 1;
  for (; a < r && !t.isEmpty(a); a++) {
    if (t.sCount[a] - t.blkIndent > 3)
      continue;
    if (t.sCount[a] >= t.blkIndent) {
      let p = t.bMarks[a] + t.tShift[a];
      const g = t.eMarks[a];
      if (p < g && (s = t.src.charCodeAt(p), (s === 45 || s === 61) && (p = t.skipChars(p, s), p = t.skipSpaces(p), p >= g))) {
        o = s === 61 ? 1 : 2;
        break;
      }
    }
    if (t.sCount[a] < 0)
      continue;
    let d = !1;
    for (let p = 0, g = n.length; p < g; p++)
      if (n[p](t, a, r, !0)) {
        d = !0;
        break;
      }
    if (d)
      break;
  }
  if (!o)
    return !1;
  const l = t.getLines(e, a, t.blkIndent, !1).trim();
  t.line = a + 1;
  const u = t.push("heading_open", "h" + String(o), 1);
  u.markup = String.fromCharCode(s), u.map = [e, t.line];
  const c = t.push("inline", "", 0);
  c.content = l, c.map = [e, t.line - 1], c.children = [];
  const h = t.push("heading_close", "h" + String(o), -1);
  return h.markup = String.fromCharCode(s), t.parentType = i, !0;
}
function Sle(t, e, r) {
  const n = t.md.block.ruler.getRules("paragraph"), i = t.parentType;
  let o = e + 1;
  for (t.parentType = "paragraph"; o < r && !t.isEmpty(o); o++) {
    if (t.sCount[o] - t.blkIndent > 3 || t.sCount[o] < 0)
      continue;
    let u = !1;
    for (let c = 0, h = n.length; c < h; c++)
      if (n[c](t, o, r, !0)) {
        u = !0;
        break;
      }
    if (u)
      break;
  }
  const s = t.getLines(e, o, t.blkIndent, !1).trim();
  t.line = o;
  const a = t.push("paragraph_open", "p", 1);
  a.map = [e, t.line];
  const l = t.push("inline", "", 0);
  return l.content = s, l.map = [e, t.line], l.children = [], t.push("paragraph_close", "p", -1), t.parentType = i, !0;
}
const ey = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", tle, ["paragraph", "reference"]],
  ["code", rle],
  ["fence", nle, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", ile, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", ole, ["paragraph", "reference", "blockquote", "list"]],
  ["list", ale, ["paragraph", "reference", "blockquote"]],
  ["reference", lle],
  ["html_block", kle, ["paragraph", "reference", "blockquote"]],
  ["heading", Cle, ["paragraph", "reference", "blockquote"]],
  ["lheading", _le],
  ["paragraph", Sle]
];
function Yb() {
  this.ruler = new ho();
  for (let t = 0; t < ey.length; t++)
    this.ruler.push(ey[t][0], ey[t][1], { alt: (ey[t][2] || []).slice() });
}
Yb.prototype.tokenize = function(t, e, r) {
  const n = this.ruler.getRules(""), i = n.length, o = t.md.options.maxNesting;
  let s = e, a = !1;
  for (; s < r && (t.line = s = t.skipEmptyLines(s), !(s >= r || t.sCount[s] < t.blkIndent)); ) {
    if (t.level >= o) {
      t.line = r;
      break;
    }
    const l = t.line;
    let u = !1;
    for (let c = 0; c < i; c++)
      if (u = n[c](t, s, r, !1), u) {
        if (l >= t.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!u) throw new Error("none of the block rules matched");
    t.tight = !a, t.isEmpty(t.line - 1) && (a = !0), s = t.line, s < r && t.isEmpty(s) && (a = !0, s++, t.line = s);
  }
};
Yb.prototype.parse = function(t, e, r, n) {
  if (!t)
    return;
  const i = new this.State(t, e, r, n);
  this.tokenize(i, i.line, i.lineMax);
};
Yb.prototype.State = ul;
function l0(t, e, r, n) {
  this.src = t, this.env = r, this.md = e, this.tokens = n, this.tokens_meta = Array(n.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
l0.prototype.pushPending = function() {
  const t = new aa("text", "", 0);
  return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t;
};
l0.prototype.push = function(t, e, r) {
  this.pending && this.pushPending();
  const n = new aa(t, e, r);
  let i = null;
  return r < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), n.level = this.level, r > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(n), this.tokens_meta.push(i), n;
};
l0.prototype.scanDelims = function(t, e) {
  const r = this.posMax, n = this.src.charCodeAt(t), i = t > 0 ? this.src.charCodeAt(t - 1) : 32;
  let o = t;
  for (; o < r && this.src.charCodeAt(o) === n; )
    o++;
  const s = o - t, a = o < r ? this.src.charCodeAt(o) : 32, l = wg(i) || xg(String.fromCharCode(i)), u = wg(a) || xg(String.fromCharCode(a)), c = bg(i), h = bg(a), d = !h && (!u || c || l), p = !c && (!l || h || u);
  return { can_open: d && (e || !p || l), can_close: p && (e || !d || u), length: s };
};
l0.prototype.Token = aa;
function Ale(t) {
  switch (t) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function Ele(t, e) {
  let r = t.pos;
  for (; r < t.posMax && !Ale(t.src.charCodeAt(r)); )
    r++;
  return r === t.pos ? !1 : (e || (t.pending += t.src.slice(t.pos, r)), t.pos = r, !0);
}
const Dle = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function Ole(t, e) {
  if (!t.md.options.linkify || t.linkLevel > 0) return !1;
  const r = t.pos, n = t.posMax;
  if (r + 3 > n || t.src.charCodeAt(r) !== 58 || t.src.charCodeAt(r + 1) !== 47 || t.src.charCodeAt(r + 2) !== 47) return !1;
  const i = t.pending.match(Dle);
  if (!i) return !1;
  const o = i[1], s = t.md.linkify.matchAtStart(t.src.slice(r - o.length));
  if (!s) return !1;
  let a = s.url;
  if (a.length <= o.length) return !1;
  a = a.replace(/\*+$/, "");
  const l = t.md.normalizeLink(a);
  if (!t.md.validateLink(l)) return !1;
  if (!e) {
    t.pending = t.pending.slice(0, -o.length);
    const u = t.push("link_open", "a", 1);
    u.attrs = [["href", l]], u.markup = "linkify", u.info = "auto";
    const c = t.push("text", "", 0);
    c.content = t.md.normalizeLinkText(a);
    const h = t.push("link_close", "a", -1);
    h.markup = "linkify", h.info = "auto";
  }
  return t.pos += a.length - o.length, !0;
}
function Fle(t, e) {
  let r = t.pos;
  if (t.src.charCodeAt(r) !== 10)
    return !1;
  const n = t.pending.length - 1, i = t.posMax;
  if (!e)
    if (n >= 0 && t.pending.charCodeAt(n) === 32)
      if (n >= 1 && t.pending.charCodeAt(n - 1) === 32) {
        let o = n - 1;
        for (; o >= 1 && t.pending.charCodeAt(o - 1) === 32; ) o--;
        t.pending = t.pending.slice(0, o), t.push("hardbreak", "br", 0);
      } else
        t.pending = t.pending.slice(0, -1), t.push("softbreak", "br", 0);
    else
      t.push("softbreak", "br", 0);
  for (r++; r < i && Nr(t.src.charCodeAt(r)); )
    r++;
  return t.pos = r, !0;
}
const Z4 = [];
for (let t = 0; t < 256; t++)
  Z4.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t) {
  Z4[t.charCodeAt(0)] = 1;
});
function Tle(t, e) {
  let r = t.pos;
  const n = t.posMax;
  if (t.src.charCodeAt(r) !== 92 || (r++, r >= n)) return !1;
  let i = t.src.charCodeAt(r);
  if (i === 10) {
    for (e || t.push("hardbreak", "br", 0), r++; r < n && (i = t.src.charCodeAt(r), !!Nr(i)); )
      r++;
    return t.pos = r, !0;
  }
  let o = t.src[r];
  if (i >= 55296 && i <= 56319 && r + 1 < n) {
    const a = t.src.charCodeAt(r + 1);
    a >= 56320 && a <= 57343 && (o += t.src[r + 1], r++);
  }
  const s = "\\" + o;
  if (!e) {
    const a = t.push("text_special", "", 0);
    i < 256 && Z4[i] !== 0 ? a.content = o : a.content = s, a.markup = s, a.info = "escape";
  }
  return t.pos = r + 1, !0;
}
function Mle(t, e) {
  let r = t.pos;
  if (t.src.charCodeAt(r) !== 96)
    return !1;
  const n = r;
  r++;
  const i = t.posMax;
  for (; r < i && t.src.charCodeAt(r) === 96; )
    r++;
  const o = t.src.slice(n, r), s = o.length;
  if (t.backticksScanned && (t.backticks[s] || 0) <= n)
    return e || (t.pending += o), t.pos += s, !0;
  let a = r, l;
  for (; (l = t.src.indexOf("`", a)) !== -1; ) {
    for (a = l + 1; a < i && t.src.charCodeAt(a) === 96; )
      a++;
    const u = a - l;
    if (u === s) {
      if (!e) {
        const c = t.push("code_inline", "code", 0);
        c.markup = o, c.content = t.src.slice(r, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return t.pos = a, !0;
    }
    t.backticks[u] = l;
  }
  return t.backticksScanned = !0, e || (t.pending += o), t.pos += s, !0;
}
function Ple(t, e) {
  const r = t.pos, n = t.src.charCodeAt(r);
  if (e || n !== 126)
    return !1;
  const i = t.scanDelims(t.pos, !0);
  let o = i.length;
  const s = String.fromCharCode(n);
  if (o < 2)
    return !1;
  let a;
  o % 2 && (a = t.push("text", "", 0), a.content = s, o--);
  for (let l = 0; l < o; l += 2)
    a = t.push("text", "", 0), a.content = s + s, t.delimiters.push({
      marker: n,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: t.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return t.pos += i.length, !0;
}
function k7(t, e) {
  let r;
  const n = [], i = e.length;
  for (let o = 0; o < i; o++) {
    const s = e[o];
    if (s.marker !== 126 || s.end === -1)
      continue;
    const a = e[s.end];
    r = t.tokens[s.token], r.type = "s_open", r.tag = "s", r.nesting = 1, r.markup = "~~", r.content = "", r = t.tokens[a.token], r.type = "s_close", r.tag = "s", r.nesting = -1, r.markup = "~~", r.content = "", t.tokens[a.token - 1].type === "text" && t.tokens[a.token - 1].content === "~" && n.push(a.token - 1);
  }
  for (; n.length; ) {
    const o = n.pop();
    let s = o + 1;
    for (; s < t.tokens.length && t.tokens[s].type === "s_close"; )
      s++;
    s--, o !== s && (r = t.tokens[s], t.tokens[s] = t.tokens[o], t.tokens[o] = r);
  }
}
function Rle(t) {
  const e = t.tokens_meta, r = t.tokens_meta.length;
  k7(t, t.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && k7(t, e[n].delimiters);
}
const UN = {
  tokenize: Ple,
  postProcess: Rle
};
function Nle(t, e) {
  const r = t.pos, n = t.src.charCodeAt(r);
  if (e || n !== 95 && n !== 42)
    return !1;
  const i = t.scanDelims(t.pos, n === 42);
  for (let o = 0; o < i.length; o++) {
    const s = t.push("text", "", 0);
    s.content = String.fromCharCode(n), t.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: n,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: t.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  }
  return t.pos += i.length, !0;
}
function C7(t, e) {
  const r = e.length;
  for (let n = r - 1; n >= 0; n--) {
    const i = e[n];
    if (i.marker !== 95 && i.marker !== 42 || i.end === -1)
      continue;
    const o = e[i.end], s = n > 0 && e[n - 1].end === i.end + 1 && // check that first two markers match and adjacent
    e[n - 1].marker === i.marker && e[n - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[i.end + 1].token === o.token + 1, a = String.fromCharCode(i.marker), l = t.tokens[i.token];
    l.type = s ? "strong_open" : "em_open", l.tag = s ? "strong" : "em", l.nesting = 1, l.markup = s ? a + a : a, l.content = "";
    const u = t.tokens[o.token];
    u.type = s ? "strong_close" : "em_close", u.tag = s ? "strong" : "em", u.nesting = -1, u.markup = s ? a + a : a, u.content = "", s && (t.tokens[e[n - 1].token].content = "", t.tokens[e[i.end + 1].token].content = "", n--);
  }
}
function $le(t) {
  const e = t.tokens_meta, r = t.tokens_meta.length;
  C7(t, t.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && C7(t, e[n].delimiters);
}
const HN = {
  tokenize: Nle,
  postProcess: $le
};
function Ile(t, e) {
  let r, n, i, o, s = "", a = "", l = t.pos, u = !0;
  if (t.src.charCodeAt(t.pos) !== 91)
    return !1;
  const c = t.pos, h = t.posMax, d = t.pos + 1, p = t.md.helpers.parseLinkLabel(t, t.pos, !0);
  if (p < 0)
    return !1;
  let g = p + 1;
  if (g < h && t.src.charCodeAt(g) === 40) {
    for (u = !1, g++; g < h && (r = t.src.charCodeAt(g), !(!Nr(r) && r !== 10)); g++)
      ;
    if (g >= h)
      return !1;
    if (l = g, i = t.md.helpers.parseLinkDestination(t.src, g, t.posMax), i.ok) {
      for (s = t.md.normalizeLink(i.str), t.md.validateLink(s) ? g = i.pos : s = "", l = g; g < h && (r = t.src.charCodeAt(g), !(!Nr(r) && r !== 10)); g++)
        ;
      if (i = t.md.helpers.parseLinkTitle(t.src, g, t.posMax), g < h && l !== g && i.ok)
        for (a = i.str, g = i.pos; g < h && (r = t.src.charCodeAt(g), !(!Nr(r) && r !== 10)); g++)
          ;
    }
    (g >= h || t.src.charCodeAt(g) !== 41) && (u = !0), g++;
  }
  if (u) {
    if (typeof t.env.references > "u")
      return !1;
    if (g < h && t.src.charCodeAt(g) === 91 ? (l = g + 1, g = t.md.helpers.parseLinkLabel(t, g), g >= 0 ? n = t.src.slice(l, g++) : g = p + 1) : g = p + 1, n || (n = t.src.slice(d, p)), o = t.env.references[Jb(n)], !o)
      return t.pos = c, !1;
    s = o.href, a = o.title;
  }
  if (!e) {
    t.pos = d, t.posMax = p;
    const v = t.push("link_open", "a", 1), y = [["href", s]];
    v.attrs = y, a && y.push(["title", a]), t.linkLevel++, t.md.inline.tokenize(t), t.linkLevel--, t.push("link_close", "a", -1);
  }
  return t.pos = g, t.posMax = h, !0;
}
function Ble(t, e) {
  let r, n, i, o, s, a, l, u, c = "";
  const h = t.pos, d = t.posMax;
  if (t.src.charCodeAt(t.pos) !== 33 || t.src.charCodeAt(t.pos + 1) !== 91)
    return !1;
  const p = t.pos + 2, g = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1);
  if (g < 0)
    return !1;
  if (o = g + 1, o < d && t.src.charCodeAt(o) === 40) {
    for (o++; o < d && (r = t.src.charCodeAt(o), !(!Nr(r) && r !== 10)); o++)
      ;
    if (o >= d)
      return !1;
    for (u = o, a = t.md.helpers.parseLinkDestination(t.src, o, t.posMax), a.ok && (c = t.md.normalizeLink(a.str), t.md.validateLink(c) ? o = a.pos : c = ""), u = o; o < d && (r = t.src.charCodeAt(o), !(!Nr(r) && r !== 10)); o++)
      ;
    if (a = t.md.helpers.parseLinkTitle(t.src, o, t.posMax), o < d && u !== o && a.ok)
      for (l = a.str, o = a.pos; o < d && (r = t.src.charCodeAt(o), !(!Nr(r) && r !== 10)); o++)
        ;
    else
      l = "";
    if (o >= d || t.src.charCodeAt(o) !== 41)
      return t.pos = h, !1;
    o++;
  } else {
    if (typeof t.env.references > "u")
      return !1;
    if (o < d && t.src.charCodeAt(o) === 91 ? (u = o + 1, o = t.md.helpers.parseLinkLabel(t, o), o >= 0 ? i = t.src.slice(u, o++) : o = g + 1) : o = g + 1, i || (i = t.src.slice(p, g)), s = t.env.references[Jb(i)], !s)
      return t.pos = h, !1;
    c = s.href, l = s.title;
  }
  if (!e) {
    n = t.src.slice(p, g);
    const v = [];
    t.md.inline.parse(
      n,
      t.md,
      t.env,
      v
    );
    const y = t.push("image", "img", 0), b = [["src", c], ["alt", ""]];
    y.attrs = b, y.children = v, y.content = n, l && b.push(["title", l]);
  }
  return t.pos = o, t.posMax = d, !0;
}
const Lle = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, zle = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function jle(t, e) {
  let r = t.pos;
  if (t.src.charCodeAt(r) !== 60)
    return !1;
  const n = t.pos, i = t.posMax;
  for (; ; ) {
    if (++r >= i) return !1;
    const s = t.src.charCodeAt(r);
    if (s === 60) return !1;
    if (s === 62) break;
  }
  const o = t.src.slice(n + 1, r);
  if (zle.test(o)) {
    const s = t.md.normalizeLink(o);
    if (!t.md.validateLink(s))
      return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      a.attrs = [["href", s]], a.markup = "autolink", a.info = "auto";
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(o);
      const u = t.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return t.pos += o.length + 2, !0;
  }
  if (Lle.test(o)) {
    const s = t.md.normalizeLink("mailto:" + o);
    if (!t.md.validateLink(s))
      return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      a.attrs = [["href", s]], a.markup = "autolink", a.info = "auto";
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(o);
      const u = t.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return t.pos += o.length + 2, !0;
  }
  return !1;
}
function qle(t) {
  return /^<a[>\s]/i.test(t);
}
function Ule(t) {
  return /^<\/a\s*>/i.test(t);
}
function Hle(t) {
  const e = t | 32;
  return e >= 97 && e <= 122;
}
function Vle(t, e) {
  if (!t.md.options.html)
    return !1;
  const r = t.posMax, n = t.pos;
  if (t.src.charCodeAt(n) !== 60 || n + 2 >= r)
    return !1;
  const i = t.src.charCodeAt(n + 1);
  if (i !== 33 && i !== 63 && i !== 47 && !Hle(i))
    return !1;
  const o = t.src.slice(n).match(xle);
  if (!o)
    return !1;
  if (!e) {
    const s = t.push("html_inline", "", 0);
    s.content = o[0], qle(s.content) && t.linkLevel++, Ule(s.content) && t.linkLevel--;
  }
  return t.pos += o[0].length, !0;
}
const Wle = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, Gle = /^&([a-z][a-z0-9]{1,31});/i;
function Kle(t, e) {
  const r = t.pos, n = t.posMax;
  if (t.src.charCodeAt(r) !== 38 || r + 1 >= n) return !1;
  if (t.src.charCodeAt(r + 1) === 35) {
    const i = t.src.slice(r).match(Wle);
    if (i) {
      if (!e) {
        const o = i[1][0].toLowerCase() === "x" ? parseInt(i[1].slice(1), 16) : parseInt(i[1], 10), s = t.push("text_special", "", 0);
        s.content = J4(o) ? L1(o) : L1(65533), s.markup = i[0], s.info = "entity";
      }
      return t.pos += i[0].length, !0;
    }
  } else {
    const i = t.src.slice(r).match(Gle);
    if (i) {
      const o = $N(i[0]);
      if (o !== i[0]) {
        if (!e) {
          const s = t.push("text_special", "", 0);
          s.content = o, s.markup = i[0], s.info = "entity";
        }
        return t.pos += i[0].length, !0;
      }
    }
  }
  return !1;
}
function _7(t) {
  const e = {}, r = t.length;
  if (!r) return;
  let n = 0, i = -2;
  const o = [];
  for (let s = 0; s < r; s++) {
    const a = t[s];
    if (o.push(0), (t[n].marker !== a.marker || i !== a.token - 1) && (n = s), i = a.token, a.length = a.length || 0, !a.close) continue;
    e.hasOwnProperty(a.marker) || (e[a.marker] = [-1, -1, -1, -1, -1, -1]);
    const l = e[a.marker][(a.open ? 3 : 0) + a.length % 3];
    let u = n - o[n] - 1, c = u;
    for (; u > l; u -= o[u] + 1) {
      const h = t[u];
      if (h.marker === a.marker && h.open && h.end < 0) {
        let d = !1;
        if ((h.close || a.open) && (h.length + a.length) % 3 === 0 && (h.length % 3 !== 0 || a.length % 3 !== 0) && (d = !0), !d) {
          const p = u > 0 && !t[u - 1].open ? o[u - 1] + 1 : 0;
          o[s] = s - u + p, o[u] = p, a.open = !1, h.end = s, h.close = !1, c = -1, i = -2;
          break;
        }
      }
    }
    c !== -1 && (e[a.marker][(a.open ? 3 : 0) + (a.length || 0) % 3] = c);
  }
}
function Xle(t) {
  const e = t.tokens_meta, r = t.tokens_meta.length;
  _7(t.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && _7(e[n].delimiters);
}
function Qle(t) {
  let e, r, n = 0;
  const i = t.tokens, o = t.tokens.length;
  for (e = r = 0; e < o; e++)
    i[e].nesting < 0 && n--, i[e].level = n, i[e].nesting > 0 && n++, i[e].type === "text" && e + 1 < o && i[e + 1].type === "text" ? i[e + 1].content = i[e].content + i[e + 1].content : (e !== r && (i[r] = i[e]), r++);
  e !== r && (i.length = r);
}
const Y2 = [
  ["text", Ele],
  ["linkify", Ole],
  ["newline", Fle],
  ["escape", Tle],
  ["backticks", Mle],
  ["strikethrough", UN.tokenize],
  ["emphasis", HN.tokenize],
  ["link", Ile],
  ["image", Ble],
  ["autolink", jle],
  ["html_inline", Vle],
  ["entity", Kle]
], Z2 = [
  ["balance_pairs", Xle],
  ["strikethrough", UN.postProcess],
  ["emphasis", HN.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", Qle]
];
function u0() {
  this.ruler = new ho();
  for (let t = 0; t < Y2.length; t++)
    this.ruler.push(Y2[t][0], Y2[t][1]);
  this.ruler2 = new ho();
  for (let t = 0; t < Z2.length; t++)
    this.ruler2.push(Z2[t][0], Z2[t][1]);
}
u0.prototype.skipToken = function(t) {
  const e = t.pos, r = this.ruler.getRules(""), n = r.length, i = t.md.options.maxNesting, o = t.cache;
  if (typeof o[e] < "u") {
    t.pos = o[e];
    return;
  }
  let s = !1;
  if (t.level < i) {
    for (let a = 0; a < n; a++)
      if (t.level++, s = r[a](t, !0), t.level--, s) {
        if (e >= t.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    t.pos = t.posMax;
  s || t.pos++, o[e] = t.pos;
};
u0.prototype.tokenize = function(t) {
  const e = this.ruler.getRules(""), r = e.length, n = t.posMax, i = t.md.options.maxNesting;
  for (; t.pos < n; ) {
    const o = t.pos;
    let s = !1;
    if (t.level < i) {
      for (let a = 0; a < r; a++)
        if (s = e[a](t, !1), s) {
          if (o >= t.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (s) {
      if (t.pos >= n)
        break;
      continue;
    }
    t.pending += t.src[t.pos++];
  }
  t.pending && t.pushPending();
};
u0.prototype.parse = function(t, e, r, n) {
  const i = new this.State(t, e, r, n);
  this.tokenize(i);
  const o = this.ruler2.getRules(""), s = o.length;
  for (let a = 0; a < s; a++)
    o[a](i);
};
u0.prototype.State = l0;
function Jle(t) {
  const e = {};
  t = t || {}, e.src_Any = TN.source, e.src_Cc = MN.source, e.src_Z = RN.source, e.src_P = X4.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
  const r = "[><ï½œ]";
  return e.src_pseudo_letter = "(?:(?!" + r + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + r + "|" + e.src_ZPCc + ")(?!" + (t["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + r + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + r + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + e.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + e.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
}
function SC(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    e && Object.keys(e).forEach(function(r) {
      t[r] = e[r];
    });
  }), t;
}
function Zb(t) {
  return Object.prototype.toString.call(t);
}
function Yle(t) {
  return Zb(t) === "[object String]";
}
function Zle(t) {
  return Zb(t) === "[object Object]";
}
function eue(t) {
  return Zb(t) === "[object RegExp]";
}
function S7(t) {
  return Zb(t) === "[object Function]";
}
function tue(t) {
  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const VN = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function rue(t) {
  return Object.keys(t || {}).reduce(function(e, r) {
    return e || VN.hasOwnProperty(r);
  }, !1);
}
const nue = {
  "http:": {
    validate: function(t, e, r) {
      const n = t.slice(e);
      return r.re.http || (r.re.http = new RegExp(
        "^\\/\\/" + r.re.src_auth + r.re.src_host_port_strict + r.re.src_path,
        "i"
      )), r.re.http.test(n) ? n.match(r.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t, e, r) {
      const n = t.slice(e);
      return r.re.no_http || (r.re.no_http = new RegExp(
        "^" + r.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + r.re.src_domain + ")\\.)+" + r.re.src_domain_root + ")" + r.re.src_port + r.re.src_host_terminator + r.re.src_path,
        "i"
      )), r.re.no_http.test(n) ? e >= 3 && t[e - 3] === ":" || e >= 3 && t[e - 3] === "/" ? 0 : n.match(r.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t, e, r) {
      const n = t.slice(e);
      return r.re.mailto || (r.re.mailto = new RegExp(
        "^" + r.re.src_email_name + "@" + r.re.src_host_strict,
        "i"
      )), r.re.mailto.test(n) ? n.match(r.re.mailto)[0].length : 0;
    }
  }
}, iue = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", oue = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
function sue(t) {
  t.__index__ = -1, t.__text_cache__ = "";
}
function aue(t) {
  return function(e, r) {
    const n = e.slice(r);
    return t.test(n) ? n.match(t)[0].length : 0;
  };
}
function A7() {
  return function(t, e) {
    e.normalize(t);
  };
}
function z1(t) {
  const e = t.re = Jle(t.__opts__), r = t.__tlds__.slice();
  t.onCompile(), t.__tlds_replaced__ || r.push(iue), r.push(e.src_xn), e.src_tlds = r.join("|");
  function n(a) {
    return a.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(n(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(n(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(n(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(n(e.tpl_host_fuzzy_test), "i");
  const i = [];
  t.__compiled__ = {};
  function o(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(t.__schemas__).forEach(function(a) {
    const l = t.__schemas__[a];
    if (l === null)
      return;
    const u = { validate: null, link: null };
    if (t.__compiled__[a] = u, Zle(l)) {
      eue(l.validate) ? u.validate = aue(l.validate) : S7(l.validate) ? u.validate = l.validate : o(a, l), S7(l.normalize) ? u.normalize = l.normalize : l.normalize ? o(a, l) : u.normalize = A7();
      return;
    }
    if (Yle(l)) {
      i.push(a);
      return;
    }
    o(a, l);
  }), i.forEach(function(a) {
    t.__compiled__[t.__schemas__[a]] && (t.__compiled__[a].validate = t.__compiled__[t.__schemas__[a]].validate, t.__compiled__[a].normalize = t.__compiled__[t.__schemas__[a]].normalize);
  }), t.__compiled__[""] = { validate: null, normalize: A7() };
  const s = Object.keys(t.__compiled__).filter(function(a) {
    return a.length > 0 && t.__compiled__[a];
  }).map(tue).join("|");
  t.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + e.src_ZPCc + "))(" + s + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + e.src_ZPCc + "))(" + s + ")", "ig"), t.re.schema_at_start = RegExp("^" + t.re.schema_search.source, "i"), t.re.pretest = RegExp(
    "(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@",
    "i"
  ), sue(t);
}
function lue(t, e) {
  const r = t.__index__, n = t.__last_index__, i = t.__text_cache__.slice(r, n);
  this.schema = t.__schema__.toLowerCase(), this.index = r + e, this.lastIndex = n + e, this.raw = i, this.text = i, this.url = i;
}
function AC(t, e) {
  const r = new lue(t, e);
  return t.__compiled__[r.schema].normalize(r, t), r;
}
function Xo(t, e) {
  if (!(this instanceof Xo))
    return new Xo(t, e);
  e || rue(t) && (e = t, t = {}), this.__opts__ = SC({}, VN, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = SC({}, nue, t), this.__compiled__ = {}, this.__tlds__ = oue, this.__tlds_replaced__ = !1, this.re = {}, z1(this);
}
Xo.prototype.add = function(t, e) {
  return this.__schemas__[t] = e, z1(this), this;
};
Xo.prototype.set = function(t) {
  return this.__opts__ = SC(this.__opts__, t), this;
};
Xo.prototype.test = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length)
    return !1;
  let e, r, n, i, o, s, a, l, u;
  if (this.re.schema_test.test(t)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (e = a.exec(t)) !== null; )
      if (i = this.testSchemaAt(t, e[2], a.lastIndex), i) {
        this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + i;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = t.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = r.index + r[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = t.indexOf("@"), u >= 0 && (n = t.match(this.re.email_fuzzy)) !== null && (o = n.index + n[1].length, s = n.index + n[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = s))), this.__index__ >= 0;
};
Xo.prototype.pretest = function(t) {
  return this.re.pretest.test(t);
};
Xo.prototype.testSchemaAt = function(t, e, r) {
  return this.__compiled__[e.toLowerCase()] ? this.__compiled__[e.toLowerCase()].validate(t, r, this) : 0;
};
Xo.prototype.match = function(t) {
  const e = [];
  let r = 0;
  this.__index__ >= 0 && this.__text_cache__ === t && (e.push(AC(this, r)), r = this.__last_index__);
  let n = r ? t.slice(r) : t;
  for (; this.test(n); )
    e.push(AC(this, r)), n = n.slice(this.__last_index__), r += this.__last_index__;
  return e.length ? e : null;
};
Xo.prototype.matchAtStart = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return null;
  const e = this.re.schema_at_start.exec(t);
  if (!e) return null;
  const r = this.testSchemaAt(t, e[2], e[0].length);
  return r ? (this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + r, AC(this, 0)) : null;
};
Xo.prototype.tlds = function(t, e) {
  return t = Array.isArray(t) ? t : [t], e ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(r, n, i) {
    return r !== i[n - 1];
  }).reverse(), z1(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, z1(this), this);
};
Xo.prototype.normalize = function(t) {
  t.schema || (t.url = "http://" + t.url), t.schema === "mailto:" && !/^mailto:/i.test(t.url) && (t.url = "mailto:" + t.url);
};
Xo.prototype.onCompile = function() {
};
const Jf = 2147483647, Ia = 36, eS = 1, kg = 26, uue = 38, cue = 700, WN = 72, GN = 128, KN = "-", hue = /^xn--/, fue = /[^\0-\x7F]/, due = /[\x2E\u3002\uFF0E\uFF61]/g, pue = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, ek = Ia - eS, Ba = Math.floor, tk = String.fromCharCode;
function Du(t) {
  throw new RangeError(pue[t]);
}
function mue(t, e) {
  const r = [];
  let n = t.length;
  for (; n--; )
    r[n] = e(t[n]);
  return r;
}
function XN(t, e) {
  const r = t.split("@");
  let n = "";
  r.length > 1 && (n = r[0] + "@", t = r[1]), t = t.replace(due, ".");
  const i = t.split("."), o = mue(i, e).join(".");
  return n + o;
}
function QN(t) {
  const e = [];
  let r = 0;
  const n = t.length;
  for (; r < n; ) {
    const i = t.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      const o = t.charCodeAt(r++);
      (o & 64512) == 56320 ? e.push(((i & 1023) << 10) + (o & 1023) + 65536) : (e.push(i), r--);
    } else
      e.push(i);
  }
  return e;
}
const gue = (t) => String.fromCodePoint(...t), vue = function(t) {
  return t >= 48 && t < 58 ? 26 + (t - 48) : t >= 65 && t < 91 ? t - 65 : t >= 97 && t < 123 ? t - 97 : Ia;
}, E7 = function(t, e) {
  return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
}, JN = function(t, e, r) {
  let n = 0;
  for (t = r ? Ba(t / cue) : t >> 1, t += Ba(t / e); t > ek * kg >> 1; n += Ia)
    t = Ba(t / ek);
  return Ba(n + (ek + 1) * t / (t + uue));
}, YN = function(t) {
  const e = [], r = t.length;
  let n = 0, i = GN, o = WN, s = t.lastIndexOf(KN);
  s < 0 && (s = 0);
  for (let a = 0; a < s; ++a)
    t.charCodeAt(a) >= 128 && Du("not-basic"), e.push(t.charCodeAt(a));
  for (let a = s > 0 ? s + 1 : 0; a < r; ) {
    const l = n;
    for (let c = 1, h = Ia; ; h += Ia) {
      a >= r && Du("invalid-input");
      const d = vue(t.charCodeAt(a++));
      d >= Ia && Du("invalid-input"), d > Ba((Jf - n) / c) && Du("overflow"), n += d * c;
      const p = h <= o ? eS : h >= o + kg ? kg : h - o;
      if (d < p)
        break;
      const g = Ia - p;
      c > Ba(Jf / g) && Du("overflow"), c *= g;
    }
    const u = e.length + 1;
    o = JN(n - l, u, l == 0), Ba(n / u) > Jf - i && Du("overflow"), i += Ba(n / u), n %= u, e.splice(n++, 0, i);
  }
  return String.fromCodePoint(...e);
}, ZN = function(t) {
  const e = [];
  t = QN(t);
  const r = t.length;
  let n = GN, i = 0, o = WN;
  for (const l of t)
    l < 128 && e.push(tk(l));
  const s = e.length;
  let a = s;
  for (s && e.push(KN); a < r; ) {
    let l = Jf;
    for (const c of t)
      c >= n && c < l && (l = c);
    const u = a + 1;
    l - n > Ba((Jf - i) / u) && Du("overflow"), i += (l - n) * u, n = l;
    for (const c of t)
      if (c < n && ++i > Jf && Du("overflow"), c === n) {
        let h = i;
        for (let d = Ia; ; d += Ia) {
          const p = d <= o ? eS : d >= o + kg ? kg : d - o;
          if (h < p)
            break;
          const g = h - p, v = Ia - p;
          e.push(
            tk(E7(p + g % v, 0))
          ), h = Ba(g / v);
        }
        e.push(tk(E7(h, 0))), o = JN(i, u, a === s), i = 0, ++a;
      }
    ++i, ++n;
  }
  return e.join("");
}, yue = function(t) {
  return XN(t, function(e) {
    return hue.test(e) ? YN(e.slice(4).toLowerCase()) : e;
  });
}, bue = function(t) {
  return XN(t, function(e) {
    return fue.test(e) ? "xn--" + ZN(e) : e;
  });
}, e$ = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: QN,
    encode: gue
  },
  decode: YN,
  encode: ZN,
  toASCII: bue,
  toUnicode: yue
}, xue = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, wue = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, kue = {
  options: {
    // Enable HTML tags in source
    html: !0,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !0,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, Cue = {
  default: xue,
  zero: wue,
  commonmark: kue
}, _ue = /^(vbscript|javascript|file|data):/, Sue = /^data:image\/(gif|png|jpeg|webp);/;
function Aue(t) {
  const e = t.trim().toLowerCase();
  return _ue.test(e) ? Sue.test(e) : !0;
}
const t$ = ["http:", "https:", "mailto:"];
function Eue(t) {
  const e = K4(t, !0);
  if (e.hostname && (!e.protocol || t$.indexOf(e.protocol) >= 0))
    try {
      e.hostname = e$.toASCII(e.hostname);
    } catch {
    }
  return a0(G4(e));
}
function Due(t) {
  const e = K4(t, !0);
  if (e.hostname && (!e.protocol || t$.indexOf(e.protocol) >= 0))
    try {
      e.hostname = e$.toUnicode(e.hostname);
    } catch {
    }
  return Od(G4(e), Od.defaultChars + "%");
}
function Cs(t, e) {
  if (!(this instanceof Cs))
    return new Cs(t, e);
  e || Q4(t) || (e = t || {}, t = "default"), this.inline = new u0(), this.block = new Yb(), this.core = new Y4(), this.renderer = new rp(), this.linkify = new Xo(), this.validateLink = Aue, this.normalizeLink = Eue, this.normalizeLinkText = Due, this.utils = Fae, this.helpers = Qb({}, Rae), this.options = {}, this.configure(t), e && this.set(e);
}
Cs.prototype.set = function(t) {
  return Qb(this.options, t), this;
};
Cs.prototype.configure = function(t) {
  const e = this;
  if (Q4(t)) {
    const r = t;
    if (t = Cue[r], !t)
      throw new Error('Wrong `markdown-it` preset "' + r + '", check name');
  }
  if (!t)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t.options && e.set(t.options), t.components && Object.keys(t.components).forEach(function(r) {
    t.components[r].rules && e[r].ruler.enableOnly(t.components[r].rules), t.components[r].rules2 && e[r].ruler2.enableOnly(t.components[r].rules2);
  }), this;
};
Cs.prototype.enable = function(t, e) {
  let r = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.enable(t, !0));
  }, this), r = r.concat(this.inline.ruler2.enable(t, !0));
  const n = t.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + n);
  return this;
};
Cs.prototype.disable = function(t, e) {
  let r = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.disable(t, !0));
  }, this), r = r.concat(this.inline.ruler2.disable(t, !0));
  const n = t.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + n);
  return this;
};
Cs.prototype.use = function(t) {
  const e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t.apply(t, e), this;
};
Cs.prototype.parse = function(t, e) {
  if (typeof t != "string")
    throw new Error("Input data should be a String");
  const r = new this.core.State(t, this, e);
  return this.core.process(r), r.tokens;
};
Cs.prototype.render = function(t, e) {
  return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e);
};
Cs.prototype.parseInline = function(t, e) {
  const r = new this.core.State(t, this, e);
  return r.inlineMode = !0, this.core.process(r), r.tokens;
};
Cs.prototype.renderInline = function(t, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e);
};
function Oue(t, e, r) {
  const {
    parseMetaString: n,
    trimEndingNewline: i = !0,
    defaultLanguage: o = "text",
    fallbackLanguage: s
  } = r, a = e.getLoadedLanguages();
  t.options.highlight = (l, u = "text", c) => {
    u === "" && (u = o), s && !a.includes(u) && (u = s);
    const h = n?.(c, l, u) || {}, d = {
      ...r,
      lang: u,
      meta: {
        ...r.meta,
        ...h,
        __raw: c
      }
    }, p = [];
    return p.push({
      name: "@shikijs/markdown-it:block-class",
      code(g) {
        g.properties.class = `language-${u}`;
      }
    }), i && l.endsWith(`
`) && (l = l.slice(0, -1)), e.codeToHtml(
      l,
      {
        ...d,
        transformers: [
          ...p,
          ...d.transformers || []
        ]
      }
    );
  };
}
function Fue(t, e) {
  return function(r) {
    Oue(r, t, e);
  };
}
let ah = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
}, tS = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function Tue() {
  return 2147483648;
}
function Mue() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const Pue = (t, e) => t + (e - t % e) % e;
async function Rue(t) {
  let e, r;
  const n = {};
  function i(p) {
    r = p, n.HEAPU8 = new Uint8Array(p), n.HEAPU32 = new Uint32Array(p);
  }
  function o(p, g, v) {
    n.HEAPU8.copyWithin(p, g, g + v);
  }
  function s(p) {
    try {
      return e.grow(p - r.byteLength + 65535 >>> 16), i(e.buffer), 1;
    } catch {
    }
  }
  function a(p) {
    const g = n.HEAPU8.length;
    p = p >>> 0;
    const v = Tue();
    if (p > v)
      return !1;
    for (let y = 1; y <= 4; y *= 2) {
      let b = g * (1 + 0.2 / y);
      b = Math.min(b, p + 100663296);
      const k = Math.min(v, Pue(Math.max(p, b), 65536));
      if (s(k))
        return !0;
    }
    return !1;
  }
  const l = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function u(p, g, v = 1024) {
    const y = g + v;
    let b = g;
    for (; p[b] && !(b >= y); )
      ++b;
    if (b - g > 16 && p.buffer && l)
      return l.decode(p.subarray(g, b));
    let k = "";
    for (; g < b; ) {
      let C = p[g++];
      if (!(C & 128)) {
        k += String.fromCharCode(C);
        continue;
      }
      const S = p[g++] & 63;
      if ((C & 224) === 192) {
        k += String.fromCharCode((C & 31) << 6 | S);
        continue;
      }
      const _ = p[g++] & 63;
      if ((C & 240) === 224 ? C = (C & 15) << 12 | S << 6 | _ : C = (C & 7) << 18 | S << 12 | _ << 6 | p[g++] & 63, C < 65536)
        k += String.fromCharCode(C);
      else {
        const D = C - 65536;
        k += String.fromCharCode(55296 | D >> 10, 56320 | D & 1023);
      }
    }
    return k;
  }
  function c(p, g) {
    return p ? u(n.HEAPU8, p, g) : "";
  }
  const h = {
    emscripten_get_now: Mue,
    emscripten_memcpy_big: o,
    emscripten_resize_heap: a,
    fd_write: () => 0
  };
  async function d() {
    const p = await t({
      env: h,
      wasi_snapshot_preview1: h
    });
    e = p.memory, i(e.buffer), Object.assign(n, p), n.UTF8ToString = c;
  }
  return await d(), n;
}
var Nue = Object.defineProperty, $ue = (t, e, r) => e in t ? Nue(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, En = (t, e, r) => ($ue(t, typeof e != "symbol" ? e + "" : e, r), r);
let Rn = null;
function Iue(t) {
  throw new tS(t.UTF8ToString(t.getLastOnigError()));
}
class ex {
  constructor(e) {
    En(this, "utf16Length"), En(this, "utf8Length"), En(this, "utf16Value"), En(this, "utf8Value"), En(this, "utf16OffsetToUtf8"), En(this, "utf8OffsetToUtf16");
    const r = e.length, n = ex._utf8ByteLength(e), i = n !== r, o = i ? new Uint32Array(r + 1) : null;
    i && (o[r] = n);
    const s = i ? new Uint32Array(n + 1) : null;
    i && (s[n] = r);
    const a = new Uint8Array(n);
    let l = 0;
    for (let u = 0; u < r; u++) {
      const c = e.charCodeAt(u);
      let h = c, d = !1;
      if (c >= 55296 && c <= 56319 && u + 1 < r) {
        const p = e.charCodeAt(u + 1);
        p >= 56320 && p <= 57343 && (h = (c - 55296 << 10) + 65536 | p - 56320, d = !0);
      }
      i && (o[u] = l, d && (o[u + 1] = l), h <= 127 ? s[l + 0] = u : h <= 2047 ? (s[l + 0] = u, s[l + 1] = u) : h <= 65535 ? (s[l + 0] = u, s[l + 1] = u, s[l + 2] = u) : (s[l + 0] = u, s[l + 1] = u, s[l + 2] = u, s[l + 3] = u)), h <= 127 ? a[l++] = h : h <= 2047 ? (a[l++] = 192 | (h & 1984) >>> 6, a[l++] = 128 | (h & 63) >>> 0) : h <= 65535 ? (a[l++] = 224 | (h & 61440) >>> 12, a[l++] = 128 | (h & 4032) >>> 6, a[l++] = 128 | (h & 63) >>> 0) : (a[l++] = 240 | (h & 1835008) >>> 18, a[l++] = 128 | (h & 258048) >>> 12, a[l++] = 128 | (h & 4032) >>> 6, a[l++] = 128 | (h & 63) >>> 0), d && u++;
    }
    this.utf16Length = r, this.utf8Length = n, this.utf16Value = e, this.utf8Value = a, this.utf16OffsetToUtf8 = o, this.utf8OffsetToUtf16 = s;
  }
  static _utf8ByteLength(e) {
    let r = 0;
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e.charCodeAt(n);
      let s = o, a = !1;
      if (o >= 55296 && o <= 56319 && n + 1 < i) {
        const l = e.charCodeAt(n + 1);
        l >= 56320 && l <= 57343 && (s = (o - 55296 << 10) + 65536 | l - 56320, a = !0);
      }
      s <= 127 ? r += 1 : s <= 2047 ? r += 2 : s <= 65535 ? r += 3 : r += 4, a && n++;
    }
    return r;
  }
  createString(e) {
    const r = e.omalloc(this.utf8Length);
    return e.HEAPU8.set(this.utf8Value, r), r;
  }
}
const ya = class {
  constructor(t) {
    if (En(this, "id", ++ya.LAST_ID), En(this, "_onigBinding"), En(this, "content"), En(this, "utf16Length"), En(this, "utf8Length"), En(this, "utf16OffsetToUtf8"), En(this, "utf8OffsetToUtf16"), En(this, "ptr"), !Rn)
      throw new tS("Must invoke loadWasm first.");
    this._onigBinding = Rn, this.content = t;
    const e = new ex(t);
    this.utf16Length = e.utf16Length, this.utf8Length = e.utf8Length, this.utf16OffsetToUtf8 = e.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = e.utf8OffsetToUtf16, this.utf8Length < 1e4 && !ya._sharedPtrInUse ? (ya._sharedPtr || (ya._sharedPtr = Rn.omalloc(1e4)), ya._sharedPtrInUse = !0, Rn.HEAPU8.set(e.utf8Value, ya._sharedPtr), this.ptr = ya._sharedPtr) : this.ptr = e.createString(Rn);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === ya._sharedPtr ? ya._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
let c0 = ya;
En(c0, "LAST_ID", 0);
En(c0, "_sharedPtr", 0);
En(c0, "_sharedPtrInUse", !1);
class Bue {
  constructor(e) {
    if (En(this, "_onigBinding"), En(this, "_ptr"), !Rn)
      throw new tS("Must invoke loadWasm first.");
    const r = [], n = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = new ex(e[a]);
      r[a] = u.createString(Rn), n[a] = u.utf8Length;
    }
    const i = Rn.omalloc(4 * e.length);
    Rn.HEAPU32.set(r, i / 4);
    const o = Rn.omalloc(4 * e.length);
    Rn.HEAPU32.set(n, o / 4);
    const s = Rn.createOnigScanner(i, o, e.length);
    for (let a = 0, l = e.length; a < l; a++)
      Rn.ofree(r[a]);
    Rn.ofree(o), Rn.ofree(i), s === 0 && Iue(Rn), this._onigBinding = Rn, this._ptr = s;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(e, r, n) {
    let i = 0;
    if (typeof n == "number" && (i = n), typeof e == "string") {
      e = new c0(e);
      const o = this._findNextMatchSync(e, r, !1, i);
      return e.dispose(), o;
    }
    return this._findNextMatchSync(e, r, !1, i);
  }
  _findNextMatchSync(e, r, n, i) {
    const o = this._onigBinding, s = o.findNextOnigScannerMatch(this._ptr, e.id, e.ptr, e.utf8Length, e.convertUtf16OffsetToUtf8(r), i);
    if (s === 0)
      return null;
    const a = o.HEAPU32;
    let l = s / 4;
    const u = a[l++], c = a[l++], h = [];
    for (let d = 0; d < c; d++) {
      const p = e.convertUtf8OffsetToUtf16(a[l++]), g = e.convertUtf8OffsetToUtf16(a[l++]);
      h[d] = {
        start: p,
        end: g,
        length: g - p
      };
    }
    return {
      index: u,
      captureIndices: h
    };
  }
}
function Lue(t) {
  return typeof t.instantiator == "function";
}
function zue(t) {
  return typeof t.default == "function";
}
function jue(t) {
  return typeof t.data < "u";
}
function que(t) {
  return typeof Response < "u" && t instanceof Response;
}
function Uue(t) {
  return typeof ArrayBuffer < "u" && (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) || typeof Buffer < "u" && Buffer.isBuffer?.(t) || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer || typeof Uint32Array < "u" && t instanceof Uint32Array;
}
let ty;
function Hue(t) {
  if (ty)
    return ty;
  async function e() {
    Rn = await Rue(async (r) => {
      let n = t;
      return n = await n, typeof n == "function" && (n = await n(r)), typeof n == "function" && (n = await n(r)), Lue(n) ? n = await n.instantiator(r) : zue(n) ? n = await n.default(r) : (jue(n) && (n = n.data), que(n) ? typeof WebAssembly.instantiateStreaming == "function" ? n = await Vue(n)(r) : n = await Wue(n)(r) : Uue(n) ? n = await rk(n)(r) : n instanceof WebAssembly.Module ? n = await rk(n)(r) : "default" in n && n.default instanceof WebAssembly.Module && (n = await rk(n.default)(r))), "instance" in n && (n = n.instance), "exports" in n && (n = n.exports), n;
    });
  }
  return ty = e(), ty;
}
function rk(t) {
  return (e) => WebAssembly.instantiate(t, e);
}
function Vue(t) {
  return (e) => WebAssembly.instantiateStreaming(t, e);
}
function Wue(t) {
  return async (e) => {
    const r = await t.arrayBuffer();
    return WebAssembly.instantiate(r, e);
  };
}
let Gue;
function Kue() {
  return Gue;
}
async function Xue(t) {
  return t && await Hue(t), {
    createScanner(e) {
      return new Bue(e.map((r) => typeof r == "string" ? r : r.source));
    },
    createString(e) {
      return new c0(e);
    }
  };
}
function Que(t) {
  return rS(t);
}
function rS(t) {
  return Array.isArray(t) ? Jue(t) : t instanceof RegExp ? t : typeof t == "object" ? Yue(t) : t;
}
function Jue(t) {
  let e = [];
  for (let r = 0, n = t.length; r < n; r++)
    e[r] = rS(t[r]);
  return e;
}
function Yue(t) {
  let e = {};
  for (let r in t)
    e[r] = rS(t[r]);
  return e;
}
function r$(t, ...e) {
  return e.forEach((r) => {
    for (let n in r)
      t[n] = r[n];
  }), t;
}
function n$(t) {
  const e = ~t.lastIndexOf("/") || ~t.lastIndexOf("\\");
  return e === 0 ? t : ~e === t.length - 1 ? n$(t.substring(0, t.length - 1)) : t.substr(~e + 1);
}
var nk = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, ry = class {
  static hasCaptures(t) {
    return t === null ? !1 : (nk.lastIndex = 0, nk.test(t));
  }
  static replaceCaptures(t, e, r) {
    return t.replace(nk, (n, i, o, s) => {
      let a = r[parseInt(i || o, 10)];
      if (a) {
        let l = e.substring(a.start, a.end);
        for (; l[0] === "."; )
          l = l.substring(1);
        switch (s) {
          case "downcase":
            return l.toLowerCase();
          case "upcase":
            return l.toUpperCase();
          default:
            return l;
        }
      } else
        return n;
    });
  }
};
function i$(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function o$(t, e) {
  if (t === null && e === null)
    return 0;
  if (!t)
    return -1;
  if (!e)
    return 1;
  let r = t.length, n = e.length;
  if (r === n) {
    for (let i = 0; i < r; i++) {
      let o = i$(t[i], e[i]);
      if (o !== 0)
        return o;
    }
    return 0;
  }
  return r - n;
}
function D7(t) {
  return !!(/^#[0-9a-f]{6}$/i.test(t) || /^#[0-9a-f]{8}$/i.test(t) || /^#[0-9a-f]{3}$/i.test(t) || /^#[0-9a-f]{4}$/i.test(t));
}
function s$(t) {
  return t.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var a$ = class {
  constructor(t) {
    this.fn = t;
  }
  cache = /* @__PURE__ */ new Map();
  get(t) {
    if (this.cache.has(t))
      return this.cache.get(t);
    const e = this.fn(t);
    return this.cache.set(t, e), e;
  }
}, j1 = class {
  constructor(t, e, r) {
    this._colorMap = t, this._defaults = e, this._root = r;
  }
  static createFromRawTheme(t, e) {
    return this.createFromParsedTheme(tce(t), e);
  }
  static createFromParsedTheme(t, e) {
    return nce(t, e);
  }
  _cachedMatchRoot = new a$(
    (t) => this._root.match(t)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(t) {
    if (t === null)
      return this._defaults;
    const e = t.scopeName, r = this._cachedMatchRoot.get(e).find(
      (n) => Zue(t.parent, n.parentScopes)
    );
    return r ? new l$(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, ik = class Vy {
  constructor(e, r) {
    this.parent = e, this.scopeName = r;
  }
  static push(e, r) {
    for (const n of r)
      e = new Vy(e, n);
    return e;
  }
  static from(...e) {
    let r = null;
    for (let n = 0; n < e.length; n++)
      r = new Vy(r, e[n]);
    return r;
  }
  push(e) {
    return new Vy(this, e);
  }
  getSegments() {
    let e = this;
    const r = [];
    for (; e; )
      r.push(e.scopeName), e = e.parent;
    return r.reverse(), r;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(e) {
    return this === e ? !0 : this.parent === null ? !1 : this.parent.extends(e);
  }
  getExtensionIfDefined(e) {
    const r = [];
    let n = this;
    for (; n && n !== e; )
      r.push(n.scopeName), n = n.parent;
    return n === e ? r.reverse() : void 0;
  }
};
function Zue(t, e) {
  if (e.length === 0)
    return !0;
  for (let r = 0; r < e.length; r++) {
    let n = e[r], i = !1;
    if (n === ">") {
      if (r === e.length - 1)
        return !1;
      n = e[++r], i = !0;
    }
    for (; t && !ece(t.scopeName, n); ) {
      if (i)
        return !1;
      t = t.parent;
    }
    if (!t)
      return !1;
    t = t.parent;
  }
  return !0;
}
function ece(t, e) {
  return e === t || t.startsWith(e) && t[e.length] === ".";
}
var l$ = class {
  constructor(t, e, r) {
    this.fontStyle = t, this.foregroundId = e, this.backgroundId = r;
  }
};
function tce(t) {
  if (!t)
    return [];
  if (!t.settings || !Array.isArray(t.settings))
    return [];
  let e = t.settings, r = [], n = 0;
  for (let i = 0, o = e.length; i < o; i++) {
    let s = e[i];
    if (!s.settings)
      continue;
    let a;
    if (typeof s.scope == "string") {
      let h = s.scope;
      h = h.replace(/^[,]+/, ""), h = h.replace(/[,]+$/, ""), a = h.split(",");
    } else Array.isArray(s.scope) ? a = s.scope : a = [""];
    let l = -1;
    if (typeof s.settings.fontStyle == "string") {
      l = 0;
      let h = s.settings.fontStyle.split(" ");
      for (let d = 0, p = h.length; d < p; d++)
        switch (h[d]) {
          case "italic":
            l = l | 1;
            break;
          case "bold":
            l = l | 2;
            break;
          case "underline":
            l = l | 4;
            break;
          case "strikethrough":
            l = l | 8;
            break;
        }
    }
    let u = null;
    typeof s.settings.foreground == "string" && D7(s.settings.foreground) && (u = s.settings.foreground);
    let c = null;
    typeof s.settings.background == "string" && D7(s.settings.background) && (c = s.settings.background);
    for (let h = 0, d = a.length; h < d; h++) {
      let p = a[h].trim().split(" "), g = p[p.length - 1], v = null;
      p.length > 1 && (v = p.slice(0, p.length - 1), v.reverse()), r[n++] = new rce(
        g,
        v,
        i,
        l,
        u,
        c
      );
    }
  }
  return r;
}
var rce = class {
  constructor(t, e, r, n, i, o) {
    this.scope = t, this.parentScopes = e, this.index = r, this.fontStyle = n, this.foreground = i, this.background = o;
  }
}, Ll = /* @__PURE__ */ ((t) => (t[t.NotSet = -1] = "NotSet", t[t.None = 0] = "None", t[t.Italic = 1] = "Italic", t[t.Bold = 2] = "Bold", t[t.Underline = 4] = "Underline", t[t.Strikethrough = 8] = "Strikethrough", t))(Ll || {});
function nce(t, e) {
  t.sort((l, u) => {
    let c = i$(l.scope, u.scope);
    return c !== 0 || (c = o$(l.parentScopes, u.parentScopes), c !== 0) ? c : l.index - u.index;
  });
  let r = 0, n = "#000000", i = "#ffffff";
  for (; t.length >= 1 && t[0].scope === ""; ) {
    let l = t.shift();
    l.fontStyle !== -1 && (r = l.fontStyle), l.foreground !== null && (n = l.foreground), l.background !== null && (i = l.background);
  }
  let o = new ice(e), s = new l$(r, o.getId(n), o.getId(i)), a = new sce(new EC(0, null, -1, 0, 0), []);
  for (let l = 0, u = t.length; l < u; l++) {
    let c = t[l];
    a.insert(0, c.scope, c.parentScopes, c.fontStyle, o.getId(c.foreground), o.getId(c.background));
  }
  return new j1(o, s, a);
}
var ice = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(t) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(t)) {
      this._isFrozen = !0;
      for (let e = 0, r = t.length; e < r; e++)
        this._color2id[t[e]] = e, this._id2color[e] = t[e];
    } else
      this._isFrozen = !1;
  }
  getId(t) {
    if (t === null)
      return 0;
    t = t.toUpperCase();
    let e = this._color2id[t];
    if (e)
      return e;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${t}`);
    return e = ++this._lastColorId, this._color2id[t] = e, this._id2color[e] = t, e;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, oce = Object.freeze([]), EC = class u$ {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(e, r, n, i, o) {
    this.scopeDepth = e, this.parentScopes = r || oce, this.fontStyle = n, this.foreground = i, this.background = o;
  }
  clone() {
    return new u$(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(e) {
    let r = [];
    for (let n = 0, i = e.length; n < i; n++)
      r[n] = e[n].clone();
    return r;
  }
  acceptOverwrite(e, r, n, i) {
    this.scopeDepth > e ? console.log("how did this happen?") : this.scopeDepth = e, r !== -1 && (this.fontStyle = r), n !== 0 && (this.foreground = n), i !== 0 && (this.background = i);
  }
}, sce = class DC {
  constructor(e, r = [], n = {}) {
    this._mainRule = e, this._children = n, this._rulesWithParentScopes = r;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(e, r) {
    if (e.scopeDepth !== r.scopeDepth)
      return r.scopeDepth - e.scopeDepth;
    let n = 0, i = 0;
    for (; e.parentScopes[n] === ">" && n++, r.parentScopes[i] === ">" && i++, !(n >= e.parentScopes.length || i >= r.parentScopes.length); ) {
      const o = r.parentScopes[i].length - e.parentScopes[n].length;
      if (o !== 0)
        return o;
      n++, i++;
    }
    return r.parentScopes.length - e.parentScopes.length;
  }
  match(e) {
    if (e !== "") {
      let n = e.indexOf("."), i, o;
      if (n === -1 ? (i = e, o = "") : (i = e.substring(0, n), o = e.substring(n + 1)), this._children.hasOwnProperty(i))
        return this._children[i].match(o);
    }
    const r = this._rulesWithParentScopes.concat(this._mainRule);
    return r.sort(DC._cmpBySpecificity), r;
  }
  insert(e, r, n, i, o, s) {
    if (r === "") {
      this._doInsertHere(e, n, i, o, s);
      return;
    }
    let a = r.indexOf("."), l, u;
    a === -1 ? (l = r, u = "") : (l = r.substring(0, a), u = r.substring(a + 1));
    let c;
    this._children.hasOwnProperty(l) ? c = this._children[l] : (c = new DC(this._mainRule.clone(), EC.cloneArr(this._rulesWithParentScopes)), this._children[l] = c), c.insert(e + 1, u, n, i, o, s);
  }
  _doInsertHere(e, r, n, i, o) {
    if (r === null) {
      this._mainRule.acceptOverwrite(e, n, i, o);
      return;
    }
    for (let s = 0, a = this._rulesWithParentScopes.length; s < a; s++) {
      let l = this._rulesWithParentScopes[s];
      if (o$(l.parentScopes, r) === 0) {
        l.acceptOverwrite(e, n, i, o);
        return;
      }
    }
    n === -1 && (n = this._mainRule.fontStyle), i === 0 && (i = this._mainRule.foreground), o === 0 && (o = this._mainRule.background), this._rulesWithParentScopes.push(new EC(e, r, n, i, o));
  }
}, Td = class ls {
  static toBinaryStr(e) {
    return e.toString(2).padStart(32, "0");
  }
  static print(e) {
    const r = ls.getLanguageId(e), n = ls.getTokenType(e), i = ls.getFontStyle(e), o = ls.getForeground(e), s = ls.getBackground(e);
    console.log({
      languageId: r,
      tokenType: n,
      fontStyle: i,
      foreground: o,
      background: s
    });
  }
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(e, r, n, i, o, s, a) {
    let l = ls.getLanguageId(e), u = ls.getTokenType(e), c = ls.containsBalancedBrackets(e) ? 1 : 0, h = ls.getFontStyle(e), d = ls.getForeground(e), p = ls.getBackground(e);
    return r !== 0 && (l = r), n !== 8 && (u = n), i !== null && (c = i ? 1 : 0), o !== -1 && (h = o), s !== 0 && (d = s), a !== 0 && (p = a), (l << 0 | u << 8 | c << 10 | h << 11 | d << 15 | p << 24) >>> 0;
  }
};
function q1(t, e) {
  const r = [], n = ace(t);
  let i = n.next();
  for (; i !== null; ) {
    let l = 0;
    if (i.length === 2 && i.charAt(1) === ":") {
      switch (i.charAt(0)) {
        case "R":
          l = 1;
          break;
        case "L":
          l = -1;
          break;
        default:
          console.log(`Unknown priority ${i} in scope selector`);
      }
      i = n.next();
    }
    let u = s();
    if (r.push({ matcher: u, priority: l }), i !== ",")
      break;
    i = n.next();
  }
  return r;
  function o() {
    if (i === "-") {
      i = n.next();
      const l = o();
      return (u) => !!l && !l(u);
    }
    if (i === "(") {
      i = n.next();
      const l = a();
      return i === ")" && (i = n.next()), l;
    }
    if (O7(i)) {
      const l = [];
      do
        l.push(i), i = n.next();
      while (O7(i));
      return (u) => e(l, u);
    }
    return null;
  }
  function s() {
    const l = [];
    let u = o();
    for (; u; )
      l.push(u), u = o();
    return (c) => l.every((h) => h(c));
  }
  function a() {
    const l = [];
    let u = s();
    for (; u && (l.push(u), i === "|" || i === ","); ) {
      do
        i = n.next();
      while (i === "|" || i === ",");
      u = s();
    }
    return (c) => l.some((h) => h(c));
  }
}
function O7(t) {
  return !!t && !!t.match(/[\w\.:]+/);
}
function ace(t) {
  let e = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, r = e.exec(t);
  return {
    next: () => {
      if (!r)
        return null;
      const n = r[0];
      return r = e.exec(t), n;
    }
  };
}
function c$(t) {
  typeof t.dispose == "function" && t.dispose();
}
var Cg = class {
  constructor(t) {
    this.scopeName = t;
  }
  toKey() {
    return this.scopeName;
  }
}, lce = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, uce = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(t) {
    const e = t.toKey();
    this._seenReferenceKeys.has(e) || (this._seenReferenceKeys.add(e), this._references.push(t));
  }
}, cce = class {
  constructor(t, e) {
    this.repo = t, this.initialScopeName = e, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new Cg(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const t = this.Q;
    this.Q = [];
    const e = new uce();
    for (const r of t)
      hce(r, this.initialScopeName, this.repo, e);
    for (const r of e.references)
      if (r instanceof Cg) {
        if (this.seenFullScopeRequests.has(r.scopeName))
          continue;
        this.seenFullScopeRequests.add(r.scopeName), this.Q.push(r);
      } else {
        if (this.seenFullScopeRequests.has(r.scopeName) || this.seenPartialScopeRequests.has(r.toKey()))
          continue;
        this.seenPartialScopeRequests.add(r.toKey()), this.Q.push(r);
      }
  }
};
function hce(t, e, r, n) {
  const i = r.lookup(t.scopeName);
  if (!i) {
    if (t.scopeName === e)
      throw new Error(`No grammar provided for <${e}>`);
    return;
  }
  const o = r.lookup(e);
  t instanceof Cg ? Wy({ baseGrammar: o, selfGrammar: i }, n) : OC(
    t.ruleName,
    { baseGrammar: o, selfGrammar: i, repository: i.repository },
    n
  );
  const s = r.injections(t.scopeName);
  if (s)
    for (const a of s)
      n.add(new Cg(a));
}
function OC(t, e, r) {
  if (e.repository && e.repository[t]) {
    const n = e.repository[t];
    U1([n], e, r);
  }
}
function Wy(t, e) {
  t.selfGrammar.patterns && Array.isArray(t.selfGrammar.patterns) && U1(
    t.selfGrammar.patterns,
    { ...t, repository: t.selfGrammar.repository },
    e
  ), t.selfGrammar.injections && U1(
    Object.values(t.selfGrammar.injections),
    { ...t, repository: t.selfGrammar.repository },
    e
  );
}
function U1(t, e, r) {
  for (const n of t) {
    if (r.visitedRule.has(n))
      continue;
    r.visitedRule.add(n);
    const i = n.repository ? r$({}, e.repository, n.repository) : e.repository;
    Array.isArray(n.patterns) && U1(n.patterns, { ...e, repository: i }, r);
    const o = n.include;
    if (!o)
      continue;
    const s = h$(o);
    switch (s.kind) {
      case 0:
        Wy({ ...e, selfGrammar: e.baseGrammar }, r);
        break;
      case 1:
        Wy(e, r);
        break;
      case 2:
        OC(s.ruleName, { ...e, repository: i }, r);
        break;
      case 3:
      case 4:
        const a = s.scopeName === e.selfGrammar.scopeName ? e.selfGrammar : s.scopeName === e.baseGrammar.scopeName ? e.baseGrammar : void 0;
        if (a) {
          const l = { baseGrammar: e.baseGrammar, selfGrammar: a, repository: i };
          s.kind === 4 ? OC(s.ruleName, l, r) : Wy(l, r);
        } else
          s.kind === 4 ? r.add(new lce(s.scopeName, s.ruleName)) : r.add(new Cg(s.scopeName));
        break;
    }
  }
}
var fce = class {
  kind = 0;
}, dce = class {
  kind = 1;
}, pce = class {
  constructor(t) {
    this.ruleName = t;
  }
  kind = 2;
}, mce = class {
  constructor(t) {
    this.scopeName = t;
  }
  kind = 3;
}, gce = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  kind = 4;
};
function h$(t) {
  if (t === "$base")
    return new fce();
  if (t === "$self")
    return new dce();
  const e = t.indexOf("#");
  if (e === -1)
    return new mce(t);
  if (e === 0)
    return new pce(t.substring(1));
  {
    const r = t.substring(0, e), n = t.substring(e + 1);
    return new gce(r, n);
  }
}
var vce = /\\(\d+)/, F7 = /\\(\d+)/g, yce = -1, f$ = -2, h0 = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(t, e, r, n) {
    this.$location = t, this.id = e, this._name = r || null, this._nameIsCapturing = ry.hasCaptures(this._name), this._contentName = n || null, this._contentNameIsCapturing = ry.hasCaptures(this._contentName);
  }
  get debugName() {
    const t = this.$location ? `${n$(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${t}`;
  }
  getName(t, e) {
    return !this._nameIsCapturing || this._name === null || t === null || e === null ? this._name : ry.replaceCaptures(this._name, t, e);
  }
  getContentName(t, e) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : ry.replaceCaptures(this._contentName, t, e);
  }
}, bce = class extends h0 {
  retokenizeCapturedWithRuleId;
  constructor(t, e, r, n, i) {
    super(t, e, r, n), this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(t, e) {
    throw new Error("Not supported!");
  }
  compile(t, e) {
    throw new Error("Not supported!");
  }
  compileAG(t, e, r, n) {
    throw new Error("Not supported!");
  }
}, xce = class extends h0 {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(t, e, r, n, i) {
    super(t, e, r, null), this._match = new _g(n, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(t, e) {
    e.push(this._match);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Sg(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, T7 = class extends h0 {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, r, n, i) {
    super(t, e, r, n), this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(t, e) {
    for (const r of this.patterns)
      t.getRule(r).collectPatterns(t, e);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Sg(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, FC = class extends h0 {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, r, n, i, o, s, a, l, u) {
    super(t, e, r, n), this._begin = new _g(i, this.id), this.beginCaptures = o, this._end = new _g(s || "ï¿¿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = a, this.applyEndPatternLast = l || !1, this.patterns = u.patterns, this.hasMissingPatterns = u.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(t, e) {
    return this._end.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t, e).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t, e).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t, e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Sg();
      for (const r of this.patterns)
        t.getRule(r).collectPatterns(t, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, e) : this._cachedCompiledPatterns.setSource(0, e)), this._cachedCompiledPatterns;
  }
}, H1 = class extends h0 {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(t, e, r, n, i, o, s, a, l) {
    super(t, e, r, n), this._begin = new _g(i, this.id), this.beginCaptures = o, this.whileCaptures = a, this._while = new _g(s, f$), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = l.patterns, this.hasMissingPatterns = l.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(t, e) {
    return this._while.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, r, n) {
    return this._getCachedCompiledPatterns(t).compileAG(t, r, n);
  }
  _getCachedCompiledPatterns(t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Sg();
      for (const e of this.patterns)
        t.getRule(e).collectPatterns(t, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(t, e) {
    return this._getCachedCompiledWhilePatterns(t, e).compile(t);
  }
  compileWhileAG(t, e, r, n) {
    return this._getCachedCompiledWhilePatterns(t, e).compileAG(t, r, n);
  }
  _getCachedCompiledWhilePatterns(t, e) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new Sg(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, e || "ï¿¿"), this._cachedCompiledWhilePatterns;
  }
}, d$ = class Zn {
  static createCaptureRule(e, r, n, i, o) {
    return e.registerRule((s) => new bce(r, s, n, i, o));
  }
  static getCompiledRuleId(e, r, n) {
    return e.id || r.registerRule((i) => {
      if (e.id = i, e.match)
        return new xce(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.match,
          Zn._compileCaptures(e.captures, r, n)
        );
      if (typeof e.begin > "u") {
        e.repository && (n = r$({}, n, e.repository));
        let o = e.patterns;
        return typeof o > "u" && e.include && (o = [{ include: e.include }]), new T7(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.contentName,
          Zn._compilePatterns(o, r, n)
        );
      }
      return e.while ? new H1(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Zn._compileCaptures(e.beginCaptures || e.captures, r, n),
        e.while,
        Zn._compileCaptures(e.whileCaptures || e.captures, r, n),
        Zn._compilePatterns(e.patterns, r, n)
      ) : new FC(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Zn._compileCaptures(e.beginCaptures || e.captures, r, n),
        e.end,
        Zn._compileCaptures(e.endCaptures || e.captures, r, n),
        e.applyEndPatternLast,
        Zn._compilePatterns(e.patterns, r, n)
      );
    }), e.id;
  }
  static _compileCaptures(e, r, n) {
    let i = [];
    if (e) {
      let o = 0;
      for (const s in e) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        a > o && (o = a);
      }
      for (let s = 0; s <= o; s++)
        i[s] = null;
      for (const s in e) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        let l = 0;
        e[s].patterns && (l = Zn.getCompiledRuleId(e[s], r, n)), i[a] = Zn.createCaptureRule(r, e[s].$vscodeTextmateLocation, e[s].name, e[s].contentName, l);
      }
    }
    return i;
  }
  static _compilePatterns(e, r, n) {
    let i = [];
    if (e)
      for (let o = 0, s = e.length; o < s; o++) {
        const a = e[o];
        let l = -1;
        if (a.include) {
          const u = h$(a.include);
          switch (u.kind) {
            case 0:
            case 1:
              l = Zn.getCompiledRuleId(n[a.include], r, n);
              break;
            case 2:
              let c = n[u.ruleName];
              c && (l = Zn.getCompiledRuleId(c, r, n));
              break;
            case 3:
            case 4:
              const h = u.scopeName, d = u.kind === 4 ? u.ruleName : null, p = r.getExternalGrammar(h, n);
              if (p)
                if (d) {
                  let g = p.repository[d];
                  g && (l = Zn.getCompiledRuleId(g, r, p.repository));
                } else
                  l = Zn.getCompiledRuleId(p.repository.$self, r, p.repository);
              break;
          }
        } else
          l = Zn.getCompiledRuleId(a, r, n);
        if (l !== -1) {
          const u = r.getRule(l);
          let c = !1;
          if ((u instanceof T7 || u instanceof FC || u instanceof H1) && u.hasMissingPatterns && u.patterns.length === 0 && (c = !0), c)
            continue;
          i.push(l);
        }
      }
    return {
      patterns: i,
      hasMissingPatterns: (e ? e.length : 0) !== i.length
    };
  }
}, _g = class p$ {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(e, r) {
    if (e && typeof e == "string") {
      const n = e.length;
      let i = 0, o = [], s = !1;
      for (let a = 0; a < n; a++)
        if (e.charAt(a) === "\\" && a + 1 < n) {
          const l = e.charAt(a + 1);
          l === "z" ? (o.push(e.substring(i, a)), o.push("$(?!\\n)(?<!\\n)"), i = a + 2) : (l === "A" || l === "G") && (s = !0), a++;
        }
      this.hasAnchor = s, i === 0 ? this.source = e : (o.push(e.substring(i, n)), this.source = o.join(""));
    } else
      this.hasAnchor = !1, this.source = e;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = r, typeof this.source == "string" ? this.hasBackReferences = vce.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new p$(this.source, this.ruleId);
  }
  setSource(e) {
    this.source !== e && (this.source = e, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(e, r) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let n = r.map((i) => e.substring(i.start, i.end));
    return F7.lastIndex = 0, this.source.replace(F7, (i, o) => s$(n[parseInt(o, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let e = [], r = [], n = [], i = [], o, s, a, l;
    for (o = 0, s = this.source.length; o < s; o++)
      a = this.source.charAt(o), e[o] = a, r[o] = a, n[o] = a, i[o] = a, a === "\\" && o + 1 < s && (l = this.source.charAt(o + 1), l === "A" ? (e[o + 1] = "ï¿¿", r[o + 1] = "ï¿¿", n[o + 1] = "A", i[o + 1] = "A") : l === "G" ? (e[o + 1] = "ï¿¿", r[o + 1] = "G", n[o + 1] = "ï¿¿", i[o + 1] = "G") : (e[o + 1] = l, r[o + 1] = l, n[o + 1] = l, i[o + 1] = l), o++);
    return {
      A0_G0: e.join(""),
      A0_G1: r.join(""),
      A1_G0: n.join(""),
      A1_G1: i.join("")
    };
  }
  resolveAnchors(e, r) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : e ? r ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : r ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, Sg = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(t) {
    this._items.push(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  unshift(t) {
    this._items.unshift(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(t, e) {
    this._items[t].source !== e && (this._disposeCaches(), this._items[t].setSource(e));
  }
  compile(t) {
    if (!this._cached) {
      let e = this._items.map((r) => r.source);
      this._cached = new M7(t, e, this._items.map((r) => r.ruleId));
    }
    return this._cached;
  }
  compileAG(t, e, r) {
    return this._hasAnchors ? e ? r ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(t, e, r)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(t, e, r)), this._anchorCache.A1_G0) : r ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(t, e, r)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(t, e, r)), this._anchorCache.A0_G0) : this.compile(t);
  }
  _resolveAnchors(t, e, r) {
    let n = this._items.map((i) => i.resolveAnchors(e, r));
    return new M7(t, n, this._items.map((i) => i.ruleId));
  }
}, M7 = class {
  constructor(t, e, r) {
    this.regExps = e, this.rules = r, this.scanner = t.createOnigScanner(e);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const t = [];
    for (let e = 0, r = this.rules.length; e < r; e++)
      t.push("   - " + this.rules[e] + ": " + this.regExps[e]);
    return t.join(`
`);
  }
  findNextMatchSync(t, e, r) {
    const n = this.scanner.findNextMatchSync(t, e, r);
    return n ? {
      ruleId: this.rules[n.index],
      captureIndices: n.captureIndices
    } : null;
  }
}, ok = class {
  constructor(t, e) {
    this.languageId = t, this.tokenType = e;
  }
}, wce = class TC {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(e, r) {
    this._defaultAttributes = new ok(
      e,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new kce(Object.entries(r || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(e) {
    return e === null ? TC._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(e);
  }
  static _NULL_SCOPE_METADATA = new ok(0, 0);
  _getBasicScopeAttributes = new a$((e) => {
    const r = this._scopeToLanguage(e), n = this._toStandardTokenType(e);
    return new ok(r, n);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(e) {
    return this._embeddedLanguagesMatcher.match(e) || 0;
  }
  _toStandardTokenType(e) {
    const r = e.match(TC.STANDARD_TOKEN_TYPE_REGEXP);
    if (!r)
      return 8;
    switch (r[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, kce = class {
  values;
  scopesRegExp;
  constructor(t) {
    if (t.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(t);
      const e = t.map(
        ([r, n]) => s$(r)
      );
      e.sort(), e.reverse(), this.scopesRegExp = new RegExp(
        `^((${e.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(t) {
    if (!this.scopesRegExp)
      return;
    const e = t.match(this.scopesRegExp);
    if (e)
      return this.values.get(e[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var P7 = class {
  constructor(t, e) {
    this.stack = t, this.stoppedEarly = e;
  }
};
function m$(t, e, r, n, i, o, s, a) {
  const l = e.content.length;
  let u = !1, c = -1;
  if (s) {
    const p = Cce(
      t,
      e,
      r,
      n,
      i,
      o
    );
    i = p.stack, n = p.linePos, r = p.isFirstLine, c = p.anchorPosition;
  }
  const h = Date.now();
  for (; !u; ) {
    if (a !== 0 && Date.now() - h > a)
      return new P7(i, !0);
    d();
  }
  return new P7(i, !1);
  function d() {
    const p = _ce(
      t,
      e,
      r,
      n,
      i,
      c
    );
    if (!p) {
      o.produce(i, l), u = !0;
      return;
    }
    const g = p.captureIndices, v = p.matchedRuleId, y = g && g.length > 0 ? g[0].end > n : !1;
    if (v === yce) {
      const b = i.getRule(t);
      o.produce(i, g[0].start), i = i.withContentNameScopesList(i.nameScopesList), ym(
        t,
        e,
        r,
        i,
        o,
        b.endCaptures,
        g
      ), o.produce(i, g[0].end);
      const k = i;
      if (i = i.parent, c = k.getAnchorPos(), !y && k.getEnterPos() === n) {
        i = k, o.produce(i, l), u = !0;
        return;
      }
    } else {
      const b = t.getRule(v);
      o.produce(i, g[0].start);
      const k = i, C = b.getName(e.content, g), S = i.contentNameScopesList.pushAttributed(
        C,
        t
      );
      if (i = i.push(
        v,
        n,
        c,
        g[0].end === l,
        null,
        S,
        S
      ), b instanceof FC) {
        const _ = b;
        ym(
          t,
          e,
          r,
          i,
          o,
          _.beginCaptures,
          g
        ), o.produce(i, g[0].end), c = g[0].end;
        const D = _.getContentName(
          e.content,
          g
        ), A = S.pushAttributed(
          D,
          t
        );
        if (i = i.withContentNameScopesList(A), _.endHasBackReferences && (i = i.withEndRule(
          _.getEndWithResolvedBackReferences(
            e.content,
            g
          )
        )), !y && k.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, l), u = !0;
          return;
        }
      } else if (b instanceof H1) {
        const _ = b;
        ym(
          t,
          e,
          r,
          i,
          o,
          _.beginCaptures,
          g
        ), o.produce(i, g[0].end), c = g[0].end;
        const D = _.getContentName(
          e.content,
          g
        ), A = S.pushAttributed(
          D,
          t
        );
        if (i = i.withContentNameScopesList(A), _.whileHasBackReferences && (i = i.withEndRule(
          _.getWhileWithResolvedBackReferences(
            e.content,
            g
          )
        )), !y && k.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, l), u = !0;
          return;
        }
      } else if (ym(
        t,
        e,
        r,
        i,
        o,
        b.captures,
        g
      ), o.produce(i, g[0].end), i = i.pop(), !y) {
        i = i.safePop(), o.produce(i, l), u = !0;
        return;
      }
    }
    g[0].end > n && (n = g[0].end, r = !1);
  }
}
function Cce(t, e, r, n, i, o) {
  let s = i.beginRuleCapturedEOL ? 0 : -1;
  const a = [];
  for (let l = i; l; l = l.pop()) {
    const u = l.getRule(t);
    u instanceof H1 && a.push({
      rule: u,
      stack: l
    });
  }
  for (let l = a.pop(); l; l = a.pop()) {
    const { ruleScanner: u, findOptions: c } = Ece(l.rule, t, l.stack.endRule, r, n === s), h = u.findNextMatchSync(e, n, c);
    if (h) {
      if (h.ruleId !== f$) {
        i = l.stack.pop();
        break;
      }
      h.captureIndices && h.captureIndices.length && (o.produce(l.stack, h.captureIndices[0].start), ym(t, e, r, l.stack, o, l.rule.whileCaptures, h.captureIndices), o.produce(l.stack, h.captureIndices[0].end), s = h.captureIndices[0].end, h.captureIndices[0].end > n && (n = h.captureIndices[0].end, r = !1));
    } else {
      i = l.stack.pop();
      break;
    }
  }
  return { stack: i, linePos: n, anchorPosition: s, isFirstLine: r };
}
function _ce(t, e, r, n, i, o) {
  const s = Sce(t, e, r, n, i, o), a = t.getInjections();
  if (a.length === 0)
    return s;
  const l = Ace(a, t, e, r, n, i, o);
  if (!l)
    return s;
  if (!s)
    return l;
  const u = s.captureIndices[0].start, c = l.captureIndices[0].start;
  return c < u || l.priorityMatch && c === u ? l : s;
}
function Sce(t, e, r, n, i, o) {
  const s = i.getRule(t), { ruleScanner: a, findOptions: l } = g$(s, t, i.endRule, r, n === o), u = a.findNextMatchSync(e, n, l);
  return u ? {
    captureIndices: u.captureIndices,
    matchedRuleId: u.ruleId
  } : null;
}
function Ace(t, e, r, n, i, o, s) {
  let a = Number.MAX_VALUE, l = null, u, c = 0;
  const h = o.contentNameScopesList.getScopeNames();
  for (let d = 0, p = t.length; d < p; d++) {
    const g = t[d];
    if (!g.matcher(h))
      continue;
    const v = e.getRule(g.ruleId), { ruleScanner: y, findOptions: b } = g$(v, e, null, n, i === s), k = y.findNextMatchSync(r, i, b);
    if (!k)
      continue;
    const C = k.captureIndices[0].start;
    if (!(C >= a) && (a = C, l = k.captureIndices, u = k.ruleId, c = g.priority, a === i))
      break;
  }
  return l ? {
    priorityMatch: c === -1,
    captureIndices: l,
    matchedRuleId: u
  } : null;
}
function g$(t, e, r, n, i) {
  return {
    ruleScanner: t.compileAG(e, r, n, i),
    findOptions: 0
    /* None */
  };
}
function Ece(t, e, r, n, i) {
  return {
    ruleScanner: t.compileWhileAG(e, r, n, i),
    findOptions: 0
    /* None */
  };
}
function ym(t, e, r, n, i, o, s) {
  if (o.length === 0)
    return;
  const a = e.content, l = Math.min(o.length, s.length), u = [], c = s[0].end;
  for (let h = 0; h < l; h++) {
    const d = o[h];
    if (d === null)
      continue;
    const p = s[h];
    if (p.length === 0)
      continue;
    if (p.start > c)
      break;
    for (; u.length > 0 && u[u.length - 1].endPos <= p.start; )
      i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
    if (u.length > 0 ? i.produceFromScopes(u[u.length - 1].scopes, p.start) : i.produce(n, p.start), d.retokenizeCapturedWithRuleId) {
      const v = d.getName(a, s), y = n.contentNameScopesList.pushAttributed(v, t), b = d.getContentName(a, s), k = y.pushAttributed(b, t), C = n.push(d.retokenizeCapturedWithRuleId, p.start, -1, !1, null, y, k), S = t.createOnigString(a.substring(0, p.end));
      m$(
        t,
        S,
        r && p.start === 0,
        p.start,
        C,
        i,
        !1,
        /* no time limit */
        0
      ), c$(S);
      continue;
    }
    const g = d.getName(a, s);
    if (g !== null) {
      const v = (u.length > 0 ? u[u.length - 1].scopes : n.contentNameScopesList).pushAttributed(g, t);
      u.push(new Dce(v, p.end));
    }
  }
  for (; u.length > 0; )
    i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
}
var Dce = class {
  scopes;
  endPos;
  constructor(t, e) {
    this.scopes = t, this.endPos = e;
  }
};
function Oce(t, e, r, n, i, o, s, a) {
  return new Tce(
    t,
    e,
    r,
    n,
    i,
    o,
    s,
    a
  );
}
function R7(t, e, r, n, i) {
  const o = q1(e, V1), s = d$.getCompiledRuleId(r, n, i.repository);
  for (const a of o)
    t.push({
      debugSelector: e,
      matcher: a.matcher,
      ruleId: s,
      grammar: i,
      priority: a.priority
    });
}
function V1(t, e) {
  if (e.length < t.length)
    return !1;
  let r = 0;
  return t.every((n) => {
    for (let i = r; i < e.length; i++)
      if (Fce(e[i], n))
        return r = i + 1, !0;
    return !1;
  });
}
function Fce(t, e) {
  if (!t)
    return !1;
  if (t === e)
    return !0;
  const r = e.length;
  return t.length > r && t.substr(0, r) === e && t[r] === ".";
}
var Tce = class {
  constructor(t, e, r, n, i, o, s, a) {
    if (this._rootScopeName = t, this.balancedBracketSelectors = o, this._onigLib = a, this._basicScopeAttributesProvider = new wce(
      r,
      n
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = s, this._grammar = N7(e, null), this._injections = null, this._tokenTypeMatchers = [], i)
      for (const l of Object.keys(i)) {
        const u = q1(l, V1);
        for (const c of u)
          this._tokenTypeMatchers.push({
            matcher: c.matcher,
            type: i[l]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const t of this._ruleId2desc)
      t && t.dispose();
  }
  createOnigScanner(t) {
    return this._onigLib.createOnigScanner(t);
  }
  createOnigString(t) {
    return this._onigLib.createOnigString(t);
  }
  getMetadataForScope(t) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(t);
  }
  _collectInjections() {
    const t = {
      lookup: (i) => i === this._rootScopeName ? this._grammar : this.getExternalGrammar(i),
      injections: (i) => this._grammarRepository.injections(i)
    }, e = [], r = this._rootScopeName, n = t.lookup(r);
    if (n) {
      const i = n.injections;
      if (i)
        for (let s in i)
          R7(
            e,
            s,
            i[s],
            this,
            n
          );
      const o = this._grammarRepository.injections(r);
      o && o.forEach((s) => {
        const a = this.getExternalGrammar(s);
        if (a) {
          const l = a.injectionSelector;
          l && R7(
            e,
            l,
            a,
            this,
            a
          );
        }
      });
    }
    return e.sort((i, o) => i.priority - o.priority), e;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(t) {
    const e = ++this._lastRuleId, r = t(e);
    return this._ruleId2desc[e] = r, r;
  }
  getRule(t) {
    return this._ruleId2desc[t];
  }
  getExternalGrammar(t, e) {
    if (this._includedGrammars[t])
      return this._includedGrammars[t];
    if (this._grammarRepository) {
      const r = this._grammarRepository.lookup(t);
      if (r)
        return this._includedGrammars[t] = N7(
          r,
          e && e.$base
        ), this._includedGrammars[t];
    }
  }
  tokenizeLine(t, e, r = 0) {
    const n = this._tokenize(t, e, !1, r);
    return {
      tokens: n.lineTokens.getResult(n.ruleStack, n.lineLength),
      ruleStack: n.ruleStack,
      stoppedEarly: n.stoppedEarly
    };
  }
  tokenizeLine2(t, e, r = 0) {
    const n = this._tokenize(t, e, !0, r);
    return {
      tokens: n.lineTokens.getBinaryResult(n.ruleStack, n.lineLength),
      ruleStack: n.ruleStack,
      stoppedEarly: n.stoppedEarly
    };
  }
  _tokenize(t, e, r, n) {
    this._rootId === -1 && (this._rootId = d$.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let i;
    if (!e || e === MC.NULL) {
      i = !0;
      const u = this._basicScopeAttributesProvider.getDefaultAttributes(), c = this.themeProvider.getDefaults(), h = Td.set(
        0,
        u.languageId,
        u.tokenType,
        null,
        c.fontStyle,
        c.foregroundId,
        c.backgroundId
      ), d = this.getRule(this._rootId).getName(
        null,
        null
      );
      let p;
      d ? p = Rm.createRootAndLookUpScopeName(
        d,
        h,
        this
      ) : p = Rm.createRoot(
        "unknown",
        h
      ), e = new MC(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        p,
        p
      );
    } else
      i = !1, e.reset();
    t = t + `
`;
    const o = this.createOnigString(t), s = o.content.length, a = new Pce(
      r,
      t,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), l = m$(
      this,
      o,
      i,
      0,
      e,
      a,
      !0,
      n
    );
    return c$(o), {
      lineLength: s,
      lineTokens: a,
      ruleStack: l.stack,
      stoppedEarly: l.stoppedEarly
    };
  }
};
function N7(t, e) {
  return t = Que(t), t.repository = t.repository || {}, t.repository.$self = {
    $vscodeTextmateLocation: t.$vscodeTextmateLocation,
    patterns: t.patterns,
    name: t.scopeName
  }, t.repository.$base = e || t.repository.$self, t;
}
var Rm = class ba {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, r, n) {
    this.parent = e, this.scopePath = r, this.tokenAttributes = n;
  }
  static fromExtension(e, r) {
    let n = e, i = e?.scopePath ?? null;
    for (const o of r)
      i = ik.push(i, o.scopeNames), n = new ba(n, i, o.encodedTokenAttributes);
    return n;
  }
  static createRoot(e, r) {
    return new ba(null, new ik(null, e), r);
  }
  static createRootAndLookUpScopeName(e, r, n) {
    const i = n.getMetadataForScope(e), o = new ik(null, e), s = n.themeProvider.themeMatch(o), a = ba.mergeAttributes(
      r,
      i,
      s
    );
    return new ba(null, o, a);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(e) {
    return ba.equals(this, e);
  }
  static equals(e, r) {
    do {
      if (e === r || !e && !r)
        return !0;
      if (!e || !r || e.scopeName !== r.scopeName || e.tokenAttributes !== r.tokenAttributes)
        return !1;
      e = e.parent, r = r.parent;
    } while (!0);
  }
  static mergeAttributes(e, r, n) {
    let i = -1, o = 0, s = 0;
    return n !== null && (i = n.fontStyle, o = n.foregroundId, s = n.backgroundId), Td.set(
      e,
      r.languageId,
      r.tokenType,
      null,
      i,
      o,
      s
    );
  }
  pushAttributed(e, r) {
    if (e === null)
      return this;
    if (e.indexOf(" ") === -1)
      return ba._pushAttributed(this, e, r);
    const n = e.split(/ /g);
    let i = this;
    for (const o of n)
      i = ba._pushAttributed(i, o, r);
    return i;
  }
  static _pushAttributed(e, r, n) {
    const i = n.getMetadataForScope(r), o = e.scopePath.push(r), s = n.themeProvider.themeMatch(o), a = ba.mergeAttributes(
      e.tokenAttributes,
      i,
      s
    );
    return new ba(e, o, a);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(e) {
    const r = [];
    let n = this;
    for (; n && n !== e; )
      r.push({
        encodedTokenAttributes: n.tokenAttributes,
        scopeNames: n.scopePath.getExtensionIfDefined(n.parent?.scopePath ?? null)
      }), n = n.parent;
    return n === e ? r.reverse() : void 0;
  }
}, MC = class Ic {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, r, n, i, o, s, a, l) {
    this.parent = e, this.ruleId = r, this.beginRuleCapturedEOL = o, this.endRule = s, this.nameScopesList = a, this.contentNameScopesList = l, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = n, this._anchorPos = i;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new Ic(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(e) {
    return e === null ? !1 : Ic._equals(this, e);
  }
  static _equals(e, r) {
    return e === r ? !0 : this._structuralEquals(e, r) ? Rm.equals(e.contentNameScopesList, r.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(e, r) {
    do {
      if (e === r || !e && !r)
        return !0;
      if (!e || !r || e.depth !== r.depth || e.ruleId !== r.ruleId || e.endRule !== r.endRule)
        return !1;
      e = e.parent, r = r.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(e) {
    for (; e; )
      e._enterPos = -1, e._anchorPos = -1, e = e.parent;
  }
  reset() {
    Ic._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(e, r, n, i, o, s, a) {
    return new Ic(
      this,
      e,
      r,
      n,
      i,
      o,
      s,
      a
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(e) {
    return e.getRule(this.ruleId);
  }
  toString() {
    const e = [];
    return this._writeString(e, 0), "[" + e.join(",") + "]";
  }
  _writeString(e, r) {
    return this.parent && (r = this.parent._writeString(e, r)), e[r++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, r;
  }
  withContentNameScopesList(e) {
    return this.contentNameScopesList === e ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      e
    );
  }
  withEndRule(e) {
    return this.endRule === e ? this : new Ic(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      e,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(e) {
    let r = this;
    for (; r && r._enterPos === e._enterPos; ) {
      if (r.ruleId === e.ruleId)
        return !0;
      r = r.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(e, r) {
    const n = Rm.fromExtension(e?.nameScopesList ?? null, r.nameScopesList);
    return new Ic(
      e,
      r.ruleId,
      r.enterPos ?? -1,
      r.anchorPos ?? -1,
      r.beginRuleCapturedEOL,
      r.endRule,
      n,
      Rm.fromExtension(n, r.contentNameScopesList)
    );
  }
}, Mce = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(t, e) {
    this.balancedBracketScopes = t.flatMap(
      (r) => r === "*" ? (this.allowAny = !0, []) : q1(r, V1).map((n) => n.matcher)
    ), this.unbalancedBracketScopes = e.flatMap(
      (r) => q1(r, V1).map((n) => n.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(t) {
    for (const e of this.unbalancedBracketScopes)
      if (e(t))
        return !1;
    for (const e of this.balancedBracketScopes)
      if (e(t))
        return !0;
    return this.allowAny;
  }
}, Pce = class {
  constructor(t, e, r, n) {
    this.balancedBracketSelectors = n, this._emitBinaryTokens = t, this._tokenTypeOverrides = r, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(t, e) {
    this.produceFromScopes(t.contentNameScopesList, e);
  }
  produceFromScopes(t, e) {
    if (this._lastTokenEndIndex >= e)
      return;
    if (this._emitBinaryTokens) {
      let n = t?.tokenAttributes ?? 0, i = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const o = t?.getScopeNames() ?? [];
        for (const s of this._tokenTypeOverrides)
          s.matcher(o) && (n = Td.set(
            n,
            0,
            s.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(o));
      }
      if (i && (n = Td.set(
        n,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === n) {
        this._lastTokenEndIndex = e;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(n), this._lastTokenEndIndex = e;
      return;
    }
    const r = t?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: e,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: r
    }), this._lastTokenEndIndex = e;
  }
  getResult(t, e) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === e - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(t, e) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === e - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const r = new Uint32Array(this._binaryTokens.length);
    for (let n = 0, i = this._binaryTokens.length; n < i; n++)
      r[n] = this._binaryTokens[n];
    return r;
  }
}, Rce = class {
  constructor(t, e) {
    this._onigLib = e, this._theme = t;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const t of this._grammars.values())
      t.dispose();
  }
  setTheme(t) {
    this._theme = t;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(t, e) {
    this._rawGrammars.set(t.scopeName, t), e && this._injectionGrammars.set(t.scopeName, e);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(t) {
    return this._rawGrammars.get(t);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(t) {
    return this._injectionGrammars.get(t);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(t) {
    return this._theme.match(t);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(t, e, r, n, i) {
    if (!this._grammars.has(t)) {
      let o = this._rawGrammars.get(t);
      if (!o)
        return null;
      this._grammars.set(t, Oce(
        t,
        o,
        e,
        r,
        n,
        i,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(t);
  }
}, Nce = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(t) {
    this._options = t, this._syncRegistry = new Rce(
      j1.createFromRawTheme(t.theme, t.colorMap),
      t.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(t, e) {
    this._syncRegistry.setTheme(j1.createFromRawTheme(t, e));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(t, e, r) {
    return this.loadGrammarWithConfiguration(t, e, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(t, e, r) {
    return this._loadGrammar(
      t,
      e,
      r.embeddedLanguages,
      r.tokenTypes,
      new Mce(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(t) {
    return this._loadGrammar(t, 0, null, null, null);
  }
  _loadGrammar(t, e, r, n, i) {
    const o = new cce(this._syncRegistry, t);
    for (; o.Q.length > 0; )
      o.Q.map((s) => this._loadSingleGrammar(s.scopeName)), o.processQueue();
    return this._grammarForScopeName(
      t,
      e,
      r,
      n,
      i
    );
  }
  _loadSingleGrammar(t) {
    this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0));
  }
  _doLoadSingleGrammar(t) {
    const e = this._options.loadGrammar(t);
    if (e) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0;
      this._syncRegistry.addGrammar(e, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(t, e = [], r = 0, n = null) {
    return this._syncRegistry.addGrammar(t, e), this._grammarForScopeName(t.scopeName, r, n);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(t, e = 0, r = null, n = null, i = null) {
    return this._syncRegistry.grammarForScopeName(
      t,
      e,
      r,
      n,
      i
    );
  }
}, PC = MC.NULL;
const $ce = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
let f0 = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, e, r) {
    this.normal = e, this.property = t, r && (this.space = r);
  }
};
f0.prototype.normal = {};
f0.prototype.property = {};
f0.prototype.space = void 0;
function v$(t, e) {
  const r = {}, n = {};
  for (const i of t)
    Object.assign(r, i.property), Object.assign(n, i.normal);
  return new f0(r, n, e);
}
function RC(t) {
  return t.toLowerCase();
}
class vo {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, r) {
    this.attribute = r, this.property = e;
  }
}
vo.prototype.attribute = "";
vo.prototype.booleanish = !1;
vo.prototype.boolean = !1;
vo.prototype.commaOrSpaceSeparated = !1;
vo.prototype.commaSeparated = !1;
vo.prototype.defined = !1;
vo.prototype.mustUseProperty = !1;
vo.prototype.number = !1;
vo.prototype.overloadedBoolean = !1;
vo.prototype.property = "";
vo.prototype.spaceSeparated = !1;
vo.prototype.space = void 0;
let Ice = 0;
const _t = jh(), gn = jh(), NC = jh(), Oe = jh(), Pr = jh(), Yf = jh(), Do = jh();
function jh() {
  return 2 ** ++Ice;
}
const $C = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: _t,
  booleanish: gn,
  commaOrSpaceSeparated: Do,
  commaSeparated: Yf,
  number: Oe,
  overloadedBoolean: NC,
  spaceSeparated: Pr
}, Symbol.toStringTag, { value: "Module" })), sk = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys($C)
);
class nS extends vo {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, r, n, i) {
    let o = -1;
    if (super(e, r), $7(this, "space", i), typeof n == "number")
      for (; ++o < sk.length; ) {
        const s = sk[o];
        $7(this, sk[o], (n & $C[s]) === $C[s]);
      }
  }
}
nS.prototype.defined = !0;
function $7(t, e, r) {
  r && (t[e] = r);
}
function np(t) {
  const e = {}, r = {};
  for (const [n, i] of Object.entries(t.properties)) {
    const o = new nS(
      n,
      t.transform(t.attributes || {}, n),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(n) && (o.mustUseProperty = !0), e[n] = o, r[RC(n)] = n, r[RC(o.attribute)] = n;
  }
  return new f0(e, r, t.space);
}
const y$ = np({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: gn,
    ariaAutoComplete: null,
    ariaBusy: gn,
    ariaChecked: gn,
    ariaColCount: Oe,
    ariaColIndex: Oe,
    ariaColSpan: Oe,
    ariaControls: Pr,
    ariaCurrent: null,
    ariaDescribedBy: Pr,
    ariaDetails: null,
    ariaDisabled: gn,
    ariaDropEffect: Pr,
    ariaErrorMessage: null,
    ariaExpanded: gn,
    ariaFlowTo: Pr,
    ariaGrabbed: gn,
    ariaHasPopup: null,
    ariaHidden: gn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Pr,
    ariaLevel: Oe,
    ariaLive: null,
    ariaModal: gn,
    ariaMultiLine: gn,
    ariaMultiSelectable: gn,
    ariaOrientation: null,
    ariaOwns: Pr,
    ariaPlaceholder: null,
    ariaPosInSet: Oe,
    ariaPressed: gn,
    ariaReadOnly: gn,
    ariaRelevant: null,
    ariaRequired: gn,
    ariaRoleDescription: Pr,
    ariaRowCount: Oe,
    ariaRowIndex: Oe,
    ariaRowSpan: Oe,
    ariaSelected: gn,
    ariaSetSize: Oe,
    ariaSort: null,
    ariaValueMax: Oe,
    ariaValueMin: Oe,
    ariaValueNow: Oe,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function b$(t, e) {
  return e in t ? t[e] : e;
}
function x$(t, e) {
  return b$(t, e.toLowerCase());
}
const Bce = np({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Yf,
    acceptCharset: Pr,
    accessKey: Pr,
    action: null,
    allow: null,
    allowFullScreen: _t,
    allowPaymentRequest: _t,
    allowUserMedia: _t,
    alt: null,
    as: null,
    async: _t,
    autoCapitalize: null,
    autoComplete: Pr,
    autoFocus: _t,
    autoPlay: _t,
    blocking: Pr,
    capture: null,
    charSet: null,
    checked: _t,
    cite: null,
    className: Pr,
    cols: Oe,
    colSpan: null,
    content: null,
    contentEditable: gn,
    controls: _t,
    controlsList: Pr,
    coords: Oe | Yf,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: _t,
    defer: _t,
    dir: null,
    dirName: null,
    disabled: _t,
    download: NC,
    draggable: gn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: _t,
    formTarget: null,
    headers: Pr,
    height: Oe,
    hidden: NC,
    high: Oe,
    href: null,
    hrefLang: null,
    htmlFor: Pr,
    httpEquiv: Pr,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: _t,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: _t,
    itemId: null,
    itemProp: Pr,
    itemRef: Pr,
    itemScope: _t,
    itemType: Pr,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: _t,
    low: Oe,
    manifest: null,
    max: null,
    maxLength: Oe,
    media: null,
    method: null,
    min: null,
    minLength: Oe,
    multiple: _t,
    muted: _t,
    name: null,
    nonce: null,
    noModule: _t,
    noValidate: _t,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: _t,
    optimum: Oe,
    pattern: null,
    ping: Pr,
    placeholder: null,
    playsInline: _t,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: _t,
    referrerPolicy: null,
    rel: Pr,
    required: _t,
    reversed: _t,
    rows: Oe,
    rowSpan: Oe,
    sandbox: Pr,
    scope: null,
    scoped: _t,
    seamless: _t,
    selected: _t,
    shadowRootClonable: _t,
    shadowRootDelegatesFocus: _t,
    shadowRootMode: null,
    shape: null,
    size: Oe,
    sizes: null,
    slot: null,
    span: Oe,
    spellCheck: gn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Oe,
    step: null,
    style: null,
    tabIndex: Oe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: _t,
    useMap: null,
    value: gn,
    width: Oe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Pr,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Oe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Oe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: _t,
    // Lists. Use CSS to reduce space between items instead
    declare: _t,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Oe,
    // `<img>` and `<object>`
    leftMargin: Oe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Oe,
    // `<body>`
    marginWidth: Oe,
    // `<body>`
    noResize: _t,
    // `<frame>`
    noHref: _t,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: _t,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: _t,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Oe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: gn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Oe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Oe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: _t,
    disableRemotePlayback: _t,
    prefix: null,
    property: null,
    results: Oe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: x$
}), Lce = np({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Do,
    accentHeight: Oe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Oe,
    amplitude: Oe,
    arabicForm: null,
    ascent: Oe,
    attributeName: null,
    attributeType: null,
    azimuth: Oe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Oe,
    by: null,
    calcMode: null,
    capHeight: Oe,
    className: Pr,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Oe,
    diffuseConstant: Oe,
    direction: null,
    display: null,
    dur: null,
    divisor: Oe,
    dominantBaseline: null,
    download: _t,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Oe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Oe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Oe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Yf,
    g2: Yf,
    glyphName: Yf,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Oe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Oe,
    horizOriginX: Oe,
    horizOriginY: Oe,
    id: null,
    ideographic: Oe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Oe,
    k: Oe,
    k1: Oe,
    k2: Oe,
    k3: Oe,
    k4: Oe,
    kernelMatrix: Do,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Oe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Oe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Oe,
    overlineThickness: Oe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Oe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Pr,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Oe,
    pointsAtY: Oe,
    pointsAtZ: Oe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Do,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Do,
    rev: Do,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Do,
    requiredFeatures: Do,
    requiredFonts: Do,
    requiredFormats: Do,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Oe,
    specularExponent: Oe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Oe,
    strikethroughThickness: Oe,
    string: null,
    stroke: null,
    strokeDashArray: Do,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Oe,
    strokeOpacity: Oe,
    strokeWidth: null,
    style: null,
    surfaceScale: Oe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Do,
    tabIndex: Oe,
    tableValues: null,
    target: null,
    targetX: Oe,
    targetY: Oe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Do,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Oe,
    underlineThickness: Oe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Oe,
    values: null,
    vAlphabetic: Oe,
    vMathematical: Oe,
    vectorEffect: null,
    vHanging: Oe,
    vIdeographic: Oe,
    version: null,
    vertAdvY: Oe,
    vertOriginX: Oe,
    vertOriginY: Oe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Oe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: b$
}), w$ = np({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), k$ = np({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: x$
}), C$ = np({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), zce = /[A-Z]/g, I7 = /-[a-z]/g, jce = /^data[-\w.:]+$/i;
function qce(t, e) {
  const r = RC(e);
  let n = e, i = vo;
  if (r in t.normal)
    return t.property[t.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && jce.test(e)) {
    if (e.charAt(4) === "-") {
      const o = e.slice(5).replace(I7, Hce);
      n = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = e.slice(4);
      if (!I7.test(o)) {
        let s = o.replace(zce, Uce);
        s.charAt(0) !== "-" && (s = "-" + s), e = "data" + s;
      }
    }
    i = nS;
  }
  return new i(n, e);
}
function Uce(t) {
  return "-" + t.toLowerCase();
}
function Hce(t) {
  return t.charAt(1).toUpperCase();
}
const Vce = v$([y$, Bce, w$, k$, C$], "html"), _$ = v$([y$, Lce, w$, k$, C$], "svg"), B7 = {}.hasOwnProperty;
function Wce(t, e) {
  const r = e || {};
  function n(i, ...o) {
    let s = n.invalid;
    const a = n.handlers;
    if (i && B7.call(i, t)) {
      const l = String(i[t]);
      s = B7.call(a, l) ? a[l] : n.unknown;
    }
    if (s)
      return s.call(this, i, ...o);
  }
  return n.handlers = r.handlers || {}, n.invalid = r.invalid, n.unknown = r.unknown, n;
}
const Gce = /["&'<>`]/g, Kce = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Xce = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), Qce = /[|\\{}()[\]^$+*?.]/g, L7 = /* @__PURE__ */ new WeakMap();
function Jce(t, e) {
  if (t = t.replace(
    e.subset ? Yce(e.subset) : Gce,
    n
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(Kce, r).replace(Xce, n);
  function r(i, o, s) {
    return e.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      s.charCodeAt(o + 2),
      e
    );
  }
  function n(i, o, s) {
    return e.format(
      i.charCodeAt(0),
      s.charCodeAt(o + 1),
      e
    );
  }
}
function Yce(t) {
  let e = L7.get(t);
  return e || (e = Zce(t), L7.set(t, e)), e;
}
function Zce(t) {
  const e = [];
  let r = -1;
  for (; ++r < t.length; )
    e.push(t[r].replace(Qce, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
const ehe = /[\dA-Fa-f]/;
function the(t, e, r) {
  const n = "&#x" + t.toString(16).toUpperCase();
  return r && e && !ehe.test(String.fromCharCode(e)) ? n : n + ";";
}
const rhe = /\d/;
function nhe(t, e, r) {
  const n = "&#" + String(t);
  return r && e && !rhe.test(String.fromCharCode(e)) ? n : n + ";";
}
const ihe = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], ak = {
  nbsp: "Â ",
  iexcl: "Â¡",
  cent: "Â¢",
  pound: "Â£",
  curren: "Â¤",
  yen: "Â¥",
  brvbar: "Â¦",
  sect: "Â§",
  uml: "Â¨",
  copy: "Â©",
  ordf: "Âª",
  laquo: "Â«",
  not: "Â¬",
  shy: "Â­",
  reg: "Â®",
  macr: "Â¯",
  deg: "Â°",
  plusmn: "Â±",
  sup2: "Â²",
  sup3: "Â³",
  acute: "Â´",
  micro: "Âµ",
  para: "Â¶",
  middot: "Â·",
  cedil: "Â¸",
  sup1: "Â¹",
  ordm: "Âº",
  raquo: "Â»",
  frac14: "Â¼",
  frac12: "Â½",
  frac34: "Â¾",
  iquest: "Â¿",
  Agrave: "Ã€",
  Aacute: "Ã",
  Acirc: "Ã‚",
  Atilde: "Ãƒ",
  Auml: "Ã„",
  Aring: "Ã…",
  AElig: "Ã†",
  Ccedil: "Ã‡",
  Egrave: "Ãˆ",
  Eacute: "Ã‰",
  Ecirc: "ÃŠ",
  Euml: "Ã‹",
  Igrave: "ÃŒ",
  Iacute: "Ã",
  Icirc: "ÃŽ",
  Iuml: "Ã",
  ETH: "Ã",
  Ntilde: "Ã‘",
  Ograve: "Ã’",
  Oacute: "Ã“",
  Ocirc: "Ã”",
  Otilde: "Ã•",
  Ouml: "Ã–",
  times: "Ã—",
  Oslash: "Ã˜",
  Ugrave: "Ã™",
  Uacute: "Ãš",
  Ucirc: "Ã›",
  Uuml: "Ãœ",
  Yacute: "Ã",
  THORN: "Ãž",
  szlig: "ÃŸ",
  agrave: "Ã ",
  aacute: "Ã¡",
  acirc: "Ã¢",
  atilde: "Ã£",
  auml: "Ã¤",
  aring: "Ã¥",
  aelig: "Ã¦",
  ccedil: "Ã§",
  egrave: "Ã¨",
  eacute: "Ã©",
  ecirc: "Ãª",
  euml: "Ã«",
  igrave: "Ã¬",
  iacute: "Ã­",
  icirc: "Ã®",
  iuml: "Ã¯",
  eth: "Ã°",
  ntilde: "Ã±",
  ograve: "Ã²",
  oacute: "Ã³",
  ocirc: "Ã´",
  otilde: "Ãµ",
  ouml: "Ã¶",
  divide: "Ã·",
  oslash: "Ã¸",
  ugrave: "Ã¹",
  uacute: "Ãº",
  ucirc: "Ã»",
  uuml: "Ã¼",
  yacute: "Ã½",
  thorn: "Ã¾",
  yuml: "Ã¿",
  fnof: "Æ’",
  Alpha: "Î‘",
  Beta: "Î’",
  Gamma: "Î“",
  Delta: "Î”",
  Epsilon: "Î•",
  Zeta: "Î–",
  Eta: "Î—",
  Theta: "Î˜",
  Iota: "Î™",
  Kappa: "Îš",
  Lambda: "Î›",
  Mu: "Îœ",
  Nu: "Î",
  Xi: "Îž",
  Omicron: "ÎŸ",
  Pi: "Î ",
  Rho: "Î¡",
  Sigma: "Î£",
  Tau: "Î¤",
  Upsilon: "Î¥",
  Phi: "Î¦",
  Chi: "Î§",
  Psi: "Î¨",
  Omega: "Î©",
  alpha: "Î±",
  beta: "Î²",
  gamma: "Î³",
  delta: "Î´",
  epsilon: "Îµ",
  zeta: "Î¶",
  eta: "Î·",
  theta: "Î¸",
  iota: "Î¹",
  kappa: "Îº",
  lambda: "Î»",
  mu: "Î¼",
  nu: "Î½",
  xi: "Î¾",
  omicron: "Î¿",
  pi: "Ï€",
  rho: "Ï",
  sigmaf: "Ï‚",
  sigma: "Ïƒ",
  tau: "Ï„",
  upsilon: "Ï…",
  phi: "Ï†",
  chi: "Ï‡",
  psi: "Ïˆ",
  omega: "Ï‰",
  thetasym: "Ï‘",
  upsih: "Ï’",
  piv: "Ï–",
  bull: "â€¢",
  hellip: "â€¦",
  prime: "â€²",
  Prime: "â€³",
  oline: "â€¾",
  frasl: "â„",
  weierp: "â„˜",
  image: "â„‘",
  real: "â„œ",
  trade: "â„¢",
  alefsym: "â„µ",
  larr: "â†",
  uarr: "â†‘",
  rarr: "â†’",
  darr: "â†“",
  harr: "â†”",
  crarr: "â†µ",
  lArr: "â‡",
  uArr: "â‡‘",
  rArr: "â‡’",
  dArr: "â‡“",
  hArr: "â‡”",
  forall: "âˆ€",
  part: "âˆ‚",
  exist: "âˆƒ",
  empty: "âˆ…",
  nabla: "âˆ‡",
  isin: "âˆˆ",
  notin: "âˆ‰",
  ni: "âˆ‹",
  prod: "âˆ",
  sum: "âˆ‘",
  minus: "âˆ’",
  lowast: "âˆ—",
  radic: "âˆš",
  prop: "âˆ",
  infin: "âˆž",
  ang: "âˆ ",
  and: "âˆ§",
  or: "âˆ¨",
  cap: "âˆ©",
  cup: "âˆª",
  int: "âˆ«",
  there4: "âˆ´",
  sim: "âˆ¼",
  cong: "â‰…",
  asymp: "â‰ˆ",
  ne: "â‰ ",
  equiv: "â‰¡",
  le: "â‰¤",
  ge: "â‰¥",
  sub: "âŠ‚",
  sup: "âŠƒ",
  nsub: "âŠ„",
  sube: "âŠ†",
  supe: "âŠ‡",
  oplus: "âŠ•",
  otimes: "âŠ—",
  perp: "âŠ¥",
  sdot: "â‹…",
  lceil: "âŒˆ",
  rceil: "âŒ‰",
  lfloor: "âŒŠ",
  rfloor: "âŒ‹",
  lang: "âŒ©",
  rang: "âŒª",
  loz: "â—Š",
  spades: "â™ ",
  clubs: "â™£",
  hearts: "â™¥",
  diams: "â™¦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Å’",
  oelig: "Å“",
  Scaron: "Å ",
  scaron: "Å¡",
  Yuml: "Å¸",
  circ: "Ë†",
  tilde: "Ëœ",
  ensp: "â€‚",
  emsp: "â€ƒ",
  thinsp: "â€‰",
  zwnj: "â€Œ",
  zwj: "â€",
  lrm: "â€Ž",
  rlm: "â€",
  ndash: "â€“",
  mdash: "â€”",
  lsquo: "â€˜",
  rsquo: "â€™",
  sbquo: "â€š",
  ldquo: "â€œ",
  rdquo: "â€",
  bdquo: "â€ž",
  dagger: "â€ ",
  Dagger: "â€¡",
  permil: "â€°",
  lsaquo: "â€¹",
  rsaquo: "â€º",
  euro: "â‚¬"
}, ohe = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], S$ = {}.hasOwnProperty, IC = {};
let ny;
for (ny in ak)
  S$.call(ak, ny) && (IC[ak[ny]] = ny);
const she = /[^\dA-Za-z]/;
function ahe(t, e, r, n) {
  const i = String.fromCharCode(t);
  if (S$.call(IC, i)) {
    const o = IC[i], s = "&" + o;
    return r && ihe.includes(o) && !ohe.includes(o) && (!n || e && e !== 61 && she.test(String.fromCharCode(e))) ? s : s + ";";
  }
  return "";
}
function lhe(t, e, r) {
  let n = the(t, e, r.omitOptionalSemicolons), i;
  if ((r.useNamedReferences || r.useShortestReferences) && (i = ahe(
    t,
    e,
    r.omitOptionalSemicolons,
    r.attribute
  )), (r.useShortestReferences || !i) && r.useShortestReferences) {
    const o = nhe(t, e, r.omitOptionalSemicolons);
    o.length < n.length && (n = o);
  }
  return i && (!r.useShortestReferences || i.length < n.length) ? i : n;
}
function Zf(t, e) {
  return Jce(t, Object.assign({ format: lhe }, e));
}
const uhe = /^>|^->|<!--|-->|--!>|<!-$/g, che = [">"], hhe = ["<", ">"];
function fhe(t, e, r, n) {
  return n.settings.bogusComments ? "<?" + Zf(
    t.value,
    Object.assign({}, n.settings.characterReferences, {
      subset: che
    })
  ) + ">" : "<!--" + t.value.replace(uhe, i) + "-->";
  function i(o) {
    return Zf(
      o,
      Object.assign({}, n.settings.characterReferences, {
        subset: hhe
      })
    );
  }
}
function dhe(t, e, r, n) {
  return "<!" + (n.settings.upperDoctype ? "DOCTYPE" : "doctype") + (n.settings.tightDoctype ? "" : " ") + "html>";
}
function z7(t, e) {
  const r = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let n = 0, i = r.indexOf(e);
  for (; i !== -1; )
    n++, i = r.indexOf(e, i + e.length);
  return n;
}
function phe(t, e) {
  const r = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (r.padRight ? " " : "") + "," + (r.padLeft === !1 ? "" : " ")
  ).trim();
}
function mhe(t) {
  return t.join(" ").trim();
}
const ghe = /[ \t\n\f\r]/g;
function iS(t) {
  return typeof t == "object" ? t.type === "text" ? j7(t.value) : !1 : j7(t);
}
function j7(t) {
  return t.replace(ghe, "") === "";
}
const Fn = E$(1), A$ = E$(-1), vhe = [];
function E$(t) {
  return e;
  function e(r, n, i) {
    const o = r ? r.children : vhe;
    let s = (n || 0) + t, a = o[s];
    if (!i)
      for (; a && iS(a); )
        s += t, a = o[s];
    return a;
  }
}
const yhe = {}.hasOwnProperty;
function D$(t) {
  return e;
  function e(r, n, i) {
    return yhe.call(t, r.tagName) && t[r.tagName](r, n, i);
  }
}
const oS = D$({
  body: xhe,
  caption: lk,
  colgroup: lk,
  dd: _he,
  dt: Che,
  head: lk,
  html: bhe,
  li: khe,
  optgroup: She,
  option: Ahe,
  p: whe,
  rp: q7,
  rt: q7,
  tbody: Dhe,
  td: U7,
  tfoot: Ohe,
  th: U7,
  thead: Ehe,
  tr: Fhe
});
function lk(t, e, r) {
  const n = Fn(r, e, !0);
  return !n || n.type !== "comment" && !(n.type === "text" && iS(n.value.charAt(0)));
}
function bhe(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type !== "comment";
}
function xhe(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type !== "comment";
}
function whe(t, e, r) {
  const n = Fn(r, e);
  return n ? n.type === "element" && (n.tagName === "address" || n.tagName === "article" || n.tagName === "aside" || n.tagName === "blockquote" || n.tagName === "details" || n.tagName === "div" || n.tagName === "dl" || n.tagName === "fieldset" || n.tagName === "figcaption" || n.tagName === "figure" || n.tagName === "footer" || n.tagName === "form" || n.tagName === "h1" || n.tagName === "h2" || n.tagName === "h3" || n.tagName === "h4" || n.tagName === "h5" || n.tagName === "h6" || n.tagName === "header" || n.tagName === "hgroup" || n.tagName === "hr" || n.tagName === "main" || n.tagName === "menu" || n.tagName === "nav" || n.tagName === "ol" || n.tagName === "p" || n.tagName === "pre" || n.tagName === "section" || n.tagName === "table" || n.tagName === "ul") : !r || // Confusing parent.
  !(r.type === "element" && (r.tagName === "a" || r.tagName === "audio" || r.tagName === "del" || r.tagName === "ins" || r.tagName === "map" || r.tagName === "noscript" || r.tagName === "video"));
}
function khe(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && n.tagName === "li";
}
function Che(t, e, r) {
  const n = Fn(r, e);
  return !!(n && n.type === "element" && (n.tagName === "dt" || n.tagName === "dd"));
}
function _he(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && (n.tagName === "dt" || n.tagName === "dd");
}
function q7(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && (n.tagName === "rp" || n.tagName === "rt");
}
function She(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && n.tagName === "optgroup";
}
function Ahe(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && (n.tagName === "option" || n.tagName === "optgroup");
}
function Ehe(t, e, r) {
  const n = Fn(r, e);
  return !!(n && n.type === "element" && (n.tagName === "tbody" || n.tagName === "tfoot"));
}
function Dhe(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && (n.tagName === "tbody" || n.tagName === "tfoot");
}
function Ohe(t, e, r) {
  return !Fn(r, e);
}
function Fhe(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && n.tagName === "tr";
}
function U7(t, e, r) {
  const n = Fn(r, e);
  return !n || n.type === "element" && (n.tagName === "td" || n.tagName === "th");
}
const The = D$({
  body: Rhe,
  colgroup: Nhe,
  head: Phe,
  html: Mhe,
  tbody: $he
});
function Mhe(t) {
  const e = Fn(t, -1);
  return !e || e.type !== "comment";
}
function Phe(t) {
  const e = /* @__PURE__ */ new Set();
  for (const n of t.children)
    if (n.type === "element" && (n.tagName === "base" || n.tagName === "title")) {
      if (e.has(n.tagName)) return !1;
      e.add(n.tagName);
    }
  const r = t.children[0];
  return !r || r.type === "element";
}
function Rhe(t) {
  const e = Fn(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && iS(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function Nhe(t, e, r) {
  const n = A$(r, e), i = Fn(t, -1, !0);
  return r && n && n.type === "element" && n.tagName === "colgroup" && oS(n, r.children.indexOf(n), r) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function $he(t, e, r) {
  const n = A$(r, e), i = Fn(t, -1);
  return r && n && n.type === "element" && (n.tagName === "thead" || n.tagName === "tbody") && oS(n, r.children.indexOf(n), r) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const iy = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Ihe(t, e, r, n) {
  const i = n.schema, o = i.space === "svg" ? !1 : n.settings.omitOptionalTags;
  let s = i.space === "svg" ? n.settings.closeEmptyElements : n.settings.voids.includes(t.tagName.toLowerCase());
  const a = [];
  let l;
  i.space === "html" && t.tagName === "svg" && (n.schema = _$);
  const u = Bhe(n, t.properties), c = n.all(
    i.space === "html" && t.tagName === "template" ? t.content : t
  );
  return n.schema = i, c && (s = !1), (u || !o || !The(t, e, r)) && (a.push("<", t.tagName, u ? " " + u : ""), s && (i.space === "svg" || n.settings.closeSelfClosing) && (l = u.charAt(u.length - 1), (!n.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(c), !s && (!o || !oS(t, e, r)) && a.push("</" + t.tagName + ">"), a.join("");
}
function Bhe(t, e) {
  const r = [];
  let n = -1, i;
  if (e) {
    for (i in e)
      if (e[i] !== null && e[i] !== void 0) {
        const o = Lhe(t, i, e[i]);
        o && r.push(o);
      }
  }
  for (; ++n < r.length; ) {
    const o = t.settings.tightAttributes ? r[n].charAt(r[n].length - 1) : void 0;
    n !== r.length - 1 && o !== '"' && o !== "'" && (r[n] += " ");
  }
  return r.join("");
}
function Lhe(t, e, r) {
  const n = qce(t.schema, e), i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, o = t.settings.allowDangerousCharacters ? 0 : 1;
  let s = t.quote, a;
  if (n.overloadedBoolean && (r === n.attribute || r === "") ? r = !0 : (n.boolean || n.overloadedBoolean) && (typeof r != "string" || r === n.attribute || r === "") && (r = !!r), r == null || r === !1 || typeof r == "number" && Number.isNaN(r))
    return "";
  const l = Zf(
    n.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: iy.name[i][o]
    })
  );
  return r === !0 || (r = Array.isArray(r) ? (n.commaSeparated ? phe : mhe)(r, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(r), t.settings.collapseEmptyAttributes && !r) ? l : (t.settings.preferUnquoted && (a = Zf(
    r,
    Object.assign({}, t.settings.characterReferences, {
      attribute: !0,
      subset: iy.unquoted[i][o]
    })
  )), a !== r && (t.settings.quoteSmart && z7(r, s) > z7(r, t.alternative) && (s = t.alternative), a = s + Zf(
    r,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (s === "'" ? iy.single : iy.double)[i][o],
      attribute: !0
    })
  ) + s), l + (a && "=" + a));
}
const zhe = ["<", "&"];
function O$(t, e, r, n) {
  return r && r.type === "element" && (r.tagName === "script" || r.tagName === "style") ? t.value : Zf(
    t.value,
    Object.assign({}, n.settings.characterReferences, {
      subset: zhe
    })
  );
}
function jhe(t, e, r, n) {
  return n.settings.allowDangerousHtml ? t.value : O$(t, e, r, n);
}
function qhe(t, e, r, n) {
  return n.all(t);
}
const Uhe = Wce("type", {
  invalid: Hhe,
  unknown: Vhe,
  handlers: { comment: fhe, doctype: dhe, element: Ihe, raw: jhe, root: qhe, text: O$ }
});
function Hhe(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function Vhe(t) {
  const e = (
    /** @type {Nodes} */
    t
  );
  throw new Error("Cannot compile unknown node `" + e.type + "`");
}
const Whe = {}, Ghe = {}, Khe = [];
function Xhe(t, e) {
  const r = Whe, n = r.quote || '"', i = n === '"' ? "'" : '"';
  if (n !== '"' && n !== "'")
    throw new Error("Invalid quote `" + n + "`, expected `'` or `\"`");
  return {
    one: Qhe,
    all: Jhe,
    settings: {
      omitOptionalTags: r.omitOptionalTags || !1,
      allowParseErrors: r.allowParseErrors || !1,
      allowDangerousCharacters: r.allowDangerousCharacters || !1,
      quoteSmart: r.quoteSmart || !1,
      preferUnquoted: r.preferUnquoted || !1,
      tightAttributes: r.tightAttributes || !1,
      upperDoctype: r.upperDoctype || !1,
      tightDoctype: r.tightDoctype || !1,
      bogusComments: r.bogusComments || !1,
      tightCommaSeparatedLists: r.tightCommaSeparatedLists || !1,
      tightSelfClosing: r.tightSelfClosing || !1,
      collapseEmptyAttributes: r.collapseEmptyAttributes || !1,
      allowDangerousHtml: r.allowDangerousHtml || !1,
      voids: r.voids || $ce,
      characterReferences: r.characterReferences || Ghe,
      closeSelfClosing: r.closeSelfClosing || !1,
      closeEmptyElements: r.closeEmptyElements || !1
    },
    schema: r.space === "svg" ? _$ : Vce,
    quote: n,
    alternative: i
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function Qhe(t, e, r) {
  return Uhe(t, e, r, this);
}
function Jhe(t) {
  const e = [], r = t && t.children || Khe;
  let n = -1;
  for (; ++n < r.length; )
    e[n] = this.one(r[n], n, t);
  return e.join("");
}
function Yhe(t) {
  return Array.isArray(t) ? t : [t];
}
function tx(t, e = !1) {
  const r = t.split(/(\r?\n)/g);
  let n = 0;
  const i = [];
  for (let o = 0; o < r.length; o += 2) {
    const s = e ? r[o] + (r[o + 1] || "") : r[o];
    i.push([s, n]), n += r[o].length, n += r[o + 1]?.length || 0;
  }
  return i;
}
function sS(t) {
  return !t || ["plaintext", "txt", "text", "plain"].includes(t);
}
function Zhe(t) {
  return t === "ansi" || sS(t);
}
function aS(t) {
  return t === "none";
}
function efe(t) {
  return aS(t);
}
function F$(t, e) {
  if (!e)
    return t;
  t.properties ||= {}, t.properties.class ||= [], typeof t.properties.class == "string" && (t.properties.class = t.properties.class.split(/\s+/g)), Array.isArray(t.properties.class) || (t.properties.class = []);
  const r = Array.isArray(e) ? e : e.split(/\s+/g);
  for (const n of r)
    n && !t.properties.class.includes(n) && t.properties.class.push(n);
  return t;
}
function tfe(t, e) {
  let r = 0;
  const n = [];
  for (const i of e)
    i > r && n.push({
      ...t,
      content: t.content.slice(r, i),
      offset: t.offset + r
    }), r = i;
  return r < t.content.length && n.push({
    ...t,
    content: t.content.slice(r),
    offset: t.offset + r
  }), n;
}
function rfe(t, e) {
  const r = Array.from(e instanceof Set ? e : new Set(e)).sort((n, i) => n - i);
  return r.length ? t.map((n) => n.flatMap((i) => {
    const o = r.filter((s) => i.offset < s && s < i.offset + i.content.length).map((s) => s - i.offset).sort((s, a) => s - a);
    return o.length ? tfe(i, o) : i;
  })) : t;
}
async function T$(t) {
  return Promise.resolve(typeof t == "function" ? t() : t).then((e) => e.default || e);
}
function W1(t, e) {
  const r = typeof t == "string" ? {} : { ...t.colorReplacements }, n = typeof t == "string" ? t : t.name;
  for (const [i, o] of Object.entries(e?.colorReplacements || {}))
    typeof o == "string" ? r[i] = o : i === n && Object.assign(r, o);
  return r;
}
function Wc(t, e) {
  return t && (e?.[t?.toLowerCase()] || t);
}
function M$(t) {
  const e = {};
  return t.color && (e.color = t.color), t.bgColor && (e["background-color"] = t.bgColor), t.fontStyle && (t.fontStyle & Ll.Italic && (e["font-style"] = "italic"), t.fontStyle & Ll.Bold && (e["font-weight"] = "bold"), t.fontStyle & Ll.Underline && (e["text-decoration"] = "underline")), e;
}
function nfe(t) {
  return typeof t == "string" ? t : Object.entries(t).map(([e, r]) => `${e}:${r}`).join(";");
}
function ife(t) {
  const e = tx(t, !0).map(([i]) => i);
  function r(i) {
    if (i === t.length)
      return {
        line: e.length - 1,
        character: e[e.length - 1].length
      };
    let o = i, s = 0;
    for (const a of e) {
      if (o < a.length)
        break;
      o -= a.length, s++;
    }
    return { line: s, character: o };
  }
  function n(i, o) {
    let s = 0;
    for (let a = 0; a < i; a++)
      s += e[a].length;
    return s += o, s;
  }
  return {
    lines: e,
    indexToPos: r,
    posToIndex: n
  };
}
class Mi extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
}
const P$ = /* @__PURE__ */ new WeakMap();
function rx(t, e) {
  P$.set(t, e);
}
function Ag(t) {
  return P$.get(t);
}
class ip {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(e, r) {
    return new ip(
      Object.fromEntries(Yhe(r).map((n) => [n, PC])),
      e
    );
  }
  constructor(...e) {
    if (e.length === 2) {
      const [r, n] = e;
      this.lang = n, this._stacks = r;
    } else {
      const [r, n, i] = e;
      this.lang = n, this._stacks = { [i]: r };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(e = this.theme) {
    return this._stacks[e];
  }
  /**
   * @deprecated use `getScopes` instead
   */
  get scopes() {
    return H7(this._stacks[this.theme]);
  }
  getScopes(e = this.theme) {
    return H7(this._stacks[e]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.scopes
    };
  }
}
function H7(t) {
  const e = [], r = /* @__PURE__ */ new Set();
  function n(i) {
    if (r.has(i))
      return;
    r.add(i);
    const o = i?.nameScopesList?.scopeName;
    o && e.push(o), i.parent && n(i.parent);
  }
  return n(t), e;
}
function ofe(t, e) {
  if (!(t instanceof ip))
    throw new Mi("Invalid grammar state");
  return t.getInternalStack(e);
}
function sfe() {
  const t = /* @__PURE__ */ new WeakMap();
  function e(r) {
    if (!t.has(r.meta)) {
      let n = function(s) {
        if (typeof s == "number") {
          if (s < 0 || s > r.source.length)
            throw new Mi(`Invalid decoration offset: ${s}. Code length: ${r.source.length}`);
          return {
            ...i.indexToPos(s),
            offset: s
          };
        } else {
          const a = i.lines[s.line];
          if (a === void 0)
            throw new Mi(`Invalid decoration position ${JSON.stringify(s)}. Lines length: ${i.lines.length}`);
          if (s.character < 0 || s.character > a.length)
            throw new Mi(`Invalid decoration position ${JSON.stringify(s)}. Line ${s.line} length: ${a.length}`);
          return {
            ...s,
            offset: i.posToIndex(s.line, s.character)
          };
        }
      };
      const i = ife(r.source), o = (r.options.decorations || []).map((s) => ({
        ...s,
        start: n(s.start),
        end: n(s.end)
      }));
      afe(o), t.set(r.meta, {
        decorations: o,
        converter: i,
        source: r.source
      });
    }
    return t.get(r.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(r) {
      if (!this.options.decorations?.length)
        return;
      const n = e(this).decorations.flatMap((i) => [i.start.offset, i.end.offset]);
      return rfe(r, n);
    },
    code(r) {
      if (!this.options.decorations?.length)
        return;
      const n = e(this), i = Array.from(r.children).filter((c) => c.type === "element" && c.tagName === "span");
      if (i.length !== n.converter.lines.length)
        throw new Mi(`Number of lines in code element (${i.length}) does not match the number of lines in the source (${n.converter.lines.length}). Failed to apply decorations.`);
      function o(c, h, d, p) {
        const g = i[c];
        let v = "", y = -1, b = -1;
        if (h === 0 && (y = 0), d === 0 && (b = 0), d === Number.POSITIVE_INFINITY && (b = g.children.length), y === -1 || b === -1)
          for (let C = 0; C < g.children.length; C++)
            v += R$(g.children[C]), y === -1 && v.length === h && (y = C + 1), b === -1 && v.length === d && (b = C + 1);
        if (y === -1)
          throw new Mi(`Failed to find start index for decoration ${JSON.stringify(p.start)}`);
        if (b === -1)
          throw new Mi(`Failed to find end index for decoration ${JSON.stringify(p.end)}`);
        const k = g.children.slice(y, b);
        if (!p.alwaysWrap && k.length === g.children.length)
          a(g, p, "line");
        else if (!p.alwaysWrap && k.length === 1 && k[0].type === "element")
          a(k[0], p, "token");
        else {
          const C = {
            type: "element",
            tagName: "span",
            properties: {},
            children: k
          };
          a(C, p, "wrapper"), g.children.splice(y, k.length, C);
        }
      }
      function s(c, h) {
        i[c] = a(i[c], h, "line");
      }
      function a(c, h, d) {
        const p = h.properties || {}, g = h.transform || ((v) => v);
        return c.tagName = h.tagName || "span", c.properties = {
          ...c.properties,
          ...p,
          class: c.properties.class
        }, h.properties?.class && F$(c, h.properties.class), c = g(c, d) || c, c;
      }
      const l = [], u = n.decorations.sort((c, h) => h.start.offset - c.start.offset);
      for (const c of u) {
        const { start: h, end: d } = c;
        if (h.line === d.line)
          o(h.line, h.character, d.character, c);
        else if (h.line < d.line) {
          o(h.line, h.character, Number.POSITIVE_INFINITY, c);
          for (let p = h.line + 1; p < d.line; p++)
            l.unshift(() => s(p, c));
          o(d.line, 0, d.character, c);
        }
      }
      l.forEach((c) => c());
    }
  };
}
function afe(t) {
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (r.start.offset > r.end.offset)
      throw new Mi(`Invalid decoration range: ${JSON.stringify(r.start)} - ${JSON.stringify(r.end)}`);
    for (let n = e + 1; n < t.length; n++) {
      const i = t[n], o = r.start.offset < i.start.offset && i.start.offset < r.end.offset, s = r.start.offset < i.end.offset && i.end.offset < r.end.offset, a = i.start.offset < r.start.offset && r.start.offset < i.end.offset, l = i.start.offset < r.end.offset && r.end.offset < i.end.offset;
      if (o || s || a || l) {
        if (s && s || a && l)
          continue;
        throw new Mi(`Decorations ${JSON.stringify(r.start)} and ${JSON.stringify(i.start)} intersect.`);
      }
    }
  }
}
function R$(t) {
  return t.type === "text" ? t.value : t.type === "element" ? t.children.map(R$).join("") : "";
}
const lfe = [
  /* @__PURE__ */ sfe()
];
function G1(t) {
  return [
    ...t.transformers || [],
    ...lfe
  ];
}
var Gc = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], uk = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function ufe(t, e) {
  const r = t.indexOf("\x1B[", e);
  if (r !== -1) {
    const n = t.indexOf("m", r);
    return {
      sequence: t.substring(r + 2, n).split(";"),
      startPosition: r,
      position: n + 1
    };
  }
  return {
    position: t.length
  };
}
function V7(t, e) {
  let r = 1;
  const n = t[e + r++];
  let i;
  if (n === "2") {
    const o = [
      t[e + r++],
      t[e + r++],
      t[e + r]
    ].map((s) => Number.parseInt(s));
    o.length === 3 && !o.some((s) => Number.isNaN(s)) && (i = {
      type: "rgb",
      rgb: o
    });
  } else if (n === "5") {
    const o = Number.parseInt(t[e + r]);
    Number.isNaN(o) || (i = { type: "table", index: Number(o) });
  }
  return [r, i];
}
function cfe(t) {
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const n = t[r], i = Number.parseInt(n);
    if (!Number.isNaN(i))
      if (i === 0)
        e.push({ type: "resetAll" });
      else if (i <= 9)
        uk[i] && e.push({
          type: "setDecoration",
          value: uk[i]
        });
      else if (i <= 29) {
        const o = uk[i - 20];
        o && e.push({
          type: "resetDecoration",
          value: o
        });
      } else if (i <= 37)
        e.push({
          type: "setForegroundColor",
          value: { type: "named", name: Gc[i - 30] }
        });
      else if (i === 38) {
        const [o, s] = V7(t, r);
        s && e.push({
          type: "setForegroundColor",
          value: s
        }), r += o;
      } else if (i === 39)
        e.push({
          type: "resetForegroundColor"
        });
      else if (i <= 47)
        e.push({
          type: "setBackgroundColor",
          value: { type: "named", name: Gc[i - 40] }
        });
      else if (i === 48) {
        const [o, s] = V7(t, r);
        s && e.push({
          type: "setBackgroundColor",
          value: s
        }), r += o;
      } else i === 49 ? e.push({
        type: "resetBackgroundColor"
      }) : i >= 90 && i <= 97 ? e.push({
        type: "setForegroundColor",
        value: { type: "named", name: Gc[i - 90 + 8] }
      }) : i >= 100 && i <= 107 && e.push({
        type: "setBackgroundColor",
        value: { type: "named", name: Gc[i - 100 + 8] }
      });
  }
  return e;
}
function hfe() {
  let t = null, e = null, r = /* @__PURE__ */ new Set();
  return {
    parse(n) {
      const i = [];
      let o = 0;
      do {
        const s = ufe(n, o), a = s.sequence ? n.substring(o, s.startPosition) : n.substring(o);
        if (a.length > 0 && i.push({
          value: a,
          foreground: t,
          background: e,
          decorations: new Set(r)
        }), s.sequence) {
          const l = cfe(s.sequence);
          for (const u of l)
            u.type === "resetAll" ? (t = null, e = null, r.clear()) : u.type === "resetForegroundColor" ? t = null : u.type === "resetBackgroundColor" ? e = null : u.type === "resetDecoration" && r.delete(u.value);
          for (const u of l)
            u.type === "setForegroundColor" ? t = u.value : u.type === "setBackgroundColor" ? e = u.value : u.type === "setDecoration" && r.add(u.value);
        }
        o = s.position;
      } while (o < n.length);
      return i;
    }
  };
}
var ffe = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function dfe(t = ffe) {
  function e(a) {
    return t[a];
  }
  function r(a) {
    return `#${a.map((l) => Math.max(0, Math.min(l, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let n;
  function i() {
    if (n)
      return n;
    n = [];
    for (let u = 0; u < Gc.length; u++)
      n.push(e(Gc[u]));
    let a = [0, 95, 135, 175, 215, 255];
    for (let u = 0; u < 6; u++)
      for (let c = 0; c < 6; c++)
        for (let h = 0; h < 6; h++)
          n.push(r([a[u], a[c], a[h]]));
    let l = 8;
    for (let u = 0; u < 24; u++, l += 10)
      n.push(r([l, l, l]));
    return n;
  }
  function o(a) {
    return i()[a];
  }
  function s(a) {
    switch (a.type) {
      case "named":
        return e(a.name);
      case "rgb":
        return r(a.rgb);
      case "table":
        return o(a.index);
    }
  }
  return {
    value: s
  };
}
function pfe(t, e, r) {
  const n = W1(t, r), i = tx(e), o = dfe(
    Object.fromEntries(
      Gc.map((a) => [
        a,
        t.colors?.[`terminal.ansi${a[0].toUpperCase()}${a.substring(1)}`]
      ])
    )
  ), s = hfe();
  return i.map(
    (a) => s.parse(a[0]).map((l) => {
      let u, c;
      l.decorations.has("reverse") ? (u = l.background ? o.value(l.background) : t.bg, c = l.foreground ? o.value(l.foreground) : t.fg) : (u = l.foreground ? o.value(l.foreground) : t.fg, c = l.background ? o.value(l.background) : void 0), u = Wc(u, n), c = Wc(c, n), l.decorations.has("dim") && (u = mfe(u));
      let h = Ll.None;
      return l.decorations.has("bold") && (h |= Ll.Bold), l.decorations.has("italic") && (h |= Ll.Italic), l.decorations.has("underline") && (h |= Ll.Underline), {
        content: l.value,
        offset: a[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: u,
        bgColor: c,
        fontStyle: h
      };
    })
  );
}
function mfe(t) {
  const e = t.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (e)
    if (e[3]) {
      const n = Math.round(Number.parseInt(e[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${e[1]}${e[2]}${n}`;
    } else return e[2] ? `#${e[1]}${e[2]}80` : `#${Array.from(e[1]).map((n) => `${n}${n}`).join("")}80`;
  const r = t.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return r ? `var(${r[1]}-dim)` : t;
}
function lS(t, e, r = {}) {
  const {
    lang: n = "text",
    theme: i = t.getLoadedThemes()[0]
  } = r;
  if (sS(n) || aS(i))
    return tx(e).map((l) => [{ content: l[0], offset: l[1] }]);
  const { theme: o, colorMap: s } = t.setTheme(i);
  if (n === "ansi")
    return pfe(o, e, r);
  const a = t.getLanguage(n);
  if (r.grammarState) {
    if (r.grammarState.lang !== a.name)
      throw new ah(`Grammar state language "${r.grammarState.lang}" does not match highlight language "${a.name}"`);
    if (!r.grammarState.themes.includes(o.name))
      throw new ah(`Grammar state themes "${r.grammarState.themes}" do not contain highlight theme "${o.name}"`);
  }
  return vfe(e, a, o, s, r);
}
function gfe(...t) {
  if (t.length === 2)
    return Ag(t[1]);
  const [e, r, n = {}] = t, {
    lang: i = "text",
    theme: o = e.getLoadedThemes()[0]
  } = n;
  if (sS(i) || aS(o))
    throw new ah("Plain language does not have grammar state");
  if (i === "ansi")
    throw new ah("ANSI language does not have grammar state");
  const { theme: s, colorMap: a } = e.setTheme(o), l = e.getLanguage(i);
  return new ip(
    K1(r, l, s, a, n).stateStack,
    l.name,
    s.name
  );
}
function vfe(t, e, r, n, i) {
  const o = K1(t, e, r, n, i), s = new ip(
    K1(t, e, r, n, i).stateStack,
    e.name,
    r.name
  );
  return rx(o.tokens, s), o.tokens;
}
function K1(t, e, r, n, i) {
  const o = W1(r, i), {
    tokenizeMaxLineLength: s = 0,
    tokenizeTimeLimit: a = 500
  } = i, l = tx(t);
  let u = i.grammarState ? ofe(i.grammarState, r.name) ?? PC : i.grammarContextCode != null ? K1(
    i.grammarContextCode,
    e,
    r,
    n,
    {
      ...i,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : PC, c = [];
  const h = [];
  for (let d = 0, p = l.length; d < p; d++) {
    const [g, v] = l[d];
    if (g === "") {
      c = [], h.push([]);
      continue;
    }
    if (s > 0 && g.length >= s) {
      c = [], h.push([{
        content: g,
        offset: v,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let y, b, k;
    i.includeExplanation && (y = e.tokenizeLine(g, u), b = y.tokens, k = 0);
    const C = e.tokenizeLine2(g, u, a), S = C.tokens.length / 2;
    for (let _ = 0; _ < S; _++) {
      const D = C.tokens[2 * _], A = _ + 1 < S ? C.tokens[2 * _ + 2] : g.length;
      if (D === A)
        continue;
      const O = C.tokens[2 * _ + 1], M = Wc(
        n[Td.getForeground(O)],
        o
      ), z = Td.getFontStyle(O), N = {
        content: g.substring(D, A),
        offset: v + D,
        color: M,
        fontStyle: z
      };
      if (i.includeExplanation) {
        const P = [];
        if (i.includeExplanation !== "scopeName")
          for (const B of r.settings) {
            let $;
            switch (typeof B.scope) {
              case "string":
                $ = B.scope.split(/,/).map((j) => j.trim());
                break;
              case "object":
                $ = B.scope;
                break;
              default:
                continue;
            }
            P.push({
              settings: B,
              selectors: $.map((j) => j.split(/ /))
            });
          }
        N.explanation = [];
        let I = 0;
        for (; D + I < A; ) {
          const B = b[k], $ = g.substring(
            B.startIndex,
            B.endIndex
          );
          I += $.length, N.explanation.push({
            content: $,
            scopes: i.includeExplanation === "scopeName" ? yfe(
              B.scopes
            ) : bfe(
              P,
              B.scopes
            )
          }), k += 1;
        }
      }
      c.push(N);
    }
    h.push(c), c = [], u = C.ruleStack;
  }
  return {
    tokens: h,
    stateStack: u
  };
}
function yfe(t) {
  return t.map((e) => ({ scopeName: e }));
}
function bfe(t, e) {
  const r = [];
  for (let n = 0, i = e.length; n < i; n++) {
    const o = e[n];
    r[n] = {
      scopeName: o,
      themeMatches: wfe(t, o, e.slice(0, n))
    };
  }
  return r;
}
function W7(t, e) {
  return t === e || e.substring(0, t.length) === t && e[t.length] === ".";
}
function xfe(t, e, r) {
  if (!W7(t[t.length - 1], e))
    return !1;
  let n = t.length - 2, i = r.length - 1;
  for (; n >= 0 && i >= 0; )
    W7(t[n], r[i]) && (n -= 1), i -= 1;
  return n === -1;
}
function wfe(t, e, r) {
  const n = [];
  for (const { selectors: i, settings: o } of t)
    for (const s of i)
      if (xfe(s, e, r)) {
        n.push(o);
        break;
      }
  return n;
}
function N$(t, e, r) {
  const n = Object.entries(r.themes).filter((l) => l[1]).map((l) => ({ color: l[0], theme: l[1] })), i = n.map((l) => {
    const u = lS(t, e, {
      ...r,
      theme: l.theme
    }), c = Ag(u), h = typeof l.theme == "string" ? l.theme : l.theme.name;
    return {
      tokens: u,
      state: c,
      theme: h
    };
  }), o = kfe(
    ...i.map((l) => l.tokens)
  ), s = o[0].map(
    (l, u) => l.map((c, h) => {
      const d = {
        content: c.content,
        variants: {},
        offset: c.offset
      };
      return "includeExplanation" in r && r.includeExplanation && (d.explanation = c.explanation), o.forEach((p, g) => {
        const {
          content: v,
          explanation: y,
          offset: b,
          ...k
        } = p[u][h];
        d.variants[n[g].color] = k;
      }), d;
    })
  ), a = i[0].state ? new ip(
    Object.fromEntries(i.map((l) => [l.theme, l.state?.getInternalStack(l.theme)])),
    i[0].state.lang
  ) : void 0;
  return a && rx(s, a), s;
}
function kfe(...t) {
  const e = t.map(() => []), r = t.length;
  for (let n = 0; n < t[0].length; n++) {
    const i = t.map((l) => l[n]), o = e.map(() => []);
    e.forEach((l, u) => l.push(o[u]));
    const s = i.map(() => 0), a = i.map((l) => l[0]);
    for (; a.every((l) => l); ) {
      const l = Math.min(...a.map((u) => u.content.length));
      for (let u = 0; u < r; u++) {
        const c = a[u];
        c.content.length === l ? (o[u].push(c), s[u] += 1, a[u] = i[u][s[u]]) : (o[u].push({
          ...c,
          content: c.content.slice(0, l)
        }), a[u] = {
          ...c,
          content: c.content.slice(l),
          offset: c.offset + l
        });
      }
    }
  }
  return e;
}
function X1(t, e, r) {
  let n, i, o, s, a, l;
  if ("themes" in r) {
    const {
      defaultColor: u = "light",
      cssVariablePrefix: c = "--shiki-"
    } = r, h = Object.entries(r.themes).filter((y) => y[1]).map((y) => ({ color: y[0], theme: y[1] })).sort((y, b) => y.color === u ? -1 : b.color === u ? 1 : 0);
    if (h.length === 0)
      throw new ah("`themes` option must not be empty");
    const d = N$(
      t,
      e,
      r
    );
    if (l = Ag(d), u && !h.find((y) => y.color === u))
      throw new ah(`\`themes\` option must contain the defaultColor key \`${u}\``);
    const p = h.map((y) => t.getTheme(y.theme)), g = h.map((y) => y.color);
    o = d.map((y) => y.map((b) => Cfe(b, g, c, u))), l && rx(o, l);
    const v = h.map((y) => W1(y.theme, r));
    i = h.map((y, b) => (b === 0 && u ? "" : `${c + y.color}:`) + (Wc(p[b].fg, v[b]) || "inherit")).join(";"), n = h.map((y, b) => (b === 0 && u ? "" : `${c + y.color}-bg:`) + (Wc(p[b].bg, v[b]) || "inherit")).join(";"), s = `shiki-themes ${p.map((y) => y.name).join(" ")}`, a = u ? void 0 : [i, n].join(";");
  } else if ("theme" in r) {
    const u = W1(r.theme, r);
    o = lS(
      t,
      e,
      r
    );
    const c = t.getTheme(r.theme);
    n = Wc(c.bg, u), i = Wc(c.fg, u), s = c.name, l = Ag(o);
  } else
    throw new ah("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: o,
    fg: i,
    bg: n,
    themeName: s,
    rootStyle: a,
    grammarState: l
  };
}
function Cfe(t, e, r, n) {
  const i = {
    content: t.content,
    explanation: t.explanation,
    offset: t.offset
  }, o = e.map((l) => M$(t.variants[l])), s = new Set(o.flatMap((l) => Object.keys(l))), a = {};
  return o.forEach((l, u) => {
    for (const c of s) {
      const h = l[c] || "inherit";
      if (u === 0 && n)
        a[c] = h;
      else {
        const d = c === "color" ? "" : c === "background-color" ? "-bg" : `-${c}`, p = r + e[u] + (c === "color" ? "" : d);
        a[p] = h;
      }
    }
  }), i.htmlStyle = a, i;
}
function Q1(t, e, r, n = {
  meta: {},
  options: r,
  codeToHast: (i, o) => Q1(t, i, o),
  codeToTokens: (i, o) => X1(t, i, o)
}) {
  let i = e;
  for (const p of G1(r))
    i = p.preprocess?.call(n, i, r) || i;
  let {
    tokens: o,
    fg: s,
    bg: a,
    themeName: l,
    rootStyle: u,
    grammarState: c
  } = X1(t, i, r);
  const {
    mergeWhitespaces: h = !0
  } = r;
  h === !0 ? o = Sfe(o) : h === "never" && (o = Afe(o));
  const d = {
    ...n,
    get source() {
      return i;
    }
  };
  for (const p of G1(r))
    o = p.tokens?.call(d, o) || o;
  return _fe(
    o,
    {
      ...r,
      fg: s,
      bg: a,
      themeName: l,
      rootStyle: u
    },
    d,
    c
  );
}
function _fe(t, e, r, n = Ag(t)) {
  const i = G1(e), o = [], s = {
    type: "root",
    children: []
  }, {
    structure: a = "classic",
    tabindex: l = "0"
  } = e;
  let u = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${e.themeName || ""}`,
      style: e.rootStyle || `background-color:${e.bg};color:${e.fg}`,
      ...l !== !1 && l != null ? {
        tabindex: l.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(e.meta || {})
        ).filter(([g]) => !g.startsWith("_"))
      )
    },
    children: []
  }, c = {
    type: "element",
    tagName: "code",
    properties: {},
    children: o
  };
  const h = [], d = {
    ...r,
    structure: a,
    addClassToHast: F$,
    get source() {
      return r.source;
    },
    get tokens() {
      return t;
    },
    get options() {
      return e;
    },
    get root() {
      return s;
    },
    get pre() {
      return u;
    },
    get code() {
      return c;
    },
    get lines() {
      return h;
    }
  };
  if (t.forEach((g, v) => {
    v && (a === "inline" ? s.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : a === "classic" && o.push({ type: "text", value: `
` }));
    let y = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, b = 0;
    for (const k of g) {
      let C = {
        type: "element",
        tagName: "span",
        properties: {
          ...k.htmlAttrs
        },
        children: [{ type: "text", value: k.content }]
      };
      k.htmlStyle;
      const S = nfe(k.htmlStyle || M$(k));
      S && (C.properties.style = S);
      for (const _ of i)
        C = _?.span?.call(d, C, v + 1, b, y, k) || C;
      a === "inline" ? s.children.push(C) : a === "classic" && y.children.push(C), b += k.content.length;
    }
    if (a === "classic") {
      for (const k of i)
        y = k?.line?.call(d, y, v + 1) || y;
      h.push(y), o.push(y);
    }
  }), a === "classic") {
    for (const g of i)
      c = g?.code?.call(d, c) || c;
    u.children.push(c);
    for (const g of i)
      u = g?.pre?.call(d, u) || u;
    s.children.push(u);
  }
  let p = s;
  for (const g of i)
    p = g?.root?.call(d, p) || p;
  return n && rx(p, n), p;
}
function Sfe(t) {
  return t.map((e) => {
    const r = [];
    let n = "", i = 0;
    return e.forEach((o, s) => {
      const a = !(o.fontStyle && o.fontStyle & Ll.Underline);
      a && o.content.match(/^\s+$/) && e[s + 1] ? (i || (i = o.offset), n += o.content) : n ? (a ? r.push({
        ...o,
        offset: i,
        content: n + o.content
      }) : r.push(
        {
          content: n,
          offset: i
        },
        o
      ), i = 0, n = "") : r.push(o);
    }), r;
  });
}
function Afe(t) {
  return t.map((e) => e.flatMap((r) => {
    if (r.content.match(/^\s+$/))
      return r;
    const n = r.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!n)
      return r;
    const [, i, o, s] = n;
    if (!i && !s)
      return r;
    const a = [{
      ...r,
      offset: r.offset + i.length,
      content: o
    }];
    return i && a.unshift({
      content: i,
      offset: r.offset
    }), s && a.push({
      content: s,
      offset: r.offset + i.length + o.length
    }), a;
  }));
}
function Efe(t, e, r) {
  const n = {
    meta: {},
    options: r,
    codeToHast: (o, s) => Q1(t, o, s),
    codeToTokens: (o, s) => X1(t, o, s)
  };
  let i = Xhe(Q1(t, e, r, n));
  for (const o of G1(r))
    i = o.postprocess?.call(n, i, r) || i;
  return i;
}
const G7 = { light: "#333333", dark: "#bbbbbb" }, K7 = { light: "#fffffe", dark: "#1e1e1e" }, X7 = "__shiki_resolved";
function uS(t) {
  if (t?.[X7])
    return t;
  const e = {
    ...t
  };
  e.tokenColors && !e.settings && (e.settings = e.tokenColors, delete e.tokenColors), e.type ||= "dark", e.colorReplacements = { ...e.colorReplacements }, e.settings ||= [];
  let { bg: r, fg: n } = e;
  if (!r || !n) {
    const a = e.settings ? e.settings.find((l) => !l.name && !l.scope) : void 0;
    a?.settings?.foreground && (n = a.settings.foreground), a?.settings?.background && (r = a.settings.background), !n && e?.colors?.["editor.foreground"] && (n = e.colors["editor.foreground"]), !r && e?.colors?.["editor.background"] && (r = e.colors["editor.background"]), n || (n = e.type === "light" ? G7.light : G7.dark), r || (r = e.type === "light" ? K7.light : K7.dark), e.fg = n, e.bg = r;
  }
  e.settings[0] && e.settings[0].settings && !e.settings[0].scope || e.settings.unshift({
    settings: {
      foreground: e.fg,
      background: e.bg
    }
  });
  let i = 0;
  const o = /* @__PURE__ */ new Map();
  function s(a) {
    if (o.has(a))
      return o.get(a);
    i += 1;
    const l = `#${i.toString(16).padStart(8, "0").toLowerCase()}`;
    return e.colorReplacements?.[`#${l}`] ? s(a) : (o.set(a, l), l);
  }
  e.settings = e.settings.map((a) => {
    const l = a.settings?.foreground && !a.settings.foreground.startsWith("#"), u = a.settings?.background && !a.settings.background.startsWith("#");
    if (!l && !u)
      return a;
    const c = {
      ...a,
      settings: {
        ...a.settings
      }
    };
    if (l) {
      const h = s(a.settings.foreground);
      e.colorReplacements[h] = a.settings.foreground, c.settings.foreground = h;
    }
    if (u) {
      const h = s(a.settings.background);
      e.colorReplacements[h] = a.settings.background, c.settings.background = h;
    }
    return c;
  });
  for (const a of Object.keys(e.colors || {}))
    if ((a === "editor.foreground" || a === "editor.background" || a.startsWith("terminal.ansi")) && !e.colors[a]?.startsWith("#")) {
      const l = s(e.colors[a]);
      e.colorReplacements[l] = e.colors[a], e.colors[a] = l;
    }
  return Object.defineProperty(e, X7, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), e;
}
async function $$(t) {
  return Array.from(new Set((await Promise.all(
    t.filter((e) => !Zhe(e)).map(async (e) => await T$(e).then((r) => Array.isArray(r) ? r : [r]))
  )).flat()));
}
async function I$(t) {
  return (await Promise.all(
    t.map(
      async (e) => efe(e) ? null : uS(await T$(e))
    )
  )).filter((e) => !!e);
}
class Dfe extends Nce {
  constructor(e, r, n, i = {}) {
    super(e), this._resolver = e, this._themes = r, this._langs = n, this._alias = i, this._themes.map((o) => this.loadTheme(o)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(e) {
    return typeof e == "string" ? this._resolvedThemes.get(e) : this.loadTheme(e);
  }
  loadTheme(e) {
    const r = uS(e);
    return r.name && (this._resolvedThemes.set(r.name, r), this._loadedThemesCache = null), r;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(e) {
    let r = this._textmateThemeCache.get(e);
    r || (r = j1.createFromRawTheme(e), this._textmateThemeCache.set(e, r)), this._syncRegistry.setTheme(r);
  }
  getGrammar(e) {
    if (this._alias[e]) {
      const r = /* @__PURE__ */ new Set([e]);
      for (; this._alias[e]; ) {
        if (e = this._alias[e], r.has(e))
          throw new Mi(`Circular alias \`${Array.from(r).join(" -> ")} -> ${e}\``);
        r.add(e);
      }
    }
    return this._resolvedGrammars.get(e);
  }
  loadLanguage(e) {
    if (this.getGrammar(e.name))
      return;
    const r = new Set(
      [...this._langMap.values()].filter((o) => o.embeddedLangsLazy?.includes(e.name))
    );
    this._resolver.addLanguage(e);
    const n = {
      balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(e.scopeName, e);
    const i = this.loadGrammarWithConfiguration(e.scopeName, 1, n);
    if (i.name = e.name, this._resolvedGrammars.set(e.name, i), e.aliases && e.aliases.forEach((o) => {
      this._alias[o] = e.name;
    }), this._loadedLanguagesCache = null, r.size)
      for (const o of r)
        this._resolvedGrammars.delete(o.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(o.scopeName), this._syncRegistry?._grammars?.delete(o.scopeName), this.loadLanguage(this._langMap.get(o.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(e) {
    for (const i of e)
      this.resolveEmbeddedLanguages(i);
    const r = Array.from(this._langGraph.entries()), n = r.filter(([i, o]) => !o);
    if (n.length) {
      const i = r.filter(([o, s]) => s && s.embeddedLangs?.some((a) => n.map(([l]) => l).includes(a))).filter((o) => !n.includes(o));
      throw new Mi(`Missing languages ${n.map(([o]) => `\`${o}\``).join(", ")}, required by ${i.map(([o]) => `\`${o}\``).join(", ")}`);
    }
    for (const [i, o] of r)
      this._resolver.addLanguage(o);
    for (const [i, o] of r)
      this.loadLanguage(o);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(e) {
    if (this._langMap.set(e.name, e), this._langGraph.set(e.name, e), e.embeddedLangs)
      for (const r of e.embeddedLangs)
        this._langGraph.set(r, this._langMap.get(r));
  }
}
class Ofe {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(e, r) {
    this._onigLib = {
      createOnigScanner: (n) => e.createScanner(n),
      createOnigString: (n) => e.createString(n)
    }, r.forEach((n) => this.addLanguage(n));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(e) {
    return this._langs.get(e);
  }
  loadGrammar(e) {
    return this._scopeToLang.get(e);
  }
  addLanguage(e) {
    this._langs.set(e.name, e), e.aliases && e.aliases.forEach((r) => {
      this._langs.set(r, e);
    }), this._scopeToLang.set(e.scopeName, e), e.injectTo && e.injectTo.forEach((r) => {
      this._injections.get(r) || this._injections.set(r, []), this._injections.get(r).push(e.scopeName);
    });
  }
  getInjections(e) {
    const r = e.split(".");
    let n = [];
    for (let i = 1; i <= r.length; i++) {
      const o = r.slice(0, i).join(".");
      n = [...n, ...this._injections.get(o) || []];
    }
    return n;
  }
}
let rm = 0;
function Ffe(t) {
  rm += 1, t.warnings !== !1 && rm >= 10 && rm % 10 === 0 && console.warn(`[Shiki] ${rm} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let e = !1;
  if (!t.engine)
    throw new Mi("`engine` option is required for synchronous mode");
  const r = (t.langs || []).flat(1), n = (t.themes || []).flat(1).map(uS), i = new Ofe(t.engine, r), o = new Dfe(i, n, r, t.langAlias);
  let s;
  function a(k) {
    y();
    const C = o.getGrammar(typeof k == "string" ? k : k.name);
    if (!C)
      throw new Mi(`Language \`${k}\` not found, you may need to load it first`);
    return C;
  }
  function l(k) {
    if (k === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    y();
    const C = o.getTheme(k);
    if (!C)
      throw new Mi(`Theme \`${k}\` not found, you may need to load it first`);
    return C;
  }
  function u(k) {
    y();
    const C = l(k);
    s !== k && (o.setTheme(C), s = k);
    const S = o.getColorMap();
    return {
      theme: C,
      colorMap: S
    };
  }
  function c() {
    return y(), o.getLoadedThemes();
  }
  function h() {
    return y(), o.getLoadedLanguages();
  }
  function d(...k) {
    y(), o.loadLanguages(k.flat(1));
  }
  async function p(...k) {
    return d(await $$(k));
  }
  function g(...k) {
    y();
    for (const C of k.flat(1))
      o.loadTheme(C);
  }
  async function v(...k) {
    return y(), g(await I$(k));
  }
  function y() {
    if (e)
      throw new Mi("Shiki instance has been disposed");
  }
  function b() {
    e || (e = !0, o.dispose(), rm -= 1);
  }
  return {
    setTheme: u,
    getTheme: l,
    getLanguage: a,
    getLoadedThemes: c,
    getLoadedLanguages: h,
    loadLanguage: p,
    loadLanguageSync: d,
    loadTheme: v,
    loadThemeSync: g,
    dispose: b,
    [Symbol.dispose]: b
  };
}
async function Tfe(t = {}) {
  t.loadWasm;
  const [
    e,
    r,
    n
  ] = await Promise.all([
    I$(t.themes || []),
    $$(t.langs || []),
    t.engine || Xue(t.loadWasm || Kue())
  ]);
  return Ffe({
    ...t,
    themes: e,
    langs: r,
    engine: n
  });
}
async function Mfe(t = {}) {
  const e = await Tfe(t);
  return {
    getLastGrammarState: (...r) => gfe(e, ...r),
    codeToTokensBase: (r, n) => lS(e, r, n),
    codeToTokensWithThemes: (r, n) => N$(e, r, n),
    codeToTokens: (r, n) => X1(e, r, n),
    codeToHast: (r, n) => Q1(e, r, n),
    codeToHtml: (r, n) => Efe(e, r, n),
    ...e,
    getInternalContext: () => e
  };
}
const BC = Cs({
  linkify: !0,
  typographer: !0
});
(async () => {
  const t = await Mfe({
    themes: [
      import("./chunk-CcmG315c.js"),
      import("./chunk-Cym-eLtO.js")
    ],
    langs: [import("./chunk-fa8UlHZE.js")]
  });
  BC.use(Fue(t, {
    themes: {
      light: "vitesse-light",
      dark: "vitesse-dark"
    }
  }));
})();
function ed(t, e = !0) {
  return e ? BC.renderInline(t) : BC.render(t);
}
const Pfe = g4({
  String: oe.string,
  Number: oe.number,
  "True False": oe.bool,
  PropertyName: oe.propertyName,
  Null: oe.null,
  ", :": oe.separator,
  "[ ]": oe.squareBracket,
  "{ }": oe.brace
}), Rfe = hg.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "âš  JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [Pfe],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), Nfe = () => (t) => {
  try {
    JSON.parse(t.state.doc.toString());
  } catch (e) {
    if (!(e instanceof SyntaxError))
      throw e;
    const r = $fe(e, t.state.doc);
    return [{
      from: r,
      message: e.message,
      severity: "error",
      to: r
    }];
  }
  return [];
};
function $fe(t, e) {
  let r;
  return (r = t.message.match(/at position (\d+)/)) ? Math.min(+r[1], e.length) : (r = t.message.match(/at line (\d+) column (\d+)/)) ? Math.min(e.line(+r[1]).from + +r[2] - 1, e.length) : 0;
}
const B$ = /* @__PURE__ */ sg.define({
  name: "json",
  parser: /* @__PURE__ */ Rfe.configure({
    props: [
      /* @__PURE__ */ y4.add({
        Object: /* @__PURE__ */ rC({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ rC({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ xP.add({
        "Object Array": qZ
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function Ife() {
  return new yP(B$);
}
var Q7 = {}, J7;
function Bfe() {
  return J7 || (J7 = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.parse = t.enableErrorLogging = t.disableErrorLogging = t.setErrorLogger = void 0;
    let e = console.error;
    function r(A) {
      e = A;
    }
    t.setErrorLogger = r;
    function n() {
      e = () => {
      };
    }
    t.disableErrorLogging = n;
    function i() {
      e = console.error;
    }
    t.enableErrorLogging = i;
    function o(A) {
      if (A !== void 0) {
        if (A === null)
          return null;
        if (A === "")
          return "";
        A = A.replace(/\\+$/, (O) => O.length % 2 === 0 ? O : O.slice(0, -1));
        try {
          return JSON.parse(A);
        } catch (O) {
          const [M, z] = A.trimLeft()[0] === ":" ? s(A, O) : s(A, O, b);
          if (o.lastParseReminding = z, o.onExtraToken && z.length > 0) {
            const N = z.trimRight();
            o.lastParseReminding = N, N.length > 0 && o.onExtraToken(A, M, N);
          }
          return M;
        }
      }
    }
    t.parse = o, (function(A) {
      A.onExtraToken = (O, M, z) => {
        e("parsed json with extra tokens:", {
          text: O,
          data: M,
          reminding: z
        });
      };
    })(o = t.parse || (t.parse = {}));
    function s(A, O, M) {
      const z = l[A[0]] || M;
      if (!z)
        throw e(`no parser registered for ${JSON.stringify(A[0])}:`, { s: A }), O;
      return z(A, O);
    }
    function a(A, O, M) {
      return A[0] === '"' ? g(A) : A[0] === "'" ? y(A) : b(A, O, M);
    }
    const l = {};
    function u(A) {
      return A.trimLeft();
    }
    l[" "] = c, l["\r"] = c, l[`
`] = c, l["	"] = c;
    function c(A, O) {
      return A = u(A), s(A, O);
    }
    l["["] = h;
    function h(A, O) {
      A = A.substr(1);
      const M = [];
      for (A = u(A); A.length > 0; ) {
        if (A[0] === "]") {
          A = A.substr(1);
          break;
        }
        const z = s(A, O, (N, P) => b(N, P, [",", "]"]));
        M.push(z[0]), A = z[1], A = u(A), A[0] === "," && (A = A.substring(1), A = u(A));
      }
      return [M, A];
    }
    for (const A of "0123456789.-".slice())
      l[A] = d;
    function d(A) {
      for (let O = 0; O < A.length; O++) {
        const M = A[O];
        if (l[M] === d)
          continue;
        const z = A.substring(0, O);
        return A = A.substring(O), [p(z), A];
      }
      return [p(A), ""];
    }
    function p(A) {
      if (A === "-")
        return -0;
      const O = +A;
      return Number.isNaN(O) ? A : O;
    }
    l['"'] = g;
    function g(A) {
      for (let O = 1; O < A.length; O++) {
        const M = A[O];
        if (M === "\\") {
          O++;
          continue;
        }
        if (M === '"') {
          const z = v(A.substring(0, O + 1));
          return A = A.substring(O + 1), [JSON.parse(z), A];
        }
      }
      return [JSON.parse(v(A) + '"'), ""];
    }
    function v(A) {
      return A.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    }
    l["'"] = y;
    function y(A) {
      for (let O = 1; O < A.length; O++) {
        const M = A[O];
        if (M === "\\") {
          O++;
          continue;
        }
        if (M === "'") {
          const z = v(A.substring(0, O + 1));
          return A = A.substring(O + 1), [JSON.parse('"' + z.slice(1, -1) + '"'), A];
        }
      }
      return [JSON.parse('"' + v(A.slice(1)) + '"'), ""];
    }
    function b(A, O, M = [" "]) {
      const z = Math.min(...M.map((I) => {
        const B = A.indexOf(I);
        return B === -1 ? A.length : B;
      })), N = A.substring(0, z).trim(), P = A.substring(z);
      return [N, P];
    }
    l["{"] = k;
    function k(A, O) {
      A = A.substr(1);
      const M = {};
      for (A = u(A); A.length > 0; ) {
        if (A[0] === "}") {
          A = A.substr(1);
          break;
        }
        const z = a(A, O, [":", "}"]), N = z[0];
        if (A = z[1], A = u(A), A[0] !== ":") {
          M[N] = void 0;
          break;
        }
        if (A = A.substr(1), A = u(A), A.length === 0) {
          M[N] = void 0;
          break;
        }
        const P = s(A, O);
        M[N] = P[0], A = P[1], A = u(A), A[0] === "," && (A = A.substr(1), A = u(A));
      }
      return [M, A];
    }
    l.t = C;
    function C(A, O) {
      return D(A, "true", !0, O);
    }
    l.f = S;
    function S(A, O) {
      return D(A, "false", !1, O);
    }
    l.n = _;
    function _(A, O) {
      return D(A, "null", null, O);
    }
    function D(A, O, M, z) {
      for (let N = O.length; N >= 1; N--)
        if (A.startsWith(O.slice(0, N)))
          return [M, A.slice(N)];
      {
        const N = JSON.stringify(A.slice(0, O.length));
        throw e(`unknown token starting with ${N}:`, { s: A }), z;
      }
    }
  })(Q7)), Q7;
}
var L$ = Bfe();
function Lfe(t) {
  let e = null;
  try {
    e = JSON.parse(t.doc.toString());
  } catch {
    try {
      e = L$.parse(t.doc.toString());
    } catch {
    }
  }
  const r = L4(t, Hr.JSON);
  return { data: e, pointers: r };
}
var zfe = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, jfe = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, qfe = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, ck = {
  Space_Separator: zfe,
  ID_Start: jfe,
  ID_Continue: qfe
}, fn = {
  isSpaceSeparator(t) {
    return typeof t == "string" && ck.Space_Separator.test(t);
  },
  isIdStartChar(t) {
    return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t === "$" || t === "_" || ck.ID_Start.test(t));
  },
  isIdContinueChar(t) {
    return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t >= "0" && t <= "9" || t === "$" || t === "_" || t === "â€Œ" || t === "â€" || ck.ID_Continue.test(t));
  },
  isDigit(t) {
    return typeof t == "string" && /[0-9]/.test(t);
  },
  isHexDigit(t) {
    return typeof t == "string" && /[0-9A-Fa-f]/.test(t);
  }
};
let LC, Pi, Bl, J1, cc, Gs, Nn, cS, Nm;
var Ufe = function(t, e) {
  LC = String(t), Pi = "start", Bl = [], J1 = 0, cc = 1, Gs = 0, Nn = void 0, cS = void 0, Nm = void 0;
  do
    Nn = Hfe(), Gfe[Pi]();
  while (Nn.type !== "eof");
  return typeof e == "function" ? zC({ "": Nm }, "", e) : Nm;
};
function zC(t, e, r) {
  const n = t[e];
  if (n != null && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0; i < n.length; i++) {
        const o = String(i), s = zC(n, o, r);
        s === void 0 ? delete n[o] : Object.defineProperty(n, o, {
          value: s,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const i in n) {
        const o = zC(n, i, r);
        o === void 0 ? delete n[i] : Object.defineProperty(n, i, {
          value: o,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return r.call(t, e, n);
}
let Ot, bt, bm, El, zt;
function Hfe() {
  for (Ot = "default", bt = "", bm = !1, El = 1; ; ) {
    zt = Wl();
    const t = z$[Ot]();
    if (t)
      return t;
  }
}
function Wl() {
  if (LC[J1])
    return String.fromCodePoint(LC.codePointAt(J1));
}
function ye() {
  const t = Wl();
  return t === `
` ? (cc++, Gs = 0) : t ? Gs += t.length : Gs++, t && (J1 += t.length), t;
}
const z$ = {
  default() {
    switch (zt) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "Â ":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        ye();
        return;
      case "/":
        ye(), Ot = "comment";
        return;
      case void 0:
        return ye(), Br("eof");
    }
    if (fn.isSpaceSeparator(zt)) {
      ye();
      return;
    }
    return z$[Pi]();
  },
  comment() {
    switch (zt) {
      case "*":
        ye(), Ot = "multiLineComment";
        return;
      case "/":
        ye(), Ot = "singleLineComment";
        return;
    }
    throw qr(ye());
  },
  multiLineComment() {
    switch (zt) {
      case "*":
        ye(), Ot = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw qr(ye());
    }
    ye();
  },
  multiLineCommentAsterisk() {
    switch (zt) {
      case "*":
        ye();
        return;
      case "/":
        ye(), Ot = "default";
        return;
      case void 0:
        throw qr(ye());
    }
    ye(), Ot = "multiLineComment";
  },
  singleLineComment() {
    switch (zt) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        ye(), Ot = "default";
        return;
      case void 0:
        return ye(), Br("eof");
    }
    ye();
  },
  value() {
    switch (zt) {
      case "{":
      case "[":
        return Br("punctuator", ye());
      case "n":
        return ye(), Pc("ull"), Br("null", null);
      case "t":
        return ye(), Pc("rue"), Br("boolean", !0);
      case "f":
        return ye(), Pc("alse"), Br("boolean", !1);
      case "-":
      case "+":
        ye() === "-" && (El = -1), Ot = "sign";
        return;
      case ".":
        bt = ye(), Ot = "decimalPointLeading";
        return;
      case "0":
        bt = ye(), Ot = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        bt = ye(), Ot = "decimalInteger";
        return;
      case "I":
        return ye(), Pc("nfinity"), Br("numeric", 1 / 0);
      case "N":
        return ye(), Pc("aN"), Br("numeric", NaN);
      case '"':
      case "'":
        bm = ye() === '"', bt = "", Ot = "string";
        return;
    }
    throw qr(ye());
  },
  identifierNameStartEscape() {
    if (zt !== "u")
      throw qr(ye());
    ye();
    const t = jC();
    switch (t) {
      case "$":
      case "_":
        break;
      default:
        if (!fn.isIdStartChar(t))
          throw Y7();
        break;
    }
    bt += t, Ot = "identifierName";
  },
  identifierName() {
    switch (zt) {
      case "$":
      case "_":
      case "â€Œ":
      case "â€":
        bt += ye();
        return;
      case "\\":
        ye(), Ot = "identifierNameEscape";
        return;
    }
    if (fn.isIdContinueChar(zt)) {
      bt += ye();
      return;
    }
    return Br("identifier", bt);
  },
  identifierNameEscape() {
    if (zt !== "u")
      throw qr(ye());
    ye();
    const t = jC();
    switch (t) {
      case "$":
      case "_":
      case "â€Œ":
      case "â€":
        break;
      default:
        if (!fn.isIdContinueChar(t))
          throw Y7();
        break;
    }
    bt += t, Ot = "identifierName";
  },
  sign() {
    switch (zt) {
      case ".":
        bt = ye(), Ot = "decimalPointLeading";
        return;
      case "0":
        bt = ye(), Ot = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        bt = ye(), Ot = "decimalInteger";
        return;
      case "I":
        return ye(), Pc("nfinity"), Br("numeric", El * (1 / 0));
      case "N":
        return ye(), Pc("aN"), Br("numeric", NaN);
    }
    throw qr(ye());
  },
  zero() {
    switch (zt) {
      case ".":
        bt += ye(), Ot = "decimalPoint";
        return;
      case "e":
      case "E":
        bt += ye(), Ot = "decimalExponent";
        return;
      case "x":
      case "X":
        bt += ye(), Ot = "hexadecimal";
        return;
    }
    return Br("numeric", El * 0);
  },
  decimalInteger() {
    switch (zt) {
      case ".":
        bt += ye(), Ot = "decimalPoint";
        return;
      case "e":
      case "E":
        bt += ye(), Ot = "decimalExponent";
        return;
    }
    if (fn.isDigit(zt)) {
      bt += ye();
      return;
    }
    return Br("numeric", El * Number(bt));
  },
  decimalPointLeading() {
    if (fn.isDigit(zt)) {
      bt += ye(), Ot = "decimalFraction";
      return;
    }
    throw qr(ye());
  },
  decimalPoint() {
    switch (zt) {
      case "e":
      case "E":
        bt += ye(), Ot = "decimalExponent";
        return;
    }
    if (fn.isDigit(zt)) {
      bt += ye(), Ot = "decimalFraction";
      return;
    }
    return Br("numeric", El * Number(bt));
  },
  decimalFraction() {
    switch (zt) {
      case "e":
      case "E":
        bt += ye(), Ot = "decimalExponent";
        return;
    }
    if (fn.isDigit(zt)) {
      bt += ye();
      return;
    }
    return Br("numeric", El * Number(bt));
  },
  decimalExponent() {
    switch (zt) {
      case "+":
      case "-":
        bt += ye(), Ot = "decimalExponentSign";
        return;
    }
    if (fn.isDigit(zt)) {
      bt += ye(), Ot = "decimalExponentInteger";
      return;
    }
    throw qr(ye());
  },
  decimalExponentSign() {
    if (fn.isDigit(zt)) {
      bt += ye(), Ot = "decimalExponentInteger";
      return;
    }
    throw qr(ye());
  },
  decimalExponentInteger() {
    if (fn.isDigit(zt)) {
      bt += ye();
      return;
    }
    return Br("numeric", El * Number(bt));
  },
  hexadecimal() {
    if (fn.isHexDigit(zt)) {
      bt += ye(), Ot = "hexadecimalInteger";
      return;
    }
    throw qr(ye());
  },
  hexadecimalInteger() {
    if (fn.isHexDigit(zt)) {
      bt += ye();
      return;
    }
    return Br("numeric", El * Number(bt));
  },
  string() {
    switch (zt) {
      case "\\":
        ye(), bt += Vfe();
        return;
      case '"':
        if (bm)
          return ye(), Br("string", bt);
        bt += ye();
        return;
      case "'":
        if (!bm)
          return ye(), Br("string", bt);
        bt += ye();
        return;
      case `
`:
      case "\r":
        throw qr(ye());
      case "\u2028":
      case "\u2029":
        Kfe(zt);
        break;
      case void 0:
        throw qr(ye());
    }
    bt += ye();
  },
  start() {
    switch (zt) {
      case "{":
      case "[":
        return Br("punctuator", ye());
    }
    Ot = "value";
  },
  beforePropertyName() {
    switch (zt) {
      case "$":
      case "_":
        bt = ye(), Ot = "identifierName";
        return;
      case "\\":
        ye(), Ot = "identifierNameStartEscape";
        return;
      case "}":
        return Br("punctuator", ye());
      case '"':
      case "'":
        bm = ye() === '"', Ot = "string";
        return;
    }
    if (fn.isIdStartChar(zt)) {
      bt += ye(), Ot = "identifierName";
      return;
    }
    throw qr(ye());
  },
  afterPropertyName() {
    if (zt === ":")
      return Br("punctuator", ye());
    throw qr(ye());
  },
  beforePropertyValue() {
    Ot = "value";
  },
  afterPropertyValue() {
    switch (zt) {
      case ",":
      case "}":
        return Br("punctuator", ye());
    }
    throw qr(ye());
  },
  beforeArrayValue() {
    if (zt === "]")
      return Br("punctuator", ye());
    Ot = "value";
  },
  afterArrayValue() {
    switch (zt) {
      case ",":
      case "]":
        return Br("punctuator", ye());
    }
    throw qr(ye());
  },
  end() {
    throw qr(ye());
  }
};
function Br(t, e) {
  return {
    type: t,
    value: e,
    line: cc,
    column: Gs
  };
}
function Pc(t) {
  for (const e of t) {
    if (Wl() !== e)
      throw qr(ye());
    ye();
  }
}
function Vfe() {
  switch (Wl()) {
    case "b":
      return ye(), "\b";
    case "f":
      return ye(), "\f";
    case "n":
      return ye(), `
`;
    case "r":
      return ye(), "\r";
    case "t":
      return ye(), "	";
    case "v":
      return ye(), "\v";
    case "0":
      if (ye(), fn.isDigit(Wl()))
        throw qr(ye());
      return "\0";
    case "x":
      return ye(), Wfe();
    case "u":
      return ye(), jC();
    case `
`:
    case "\u2028":
    case "\u2029":
      return ye(), "";
    case "\r":
      return ye(), Wl() === `
` && ye(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw qr(ye());
    case void 0:
      throw qr(ye());
  }
  return ye();
}
function Wfe() {
  let t = "", e = Wl();
  if (!fn.isHexDigit(e) || (t += ye(), e = Wl(), !fn.isHexDigit(e)))
    throw qr(ye());
  return t += ye(), String.fromCodePoint(parseInt(t, 16));
}
function jC() {
  let t = "", e = 4;
  for (; e-- > 0; ) {
    const r = Wl();
    if (!fn.isHexDigit(r))
      throw qr(ye());
    t += ye();
  }
  return String.fromCodePoint(parseInt(t, 16));
}
const Gfe = {
  start() {
    if (Nn.type === "eof")
      throw Rc();
    hk();
  },
  beforePropertyName() {
    switch (Nn.type) {
      case "identifier":
      case "string":
        cS = Nn.value, Pi = "afterPropertyName";
        return;
      case "punctuator":
        oy();
        return;
      case "eof":
        throw Rc();
    }
  },
  afterPropertyName() {
    if (Nn.type === "eof")
      throw Rc();
    Pi = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (Nn.type === "eof")
      throw Rc();
    hk();
  },
  beforeArrayValue() {
    if (Nn.type === "eof")
      throw Rc();
    if (Nn.type === "punctuator" && Nn.value === "]") {
      oy();
      return;
    }
    hk();
  },
  afterPropertyValue() {
    if (Nn.type === "eof")
      throw Rc();
    switch (Nn.value) {
      case ",":
        Pi = "beforePropertyName";
        return;
      case "}":
        oy();
    }
  },
  afterArrayValue() {
    if (Nn.type === "eof")
      throw Rc();
    switch (Nn.value) {
      case ",":
        Pi = "beforeArrayValue";
        return;
      case "]":
        oy();
    }
  },
  end() {
  }
};
function hk() {
  let t;
  switch (Nn.type) {
    case "punctuator":
      switch (Nn.value) {
        case "{":
          t = {};
          break;
        case "[":
          t = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      t = Nn.value;
      break;
  }
  if (Nm === void 0)
    Nm = t;
  else {
    const e = Bl[Bl.length - 1];
    Array.isArray(e) ? e.push(t) : Object.defineProperty(e, cS, {
      value: t,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (t !== null && typeof t == "object")
    Bl.push(t), Array.isArray(t) ? Pi = "beforeArrayValue" : Pi = "beforePropertyName";
  else {
    const e = Bl[Bl.length - 1];
    e == null ? Pi = "end" : Array.isArray(e) ? Pi = "afterArrayValue" : Pi = "afterPropertyValue";
  }
}
function oy() {
  Bl.pop();
  const t = Bl[Bl.length - 1];
  t == null ? Pi = "end" : Array.isArray(t) ? Pi = "afterArrayValue" : Pi = "afterPropertyValue";
}
function qr(t) {
  return hS(t === void 0 ? `JSON5: invalid end of input at ${cc}:${Gs}` : `JSON5: invalid character '${j$(t)}' at ${cc}:${Gs}`);
}
function Rc() {
  return hS(`JSON5: invalid end of input at ${cc}:${Gs}`);
}
function Y7() {
  return Gs -= 5, hS(`JSON5: invalid identifier character at ${cc}:${Gs}`);
}
function Kfe(t) {
  console.warn(`JSON5: '${j$(t)}' in strings is not valid ECMAScript; consider escaping`);
}
function j$(t) {
  const e = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (e[t])
    return e[t];
  if (t < " ") {
    const r = t.charCodeAt(0).toString(16);
    return "\\x" + ("00" + r).substring(r.length);
  }
  return t;
}
function hS(t) {
  const e = new SyntaxError(t);
  return e.lineNumber = cc, e.columnNumber = Gs, e;
}
var Xfe = function(t, e, r) {
  const n = [];
  let i = "", o, s, a = "", l;
  if (e != null && typeof e == "object" && !Array.isArray(e) && (r = e.space, l = e.quote, e = e.replacer), typeof e == "function")
    s = e;
  else if (Array.isArray(e)) {
    o = [];
    for (const g of e) {
      let v;
      typeof g == "string" ? v = g : (typeof g == "number" || g instanceof String || g instanceof Number) && (v = String(g)), v !== void 0 && o.indexOf(v) < 0 && o.push(v);
    }
  }
  return r instanceof Number ? r = Number(r) : r instanceof String && (r = String(r)), typeof r == "number" ? r > 0 && (r = Math.min(10, Math.floor(r)), a = "          ".substr(0, r)) : typeof r == "string" && (a = r.substr(0, 10)), u("", { "": t });
  function u(g, v) {
    let y = v[g];
    switch (y != null && (typeof y.toJSON5 == "function" ? y = y.toJSON5(g) : typeof y.toJSON == "function" && (y = y.toJSON(g))), s && (y = s.call(v, g, y)), y instanceof Number ? y = Number(y) : y instanceof String ? y = String(y) : y instanceof Boolean && (y = y.valueOf()), y) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof y == "string")
      return c(y);
    if (typeof y == "number")
      return String(y);
    if (typeof y == "object")
      return Array.isArray(y) ? p(y) : h(y);
  }
  function c(g) {
    const v = {
      "'": 0.1,
      '"': 0.2
    }, y = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let b = "";
    for (let C = 0; C < g.length; C++) {
      const S = g[C];
      switch (S) {
        case "'":
        case '"':
          v[S]++, b += S;
          continue;
        case "\0":
          if (fn.isDigit(g[C + 1])) {
            b += "\\x00";
            continue;
          }
      }
      if (y[S]) {
        b += y[S];
        continue;
      }
      if (S < " ") {
        let _ = S.charCodeAt(0).toString(16);
        b += "\\x" + ("00" + _).substring(_.length);
        continue;
      }
      b += S;
    }
    const k = l || Object.keys(v).reduce((C, S) => v[C] < v[S] ? C : S);
    return b = b.replace(new RegExp(k, "g"), y[k]), k + b + k;
  }
  function h(g) {
    if (n.indexOf(g) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    n.push(g);
    let v = i;
    i = i + a;
    let y = o || Object.keys(g), b = [];
    for (const C of y) {
      const S = u(C, g);
      if (S !== void 0) {
        let _ = d(C) + ":";
        a !== "" && (_ += " "), _ += S, b.push(_);
      }
    }
    let k;
    if (b.length === 0)
      k = "{}";
    else {
      let C;
      if (a === "")
        C = b.join(","), k = "{" + C + "}";
      else {
        let S = `,
` + i;
        C = b.join(S), k = `{
` + i + C + `,
` + v + "}";
      }
    }
    return n.pop(), i = v, k;
  }
  function d(g) {
    if (g.length === 0)
      return c(g);
    const v = String.fromCodePoint(g.codePointAt(0));
    if (!fn.isIdStartChar(v))
      return c(g);
    for (let y = v.length; y < g.length; y++)
      if (!fn.isIdContinueChar(String.fromCodePoint(g.codePointAt(y))))
        return c(g);
    return g;
  }
  function p(g) {
    if (n.indexOf(g) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    n.push(g);
    let v = i;
    i = i + a;
    let y = [];
    for (let k = 0; k < g.length; k++) {
      const C = u(String(k), g);
      y.push(C !== void 0 ? C : "null");
    }
    let b;
    if (y.length === 0)
      b = "[]";
    else if (a === "")
      b = "[" + y.join(",") + "]";
    else {
      let k = `,
` + i, C = y.join(k);
      b = `[
` + i + C + `,
` + v + "]";
    }
    return n.pop(), i = v, b;
  }
};
const Qfe = {
  parse: Ufe,
  stringify: Xfe
};
var Jfe = Qfe;
function Yfe(t) {
  const e = t.doc.toString();
  let r = null;
  try {
    r = Jfe.parse(e);
  } catch {
    try {
      r = L$.parse(e);
    } catch {
    }
  }
  const n = L4(t, Hr.JSON5);
  return { data: r, pointers: n };
}
const fS = Symbol.for("yaml.alias"), qC = Symbol.for("yaml.document"), Ku = Symbol.for("yaml.map"), q$ = Symbol.for("yaml.pair"), Ya = Symbol.for("yaml.scalar"), op = Symbol.for("yaml.seq"), _s = Symbol.for("yaml.node.type"), vc = (t) => !!t && typeof t == "object" && t[_s] === fS, qh = (t) => !!t && typeof t == "object" && t[_s] === qC, sp = (t) => !!t && typeof t == "object" && t[_s] === Ku, Gr = (t) => !!t && typeof t == "object" && t[_s] === q$, Tr = (t) => !!t && typeof t == "object" && t[_s] === Ya, ap = (t) => !!t && typeof t == "object" && t[_s] === op;
function Jr(t) {
  if (t && typeof t == "object")
    switch (t[_s]) {
      case Ku:
      case op:
        return !0;
    }
  return !1;
}
function Yr(t) {
  if (t && typeof t == "object")
    switch (t[_s]) {
      case fS:
      case Ku:
      case Ya:
      case op:
        return !0;
    }
  return !1;
}
const U$ = (t) => (Tr(t) || Jr(t)) && !!t.anchor, eo = Symbol("break visit"), H$ = Symbol("skip children"), Ha = Symbol("remove node");
function Uh(t, e) {
  const r = V$(e);
  qh(t) ? Nf(null, t.contents, r, Object.freeze([t])) === Ha && (t.contents = null) : Nf(null, t, r, Object.freeze([]));
}
Uh.BREAK = eo;
Uh.SKIP = H$;
Uh.REMOVE = Ha;
function Nf(t, e, r, n) {
  const i = W$(t, e, r, n);
  if (Yr(i) || Gr(i))
    return G$(t, n, i), Nf(t, i, r, n);
  if (typeof i != "symbol") {
    if (Jr(e)) {
      n = Object.freeze(n.concat(e));
      for (let o = 0; o < e.items.length; ++o) {
        const s = Nf(o, e.items[o], r, n);
        if (typeof s == "number")
          o = s - 1;
        else {
          if (s === eo)
            return eo;
          s === Ha && (e.items.splice(o, 1), o -= 1);
        }
      }
    } else if (Gr(e)) {
      n = Object.freeze(n.concat(e));
      const o = Nf("key", e.key, r, n);
      if (o === eo)
        return eo;
      o === Ha && (e.key = null);
      const s = Nf("value", e.value, r, n);
      if (s === eo)
        return eo;
      s === Ha && (e.value = null);
    }
  }
  return i;
}
async function nx(t, e) {
  const r = V$(e);
  qh(t) ? await $f(null, t.contents, r, Object.freeze([t])) === Ha && (t.contents = null) : await $f(null, t, r, Object.freeze([]));
}
nx.BREAK = eo;
nx.SKIP = H$;
nx.REMOVE = Ha;
async function $f(t, e, r, n) {
  const i = await W$(t, e, r, n);
  if (Yr(i) || Gr(i))
    return G$(t, n, i), $f(t, i, r, n);
  if (typeof i != "symbol") {
    if (Jr(e)) {
      n = Object.freeze(n.concat(e));
      for (let o = 0; o < e.items.length; ++o) {
        const s = await $f(o, e.items[o], r, n);
        if (typeof s == "number")
          o = s - 1;
        else {
          if (s === eo)
            return eo;
          s === Ha && (e.items.splice(o, 1), o -= 1);
        }
      }
    } else if (Gr(e)) {
      n = Object.freeze(n.concat(e));
      const o = await $f("key", e.key, r, n);
      if (o === eo)
        return eo;
      o === Ha && (e.key = null);
      const s = await $f("value", e.value, r, n);
      if (s === eo)
        return eo;
      s === Ha && (e.value = null);
    }
  }
  return i;
}
function V$(t) {
  return typeof t == "object" && (t.Collection || t.Node || t.Value) ? Object.assign({
    Alias: t.Node,
    Map: t.Node,
    Scalar: t.Node,
    Seq: t.Node
  }, t.Value && {
    Map: t.Value,
    Scalar: t.Value,
    Seq: t.Value
  }, t.Collection && {
    Map: t.Collection,
    Seq: t.Collection
  }, t) : t;
}
function W$(t, e, r, n) {
  if (typeof r == "function")
    return r(t, e, n);
  if (sp(e))
    return r.Map?.(t, e, n);
  if (ap(e))
    return r.Seq?.(t, e, n);
  if (Gr(e))
    return r.Pair?.(t, e, n);
  if (Tr(e))
    return r.Scalar?.(t, e, n);
  if (vc(e))
    return r.Alias?.(t, e, n);
}
function G$(t, e, r) {
  const n = e[e.length - 1];
  if (Jr(n))
    n.items[t] = r;
  else if (Gr(n))
    t === "key" ? n.key = r : n.value = r;
  else if (qh(n))
    n.contents = r;
  else {
    const i = vc(n) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
const Zfe = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, ede = (t) => t.replace(/[!,[\]{}]/g, (e) => Zfe[e]);
class Ei {
  constructor(e, r) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Ei.defaultYaml, e), this.tags = Object.assign({}, Ei.defaultTags, r);
  }
  clone() {
    const e = new Ei(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new Ei(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Ei.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Ei.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, r) {
    this.atNextDocument && (this.yaml = { explicit: Ei.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Ei.defaultTags), this.atNextDocument = !1);
    const n = e.trim().split(/[ \t]+/), i = n.shift();
    switch (i) {
      case "%TAG": {
        if (n.length !== 2 && (r(0, "%TAG directive should contain exactly two parts"), n.length < 2))
          return !1;
        const [o, s] = n;
        return this.tags[o] = s, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, n.length !== 1)
          return r(0, "%YAML directive should contain exactly one part"), !1;
        const [o] = n;
        if (o === "1.1" || o === "1.2")
          return this.yaml.version = o, !0;
        {
          const s = /^\d+\.\d+$/.test(o);
          return r(6, `Unsupported YAML version ${o}`, s), !1;
        }
      }
      default:
        return r(0, `Unknown directive ${i}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, r) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return r(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const s = e.slice(2, -1);
      return s === "!" || s === "!!" ? (r(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && r("Verbatim tags must end with a >"), s);
    }
    const [, n, i] = e.match(/^(.*!)([^!]*)$/s);
    i || r(`The ${e} tag has no suffix`);
    const o = this.tags[n];
    if (o)
      try {
        return o + decodeURIComponent(i);
      } catch (s) {
        return r(String(s)), null;
      }
    return n === "!" ? e : (r(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [r, n] of Object.entries(this.tags))
      if (e.startsWith(n))
        return r + ede(e.substring(n.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const r = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags);
    let i;
    if (e && n.length > 0 && Yr(e.contents)) {
      const o = {};
      Uh(e.contents, (s, a) => {
        Yr(a) && a.tag && (o[a.tag] = !0);
      }), i = Object.keys(o);
    } else
      i = [];
    for (const [o, s] of n)
      o === "!!" && s === "tag:yaml.org,2002:" || (!e || i.some((a) => a.startsWith(s))) && r.push(`%TAG ${o} ${s}`);
    return r.join(`
`);
  }
}
Ei.defaultYaml = { explicit: !1, version: "1.2" };
Ei.defaultTags = { "!!": "tag:yaml.org,2002:" };
function K$(t) {
  if (/[\x00-\x19\s,[\]{}]/.test(t)) {
    const e = `Anchor must not contain whitespace or control characters: ${JSON.stringify(t)}`;
    throw new Error(e);
  }
  return !0;
}
function X$(t) {
  const e = /* @__PURE__ */ new Set();
  return Uh(t, {
    Value(r, n) {
      n.anchor && e.add(n.anchor);
    }
  }), e;
}
function Q$(t, e) {
  for (let r = 1; ; ++r) {
    const n = `${t}${r}`;
    if (!e.has(n))
      return n;
  }
}
function tde(t, e) {
  const r = [], n = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (o) => {
      r.push(o), i ?? (i = X$(t));
      const s = Q$(e, i);
      return i.add(s), s;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const o of r) {
        const s = n.get(o);
        if (typeof s == "object" && s.anchor && (Tr(s.node) || Jr(s.node)))
          s.node.anchor = s.anchor;
        else {
          const a = new Error("Failed to resolve repeated object (this should not happen)");
          throw a.source = o, a;
        }
      }
    },
    sourceObjects: n
  };
}
function If(t, e, r, n) {
  if (n && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0, o = n.length; i < o; ++i) {
        const s = n[i], a = If(t, n, String(i), s);
        a === void 0 ? delete n[i] : a !== s && (n[i] = a);
      }
    else if (n instanceof Map)
      for (const i of Array.from(n.keys())) {
        const o = n.get(i), s = If(t, n, i, o);
        s === void 0 ? n.delete(i) : s !== o && n.set(i, s);
      }
    else if (n instanceof Set)
      for (const i of Array.from(n)) {
        const o = If(t, n, i, i);
        o === void 0 ? n.delete(i) : o !== i && (n.delete(i), n.add(o));
      }
    else
      for (const [i, o] of Object.entries(n)) {
        const s = If(t, n, i, o);
        s === void 0 ? delete n[i] : s !== o && (n[i] = s);
      }
  return t.call(e, r, n);
}
function xs(t, e, r) {
  if (Array.isArray(t))
    return t.map((n, i) => xs(n, String(i), r));
  if (t && typeof t.toJSON == "function") {
    if (!r || !U$(t))
      return t.toJSON(e, r);
    const n = { aliasCount: 0, count: 1, res: void 0 };
    r.anchors.set(t, n), r.onCreate = (o) => {
      n.res = o, delete r.onCreate;
    };
    const i = t.toJSON(e, r);
    return r.onCreate && r.onCreate(i), i;
  }
  return typeof t == "bigint" && !r?.keep ? Number(t) : t;
}
class dS {
  constructor(e) {
    Object.defineProperty(this, _s, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: r, maxAliasCount: n, onAnchor: i, reviver: o } = {}) {
    if (!qh(e))
      throw new TypeError("A document argument is required");
    const s = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: r === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof n == "number" ? n : 100
    }, a = xs(this, "", s);
    if (typeof i == "function")
      for (const { count: l, res: u } of s.anchors.values())
        i(u, l);
    return typeof o == "function" ? If(o, { "": a }, "", a) : a;
  }
}
class ix extends dS {
  constructor(e) {
    super(fS), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e, r) {
    let n;
    r?.aliasResolveCache ? n = r.aliasResolveCache : (n = [], Uh(e, {
      Node: (o, s) => {
        (vc(s) || U$(s)) && n.push(s);
      }
    }), r && (r.aliasResolveCache = n));
    let i;
    for (const o of n) {
      if (o === this)
        break;
      o.anchor === this.source && (i = o);
    }
    return i;
  }
  toJSON(e, r) {
    if (!r)
      return { source: this.source };
    const { anchors: n, doc: i, maxAliasCount: o } = r, s = this.resolve(i, r);
    if (!s) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let a = n.get(s);
    if (a || (xs(s, null, r), a = n.get(s)), !a || a.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (o >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = Gy(i, s, n)), a.count * a.aliasCount > o)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return a.res;
  }
  toString(e, r, n) {
    const i = `*${this.source}`;
    if (e) {
      if (K$(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const o = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(o);
      }
      if (e.implicitKey)
        return `${i} `;
    }
    return i;
  }
}
function Gy(t, e, r) {
  if (vc(e)) {
    const n = e.resolve(t), i = r && n && r.get(n);
    return i ? i.count * i.aliasCount : 0;
  } else if (Jr(e)) {
    let n = 0;
    for (const i of e.items) {
      const o = Gy(t, i, r);
      o > n && (n = o);
    }
    return n;
  } else if (Gr(e)) {
    const n = Gy(t, e.key, r), i = Gy(t, e.value, r);
    return Math.max(n, i);
  }
  return 1;
}
const J$ = (t) => !t || typeof t != "function" && typeof t != "object";
class vt extends dS {
  constructor(e) {
    super(Ya), this.value = e;
  }
  toJSON(e, r) {
    return r?.keep ? this.value : xs(this.value, e, r);
  }
  toString() {
    return String(this.value);
  }
}
vt.BLOCK_FOLDED = "BLOCK_FOLDED";
vt.BLOCK_LITERAL = "BLOCK_LITERAL";
vt.PLAIN = "PLAIN";
vt.QUOTE_DOUBLE = "QUOTE_DOUBLE";
vt.QUOTE_SINGLE = "QUOTE_SINGLE";
const rde = "tag:yaml.org,2002:";
function nde(t, e, r) {
  if (e) {
    const n = r.filter((o) => o.tag === e), i = n.find((o) => !o.format) ?? n[0];
    if (!i)
      throw new Error(`Tag ${e} not found`);
    return i;
  }
  return r.find((n) => n.identify?.(t) && !n.format);
}
function Eg(t, e, r) {
  if (qh(t) && (t = t.contents), Yr(t))
    return t;
  if (Gr(t)) {
    const h = r.schema[Ku].createNode?.(r.schema, null, r);
    return h.items.push(t), h;
  }
  (t instanceof String || t instanceof Number || t instanceof Boolean || typeof BigInt < "u" && t instanceof BigInt) && (t = t.valueOf());
  const { aliasDuplicateObjects: n, onAnchor: i, onTagObj: o, schema: s, sourceObjects: a } = r;
  let l;
  if (n && t && typeof t == "object") {
    if (l = a.get(t), l)
      return l.anchor ?? (l.anchor = i(t)), new ix(l.anchor);
    l = { anchor: null, node: null }, a.set(t, l);
  }
  e?.startsWith("!!") && (e = rde + e.slice(2));
  let u = nde(t, e, s.tags);
  if (!u) {
    if (t && typeof t.toJSON == "function" && (t = t.toJSON()), !t || typeof t != "object") {
      const h = new vt(t);
      return l && (l.node = h), h;
    }
    u = t instanceof Map ? s[Ku] : Symbol.iterator in Object(t) ? s[op] : s[Ku];
  }
  o && (o(u), delete r.onTagObj);
  const c = u?.createNode ? u.createNode(r.schema, t, r) : typeof u?.nodeClass?.from == "function" ? u.nodeClass.from(r.schema, t, r) : new vt(t);
  return e ? c.tag = e : u.default || (c.tag = u.tag), l && (l.node = c), c;
}
function Y1(t, e, r) {
  let n = r;
  for (let i = e.length - 1; i >= 0; --i) {
    const o = e[i];
    if (typeof o == "number" && Number.isInteger(o) && o >= 0) {
      const s = [];
      s[o] = n, n = s;
    } else
      n = /* @__PURE__ */ new Map([[o, n]]);
  }
  return Eg(n, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: t,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const xm = (t) => t == null || typeof t == "object" && !!t[Symbol.iterator]().next().done;
class Y$ extends dS {
  constructor(e, r) {
    super(e), Object.defineProperty(this, "schema", {
      value: r,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const r = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (r.schema = e), r.items = r.items.map((n) => Yr(n) || Gr(n) ? n.clone(e) : n), this.range && (r.range = this.range.slice()), r;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, r) {
    if (xm(e))
      this.add(r);
    else {
      const [n, ...i] = e, o = this.get(n, !0);
      if (Jr(o))
        o.addIn(i, r);
      else if (o === void 0 && this.schema)
        this.set(n, Y1(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.delete(r);
    const i = this.get(r, !0);
    if (Jr(i))
      return i.deleteIn(n);
    throw new Error(`Expected YAML collection at ${r}. Remaining path: ${n}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    const [n, ...i] = e, o = this.get(n, !0);
    return i.length === 0 ? !r && Tr(o) ? o.value : o : Jr(o) ? o.getIn(i, r) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((r) => {
      if (!Gr(r))
        return !1;
      const n = r.value;
      return n == null || e && Tr(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.has(r);
    const i = this.get(r, !0);
    return Jr(i) ? i.hasIn(n) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    const [n, ...i] = e;
    if (i.length === 0)
      this.set(n, r);
    else {
      const o = this.get(n, !0);
      if (Jr(o))
        o.setIn(i, r);
      else if (o === void 0 && this.schema)
        this.set(n, Y1(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
}
const ide = (t) => t.replace(/^(?!$)(?: $)?/gm, "#");
function zl(t, e) {
  return /^\n+$/.test(t) ? t.substring(1) : e ? t.replace(/^(?! *$)/gm, e) : t;
}
const Kc = (t, e, r) => t.endsWith(`
`) ? zl(r, e) : r.includes(`
`) ? `
` + zl(r, e) : (t.endsWith(" ") ? "" : " ") + r, Z$ = "flow", UC = "block", Ky = "quoted";
function ox(t, e, r = "flow", { indentAtStart: n, lineWidth: i = 80, minContentWidth: o = 20, onFold: s, onOverflow: a } = {}) {
  if (!i || i < 0)
    return t;
  i < o && (o = 0);
  const l = Math.max(1 + o, 1 + i - e.length);
  if (t.length <= l)
    return t;
  const u = [], c = {};
  let h = i - e.length;
  typeof n == "number" && (n > i - Math.max(2, o) ? u.push(0) : h = i - n);
  let d, p, g = !1, v = -1, y = -1, b = -1;
  r === UC && (v = Z7(t, v, e.length), v !== -1 && (h = v + l));
  for (let C; C = t[v += 1]; ) {
    if (r === Ky && C === "\\") {
      switch (y = v, t[v + 1]) {
        case "x":
          v += 3;
          break;
        case "u":
          v += 5;
          break;
        case "U":
          v += 9;
          break;
        default:
          v += 1;
      }
      b = v;
    }
    if (C === `
`)
      r === UC && (v = Z7(t, v, e.length)), h = v + e.length + l, d = void 0;
    else {
      if (C === " " && p && p !== " " && p !== `
` && p !== "	") {
        const S = t[v + 1];
        S && S !== " " && S !== `
` && S !== "	" && (d = v);
      }
      if (v >= h)
        if (d)
          u.push(d), h = d + l, d = void 0;
        else if (r === Ky) {
          for (; p === " " || p === "	"; )
            p = C, C = t[v += 1], g = !0;
          const S = v > b + 1 ? v - 2 : y - 1;
          if (c[S])
            return t;
          u.push(S), c[S] = !0, h = S + l, d = void 0;
        } else
          g = !0;
    }
    p = C;
  }
  if (g && a && a(), u.length === 0)
    return t;
  s && s();
  let k = t.slice(0, u[0]);
  for (let C = 0; C < u.length; ++C) {
    const S = u[C], _ = u[C + 1] || t.length;
    S === 0 ? k = `
${e}${t.slice(0, _)}` : (r === Ky && c[S] && (k += `${t[S]}\\`), k += `
${e}${t.slice(S + 1, _)}`);
  }
  return k;
}
function Z7(t, e, r) {
  let n = e, i = e + 1, o = t[i];
  for (; o === " " || o === "	"; )
    if (e < i + r)
      o = t[++e];
    else {
      do
        o = t[++e];
      while (o && o !== `
`);
      n = e, i = e + 1, o = t[i];
    }
  return n;
}
const sx = (t, e) => ({
  indentAtStart: e ? t.indent.length : t.indentAtStart,
  lineWidth: t.options.lineWidth,
  minContentWidth: t.options.minContentWidth
}), ax = (t) => /^(%|---|\.\.\.)/m.test(t);
function ode(t, e, r) {
  if (!e || e < 0)
    return !1;
  const n = e - r, i = t.length;
  if (i <= n)
    return !1;
  for (let o = 0, s = 0; o < i; ++o)
    if (t[o] === `
`) {
      if (o - s > n)
        return !0;
      if (s = o + 1, i - s <= n)
        return !1;
    }
  return !0;
}
function $m(t, e) {
  const r = JSON.stringify(t);
  if (e.options.doubleQuotedAsJSON)
    return r;
  const { implicitKey: n } = e, i = e.options.doubleQuotedMinMultiLineLength, o = e.indent || (ax(t) ? "  " : "");
  let s = "", a = 0;
  for (let l = 0, u = r[l]; u; u = r[++l])
    if (u === " " && r[l + 1] === "\\" && r[l + 2] === "n" && (s += r.slice(a, l) + "\\ ", l += 1, a = l, u = "\\"), u === "\\")
      switch (r[l + 1]) {
        case "u":
          {
            s += r.slice(a, l);
            const c = r.substr(l + 2, 4);
            switch (c) {
              case "0000":
                s += "\\0";
                break;
              case "0007":
                s += "\\a";
                break;
              case "000b":
                s += "\\v";
                break;
              case "001b":
                s += "\\e";
                break;
              case "0085":
                s += "\\N";
                break;
              case "00a0":
                s += "\\_";
                break;
              case "2028":
                s += "\\L";
                break;
              case "2029":
                s += "\\P";
                break;
              default:
                c.substr(0, 2) === "00" ? s += "\\x" + c.substr(2) : s += r.substr(l, 6);
            }
            l += 5, a = l + 1;
          }
          break;
        case "n":
          if (n || r[l + 2] === '"' || r.length < i)
            l += 1;
          else {
            for (s += r.slice(a, l) + `

`; r[l + 2] === "\\" && r[l + 3] === "n" && r[l + 4] !== '"'; )
              s += `
`, l += 2;
            s += o, r[l + 2] === " " && (s += "\\"), l += 1, a = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return s = a ? s + r.slice(a) : r, n ? s : ox(s, o, Ky, sx(e, !1));
}
function HC(t, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && t.includes(`
`) || /[ \t]\n|\n[ \t]/.test(t))
    return $m(t, e);
  const r = e.indent || (ax(t) ? "  " : ""), n = "'" + t.replace(/'/g, "''").replace(/\n+/g, `$&
${r}`) + "'";
  return e.implicitKey ? n : ox(n, r, Z$, sx(e, !1));
}
function Bf(t, e) {
  const { singleQuote: r } = e.options;
  let n;
  if (r === !1)
    n = $m;
  else {
    const i = t.includes('"'), o = t.includes("'");
    i && !o ? n = HC : o && !i ? n = $m : n = r ? HC : $m;
  }
  return n(t, e);
}
let VC;
try {
  VC = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  VC = /\n+(?!\n|$)/g;
}
function Xy({ comment: t, type: e, value: r }, n, i, o) {
  const { blockQuote: s, commentString: a, lineWidth: l } = n.options;
  if (!s || /\n[\t ]+$/.test(r))
    return Bf(r, n);
  const u = n.indent || (n.forceBlockIndent || ax(r) ? "  " : ""), c = s === "literal" ? !0 : s === "folded" || e === vt.BLOCK_FOLDED ? !1 : e === vt.BLOCK_LITERAL ? !0 : !ode(r, l, u.length);
  if (!r)
    return c ? `|
` : `>
`;
  let h, d;
  for (d = r.length; d > 0; --d) {
    const S = r[d - 1];
    if (S !== `
` && S !== "	" && S !== " ")
      break;
  }
  let p = r.substring(d);
  const g = p.indexOf(`
`);
  g === -1 ? h = "-" : r === p || g !== p.length - 1 ? (h = "+", o && o()) : h = "", p && (r = r.slice(0, -p.length), p[p.length - 1] === `
` && (p = p.slice(0, -1)), p = p.replace(VC, `$&${u}`));
  let v = !1, y, b = -1;
  for (y = 0; y < r.length; ++y) {
    const S = r[y];
    if (S === " ")
      v = !0;
    else if (S === `
`)
      b = y;
    else
      break;
  }
  let k = r.substring(0, b < y ? b + 1 : y);
  k && (r = r.substring(k.length), k = k.replace(/\n+/g, `$&${u}`));
  let C = (v ? u ? "2" : "1" : "") + h;
  if (t && (C += " " + a(t.replace(/ ?[\r\n]+/g, " ")), i && i()), !c) {
    const S = r.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${u}`);
    let _ = !1;
    const D = sx(n, !0);
    s !== "folded" && e !== vt.BLOCK_FOLDED && (D.onOverflow = () => {
      _ = !0;
    });
    const A = ox(`${k}${S}${p}`, u, UC, D);
    if (!_)
      return `>${C}
${u}${A}`;
  }
  return r = r.replace(/\n+/g, `$&${u}`), `|${C}
${u}${k}${r}${p}`;
}
function sde(t, e, r, n) {
  const { type: i, value: o } = t, { actualString: s, implicitKey: a, indent: l, indentStep: u, inFlow: c } = e;
  if (a && o.includes(`
`) || c && /[[\]{},]/.test(o))
    return Bf(o, e);
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
    return a || c || !o.includes(`
`) ? Bf(o, e) : Xy(t, e, r, n);
  if (!a && !c && i !== vt.PLAIN && o.includes(`
`))
    return Xy(t, e, r, n);
  if (ax(o)) {
    if (l === "")
      return e.forceBlockIndent = !0, Xy(t, e, r, n);
    if (a && l === u)
      return Bf(o, e);
  }
  const h = o.replace(/\n+/g, `$&
${l}`);
  if (s) {
    const d = (v) => v.default && v.tag !== "tag:yaml.org,2002:str" && v.test?.test(h), { compat: p, tags: g } = e.doc.schema;
    if (g.some(d) || p?.some(d))
      return Bf(o, e);
  }
  return a ? h : ox(h, l, Z$, sx(e, !1));
}
function d0(t, e, r, n) {
  const { implicitKey: i, inFlow: o } = e, s = typeof t.value == "string" ? t : Object.assign({}, t, { value: String(t.value) });
  let { type: a } = t;
  a !== vt.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(s.value) && (a = vt.QUOTE_DOUBLE);
  const l = (c) => {
    switch (c) {
      case vt.BLOCK_FOLDED:
      case vt.BLOCK_LITERAL:
        return i || o ? Bf(s.value, e) : Xy(s, e, r, n);
      case vt.QUOTE_DOUBLE:
        return $m(s.value, e);
      case vt.QUOTE_SINGLE:
        return HC(s.value, e);
      case vt.PLAIN:
        return sde(s, e, r, n);
      default:
        return null;
    }
  };
  let u = l(a);
  if (u === null) {
    const { defaultKeyType: c, defaultStringType: h } = e.options, d = i && c || h;
    if (u = l(d), u === null)
      throw new Error(`Unsupported default string type ${d}`);
  }
  return u;
}
function eI(t, e) {
  const r = Object.assign({
    blockQuote: !0,
    commentString: ide,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, t.schema.toStringOptions, e);
  let n;
  switch (r.collectionStyle) {
    case "block":
      n = !1;
      break;
    case "flow":
      n = !0;
      break;
    default:
      n = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: t,
    flowCollectionPadding: r.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof r.indent == "number" ? " ".repeat(r.indent) : "  ",
    inFlow: n,
    options: r
  };
}
function ade(t, e) {
  if (e.tag) {
    const i = t.filter((o) => o.tag === e.tag);
    if (i.length > 0)
      return i.find((o) => o.format === e.format) ?? i[0];
  }
  let r, n;
  if (Tr(e)) {
    n = e.value;
    let i = t.filter((o) => o.identify?.(n));
    if (i.length > 1) {
      const o = i.filter((s) => s.test);
      o.length > 0 && (i = o);
    }
    r = i.find((o) => o.format === e.format) ?? i.find((o) => !o.format);
  } else
    n = e, r = t.find((i) => i.nodeClass && n instanceof i.nodeClass);
  if (!r) {
    const i = n?.constructor?.name ?? (n === null ? "null" : typeof n);
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return r;
}
function lde(t, e, { anchors: r, doc: n }) {
  if (!n.directives)
    return "";
  const i = [], o = (Tr(t) || Jr(t)) && t.anchor;
  o && K$(o) && (r.add(o), i.push(`&${o}`));
  const s = t.tag ?? (e.default ? null : e.tag);
  return s && i.push(n.directives.tagString(s)), i.join(" ");
}
function Md(t, e, r, n) {
  if (Gr(t))
    return t.toString(e, r, n);
  if (vc(t)) {
    if (e.doc.directives)
      return t.toString(e);
    if (e.resolvedAliases?.has(t))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(t) : e.resolvedAliases = /* @__PURE__ */ new Set([t]), t = t.resolve(e.doc);
  }
  let i;
  const o = Yr(t) ? t : e.doc.createNode(t, { onTagObj: (l) => i = l });
  i ?? (i = ade(e.doc.schema.tags, o));
  const s = lde(o, i, e);
  s.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + s.length + 1);
  const a = typeof i.stringify == "function" ? i.stringify(o, e, r, n) : Tr(o) ? d0(o, e, r, n) : o.toString(e, r, n);
  return s ? Tr(o) || a[0] === "{" || a[0] === "[" ? `${s} ${a}` : `${s}
${e.indent}${a}` : a;
}
function ude({ key: t, value: e }, r, n, i) {
  const { allNullValues: o, doc: s, indent: a, indentStep: l, options: { commentString: u, indentSeq: c, simpleKeys: h } } = r;
  let d = Yr(t) && t.comment || null;
  if (h) {
    if (d)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (Jr(t) || !Yr(t) && typeof t == "object") {
      const A = "With simple keys, collection cannot be used as a key value";
      throw new Error(A);
    }
  }
  let p = !h && (!t || d && e == null && !r.inFlow || Jr(t) || (Tr(t) ? t.type === vt.BLOCK_FOLDED || t.type === vt.BLOCK_LITERAL : typeof t == "object"));
  r = Object.assign({}, r, {
    allNullValues: !1,
    implicitKey: !p && (h || !o),
    indent: a + l
  });
  let g = !1, v = !1, y = Md(t, r, () => g = !0, () => v = !0);
  if (!p && !r.inFlow && y.length > 1024) {
    if (h)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    p = !0;
  }
  if (r.inFlow) {
    if (o || e == null)
      return g && n && n(), y === "" ? "?" : p ? `? ${y}` : y;
  } else if (o && !h || e == null && p)
    return y = `? ${y}`, d && !g ? y += Kc(y, r.indent, u(d)) : v && i && i(), y;
  g && (d = null), p ? (d && (y += Kc(y, r.indent, u(d))), y = `? ${y}
${a}:`) : (y = `${y}:`, d && (y += Kc(y, r.indent, u(d))));
  let b, k, C;
  Yr(e) ? (b = !!e.spaceBefore, k = e.commentBefore, C = e.comment) : (b = !1, k = null, C = null, e && typeof e == "object" && (e = s.createNode(e))), r.implicitKey = !1, !p && !d && Tr(e) && (r.indentAtStart = y.length + 1), v = !1, !c && l.length >= 2 && !r.inFlow && !p && ap(e) && !e.flow && !e.tag && !e.anchor && (r.indent = r.indent.substring(2));
  let S = !1;
  const _ = Md(e, r, () => S = !0, () => v = !0);
  let D = " ";
  if (d || b || k) {
    if (D = b ? `
` : "", k) {
      const A = u(k);
      D += `
${zl(A, r.indent)}`;
    }
    _ === "" && !r.inFlow ? D === `
` && (D = `

`) : D += `
${r.indent}`;
  } else if (!p && Jr(e)) {
    const A = _[0], O = _.indexOf(`
`), M = O !== -1, z = r.inFlow ?? e.flow ?? e.items.length === 0;
    if (M || !z) {
      let N = !1;
      if (M && (A === "&" || A === "!")) {
        let P = _.indexOf(" ");
        A === "&" && P !== -1 && P < O && _[P + 1] === "!" && (P = _.indexOf(" ", P + 1)), (P === -1 || O < P) && (N = !0);
      }
      N || (D = `
${r.indent}`);
    }
  } else (_ === "" || _[0] === `
`) && (D = "");
  return y += D + _, r.inFlow ? S && n && n() : C && !S ? y += Kc(y, r.indent, u(C)) : v && i && i(), y;
}
function tI(t, e) {
  (t === "debug" || t === "warn") && console.warn(e);
}
const sy = "<<", Gl = {
  identify: (t) => t === sy || typeof t == "symbol" && t.description === sy,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new vt(Symbol(sy)), {
    addToJSMap: rI
  }),
  stringify: () => sy
}, cde = (t, e) => (Gl.identify(e) || Tr(e) && (!e.type || e.type === vt.PLAIN) && Gl.identify(e.value)) && t?.doc.schema.tags.some((r) => r.tag === Gl.tag && r.default);
function rI(t, e, r) {
  if (r = t && vc(r) ? r.resolve(t.doc) : r, ap(r))
    for (const n of r.items)
      fk(t, e, n);
  else if (Array.isArray(r))
    for (const n of r)
      fk(t, e, n);
  else
    fk(t, e, r);
}
function fk(t, e, r) {
  const n = t && vc(r) ? r.resolve(t.doc) : r;
  if (!sp(n))
    throw new Error("Merge sources must be maps or map aliases");
  const i = n.toJSON(null, t, Map);
  for (const [o, s] of i)
    e instanceof Map ? e.has(o) || e.set(o, s) : e instanceof Set ? e.add(o) : Object.prototype.hasOwnProperty.call(e, o) || Object.defineProperty(e, o, {
      value: s,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function nI(t, e, { key: r, value: n }) {
  if (Yr(r) && r.addToJSMap)
    r.addToJSMap(t, e, n);
  else if (cde(t, r))
    rI(t, e, n);
  else {
    const i = xs(r, "", t);
    if (e instanceof Map)
      e.set(i, xs(n, i, t));
    else if (e instanceof Set)
      e.add(i);
    else {
      const o = hde(r, i, t), s = xs(n, o, t);
      o in e ? Object.defineProperty(e, o, {
        value: s,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[o] = s;
    }
  }
  return e;
}
function hde(t, e, r) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (Yr(t) && r?.doc) {
    const n = eI(r.doc, {});
    n.anchors = /* @__PURE__ */ new Set();
    for (const o of r.anchors.keys())
      n.anchors.add(o.anchor);
    n.inFlow = !0, n.inStringifyKey = !0;
    const i = t.toString(n);
    if (!r.mapKeyWarned) {
      let o = JSON.stringify(i);
      o.length > 40 && (o = o.substring(0, 36) + '..."'), tI(r.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${o}. Set mapAsMap: true to use object keys.`), r.mapKeyWarned = !0;
    }
    return i;
  }
  return JSON.stringify(e);
}
function pS(t, e, r) {
  const n = Eg(t, void 0, r), i = Eg(e, void 0, r);
  return new fi(n, i);
}
class fi {
  constructor(e, r = null) {
    Object.defineProperty(this, _s, { value: q$ }), this.key = e, this.value = r;
  }
  clone(e) {
    let { key: r, value: n } = this;
    return Yr(r) && (r = r.clone(e)), Yr(n) && (n = n.clone(e)), new fi(r, n);
  }
  toJSON(e, r) {
    const n = r?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return nI(r, n, this);
  }
  toString(e, r, n) {
    return e?.doc ? ude(this, e, r, n) : JSON.stringify(this);
  }
}
function iI(t, e, r) {
  return (e.inFlow ?? t.flow ? dde : fde)(t, e, r);
}
function fde({ comment: t, items: e }, r, { blockItemPrefix: n, flowChars: i, itemIndent: o, onChompKeep: s, onComment: a }) {
  const { indent: l, options: { commentString: u } } = r, c = Object.assign({}, r, { indent: o, type: null });
  let h = !1;
  const d = [];
  for (let g = 0; g < e.length; ++g) {
    const v = e[g];
    let y = null;
    if (Yr(v))
      !h && v.spaceBefore && d.push(""), Z1(r, d, v.commentBefore, h), v.comment && (y = v.comment);
    else if (Gr(v)) {
      const k = Yr(v.key) ? v.key : null;
      k && (!h && k.spaceBefore && d.push(""), Z1(r, d, k.commentBefore, h));
    }
    h = !1;
    let b = Md(v, c, () => y = null, () => h = !0);
    y && (b += Kc(b, o, u(y))), h && y && (h = !1), d.push(n + b);
  }
  let p;
  if (d.length === 0)
    p = i.start + i.end;
  else {
    p = d[0];
    for (let g = 1; g < d.length; ++g) {
      const v = d[g];
      p += v ? `
${l}${v}` : `
`;
    }
  }
  return t ? (p += `
` + zl(u(t), l), a && a()) : h && s && s(), p;
}
function dde({ items: t }, e, { flowChars: r, itemIndent: n }) {
  const { indent: i, indentStep: o, flowCollectionPadding: s, options: { commentString: a } } = e;
  n += o;
  const l = Object.assign({}, e, {
    indent: n,
    inFlow: !0,
    type: null
  });
  let u = !1, c = 0;
  const h = [];
  for (let g = 0; g < t.length; ++g) {
    const v = t[g];
    let y = null;
    if (Yr(v))
      v.spaceBefore && h.push(""), Z1(e, h, v.commentBefore, !1), v.comment && (y = v.comment);
    else if (Gr(v)) {
      const k = Yr(v.key) ? v.key : null;
      k && (k.spaceBefore && h.push(""), Z1(e, h, k.commentBefore, !1), k.comment && (u = !0));
      const C = Yr(v.value) ? v.value : null;
      C ? (C.comment && (y = C.comment), C.commentBefore && (u = !0)) : v.value == null && k?.comment && (y = k.comment);
    }
    y && (u = !0);
    let b = Md(v, l, () => y = null);
    g < t.length - 1 && (b += ","), y && (b += Kc(b, n, a(y))), !u && (h.length > c || b.includes(`
`)) && (u = !0), h.push(b), c = h.length;
  }
  const { start: d, end: p } = r;
  if (h.length === 0)
    return d + p;
  if (!u) {
    const g = h.reduce((v, y) => v + y.length + 2, 2);
    u = e.options.lineWidth > 0 && g > e.options.lineWidth;
  }
  if (u) {
    let g = d;
    for (const v of h)
      g += v ? `
${o}${i}${v}` : `
`;
    return `${g}
${i}${p}`;
  } else
    return `${d}${s}${h.join(" ")}${s}${p}`;
}
function Z1({ indent: t, options: { commentString: e } }, r, n, i) {
  if (n && i && (n = n.replace(/^\n+/, "")), n) {
    const o = zl(e(n), t);
    r.push(o.trimStart());
  }
}
function Xc(t, e) {
  const r = Tr(e) ? e.value : e;
  for (const n of t)
    if (Gr(n) && (n.key === e || n.key === r || Tr(n.key) && n.key.value === r))
      return n;
}
class Io extends Y$ {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(Ku, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, r, n) {
    const { keepUndefined: i, replacer: o } = n, s = new this(e), a = (l, u) => {
      if (typeof o == "function")
        u = o.call(r, l, u);
      else if (Array.isArray(o) && !o.includes(l))
        return;
      (u !== void 0 || i) && s.items.push(pS(l, u, n));
    };
    if (r instanceof Map)
      for (const [l, u] of r)
        a(l, u);
    else if (r && typeof r == "object")
      for (const l of Object.keys(r))
        a(l, r[l]);
    return typeof e.sortMapEntries == "function" && s.items.sort(e.sortMapEntries), s;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, r) {
    let n;
    Gr(e) ? n = e : !e || typeof e != "object" || !("key" in e) ? n = new fi(e, e?.value) : n = new fi(e.key, e.value);
    const i = Xc(this.items, n.key), o = this.schema?.sortMapEntries;
    if (i) {
      if (!r)
        throw new Error(`Key ${n.key} already set`);
      Tr(i.value) && J$(n.value) ? i.value.value = n.value : i.value = n.value;
    } else if (o) {
      const s = this.items.findIndex((a) => o(n, a) < 0);
      s === -1 ? this.items.push(n) : this.items.splice(s, 0, n);
    } else
      this.items.push(n);
  }
  delete(e) {
    const r = Xc(this.items, e);
    return r ? this.items.splice(this.items.indexOf(r), 1).length > 0 : !1;
  }
  get(e, r) {
    const n = Xc(this.items, e)?.value;
    return (!r && Tr(n) ? n.value : n) ?? void 0;
  }
  has(e) {
    return !!Xc(this.items, e);
  }
  set(e, r) {
    this.add(new fi(e, r), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, r, n) {
    const i = n ? new n() : r?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    r?.onCreate && r.onCreate(i);
    for (const o of this.items)
      nI(r, i, o);
    return i;
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!Gr(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), iI(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: n,
      onComment: r
    });
  }
}
const lp = {
  collection: "map",
  default: !0,
  nodeClass: Io,
  tag: "tag:yaml.org,2002:map",
  resolve(t, e) {
    return sp(t) || e("Expected a mapping for this tag"), t;
  },
  createNode: (t, e, r) => Io.from(t, e, r)
};
class hc extends Y$ {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(op, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const r = ay(e);
    return typeof r != "number" ? !1 : this.items.splice(r, 1).length > 0;
  }
  get(e, r) {
    const n = ay(e);
    if (typeof n != "number")
      return;
    const i = this.items[n];
    return !r && Tr(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const r = ay(e);
    return typeof r == "number" && r < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, r) {
    const n = ay(e);
    if (typeof n != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const i = this.items[n];
    Tr(i) && J$(r) ? i.value = r : this.items[n] = r;
  }
  toJSON(e, r) {
    const n = [];
    r?.onCreate && r.onCreate(n);
    let i = 0;
    for (const o of this.items)
      n.push(xs(o, String(i++), r));
    return n;
  }
  toString(e, r, n) {
    return e ? iI(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: n,
      onComment: r
    }) : JSON.stringify(this);
  }
  static from(e, r, n) {
    const { replacer: i } = n, o = new this(e);
    if (r && Symbol.iterator in Object(r)) {
      let s = 0;
      for (let a of r) {
        if (typeof i == "function") {
          const l = r instanceof Set ? a : String(s++);
          a = i.call(r, l, a);
        }
        o.items.push(Eg(a, void 0, n));
      }
    }
    return o;
  }
}
function ay(t) {
  let e = Tr(t) ? t.value : t;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
const up = {
  collection: "seq",
  default: !0,
  nodeClass: hc,
  tag: "tag:yaml.org,2002:seq",
  resolve(t, e) {
    return ap(t) || e("Expected a sequence for this tag"), t;
  },
  createNode: (t, e, r) => hc.from(t, e, r)
}, lx = {
  identify: (t) => typeof t == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (t) => t,
  stringify(t, e, r, n) {
    return e = Object.assign({ actualString: !0 }, e), d0(t, e, r, n);
  }
}, ux = {
  identify: (t) => t == null,
  createNode: () => new vt(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new vt(null),
  stringify: ({ source: t }, e) => typeof t == "string" && ux.test.test(t) ? t : e.options.nullStr
}, mS = {
  identify: (t) => typeof t == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (t) => new vt(t[0] === "t" || t[0] === "T"),
  stringify({ source: t, value: e }, r) {
    if (t && mS.test.test(t)) {
      const n = t[0] === "t" || t[0] === "T";
      if (e === n)
        return t;
    }
    return e ? r.options.trueStr : r.options.falseStr;
  }
};
function la({ format: t, minFractionDigits: e, tag: r, value: n }) {
  if (typeof n == "bigint")
    return String(n);
  const i = typeof n == "number" ? n : Number(n);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let o = JSON.stringify(n);
  if (!t && e && (!r || r === "tag:yaml.org,2002:float") && /^\d/.test(o)) {
    let s = o.indexOf(".");
    s < 0 && (s = o.length, o += ".");
    let a = e - (o.length - s - 1);
    for (; a-- > 0; )
      o += "0";
  }
  return o;
}
const oI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: la
}, sI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : la(t);
  }
}, aI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(t) {
    const e = new vt(parseFloat(t)), r = t.indexOf(".");
    return r !== -1 && t[t.length - 1] === "0" && (e.minFractionDigits = t.length - r - 1), e;
  },
  stringify: la
}, cx = (t) => typeof t == "bigint" || Number.isInteger(t), gS = (t, e, r, { intAsBigInt: n }) => n ? BigInt(t) : parseInt(t.substring(e), r);
function lI(t, e, r) {
  const { value: n } = t;
  return cx(n) && n >= 0 ? r + n.toString(e) : la(t);
}
const uI = {
  identify: (t) => cx(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (t, e, r) => gS(t, 2, 8, r),
  stringify: (t) => lI(t, 8, "0o")
}, cI = {
  identify: cx,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (t, e, r) => gS(t, 0, 10, r),
  stringify: la
}, hI = {
  identify: (t) => cx(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (t, e, r) => gS(t, 2, 16, r),
  stringify: (t) => lI(t, 16, "0x")
}, pde = [
  lp,
  up,
  lx,
  ux,
  mS,
  uI,
  cI,
  hI,
  oI,
  sI,
  aI
];
function e9(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}
const ly = ({ value: t }) => JSON.stringify(t), mde = [
  {
    identify: (t) => typeof t == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (t) => t,
    stringify: ly
  },
  {
    identify: (t) => t == null,
    createNode: () => new vt(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: ly
  },
  {
    identify: (t) => typeof t == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (t) => t === "true",
    stringify: ly
  },
  {
    identify: e9,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (t, e, { intAsBigInt: r }) => r ? BigInt(t) : parseInt(t, 10),
    stringify: ({ value: t }) => e9(t) ? t.toString() : JSON.stringify(t)
  },
  {
    identify: (t) => typeof t == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (t) => parseFloat(t),
    stringify: ly
  }
], gde = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(t, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(t)}`), t;
  }
}, vde = [lp, up].concat(mde, gde), vS = {
  identify: (t) => t instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(t, e) {
    if (typeof atob == "function") {
      const r = atob(t.replace(/[\n\r]/g, "")), n = new Uint8Array(r.length);
      for (let i = 0; i < r.length; ++i)
        n[i] = r.charCodeAt(i);
      return n;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), t;
  },
  stringify({ comment: t, type: e, value: r }, n, i, o) {
    if (!r)
      return "";
    const s = r;
    let a;
    if (typeof btoa == "function") {
      let l = "";
      for (let u = 0; u < s.length; ++u)
        l += String.fromCharCode(s[u]);
      a = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e ?? (e = vt.BLOCK_LITERAL), e !== vt.QUOTE_DOUBLE) {
      const l = Math.max(n.options.lineWidth - n.indent.length, n.options.minContentWidth), u = Math.ceil(a.length / l), c = new Array(u);
      for (let h = 0, d = 0; h < u; ++h, d += l)
        c[h] = a.substr(d, l);
      a = c.join(e === vt.BLOCK_LITERAL ? `
` : " ");
    }
    return d0({ comment: t, type: e, value: a }, n, i, o);
  }
};
function fI(t, e) {
  if (ap(t))
    for (let r = 0; r < t.items.length; ++r) {
      let n = t.items[r];
      if (!Gr(n)) {
        if (sp(n)) {
          n.items.length > 1 && e("Each pair must have its own sequence indicator");
          const i = n.items[0] || new fi(new vt(null));
          if (n.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${n.commentBefore}
${i.key.commentBefore}` : n.commentBefore), n.comment) {
            const o = i.value ?? i.key;
            o.comment = o.comment ? `${n.comment}
${o.comment}` : n.comment;
          }
          n = i;
        }
        t.items[r] = Gr(n) ? n : new fi(n);
      }
    }
  else
    e("Expected a sequence for this tag");
  return t;
}
function dI(t, e, r) {
  const { replacer: n } = r, i = new hc(t);
  i.tag = "tag:yaml.org,2002:pairs";
  let o = 0;
  if (e && Symbol.iterator in Object(e))
    for (let s of e) {
      typeof n == "function" && (s = n.call(e, String(o++), s));
      let a, l;
      if (Array.isArray(s))
        if (s.length === 2)
          a = s[0], l = s[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${s}`);
      else if (s && s instanceof Object) {
        const u = Object.keys(s);
        if (u.length === 1)
          a = u[0], l = s[a];
        else
          throw new TypeError(`Expected tuple with one key, not ${u.length} keys`);
      } else
        a = s;
      i.items.push(pS(a, l, r));
    }
  return i;
}
const yS = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: fI,
  createNode: dI
};
class td extends hc {
  constructor() {
    super(), this.add = Io.prototype.add.bind(this), this.delete = Io.prototype.delete.bind(this), this.get = Io.prototype.get.bind(this), this.has = Io.prototype.has.bind(this), this.set = Io.prototype.set.bind(this), this.tag = td.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, r) {
    if (!r)
      return super.toJSON(e);
    const n = /* @__PURE__ */ new Map();
    r?.onCreate && r.onCreate(n);
    for (const i of this.items) {
      let o, s;
      if (Gr(i) ? (o = xs(i.key, "", r), s = xs(i.value, o, r)) : o = xs(i, "", r), n.has(o))
        throw new Error("Ordered maps must not include duplicate keys");
      n.set(o, s);
    }
    return n;
  }
  static from(e, r, n) {
    const i = dI(e, r, n), o = new this();
    return o.items = i.items, o;
  }
}
td.tag = "tag:yaml.org,2002:omap";
const bS = {
  collection: "seq",
  identify: (t) => t instanceof Map,
  nodeClass: td,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(t, e) {
    const r = fI(t, e), n = [];
    for (const { key: i } of r.items)
      Tr(i) && (n.includes(i.value) ? e(`Ordered maps must not include duplicate keys: ${i.value}`) : n.push(i.value));
    return Object.assign(new td(), r);
  },
  createNode: (t, e, r) => td.from(t, e, r)
};
function pI({ value: t, source: e }, r) {
  return e && (t ? mI : gI).test.test(e) ? e : t ? r.options.trueStr : r.options.falseStr;
}
const mI = {
  identify: (t) => t === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new vt(!0),
  stringify: pI
}, gI = {
  identify: (t) => t === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new vt(!1),
  stringify: pI
}, yde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: la
}, bde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t.replace(/_/g, "")),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : la(t);
  }
}, xde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(t) {
    const e = new vt(parseFloat(t.replace(/_/g, ""))), r = t.indexOf(".");
    if (r !== -1) {
      const n = t.substring(r + 1).replace(/_/g, "");
      n[n.length - 1] === "0" && (e.minFractionDigits = n.length);
    }
    return e;
  },
  stringify: la
}, p0 = (t) => typeof t == "bigint" || Number.isInteger(t);
function hx(t, e, r, { intAsBigInt: n }) {
  const i = t[0];
  if ((i === "-" || i === "+") && (e += 1), t = t.substring(e).replace(/_/g, ""), n) {
    switch (r) {
      case 2:
        t = `0b${t}`;
        break;
      case 8:
        t = `0o${t}`;
        break;
      case 16:
        t = `0x${t}`;
        break;
    }
    const s = BigInt(t);
    return i === "-" ? BigInt(-1) * s : s;
  }
  const o = parseInt(t, r);
  return i === "-" ? -1 * o : o;
}
function xS(t, e, r) {
  const { value: n } = t;
  if (p0(n)) {
    const i = n.toString(e);
    return n < 0 ? "-" + r + i.substr(1) : r + i;
  }
  return la(t);
}
const wde = {
  identify: p0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (t, e, r) => hx(t, 2, 2, r),
  stringify: (t) => xS(t, 2, "0b")
}, kde = {
  identify: p0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (t, e, r) => hx(t, 1, 8, r),
  stringify: (t) => xS(t, 8, "0")
}, Cde = {
  identify: p0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (t, e, r) => hx(t, 0, 10, r),
  stringify: la
}, _de = {
  identify: p0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (t, e, r) => hx(t, 2, 16, r),
  stringify: (t) => xS(t, 16, "0x")
};
class rd extends Io {
  constructor(e) {
    super(e), this.tag = rd.tag;
  }
  add(e) {
    let r;
    Gr(e) ? r = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? r = new fi(e.key, null) : r = new fi(e, null), Xc(this.items, r.key) || this.items.push(r);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, r) {
    const n = Xc(this.items, e);
    return !r && Gr(n) ? Tr(n.key) ? n.key.value : n.key : n;
  }
  set(e, r) {
    if (typeof r != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof r}`);
    const n = Xc(this.items, e);
    n && !r ? this.items.splice(this.items.indexOf(n), 1) : !n && r && this.items.push(new fi(e));
  }
  toJSON(e, r) {
    return super.toJSON(e, r, Set);
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), r, n);
    throw new Error("Set items must all have null values");
  }
  static from(e, r, n) {
    const { replacer: i } = n, o = new this(e);
    if (r && Symbol.iterator in Object(r))
      for (let s of r)
        typeof i == "function" && (s = i.call(r, s, s)), o.items.push(pS(s, null, n));
    return o;
  }
}
rd.tag = "tag:yaml.org,2002:set";
const wS = {
  collection: "map",
  identify: (t) => t instanceof Set,
  nodeClass: rd,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (t, e, r) => rd.from(t, e, r),
  resolve(t, e) {
    if (sp(t)) {
      if (t.hasAllNullValues(!0))
        return Object.assign(new rd(), t);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return t;
  }
};
function kS(t, e) {
  const r = t[0], n = r === "-" || r === "+" ? t.substring(1) : t, i = (s) => e ? BigInt(s) : Number(s), o = n.replace(/_/g, "").split(":").reduce((s, a) => s * i(60) + i(a), i(0));
  return r === "-" ? i(-1) * o : o;
}
function vI(t) {
  let { value: e } = t, r = (s) => s;
  if (typeof e == "bigint")
    r = (s) => BigInt(s);
  else if (isNaN(e) || !isFinite(e))
    return la(t);
  let n = "";
  e < 0 && (n = "-", e *= r(-1));
  const i = r(60), o = [e % i];
  return e < 60 ? o.unshift(0) : (e = (e - o[0]) / i, o.unshift(e % i), e >= 60 && (e = (e - o[0]) / i, o.unshift(e))), n + o.map((s) => String(s).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const yI = {
  identify: (t) => typeof t == "bigint" || Number.isInteger(t),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (t, e, { intAsBigInt: r }) => kS(t, r),
  stringify: vI
}, bI = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (t) => kS(t, !1),
  stringify: vI
}, fx = {
  identify: (t) => t instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(t) {
    const e = t.match(fx.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, r, n, i, o, s, a] = e.map(Number), l = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let u = Date.UTC(r, n - 1, i, o || 0, s || 0, a || 0, l);
    const c = e[8];
    if (c && c !== "Z") {
      let h = kS(c, !1);
      Math.abs(h) < 30 && (h *= 60), u -= 6e4 * h;
    }
    return new Date(u);
  },
  stringify: ({ value: t }) => t?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
}, t9 = [
  lp,
  up,
  lx,
  ux,
  mI,
  gI,
  wde,
  kde,
  Cde,
  _de,
  yde,
  bde,
  xde,
  vS,
  Gl,
  bS,
  yS,
  wS,
  yI,
  bI,
  fx
], r9 = /* @__PURE__ */ new Map([
  ["core", pde],
  ["failsafe", [lp, up, lx]],
  ["json", vde],
  ["yaml11", t9],
  ["yaml-1.1", t9]
]), n9 = {
  binary: vS,
  bool: mS,
  float: aI,
  floatExp: sI,
  floatNaN: oI,
  floatTime: bI,
  int: cI,
  intHex: hI,
  intOct: uI,
  intTime: yI,
  map: lp,
  merge: Gl,
  null: ux,
  omap: bS,
  pairs: yS,
  seq: up,
  set: wS,
  timestamp: fx
}, Sde = {
  "tag:yaml.org,2002:binary": vS,
  "tag:yaml.org,2002:merge": Gl,
  "tag:yaml.org,2002:omap": bS,
  "tag:yaml.org,2002:pairs": yS,
  "tag:yaml.org,2002:set": wS,
  "tag:yaml.org,2002:timestamp": fx
};
function dk(t, e, r) {
  const n = r9.get(e);
  if (n && !t)
    return r && !n.includes(Gl) ? n.concat(Gl) : n.slice();
  let i = n;
  if (!i)
    if (Array.isArray(t))
      i = [];
    else {
      const o = Array.from(r9.keys()).filter((s) => s !== "yaml11").map((s) => JSON.stringify(s)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${o} or define customTags array`);
    }
  if (Array.isArray(t))
    for (const o of t)
      i = i.concat(o);
  else typeof t == "function" && (i = t(i.slice()));
  return r && (i = i.concat(Gl)), i.reduce((o, s) => {
    const a = typeof s == "string" ? n9[s] : s;
    if (!a) {
      const l = JSON.stringify(s), u = Object.keys(n9).map((c) => JSON.stringify(c)).join(", ");
      throw new Error(`Unknown custom tag ${l}; use one of ${u}`);
    }
    return o.includes(a) || o.push(a), o;
  }, []);
}
const Ade = (t, e) => t.key < e.key ? -1 : t.key > e.key ? 1 : 0;
class dx {
  constructor({ compat: e, customTags: r, merge: n, resolveKnownTags: i, schema: o, sortMapEntries: s, toStringDefaults: a }) {
    this.compat = Array.isArray(e) ? dk(e, "compat") : e ? dk(null, e) : null, this.name = typeof o == "string" && o || "core", this.knownTags = i ? Sde : {}, this.tags = dk(r, this.name, n), this.toStringOptions = a ?? null, Object.defineProperty(this, Ku, { value: lp }), Object.defineProperty(this, Ya, { value: lx }), Object.defineProperty(this, op, { value: up }), this.sortMapEntries = typeof s == "function" ? s : s === !0 ? Ade : null;
  }
  clone() {
    const e = Object.create(dx.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
}
function Ede(t, e) {
  const r = [];
  let n = e.directives === !0;
  if (e.directives !== !1 && t.directives) {
    const l = t.directives.toString(t);
    l ? (r.push(l), n = !0) : t.directives.docStart && (n = !0);
  }
  n && r.push("---");
  const i = eI(t, e), { commentString: o } = i.options;
  if (t.commentBefore) {
    r.length !== 1 && r.unshift("");
    const l = o(t.commentBefore);
    r.unshift(zl(l, ""));
  }
  let s = !1, a = null;
  if (t.contents) {
    if (Yr(t.contents)) {
      if (t.contents.spaceBefore && n && r.push(""), t.contents.commentBefore) {
        const c = o(t.contents.commentBefore);
        r.push(zl(c, ""));
      }
      i.forceBlockIndent = !!t.comment, a = t.contents.comment;
    }
    const l = a ? void 0 : () => s = !0;
    let u = Md(t.contents, i, () => a = null, l);
    a && (u += Kc(u, "", o(a))), (u[0] === "|" || u[0] === ">") && r[r.length - 1] === "---" ? r[r.length - 1] = `--- ${u}` : r.push(u);
  } else
    r.push(Md(t.contents, i));
  if (t.directives?.docEnd)
    if (t.comment) {
      const l = o(t.comment);
      l.includes(`
`) ? (r.push("..."), r.push(zl(l, ""))) : r.push(`... ${l}`);
    } else
      r.push("...");
  else {
    let l = t.comment;
    l && s && (l = l.replace(/^\n+/, "")), l && ((!s || a) && r[r.length - 1] !== "" && r.push(""), r.push(zl(o(l), "")));
  }
  return r.join(`
`) + `
`;
}
class cp {
  constructor(e, r, n) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, _s, { value: qC });
    let i = null;
    typeof r == "function" || Array.isArray(r) ? i = r : n === void 0 && r && (n = r, r = void 0);
    const o = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      stringKeys: !1,
      uniqueKeys: !0,
      version: "1.2"
    }, n);
    this.options = o;
    let { version: s } = o;
    n?._directives ? (this.directives = n._directives.atDocument(), this.directives.yaml.explicit && (s = this.directives.yaml.version)) : this.directives = new Ei({ version: s }), this.setSchema(s, n), this.contents = e === void 0 ? null : this.createNode(e, i, n);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(cp.prototype, {
      [_s]: { value: qC }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = Yr(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    xf(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, r) {
    xf(this.contents) && this.contents.addIn(e, r);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, r) {
    if (!e.anchor) {
      const n = X$(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !r || n.has(r) ? Q$(r || "a", n) : r;
    }
    return new ix(e.anchor);
  }
  createNode(e, r, n) {
    let i;
    if (typeof r == "function")
      e = r.call({ "": e }, "", e), i = r;
    else if (Array.isArray(r)) {
      const y = (k) => typeof k == "number" || k instanceof String || k instanceof Number, b = r.filter(y).map(String);
      b.length > 0 && (r = r.concat(b)), i = r;
    } else n === void 0 && r && (n = r, r = void 0);
    const { aliasDuplicateObjects: o, anchorPrefix: s, flow: a, keepUndefined: l, onTagObj: u, tag: c } = n ?? {}, { onAnchor: h, setAnchors: d, sourceObjects: p } = tde(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      s || "a"
    ), g = {
      aliasDuplicateObjects: o ?? !0,
      keepUndefined: l ?? !1,
      onAnchor: h,
      onTagObj: u,
      replacer: i,
      schema: this.schema,
      sourceObjects: p
    }, v = Eg(e, c, g);
    return a && Jr(v) && (v.flow = !0), d(), v;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, r, n = {}) {
    const i = this.createNode(e, null, n), o = this.createNode(r, null, n);
    return new fi(i, o);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return xf(this.contents) ? this.contents.delete(e) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return xm(e) ? this.contents == null ? !1 : (this.contents = null, !0) : xf(this.contents) ? this.contents.deleteIn(e) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, r) {
    return Jr(this.contents) ? this.contents.get(e, r) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    return xm(e) ? !r && Tr(this.contents) ? this.contents.value : this.contents : Jr(this.contents) ? this.contents.getIn(e, r) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return Jr(this.contents) ? this.contents.has(e) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return xm(e) ? this.contents !== void 0 : Jr(this.contents) ? this.contents.hasIn(e) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, r) {
    this.contents == null ? this.contents = Y1(this.schema, [e], r) : xf(this.contents) && this.contents.set(e, r);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    xm(e) ? this.contents = r : this.contents == null ? this.contents = Y1(this.schema, Array.from(e), r) : xf(this.contents) && this.contents.setIn(e, r);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, r = {}) {
    typeof e == "number" && (e = String(e));
    let n;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Ei({ version: "1.1" }), n = { resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Ei({ version: e }), n = { resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, n = null;
        break;
      default: {
        const i = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (r.schema instanceof Object)
      this.schema = r.schema;
    else if (n)
      this.schema = new dx(Object.assign(n, r));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: r, mapAsMap: n, maxAliasCount: i, onAnchor: o, reviver: s } = {}) {
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: n === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof i == "number" ? i : 100
    }, l = xs(this.contents, r ?? "", a);
    if (typeof o == "function")
      for (const { count: u, res: c } of a.anchors.values())
        o(c, u);
    return typeof s == "function" ? If(s, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, r) {
    return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: r });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const r = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${r}`);
    }
    return Ede(this, e);
  }
}
function xf(t) {
  if (Jr(t))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class CS extends Error {
  constructor(e, r, n, i) {
    super(), this.name = e, this.code = n, this.message = i, this.pos = r;
  }
}
class Qc extends CS {
  constructor(e, r, n) {
    super("YAMLParseError", e, r, n);
  }
}
class xI extends CS {
  constructor(e, r, n) {
    super("YAMLWarning", e, r, n);
  }
}
const eb = (t, e) => (r) => {
  if (r.pos[0] === -1)
    return;
  r.linePos = r.pos.map((a) => e.linePos(a));
  const { line: n, col: i } = r.linePos[0];
  r.message += ` at line ${n}, column ${i}`;
  let o = i - 1, s = t.substring(e.lineStarts[n - 1], e.lineStarts[n]).replace(/[\n\r]+$/, "");
  if (o >= 60 && s.length > 80) {
    const a = Math.min(o - 39, s.length - 79);
    s = "â€¦" + s.substring(a), o -= a - 1;
  }
  if (s.length > 80 && (s = s.substring(0, 79) + "â€¦"), n > 1 && /^ *$/.test(s.substring(0, o))) {
    let a = t.substring(e.lineStarts[n - 2], e.lineStarts[n - 1]);
    a.length > 80 && (a = a.substring(0, 79) + `â€¦
`), s = a + s;
  }
  if (/[^ ]/.test(s)) {
    let a = 1;
    const l = r.linePos[1];
    l && l.line === n && l.col > i && (a = Math.max(1, Math.min(l.col - i, 80 - o)));
    const u = " ".repeat(o) + "^".repeat(a);
    r.message += `:

${s}
${u}
`;
  }
};
function Pd(t, { flow: e, indicator: r, next: n, offset: i, onError: o, parentIndent: s, startOnNewline: a }) {
  let l = !1, u = a, c = a, h = "", d = "", p = !1, g = !1, v = null, y = null, b = null, k = null, C = null, S = null, _ = null;
  for (const O of t)
    switch (g && (O.type !== "space" && O.type !== "newline" && O.type !== "comma" && o(O.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), g = !1), v && (u && O.type !== "comment" && O.type !== "newline" && o(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), v = null), O.type) {
      case "space":
        !e && (r !== "doc-start" || n?.type !== "flow-collection") && O.source.includes("	") && (v = O), c = !0;
        break;
      case "comment": {
        c || o(O, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const M = O.source.substring(1) || " ";
        h ? h += d + M : h = M, d = "", u = !1;
        break;
      }
      case "newline":
        u ? h ? h += O.source : (!S || r !== "seq-item-ind") && (l = !0) : d += O.source, u = !0, p = !0, (y || b) && (k = O), c = !0;
        break;
      case "anchor":
        y && o(O, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), O.source.endsWith(":") && o(O.offset + O.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), y = O, _ ?? (_ = O.offset), u = !1, c = !1, g = !0;
        break;
      case "tag": {
        b && o(O, "MULTIPLE_TAGS", "A node can have at most one tag"), b = O, _ ?? (_ = O.offset), u = !1, c = !1, g = !0;
        break;
      }
      case r:
        (y || b) && o(O, "BAD_PROP_ORDER", `Anchors and tags must be after the ${O.source} indicator`), S && o(O, "UNEXPECTED_TOKEN", `Unexpected ${O.source} in ${e ?? "collection"}`), S = O, u = r === "seq-item-ind" || r === "explicit-key-ind", c = !1;
        break;
      case "comma":
        if (e) {
          C && o(O, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), C = O, u = !1, c = !1;
          break;
        }
      // else fallthrough
      default:
        o(O, "UNEXPECTED_TOKEN", `Unexpected ${O.type} token`), u = !1, c = !1;
    }
  const D = t[t.length - 1], A = D ? D.offset + D.source.length : i;
  return g && n && n.type !== "space" && n.type !== "newline" && n.type !== "comma" && (n.type !== "scalar" || n.source !== "") && o(n.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), v && (u && v.indent <= s || n?.type === "block-map" || n?.type === "block-seq") && o(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: C,
    found: S,
    spaceBefore: l,
    comment: h,
    hasNewline: p,
    anchor: y,
    tag: b,
    newlineAfterProp: k,
    end: A,
    start: _ ?? A
  };
}
function Dg(t) {
  if (!t)
    return null;
  switch (t.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (t.source.includes(`
`))
        return !0;
      if (t.end) {
        for (const e of t.end)
          if (e.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const e of t.items) {
        for (const r of e.start)
          if (r.type === "newline")
            return !0;
        if (e.sep) {
          for (const r of e.sep)
            if (r.type === "newline")
              return !0;
        }
        if (Dg(e.key) || Dg(e.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function WC(t, e, r) {
  if (e?.type === "flow-collection") {
    const n = e.end[0];
    n.indent === t && (n.source === "]" || n.source === "}") && Dg(e) && r(n, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function wI(t, e, r) {
  const { uniqueKeys: n } = t.options;
  if (n === !1)
    return !1;
  const i = typeof n == "function" ? n : (o, s) => o === s || Tr(o) && Tr(s) && o.value === s.value;
  return e.some((o) => i(o.key, r));
}
const i9 = "All mapping items must start at the same column";
function Dde({ composeNode: t, composeEmptyNode: e }, r, n, i, o) {
  const s = o?.nodeClass ?? Io, a = new s(r.schema);
  r.atRoot && (r.atRoot = !1);
  let l = n.offset, u = null;
  for (const c of n.items) {
    const { start: h, key: d, sep: p, value: g } = c, v = Pd(h, {
      indicator: "explicit-key-ind",
      next: d ?? p?.[0],
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !0
    }), y = !v.found;
    if (y) {
      if (d && (d.type === "block-seq" ? i(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in d && d.indent !== n.indent && i(l, "BAD_INDENT", i9)), !v.anchor && !v.tag && !p) {
        u = v.end, v.comment && (a.comment ? a.comment += `
` + v.comment : a.comment = v.comment);
        continue;
      }
      (v.newlineAfterProp || Dg(d)) && i(d ?? h[h.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else v.found?.indent !== n.indent && i(l, "BAD_INDENT", i9);
    r.atKey = !0;
    const b = v.end, k = d ? t(r, d, v, i) : e(r, b, h, null, v, i);
    r.schema.compat && WC(n.indent, d, i), r.atKey = !1, wI(r, a.items, k) && i(b, "DUPLICATE_KEY", "Map keys must be unique");
    const C = Pd(p ?? [], {
      indicator: "map-value-ind",
      next: g,
      offset: k.range[2],
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !d || d.type === "block-scalar"
    });
    if (l = C.end, C.found) {
      y && (g?.type === "block-map" && !C.hasNewline && i(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), r.options.strict && v.start < C.found.offset - 1024 && i(k.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const S = g ? t(r, g, C, i) : e(r, l, p, null, C, i);
      r.schema.compat && WC(n.indent, g, i), l = S.range[2];
      const _ = new fi(k, S);
      r.options.keepSourceTokens && (_.srcToken = c), a.items.push(_);
    } else {
      y && i(k.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), C.comment && (k.comment ? k.comment += `
` + C.comment : k.comment = C.comment);
      const S = new fi(k);
      r.options.keepSourceTokens && (S.srcToken = c), a.items.push(S);
    }
  }
  return u && u < l && i(u, "IMPOSSIBLE", "Map comment with trailing content"), a.range = [n.offset, l, u ?? l], a;
}
function Ode({ composeNode: t, composeEmptyNode: e }, r, n, i, o) {
  const s = o?.nodeClass ?? hc, a = new s(r.schema);
  r.atRoot && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let l = n.offset, u = null;
  for (const { start: c, value: h } of n.items) {
    const d = Pd(c, {
      indicator: "seq-item-ind",
      next: h,
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !0
    });
    if (!d.found)
      if (d.anchor || d.tag || h)
        h && h.type === "block-seq" ? i(d.end, "BAD_INDENT", "All sequence items must start at the same column") : i(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        u = d.end, d.comment && (a.comment = d.comment);
        continue;
      }
    const p = h ? t(r, h, d, i) : e(r, d.end, c, null, d, i);
    r.schema.compat && WC(n.indent, h, i), l = p.range[2], a.items.push(p);
  }
  return a.range = [n.offset, l, u ?? l], a;
}
function m0(t, e, r, n) {
  let i = "";
  if (t) {
    let o = !1, s = "";
    for (const a of t) {
      const { source: l, type: u } = a;
      switch (u) {
        case "space":
          o = !0;
          break;
        case "comment": {
          r && !o && n(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const c = l.substring(1) || " ";
          i ? i += s + c : i = c, s = "";
          break;
        }
        case "newline":
          i && (s += l), o = !0;
          break;
        default:
          n(a, "UNEXPECTED_TOKEN", `Unexpected ${u} at node end`);
      }
      e += l.length;
    }
  }
  return { comment: i, offset: e };
}
const pk = "Block collections are not allowed within flow collections", mk = (t) => t && (t.type === "block-map" || t.type === "block-seq");
function Fde({ composeNode: t, composeEmptyNode: e }, r, n, i, o) {
  const s = n.start.source === "{", a = s ? "flow map" : "flow sequence", l = o?.nodeClass ?? (s ? Io : hc), u = new l(r.schema);
  u.flow = !0;
  const c = r.atRoot;
  c && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let h = n.offset + n.start.source.length;
  for (let y = 0; y < n.items.length; ++y) {
    const b = n.items[y], { start: k, key: C, sep: S, value: _ } = b, D = Pd(k, {
      flow: a,
      indicator: "explicit-key-ind",
      next: C ?? S?.[0],
      offset: h,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !1
    });
    if (!D.found) {
      if (!D.anchor && !D.tag && !S && !_) {
        y === 0 && D.comma ? i(D.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`) : y < n.items.length - 1 && i(D.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${a}`), D.comment && (u.comment ? u.comment += `
` + D.comment : u.comment = D.comment), h = D.end;
        continue;
      }
      !s && r.options.strict && Dg(C) && i(
        C,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (y === 0)
      D.comma && i(D.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`);
    else if (D.comma || i(D.start, "MISSING_CHAR", `Missing , between ${a} items`), D.comment) {
      let A = "";
      e: for (const O of k)
        switch (O.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            A = O.source.substring(1);
            break e;
          default:
            break e;
        }
      if (A) {
        let O = u.items[u.items.length - 1];
        Gr(O) && (O = O.value ?? O.key), O.comment ? O.comment += `
` + A : O.comment = A, D.comment = D.comment.substring(A.length + 1);
      }
    }
    if (!s && !S && !D.found) {
      const A = _ ? t(r, _, D, i) : e(r, D.end, S, null, D, i);
      u.items.push(A), h = A.range[2], mk(_) && i(A.range, "BLOCK_IN_FLOW", pk);
    } else {
      r.atKey = !0;
      const A = D.end, O = C ? t(r, C, D, i) : e(r, A, k, null, D, i);
      mk(C) && i(O.range, "BLOCK_IN_FLOW", pk), r.atKey = !1;
      const M = Pd(S ?? [], {
        flow: a,
        indicator: "map-value-ind",
        next: _,
        offset: O.range[2],
        onError: i,
        parentIndent: n.indent,
        startOnNewline: !1
      });
      if (M.found) {
        if (!s && !D.found && r.options.strict) {
          if (S)
            for (const P of S) {
              if (P === M.found)
                break;
              if (P.type === "newline") {
                i(P, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          D.start < M.found.offset - 1024 && i(M.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else _ && ("source" in _ && _.source && _.source[0] === ":" ? i(_, "MISSING_CHAR", `Missing space after : in ${a}`) : i(M.start, "MISSING_CHAR", `Missing , or : between ${a} items`));
      const z = _ ? t(r, _, M, i) : M.found ? e(r, M.end, S, null, M, i) : null;
      z ? mk(_) && i(z.range, "BLOCK_IN_FLOW", pk) : M.comment && (O.comment ? O.comment += `
` + M.comment : O.comment = M.comment);
      const N = new fi(O, z);
      if (r.options.keepSourceTokens && (N.srcToken = b), s) {
        const P = u;
        wI(r, P.items, O) && i(A, "DUPLICATE_KEY", "Map keys must be unique"), P.items.push(N);
      } else {
        const P = new Io(r.schema);
        P.flow = !0, P.items.push(N);
        const I = (z ?? O).range;
        P.range = [O.range[0], I[1], I[2]], u.items.push(P);
      }
      h = z ? z.range[2] : M.end;
    }
  }
  const d = s ? "}" : "]", [p, ...g] = n.end;
  let v = h;
  if (p && p.source === d)
    v = p.offset + p.source.length;
  else {
    const y = a[0].toUpperCase() + a.substring(1), b = c ? `${y} must end with a ${d}` : `${y} in block collection must be sufficiently indented and end with a ${d}`;
    i(h, c ? "MISSING_CHAR" : "BAD_INDENT", b), p && p.source.length !== 1 && g.unshift(p);
  }
  if (g.length > 0) {
    const y = m0(g, v, r.options.strict, i);
    y.comment && (u.comment ? u.comment += `
` + y.comment : u.comment = y.comment), u.range = [n.offset, v, y.offset];
  } else
    u.range = [n.offset, v, v];
  return u;
}
function gk(t, e, r, n, i, o) {
  const s = r.type === "block-map" ? Dde(t, e, r, n, o) : r.type === "block-seq" ? Ode(t, e, r, n, o) : Fde(t, e, r, n, o), a = s.constructor;
  return i === "!" || i === a.tagName ? (s.tag = a.tagName, s) : (i && (s.tag = i), s);
}
function Tde(t, e, r, n, i) {
  const o = n.tag, s = o ? e.directives.tagName(o.source, (d) => i(o, "TAG_RESOLVE_FAILED", d)) : null;
  if (r.type === "block-seq") {
    const { anchor: d, newlineAfterProp: p } = n, g = d && o ? d.offset > o.offset ? d : o : d ?? o;
    g && (!p || p.offset < g.offset) && i(g, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const a = r.type === "block-map" ? "map" : r.type === "block-seq" ? "seq" : r.start.source === "{" ? "map" : "seq";
  if (!o || !s || s === "!" || s === Io.tagName && a === "map" || s === hc.tagName && a === "seq")
    return gk(t, e, r, i, s);
  let l = e.schema.tags.find((d) => d.tag === s && d.collection === a);
  if (!l) {
    const d = e.schema.knownTags[s];
    if (d && d.collection === a)
      e.schema.tags.push(Object.assign({}, d, { default: !1 })), l = d;
    else
      return d ? i(o, "BAD_COLLECTION_TYPE", `${d.tag} used for ${a} collection, but expects ${d.collection ?? "scalar"}`, !0) : i(o, "TAG_RESOLVE_FAILED", `Unresolved tag: ${s}`, !0), gk(t, e, r, i, s);
  }
  const u = gk(t, e, r, i, s, l), c = l.resolve?.(u, (d) => i(o, "TAG_RESOLVE_FAILED", d), e.options) ?? u, h = Yr(c) ? c : new vt(c);
  return h.range = u.range, h.tag = s, l?.format && (h.format = l.format), h;
}
function kI(t, e, r) {
  const n = e.offset, i = Mde(e, t.options.strict, r);
  if (!i)
    return { value: "", type: null, comment: "", range: [n, n, n] };
  const o = i.mode === ">" ? vt.BLOCK_FOLDED : vt.BLOCK_LITERAL, s = e.source ? Pde(e.source) : [];
  let a = s.length;
  for (let v = s.length - 1; v >= 0; --v) {
    const y = s[v][1];
    if (y === "" || y === "\r")
      a = v;
    else
      break;
  }
  if (a === 0) {
    const v = i.chomp === "+" && s.length > 0 ? `
`.repeat(Math.max(1, s.length - 1)) : "";
    let y = n + i.length;
    return e.source && (y += e.source.length), { value: v, type: o, comment: i.comment, range: [n, y, y] };
  }
  let l = e.indent + i.indent, u = e.offset + i.length, c = 0;
  for (let v = 0; v < a; ++v) {
    const [y, b] = s[v];
    if (b === "" || b === "\r")
      i.indent === 0 && y.length > l && (l = y.length);
    else {
      y.length < l && r(u + y.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (l = y.length), c = v, l === 0 && !t.atRoot && r(u, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    u += y.length + b.length + 1;
  }
  for (let v = s.length - 1; v >= a; --v)
    s[v][0].length > l && (a = v + 1);
  let h = "", d = "", p = !1;
  for (let v = 0; v < c; ++v)
    h += s[v][0].slice(l) + `
`;
  for (let v = c; v < a; ++v) {
    let [y, b] = s[v];
    u += y.length + b.length + 1;
    const k = b[b.length - 1] === "\r";
    if (k && (b = b.slice(0, -1)), b && y.length < l) {
      const C = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      r(u - b.length - (k ? 2 : 1), "BAD_INDENT", C), y = "";
    }
    o === vt.BLOCK_LITERAL ? (h += d + y.slice(l) + b, d = `
`) : y.length > l || b[0] === "	" ? (d === " " ? d = `
` : !p && d === `
` && (d = `

`), h += d + y.slice(l) + b, d = `
`, p = !0) : b === "" ? d === `
` ? h += `
` : d = `
` : (h += d + b, d = " ", p = !1);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let v = a; v < s.length; ++v)
        h += `
` + s[v][0].slice(l);
      h[h.length - 1] !== `
` && (h += `
`);
      break;
    default:
      h += `
`;
  }
  const g = n + i.length + e.source.length;
  return { value: h, type: o, comment: i.comment, range: [n, g, g] };
}
function Mde({ offset: t, props: e }, r, n) {
  if (e[0].type !== "block-scalar-header")
    return n(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = e[0], o = i[0];
  let s = 0, a = "", l = -1;
  for (let d = 1; d < i.length; ++d) {
    const p = i[d];
    if (!a && (p === "-" || p === "+"))
      a = p;
    else {
      const g = Number(p);
      !s && g ? s = g : l === -1 && (l = t + d);
    }
  }
  l !== -1 && n(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let u = !1, c = "", h = i.length;
  for (let d = 1; d < e.length; ++d) {
    const p = e[d];
    switch (p.type) {
      case "space":
        u = !0;
      // fallthrough
      case "newline":
        h += p.source.length;
        break;
      case "comment":
        r && !u && n(p, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), h += p.source.length, c = p.source.substring(1);
        break;
      case "error":
        n(p, "UNEXPECTED_TOKEN", p.message), h += p.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const g = `Unexpected token in block scalar header: ${p.type}`;
        n(p, "UNEXPECTED_TOKEN", g);
        const v = p.source;
        v && typeof v == "string" && (h += v.length);
      }
    }
  }
  return { mode: o, indent: s, chomp: a, comment: c, length: h };
}
function Pde(t) {
  const e = t.split(/\n( *)/), r = e[0], n = r.match(/^( *)/), i = [n?.[1] ? [n[1], r.slice(n[1].length)] : ["", r]];
  for (let o = 1; o < e.length; o += 2)
    i.push([e[o], e[o + 1]]);
  return i;
}
function CI(t, e, r) {
  const { offset: n, type: i, source: o, end: s } = t;
  let a, l;
  const u = (d, p, g) => r(n + d, p, g);
  switch (i) {
    case "scalar":
      a = vt.PLAIN, l = Rde(o, u);
      break;
    case "single-quoted-scalar":
      a = vt.QUOTE_SINGLE, l = Nde(o, u);
      break;
    case "double-quoted-scalar":
      a = vt.QUOTE_DOUBLE, l = $de(o, u);
      break;
    /* istanbul ignore next should not happen */
    default:
      return r(t, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [n, n + o.length, n + o.length]
      };
  }
  const c = n + o.length, h = m0(s, c, e, r);
  return {
    value: l,
    type: a,
    comment: h.comment,
    range: [n, c, h.offset]
  };
}
function Rde(t, e) {
  let r = "";
  switch (t[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      r = "a tab character";
      break;
    case ",":
      r = "flow indicator character ,";
      break;
    case "%":
      r = "directive indicator character %";
      break;
    case "|":
    case ">": {
      r = `block scalar indicator ${t[0]}`;
      break;
    }
    case "@":
    case "`": {
      r = `reserved character ${t[0]}`;
      break;
    }
  }
  return r && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${r}`), _I(t);
}
function Nde(t, e) {
  return (t[t.length - 1] !== "'" || t.length === 1) && e(t.length, "MISSING_CHAR", "Missing closing 'quote"), _I(t.slice(1, -1)).replace(/''/g, "'");
}
function _I(t) {
  let e, r;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), r = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, r = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let n = e.exec(t);
  if (!n)
    return t;
  let i = n[1], o = " ", s = e.lastIndex;
  for (r.lastIndex = s; n = r.exec(t); )
    n[1] === "" ? o === `
` ? i += o : o = `
` : (i += o + n[1], o = " "), s = r.lastIndex;
  const a = /[ \t]*(.*)/sy;
  return a.lastIndex = s, n = a.exec(t), i + o + (n?.[1] ?? "");
}
function $de(t, e) {
  let r = "";
  for (let n = 1; n < t.length - 1; ++n) {
    const i = t[n];
    if (!(i === "\r" && t[n + 1] === `
`))
      if (i === `
`) {
        const { fold: o, offset: s } = Ide(t, n);
        r += o, n = s;
      } else if (i === "\\") {
        let o = t[++n];
        const s = Bde[o];
        if (s)
          r += s;
        else if (o === `
`)
          for (o = t[n + 1]; o === " " || o === "	"; )
            o = t[++n + 1];
        else if (o === "\r" && t[n + 1] === `
`)
          for (o = t[++n + 1]; o === " " || o === "	"; )
            o = t[++n + 1];
        else if (o === "x" || o === "u" || o === "U") {
          const a = { x: 2, u: 4, U: 8 }[o];
          r += Lde(t, n + 1, a, e), n += a;
        } else {
          const a = t.substr(n - 1, 2);
          e(n - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), r += a;
        }
      } else if (i === " " || i === "	") {
        const o = n;
        let s = t[n + 1];
        for (; s === " " || s === "	"; )
          s = t[++n + 1];
        s !== `
` && !(s === "\r" && t[n + 2] === `
`) && (r += n > o ? t.slice(o, n + 1) : i);
      } else
        r += i;
  }
  return (t[t.length - 1] !== '"' || t.length === 1) && e(t.length, "MISSING_CHAR", 'Missing closing "quote'), r;
}
function Ide(t, e) {
  let r = "", n = t[e + 1];
  for (; (n === " " || n === "	" || n === `
` || n === "\r") && !(n === "\r" && t[e + 2] !== `
`); )
    n === `
` && (r += `
`), e += 1, n = t[e + 1];
  return r || (r = " "), { fold: r, offset: e };
}
const Bde = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "Â…",
  // Unicode next line
  _: "Â ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function Lde(t, e, r, n) {
  const i = t.substr(e, r), o = i.length === r && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(o)) {
    const s = t.substr(e - 2, r + 2);
    return n(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${s}`), s;
  }
  return String.fromCodePoint(o);
}
function SI(t, e, r, n) {
  const { value: i, type: o, comment: s, range: a } = e.type === "block-scalar" ? kI(t, e, n) : CI(e, t.options.strict, n), l = r ? t.directives.tagName(r.source, (h) => n(r, "TAG_RESOLVE_FAILED", h)) : null;
  let u;
  t.options.stringKeys && t.atKey ? u = t.schema[Ya] : l ? u = zde(t.schema, i, l, r, n) : e.type === "scalar" ? u = jde(t, i, e, n) : u = t.schema[Ya];
  let c;
  try {
    const h = u.resolve(i, (d) => n(r ?? e, "TAG_RESOLVE_FAILED", d), t.options);
    c = Tr(h) ? h : new vt(h);
  } catch (h) {
    const d = h instanceof Error ? h.message : String(h);
    n(r ?? e, "TAG_RESOLVE_FAILED", d), c = new vt(i);
  }
  return c.range = a, c.source = i, o && (c.type = o), l && (c.tag = l), u.format && (c.format = u.format), s && (c.comment = s), c;
}
function zde(t, e, r, n, i) {
  if (r === "!")
    return t[Ya];
  const o = [];
  for (const a of t.tags)
    if (!a.collection && a.tag === r)
      if (a.default && a.test)
        o.push(a);
      else
        return a;
  for (const a of o)
    if (a.test?.test(e))
      return a;
  const s = t.knownTags[r];
  return s && !s.collection ? (t.tags.push(Object.assign({}, s, { default: !1, test: void 0 })), s) : (i(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${r}`, r !== "tag:yaml.org,2002:str"), t[Ya]);
}
function jde({ atKey: t, directives: e, schema: r }, n, i, o) {
  const s = r.tags.find((a) => (a.default === !0 || t && a.default === "key") && a.test?.test(n)) || r[Ya];
  if (r.compat) {
    const a = r.compat.find((l) => l.default && l.test?.test(n)) ?? r[Ya];
    if (s.tag !== a.tag) {
      const l = e.tagString(s.tag), u = e.tagString(a.tag), c = `Value may be parsed as either ${l} or ${u}`;
      o(i, "TAG_RESOLVE_FAILED", c, !0);
    }
  }
  return s;
}
function qde(t, e, r) {
  if (e) {
    r ?? (r = e.length);
    for (let n = r - 1; n >= 0; --n) {
      let i = e[n];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          t -= i.source.length;
          continue;
      }
      for (i = e[++n]; i?.type === "space"; )
        t += i.source.length, i = e[++n];
      break;
    }
  }
  return t;
}
const Ude = { composeNode: AI, composeEmptyNode: _S };
function AI(t, e, r, n) {
  const i = t.atKey, { spaceBefore: o, comment: s, anchor: a, tag: l } = r;
  let u, c = !0;
  switch (e.type) {
    case "alias":
      u = Hde(t, e, n), (a || l) && n(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      u = SI(t, e, l, n), a && (u.anchor = a.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      u = Tde(Ude, t, e, r, n), a && (u.anchor = a.source.substring(1));
      break;
    default: {
      const h = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      n(e, "UNEXPECTED_TOKEN", h), u = _S(t, e.offset, void 0, null, r, n), c = !1;
    }
  }
  return a && u.anchor === "" && n(a, "BAD_ALIAS", "Anchor cannot be an empty string"), i && t.options.stringKeys && (!Tr(u) || typeof u.value != "string" || u.tag && u.tag !== "tag:yaml.org,2002:str") && n(l ?? e, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), o && (u.spaceBefore = !0), s && (e.type === "scalar" && e.source === "" ? u.comment = s : u.commentBefore = s), t.options.keepSourceTokens && c && (u.srcToken = e), u;
}
function _S(t, e, r, n, { spaceBefore: i, comment: o, anchor: s, tag: a, end: l }, u) {
  const c = {
    type: "scalar",
    offset: qde(e, r, n),
    indent: -1,
    source: ""
  }, h = SI(t, c, a, u);
  return s && (h.anchor = s.source.substring(1), h.anchor === "" && u(s, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (h.spaceBefore = !0), o && (h.comment = o, h.range[2] = l), h;
}
function Hde({ options: t }, { offset: e, source: r, end: n }, i) {
  const o = new ix(r.substring(1));
  o.source === "" && i(e, "BAD_ALIAS", "Alias cannot be an empty string"), o.source.endsWith(":") && i(e + r.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const s = e + r.length, a = m0(n, s, t.strict, i);
  return o.range = [e, s, a.offset], a.comment && (o.comment = a.comment), o;
}
function Vde(t, e, { offset: r, start: n, value: i, end: o }, s) {
  const a = Object.assign({ _directives: e }, t), l = new cp(void 0, a), u = {
    atKey: !1,
    atRoot: !0,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, c = Pd(n, {
    indicator: "doc-start",
    next: i ?? o?.[0],
    offset: r,
    onError: s,
    parentIndent: 0,
    startOnNewline: !0
  });
  c.found && (l.directives.docStart = !0, i && (i.type === "block-map" || i.type === "block-seq") && !c.hasNewline && s(c.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = i ? AI(u, i, c, s) : _S(u, c.end, n, null, c, s);
  const h = l.contents.range[2], d = m0(o, h, !1, s);
  return d.comment && (l.comment = d.comment), l.range = [r, h, d.offset], l;
}
function nm(t) {
  if (typeof t == "number")
    return [t, t + 1];
  if (Array.isArray(t))
    return t.length === 2 ? t : [t[0], t[1]];
  const { offset: e, source: r } = t;
  return [e, e + (typeof r == "string" ? r.length : 1)];
}
function o9(t) {
  let e = "", r = !1, n = !1;
  for (let i = 0; i < t.length; ++i) {
    const o = t[i];
    switch (o[0]) {
      case "#":
        e += (e === "" ? "" : n ? `

` : `
`) + (o.substring(1) || " "), r = !0, n = !1;
        break;
      case "%":
        t[i + 1]?.[0] !== "#" && (i += 1), r = !1;
        break;
      default:
        r || (n = !0), r = !1;
    }
  }
  return { comment: e, afterEmptyLine: n };
}
class SS {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (r, n, i, o) => {
      const s = nm(r);
      o ? this.warnings.push(new xI(s, n, i)) : this.errors.push(new Qc(s, n, i));
    }, this.directives = new Ei({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, r) {
    const { comment: n, afterEmptyLine: i } = o9(this.prelude);
    if (n) {
      const o = e.contents;
      if (r)
        e.comment = e.comment ? `${e.comment}
${n}` : n;
      else if (i || e.directives.docStart || !o)
        e.commentBefore = n;
      else if (Jr(o) && !o.flow && o.items.length > 0) {
        let s = o.items[0];
        Gr(s) && (s = s.key);
        const a = s.commentBefore;
        s.commentBefore = a ? `${n}
${a}` : n;
      } else {
        const s = o.commentBefore;
        o.commentBefore = s ? `${n}
${s}` : n;
      }
    }
    r ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: o9(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, r = !1, n = -1) {
    for (const i of e)
      yield* this.next(i);
    yield* this.end(r, n);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (r, n, i) => {
          const o = nm(e);
          o[0] += r, this.onError(o, "BAD_DIRECTIVE", n, i);
        }), this.prelude.push(e.source), this.atDirectives = !0;
        break;
      case "document": {
        const r = Vde(this.options, this.directives, e, this.onError);
        this.atDirectives && !r.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(r, !1), this.doc && (yield this.doc), this.doc = r, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const r = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, n = new Qc(nm(e), "UNEXPECTED_TOKEN", r);
        this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const n = "Unexpected doc-end without preceding document";
          this.errors.push(new Qc(nm(e), "UNEXPECTED_TOKEN", n));
          break;
        }
        this.doc.directives.docEnd = !0;
        const r = m0(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), r.comment) {
          const n = this.doc.comment;
          this.doc.comment = n ? `${n}
${r.comment}` : r.comment;
        }
        this.doc.range[2] = r.offset;
        break;
      }
      default:
        this.errors.push(new Qc(nm(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = !1, r = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (e) {
      const n = Object.assign({ _directives: this.directives }, this.options), i = new cp(void 0, n);
      this.atDirectives && this.onError(r, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, r, r], this.decorate(i, !1), yield i;
    }
  }
}
function Wde(t, e = !0, r) {
  if (t) {
    const n = (i, o, s) => {
      const a = typeof i == "number" ? i : Array.isArray(i) ? i[0] : i.offset;
      if (r)
        r(a, o, s);
      else
        throw new Qc([a, a + 1], o, s);
    };
    switch (t.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return CI(t, e, n);
      case "block-scalar":
        return kI({ options: { strict: e } }, t, n);
    }
  }
  return null;
}
function Gde(t, e) {
  const { implicitKey: r = !1, indent: n, inFlow: i = !1, offset: o = -1, type: s = "PLAIN" } = e, a = d0({ type: s, value: t }, {
    implicitKey: r,
    indent: n > 0 ? " ".repeat(n) : "",
    inFlow: i,
    options: { blockQuote: !0, lineWidth: -1 }
  }), l = e.end ?? [
    { type: "newline", offset: -1, indent: n, source: `
` }
  ];
  switch (a[0]) {
    case "|":
    case ">": {
      const u = a.indexOf(`
`), c = a.substring(0, u), h = a.substring(u + 1) + `
`, d = [
        { type: "block-scalar-header", offset: o, indent: n, source: c }
      ];
      return EI(d, l) || d.push({ type: "newline", offset: -1, indent: n, source: `
` }), { type: "block-scalar", offset: o, indent: n, props: d, source: h };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: o, indent: n, source: a, end: l };
    case "'":
      return { type: "single-quoted-scalar", offset: o, indent: n, source: a, end: l };
    default:
      return { type: "scalar", offset: o, indent: n, source: a, end: l };
  }
}
function Kde(t, e, r = {}) {
  let { afterKey: n = !1, implicitKey: i = !1, inFlow: o = !1, type: s } = r, a = "indent" in t ? t.indent : null;
  if (n && typeof a == "number" && (a += 2), !s)
    switch (t.type) {
      case "single-quoted-scalar":
        s = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        s = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const u = t.props[0];
        if (u.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        s = u.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        s = "PLAIN";
    }
  const l = d0({ type: s, value: e }, {
    implicitKey: i || a === null,
    indent: a !== null && a > 0 ? " ".repeat(a) : "",
    inFlow: o,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (l[0]) {
    case "|":
    case ">":
      Xde(t, l);
      break;
    case '"':
      vk(t, l, "double-quoted-scalar");
      break;
    case "'":
      vk(t, l, "single-quoted-scalar");
      break;
    default:
      vk(t, l, "scalar");
  }
}
function Xde(t, e) {
  const r = e.indexOf(`
`), n = e.substring(0, r), i = e.substring(r + 1) + `
`;
  if (t.type === "block-scalar") {
    const o = t.props[0];
    if (o.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    o.source = n, t.source = i;
  } else {
    const { offset: o } = t, s = "indent" in t ? t.indent : -1, a = [
      { type: "block-scalar-header", offset: o, indent: s, source: n }
    ];
    EI(a, "end" in t ? t.end : void 0) || a.push({ type: "newline", offset: -1, indent: s, source: `
` });
    for (const l of Object.keys(t))
      l !== "type" && l !== "offset" && delete t[l];
    Object.assign(t, { type: "block-scalar", indent: s, props: a, source: i });
  }
}
function EI(t, e) {
  if (e)
    for (const r of e)
      switch (r.type) {
        case "space":
        case "comment":
          t.push(r);
          break;
        case "newline":
          return t.push(r), !0;
      }
  return !1;
}
function vk(t, e, r) {
  switch (t.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      t.type = r, t.source = e;
      break;
    case "block-scalar": {
      const n = t.props.slice(1);
      let i = e.length;
      t.props[0].type === "block-scalar-header" && (i -= t.props[0].source.length);
      for (const o of n)
        o.offset += i;
      delete t.props, Object.assign(t, { type: r, source: e, end: n });
      break;
    }
    case "block-map":
    case "block-seq": {
      const n = { type: "newline", offset: t.offset + e.length, indent: t.indent, source: `
` };
      delete t.items, Object.assign(t, { type: r, source: e, end: [n] });
      break;
    }
    default: {
      const n = "indent" in t ? t.indent : -1, i = "end" in t && Array.isArray(t.end) ? t.end.filter((o) => o.type === "space" || o.type === "comment" || o.type === "newline") : [];
      for (const o of Object.keys(t))
        o !== "type" && o !== "offset" && delete t[o];
      Object.assign(t, { type: r, indent: n, source: e, end: i });
    }
  }
}
const Qde = (t) => "type" in t ? tb(t) : Qy(t);
function tb(t) {
  switch (t.type) {
    case "block-scalar": {
      let e = "";
      for (const r of t.props)
        e += tb(r);
      return e + t.source;
    }
    case "block-map":
    case "block-seq": {
      let e = "";
      for (const r of t.items)
        e += Qy(r);
      return e;
    }
    case "flow-collection": {
      let e = t.start.source;
      for (const r of t.items)
        e += Qy(r);
      for (const r of t.end)
        e += r.source;
      return e;
    }
    case "document": {
      let e = Qy(t);
      if (t.end)
        for (const r of t.end)
          e += r.source;
      return e;
    }
    default: {
      let e = t.source;
      if ("end" in t && t.end)
        for (const r of t.end)
          e += r.source;
      return e;
    }
  }
}
function Qy({ start: t, key: e, sep: r, value: n }) {
  let i = "";
  for (const o of t)
    i += o.source;
  if (e && (i += tb(e)), r)
    for (const o of r)
      i += o.source;
  return n && (i += tb(n)), i;
}
const GC = Symbol("break visit"), Jde = Symbol("skip children"), DI = Symbol("remove item");
function Sh(t, e) {
  "type" in t && t.type === "document" && (t = { start: t.start, value: t.value }), OI(Object.freeze([]), t, e);
}
Sh.BREAK = GC;
Sh.SKIP = Jde;
Sh.REMOVE = DI;
Sh.itemAtPath = (t, e) => {
  let r = t;
  for (const [n, i] of e) {
    const o = r?.[n];
    if (o && "items" in o)
      r = o.items[i];
    else
      return;
  }
  return r;
};
Sh.parentCollection = (t, e) => {
  const r = Sh.itemAtPath(t, e.slice(0, -1)), n = e[e.length - 1][0], i = r?.[n];
  if (i && "items" in i)
    return i;
  throw new Error("Parent collection not found");
};
function OI(t, e, r) {
  let n = r(e, t);
  if (typeof n == "symbol")
    return n;
  for (const i of ["key", "value"]) {
    const o = e[i];
    if (o && "items" in o) {
      for (let s = 0; s < o.items.length; ++s) {
        const a = OI(Object.freeze(t.concat([[i, s]])), o.items[s], r);
        if (typeof a == "number")
          s = a - 1;
        else {
          if (a === GC)
            return GC;
          a === DI && (o.items.splice(s, 1), s -= 1);
        }
      }
      typeof n == "function" && i === "key" && (n = n(e, t));
    }
  }
  return typeof n == "function" ? n(e, t) : n;
}
const px = "\uFEFF", mx = "", gx = "", Og = "", Yde = (t) => !!t && "items" in t, Zde = (t) => !!t && (t.type === "scalar" || t.type === "single-quoted-scalar" || t.type === "double-quoted-scalar" || t.type === "block-scalar");
function epe(t) {
  switch (t) {
    case px:
      return "<BOM>";
    case mx:
      return "<DOC>";
    case gx:
      return "<FLOW_END>";
    case Og:
      return "<SCALAR>";
    default:
      return JSON.stringify(t);
  }
}
function FI(t) {
  switch (t) {
    case px:
      return "byte-order-mark";
    case mx:
      return "doc-mode";
    case gx:
      return "flow-error-end";
    case Og:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (t[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const tpe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: px,
  DOCUMENT: mx,
  FLOW_END: gx,
  SCALAR: Og,
  createScalarToken: Gde,
  isCollection: Yde,
  isScalar: Zde,
  prettyToken: epe,
  resolveAsScalar: Wde,
  setScalarValue: Kde,
  stringify: Qde,
  tokenType: FI,
  visit: Sh
}, Symbol.toStringTag, { value: "Module" }));
function Rs(t) {
  switch (t) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const s9 = new Set("0123456789ABCDEFabcdef"), rpe = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), uy = new Set(",[]{}"), npe = new Set(` ,[]{}
\r	`), yk = (t) => !t || npe.has(t);
class TI {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, r = !1) {
    if (e) {
      if (typeof e != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null;
    }
    this.atEnd = !r;
    let n = this.next ?? "stream";
    for (; n && (r || this.hasChars(1)); )
      n = yield* this.parseNext(n);
  }
  atLineEnd() {
    let e = this.pos, r = this.buffer[e];
    for (; r === " " || r === "	"; )
      r = this.buffer[++e];
    return !r || r === "#" || r === `
` ? !0 : r === "\r" ? this.buffer[e + 1] === `
` : !1;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let r = this.buffer[e];
    if (this.indentNext > 0) {
      let n = 0;
      for (; r === " "; )
        r = this.buffer[++n + e];
      if (r === "\r") {
        const i = this.buffer[n + e + 1];
        if (i === `
` || !i && !this.atEnd)
          return e + n + 1;
      }
      return r === `
` || n >= this.indentNext || !r && !this.atEnd ? e + n : -1;
    }
    if (r === "-" || r === ".") {
      const n = this.buffer.substr(e, 3);
      if ((n === "---" || n === "...") && Rs(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === px && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let r = e.length, n = e.indexOf("#");
      for (; n !== -1; ) {
        const o = e[n - 1];
        if (o === " " || o === "	") {
          r = n - 1;
          break;
        } else
          n = e.indexOf("#", n + 1);
      }
      for (; ; ) {
        const o = e[r - 1];
        if (o === " " || o === "	")
          r -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(r)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(e.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const r = yield* this.pushSpaces(!0);
      return yield* this.pushCount(e.length - r), yield* this.pushNewline(), "stream";
    }
    return yield mx, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const r = this.peek(3);
      if ((r === "---" || r === "...") && Rs(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, r === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !Rs(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, r] = this.peek(2);
    if (!r && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && Rs(r)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let r = yield* this.pushIndicators();
    switch (e[r]) {
      case "#":
        yield* this.pushCount(e.length - r);
      // fallthrough
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(yk), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return r += yield* this.parseBlockScalarHeader(), r += yield* this.pushSpaces(!0), yield* this.pushCount(e.length - r), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, r, n = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (r = yield* this.pushSpaces(!1), this.indentValue = n = r) : r = 0, r += yield* this.pushSpaces(!0);
    while (e + r > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((n !== -1 && n < this.indentNext && i[0] !== "#" || n === 0 && (i.startsWith("---") || i.startsWith("...")) && Rs(i[3])) && !(n === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield gx, yield* this.parseLineStart();
    let o = 0;
    for (; i[o] === ","; )
      o += yield* this.pushCount(1), o += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (o += yield* this.pushIndicators(), i[o]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - o), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(yk), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const s = this.charAt(1);
        if (this.flowKey || Rs(s) || s === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      // fallthrough
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let r = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; r !== -1 && this.buffer[r + 1] === "'"; )
        r = this.buffer.indexOf("'", r + 2);
    else
      for (; r !== -1; ) {
        let o = 0;
        for (; this.buffer[r - 1 - o] === "\\"; )
          o += 1;
        if (o % 2 === 0)
          break;
        r = this.buffer.indexOf('"', r + 1);
      }
    const n = this.buffer.substring(0, r);
    let i = n.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const o = this.continueScalar(i + 1);
        if (o === -1)
          break;
        i = n.indexOf(`
`, o);
      }
      i !== -1 && (r = i - (n[i - 1] === "\r" ? 2 : 1));
    }
    if (r === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      r = this.buffer.length;
    }
    return yield* this.pushToIndex(r + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let e = this.pos;
    for (; ; ) {
      const r = this.buffer[++e];
      if (r === "+")
        this.blockScalarKeep = !0;
      else if (r > "0" && r <= "9")
        this.blockScalarIndent = Number(r) - 1;
      else if (r !== "-")
        break;
    }
    return yield* this.pushUntil((r) => Rs(r) || r === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, r = 0, n;
    e: for (let o = this.pos; n = this.buffer[o]; ++o)
      switch (n) {
        case " ":
          r += 1;
          break;
        case `
`:
          e = o, r = 0;
          break;
        case "\r": {
          const s = this.buffer[o + 1];
          if (!s && !this.atEnd)
            return this.setNext("block-scalar");
          if (s === `
`)
            break;
        }
        // fallthrough
        default:
          break e;
      }
    if (!n && !this.atEnd)
      return this.setNext("block-scalar");
    if (r >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = r : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const o = this.continueScalar(e + 1);
        if (o === -1)
          break;
        e = this.buffer.indexOf(`
`, o);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    let i = e + 1;
    for (n = this.buffer[i]; n === " "; )
      n = this.buffer[++i];
    if (n === "	") {
      for (; n === "	" || n === " " || n === "\r" || n === `
`; )
        n = this.buffer[++i];
      e = i - 1;
    } else if (!this.blockScalarKeep)
      do {
        let o = e - 1, s = this.buffer[o];
        s === "\r" && (s = this.buffer[--o]);
        const a = o;
        for (; s === " "; )
          s = this.buffer[--o];
        if (s === `
` && o >= this.pos && o + 1 + r > a)
          e = o;
        else
          break;
      } while (!0);
    return yield Og, yield* this.pushToIndex(e + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let r = this.pos - 1, n = this.pos - 1, i;
    for (; i = this.buffer[++n]; )
      if (i === ":") {
        const o = this.buffer[n + 1];
        if (Rs(o) || e && uy.has(o))
          break;
        r = n;
      } else if (Rs(i)) {
        let o = this.buffer[n + 1];
        if (i === "\r" && (o === `
` ? (n += 1, i = `
`, o = this.buffer[n + 1]) : r = n), o === "#" || e && uy.has(o))
          break;
        if (i === `
`) {
          const s = this.continueScalar(n + 1);
          if (s === -1)
            break;
          n = Math.max(n, s - 2);
        }
      } else {
        if (e && uy.has(i))
          break;
        r = n;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield Og, yield* this.pushToIndex(r + 1, !0), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, r) {
    const n = this.buffer.slice(this.pos, e);
    return n ? (yield n, this.pos += n.length, n.length) : (r && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(yk)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const e = this.flowLevel > 0, r = this.charAt(1);
        if (Rs(r) || e && uy.has(r))
          return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, r = this.buffer[e];
      for (; !Rs(r) && r !== ">"; )
        r = this.buffer[++e];
      return yield* this.pushToIndex(r === ">" ? e + 1 : e, !1);
    } else {
      let e = this.pos + 1, r = this.buffer[e];
      for (; r; )
        if (rpe.has(r))
          r = this.buffer[++e];
        else if (r === "%" && s9.has(this.buffer[e + 1]) && s9.has(this.buffer[e + 2]))
          r = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, !1);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let r = this.pos - 1, n;
    do
      n = this.buffer[++r];
    while (n === " " || e && n === "	");
    const i = r - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = r), i;
  }
  *pushUntil(e) {
    let r = this.pos, n = this.buffer[r];
    for (; !e(n); )
      n = this.buffer[++r];
    return yield* this.pushToIndex(r, !1);
  }
}
class MI {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let r = 0, n = this.lineStarts.length;
      for (; r < n; ) {
        const o = r + n >> 1;
        this.lineStarts[o] < e ? r = o + 1 : n = o;
      }
      if (this.lineStarts[r] === e)
        return { line: r + 1, col: 1 };
      if (r === 0)
        return { line: 0, col: e };
      const i = this.lineStarts[r - 1];
      return { line: r, col: e - i + 1 };
    };
  }
}
function Ou(t, e) {
  for (let r = 0; r < t.length; ++r)
    if (t[r].type === e)
      return !0;
  return !1;
}
function a9(t) {
  for (let e = 0; e < t.length; ++e)
    switch (t[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function PI(t) {
  switch (t?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function cy(t) {
  switch (t.type) {
    case "document":
      return t.start;
    case "block-map": {
      const e = t.items[t.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return t.items[t.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function wf(t) {
  if (t.length === 0)
    return [];
  let e = t.length;
  e: for (; --e >= 0; )
    switch (t[e].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; t[++e]?.type === "space"; )
    ;
  return t.splice(e, t.length);
}
function l9(t) {
  if (t.start.type === "flow-seq-start")
    for (const e of t.items)
      e.sep && !e.value && !Ou(e.start, "explicit-key-ind") && !Ou(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, PI(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
class AS {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new TI(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, r = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const n of this.lexer.lex(e, r))
      yield* this.next(n);
    r || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += e.length;
      return;
    }
    const r = FI(e);
    if (r)
      if (r === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = r, yield* this.step(), r) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += e.length;
      }
    else {
      const n = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: n, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const r = e ?? this.stack.pop();
    if (!r)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield r;
    else {
      const n = this.peek(1);
      switch (r.type === "block-scalar" ? r.indent = "indent" in n ? n.indent : 0 : r.type === "flow-collection" && n.type === "document" && (r.indent = 0), r.type === "flow-collection" && l9(r), n.type) {
        case "document":
          n.value = r;
          break;
        case "block-scalar":
          n.props.push(r);
          break;
        case "block-map": {
          const i = n.items[n.items.length - 1];
          if (i.value) {
            n.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (i.sep)
            i.value = r;
          else {
            Object.assign(i, { key: r, sep: [] }), this.onKeyLine = !i.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const i = n.items[n.items.length - 1];
          i.value ? n.items.push({ start: [], value: r }) : i.value = r;
          break;
        }
        case "flow-collection": {
          const i = n.items[n.items.length - 1];
          !i || i.value ? n.items.push({ start: [], key: r, sep: [] }) : i.sep ? i.value = r : Object.assign(i, { key: r, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop(), yield* this.pop(r);
      }
      if ((n.type === "document" || n.type === "block-map" || n.type === "block-seq") && (r.type === "block-map" || r.type === "block-seq")) {
        const i = r.items[r.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && a9(i.start) === -1 && (r.indent === 0 || i.start.every((o) => o.type !== "comment" || o.indent < r.indent)) && (n.type === "document" ? n.end = i.start : n.items.push({ start: i.start }), r.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        a9(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const r = this.startBlockValue(e);
    r ? this.stack.push(r) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const r = cy(this.peek(2)), n = wf(r);
      let i;
      e.end ? (i = e.end, i.push(this.sourceToken), delete e.end) : i = [this.sourceToken];
      const o = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: n, key: e, sep: i }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = o;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let r = this.source.indexOf(`
`) + 1;
          for (; r !== 0; )
            this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          (Array.isArray(n) ? n[n.length - 1] : void 0)?.type === "comment" ? n?.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else if (r.sep)
          r.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = e.items[e.items.length - 2]?.value?.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const n = !this.onKeyLine && this.indent === e.indent, i = n && (r.sep || r.explicitKey) && this.type !== "seq-item-ind";
      let o = [];
      if (i && r.sep && !r.value) {
        const s = [];
        for (let a = 0; a < r.sep.length; ++a) {
          const l = r.sep[a];
          switch (l.type) {
            case "newline":
              s.push(a);
              break;
            case "space":
              break;
            case "comment":
              l.indent > e.indent && (s.length = 0);
              break;
            default:
              s.length = 0;
          }
        }
        s.length >= 2 && (o = r.sep.splice(s[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || r.value ? (o.push(this.sourceToken), e.items.push({ start: o }), this.onKeyLine = !0) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !r.sep && !r.explicitKey ? (r.start.push(this.sourceToken), r.explicitKey = !0) : i || r.value ? (o.push(this.sourceToken), e.items.push({ start: o, explicitKey: !0 })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: !0 }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (r.explicitKey)
            if (r.sep)
              if (r.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Ou(r.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: null, sep: [this.sourceToken] }]
                });
              else if (PI(r.key) && !Ou(r.sep, "newline")) {
                const s = wf(r.start), a = r.key, l = r.sep;
                l.push(this.sourceToken), delete r.key, delete r.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: a, sep: l }]
                });
              } else o.length > 0 ? r.sep = r.sep.concat(o, this.sourceToken) : r.sep.push(this.sourceToken);
            else if (Ou(r.start, "newline"))
              Object.assign(r, { key: null, sep: [this.sourceToken] });
            else {
              const s = wf(r.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: s, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            r.sep ? r.value || i ? e.items.push({ start: o, key: null, sep: [this.sourceToken] }) : Ou(r.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const s = this.flowScalar(this.type);
          i || r.value ? (e.items.push({ start: o, key: s, sep: [] }), this.onKeyLine = !0) : r.sep ? this.stack.push(s) : (Object.assign(r, { key: s, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const s = this.startBlockValue(e);
          if (s) {
            if (s.type === "block-seq") {
              if (!r.explicitKey && r.sep && !Ou(r.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else n && e.items.push({ start: o });
            this.stack.push(s);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          (Array.isArray(n) ? n[n.length - 1] : void 0)?.type === "comment" ? n?.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = e.items[e.items.length - 2]?.value?.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (r.value || this.indent <= e.indent)
          break;
        r.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        r.value || Ou(r.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const n = this.startBlockValue(e);
      if (n) {
        this.stack.push(n);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const r = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let n;
      do
        yield* this.pop(), n = this.peek(1);
      while (n && n.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !r || r.sep ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !r || r.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !r || r.value ? e.items.push({ start: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !r || r.value ? e.items.push({ start: [], key: i, sep: [] }) : r.sep ? this.stack.push(i) : Object.assign(r, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const n = this.startBlockValue(e);
      n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
    } else {
      const n = this.peek(2);
      if (n.type === "block-map" && (this.type === "map-value-ind" && n.indent === e.indent || this.type === "newline" && !n.items[n.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && n.type !== "flow-collection") {
        const i = cy(n), o = wf(i);
        l9(e);
        const s = e.end.splice(1, e.end.length);
        s.push(this.sourceToken);
        const a = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: o, key: e, sep: s }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = a;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let r = this.source.indexOf(`
`) + 1;
      for (; r !== 0; )
        this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const r = cy(e), n = wf(r);
        return n.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, explicitKey: !0 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const r = cy(e), n = wf(r);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, r) {
    return this.type !== "comment" || this.indent <= r ? !1 : e.every((n) => n.type === "newline" || n.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      // fallthrough
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function RI(t) {
  const e = t.prettyErrors !== !1;
  return { lineCounter: t.lineCounter || e && new MI() || null, prettyErrors: e };
}
function ipe(t, e = {}) {
  const { lineCounter: r, prettyErrors: n } = RI(e), i = new AS(r?.addNewLine), o = new SS(e), s = Array.from(o.compose(i.parse(t)));
  if (n && r)
    for (const a of s)
      a.errors.forEach(eb(t, r)), a.warnings.forEach(eb(t, r));
  return s.length > 0 ? s : Object.assign([], { empty: !0 }, o.streamInfo());
}
function NI(t, e = {}) {
  const { lineCounter: r, prettyErrors: n } = RI(e), i = new AS(r?.addNewLine), o = new SS(e);
  let s = null;
  for (const a of o.compose(i.parse(t), !0, t.length))
    if (!s)
      s = a;
    else if (s.options.logLevel !== "silent") {
      s.errors.push(new Qc(a.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return n && r && (s.errors.forEach(eb(t, r)), s.warnings.forEach(eb(t, r))), s;
}
function ope(t, e, r) {
  let n;
  typeof e == "function" ? n = e : r === void 0 && e && typeof e == "object" && (r = e);
  const i = NI(t, r);
  if (!i)
    return null;
  if (i.warnings.forEach((o) => tI(i.options.logLevel, o)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: n }, r));
}
function spe(t, e, r) {
  let n = null;
  if (typeof e == "function" || Array.isArray(e) ? n = e : r === void 0 && e && (r = e), typeof r == "string" && (r = r.length), typeof r == "number") {
    const i = Math.round(r);
    r = i < 1 ? void 0 : i > 8 ? { indent: 8 } : { indent: i };
  }
  if (t === void 0) {
    const { keepUndefined: i } = r ?? e ?? {};
    if (!i)
      return;
  }
  return qh(t) && !n ? t.toString(r) : new cp(t, n, r).toString(r);
}
const ape = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: ix,
  CST: tpe,
  Composer: SS,
  Document: cp,
  Lexer: TI,
  LineCounter: MI,
  Pair: fi,
  Parser: AS,
  Scalar: vt,
  Schema: dx,
  YAMLError: CS,
  YAMLMap: Io,
  YAMLParseError: Qc,
  YAMLSeq: hc,
  YAMLWarning: xI,
  isAlias: vc,
  isCollection: Jr,
  isDocument: qh,
  isMap: sp,
  isNode: Yr,
  isPair: Gr,
  isScalar: Tr,
  isSeq: ap,
  parse: ope,
  parseAllDocuments: ipe,
  parseDocument: NI,
  stringify: spe,
  visit: Uh,
  visitAsync: nx
}, Symbol.toStringTag, { value: "Module" }));
function lpe(t) {
  let e = null;
  try {
    e = ape.parse(t.doc.toString());
  } catch {
  }
  const r = L4(t, Hr.YAML);
  return { data: e, pointers: r };
}
const $I = (t) => {
  switch (t) {
    case Hr.JSON:
      return Lfe;
    case Hr.JSON5:
      return Yfe;
    case Hr.YAML:
      return lpe;
  }
};
function upe(t) {
  return Object.entries(t);
}
function wm(t, e) {
  if (typeof t == "string" || typeof t != "object" || t === null)
    return t;
  if (Array.isArray(t))
    return t.map((i) => wm(i, e));
  if (t instanceof Map) {
    const i = /* @__PURE__ */ new Map();
    for (const [o, s] of t) {
      const a = o, l = wm(s, e);
      i.set(a, l);
    }
    return i;
  }
  if (t instanceof Set) {
    const i = /* @__PURE__ */ new Set();
    for (const o of t) {
      const s = wm(o, e);
      i.add(s);
    }
    return i;
  }
  const r = {};
  function n(i, o, s, a) {
    s === i && a === o ? r[s] = wm(o, e) : r[s] = a;
  }
  for (const [i, o] of upe(t)) {
    const s = e(i, o);
    if (s.length === 2 && typeof s[0] == "string")
      n(i, o, s[0], s[1]);
    else
      for (const [a, l] of s)
        n(i, o, a, l);
  }
  return r;
}
var cpe = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
};
class hpe {
  constructor() {
    this.completions = /* @__PURE__ */ new Map(), this.reservedKeys = /* @__PURE__ */ new Set();
  }
  reserve(e) {
    this.reservedKeys.add(e);
  }
  add(e) {
    this.reservedKeys.has(e.label) || this.completions.set(e.label, e);
  }
}
function Im(t) {
  return !(!t || vi(t) || t.name === "UnknownPropertyError" || t.type === "undefined");
}
class fpe {
  // private lastKnownValidData: object | null = null;
  constructor(e) {
    var r, n, i;
    this.opts = e, this.originalSchema = null, this.schema = null, this.laxSchema = null, this.mode = Hr.JSON, this.mode = (r = e.mode) !== null && r !== void 0 ? r : Hr.JSON, this.parser = (i = (n = this.opts) === null || n === void 0 ? void 0 : n.jsonParser) !== null && i !== void 0 ? i : $I(this.mode);
  }
  doComplete(e) {
    var r;
    const n = z4(e.state);
    if (this.originalSchema !== n && (this.schema = (r = Bc(n, n)) !== null && r !== void 0 ? r : n, this.laxSchema = ppe(this.schema)), !this.schema || !this.laxSchema)
      return [];
    Xr.log("xxx", "trying with original schema");
    const i = this.doCompleteForSchema(e, this.schema);
    return i.options.length !== 0 ? i : (Xr.log("xxx", "no completions with original schema, trying with lax schema"), this.doCompleteForSchema(e, this.laxSchema));
  }
  doCompleteForSchema(e, r) {
    var n, i;
    const o = {
      from: e.pos,
      to: e.pos,
      options: [],
      filter: !1
      // will be handled manually
    }, s = e.state.doc.sliceString(0);
    let a = H2(e.state, e.pos), l = e.state.sliceDoc(a.from, e.pos).replace(/^(["'])/, "");
    if (Xr.log("xxx", "node", a, "prefix", l, "ctx", e), !(Uy(a, this.mode) || Kv(a, this.mode)) && !e.explicit)
      return Xr.log("xxx", "no completions for non-word/primitive", a), o;
    const u = Df(e.state.doc, a), c = Df(e.state.doc, a, !1);
    if (a && (Uy(a, this.mode) || Kv(a, this.mode)))
      o.from = a.from, o.to = a.to;
    else {
      const g = e.matchBefore(/[A-Za-z0-9._]*/), v = e.pos - u.length;
      Xr.log("xxx", "overwriteStart after", v, "ctx.pos", e.pos, "word", g, "currentWord", u, "=>", s[v - 1], "..", s[v], "..", s), o.from = a.name === xt.INVALID ? (n = g?.from) !== null && n !== void 0 ? n : e.pos : v, o.to = e.pos;
    }
    const h = new hpe();
    let d = !0;
    const p = P8(a, xt.PROPERTY_NAME, this.mode);
    if (p && (Xr.log("xxx", "closestPropertyNameNode", p, "node", a), a = p), Kv(a, this.mode)) {
      Xr.log("xxx", "isPropertyNameNode", a);
      const g = a.parent;
      if (g) {
        const v = M8(g, this.mode);
        d = !v || v.name === xt.INVALID && v.from - v.to === 0 || // TODO: Verify this doesn't break anything else
        (v.parent ? o0(v.parent).length <= 1 : !1), Xr.log("xxx", "addValue", d, M8(g, this.mode), a), a = (i = P8(g, xt.OBJECT, this.mode)) !== null && i !== void 0 ? i : null;
      }
    }
    if (Xr.log("xxx", a, u, e, "node at pos", H2(e.state, e.pos)), a && [xt.OBJECT, xt.JSON_TEXT].includes(pn(a.name, this.mode)) && (Kv(H2(e.state, e.pos), this.mode) || p)) {
      if (a.from === e.pos)
        return Xr.log("xxx", "no completions for just before opening brace"), o;
      this.getPropertyCompletions(r, e, a, h, d, c);
    } else {
      const g = {}, v = this.getValueCompletions(r, e, g, h);
      Xr.log("xxx", "getValueCompletions res", v);
    }
    return o.options = Array.from(h.completions.values()).filter((g) => qy(g.label).startsWith(l)), Xr.log("xxx", "result", o, "prefix", l, "collector.completions", h.completions, "reservedKeys", h.reservedKeys), o;
  }
  applySnippetCompletion(e) {
    return jee(typeof e.apply != "string" ? e.label : e.apply, e);
  }
  getPropertyCompletions(e, r, n, i, o, s) {
    const a = bie(n, xt.PROPERTY, this.mode);
    Xr.log("xxx", "getPropertyCompletions", n, r, a), a.forEach((u) => {
      const c = Df(r.state.doc, yC(u, xt.PROPERTY_NAME, this.mode));
      i.reserve(qy(c));
    });
    const l = this.getSchemas(e, r);
    Xr.log("xxx", "propertyCompletion schemas", l), l.forEach((u) => {
      if (typeof u != "object")
        return;
      const c = u.properties;
      c && Object.entries(c).forEach(([d, p]) => {
        var g, v;
        if (typeof p == "object") {
          const y = (g = p.description) !== null && g !== void 0 ? g : "", b = (v = p.type) !== null && v !== void 0 ? v : "", k = Array.isArray(b) ? b.toString() : b, C = {
            // label is the unquoted key which will be displayed.
            label: d,
            apply: this.getInsertTextForProperty(d, o, s, e, p),
            type: "property",
            detail: k,
            info: () => _a("div", {
              inner: ed(y)
            })
          };
          i.add(this.applySnippetCompletion(C));
        }
      });
      const h = u.propertyNames;
      if (typeof h == "object" && (h.enum && h.enum.forEach((d) => {
        const p = d?.toString();
        if (p) {
          const g = {
            label: p,
            apply: this.getInsertTextForProperty(p, o, s, e),
            type: "property"
          };
          i.add(this.applySnippetCompletion(g));
        }
      }), h.const)) {
        const d = h.const.toString(), p = {
          label: d,
          apply: this.getInsertTextForProperty(d, o, s, e),
          type: "property"
        };
        i.add(this.applySnippetCompletion(p));
      }
    });
  }
  // apply is the quoted key which will be applied.
  // Normally the label needs to match the token
  // prefix i.e. if the token begins with `"to`, then the
  // label needs to have the quotes as well for it to match.
  // However we are manually filtering the results so we can
  // just use the unquoted key as the label, which is nicer
  // and gives us more control.
  // If no property value is present, then we add the colon as well.
  // Use snippetCompletion to handle insert value + position cursor e.g. "key": "#{}"
  // doc: https://codemirror.net/docs/ref/#autocomplete.snippetCompletion
  // idea: https://discuss.codemirror.net/t/autocomplete-cursor-position-in-apply-function/4088/3
  getInsertTextForProperty(e, r, n, i, o) {
    o = o && Bc(o, i);
    let s = this.getInsertTextForPropertyName(e, n);
    if (!r)
      return s;
    s += ": ";
    let a, l = 0;
    if (typeof o == "object") {
      if (typeof o.default < "u")
        a || (a = this.getInsertTextForGuessedValue(o.default, "")), l++;
      else if (o.enum && (!a && o.enum.length === 1 && (a = this.getInsertTextForGuessedValue(o.enum[0], "")), l += o.enum.length), typeof o.const < "u" && (a || (a = this.getInsertTextForGuessedValue(o.const, "")), l++), Array.isArray(o.examples) && o.examples.length && (a || (a = this.getInsertTextForGuessedValue(o.examples[0], "")), l += o.examples.length), a === void 0 && l === 0) {
        let u = Array.isArray(o.type) ? o.type[0] : o.type;
        switch (u || (o.properties ? u = "object" : o.items && (u = "array")), u) {
          case "boolean":
            a = "#{}";
            break;
          case "string":
            a = this.getInsertTextForString("");
            break;
          case "object":
            switch (this.mode) {
              case Hr.JSON5:
                a = "{#{}}";
                break;
              case Hr.YAML:
                a = "#{}";
                break;
              default:
                a = "{#{}}";
                break;
            }
            break;
          case "array":
            a = "[#{}]";
            break;
          case "number":
          case "integer":
            a = "#{0}";
            break;
          case "null":
            a = "#{null}";
            break;
          default:
            a = "#{}";
            break;
        }
      }
    }
    return (!a || l > 1) && (Xr.log("xxx", "value", a, "nValueProposals", l, o), a = "#{}"), s + a;
  }
  getInsertTextForPropertyName(e, r) {
    switch (this.mode) {
      case Hr.JSON5:
      case Hr.YAML:
        return r.startsWith('"') ? `"${e}"` : r.startsWith("'") ? `'${e}'` : e;
      default:
        return `"${e}"`;
    }
  }
  getInsertTextForString(e, r = "#") {
    switch (this.mode) {
      case Hr.JSON5:
        return `'${r}{${e}}'`;
      case Hr.YAML:
        return `${r}{${e}}`;
      default:
        return `"${r}{${e}}"`;
    }
  }
  // TODO: Is this actually working?
  getInsertTextForGuessedValue(e, r = "") {
    switch (typeof e) {
      case "object":
        return e === null ? "${null}" + r : this.getInsertTextForValue(e, r);
      case "string": {
        let n = JSON.stringify(e);
        return n = n.substr(1, n.length - 2), n = this.getInsertTextForPlainText(n), this.getInsertTextForString(n, "$") + r;
      }
      case "number":
      case "boolean":
        return "${" + JSON.stringify(e) + "}" + r;
    }
    return this.getInsertTextForValue(e, r);
  }
  getInsertTextForPlainText(e) {
    return e.replace(/[\\$}]/g, "\\$&");
  }
  getInsertTextForValue(e, r) {
    const n = JSON.stringify(e, null, "	");
    return n === "{}" ? "{#{}}" + r : n === "[]" ? "[#{}]" + r : this.getInsertTextForPlainText(n + r);
  }
  getValueCompletions(e, r, n, i) {
    let o = On(r.state).resolveInner(r.pos, -1), s = null, a;
    if (Xr.log("xxx", "getValueCompletions", o, r), o && Uy(o, this.mode) && (s = o, o = o.parent), !o) {
      this.addSchemaValueCompletions(e, n, i);
      return;
    }
    if (pn(o.name, this.mode) === xt.PROPERTY) {
      const l = yC(o, xt.PROPERTY_NAME, this.mode);
      l && (a = Df(r.state.doc, l), o = o.parent);
    }
    if (Xr.log("xxx", "node", o, "parentKey", a), o && (a !== void 0 || pn(o.name, this.mode) === xt.ARRAY)) {
      const l = this.getSchemas(e, r);
      for (const u of l) {
        if (typeof u != "object")
          return;
        if (pn(o.name, this.mode) === xt.ARRAY && u.items) {
          let c = i;
          if (u.uniqueItems && (c = Object.assign(Object.assign({}, c), {
            add(h) {
              c.completions.has(h.label) || i.add(h);
            },
            reserve(h) {
              i.reserve(h);
            }
          })), Array.isArray(u.items)) {
            let h = 0;
            if (s) {
              const p = HR(o, s, this.mode);
              p >= 0 && (h = p);
            }
            const d = u.items[h];
            d && this.addSchemaValueCompletions(d, n, c);
          } else
            this.addSchemaValueCompletions(u.items, n, c);
        }
        if ((u.type == null || u.type !== "object") && this.addSchemaValueCompletions(u, n, i), a !== void 0) {
          let c = !1;
          if (u.properties) {
            const h = u.properties[a];
            h && (c = !0, this.addSchemaValueCompletions(h, n, i));
          }
          if (u.patternProperties && !c) {
            for (const h of Object.keys(u.patternProperties))
              if (this.extendedRegExp(h)?.test(a)) {
                c = !0;
                const p = u.patternProperties[h];
                p && this.addSchemaValueCompletions(p, n, i);
              }
          }
          if (u.additionalProperties && !c) {
            const h = u.additionalProperties;
            this.addSchemaValueCompletions(h, n, i);
          }
        }
        n.boolean && (this.addBooleanValueCompletion(!0, i), this.addBooleanValueCompletion(!1, i)), n.null && this.addNullValueCompletion(i);
      }
    }
    return {
      valuePrefix: s ? Df(r.state.doc, s, !0, !1) : ""
    };
  }
  addSchemaValueCompletions(e, r, n) {
    typeof e == "object" && (this.addEnumValueCompletions(e, n), this.addDefaultValueCompletions(e, n), this.collectTypes(e, r), Array.isArray(e.allOf) && e.allOf.forEach((i) => this.addSchemaValueCompletions(i, r, n)), Array.isArray(e.anyOf) && e.anyOf.forEach((i) => this.addSchemaValueCompletions(i, r, n)), Array.isArray(e.oneOf) && e.oneOf.forEach((i) => this.addSchemaValueCompletions(i, r, n)));
  }
  addDefaultValueCompletions(e, r, n = 0) {
    let i = !1;
    if (typeof e.default < "u") {
      let o = e.type, s = e.default;
      for (let l = n; l > 0; l--)
        s = [s], o = "array";
      const a = Object.assign(Object.assign({ type: o?.toString() }, this.getAppliedValue(s)), { detail: "Default value" });
      r.add(a), i = !0;
    }
    Array.isArray(e.examples) && e.examples.forEach((o) => {
      let s = e.type, a = o;
      for (let l = n; l > 0; l--)
        a = [a], s = "array";
      r.add(Object.assign({ type: s?.toString() }, this.getAppliedValue(a))), i = !0;
    }), !i && typeof e.items == "object" && !Array.isArray(e.items) && n < 5 && this.addDefaultValueCompletions(e.items, r, n + 1);
  }
  addEnumValueCompletions(e, r) {
    var n, i;
    if (typeof e.const < "u" && r.add(Object.assign(Object.assign({ type: (n = e.type) === null || n === void 0 ? void 0 : n.toString() }, this.getAppliedValue(e.const)), { info: e.description })), Array.isArray(e.enum))
      for (let o = 0, s = e.enum.length; o < s; o++) {
        const a = e.enum[o];
        r.add(Object.assign(Object.assign({ type: (i = e.type) === null || i === void 0 ? void 0 : i.toString() }, this.getAppliedValue(a)), { info: e.description }));
      }
  }
  addBooleanValueCompletion(e, r) {
    r.add({
      type: "boolean",
      label: e ? "true" : "false"
    });
  }
  addNullValueCompletion(e) {
    e.add({
      type: "null",
      label: "null"
    });
  }
  collectTypes(e, r) {
    if (Array.isArray(e.enum) || typeof e.const < "u")
      return;
    const n = e.type;
    Array.isArray(n) ? n.forEach((i) => r[i] = !0) : n && (r[n] = !0);
  }
  getSchemas(e, r) {
    var n, i, o;
    const { data: s } = this.parser(r.state), a = new FN(e);
    let l = qR(r.state, r.pos, -1, this.mode);
    if (l === "" && (l = void 0), l != null && l.endsWith("/")) {
      l = l.substring(0, l.length - 1);
      const g = u9(e, s, l);
      if (g != null)
        return [g];
    }
    let u = l?.replace(/\/[^/]*$/, "");
    u === "" && (u = void 0);
    const c = u9(e, s, u), h = l?.split("/").pop(), d = h == null || h in ((n = c?.properties) !== null && n !== void 0 ? n : {});
    let p = a.getSchema({
      pointer: l,
      data: s ?? void 0
    });
    return !d && p?.type === "null" && this.mode === "yaml" && (p = void 0), Xr.log("xxxx", "draft.getSchema", p, "data", s, "pointer", l, "pointerPointsToKnownProperty", d), vi(p) && (p = (i = p.data) === null || i === void 0 ? void 0 : i.schema), !Im(p) && c ? [c] : (Im(p) || (p = a.getSchema({ pointer: u }), l = u), Xr.log("xxx", "pointer..", JSON.stringify(l)), !Im(p) && (!l || l === "/") && (p = (o = Bc(e, e)) !== null && o !== void 0 ? o : e), Xr.log("xxx", "subSchema..", p), p ? Array.isArray(p.allOf) ? [
      p,
      ...p.allOf.map((g) => Bc(g, e))
    ] : Array.isArray(p.oneOf) ? [
      p,
      ...p.oneOf.map((g) => Bc(g, e))
    ] : Array.isArray(p.anyOf) ? [
      p,
      ...p.anyOf.map((g) => Bc(g, e))
    ] : [p] : []);
  }
  getAppliedValue(e) {
    const r = qy(JSON.stringify(e));
    switch (this.mode) {
      case Hr.JSON5:
        return {
          label: r,
          apply: vie(JSON.stringify(e))
        };
      case Hr.YAML:
        return {
          label: r,
          apply: r
        };
      default:
        return {
          label: r,
          apply: JSON.stringify(e)
        };
    }
  }
  getValueFromLabel(e) {
    return JSON.parse(e);
  }
  extendedRegExp(e) {
    let r = "";
    e.startsWith("(?i)") && (e = e.substring(4), r = "i");
    try {
      return new RegExp(e, r + "u");
    } catch {
      try {
        return new RegExp(e, r);
      } catch {
        return;
      }
    }
  }
}
function dpe(t = {}) {
  const e = new fpe(t);
  return function(r) {
    return e.doComplete(r);
  };
}
function ppe(t) {
  return wm(t, (e, r) => e === "additionalProperties" && r === !1 ? [] : e === "required" && Array.isArray(r) ? [] : e === "unevaluatedProperties" && r === !1 ? [] : e === "unevaluatedItems" && r === !1 ? [] : [e, r]);
}
function u9(t, e, r) {
  const n = new FN(t), i = n.getSchema({
    pointer: r,
    data: e ?? void 0
  });
  if (!Im(i))
    return;
  const o = II(n, i), s = {};
  for (let d of o) {
    let p = gpe(r, d);
    const g = n.getSchema({
      // TODO [performance] use subSchema and only check it's sub-properties
      pointer: p,
      data: e ?? void 0
      // pointer: `/${possibleDirectPropertyName}`,
      // schema: subSchema
    });
    Im(g) && Object.assign(s, {
      [d]: g
    });
  }
  if (o.length === 0 || Object.keys(s).length === 0)
    return;
  const a = i, { allOf: l, anyOf: u, oneOf: c } = a, h = cpe(a, ["allOf", "anyOf", "oneOf"]);
  return Object.assign(Object.assign({}, h), { properties: s });
}
function II(t, e) {
  if (e = Bc(e, t.rootSchema), typeof e != "object" || e == null)
    return [];
  const r = [];
  function n(i) {
    const o = II(t, i);
    r.push(...o);
  }
  if (typeof e.properties == "object" && e.properties != null && r.push(...Object.keys(e.properties)), typeof e.then == "object" && e.then != null && n(e.then), Array.isArray(e.allOf))
    for (const i of e.allOf)
      n(i);
  if (Array.isArray(e.anyOf))
    for (const i of e.anyOf)
      n(i);
  if (Array.isArray(e.oneOf))
    for (const i of e.oneOf)
      n(i);
  return r;
}
function Bc(t, e) {
  if (typeof t == "object" && t.$ref) {
    const r = mpe(e, t.$ref);
    if (typeof r == "object") {
      const n = Object.assign(Object.assign({}, t), r);
      return Reflect.deleteProperty(n, "$ref"), n;
    }
  }
  return t;
}
function mpe(t, e) {
  const r = e.split("/");
  let n = t;
  return r.forEach((i) => {
    if (i) {
      if (i === "#") {
        n = t;
        return;
      }
      typeof n == "object" && (n = n[i]);
    }
  }), n;
}
function gpe(t, e) {
  return t === void 0 ? `/${e}` : `${t}/${e}`;
}
const Fg = (t, e) => {
  const r = t.length > 2;
  let n = t.map((i, o) => {
    const s = "`" + (e ? e(i) : i) + "`";
    return o === t.length - 1 ? "or " + s : s;
  });
  return r ? n.join(", ") : n.join(" ");
}, vpe = (t) => {
  var e, r, n;
  return !((e = t?.data) === null || e === void 0) && e.pointer && ((r = t?.data) === null || r === void 0 ? void 0 : r.pointer) !== "#" ? t.data.pointer.slice(1) : !((n = t?.data) === null || n === void 0) && n.property ? `/${t.data.property}` : "";
}, ype = (t) => t.startState.field(T1) !== t.state.field(T1);
function bpe(t) {
  const e = new wpe(t);
  return (r) => e.doValidation(r);
}
const xpe = [
  "NoAdditionalPropertiesError",
  "RequiredPropertyError",
  "InvalidPropertyNameError",
  "ForbiddenPropertyError",
  "UndefinedValueError"
];
class wpe {
  constructor(e) {
    var r, n, i, o;
    this.options = e, this.schema = null, this.mode = Hr.JSON, this.rewriteError = (s) => {
      var a, l, u, c, h;
      const d = s?.data, p = d?.errors;
      return s.code === "one-of-error" && p?.length ? `Expected one of ${Fg(p, (g) => g.data.expected)}` : s.code === "type-error" ? `Expected \`${!((a = s?.data) === null || a === void 0) && a.expected && Array.isArray((l = s?.data) === null || l === void 0 ? void 0 : l.expected) ? Fg((u = s?.data) === null || u === void 0 ? void 0 : u.expected) : (c = s?.data) === null || c === void 0 ? void 0 : c.expected}\` but received \`${(h = s?.data) === null || h === void 0 ? void 0 : h.received}\`` : s.message.replaceAll("in `#` ", "").replaceAll("at `#`", "").replaceAll("/", ".").replaceAll("#.", "");
    }, this.mode = (n = (r = this.options) === null || r === void 0 ? void 0 : r.mode) !== null && n !== void 0 ? n : Hr.JSON, this.parser = (o = (i = this.options) === null || i === void 0 ? void 0 : i.jsonParser) !== null && o !== void 0 ? o : $I(this.mode);
  }
  get schemaTitle() {
    var e, r, n;
    return (n = (r = (e = this.schema) === null || e === void 0 ? void 0 : e.getSchema()) === null || r === void 0 ? void 0 : r.title) !== null && n !== void 0 ? n : "json-schema";
  }
  // validate using view as the linter extension signature requires
  doValidation(e) {
    const r = z4(e.state);
    if (!r)
      return [];
    if (this.schema = new DN(r), !this.schema)
      return [];
    if (!e.state.doc.toString()?.length)
      return [];
    const i = this.parser(e.state);
    if (i.data == null)
      return [];
    let o = [];
    try {
      o = this.schema.validate(i.data);
    } catch {
    }
    return Xr.log("xxx", "validation errors", o, i.data), o.length ? o.reduce((s, a) => {
      const l = () => {
        const h = this.rewriteError(a);
        s.push({
          from: 0,
          to: 0,
          message: h,
          severity: "error",
          source: this.schemaTitle,
          renderMessage: () => {
            const d = _a("div", {});
            return d.innerHTML = ed(h), d;
          }
        });
      }, u = vpe(a), c = i.pointers.get(u);
      if (a.name === "MaxPropertiesError" || a.name === "MinPropertiesError" || u === "")
        l();
      else if (c) {
        const h = xpe.includes(a.name), d = this.rewriteError(a), p = h ? c.keyFrom : c.valueFrom, g = h ? c.keyTo : c.valueTo;
        g !== void 0 && p !== void 0 && s.push({
          from: p,
          to: g,
          message: d,
          renderMessage: () => {
            const v = _a("div", {});
            return v.innerHTML = ed(d), v;
          },
          severity: "error",
          source: this.schemaTitle
        });
      } else
        l();
      return s;
    }, []) : [];
  }
}
function kpe(t) {
  const e = new _pe(t);
  return async function(r, n, i) {
    return e.doHover(r, n, i);
  };
}
function Cpe(t) {
  if (t.type)
    return t.$ref ? `${t.$ref} (${t.type})` : t.type;
  if (t.$ref)
    return `${t.$ref}`;
}
function bk(t, e, r) {
  return `${e}: ${Fg(t[e].map((n) => {
    try {
      const { data: i } = r.resolveRef({ data: n, pointer: n.$ref });
      return Cpe(i || n);
    } catch {
      return n.type;
    }
  }))}`;
}
class _pe {
  constructor(e) {
    var r, n;
    this.opts = e, this.schema = null, this.mode = Hr.JSON, this.opts = Object.assign({ parser: JSON.parse }, this.opts), this.mode = (n = (r = this.opts) === null || r === void 0 ? void 0 : r.mode) !== null && n !== void 0 ? n : Hr.JSON;
  }
  getDataForCursor(e, r, n) {
    const i = z4(e.state);
    if (!i)
      return null;
    this.schema = new DN(i);
    const o = qR(e.state, r, n, this.mode);
    let s;
    try {
      s = this.opts.parser(e.state.doc.toString());
    } catch {
    }
    if (!o)
      return null;
    let a = this.schema.getSchema({
      pointer: o,
      data: s,
      withSchemaWarning: !0
    });
    return vi(a) && (a?.data.schema.$ref ? a = this.schema.resolveRef(a) : a = a?.data.schema), { schema: a, pointer: o };
  }
  formatMessage(e) {
    const { message: r, typeInfo: n } = e;
    return r ? _a("div", { class: "cm6-json-schema-hover" }, [
      _a("div", {
        class: "cm6-json-schema-hover--description",
        inner: ed(r, !1)
      }),
      _a("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
        _a("div", {
          class: "cm6-json-schema-hover--code",
          inner: ed(n, !1)
        })
      ])
    ]) : _a("div", { class: "cm6-json-schema-hover" }, [
      _a("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
        _a("code", {
          class: "cm6-json-schema-hover--code",
          inner: ed(n, !1)
        })
      ])
    ]);
  }
  getHoverTexts(e, r) {
    let n = "", i = null;
    const { schema: o } = e;
    return o.oneOf && (n = bk(o, "oneOf", r)), o.anyOf && (n = bk(o, "anyOf", r)), o.allOf && (n = bk(o, "allOf", r)), o.type && (n = Array.isArray(o.type) ? Fg(o.type) : o.type), o.$ref && (n = ` Reference: ${o.$ref}`), o.enum && (n = `\`enum\`: ${Fg(o.enum)}`), o.format && (n += `\`format\`: ${o.format}`), o.pattern && (n += `\`pattern\`: ${o.pattern}`), o.description && (i = o.description), { message: i, typeInfo: n };
  }
  // return hover state for the current json schema property
  async doHover(e, r, n) {
    var i, o, s, a;
    const l = r, u = r;
    try {
      const c = this.getDataForCursor(e, r, n);
      if (Xr.log("cursorData", c), !c?.schema)
        return null;
      const h = ((o = (i = this.opts) === null || i === void 0 ? void 0 : i.getHoverTexts) !== null && o !== void 0 ? o : this.getHoverTexts)(c, this.schema), d = ((a = (s = this.opts) === null || s === void 0 ? void 0 : s.formatHover) !== null && a !== void 0 ? a : this.formatMessage)(h);
      return {
        pos: l,
        end: u,
        arrow: !0,
        // to mimic similar modes for other editors
        // otherwise, it gets into a z-index battle with completion/etc
        above: !0,
        create: (p) => ({
          dom: d
        })
      };
    } catch (c) {
      return Xr.log(c), null;
    }
  }
}
function Spe(t) {
  return [
    Ife(),
    x8(Nfe()),
    x8(bpe(), {
      needsRefresh: ype
    }),
    B$.data.of({
      autocomplete: dpe()
    }),
    sP(kpe()),
    kie(t)
  ];
}
function Ape() {
  return [
    uZ(),
    fZ(),
    FY(),
    hte(),
    bY(),
    _Y(),
    ir.allowMultipleSelections.of(!0),
    jZ(),
    kP(VZ, { fallback: !0 }),
    YZ(),
    Uee(),
    ete(),
    qY(),
    VY(),
    $Y(),
    Mne(),
    Ie.domEventHandlers({
      keydown(t) {
        t.stopPropagation();
      }
    }),
    Bb.of([
      ...Gee,
      ...pre,
      ...Jne,
      ...xte,
      ...IP,
      ...bne,
      { key: "Tab", preventDefault: !0, run: hre },
      { key: "Shift-Tab", preventDefault: !0, run: gR }
    ])
  ];
}
function Epe(t, e) {
  const r = Ie.theme({
    "&.cm-editor": { height: "100%" },
    ".cm-scroller": { overflow: "auto" },
    "&.cm-focused": { outline: "none" },
    ".cm-tooltip": {
      boxShadow: e.colorScheme == "light" ? "0 2px 5px rgba(0,0,0,0.2)" : "0 2px 5px rgba(0,0,0,1)"
    },
    ".cm6-json-schema-hover": { padding: "6px" }
  }), n = Ie.updateListener.of((s) => {
    if (s.docChanged && e.onChange) {
      const a = s.state.doc.toString();
      e.onChange(a);
    }
  }), i = [];
  if (e.language == "json" && i.push(Spe(e.json?.schema ?? {})), e.language == "sql") {
    let s = e.sql?.table, a = e.sql?.columns;
    i.push(cne({
      dialect: hne,
      upperCaseKeywords: !0,
      schema: s != null ? {
        [s]: a?.map((l) => ({ label: l.name, detail: l.type, type: "property" })) ?? []
      } : void 0,
      defaultTable: s
    }));
  }
  const o = new Ie({
    doc: e.initialText,
    parent: t,
    extensions: [
      // Basic setup
      ...Ape(),
      // Tooltip parent element
      WY({ parent: t.parentElement }),
      // Langauge
      ...i,
      // Theme and styling
      ...e.colorScheme == "dark" ? [hie] : [],
      r,
      // Change
      n
    ]
  });
  return {
    set: (s) => {
      o.dispatch({
        changes: { from: 0, to: o.state.doc.length, insert: s }
      });
    },
    destroy: () => {
      o.destroy();
    }
  };
}
var Dpe = /* @__PURE__ */ me('<div><div class="rounded-md overflow-hidden border border-slate-200 dark:border-slate-600 w-full h-full"></div></div>');
function ES(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]), n;
  Ws(() => {
    let s = Ko(() => e.value) ?? "", a = Epe(n, {
      language: e.language ?? "plain",
      colorScheme: e.colorScheme ?? "light",
      initialText: Ko(() => e.value) ?? "",
      json: e.json,
      sql: e.sql,
      onChange: (l) => {
        s = l, e.onChange?.(l);
      }
    });
    return dt(() => {
      e.value != null && e.value != s && (s = r.value, a.set(s));
    }), () => {
      a.destroy();
    };
  });
  var i = Dpe(), o = Y(i);
  Qs(o, (s) => n = s, () => n), J(i), Ee(() => en(i, 1, Pb(e.class ?? ""))), Q(t, i), it();
}
var Ope = /* @__PURE__ */ me('<div class="w-full h-full flex flex-col gap-2"><!> <div class="flex-none flex gap-2 items-center"><button>Confirm</button> <div class="flex-1 w-0 overflow-hidden text-nowrap text-ellipsis"> </div></div></div>');
function Fpe(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(void 0), n = /* @__PURE__ */ K(() => x(r)?.spec !== void 0);
  function i(p) {
    try {
      return { spec: JSON.parse(p) };
    } catch (g) {
      return { message: g.message?.toString() };
    }
  }
  function o() {
    x(r) && x(r).spec != null && e.onSpecChange?.(x(r).spec);
  }
  var s = Ope(), a = Y(s);
  {
    let p = /* @__PURE__ */ K(() => JSON.stringify(e.spec, null, 2));
    ES(a, {
      class: "w-full flex-1 min-h-0",
      get colorScheme() {
        return e.colorScheme;
      },
      language: "json",
      get value() {
        return x(p);
      },
      onChange: (g) => {
        ae(r, i(g), !0);
      }
    });
  }
  var l = le(a, 2), u = Y(l);
  let c;
  u.__click = o;
  var h = le(u, 2), d = Y(h, !0);
  J(h), J(l), J(s), Ee(() => {
    c = en(u, 1, "flex-none px-2 h-8 w-24 rounded-md text-white text-sm", null, c, {
      "bg-blue-500": x(n),
      "bg-gray-300": !x(n),
      "dark:text-gray-500": !x(n),
      "dark:bg-gray-700": !x(n)
    }), u.disabled = !x(n), te(h, "title", x(r)?.message ?? ""), at(d, x(r)?.message ?? "");
  }), Q(t, s), it();
}
nn(["click"]);
var Tpe = /* @__PURE__ */ me('<span class="mx-1"> </span>'), Mpe = /* @__PURE__ */ me("<button><!> <!></button>");
function hy(t, e) {
  nt(e, !0);
  let r = lt(e, "label", 3, null), n = lt(e, "icon", 3, null), i = lt(e, "title", 3, ""), o = lt(e, "order", 3, null);
  var s = Mpe();
  s.__click = () => {
    e.onClick?.();
  };
  let a;
  var l = Y(s);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(n);
      var g = kr(), v = He(g);
      Qd(v, () => x(p), (y, b) => {
        b(y, { class: "w-4 h-4" });
      }), Q(d, g);
    };
    Fe(l, (d) => {
      n() != null && d(u);
    });
  }
  var c = le(l, 2);
  {
    var h = (d) => {
      var p = Tpe(), g = Y(p, !0);
      J(p), Ee(() => at(g, r())), Q(d, p);
    };
    Fe(c, (d) => {
      r() != null && r() != "" && d(h);
    });
  }
  J(s), Ee(() => {
    en(s, 1, `rounded-md flex select-none items-center px-1 py-1 text-slate-500 bg-slate-100 dark:text-slate-400 dark:bg-slate-800 focus-visible:outline-2 outline-blue-600 -outline-offset-1 ${e.class ?? "" ?? ""}`), te(s, "title", i()), a = ct(s, "", a, { order: o() });
  }), Q(t, s), it();
}
nn(["click"]);
var Ppe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M3.2 5.74a.75.75 0 0 1 1.06-.04L8 9.227L11.74 5.7a.75.75 0 1 1 1.02 1.1l-4.25 4a.75.75 0 0 1-1.02 0l-4.25-4a.75.75 0 0 1-.04-1.06"></path></svg>');
function c9(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Ppe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Rpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M3.2 10.26a.75.75 0 0 0 1.06.04L8 6.773l3.74 3.527a.75.75 0 1 0 1.02-1.1l-4.25-4a.75.75 0 0 0-1.02 0l-4.25 4a.75.75 0 0 0-.04 1.06"></path></svg>');
function h9(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Rpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Npe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M2.75 2a.75.75 0 0 1 .75.75v12.5c0 .69.56 1.25 1.25 1.25h12.5a.75.75 0 0 1 0 1.5H4.75A2.75 2.75 0 0 1 2 15.25V2.75A.75.75 0 0 1 2.75 2M10 7.5a2.5 2.5 0 1 1-5 0a2.5 2.5 0 0 1 5 0m4.5.5a2.5 2.5 0 1 0 0-5a2.5 2.5 0 0 0 0 5m.5 4.5a2.5 2.5 0 1 1-5 0a2.5 2.5 0 0 1 5 0"></path></svg>');
function $pe(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Npe();
  Qo(n, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Ipe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="m2.397 2.554l.073-.084a.75.75 0 0 1 .976-.073l.084.073L8 6.939l4.47-4.47a.75.75 0 1 1 1.06 1.061L9.061 8l4.47 4.47a.75.75 0 0 1 .072.976l-.073.084a.75.75 0 0 1-.976.073l-.084-.073L8 9.061l-4.47 4.47a.75.75 0 0 1-1.06-1.061L6.939 8l-4.47-4.47a.75.75 0 0 1-.072-.976l.073-.084z"></path></svg>');
function vx(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Ipe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Bpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M9 1H6a2 2 0 0 0-2 2v2.205a5.5 5.5 0 0 1 4.666 9.791H12a2 2 0 0 0 2-2V6.001h-3.5A1.5 1.5 0 0 1 9 4.5zm4.997 4h-3.498a.5.5 0 0 1-.5-.5V1h.01zM10 10.5a4.5 4.5 0 1 1-9 0a4.5 4.5 0 0 1 9 0m-4.854 2.353l.003.003a.5.5 0 0 0 .348.144h.006a.5.5 0 0 0 .35-.146l2-2a.5.5 0 0 0-.707-.708L6 11.293V8.5a.5.5 0 0 0-1 0v2.793l-1.146-1.147a.5.5 0 0 0-.708.708z"></path></svg>');
function f9(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Bpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Lpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M10.529 1.764a2.621 2.621 0 1 1 3.707 3.707l-.779.779L9.75 2.543zM9.043 3.25L2.657 9.636a2.96 2.96 0 0 0-.772 1.354l-.87 3.386a.5.5 0 0 0 .61.608l3.385-.869a2.95 2.95 0 0 0 1.354-.772l6.386-6.386z"></path></svg>');
function BI(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Lpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var zpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M2 6a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3zm3-2a2 2 0 0 0-2 2v5h14V6a2 2 0 0 0-2-2z"></path></svg>');
function jpe(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = zpe();
  Qo(n, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var qpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M15 3a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3zM5 4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h6.5V4z"></path></svg>');
function Upe(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = qpe();
  Qo(n, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Hpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M10.823 11.883a5.5 5.5 0 1 1 1.06-1.06l2.897 2.897a.75.75 0 1 1-1.06 1.06zM11.5 7.5a4 4 0 1 0-8 0a4 4 0 0 0 8 0"></path></svg>');
function Vpe(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Hpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Wpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M2.267 6.153A6 6 0 0 1 3.53 3.98a.36.36 0 0 1 .382-.095l1.36.484a.71.71 0 0 0 .935-.538l.26-1.416a.35.35 0 0 1 .274-.282a6.1 6.1 0 0 1 2.52 0c.14.03.248.141.274.282l.26 1.416a.708.708 0 0 0 .935.538l1.36-.484a.36.36 0 0 1 .382.095a6 6 0 0 1 1.262 2.173a.35.35 0 0 1-.108.378l-1.102.931a.703.703 0 0 0 0 1.076l1.102.931c.11.093.152.242.108.378a6 6 0 0 1-1.262 2.173a.36.36 0 0 1-.382.095l-1.36-.484a.71.71 0 0 0-.935.538l-.26 1.416a.35.35 0 0 1-.275.282a6.1 6.1 0 0 1-2.519 0a.35.35 0 0 1-.275-.282l-.259-1.416a.708.708 0 0 0-.935-.538l-1.36.484a.36.36 0 0 1-.382-.095a6 6 0 0 1-1.262-2.173a.35.35 0 0 1 .108-.378l1.102-.931a.704.704 0 0 0 0-1.076l-1.102-.931a.35.35 0 0 1-.108-.378M6.25 8a1.75 1.75 0 1 0 3.5 0a1.75 1.75 0 0 0-3.5 0"></path></svg>');
function LI(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Wpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Gpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M7.456 2a6 6 0 1 1-5.406 8.605a.5.5 0 0 1 .36-.71c1.276-.231 3.278-.937 4.078-3.07c.563-1.5.512-3.015.283-4.23a.5.5 0 0 1 .475-.591Q7.35 2 7.456 2"></path></svg>');
function Kpe(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Gpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Xpe = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M8 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 8 1m0 10a3 3 0 1 0 0-6a3 3 0 0 0 0 6m6.5-2.5a.5.5 0 0 0 0-1h-1a.5.5 0 0 0 0 1zM8 13a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 8 13M2.5 8.5a.5.5 0 0 0 0-1h-1a.5.5 0 0 0 0 1zm.646-5.354a.5.5 0 0 1 .708 0l1 1a.5.5 0 1 1-.708.708l-1-1a.5.5 0 0 1 0-.708m.708 9.708a.5.5 0 1 1-.708-.707l1-1a.5.5 0 0 1 .708.707zm9-9.708a.5.5 0 0 0-.708 0l-1 1a.5.5 0 0 0 .708.708l1-1a.5.5 0 0 0 0-.708m-.708 9.708a.5.5 0 0 0 .708-.707l-1-1a.5.5 0 0 0-.708.707z"></path></svg>');
function Qpe(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = Xpe();
  Qo(n, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
var Jpe = /* @__PURE__ */ me('<div class="text-sm pr-0.5"><!></div>'), Ype = /* @__PURE__ */ me('<div class="text-sm pr-0.5"><!></div>'), Zpe = /* @__PURE__ */ me('<div class="h-64"><div class="w-full h-64 p-2"><!></div></div>'), eme = /* @__PURE__ */ me('<div class="px-2 pt-2 flex items-center"><button class="font-mono font-medium py-0.5 text-left flex flex-1 mr-2 overflow-hidden items-center"><!> <div class="flex-1 whitespace-nowrap overflow-hidden text-ellipsis"> </div></button> <div class="flex-none flex gap-1 sm:opacity-0 group-hover:opacity-100 pr-0.5"><!> <!> <!> <!></div></div> <div><div class="overflow-hidden"><!> <!></div></div>', 1);
function d9(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(!1);
  var n = eme(), i = He(n), o = Y(i);
  o.__click = () => e.onIsVisibleChange?.(!e.isVisible);
  var s = Y(o);
  {
    var a = (z) => {
      var N = Jpe(), P = Y(N);
      h9(P, {}), J(N), Q(z, N);
    }, l = (z) => {
      var N = Ype(), P = Y(N);
      c9(P, {}), J(N), Q(z, N);
    };
    Fe(s, (z) => {
      e.isVisible ? z(a) : z(l, !1);
    });
  }
  var u = le(s, 2), c = Y(u, !0);
  J(u), J(o);
  var h = le(o, 2), d = Y(h);
  {
    var p = (z) => {
      hy(z, {
        get icon() {
          return BI;
        },
        title: "Edit spec",
        onClick: () => ae(r, !x(r))
      });
    };
    Fe(d, (z) => {
      e.onSpecChange && z(p);
    });
  }
  var g = le(d, 2);
  {
    var v = (z) => {
      hy(z, {
        get icon() {
          return h9;
        },
        title: "Move up",
        get onClick() {
          return e.onUp;
        }
      });
    };
    Fe(g, (z) => {
      e.onUp && z(v);
    });
  }
  var y = le(g, 2);
  {
    var b = (z) => {
      hy(z, {
        get icon() {
          return c9;
        },
        title: "Move down",
        get onClick() {
          return e.onDown;
        }
      });
    };
    Fe(y, (z) => {
      e.onDown && z(b);
    });
  }
  var k = le(y, 2);
  {
    var C = (z) => {
      hy(z, {
        get icon() {
          return vx;
        },
        title: "Close",
        onClick: () => e.onRemove()
      });
    };
    Fe(k, (z) => {
      e.onRemove && z(C);
    });
  }
  J(h), J(i);
  var S = le(i, 2);
  let _;
  var D = Y(S), A = Y(D);
  Jl(A, () => e.chartView, () => ({ id: e.id, width: "container" }));
  var O = le(A, 2);
  {
    var M = (z) => {
      var N = Zpe(), P = Y(N), I = Y(P);
      Fpe(I, {
        get spec() {
          return e.spec;
        },
        get colorScheme() {
          return e.colorScheme;
        },
        onSpecChange: (B) => {
          e.onSpecChange(B), ae(r, !1);
        }
      }), J(P), J(N), fm(3, N, () => dm), Q(z, N);
    };
    Fe(O, (z) => {
      x(r) && e.onSpecChange && z(M);
    });
  }
  J(D), J(S), Ee(() => {
    at(c, e.spec.title), _ = ct(S, "", _, {
      display: "grid",
      "grid-template-rows": e.isVisible ? "1fr" : "0fr",
      transition: "grid-template-rows 300ms ease-in-out"
    });
  }), Q(t, n), it();
}
nn(["click"]);
function tme(t) {
  switch (t.type) {
    case "embedding":
      return "embedding";
    case "table":
      return "table";
    default:
      return "chart";
  }
}
function zI(t) {
  let e = { embedding: [], table: [], chart: [] };
  for (let r in t) {
    let n = tme(t[r]);
    n != null && e[n].push(r);
  }
  return e;
}
var rme = /* @__PURE__ */ me('<div class="flex-1 overflow-hidden rounded-md"><!></div>'), nme = /* @__PURE__ */ me('<div class="flex flex-row gap-2 flex-1 overflow-hidden"></div>'), ime = /* @__PURE__ */ me('<div class="flex-1 h-full overflow-hidden rounded-md"><!></div>'), ome = /* @__PURE__ */ me("<div></div>"), sme = /* @__PURE__ */ me('<div class="flex-1 flex flex-col overflow-hidden"><!> <!> <!></div>'), ame = /* @__PURE__ */ me('<div class="bg-white dark:bg-black rounded-md flex flex-col gap-2 group"><!></div>'), lme = /* @__PURE__ */ me('<div class="h-full overflow-x-hidden overflow-y-scroll"><div class="flex flex-row flex-wrap gap-2"><button class="bg-white dark:bg-black rounded-md flex flex-col justify-center items-center gap-2 p-2 w-full text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-slate-100">+ Add</button> <!></div></div>'), ume = /* @__PURE__ */ me("<!> <!> <!>", 1), cme = /* @__PURE__ */ me('<div class="bg-white dark:bg-black rounded-md flex flex-col gap-2 group"><!></div>'), hme = /* @__PURE__ */ me('<div class="w-full h-full overflow-y-scroll flex flex-col gap-2"><button class="bg-white dark:bg-black rounded-md flex flex-col justify-center items-center gap-2 p-2 w-full text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-slate-100">+ Add</button> <!></div>'), fme = /* @__PURE__ */ me('<div class="w-full h-full flex flex-row"><!></div>');
function dme(t, e) {
  nt(e, !0);
  const r = () => gi(o, "$colorScheme", n), [n, i] = Jo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ De(100), a = /* @__PURE__ */ De(100), l = /* @__PURE__ */ De(300), u = /* @__PURE__ */ De(400), c = /* @__PURE__ */ K(nD(() => zI(e.charts))), h = /* @__PURE__ */ K(() => x(s) < 500), d = /* @__PURE__ */ K(() => x(c).embedding.length > 0 && (e.state.showEmbedding ?? !0)), p = /* @__PURE__ */ K(() => x(c).table.length > 0 && (e.state.showTable ?? !0)), g = /* @__PURE__ */ K(() => e.state.showCharts ?? !0);
  function v(A, O) {
    let M = Math.round((A + 7) / (O + 7)), z, N;
    for (let P = Math.max(1, M - 1); P <= Math.max(1, M + 1); P++) {
      let I = (A - 7 * (P - 1)) / P, B = Math.abs(I - O);
      (z == null || B < z) && (z = B, N = I);
    }
    return Math.floor((N ?? 400) * 2) / 2;
  }
  let y = /* @__PURE__ */ K(nD(() => {
    let A = e.state.chartsOrder ?? [], O = x(c).chart.slice();
    return O.sort((M, z) => {
      let N = A.indexOf(M), P = A.indexOf(z);
      return N == -1 && (N = O.length), P == -1 && (P = O.length), N - P;
    }), O;
  }));
  function b(A, O) {
    let M = [...x(y)], z = M.indexOf(A);
    if (z == -1)
      return;
    let N = z + O;
    N < 0 || N >= M.length || ([M[z], M[N]] = [M[N], M[z]], e.onStateChange({ chartsOrder: M }));
  }
  function k(A) {
    e.onChartsChange({ [A]: void 0 }), e.onChartStatesChange({ [A]: void 0 });
  }
  var C = fme(), S = Y(C);
  {
    var _ = (A) => {
      var O = ume(), M = He(O);
      {
        var z = ($) => {
          var j = sme(), U = Y(j);
          {
            var H = (ie) => {
              var ce = nme();
              It(ce, 20, () => x(c).embedding, (Ce) => Ce, (Ce, Me) => {
                var Pe = rme(), Ae = Y(Pe);
                Jl(Ae, () => e.chartView, () => ({ id: Me, width: "container", height: "container" })), J(Pe), Q(Ce, Pe);
              }), J(ce), Q(ie, ce);
            };
            Fe(U, (ie) => {
              x(d) && ie(H);
            });
          }
          var G = le(U, 2);
          {
            var re = (ie) => {
              {
                let ce = /* @__PURE__ */ K(() => x(a) - 100);
                _D(ie, {
                  class: "h-2 flex-none",
                  axis: "y",
                  min: 100,
                  get max() {
                    return x(ce);
                  },
                  scaler: -1,
                  get value() {
                    return x(l);
                  },
                  onChange: (Ce) => ae(l, Ce, !0)
                });
              }
            };
            Fe(G, (ie) => {
              x(d) && x(p) && ie(re);
            });
          }
          var ne = le(G, 2);
          {
            var se = (ie) => {
              var ce = ome();
              let Ce;
              It(ce, 20, () => x(c).table, (Me) => Me, (Me, Pe) => {
                var Ae = ime(), he = Y(Ae);
                Jl(he, () => e.chartView, () => ({ id: Pe, width: "container", height: "container" })), J(Ae), Q(Me, Ae);
              }), J(ce), Ee(() => {
                en(ce, 1, Pb(x(d) ? "flex-none" : "flex-1")), Ce = ct(ce, "", Ce, {
                  height: x(d) ? `${x(l)}px` : null
                });
              }), fm(3, ce, () => dm), Q(ie, ce);
            };
            Fe(ne, (ie) => {
              x(p) && ie(se);
            });
          }
          J(j), Q($, j);
        };
        Fe(M, ($) => {
          (x(d) || x(p)) && $(z);
        });
      }
      var N = le(M, 2);
      {
        var P = ($) => {
          {
            let j = /* @__PURE__ */ K(() => x(s) - 100);
            _D($, {
              class: "w-2 flex-none",
              axis: "x",
              min: 100,
              get max() {
                return x(j);
              },
              scaler: -1,
              get value() {
                return x(u);
              },
              onChange: (U) => ae(u, U, !0)
            });
          }
        };
        Fe(N, ($) => {
          (x(d) || x(p)) && x(g) && $(P);
        });
      }
      var I = le(N, 2);
      {
        var B = ($) => {
          const j = /* @__PURE__ */ K(() => x(d) || x(p) ? x(u) : x(s));
          var U = lme();
          let H;
          var G = Y(U);
          let re;
          var ne = Y(G);
          ne.__click = () => {
            let ie = SD(e.charts);
            e.onChartsChange({ [ie]: { type: "builder", title: "New" } }), e.onStateChange({ chartsOrder: [ie, ...x(y)] });
          };
          var se = le(ne, 2);
          It(se, 26, () => x(y), (ie) => ie, (ie, ce, Ce) => {
            const Me = /* @__PURE__ */ K(() => e.charts[ce]), Pe = /* @__PURE__ */ K(() => e.state.chartVisibility?.[ce] ?? !0);
            var Ae = ame();
            let he;
            var we = Y(Ae);
            {
              let ve = /* @__PURE__ */ K(() => k.bind(null, ce)), Ge = /* @__PURE__ */ K(() => x(Ce) > 0 ? b.bind(null, ce, -1) : void 0), Xe = /* @__PURE__ */ K(() => x(Ce) + 1 < x(y).length ? b.bind(null, ce, 1) : void 0);
              d9(we, {
                get id() {
                  return ce;
                },
                get spec() {
                  return x(Me);
                },
                onIsVisibleChange: (et) => {
                  e.onStateChange({ chartVisibility: { [ce]: et } });
                },
                get isVisible() {
                  return x(Pe);
                },
                get colorScheme() {
                  return r();
                },
                get chartView() {
                  return e.chartView;
                },
                get onRemove() {
                  return x(ve);
                },
                get onUp() {
                  return x(Ge);
                },
                get onDown() {
                  return x(Xe);
                },
                onSpecChange: (et) => {
                  e.onChartsChange({ [ce]: void 0 }), e.onChartStatesChange({ [ce]: void 0 }), e.onChartsChange({ [ce]: et });
                }
              });
            }
            J(Ae), Ee((ve) => he = ct(Ae, "", he, ve), [
              () => ({ width: `${v(x(j), 500) ?? ""}px` })
            ]), xD(Ae, () => CD, () => ({ duration: 300 })), fm(2, Ae, () => dm), Q(ie, Ae);
          }), J(G), J(U), Ee(() => {
            H = ct(U, "", H, { width: `${x(j) ?? ""}px` }), re = ct(G, "", re, { width: `${x(j) ?? ""}px` });
          }), fm(3, U, () => dm, () => ({ axis: "x" })), Q($, U);
        };
        Fe(I, ($) => {
          x(g) && $(B);
        });
      }
      Q(A, O);
    }, D = (A) => {
      var O = hme(), M = Y(O);
      M.__click = () => {
        let N = SD(e.charts);
        e.onChartsChange({ [N]: { type: "builder", title: "New" } }), e.onStateChange({ chartsOrder: [N, ...x(y)] });
      };
      var z = le(M, 2);
      It(z, 26, () => x(c).embedding.concat(x(y), x(c).table), (N) => N, (N, P) => {
        const I = /* @__PURE__ */ K(() => e.state.chartVisibility?.[P] ?? !0), B = /* @__PURE__ */ K(() => x(y).indexOf(P));
        var $ = cme(), j = Y($);
        {
          let U = /* @__PURE__ */ K(() => k.bind(null, P)), H = /* @__PURE__ */ K(() => x(B) > 0 ? b.bind(null, P, -1) : void 0), G = /* @__PURE__ */ K(() => x(B) != -1 && x(B) + 1 < x(y).length ? b.bind(null, P, 1) : void 0);
          d9(j, {
            get id() {
              return P;
            },
            get spec() {
              return e.charts[P];
            },
            onIsVisibleChange: (re) => {
              e.onStateChange({ chartVisibility: { [P]: re } });
            },
            get isVisible() {
              return x(I);
            },
            get colorScheme() {
              return r();
            },
            get chartView() {
              return e.chartView;
            },
            get onRemove() {
              return x(U);
            },
            get onUp() {
              return x(H);
            },
            get onDown() {
              return x(G);
            }
          });
        }
        J($), xD($, () => CD, () => ({ duration: 300 })), fm(2, $, () => dm), Q(N, $);
      }), J(O), Q(A, O);
    };
    Fe(S, (A) => {
      x(h) ? A(D, !1) : A(_);
    });
  }
  J(C), Xs(C, "clientWidth", (A) => ae(s, A)), Xs(C, "clientHeight", (A) => ae(a, A)), Q(t, C), it(), i();
}
nn(["click"]);
var pme = /* @__PURE__ */ me('<span class="flex h-5 items-center"> </span>'), mme = /* @__PURE__ */ me("<button><!> <!></button>");
function Jy(t, e) {
  nt(e, !0);
  let r = lt(e, "title", 3, ""), n = lt(e, "checked", 15), i = lt(e, "label", 3, null), o = lt(e, "icon", 3, null);
  var s = mme();
  let a;
  s.__click = () => {
    n(!n());
  };
  var l = Y(s);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(o);
      var g = kr(), v = He(g);
      Qd(v, () => x(p), (y, b) => {
        b(y, { class: "w-5 h-5" });
      }), Q(d, g);
    };
    Fe(l, (d) => {
      o() != null && d(u);
    });
  }
  var c = le(l, 2);
  {
    var h = (d) => {
      var p = pme(), g = Y(p, !0);
      J(p), Ee(() => at(g, i())), Q(d, p);
    };
    Fe(c, (d) => {
      i() != null && d(h);
    });
  }
  J(s), Ee(() => {
    a = en(s, 1, "rounded-md px-1.5 py-1.5 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 flex select-none items-center focus-visible:outline-2 outline-blue-600 -outline-offset-1", null, a, {
      "text-slate-400": !n(),
      "dark:text-slate-500": !n()
    }), te(s, "title", r());
  }), Q(t, s), it();
}
nn(["click"]);
var gme = /* @__PURE__ */ me("<!> <!> <!>", 1);
function p9(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => zI(e.charts));
  var n = gme(), i = He(n);
  {
    var o = (d) => {
      var p = () => e.state.showEmbedding ?? !0, g = (v) => {
        e.onStateChange({ showEmbedding: v });
      };
      Jy(d, {
        get icon() {
          return $pe;
        },
        title: "Show / hide embedding",
        get checked() {
          return p();
        },
        set checked(v) {
          g(v);
        }
      });
    };
    Fe(i, (d) => {
      x(r).embedding.length > 0 && d(o);
    });
  }
  var s = le(i, 2), a = () => e.state.showTable ?? !0, l = (d) => {
    e.onStateChange({ showTable: d });
  };
  Jy(s, {
    get icon() {
      return jpe;
    },
    title: "Show / hide table",
    get checked() {
      return a();
    },
    set checked(d) {
      l(d);
    }
  });
  var u = le(s, 2), c = () => e.state.showCharts ?? !0, h = (d) => {
    e.onStateChange({ showCharts: d });
  };
  Jy(u, {
    get icon() {
      return Upe;
    },
    title: "Show / hide charts",
    get checked() {
      return c();
    },
    set checked(d) {
      h(d);
    }
  }), Q(t, n), it();
}
const nd = {
  list: [dme, p9],
  grid: [hQ, p9]
};
function vme(t) {
  return nd[t] == null ? nd.list[0] : nd[t][0];
}
function yme(t) {
  return nd[t] == null ? nd.list[1] : nd[t][1];
}
function bme(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => yme(e.layout)), n = /* @__PURE__ */ K(() => e.layoutStates[e.layout] ?? {});
  function i(u, c = "merge") {
    md(e.charts, u, c, (h) => e.onChartsChange?.(h));
  }
  function o(u, c = "merge") {
    md(e.chartStates, u, c, (h) => e.onChartStatesChange?.(h));
  }
  function s(u, c, h = "merge") {
    Ay(e.layoutStates, u, c, h, (d) => e.onLayoutStatesChange?.(d));
  }
  var a = kr(), l = He(a);
  {
    let u = /* @__PURE__ */ K(() => s.bind(null, e.layout));
    Qd(l, () => x(r), (c, h) => {
      h(c, {
        get context() {
          return e.context;
        },
        get charts() {
          return e.charts;
        },
        get state() {
          return x(n);
        },
        get onStateChange() {
          return x(u);
        },
        onChartsChange: i,
        onChartStatesChange: o
      });
    });
  }
  Q(t, a), it();
}
var xme = /* @__PURE__ */ me("<div><!></div>");
function yc(t, e) {
  let r = lt(e, "defaultWidth", 3, null), n = lt(e, "defaultHeight", 3, null), i = lt(e, "scrollX", 3, !1), o = lt(e, "scrollY", 3, !1), s = /* @__PURE__ */ K(() => e.width != null ? e.width : i() ? void 0 : r()), a = /* @__PURE__ */ K(() => e.height != null ? e.height : o() ? void 0 : n());
  var l = xme();
  let u;
  var c = Y(l);
  Jl(c, () => e.children), J(l), Ee(() => {
    en(l, 1, `p-2 ${e.class ?? "" ?? ""}`), u = ct(l, "", u, {
      width: x(s) != null ? `${x(s)}px` : void 0,
      height: x(a) != null ? `${x(a)}px` : void 0,
      "overflow-x": i() && e.width != null ? "auto" : void 0,
      "overflow-y": o() && e.height != null ? "auto" : void 0
    });
  }), Q(t, l);
}
var wme = /* @__PURE__ */ me("<div><!></div>");
function g0(t, e) {
  let r = /* @__PURE__ */ De(300), n = /* @__PURE__ */ De(200), i = lt(e, "flexHeight", 3, !0), o = lt(e, "defaultHeight", 3, 200);
  var s = wme();
  let a;
  var l = Y(s);
  Jl(l, () => e.children ?? jt, () => x(r), () => x(n)), J(s), Ee(() => {
    en(s, 1, Pb(i() ? "flex-1 min-h-0" : void 0)), a = ct(s, "", a, {
      "user-select": "none",
      position: "relative",
      height: i() ? void 0 : `${o()}px`
    });
  }), Xs(s, "clientWidth", (u) => ae(r, u)), Xs(s, "clientHeight", (u) => ae(n, u)), Q(t, s);
}
function kme(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function rb(t, e) {
  if ((r = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
  var r, n = t.slice(0, r);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +t.slice(r + 1)
  ];
}
function Rd(t) {
  return t = rb(Math.abs(t)), t ? t[1] : NaN;
}
function Cme(t, e) {
  return function(r, n) {
    for (var i = r.length, o = [], s = 0, a = t[0], l = 0; i > 0 && a > 0 && (l + a + 1 > n && (a = Math.max(1, n - l)), o.push(r.substring(i -= a, i + a)), !((l += a + 1) > n)); )
      a = t[s = (s + 1) % t.length];
    return o.reverse().join(e);
  };
}
function _me(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(r) {
      return t[+r];
    });
  };
}
var Sme = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Tg(t) {
  if (!(e = Sme.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new DS({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
Tg.prototype = DS.prototype;
function DS(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
DS.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Ame(t) {
  e: for (var e = t.length, r = 1, n = -1, i; r < e; ++r)
    switch (t[r]) {
      case ".":
        n = i = r;
        break;
      case "0":
        n === 0 && (n = r), i = r;
        break;
      default:
        if (!+t[r]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? t.slice(0, n) + t.slice(i + 1) : t;
}
var jI;
function Eme(t, e) {
  var r = rb(t, e);
  if (!r) return t + "";
  var n = r[0], i = r[1], o = i - (jI = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, s = n.length;
  return o === s ? n : o > s ? n + new Array(o - s + 1).join("0") : o > 0 ? n.slice(0, o) + "." + n.slice(o) : "0." + new Array(1 - o).join("0") + rb(t, Math.max(0, e + o - 1))[0];
}
function m9(t, e) {
  var r = rb(t, e);
  if (!r) return t + "";
  var n = r[0], i = r[1];
  return i < 0 ? "0." + new Array(-i).join("0") + n : n.length > i + 1 ? n.slice(0, i + 1) + "." + n.slice(i + 1) : n + new Array(i - n.length + 2).join("0");
}
const g9 = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: kme,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => m9(t * 100, e),
  r: m9,
  s: Eme,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function v9(t) {
  return t;
}
var y9 = Array.prototype.map, b9 = ["y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Dme(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? v9 : Cme(y9.call(t.grouping, Number), t.thousands + ""), r = t.currency === void 0 ? "" : t.currency[0] + "", n = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", o = t.numerals === void 0 ? v9 : _me(y9.call(t.numerals, String)), s = t.percent === void 0 ? "%" : t.percent + "", a = t.minus === void 0 ? "âˆ’" : t.minus + "", l = t.nan === void 0 ? "NaN" : t.nan + "";
  function u(h) {
    h = Tg(h);
    var d = h.fill, p = h.align, g = h.sign, v = h.symbol, y = h.zero, b = h.width, k = h.comma, C = h.precision, S = h.trim, _ = h.type;
    _ === "n" ? (k = !0, _ = "g") : g9[_] || (C === void 0 && (C = 12), S = !0, _ = "g"), (y || d === "0" && p === "=") && (y = !0, d = "0", p = "=");
    var D = v === "$" ? r : v === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "", A = v === "$" ? n : /[%p]/.test(_) ? s : "", O = g9[_], M = /[defgprs%]/.test(_);
    C = C === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, C)) : Math.max(0, Math.min(20, C));
    function z(N) {
      var P = D, I = A, B, $, j;
      if (_ === "c")
        I = O(N) + I, N = "";
      else {
        N = +N;
        var U = N < 0 || 1 / N < 0;
        if (N = isNaN(N) ? l : O(Math.abs(N), C), S && (N = Ame(N)), U && +N == 0 && g !== "+" && (U = !1), P = (U ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + P, I = (_ === "s" ? b9[8 + jI / 3] : "") + I + (U && g === "(" ? ")" : ""), M) {
          for (B = -1, $ = N.length; ++B < $; )
            if (j = N.charCodeAt(B), 48 > j || j > 57) {
              I = (j === 46 ? i + N.slice(B + 1) : N.slice(B)) + I, N = N.slice(0, B);
              break;
            }
        }
      }
      k && !y && (N = e(N, 1 / 0));
      var H = P.length + N.length + I.length, G = H < b ? new Array(b - H + 1).join(d) : "";
      switch (k && y && (N = e(G + N, G.length ? b - I.length : 1 / 0), G = ""), p) {
        case "<":
          N = P + N + I + G;
          break;
        case "=":
          N = P + G + N + I;
          break;
        case "^":
          N = G.slice(0, H = G.length >> 1) + P + N + I + G.slice(H);
          break;
        default:
          N = G + P + N + I;
          break;
      }
      return o(N);
    }
    return z.toString = function() {
      return h + "";
    }, z;
  }
  function c(h, d) {
    var p = u((h = Tg(h), h.type = "f", h)), g = Math.max(-8, Math.min(8, Math.floor(Rd(d) / 3))) * 3, v = Math.pow(10, -g), y = b9[8 + g / 3];
    return function(b) {
      return p(v * b) + y;
    };
  }
  return {
    format: u,
    formatPrefix: c
  };
}
var fy, su, qI;
Ome({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Ome(t) {
  return fy = Dme(t), su = fy.format, qI = fy.formatPrefix, fy;
}
function Fme(t) {
  return Math.max(0, -Rd(Math.abs(t)));
}
function Tme(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Rd(e) / 3))) * 3 - Rd(Math.abs(t)));
}
function Mme(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, Rd(e) - Rd(t)) + 1;
}
function Yy(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Pme(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function UI(t) {
  let e, r, n;
  t.length !== 2 ? (e = Yy, r = (a, l) => Yy(t(a), l), n = (a, l) => t(a) - l) : (e = t === Yy || t === Pme ? t : Rme, r = t, n = t);
  function i(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const h = u + c >>> 1;
        r(a[h], l) < 0 ? u = h + 1 : c = h;
      } while (u < c);
    }
    return u;
  }
  function o(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const h = u + c >>> 1;
        r(a[h], l) <= 0 ? u = h + 1 : c = h;
      } while (u < c);
    }
    return u;
  }
  function s(a, l, u = 0, c = a.length) {
    const h = i(a, l, u, c - 1);
    return h > u && n(a[h - 1], l) > -n(a[h], l) ? h - 1 : h;
  }
  return { left: i, center: s, right: o };
}
function Rme() {
  return 0;
}
function Nme(t) {
  return t === null ? NaN : +t;
}
const $me = UI(Yy), Ime = $me.right;
UI(Nme).center;
class x9 extends Map {
  constructor(e, r = zme) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null) for (const [n, i] of e) this.set(n, i);
  }
  get(e) {
    return super.get(w9(this, e));
  }
  has(e) {
    return super.has(w9(this, e));
  }
  set(e, r) {
    return super.set(Bme(this, e), r);
  }
  delete(e) {
    return super.delete(Lme(this, e));
  }
}
function w9({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : r;
}
function Bme({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : (t.set(n, r), r);
}
function Lme({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) && (r = t.get(n), t.delete(n)), r;
}
function zme(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
const jme = Math.sqrt(50), qme = Math.sqrt(10), Ume = Math.sqrt(2);
function nb(t, e, r) {
  const n = (e - t) / Math.max(0, r), i = Math.floor(Math.log10(n)), o = n / Math.pow(10, i), s = o >= jme ? 10 : o >= qme ? 5 : o >= Ume ? 2 : 1;
  let a, l, u;
  return i < 0 ? (u = Math.pow(10, -i) / s, a = Math.round(t * u), l = Math.round(e * u), a / u < t && ++a, l / u > e && --l, u = -u) : (u = Math.pow(10, i) * s, a = Math.round(t / u), l = Math.round(e / u), a * u < t && ++a, l * u > e && --l), l < a && 0.5 <= r && r < 2 ? nb(t, e, r * 2) : [a, l, u];
}
function KC(t, e, r) {
  if (e = +e, t = +t, r = +r, !(r > 0)) return [];
  if (t === e) return [t];
  const n = e < t, [i, o, s] = n ? nb(e, t, r) : nb(t, e, r);
  if (!(o >= i)) return [];
  const a = o - i + 1, l = new Array(a);
  if (n)
    if (s < 0) for (let u = 0; u < a; ++u) l[u] = (o - u) / -s;
    else for (let u = 0; u < a; ++u) l[u] = (o - u) * s;
  else if (s < 0) for (let u = 0; u < a; ++u) l[u] = (i + u) / -s;
  else for (let u = 0; u < a; ++u) l[u] = (i + u) * s;
  return l;
}
function XC(t, e, r) {
  return e = +e, t = +t, r = +r, nb(t, e, r)[2];
}
function Hme(t, e, r) {
  e = +e, t = +t, r = +r;
  const n = e < t, i = n ? XC(e, t, r) : XC(t, e, r);
  return (n ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function Vme(t, e, r) {
  t = +t, e = +e, r = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +r;
  for (var n = -1, i = Math.max(0, Math.ceil((e - t) / r)) | 0, o = new Array(i); ++n < i; )
    o[n] = t + n * r;
  return o;
}
function v0(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
const k9 = Symbol("implicit");
function HI() {
  var t = new x9(), e = [], r = [], n = k9;
  function i(o) {
    let s = t.get(o);
    if (s === void 0) {
      if (n !== k9) return n;
      t.set(o, s = e.push(o) - 1);
    }
    return r[s % r.length];
  }
  return i.domain = function(o) {
    if (!arguments.length) return e.slice();
    e = [], t = new x9();
    for (const s of o)
      t.has(s) || t.set(s, e.push(s) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (r = Array.from(o), i) : r.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (n = o, i) : n;
  }, i.copy = function() {
    return HI(e, r).unknown(n);
  }, v0.apply(i, arguments), i;
}
function VI() {
  var t = HI().unknown(void 0), e = t.domain, r = t.range, n = 0, i = 1, o, s, a = !1, l = 0, u = 0, c = 0.5;
  delete t.unknown;
  function h() {
    var d = e().length, p = i < n, g = p ? i : n, v = p ? n : i;
    o = (v - g) / Math.max(1, d - l + u * 2), a && (o = Math.floor(o)), g += (v - g - o * (d - l)) * c, s = o * (1 - l), a && (g = Math.round(g), s = Math.round(s));
    var y = Vme(d).map(function(b) {
      return g + o * b;
    });
    return r(p ? y.reverse() : y);
  }
  return t.domain = function(d) {
    return arguments.length ? (e(d), h()) : e();
  }, t.range = function(d) {
    return arguments.length ? ([n, i] = d, n = +n, i = +i, h()) : [n, i];
  }, t.rangeRound = function(d) {
    return [n, i] = d, n = +n, i = +i, a = !0, h();
  }, t.bandwidth = function() {
    return s;
  }, t.step = function() {
    return o;
  }, t.round = function(d) {
    return arguments.length ? (a = !!d, h()) : a;
  }, t.padding = function(d) {
    return arguments.length ? (l = Math.min(1, u = +d), h()) : l;
  }, t.paddingInner = function(d) {
    return arguments.length ? (l = Math.min(1, d), h()) : l;
  }, t.paddingOuter = function(d) {
    return arguments.length ? (u = +d, h()) : u;
  }, t.align = function(d) {
    return arguments.length ? (c = Math.max(0, Math.min(1, d)), h()) : c;
  }, t.copy = function() {
    return VI(e(), [n, i]).round(a).paddingInner(l).paddingOuter(u).align(c);
  }, v0.apply(h(), arguments);
}
function y0(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function yx(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function Hh() {
}
var Mg = 0.7, ib = 1 / Mg, id = "\\s*([+-]?\\d+)\\s*", Pg = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Va = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Wme = /^#([0-9a-f]{3,8})$/, Gme = new RegExp(`^rgb\\(${id},${id},${id}\\)$`), Kme = new RegExp(`^rgb\\(${Va},${Va},${Va}\\)$`), Xme = new RegExp(`^rgba\\(${id},${id},${id},${Pg}\\)$`), Qme = new RegExp(`^rgba\\(${Va},${Va},${Va},${Pg}\\)$`), Jme = new RegExp(`^hsl\\(${Pg},${Va},${Va}\\)$`), Yme = new RegExp(`^hsla\\(${Pg},${Va},${Va},${Pg}\\)$`), C9 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
y0(Hh, Rg, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: _9,
  // Deprecated! Use color.formatHex.
  formatHex: _9,
  formatHex8: Zme,
  formatHsl: ege,
  formatRgb: S9,
  toString: S9
});
function _9() {
  return this.rgb().formatHex();
}
function Zme() {
  return this.rgb().formatHex8();
}
function ege() {
  return GI(this).formatHsl();
}
function S9() {
  return this.rgb().formatRgb();
}
function Rg(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = Wme.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? A9(e) : r === 3 ? new si(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? dy(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? dy(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = Gme.exec(t)) ? new si(e[1], e[2], e[3], 1) : (e = Kme.exec(t)) ? new si(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Xme.exec(t)) ? dy(e[1], e[2], e[3], e[4]) : (e = Qme.exec(t)) ? dy(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = Jme.exec(t)) ? O9(e[1], e[2] / 100, e[3] / 100, 1) : (e = Yme.exec(t)) ? O9(e[1], e[2] / 100, e[3] / 100, e[4]) : C9.hasOwnProperty(t) ? A9(C9[t]) : t === "transparent" ? new si(NaN, NaN, NaN, 0) : null;
}
function A9(t) {
  return new si(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function dy(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new si(t, e, r, n);
}
function WI(t) {
  return t instanceof Hh || (t = Rg(t)), t ? (t = t.rgb(), new si(t.r, t.g, t.b, t.opacity)) : new si();
}
function Ng(t, e, r, n) {
  return arguments.length === 1 ? WI(t) : new si(t, e, r, n ?? 1);
}
function si(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
y0(si, Ng, yx(Hh, {
  brighter(t) {
    return t = t == null ? ib : Math.pow(ib, t), new si(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Mg : Math.pow(Mg, t), new si(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new si(lh(this.r), lh(this.g), lh(this.b), ob(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: E9,
  // Deprecated! Use color.formatHex.
  formatHex: E9,
  formatHex8: tge,
  formatRgb: D9,
  toString: D9
}));
function E9() {
  return `#${Jc(this.r)}${Jc(this.g)}${Jc(this.b)}`;
}
function tge() {
  return `#${Jc(this.r)}${Jc(this.g)}${Jc(this.b)}${Jc((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function D9() {
  const t = ob(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${lh(this.r)}, ${lh(this.g)}, ${lh(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function ob(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function lh(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function Jc(t) {
  return t = lh(t), (t < 16 ? "0" : "") + t.toString(16);
}
function O9(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new qs(t, e, r, n);
}
function GI(t) {
  if (t instanceof qs) return new qs(t.h, t.s, t.l, t.opacity);
  if (t instanceof Hh || (t = Rg(t)), !t) return new qs();
  if (t instanceof qs) return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, i = Math.min(e, r, n), o = Math.max(e, r, n), s = NaN, a = o - i, l = (o + i) / 2;
  return a ? (e === o ? s = (r - n) / a + (r < n) * 6 : r === o ? s = (n - e) / a + 2 : s = (e - r) / a + 4, a /= l < 0.5 ? o + i : 2 - o - i, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new qs(s, a, l, t.opacity);
}
function rge(t, e, r, n) {
  return arguments.length === 1 ? GI(t) : new qs(t, e, r, n ?? 1);
}
function qs(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
y0(qs, rge, yx(Hh, {
  brighter(t) {
    return t = t == null ? ib : Math.pow(ib, t), new qs(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Mg : Math.pow(Mg, t), new qs(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new si(
      xk(t >= 240 ? t - 240 : t + 120, i, n),
      xk(t, i, n),
      xk(t < 120 ? t + 240 : t - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new qs(F9(this.h), py(this.s), py(this.l), ob(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = ob(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${F9(this.h)}, ${py(this.s) * 100}%, ${py(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function F9(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function py(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function xk(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const nge = Math.PI / 180, ige = 180 / Math.PI, sb = 18, KI = 0.96422, XI = 1, QI = 0.82521, JI = 4 / 29, od = 6 / 29, YI = 3 * od * od, oge = od * od * od;
function ZI(t) {
  if (t instanceof Wa) return new Wa(t.l, t.a, t.b, t.opacity);
  if (t instanceof jl) return tB(t);
  t instanceof si || (t = WI(t));
  var e = _k(t.r), r = _k(t.g), n = _k(t.b), i = wk((0.2225045 * e + 0.7168786 * r + 0.0606169 * n) / XI), o, s;
  return e === r && r === n ? o = s = i : (o = wk((0.4360747 * e + 0.3850649 * r + 0.1430804 * n) / KI), s = wk((0.0139322 * e + 0.0971045 * r + 0.7141733 * n) / QI)), new Wa(116 * i - 16, 500 * (o - i), 200 * (i - s), t.opacity);
}
function eB(t, e, r, n) {
  return arguments.length === 1 ? ZI(t) : new Wa(t, e, r, n ?? 1);
}
function Wa(t, e, r, n) {
  this.l = +t, this.a = +e, this.b = +r, this.opacity = +n;
}
y0(Wa, eB, yx(Hh, {
  brighter(t) {
    return new Wa(this.l + sb * (t ?? 1), this.a, this.b, this.opacity);
  },
  darker(t) {
    return new Wa(this.l - sb * (t ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var t = (this.l + 16) / 116, e = isNaN(this.a) ? t : t + this.a / 500, r = isNaN(this.b) ? t : t - this.b / 200;
    return e = KI * kk(e), t = XI * kk(t), r = QI * kk(r), new si(
      Ck(3.1338561 * e - 1.6168667 * t - 0.4906146 * r),
      Ck(-0.9787684 * e + 1.9161415 * t + 0.033454 * r),
      Ck(0.0719453 * e - 0.2289914 * t + 1.4052427 * r),
      this.opacity
    );
  }
}));
function wk(t) {
  return t > oge ? Math.pow(t, 1 / 3) : t / YI + JI;
}
function kk(t) {
  return t > od ? t * t * t : YI * (t - JI);
}
function Ck(t) {
  return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function _k(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function sge(t) {
  if (t instanceof jl) return new jl(t.h, t.c, t.l, t.opacity);
  if (t instanceof Wa || (t = ZI(t)), t.a === 0 && t.b === 0) return new jl(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var e = Math.atan2(t.b, t.a) * ige;
  return new jl(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function age(t, e, r, n) {
  return arguments.length === 1 ? sge(t) : new jl(t, e, r, n ?? 1);
}
function jl(t, e, r, n) {
  this.h = +t, this.c = +e, this.l = +r, this.opacity = +n;
}
function tB(t) {
  if (isNaN(t.h)) return new Wa(t.l, 0, 0, t.opacity);
  var e = t.h * nge;
  return new Wa(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
}
y0(jl, age, yx(Hh, {
  brighter(t) {
    return new jl(this.h, this.c, this.l + sb * (t ?? 1), this.opacity);
  },
  darker(t) {
    return new jl(this.h, this.c, this.l - sb * (t ?? 1), this.opacity);
  },
  rgb() {
    return tB(this).rgb();
  }
}));
function lge(t, e, r, n, i) {
  var o = t * t, s = o * t;
  return ((1 - 3 * t + 3 * o - s) * e + (4 - 6 * o + 3 * s) * r + (1 + 3 * t + 3 * o - 3 * s) * n + s * i) / 6;
}
function uge(t) {
  var e = t.length - 1;
  return function(r) {
    var n = r <= 0 ? r = 0 : r >= 1 ? (r = 1, e - 1) : Math.floor(r * e), i = t[n], o = t[n + 1], s = n > 0 ? t[n - 1] : 2 * i - o, a = n < e - 1 ? t[n + 2] : 2 * o - i;
    return lge((r - n / e) * e, s, i, o, a);
  };
}
const OS = (t) => () => t;
function cge(t, e) {
  return function(r) {
    return t + r * e;
  };
}
function hge(t, e, r) {
  return t = Math.pow(t, r), e = Math.pow(e, r) - t, r = 1 / r, function(n) {
    return Math.pow(t + n * e, r);
  };
}
function fge(t) {
  return (t = +t) == 1 ? rB : function(e, r) {
    return r - e ? hge(e, r, t) : OS(isNaN(e) ? r : e);
  };
}
function rB(t, e) {
  var r = e - t;
  return r ? cge(t, r) : OS(isNaN(t) ? e : t);
}
const T9 = (function t(e) {
  var r = fge(e);
  function n(i, o) {
    var s = r((i = Ng(i)).r, (o = Ng(o)).r), a = r(i.g, o.g), l = r(i.b, o.b), u = rB(i.opacity, o.opacity);
    return function(c) {
      return i.r = s(c), i.g = a(c), i.b = l(c), i.opacity = u(c), i + "";
    };
  }
  return n.gamma = t, n;
})(1);
function dge(t) {
  return function(e) {
    var r = e.length, n = new Array(r), i = new Array(r), o = new Array(r), s, a;
    for (s = 0; s < r; ++s)
      a = Ng(e[s]), n[s] = a.r || 0, i[s] = a.g || 0, o[s] = a.b || 0;
    return n = t(n), i = t(i), o = t(o), a.opacity = 1, function(l) {
      return a.r = n(l), a.g = i(l), a.b = o(l), a + "";
    };
  };
}
var pge = dge(uge);
function mge(t, e) {
  e || (e = []);
  var r = t ? Math.min(e.length, t.length) : 0, n = e.slice(), i;
  return function(o) {
    for (i = 0; i < r; ++i) n[i] = t[i] * (1 - o) + e[i] * o;
    return n;
  };
}
function gge(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function vge(t, e) {
  var r = e ? e.length : 0, n = t ? Math.min(r, t.length) : 0, i = new Array(n), o = new Array(r), s;
  for (s = 0; s < n; ++s) i[s] = FS(t[s], e[s]);
  for (; s < r; ++s) o[s] = e[s];
  return function(a) {
    for (s = 0; s < n; ++s) o[s] = i[s](a);
    return o;
  };
}
function yge(t, e) {
  var r = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(n) {
    return r.setTime(t * (1 - n) + e * n), r;
  };
}
function ab(t, e) {
  return t = +t, e = +e, function(r) {
    return t * (1 - r) + e * r;
  };
}
function bge(t, e) {
  var r = {}, n = {}, i;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (i in e)
    i in t ? r[i] = FS(t[i], e[i]) : n[i] = e[i];
  return function(o) {
    for (i in r) n[i] = r[i](o);
    return n;
  };
}
var QC = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Sk = new RegExp(QC.source, "g");
function xge(t) {
  return function() {
    return t;
  };
}
function wge(t) {
  return function(e) {
    return t(e) + "";
  };
}
function kge(t, e) {
  var r = QC.lastIndex = Sk.lastIndex = 0, n, i, o, s = -1, a = [], l = [];
  for (t = t + "", e = e + ""; (n = QC.exec(t)) && (i = Sk.exec(e)); )
    (o = i.index) > r && (o = e.slice(r, o), a[s] ? a[s] += o : a[++s] = o), (n = n[0]) === (i = i[0]) ? a[s] ? a[s] += i : a[++s] = i : (a[++s] = null, l.push({ i: s, x: ab(n, i) })), r = Sk.lastIndex;
  return r < e.length && (o = e.slice(r), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? l[0] ? wge(l[0].x) : xge(e) : (e = l.length, function(u) {
    for (var c = 0, h; c < e; ++c) a[(h = l[c]).i] = h.x(u);
    return a.join("");
  });
}
function FS(t, e) {
  var r = typeof e, n;
  return e == null || r === "boolean" ? OS(e) : (r === "number" ? ab : r === "string" ? (n = Rg(e)) ? (e = n, T9) : kge : e instanceof Rg ? T9 : e instanceof Date ? yge : gge(e) ? mge : Array.isArray(e) ? vge : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? bge : ab)(t, e);
}
function Cge(t, e) {
  return t = +t, e = +e, function(r) {
    return Math.round(t * (1 - r) + e * r);
  };
}
function _ge(t) {
  return function() {
    return t;
  };
}
function Sge(t) {
  return +t;
}
var M9 = [0, 1];
function Lf(t) {
  return t;
}
function JC(t, e) {
  return (e -= t = +t) ? function(r) {
    return (r - t) / e;
  } : _ge(isNaN(e) ? NaN : 0.5);
}
function Age(t, e) {
  var r;
  return t > e && (r = t, t = e, e = r), function(n) {
    return Math.max(t, Math.min(e, n));
  };
}
function Ege(t, e, r) {
  var n = t[0], i = t[1], o = e[0], s = e[1];
  return i < n ? (n = JC(i, n), o = r(s, o)) : (n = JC(n, i), o = r(o, s)), function(a) {
    return o(n(a));
  };
}
function Dge(t, e, r) {
  var n = Math.min(t.length, e.length) - 1, i = new Array(n), o = new Array(n), s = -1;
  for (t[n] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < n; )
    i[s] = JC(t[s], t[s + 1]), o[s] = r(e[s], e[s + 1]);
  return function(a) {
    var l = Ime(t, a, 1, n) - 1;
    return o[l](i[l](a));
  };
}
function TS(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function MS() {
  var t = M9, e = M9, r = FS, n, i, o, s = Lf, a, l, u;
  function c() {
    var d = Math.min(t.length, e.length);
    return s !== Lf && (s = Age(t[0], t[d - 1])), a = d > 2 ? Dge : Ege, l = u = null, h;
  }
  function h(d) {
    return d == null || isNaN(d = +d) ? o : (l || (l = a(t.map(n), e, r)))(n(s(d)));
  }
  return h.invert = function(d) {
    return s(i((u || (u = a(e, t.map(n), ab)))(d)));
  }, h.domain = function(d) {
    return arguments.length ? (t = Array.from(d, Sge), c()) : t.slice();
  }, h.range = function(d) {
    return arguments.length ? (e = Array.from(d), c()) : e.slice();
  }, h.rangeRound = function(d) {
    return e = Array.from(d), r = Cge, c();
  }, h.clamp = function(d) {
    return arguments.length ? (s = d ? !0 : Lf, c()) : s !== Lf;
  }, h.interpolate = function(d) {
    return arguments.length ? (r = d, c()) : r;
  }, h.unknown = function(d) {
    return arguments.length ? (o = d, h) : o;
  }, function(d, p) {
    return n = d, i = p, c();
  };
}
function Oge() {
  return MS()(Lf, Lf);
}
function Fge(t, e, r, n) {
  var i = Hme(t, e, r), o;
  switch (n = Tg(n ?? ",f"), n.type) {
    case "s": {
      var s = Math.max(Math.abs(t), Math.abs(e));
      return n.precision == null && !isNaN(o = Tme(i, s)) && (n.precision = o), qI(n, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(o = Mme(i, Math.max(Math.abs(t), Math.abs(e)))) && (n.precision = o - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(o = Fme(i)) && (n.precision = o - (n.type === "%") * 2);
      break;
    }
  }
  return su(n);
}
function nB(t) {
  var e = t.domain;
  return t.ticks = function(r) {
    var n = e();
    return KC(n[0], n[n.length - 1], r ?? 10);
  }, t.tickFormat = function(r, n) {
    var i = e();
    return Fge(i[0], i[i.length - 1], r ?? 10, n);
  }, t.nice = function(r) {
    r == null && (r = 10);
    var n = e(), i = 0, o = n.length - 1, s = n[i], a = n[o], l, u, c = 10;
    for (a < s && (u = s, s = a, a = u, u = i, i = o, o = u); c-- > 0; ) {
      if (u = XC(s, a, r), u === l)
        return n[i] = s, n[o] = a, e(n);
      if (u > 0)
        s = Math.floor(s / u) * u, a = Math.ceil(a / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, a = Math.floor(a * u) / u;
      else
        break;
      l = u;
    }
    return t;
  }, t;
}
function hp() {
  var t = Oge();
  return t.copy = function() {
    return TS(t, hp());
  }, v0.apply(t, arguments), nB(t);
}
function Tge(t, e) {
  t = t.slice();
  var r = 0, n = t.length - 1, i = t[r], o = t[n], s;
  return o < i && (s = r, r = n, n = s, s = i, i = o, o = s), t[r] = e.floor(i), t[n] = e.ceil(o), t;
}
function P9(t) {
  return Math.log(t);
}
function R9(t) {
  return Math.exp(t);
}
function Mge(t) {
  return -Math.log(-t);
}
function Pge(t) {
  return -Math.exp(-t);
}
function Rge(t) {
  return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t;
}
function Nge(t) {
  return t === 10 ? Rge : t === Math.E ? Math.exp : (e) => Math.pow(t, e);
}
function $ge(t) {
  return t === Math.E ? Math.log : t === 10 && Math.log10 || t === 2 && Math.log2 || (t = Math.log(t), (e) => Math.log(e) / t);
}
function N9(t) {
  return (e, r) => -t(-e, r);
}
function Ige(t) {
  const e = t(P9, R9), r = e.domain;
  let n = 10, i, o;
  function s() {
    return i = $ge(n), o = Nge(n), r()[0] < 0 ? (i = N9(i), o = N9(o), t(Mge, Pge)) : t(P9, R9), e;
  }
  return e.base = function(a) {
    return arguments.length ? (n = +a, s()) : n;
  }, e.domain = function(a) {
    return arguments.length ? (r(a), s()) : r();
  }, e.ticks = (a) => {
    const l = r();
    let u = l[0], c = l[l.length - 1];
    const h = c < u;
    h && ([u, c] = [c, u]);
    let d = i(u), p = i(c), g, v;
    const y = a == null ? 10 : +a;
    let b = [];
    if (!(n % 1) && p - d < y) {
      if (d = Math.floor(d), p = Math.ceil(p), u > 0) {
        for (; d <= p; ++d)
          for (g = 1; g < n; ++g)
            if (v = d < 0 ? g / o(-d) : g * o(d), !(v < u)) {
              if (v > c) break;
              b.push(v);
            }
      } else for (; d <= p; ++d)
        for (g = n - 1; g >= 1; --g)
          if (v = d > 0 ? g / o(-d) : g * o(d), !(v < u)) {
            if (v > c) break;
            b.push(v);
          }
      b.length * 2 < y && (b = KC(u, c, y));
    } else
      b = KC(d, p, Math.min(p - d, y)).map(o);
    return h ? b.reverse() : b;
  }, e.tickFormat = (a, l) => {
    if (a == null && (a = 10), l == null && (l = n === 10 ? "s" : ","), typeof l != "function" && (!(n % 1) && (l = Tg(l)).precision == null && (l.trim = !0), l = su(l)), a === 1 / 0) return l;
    const u = Math.max(1, n * a / e.ticks().length);
    return (c) => {
      let h = c / o(Math.round(i(c)));
      return h * n < n - 0.5 && (h *= n), h <= u ? l(c) : "";
    };
  }, e.nice = () => r(Tge(r(), {
    floor: (a) => o(Math.floor(i(a))),
    ceil: (a) => o(Math.ceil(i(a)))
  })), e;
}
function $g() {
  const t = Ige(MS()).domain([1, 10]);
  return t.copy = () => TS(t, $g()).base(t.base()), v0.apply(t, arguments), t;
}
function $9(t) {
  return function(e) {
    return Math.sign(e) * Math.log1p(Math.abs(e / t));
  };
}
function I9(t) {
  return function(e) {
    return Math.sign(e) * Math.expm1(Math.abs(e)) * t;
  };
}
function Bge(t) {
  var e = 1, r = t($9(e), I9(e));
  return r.constant = function(n) {
    return arguments.length ? t($9(e = +n), I9(e)) : e;
  }, nB(r);
}
function iB() {
  var t = Bge(MS());
  return t.copy = function() {
    return TS(t, iB()).constant(t.constant());
  }, v0.apply(t, arguments);
}
function fp(t) {
  for (var e = t.length / 6 | 0, r = new Array(e), n = 0; n < e; ) r[n] = "#" + t.slice(n * 6, ++n * 6);
  return r;
}
const oB = (t) => pge(t[t.length - 1]);
var Lge = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(fp);
const zge = oB(Lge);
var jge = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(fp);
const qge = oB(jge);
function Uge(t) {
  return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}
function bx(t) {
  var e = t.length;
  return function(r) {
    return t[Math.max(0, Math.min(e - 1, Math.floor(r * e)))];
  };
}
bx(fp("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
bx(fp("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var sB = bx(fp("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
bx(fp("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
var Is = { slate: { 300: "oklch(86.9% 0.022 252.894)", 400: "oklch(70.4% 0.04 256.788)", 500: "oklch(55.4% 0.046 257.417)", 700: "oklch(37.2% 0.044 257.287)" }, gray: { 500: "oklch(55.1% 0.027 264.364)" } };
function aB() {
  return !(navigator.gpu == null || navigator.gpu.requestAdapter == null);
}
function Hge(t) {
  return t == 0 && (t = 4), t % 4 != 0 && (t += 4 - t % 4), t;
}
function sd(t, e, r, n) {
  return (t.buffer == null || t.byteSize != r || t.usage != n) && (t.buffer != null && t.buffer.destroy(), t.buffer = e.createBuffer({ size: Hge(r), usage: n }), t.byteSize = r, t.destroy = () => {
    t.buffer?.destroy();
  }), t.buffer;
}
function Ak(t, e, r, n) {
  if (t.buffer !== r || t.data !== n) {
    if (n != null)
      if (n.byteLength % 4 != 0) {
        let i = n.byteLength - n.byteLength % 4;
        if (e.queue.writeBuffer(r, 0, n, 0, i), n instanceof Uint8Array) {
          let o = new Uint8Array(4);
          for (let s = 0; s < 4; s++)
            i + s < n.length && (o[s] = n[i + s]);
          e.queue.writeBuffer(r, i, o);
        }
      } else
        e.queue.writeBuffer(r, 0, n, 0);
    else
      e.queue.writeBuffer(r, 0, new ArrayBuffer(r.size));
    t.buffer = r, t.data = n;
  }
  return r;
}
function B9(t, e, r, n, i, o) {
  return (t.texture == null || t.width != r || t.height != n || t.format != i || t.usage != o) && (t.texture != null && t.texture.destroy(), t.texture = e.createTexture({ size: [r, n], format: i, usage: o }), t.destroy = () => {
    t.texture?.destroy();
  }), t.texture;
}
const yi = 2, xx = 4, wx = 8, au = 16, lu = 32, Vh = 64, kx = 128, Zs = 512, ai = 1024, fo = 2048, uu = 4096, Vo = 8192, Xu = 16384, Cx = 32768, Nd = 65536, L9 = 1 << 17, lB = 1 << 18, dp = 1 << 19, uB = 1 << 20, Ig = 32768, YC = 1 << 21, PS = 1 << 22, Qu = 1 << 23, uh = Symbol("$state"), cB = Symbol("legacy props"), Vge = Symbol(""), zf = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), RS = 3, pp = 8, Wge = !1;
var hB = Array.isArray, Gge = Array.prototype.indexOf, NS = Array.from, fB = Object.defineProperty, ad = Object.getOwnPropertyDescriptor, dB = Object.getOwnPropertyDescriptors, Kge = Object.prototype, Xge = Array.prototype, $S = Object.getPrototypeOf, z9 = Object.isExtensible;
function Qge(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function pB() {
  var t, e, r = new Promise((n, i) => {
    t = n, e = i;
  });
  return { promise: r, resolve: t, reject: e };
}
function mB(t) {
  return t === this.v;
}
function gB(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function vB(t) {
  return !gB(t, this.v);
}
function yB(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function Jge() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function Yge(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Zge() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function e0e(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function t0e() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function r0e() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function n0e(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function i0e() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function o0e() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function s0e() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function a0e() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let l0e = !1;
const IS = 1, BS = 2, bB = 4, u0e = 8, c0e = 16, h0e = 1, f0e = 4, d0e = 8, p0e = 16, m0e = 1, g0e = 2, xB = "[", _x = "[!", LS = "]", $d = {}, ei = Symbol(), v0e = "http://www.w3.org/1999/xhtml";
let po = null;
function Id(t) {
  po = t;
}
function Wh(t, e = !1, r) {
  po = {
    p: po,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: null
  };
}
function Gh(t) {
  var e = (
    /** @type {ComponentContext} */
    po
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      KB(n);
  }
  return e.i = !0, po = e.p, /** @type {T} */
  {};
}
function wB() {
  return !0;
}
let Yc = [];
function kB() {
  var t = Yc;
  Yc = [], Qge(t);
}
function mp(t) {
  if (Yc.length === 0 && !Bm) {
    var e = Yc;
    queueMicrotask(() => {
      e === Yc && kB();
    });
  }
  Yc.push(t);
}
function y0e() {
  for (; Yc.length > 0; )
    kB();
}
function Sx(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function b0e() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let sr = !1;
function ql(t) {
  sr = t;
}
let tr;
function so(t) {
  if (t === null)
    throw Sx(), $d;
  return tr = t;
}
function b0() {
  return so(
    /** @type {TemplateNode} */
    /* @__PURE__ */ cl(tr)
  );
}
function bn(t) {
  if (sr) {
    if (/* @__PURE__ */ cl(tr) !== null)
      throw Sx(), $d;
    tr = t;
  }
}
function CB(t = 1) {
  if (sr) {
    for (var e = t, r = tr; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ cl(r);
    tr = r;
  }
}
function lb(t = !0) {
  for (var e = 0, r = tr; ; ) {
    if (r.nodeType === pp) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === LS) {
        if (e === 0) return r;
        e -= 1;
      } else (n === xB || n === _x) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ cl(r)
    );
    t && r.remove(), r = i;
  }
}
function _B(t) {
  if (!t || t.nodeType !== pp)
    throw Sx(), $d;
  return (
    /** @type {Comment} */
    t.data
  );
}
function Zc(t) {
  if (typeof t != "object" || t === null || uh in t)
    return t;
  const e = $S(t);
  if (e !== Kge && e !== Xge)
    return t;
  var r = /* @__PURE__ */ new Map(), n = hB(t), i = /* @__PURE__ */ Rr(0), o = hh, s = (a) => {
    if (hh === o)
      return a();
    var l = Zt, u = hh;
    no(null), V9(o);
    var c = a();
    return no(l), V9(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ Rr(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && i0e();
        var c = r.get(l);
        return c === void 0 ? c = s(() => {
          var h = /* @__PURE__ */ Rr(u.value);
          return r.set(l, h), h;
        }) : ht(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = s(() => /* @__PURE__ */ Rr(ei));
            r.set(l, c), Lm(i);
          }
        } else
          ht(u, ei), Lm(i);
        return !0;
      },
      get(a, l, u) {
        if (l === uh)
          return t;
        var c = r.get(l), h = l in a;
        if (c === void 0 && (!h || ad(a, l)?.writable) && (c = s(() => {
          var p = Zc(h ? a[l] : ei), g = /* @__PURE__ */ Rr(p);
          return g;
        }), r.set(l, c)), c !== void 0) {
          var d = W(c);
          return d === ei ? void 0 : d;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = W(c));
        } else if (u === void 0) {
          var h = r.get(l), d = h?.v;
          if (h !== void 0 && d !== ei)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === uh)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== ei || Reflect.has(a, l);
        if (u !== void 0 || ar !== null && (!c || ad(a, l)?.writable)) {
          u === void 0 && (u = s(() => {
            var d = c ? Zc(a[l]) : ei, p = /* @__PURE__ */ Rr(d);
            return p;
          }), r.set(l, u));
          var h = W(u);
          if (h === ei)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var h = r.get(l), d = l in a;
        if (n && l === "length")
          for (var p = u; p < /** @type {Source<number>} */
          h.v; p += 1) {
            var g = r.get(p + "");
            g !== void 0 ? ht(g, ei) : p in a && (g = s(() => /* @__PURE__ */ Rr(ei)), r.set(p + "", g));
          }
        if (h === void 0)
          (!d || ad(a, l)?.writable) && (h = s(() => /* @__PURE__ */ Rr(void 0)), ht(h, Zc(u)), r.set(l, h));
        else {
          d = h.v !== ei;
          var v = s(() => Zc(u));
          ht(h, v);
        }
        var y = Reflect.getOwnPropertyDescriptor(a, l);
        if (y?.set && y.set.call(c, u), !d) {
          if (n && typeof l == "string") {
            var b = (
              /** @type {Source<number>} */
              r.get("length")
            ), k = Number(l);
            Number.isInteger(k) && k >= b.v && ht(b, k + 1);
          }
          Lm(i);
        }
        return !0;
      },
      ownKeys(a) {
        W(i);
        var l = Reflect.ownKeys(a).filter((h) => {
          var d = r.get(h);
          return d === void 0 || d.v !== ei;
        });
        for (var [u, c] of r)
          c.v !== ei && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        o0e();
      }
    }
  );
}
var j9, SB, AB, EB;
function ZC() {
  if (j9 === void 0) {
    j9 = window, SB = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    AB = ad(e, "firstChild").get, EB = ad(e, "nextSibling").get, z9(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), z9(r) && (r.__t = void 0);
  }
}
function Za(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Zl(t) {
  return AB.call(t);
}
// @__NO_SIDE_EFFECTS__
function cl(t) {
  return EB.call(t);
}
function In(t, e) {
  if (!sr)
    return /* @__PURE__ */ Zl(t);
  var r = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ Zl(tr)
  );
  if (r === null)
    r = tr.appendChild(Za());
  else if (e && r.nodeType !== RS) {
    var n = Za();
    return r?.before(n), so(n), n;
  }
  return so(r), r;
}
function Of(t, e = !1) {
  if (!sr) {
    var r = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Zl(
        /** @type {Node} */
        t
      )
    );
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ cl(r) : r;
  }
  if (e && tr?.nodeType !== RS) {
    var n = Za();
    return tr?.before(n), so(n), n;
  }
  return tr;
}
function Vr(t, e = 1, r = !1) {
  let n = sr ? tr : t;
  for (var i; e--; )
    i = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ cl(n);
  if (!sr)
    return n;
  if (r && n?.nodeType !== RS) {
    var o = Za();
    return n === null ? i?.after(o) : n.before(o), so(o), o;
  }
  return so(n), /** @type {TemplateNode} */
  n;
}
function DB(t) {
  t.textContent = "";
}
function OB(t) {
  var e = ar;
  if (e === null)
    return Zt.f |= Qu, t;
  if ((e.f & Cx) === 0) {
    if ((e.f & kx) === 0)
      throw t;
    e.b.error(t);
  } else
    Bd(t, e);
}
function Bd(t, e) {
  for (; e !== null; ) {
    if ((e.f & kx) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const my = /* @__PURE__ */ new Set();
let Sn = null, Bo = null, Fa = [], Ax = null, e_ = !1, Bm = !1, eh = class t_ {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #l = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #a = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Fa = [], this.apply();
    var r = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const n of e)
      this.#o(n, r);
    this.is_fork || this.#u(), this.#n > 0 || this.is_fork ? (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects)) : (Sn = null, q9(r.render_effects), q9(r.effects), this.#l?.resolve()), Bo = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(e, r) {
    e.f ^= ai;
    for (var n = e.first; n !== null; ) {
      var i = n.f, o = (i & (lu | Vh)) !== 0, s = o && (i & ai) !== 0, a = s || (i & Vo) !== 0 || this.skipped_effects.has(n);
      if ((n.f & kx) !== 0 && n.b?.is_pending() && (r = {
        parent: r,
        effect: n,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !a && n.fn !== null) {
        o ? n.f ^= ai : (i & xx) !== 0 ? r.effects.push(n) : x0(n) && ((n.f & au) !== 0 && r.block_effects.push(n), Lg(n));
        var l = n.first;
        if (l !== null) {
          n = l;
          continue;
        }
      }
      var u = n.parent;
      for (n = n.next; n === null && u !== null; )
        u === r.effect && (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects), r = /** @type {EffectTarget} */
        r.parent), n = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #s(e) {
    for (const r of e)
      ((r.f & fo) !== 0 ? this.#a : this.#i).push(r), di(r, ai);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    this.previous.has(e) || this.previous.set(e, r), (e.f & Qu) === 0 && (this.current.set(e, e.v), Bo?.set(e, e.v));
  }
  activate() {
    Sn = this, this.apply();
  }
  deactivate() {
    Sn = null, Bo = null;
  }
  flush() {
    if (this.activate(), Fa.length > 0) {
      if (FB(), Sn !== null && Sn !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#n === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#r === 0 && this.#c();
  }
  #c() {
    if (my.size > 1) {
      this.previous.clear();
      var e = Bo, r = !0, n = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of my) {
        if (i === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (i.current.has(a))
            if (r && l !== i.current.get(a))
              i.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const s = [...i.current.keys()].filter((a) => !this.current.has(a));
        if (s.length > 0) {
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            TB(u, s, a, l);
          if (Fa.length > 0) {
            Sn = i, i.apply();
            for (const u of Fa)
              i.#o(u, n);
            Fa = [], i.deactivate();
          }
        }
      }
      Sn = null, Bo = e;
    }
    this.committed = !0, my.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), this.revive();
  }
  revive() {
    for (const e of this.#a)
      di(e, fo), Ah(e);
    for (const e of this.#i)
      di(e, uu), Ah(e);
    this.#a = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#l ??= pB()).promise;
  }
  static ensure() {
    if (Sn === null) {
      const e = Sn = new t_();
      my.add(Sn), Bm || t_.enqueue(() => {
        Sn === e && e.flush();
      });
    }
    return Sn;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    mp(e);
  }
  apply() {
  }
};
function x0e(t) {
  var e = Bm;
  Bm = !0;
  try {
    for (var r; ; ) {
      if (y0e(), Fa.length === 0 && (Sn?.flush(), Fa.length === 0))
        return Ax = null, /** @type {T} */
        r;
      FB();
    }
  } finally {
    Bm = e;
  }
}
function FB() {
  var t = ch;
  e_ = !0;
  try {
    var e = 0;
    for (U9(!0); Fa.length > 0; ) {
      var r = eh.ensure();
      if (e++ > 1e3) {
        var n, i;
        w0e();
      }
      r.process(Fa), Ju.clear();
    }
  } finally {
    e_ = !1, U9(t), Ax = null;
  }
}
function w0e() {
  try {
    t0e();
  } catch (t) {
    Bd(t, Ax);
  }
}
let Tl = null;
function q9(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (Xu | Vo)) === 0 && x0(n) && (Tl = /* @__PURE__ */ new Set(), Lg(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null && n.ac === null ? YB(n) : n.fn = null), Tl?.size > 0)) {
        Ju.clear();
        for (const i of Tl) {
          if ((i.f & (Xu | Vo)) !== 0) continue;
          const o = [i];
          let s = i.parent;
          for (; s !== null; )
            Tl.has(s) && (Tl.delete(s), o.push(s)), s = s.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (Xu | Vo)) === 0 && Lg(l);
          }
        }
        Tl.clear();
      }
    }
    Tl = null;
  }
}
function TB(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const o = i.f;
      (o & yi) !== 0 ? TB(
        /** @type {Derived} */
        i,
        e,
        r,
        n
      ) : (o & (PS | au)) !== 0 && (o & fo) === 0 && // we may have scheduled this one already
      MB(i, e, n) && (di(i, fo), Ah(
        /** @type {Effect} */
        i
      ));
    }
}
function MB(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & yi) !== 0 && MB(
        /** @type {Derived} */
        i,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function Ah(t) {
  for (var e = Ax = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (e_ && e === ar && (r & au) !== 0 && (r & lB) === 0)
      return;
    if ((r & (Vh | lu)) !== 0) {
      if ((r & ai) === 0) return;
      e.f ^= ai;
    }
  }
  Fa.push(e);
}
function k0e(t) {
  let e = 0, r = Eh(0), n;
  return () => {
    Dx() && (W(r), qS(() => (e === 0 && (n = Xh(() => t(() => Lm(r)))), e += 1, () => {
      mp(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Lm(r));
      });
    })));
  };
}
var C0e = Nd | dp | kx;
function _0e(t, e, r) {
  new S0e(t, e, r);
}
class S0e {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #r = sr ? tr : null;
  /** @type {BoundaryProps} */
  #n;
  /** @type {((anchor: Node) => void)} */
  #l;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #h = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #f = null;
  #v = k0e(() => (this.#f = Eh(this.#d), () => {
    this.#f = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#t = e, this.#n = r, this.#l = n, this.parent = /** @type {Effect} */
    ar.b, this.#e = !!this.#n.pending, this.#a = Ox(() => {
      if (ar.b = this, sr) {
        const o = this.#r;
        b0(), /** @type {Comment} */
        o.nodeType === pp && /** @type {Comment} */
        o.data === _x ? this.#b() : this.#y();
      } else {
        var i = this.#x();
        try {
          this.#i = Bs(() => n(i));
        } catch (o) {
          this.error(o);
        }
        this.#h > 0 ? this.#g() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, C0e), sr && (this.#t = tr);
  }
  #y() {
    try {
      this.#i = Bs(() => this.#l(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #b() {
    const e = this.#n.pending;
    e && (this.#o = Bs(() => e(this.#t)), eh.enqueue(() => {
      var r = this.#x();
      this.#i = this.#m(() => (eh.ensure(), Bs(() => this.#l(r)))), this.#h > 0 ? this.#g() : (ld(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = Za(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#n.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(e) {
    var r = ar, n = Zt, i = po;
    el(this.#a), no(this.#a), Id(this.#a.ctx);
    try {
      return e();
    } catch (o) {
      return OB(o), null;
    } finally {
      el(r), no(n), Id(i);
    }
  }
  #g() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#n.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), tL(this.#i, this.#u)), this.#o === null && (this.#o = Bs(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#h += e, this.#h === 0 && (this.#e = !1, this.#o && ld(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#f && Ld(this.#f, this.#d);
  }
  get_effect_pending() {
    return this.#v(), W(
      /** @type {Source<number>} */
      this.#f
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#n.onerror;
    let n = this.#n.failed;
    if (this.#p || !r && !n)
      throw e;
    this.#i && (Bi(this.#i), this.#i = null), this.#o && (Bi(this.#o), this.#o = null), this.#s && (Bi(this.#s), this.#s = null), sr && (so(
      /** @type {TemplateNode} */
      this.#r
    ), CB(), so(lb()));
    var i = !1, o = !1;
    const s = () => {
      if (i) {
        b0e();
        return;
      }
      i = !0, o && a0e(), eh.ensure(), this.#d = 0, this.#s !== null && ld(this.#s, () => {
        this.#s = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#m(() => (this.#p = !1, Bs(() => this.#l(this.#t)))), this.#h > 0 ? this.#g() : this.#e = !1;
    };
    var a = Zt;
    try {
      no(null), o = !0, r?.(e, s), o = !1;
    } catch (l) {
      Bd(l, this.#a && this.#a.parent);
    } finally {
      no(a);
    }
    n && mp(() => {
      this.#s = this.#m(() => {
        eh.ensure(), this.#p = !0;
        try {
          return Bs(() => {
            n(
              this.#t,
              () => e,
              () => s
            );
          });
        } catch (l) {
          return Bd(
            l,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function A0e(t, e, r, n) {
  const i = Ex;
  if (r.length === 0 && t.length === 0) {
    n(e.map(i));
    return;
  }
  var o = Sn, s = (
    /** @type {Effect} */
    ar
  ), a = E0e();
  function l() {
    Promise.all(r.map((u) => /* @__PURE__ */ D0e(u))).then((u) => {
      a();
      try {
        n([...e.map(i), ...u]);
      } catch (c) {
        (s.f & Xu) === 0 && Bd(c, s);
      }
      o?.deactivate(), ub();
    }).catch((u) => {
      Bd(u, s);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    a();
    try {
      return l();
    } finally {
      o?.deactivate(), ub();
    }
  }) : l();
}
function E0e() {
  var t = ar, e = Zt, r = po, n = Sn;
  return function(i = !0) {
    el(t), no(e), Id(r), i && n?.activate();
  };
}
function ub() {
  el(null), no(null), Id(null);
}
// @__NO_SIDE_EFFECTS__
function Ex(t) {
  var e = yi | fo, r = Zt !== null && (Zt.f & yi) !== 0 ? (
    /** @type {Derived} */
    Zt
  ) : null;
  return ar !== null && (ar.f |= dp), {
    ctx: po,
    deps: null,
    effects: null,
    equals: mB,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      ei
    ),
    wv: 0,
    parent: r ?? ar,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function D0e(t, e) {
  let r = (
    /** @type {Effect | null} */
    ar
  );
  r === null && Jge();
  var n = (
    /** @type {Boundary} */
    r.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), o = Eh(
    /** @type {V} */
    ei
  ), s = !Zt, a = /* @__PURE__ */ new Map();
  return I0e(() => {
    var l = pB();
    i = l.promise;
    try {
      Promise.resolve(t()).then(l.resolve, l.reject).then(() => {
        u === Sn && u.committed && u.deactivate(), ub();
      });
    } catch (d) {
      l.reject(d), ub();
    }
    var u = (
      /** @type {Batch} */
      Sn
    );
    if (s) {
      var c = !n.is_pending();
      n.update_pending_count(1), u.increment(c), a.get(u)?.reject(zf), a.delete(u), a.set(u, l);
    }
    const h = (d, p = void 0) => {
      if (u.activate(), p)
        p !== zf && (o.f |= Qu, Ld(o, p));
      else {
        (o.f & Qu) !== 0 && (o.f ^= Qu), Ld(o, d);
        for (const [g, v] of a) {
          if (a.delete(g), g === u) break;
          v.reject(zf);
        }
      }
      s && (n.update_pending_count(-1), u.decrement(c));
    };
    l.promise.then(h, (d) => h(null, d || "unknown"));
  }), GB(() => {
    for (const l of a.values())
      l.reject(zf);
  }), new Promise((l) => {
    function u(c) {
      function h() {
        c === i ? l(o) : u(i);
      }
      c.then(h, h);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function mt(t) {
  const e = /* @__PURE__ */ Ex(t);
  return LB(e), e;
}
// @__NO_SIDE_EFFECTS__
function PB(t) {
  const e = /* @__PURE__ */ Ex(t);
  return e.equals = vB, e;
}
function RB(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Bi(
        /** @type {Effect} */
        e[r]
      );
  }
}
function O0e(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & yi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function zS(t) {
  var e, r = ar;
  el(O0e(t));
  try {
    t.f &= ~Ig, RB(t), e = UB(t);
  } finally {
    el(r);
  }
  return e;
}
function NB(t) {
  var e = zS(t);
  if (t.equals(e) || (t.v = e, t.wv = jB()), !Kh)
    if (Bo !== null)
      Dx() && Bo.set(t, t.v);
    else {
      var r = (t.f & Zs) === 0 ? uu : ai;
      di(t, r);
    }
}
let r_ = /* @__PURE__ */ new Set();
const Ju = /* @__PURE__ */ new Map();
let $B = !1;
function Eh(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: mB,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function Rr(t, e) {
  const r = Eh(t);
  return LB(r), r;
}
// @__NO_SIDE_EFFECTS__
function IB(t, e = !1, r = !0) {
  const n = Eh(t);
  return e || (n.equals = vB), n;
}
function ht(t, e, r = !1) {
  Zt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!La || (Zt.f & L9) !== 0) && wB() && (Zt.f & (yi | au | PS | L9)) !== 0 && !Kl?.includes(t) && s0e();
  let n = r ? Zc(e) : e;
  return Ld(t, n);
}
function Ld(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Kh ? Ju.set(t, e) : Ju.set(t, r), t.v = e;
    var n = eh.ensure();
    n.capture(t, r), (t.f & yi) !== 0 && ((t.f & fo) !== 0 && zS(
      /** @type {Derived} */
      t
    ), di(t, (t.f & Zs) !== 0 ? ai : uu)), t.wv = jB(), BB(t, fo), ar !== null && (ar.f & ai) !== 0 && (ar.f & (lu | Vh)) === 0 && (cs === null ? T0e([t]) : cs.push(t)), !n.is_fork && r_.size > 0 && !$B && F0e();
  }
  return e;
}
function F0e() {
  $B = !1;
  const t = Array.from(r_);
  for (const e of t)
    (e.f & ai) !== 0 && di(e, uu), x0(e) && Lg(e);
  r_.clear();
}
function Lm(t) {
  ht(t, t.v + 1);
}
function BB(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = r.length, i = 0; i < n; i++) {
      var o = r[i], s = o.f, a = (s & fo) === 0;
      if (a && di(o, e), (s & yi) !== 0) {
        var l = (
          /** @type {Derived} */
          o
        );
        Bo?.delete(l), (s & Ig) === 0 && (s & Zs && (o.f |= Ig), BB(l, uu));
      } else a && ((s & au) !== 0 && Tl !== null && Tl.add(
        /** @type {Effect} */
        o
      ), Ah(
        /** @type {Effect} */
        o
      ));
    }
}
function jS(t) {
  var e = Zt, r = ar;
  no(null), el(null);
  try {
    return t();
  } finally {
    no(e), el(r);
  }
}
let ch = !1;
function U9(t) {
  ch = t;
}
let Kh = !1;
function H9(t) {
  Kh = t;
}
let Zt = null, La = !1;
function no(t) {
  Zt = t;
}
let ar = null;
function el(t) {
  ar = t;
}
let Kl = null;
function LB(t) {
  Zt !== null && (Kl === null ? Kl = [t] : Kl.push(t));
}
let Di = null, Fo = 0, cs = null;
function T0e(t) {
  cs = t;
}
let zB = 1, Bg = 0, hh = Bg;
function V9(t) {
  hh = t;
}
function jB() {
  return ++zB;
}
function x0(t) {
  var e = t.f;
  if ((e & fo) !== 0)
    return !0;
  if (e & yi && (t.f &= ~Ig), (e & uu) !== 0) {
    var r = t.deps;
    if (r !== null)
      for (var n = r.length, i = 0; i < n; i++) {
        var o = r[i];
        if (x0(
          /** @type {Derived} */
          o
        ) && NB(
          /** @type {Derived} */
          o
        ), o.wv > t.wv)
          return !0;
      }
    (e & Zs) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Bo === null && di(t, ai);
  }
  return !1;
}
function qB(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !Kl?.includes(t))
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      (o.f & yi) !== 0 ? qB(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? di(o, fo) : (o.f & ai) !== 0 && di(o, uu), Ah(
        /** @type {Effect} */
        o
      ));
    }
}
function UB(t) {
  var e = Di, r = Fo, n = cs, i = Zt, o = Kl, s = po, a = La, l = hh, u = t.f;
  Di = /** @type {null | Value[]} */
  null, Fo = 0, cs = null, Zt = (u & (lu | Vh)) === 0 ? t : null, Kl = null, Id(t.ctx), La = !1, hh = ++Bg, t.ac !== null && (jS(() => {
    t.ac.abort(zf);
  }), t.ac = null);
  try {
    t.f |= YC;
    var c = (
      /** @type {Function} */
      t.fn
    ), h = c(), d = t.deps;
    if (Di !== null) {
      var p;
      if (cb(t, Fo), d !== null && Fo > 0)
        for (d.length = Fo + Di.length, p = 0; p < Di.length; p++)
          d[Fo + p] = Di[p];
      else
        t.deps = d = Di;
      if (ch && Dx() && (t.f & Zs) !== 0)
        for (p = Fo; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Fo < d.length && (cb(t, Fo), d.length = Fo);
    if (wB() && cs !== null && !La && d !== null && (t.f & (yi | uu | fo)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      cs.length; p++)
        qB(
          cs[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (Bg++, cs !== null && (n === null ? n = cs : n.push(.../** @type {Source[]} */
    cs))), (t.f & Qu) !== 0 && (t.f ^= Qu), h;
  } catch (g) {
    return OB(g);
  } finally {
    t.f ^= YC, Di = e, Fo = r, cs = n, Zt = i, Kl = o, Id(s), La = a, hh = l;
  }
}
function M0e(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = Gge.call(r, t);
    if (n !== -1) {
      var i = r.length - 1;
      i === 0 ? r = e.reactions = null : (r[n] = r[i], r.pop());
    }
  }
  r === null && (e.f & yi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Di === null || !Di.includes(e)) && (di(e, uu), (e.f & Zs) !== 0 && (e.f ^= Zs, e.f &= ~Ig), RB(
    /** @type {Derived} **/
    e
  ), cb(
    /** @type {Derived} **/
    e,
    0
  ));
}
function cb(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      M0e(t, r[n]);
}
function Lg(t) {
  var e = t.f;
  if ((e & Xu) === 0) {
    di(t, ai);
    var r = ar, n = ch;
    ar = t, ch = !0;
    try {
      (e & au) !== 0 ? B0e(t) : JB(t), QB(t);
      var i = UB(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = zB;
      var o;
      Wge && l0e && (t.f & fo) !== 0 && t.deps;
    } finally {
      ch = n, ar = r;
    }
  }
}
function W(t) {
  var e = t.f, r = (e & yi) !== 0;
  if (Zt !== null && !La) {
    var n = ar !== null && (ar.f & Xu) !== 0;
    if (!n && !Kl?.includes(t)) {
      var i = Zt.deps;
      if ((Zt.f & YC) !== 0)
        t.rv < Bg && (t.rv = Bg, Di === null && i !== null && i[Fo] === t ? Fo++ : Di === null ? Di = [t] : Di.includes(t) || Di.push(t));
      else {
        (Zt.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Zt] : o.includes(Zt) || o.push(Zt);
      }
    }
  }
  if (Kh) {
    if (Ju.has(t))
      return Ju.get(t);
    if (r) {
      var s = (
        /** @type {Derived} */
        t
      ), a = s.v;
      return ((s.f & ai) === 0 && s.reactions !== null || VB(s)) && (a = zS(s)), Ju.set(s, a), a;
    }
  } else if (r) {
    if (s = /** @type {Derived} */
    t, Bo?.has(s))
      return Bo.get(s);
    x0(s) && NB(s), ch && Dx() && (s.f & Zs) === 0 && HB(s);
  } else if (Bo?.has(t))
    return Bo.get(t);
  if ((t.f & Qu) !== 0)
    throw t.v;
  return t.v;
}
function HB(t) {
  if (t.deps !== null) {
    t.f ^= Zs;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & yi) !== 0 && (e.f & Zs) === 0 && HB(
        /** @type {Derived} */
        e
      );
  }
}
function VB(t) {
  if (t.v === ei) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Ju.has(e) || (e.f & yi) !== 0 && VB(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function Xh(t) {
  var e = La;
  try {
    return La = !0, t();
  } finally {
    La = e;
  }
}
const P0e = -7169;
function di(t, e) {
  t.f = t.f & P0e | e;
}
function R0e(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (uh in t)
      n_(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && uh in r && n_(r);
      }
  }
}
function n_(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        n_(t[n], e);
      } catch {
      }
    const r = $S(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = dB(r);
      for (let i in n) {
        const o = n[i].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
function WB(t) {
  ar === null && (Zt === null && e0e(), Zge()), Kh && Yge();
}
function N0e(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function hl(t, e, r, n = !0) {
  var i = ar;
  i !== null && (i.f & Vo) !== 0 && (t |= Vo);
  var o = {
    ctx: po,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | fo | Zs,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      Lg(o), o.f |= Cx;
    } catch (l) {
      throw Bi(o), l;
    }
  else e !== null && Ah(o);
  if (n) {
    var s = o;
    if (r && s.deps === null && s.teardown === null && s.nodes_start === null && s.first === s.last && // either `null`, or a singular child
    (s.f & dp) === 0 && (s = s.first, (t & au) !== 0 && (t & Nd) !== 0 && s !== null && (s.f |= Nd)), s !== null && (s.parent = i, i !== null && N0e(s, i), Zt !== null && (Zt.f & yi) !== 0 && (t & Vh) === 0)) {
      var a = (
        /** @type {Derived} */
        Zt
      );
      (a.effects ??= []).push(s);
    }
  }
  return o;
}
function Dx() {
  return Zt !== null && !La;
}
function GB(t) {
  const e = hl(wx, null, !1);
  return di(e, ai), e.teardown = t, e;
}
function Dl(t) {
  WB();
  var e = (
    /** @type {Effect} */
    ar.f
  ), r = !Zt && (e & lu) !== 0 && (e & Cx) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      po
    );
    (n.e ??= []).push(t);
  } else
    return KB(t);
}
function KB(t) {
  return hl(xx | uB, t, !1);
}
function zm(t) {
  return WB(), hl(wx | uB, t, !0);
}
function $0e(t) {
  eh.ensure();
  const e = hl(Vh | dp, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? ld(e, () => {
      Bi(e), n(void 0);
    }) : (Bi(e), n(void 0));
  });
}
function XB(t) {
  return hl(xx, t, !1);
}
function I0e(t) {
  return hl(PS | dp, t, !0);
}
function qS(t, e = 0) {
  return hl(wx | e, t, !0);
}
function Lo(t, e = [], r = [], n = [], i = !1) {
  A0e(n, e, r, (o) => {
    hl(i ? xx : wx, () => t(...o.map(W)), !0);
  });
}
function Ox(t, e = 0) {
  var r = hl(au | e, t, !0);
  return r;
}
function Bs(t, e = !0) {
  return hl(lu | dp, t, !0, e);
}
function QB(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Kh, n = Zt;
    H9(!0), no(null);
    try {
      e.call(null);
    } finally {
      H9(r), no(n);
    }
  }
}
function JB(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const i = r.ac;
    i !== null && jS(() => {
      i.abort(zf);
    });
    var n = r.next;
    (r.f & Vh) !== 0 ? r.parent = null : Bi(r, e), r = n;
  }
}
function B0e(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & lu) === 0 && Bi(e), e = r;
  }
}
function Bi(t, e = !0) {
  var r = !1;
  (e || (t.f & lB) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (L0e(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), r = !0), JB(t, e && !r), cb(t, 0), di(t, Xu);
  var n = t.transitions;
  if (n !== null)
    for (const o of n)
      o.stop();
  QB(t);
  var i = t.parent;
  i !== null && i.first !== null && YB(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function L0e(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ cl(t)
    );
    t.remove(), t = r;
  }
}
function YB(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function ld(t, e, r = !0) {
  var n = [];
  US(t, n, !0), ZB(n, () => {
    r && Bi(t), e && e();
  });
}
function ZB(t, e) {
  var r = t.length;
  if (r > 0) {
    var n = () => --r || e();
    for (var i of t)
      i.out(n);
  } else
    e();
}
function US(t, e, r) {
  if ((t.f & Vo) === 0) {
    if (t.f ^= Vo, t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || r) && e.push(s);
    for (var n = t.first; n !== null; ) {
      var i = n.next, o = (n.f & Nd) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (n.f & lu) !== 0 && (t.f & au) !== 0;
      US(n, e, o ? r : !1), n = i;
    }
  }
}
function HS(t) {
  eL(t, !0);
}
function eL(t, e) {
  if ((t.f & Vo) !== 0) {
    t.f ^= Vo, (t.f & ai) === 0 && (di(t, fo), Ah(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, i = (r.f & Nd) !== 0 || (r.f & lu) !== 0;
      eL(r, i ? e : !1), r = n;
    }
    if (t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || e) && o.in();
  }
}
function tL(t, e) {
  for (var r = t.nodes_start, n = t.nodes_end; r !== null; ) {
    var i = r === n ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ cl(r)
    );
    e.append(r), r = i;
  }
}
const rL = /* @__PURE__ */ new Set(), i_ = /* @__PURE__ */ new Set();
function z0e(t, e, r, n = {}) {
  function i(o) {
    if (n.capture || km.call(e, o), !o.cancelBubble)
      return jS(() => r?.call(this, o));
  }
  return mp(() => {
    e.addEventListener(t, i, n);
  }), i;
}
function j0e(t, e, r, n, i) {
  var o = { capture: n, passive: i }, s = z0e(t, e, r, o);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && GB(() => {
    e.removeEventListener(t, s, o);
  });
}
function q0e(t) {
  for (var e = 0; e < t.length; e++)
    rL.add(t[e]);
  for (var r of i_)
    r(t);
}
let W9 = null;
function km(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, i = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  W9 = t;
  var s = 0, a = W9 === t && t.__root;
  if (a) {
    var l = i.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    l <= u && (s = l);
  }
  if (o = /** @type {Element} */
  i[s] || t.target, o !== e) {
    fB(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Zt, h = ar;
    no(null), el(null);
    try {
      for (var d, p = []; o !== null; ) {
        var g = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var v = o["__" + n];
          v != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && v.call(o, t);
        } catch (y) {
          d ? p.push(y) : d = y;
        }
        if (t.cancelBubble || g === e || g === null)
          break;
        o = g;
      }
      if (d) {
        for (let y of p)
          queueMicrotask(() => {
            throw y;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, no(c), el(h);
    }
  }
}
function nL(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Yu(t, e) {
  var r = (
    /** @type {Effect} */
    ar
  );
  r.nodes_start === null && (r.nodes_start = t, r.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function bc(t, e) {
  var r = (e & m0e) !== 0, n = (e & g0e) !== 0, i, o = !t.startsWith("<!>");
  return () => {
    if (sr)
      return Yu(tr, null), tr;
    i === void 0 && (i = nL(o ? t : "<!>" + t), r || (i = /** @type {Node} */
    /* @__PURE__ */ Zl(i)));
    var s = (
      /** @type {TemplateNode} */
      n || SB ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Zl(s)
      ), l = (
        /** @type {TemplateNode} */
        s.lastChild
      );
      Yu(a, l);
    } else
      Yu(s, s);
    return s;
  };
}
// @__NO_SIDE_EFFECTS__
function U0e(t, e, r = "svg") {
  var n = !t.startsWith("<!>"), i = `<${r}>${n ? t : "<!>" + t}</${r}>`, o;
  return () => {
    if (sr)
      return Yu(tr, null), tr;
    if (!o) {
      var s = (
        /** @type {DocumentFragment} */
        nL(i)
      ), a = (
        /** @type {Element} */
        /* @__PURE__ */ Zl(s)
      );
      o = /** @type {Element} */
      /* @__PURE__ */ Zl(a);
    }
    var l = (
      /** @type {TemplateNode} */
      o.cloneNode(!0)
    );
    return Yu(l, l), l;
  };
}
// @__NO_SIDE_EFFECTS__
function cu(t, e) {
  return /* @__PURE__ */ U0e(t, e, "svg");
}
function im() {
  if (sr)
    return Yu(tr, null), tr;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = Za();
  return t.append(e, r), Yu(e, r), t;
}
function rn(t, e) {
  if (sr) {
    var r = (
      /** @type {Effect} */
      ar
    );
    ((r.f & Cx) === 0 || r.nodes_end === null) && (r.nodes_end = tr), b0();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
const H0e = ["touchstart", "touchmove"];
function V0e(t) {
  return H0e.includes(t);
}
function jm(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function iL(t, e) {
  return oL(t, e);
}
function W0e(t, e) {
  ZC(), e.intro = e.intro ?? !1;
  const r = e.target, n = sr, i = tr;
  try {
    for (var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Zl(r)
    ); o && (o.nodeType !== pp || /** @type {Comment} */
    o.data !== xB); )
      o = /** @type {TemplateNode} */
      /* @__PURE__ */ cl(o);
    if (!o)
      throw $d;
    ql(!0), so(
      /** @type {Comment} */
      o
    );
    const s = oL(t, { ...e, anchor: o });
    return ql(!1), /**  @type {Exports} */
    s;
  } catch (s) {
    if (s instanceof Error && s.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw s;
    return s !== $d && console.warn("Failed to hydrate: ", s), e.recover === !1 && r0e(), ZC(), DB(r), ql(!1), iL(t, e);
  } finally {
    ql(n), so(i);
  }
}
const kf = /* @__PURE__ */ new Map();
function oL(t, { target: e, anchor: r, props: n = {}, events: i, context: o, intro: s = !0 }) {
  ZC();
  var a = /* @__PURE__ */ new Set(), l = (h) => {
    for (var d = 0; d < h.length; d++) {
      var p = h[d];
      if (!a.has(p)) {
        a.add(p);
        var g = V0e(p);
        e.addEventListener(p, km, { passive: g });
        var v = kf.get(p);
        v === void 0 ? (document.addEventListener(p, km, { passive: g }), kf.set(p, 1)) : kf.set(p, v + 1);
      }
    }
  };
  l(NS(rL)), i_.add(l);
  var u = void 0, c = $0e(() => {
    var h = r ?? e.appendChild(Za());
    return _0e(
      /** @type {TemplateNode} */
      h,
      {
        pending: () => {
        }
      },
      (d) => {
        if (o) {
          Wh({});
          var p = (
            /** @type {ComponentContext} */
            po
          );
          p.c = o;
        }
        if (i && (n.$$events = i), sr && Yu(
          /** @type {TemplateNode} */
          d,
          null
        ), u = t(d, n) || {}, sr && (ar.nodes_end = tr, tr === null || tr.nodeType !== pp || /** @type {Comment} */
        tr.data !== LS))
          throw Sx(), $d;
        o && Gh();
      }
    ), () => {
      for (var d of a) {
        e.removeEventListener(d, km);
        var p = (
          /** @type {number} */
          kf.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, km), kf.delete(d)) : kf.set(d, p);
      }
      i_.delete(l), h !== r && h.parentNode?.removeChild(h);
    };
  });
  return o_.set(u, c), u;
}
let o_ = /* @__PURE__ */ new WeakMap();
function G0e(t, e) {
  const r = o_.get(t);
  return r ? (o_.delete(t), r(e)) : Promise.resolve();
}
function K0e(t) {
  return new X0e(t);
}
class X0e {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, s) => {
      var a = /* @__PURE__ */ IB(s, !1, !1);
      return r.set(o, a), a;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, s) {
          return W(r.get(s) ?? n(s, Reflect.get(o, s)));
        },
        has(o, s) {
          return s === cB ? !0 : (W(r.get(s) ?? n(s, Reflect.get(o, s))), Reflect.has(o, s));
        },
        set(o, s, a) {
          return ht(r.get(s) ?? n(s, a), a), Reflect.set(o, s, a);
        }
      }
    );
    this.#t = (e.hydrate ? W0e : iL)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && x0e(), this.#e = i.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || fB(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(s) {
          this.#t[o] = s;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(i, o);
    }, this.#t.$destroy = () => {
      G0e(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...i) => r.call(this, ...i);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const Q0e = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(Q0e);
class sL {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #r = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#n = r;
  }
  #l = () => {
    var e = (
      /** @type {Batch} */
      Sn
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        HS(n);
      else {
        var i = this.#r.get(r);
        i && (this.#t.set(r, i.effect), this.#r.delete(r), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), n = i.effect);
      }
      for (const [o, s] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(s);
        a && (Bi(a.effect), this.#r.delete(s));
      }
      for (const [o, s] of this.#t) {
        if (o === r) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var l = document.createDocumentFragment();
            tL(s, l), l.append(Za()), this.#r.set(o, { effect: s, fragment: l });
          } else
            Bi(s);
          this.#t.delete(o);
        };
        this.#n || !n ? ld(s, a, !1) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #a = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, i] of this.#r)
      r.includes(n) || (Bi(i.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      Sn
    );
    r && !this.#t.has(e) && !this.#r.has(e) && this.#t.set(
      e,
      Bs(() => r(this.anchor))
    ), this.#e.set(n, e), sr && (this.anchor = tr), this.#l();
  }
}
function VS(t) {
  po === null && yB(), Dl(() => {
    const e = Xh(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function J0e(t) {
  po === null && yB(), VS(() => () => Xh(t));
}
function Wi(t, e, r = !1) {
  sr && b0();
  var n = new sL(t), i = r ? Nd : 0;
  function o(s, a) {
    if (sr) {
      const u = _B(t) === _x;
      if (s === u) {
        var l = lb();
        so(l), n.anchor = l, ql(!1), n.ensure(s, a), ql(!0);
        return;
      }
    }
    n.ensure(s, a);
  }
  Ox(() => {
    var s = !1;
    e((a, l = !0) => {
      s = !0, o(l, a);
    }), s || o(!1, null);
  }, i);
}
function Y0e(t, e, r) {
  sr && b0();
  var n = new sL(t);
  Ox(() => {
    var i = e();
    n.ensure(i, r);
  });
}
function Ek(t, e) {
  return e;
}
function Z0e(t, e, r) {
  for (var n = t.items, i = [], o = e.length, s = 0; s < o; s++)
    US(e[s].e, i, !0);
  var a = o > 0 && i.length === 0 && r !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      r.parentNode
    );
    DB(l), l.append(
      /** @type {Element} */
      r
    ), n.clear(), ka(t, e[0].prev, e[o - 1].next);
  }
  ZB(i, () => {
    for (var u = 0; u < o; u++) {
      var c = e[u];
      a || (n.delete(c.k), ka(t, c.prev, c.next)), Bi(c.e, !a);
    }
  });
}
function Dk(t, e, r, n, i, o = null) {
  var s = t, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & bB) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    s = sr ? so(
      /** @type {Comment | Text} */
      /* @__PURE__ */ Zl(u)
    ) : u.appendChild(Za());
  }
  sr && b0();
  var c = null, h = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ PB(() => {
    var b = r();
    return hB(b) ? b : b == null ? [] : NS(b);
  }), g, v;
  function y() {
    eve(
      v,
      g,
      a,
      d,
      s,
      i,
      e,
      n,
      r
    ), o !== null && (g.length === 0 ? c ? HS(c) : c = Bs(() => o(s)) : c !== null && ld(c, () => {
      c = null;
    }));
  }
  Ox(() => {
    v ??= /** @type {Effect} */
    ar, g = /** @type {V[]} */
    W(p);
    var b = g.length;
    if (h && b === 0)
      return;
    h = b === 0;
    let k = !1;
    if (sr) {
      var C = _B(s) === _x;
      C !== (b === 0) && (s = lb(), so(s), ql(!1), k = !0);
    }
    if (sr) {
      for (var S = null, _, D = 0; D < b; D++) {
        if (tr.nodeType === pp && /** @type {Comment} */
        tr.data === LS) {
          s = /** @type {Comment} */
          tr, k = !0, ql(!1);
          break;
        }
        var A = g[D], O = n(A, D);
        _ = aL(
          tr,
          a,
          S,
          null,
          A,
          O,
          D,
          i,
          e,
          r
        ), a.items.set(O, _), S = _;
      }
      b > 0 && so(lb());
    }
    sr ? b === 0 && o && (c = Bs(() => o(s))) : y(), k && ql(!0), W(p);
  }), sr && (s = tr);
}
function eve(t, e, r, n, i, o, s, a, l) {
  var u = (s & u0e) !== 0, c = (s & (IS | BS)) !== 0, h = e.length, d = r.items, p = r.first, g = p, v, y = null, b, k = [], C = [], S, _, D, A;
  if (u)
    for (A = 0; A < h; A += 1)
      S = e[A], _ = a(S, A), D = d.get(_), D !== void 0 && (D.a?.measure(), (b ??= /* @__PURE__ */ new Set()).add(D));
  for (A = 0; A < h; A += 1) {
    if (S = e[A], _ = a(S, A), D = d.get(_), D === void 0) {
      var O = n.get(_);
      if (O !== void 0) {
        n.delete(_), d.set(_, O);
        var M = y ? y.next : g;
        ka(r, y, O), ka(r, O, M), Ok(O, M, i), y = O;
      } else {
        var z = g ? (
          /** @type {TemplateNode} */
          g.e.nodes_start
        ) : i;
        y = aL(
          z,
          r,
          y,
          y === null ? r.first : y.next,
          S,
          _,
          A,
          o,
          s,
          l
        );
      }
      d.set(_, y), k = [], C = [], g = y.next;
      continue;
    }
    if (c && tve(D, S, A, s), (D.e.f & Vo) !== 0 && (HS(D.e), u && (D.a?.unfix(), (b ??= /* @__PURE__ */ new Set()).delete(D))), D !== g) {
      if (v !== void 0 && v.has(D)) {
        if (k.length < C.length) {
          var N = C[0], P;
          y = N.prev;
          var I = k[0], B = k[k.length - 1];
          for (P = 0; P < k.length; P += 1)
            Ok(k[P], N, i);
          for (P = 0; P < C.length; P += 1)
            v.delete(C[P]);
          ka(r, I.prev, B.next), ka(r, y, I), ka(r, B, N), g = N, y = B, A -= 1, k = [], C = [];
        } else
          v.delete(D), Ok(D, g, i), ka(r, D.prev, D.next), ka(r, D, y === null ? r.first : y.next), ka(r, y, D), y = D;
        continue;
      }
      for (k = [], C = []; g !== null && g.k !== _; )
        (g.e.f & Vo) === 0 && (v ??= /* @__PURE__ */ new Set()).add(g), C.push(g), g = g.next;
      if (g === null)
        continue;
      D = g;
    }
    k.push(D), y = D, g = D.next;
  }
  if (g !== null || v !== void 0) {
    for (var $ = v === void 0 ? [] : NS(v); g !== null; )
      (g.e.f & Vo) === 0 && $.push(g), g = g.next;
    var j = $.length;
    if (j > 0) {
      var U = (s & bB) !== 0 && h === 0 ? i : null;
      if (u) {
        for (A = 0; A < j; A += 1)
          $[A].a?.measure();
        for (A = 0; A < j; A += 1)
          $[A].a?.fix();
      }
      Z0e(r, $, U);
    }
  }
  u && mp(() => {
    if (b !== void 0)
      for (D of b)
        D.a?.apply();
  }), t.first = r.first && r.first.e, t.last = y && y.e;
  for (var H of n.values())
    Bi(H.e);
  n.clear();
}
function tve(t, e, r, n) {
  (n & IS) !== 0 && Ld(t.v, e), (n & BS) !== 0 ? Ld(
    /** @type {Value<number>} */
    t.i,
    r
  ) : t.i = r;
}
function aL(t, e, r, n, i, o, s, a, l, u, c) {
  var h = (l & IS) !== 0, d = (l & c0e) === 0, p = h ? d ? /* @__PURE__ */ IB(i, !1, !1) : Eh(i) : i, g = (l & BS) === 0 ? s : Eh(s), v = {
    i: g,
    v: p,
    k: o,
    a: null,
    // @ts-expect-error
    e: null,
    prev: r,
    next: n
  };
  try {
    if (t === null) {
      var y = document.createDocumentFragment();
      y.append(t = Za());
    }
    return v.e = Bs(() => a(
      /** @type {Node} */
      t,
      p,
      g,
      u
    ), sr), v.e.prev = r && r.e, v.e.next = n && n.e, r === null ? c || (e.first = v) : (r.next = v, r.e.next = v.e), n !== null && (n.prev = v, n.e.prev = v.e), v;
  } finally {
  }
}
function Ok(t, e, r) {
  for (var n = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : r, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : r, o = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); o !== null && o !== n; ) {
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ cl(o)
    );
    i.before(o), o = s;
  }
}
function ka(t, e, r) {
  e === null ? t.first = r : (e.next = r, e.e.next = r && r.e), r !== null && (r.prev = e, r.e.prev = e && e.e);
}
function Ns(t, e, r) {
  XB(() => {
    var n = Xh(() => e(t, r?.()) || {});
    if (r && n?.update) {
      var i = !1, o = (
        /** @type {any} */
        {}
      );
      qS(() => {
        var s = r();
        R0e(s), i && gB(o, s) && (o = s, n.update(s));
      }), i = !0;
    }
    if (n?.destroy)
      return () => (
        /** @type {Function} */
        n.destroy()
      );
  });
}
function G9(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var i in t) {
    var o = t[i];
    o != null && o !== "" && (n += " " + i + ": " + o + r);
  }
  return n;
}
function rve(t, e) {
  if (e) {
    var r = "", n, i;
    return Array.isArray(e) ? (n = e[0], i = e[1]) : n = e, n && (r += G9(n)), i && (r += G9(i, !0)), r = r.trim(), r === "" ? null : r;
  }
  return String(t);
}
function Fk(t, e = {}, r, n) {
  for (var i in r) {
    var o = r[i];
    e[i] !== o && (r[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, o, n));
  }
}
function Jt(t, e, r, n) {
  var i = t.__style;
  if (sr || i !== e) {
    var o = rve(e, n);
    (!sr || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (Fk(t, r?.[0], n[0]), Fk(t, r?.[1], n[1], "important")) : Fk(t, r, n));
  return n;
}
const nve = Symbol("is custom element"), ive = Symbol("is html");
function je(t, e, r, n) {
  var i = ove(t);
  sr && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = r) && (e === "loading" && (t[Vge] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && sve(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function ove(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [nve]: t.nodeName.includes("-"),
      [ive]: t.namespaceURI === v0e
    }
  );
}
var K9 = /* @__PURE__ */ new Map();
function sve(t) {
  var e = t.getAttribute("is") || t.nodeName, r = K9.get(e);
  if (r) return r;
  K9.set(e, r = []);
  for (var n, i = t, o = Element.prototype; o !== i; ) {
    n = dB(i);
    for (var s in n)
      n[s].set && r.push(s);
    i = $S(i);
  }
  return r;
}
function X9(t, e) {
  return t === e || t?.[uh] === e;
}
function s_(t = {}, e, r, n) {
  return XB(() => {
    var i, o;
    return qS(() => {
      i = o, o = [], Xh(() => {
        t !== r(...o) && (e(t, ...o), i && X9(r(...i), t) && e(null, ...i));
      });
    }), () => {
      mp(() => {
        o && X9(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
let gy = !1;
function ave(t) {
  var e = gy;
  try {
    return gy = !1, [t(), gy];
  } finally {
    gy = e;
  }
}
function Ye(t, e, r, n) {
  var i = (r & d0e) !== 0, o = (r & p0e) !== 0, s = (
    /** @type {V} */
    n
  ), a = !0, l = () => (a && (a = !1, s = o ? Xh(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), s), u;
  if (i) {
    var c = uh in t || cB in t;
    u = ad(t, e)?.set ?? (c && e in t ? (k) => t[e] = k : void 0);
  }
  var h, d = !1;
  i ? [h, d] = ave(() => (
    /** @type {V} */
    t[e]
  )) : h = /** @type {V} */
  t[e], h === void 0 && n !== void 0 && (h = l(), u && (n0e(), u(h)));
  var p;
  if (p = () => {
    var k = (
      /** @type {V} */
      t[e]
    );
    return k === void 0 ? l() : (a = !0, k);
  }, (r & f0e) === 0)
    return p;
  if (u) {
    var g = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(k, C) {
        return arguments.length > 0 ? ((!C || g || d) && u(C ? p() : k), k) : p();
      })
    );
  }
  var v = !1, y = ((r & h0e) !== 0 ? Ex : PB)(() => (v = !1, p()));
  i && W(y);
  var b = (
    /** @type {Effect} */
    ar
  );
  return (
    /** @type {() => V} */
    (function(k, C) {
      if (arguments.length > 0) {
        const S = C ? W(y) : i ? Zc(k) : k;
        return ht(y, S), v = !0, s !== void 0 && (s = S), k;
      }
      return Kh && v || (b.f & Xu) !== 0 ? y.v : W(y);
    })
  );
}
var lve = /* @__PURE__ */ cu('<g><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect></g>');
function uve(t, e) {
  Wh(e, !0);
  let r = /* @__PURE__ */ mt(() => e.pointLocation(e.value.xMin, e.value.yMin)), n = /* @__PURE__ */ mt(() => e.pointLocation(e.value.xMax, e.value.yMax));
  const i = 8;
  function o(y) {
    return (b) => {
      e.preventHover(!0);
      let k = [W(r).x, W(r).y, W(n).x, W(n).y];
      return {
        move: (C) => {
          let S = C.pageX - b.pageX, _ = C.pageY - b.pageY, D = [S, _, S, _].map((M, z) => k[z] + M * y[z]), A = e.coordinateAtPoint(D[0], D[1]), O = e.coordinateAtPoint(D[2], D[3]);
          e.onChange({
            xMin: Math.min(A.x, O.x),
            xMax: Math.max(A.x, O.x),
            yMin: Math.min(A.y, O.y),
            yMax: Math.max(A.y, O.y)
          });
        },
        up: () => {
          e.preventHover(!1);
        },
        cancel: () => {
          e.preventHover(!1);
        }
      };
    };
  }
  var s = lve(), a = In(s);
  Jt(a, "", {}, {
    stroke: "#fff",
    fill: "rgba(128,128,128,0.25)",
    cursor: "move"
  }), Ns(a, (y, b) => vn?.(y, b), () => ({ drag: o([1, 1, 1, 1]) }));
  var l = Vr(a);
  je(l, "width", i), Jt(l, "", {}, {
    cursor: "ew-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(l, (y, b) => vn?.(y, b), () => ({ drag: o([1, 0, 0, 0]) }));
  var u = Vr(l);
  je(u, "width", i), Jt(u, "", {}, {
    cursor: "ew-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(u, (y, b) => vn?.(y, b), () => ({ drag: o([0, 0, 1, 0]) }));
  var c = Vr(u);
  je(c, "height", i), Jt(c, "", {}, {
    cursor: "ns-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(c, (y, b) => vn?.(y, b), () => ({ drag: o([0, 1, 0, 0]) }));
  var h = Vr(c);
  je(h, "height", i), Jt(h, "", {}, {
    cursor: "ns-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(h, (y, b) => vn?.(y, b), () => ({ drag: o([0, 0, 0, 1]) }));
  var d = Vr(h);
  je(d, "width", i), je(d, "height", i), Jt(d, "", {}, {
    cursor: "nesw-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(d, (y, b) => vn?.(y, b), () => ({ drag: o([1, 1, 0, 0]) }));
  var p = Vr(d);
  je(p, "width", i), je(p, "height", i), Jt(p, "", {}, {
    cursor: "nwse-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(p, (y, b) => vn?.(y, b), () => ({ drag: o([1, 0, 0, 1]) }));
  var g = Vr(p);
  je(g, "width", i), je(g, "height", i), Jt(g, "", {}, {
    cursor: "nwse-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(g, (y, b) => vn?.(y, b), () => ({ drag: o([0, 1, 1, 0]) }));
  var v = Vr(g);
  je(v, "width", i), je(v, "height", i), Jt(v, "", {}, {
    cursor: "nesw-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Ns(v, (y, b) => vn?.(y, b), () => ({ drag: o([0, 0, 1, 1]) })), bn(s), Lo(
    (y, b, k, C, S, _, D, A, O, M, z, N) => {
      je(a, "x", y), je(a, "width", b), je(a, "y", k), je(a, "height", C), je(l, "x", W(r).x - i / 2), je(l, "y", S), je(l, "height", _), je(u, "x", W(n).x - i / 2), je(u, "y", D), je(u, "height", A), je(c, "x", O), je(c, "width", M), je(c, "y", W(r).y - i / 2), je(h, "x", z), je(h, "width", N), je(h, "y", W(n).y - i / 2), je(d, "x", W(r).x - i / 2), je(d, "y", W(r).y - i / 2), je(p, "x", W(r).x - i / 2), je(p, "y", W(n).y - i / 2), je(g, "x", W(n).x - i / 2), je(g, "y", W(r).y - i / 2), je(v, "x", W(n).x - i / 2), je(v, "y", W(n).y - i / 2);
    },
    [
      () => Math.min(W(r).x, W(n).x),
      () => Math.abs(W(r).x - W(n).x),
      () => Math.min(W(r).y, W(n).y),
      () => Math.abs(W(r).y - W(n).y),
      () => Math.min(W(r).y, W(n).y),
      () => Math.abs(W(r).y - W(n).y),
      () => Math.min(W(r).y, W(n).y),
      () => Math.abs(W(r).y - W(n).y),
      () => Math.min(W(r).x, W(n).x),
      () => Math.abs(W(r).x - W(n).x),
      () => Math.min(W(r).x, W(n).x),
      () => Math.abs(W(r).x - W(n).x)
    ]
  ), rn(t, s), Gh();
}
function cve(t, e) {
  let r = !1, n, i, o, s = 300, a = 300, l = async (c) => {
    r = !0;
    try {
      await t(c);
    } catch (h) {
      console.error(h);
    }
    if (r = !1, n !== void 0) {
      let h = n;
      n = void 0, u(h);
    }
  }, u = async (c) => {
    if (r) {
      n = c;
      return;
    }
    let h = (/* @__PURE__ */ new Date()).getTime();
    e() && (i = h);
    let d = !0;
    (i == null || h - i < a) && (d = !1), d ? (o && clearTimeout(o), o = setTimeout(() => l(c), s)) : l(c);
  };
  return u;
}
function hve(t, e) {
  let r = t.x - e.x, n = t.y - e.y;
  return Math.sqrt(r * r + n * n);
}
function fve(t) {
  return "M " + t.map(({ x: e, y: r }) => `${e},${r}`).join(" L ") + " Z";
}
function lL(t) {
  let e = 1 / 0, r = -1 / 0, n = 1 / 0, i = -1 / 0;
  for (let { x: o, y: s } of t)
    e = Math.min(e, o), n = Math.min(n, s), r = Math.max(r, o), i = Math.max(i, s);
  return { xMin: e, yMin: n, xMax: r, yMax: i };
}
async function dve(t) {
  let e = JSON.stringify(t);
  return mve(e);
}
function Bu(t, e) {
  if (t === e)
    return !0;
  if (t === null || e === null || typeof t != "object" || typeof e != "object" || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (let r in t)
    if (e.hasOwnProperty(r)) {
      if (!Bu(t[r], e[r]))
        return !1;
    } else
      return !1;
  return !0;
}
function pve(t, e = 0) {
  let r = 3735928559 ^ e, n = 1103547991 ^ e;
  for (let i = 0; i < t.length; i++) {
    let o = t[i];
    r = Math.imul(r ^ o, 2654435761), n = Math.imul(n ^ o, 1597334677);
  }
  return r = Math.imul(r ^ r >>> 16, 2246822507), r ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(r ^ r >>> 13, 3266489909), [n >>> 0, r >>> 0];
}
function mve(t) {
  let e = new TextEncoder().encode(t), r = pve(e);
  return r[0].toString(16).padStart(8, "0") + r[1].toString(16).padStart(8, "0");
}
var gve = /* @__PURE__ */ cu("<path></path>");
function vve(t, e) {
  Wh(e, !0);
  let r = /* @__PURE__ */ mt(() => e.value.map(({ x: i, y: o }) => e.pointLocation(i, o)));
  var n = gve();
  Jt(n, "", {}, { stroke: "#fff", fill: "rgba(128,128,128,0.25)" }), Lo((i) => je(n, "d", i), [() => fve(W(r))]), rn(t, n), Gh();
}
const yve = {
  marquee: "M7 5a2 2 0 1 1-4 0a2 2 0 0 1 4 0m1-.25c0 .414.336.75.75.75h6.5a.75.75 0 0 0 0-1.5h-6.5a.75.75 0 0 0-.75.75M4.75 8a.75.75 0 0 0-.75.75v6.5a.75.75 0 0 0 1.5 0v-6.5A.75.75 0 0 0 4.75 8m14.5 0a.75.75 0 0 0-.75.75v6.5a.75.75 0 0 0 1.5 0v-6.5a.75.75 0 0 0-.75-.75M8.75 20a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5zM5 21a2 2 0 1 0 0-4a2 2 0 0 0 0 4M21 5a2 2 0 1 1-4 0a2 2 0 0 1 4 0m-2 16a2 2 0 1 0 0-4a2 2 0 0 0 0 4",
  lasso: "M9.703 2.265A10 10 0 0 1 12 2c.79 0 1.559.092 2.297.265a.75.75 0 1 1-.343 1.46A8.5 8.5 0 0 0 12 3.5a8.6 8.6 0 0 0-1.954.225a.75.75 0 1 1-.343-1.46m-1.93 1.47a.75.75 0 0 1-.242 1.033a8.55 8.55 0 0 0-2.763 2.763a.75.75 0 1 1-1.275-.79a10.05 10.05 0 0 1 3.248-3.248a.75.75 0 0 1 1.032.243m8.454 0a.75.75 0 0 1 1.032-.242a10.05 10.05 0 0 1 3.248 3.248a.75.75 0 1 1-1.275.79a8.55 8.55 0 0 0-2.763-2.763a.75.75 0 0 1-.242-1.032m-13.06 5.41a.75.75 0 0 1 .558.901A8.5 8.5 0 0 0 3.5 12c0 .673.078 1.327.225 1.954a.75.75 0 1 1-1.46.343A10 10 0 0 1 2 12c0-.79.092-1.559.265-2.297a.75.75 0 0 1 .902-.559m17.666 0a.75.75 0 0 1 .902.558a10.1 10.1 0 0 1 0 4.595a.75.75 0 1 1-1.46-.343a8.54 8.54 0 0 0-.001-3.908a.75.75 0 0 1 .559-.902M3.736 16.226a.75.75 0 0 1 1.032.242a8.55 8.55 0 0 0 2.763 2.763a.75.75 0 0 1-.79 1.275a10.05 10.05 0 0 1-3.248-3.248a.75.75 0 0 1 .243-1.032m16.685.858a.75.75 0 1 0-1.342-.67l-.002.004l-.015.029l-.069.123a8 8 0 0 1-.289.466a9.6 9.6 0 0 1-.965 1.219c-1.17-1.073-2.756-2.006-4.74-2.006c-2.347 0-3.99 1.203-3.99 2.875S10.653 22 13 22c1.942 0 3.495-.75 4.658-1.645a11.7 11.7 0 0 1 1.315 2.01q.05.099.073.149l.017.035l.004.009a.75.75 0 0 0 1.368-.615c-.087-.183 0-.001 0-.001v-.002l-.003-.004l-.007-.015l-.024-.052l-.091-.184a13.2 13.2 0 0 0-1.538-2.337a11 11 0 0 0 1.525-2.032l.09-.162l.024-.047l.007-.014l.002-.005zM13 17.75c1.433 0 2.644.652 3.616 1.512c-.95.7-2.155 1.238-3.616 1.238c-1.973 0-2.49-.922-2.49-1.375s.517-1.375 2.49-1.375"
};
var bve = /* @__PURE__ */ cu('<svg width="24" height="24" viewBox="0 0 24 24"><path></path></svg>'), xve = /* @__PURE__ */ bc("<button><!></button>");
function Q9(t, e) {
  let r = Ye(e, "active", 3, !1);
  var n = xve();
  n.__click = function(...a) {
    e.onClick?.apply(this, a);
  };
  let i;
  var o = In(n);
  {
    var s = (a) => {
      var l = bve();
      Jt(l, "", {}, { width: "14px", height: "14px" });
      var u = In(l);
      Jt(u, "", {}, { fill: "currentColor" }), bn(l), Lo(() => je(u, "d", yve[e.icon])), rn(a, l);
    };
    Wi(o, (a) => {
      e.icon != null && a(s);
    });
  }
  bn(n), Lo(() => {
    je(n, "title", e.title), i = Jt(n, "", i, {
      border: "none",
      appearance: "none",
      background: r() ? "color-mix(in srgb, currentColor 20%, transparent)" : "none",
      "border-radius": "2px",
      height: "16px",
      width: "16px",
      padding: "0",
      margin: "0",
      "font-family": "inherit",
      "font-size": "1em",
      color: "currentColor",
      display: "flex",
      "flex-direction": "row",
      "align-items": "center",
      "justify-content": "center"
    });
  }), rn(t, n);
}
q0e(["click"]);
var wve = /* @__PURE__ */ bc('<div><div> </div> <svg height="6px"><line shape-rendering="crispEdges"></line><line shape-rendering="crispEdges"></line><line shape-rendering="crispEdges"></line></svg></div>');
function kve(t, e) {
  function r(d, p) {
    let g = Math.log10(p * d), v = Math.round(g), y = [0.1, 0.2, 0.5, 1, 2, 5, 10], b = 0, k = 1e10;
    for (let C of y) {
      let S = Math.abs(Math.log10(C) + v - g);
      S < k && (b = C, k = S);
    }
    return b * Math.pow(10, v);
  }
  let n = /* @__PURE__ */ mt(() => r(e.distancePerPoint, 30)), i = /* @__PURE__ */ mt(() => W(n) / e.distancePerPoint);
  var o = wve();
  Jt(o, "", {}, { display: "flex", "align-items": "center" });
  var s = In(o);
  Jt(s, "", {}, { "padding-right": "4px" });
  var a = In(s, !0);
  bn(s);
  var l = Vr(s, 2), u = In(l);
  je(u, "x1", 1), je(u, "y1", 3), je(u, "y2", 3), Jt(u, "", {}, {
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-cap": "butt"
  });
  var c = Vr(u);
  je(c, "x1", 1), je(c, "x2", 1), je(c, "y1", 0), je(c, "y2", 6), Jt(c, "", {}, { stroke: "currentColor" });
  var h = Vr(c);
  je(h, "y1", 0), je(h, "y2", 6), Jt(h, "", {}, { stroke: "currentColor" }), bn(l), bn(o), Lo(
    (d) => {
      jm(a, d), je(l, "width", `${W(i) + 2}px`), je(u, "x2", W(i) + 1), je(h, "x1", W(i) + 1), je(h, "x2", W(i) + 1);
    },
    [() => W(n).toLocaleString()]
  ), rn(t, o);
}
var Cve = /* @__PURE__ */ bc("<div> </div>"), _ve = /* @__PURE__ */ bc('<a target="_blank"> </a> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div>', 1), Sve = /* @__PURE__ */ bc('<div><div><!></div> <div></div> <div><!> <!> <!> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div> <!> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div> <span> </span></div></div>');
function Ave(t, e) {
  Wh(e, !0);
  let r = Ye(e, "statusMessage", 3, null);
  var n = Sve();
  let i;
  var o = In(n);
  let s;
  var a = In(o);
  {
    var l = (C) => {
      var S = Cve();
      Jt(S, "", {}, { display: "inline-block" });
      var _ = In(S, !0);
      bn(S), Lo(() => jm(_, r())), rn(C, S);
    };
    Wi(a, (C) => {
      r() != null && C(l);
    });
  }
  bn(o);
  var u = Vr(o, 2);
  Jt(u, "", {}, { flex: "1 1 0%" });
  var c = Vr(u, 2);
  let h;
  var d = In(c);
  {
    var p = (C) => {
      var S = _ve(), _ = Of(S);
      Jt(_, "", {}, { color: "currentColor", "text-decoration": "underline" });
      var D = In(_, !0);
      bn(_), CB(2), Lo(() => {
        je(_, "href", e.resolvedTheme.brandingLink.href), jm(D, e.resolvedTheme.brandingLink.text);
      }), rn(C, S);
    };
    Wi(d, (C) => {
      e.resolvedTheme.brandingLink != null && C(p);
    });
  }
  var g = Vr(d, 2);
  {
    let C = /* @__PURE__ */ mt(() => e.selectionMode == "marquee");
    Q9(g, {
      icon: "marquee",
      get active() {
        return W(C);
      },
      title: "Toggle rectangle selection mode. In normal mode, use shift + drag for rectangle selection.",
      onClick: () => e.onSelectionMode(e.selectionMode == "marquee" ? "none" : "marquee")
    });
  }
  var v = Vr(g, 2);
  {
    let C = /* @__PURE__ */ mt(() => e.selectionMode == "lasso");
    Q9(v, {
      icon: "lasso",
      get active() {
        return W(C);
      },
      title: "Toggle lasso selection mode. In normal mode, use shift + meta + drag for lasso selection.",
      onClick: () => e.onSelectionMode(e.selectionMode == "lasso" ? "none" : "lasso")
    });
  }
  var y = Vr(v, 4);
  kve(y, {
    get distancePerPoint() {
      return e.distancePerPoint;
    }
  });
  var b = Vr(y, 4), k = In(b);
  bn(b), bn(c), bn(n), Lo(
    (C) => {
      i = Jt(n, "", i, {
        "font-size": "12px",
        "line-height": "20px",
        height: "20px",
        color: e.resolvedTheme.statusBarTextColor,
        position: "absolute",
        bottom: "0px",
        left: "0px",
        right: "0px",
        "user-select": "none",
        "font-family": e.resolvedTheme.fontFamily,
        display: "flex",
        "flex-direction": "row"
      }), s = Jt(o, "", s, {
        flex: "none",
        display: "flex",
        "flex-direction": "row",
        gap: "4px",
        padding: "0px 4px",
        "border-radius": "2px",
        background: e.resolvedTheme.statusBarBackgroundColor
      }), h = Jt(c, "", h, {
        flex: "none",
        display: "flex",
        "flex-direction": "row",
        "align-items": "center",
        gap: "4px",
        padding: "0px 4px",
        "border-radius": "2px",
        background: e.resolvedTheme.statusBarBackgroundColor
      }), jm(k, `${C ?? ""} points`);
    },
    [() => e.pointCount.toLocaleString()]
  ), rn(t, n), Gh();
}
function Eve(t) {
  return (e, r) => {
    let n = new t(e, r);
    return {
      ...n.update ? { update: n.update.bind(n) } : {},
      ...n.destroy ? { destroy: n.destroy.bind(n) } : {}
    };
  };
}
let Tk = /* @__PURE__ */ new WeakMap();
function uL(t) {
  let e = typeof t == "function" ? t : t.class;
  if (Tk.has(e))
    return Tk.get(e);
  {
    let r = Eve(e);
    return Tk.set(e, r), r;
  }
}
function cL(t, e) {
  return typeof t == "function" ? e : { ...t.props ?? {}, ...e };
}
var Dve = /* @__PURE__ */ bc("<div><div></div></div>");
function Ove(t, e) {
  Wh(e, !0);
  let r = Ye(e, "margin", 3, 4), n, i, o = /* @__PURE__ */ mt(() => uL(e.customTooltip)), s = /* @__PURE__ */ mt(() => cL(e.customTooltip, { tooltip: e.tooltip }));
  VS(() => {
    zm(() => {
      let u = W(o), c = null;
      return zm(() => {
        i.style.left = "0px", i.style.top = "0px", i.style.pointerEvents = e.allowInteraction ? "all" : "none", c == null ? c = u(i, W(s)) : c.update?.(W(s));
        function h(y, b, k, C) {
          let S = e.location.x, _ = e.location.y, D = 2, A = y / 2, O = b + (e.targetHeight + r());
          S - A < k && (A = S - k), S - A > C - y && (A = S - C + y), _ - O < D && (O = -(e.targetHeight + r())), i.style.left = S - A + "px", i.style.top = _ - O + "px";
        }
        let d = n.getBoundingClientRect(), { width: p, height: g } = i.getBoundingClientRect();
        h(p, g, 2, d.width - 2);
        let v = requestAnimationFrame(() => {
          v = null;
          let y = i.getBoundingClientRect();
          (y.width != p || y.height != g) && h(y.width, y.height, 2, d.width - 2);
        });
        return () => {
          v != null && cancelAnimationFrame(v);
        };
      }), () => {
        c?.destroy?.(), i.replaceChildren();
      };
    });
  });
  var a = Dve();
  Jt(a, "", {}, { position: "absolute", width: "100%" });
  var l = In(a);
  Jt(l, "", {}, {
    display: "flex",
    position: "absolute",
    width: "fit-content",
    height: "fit-content",
    "z-index": "100"
  }), s_(l, (u) => i = u, () => i), bn(a), s_(a, (u) => n = u, () => n), rn(t, a), Gh();
}
function WS(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function hL(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function w0() {
}
var zg = 0.7, hb = 1 / zg, ud = "\\s*([+-]?\\d+)\\s*", jg = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ga = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Fve = /^#([0-9a-f]{3,8})$/, Tve = new RegExp(`^rgb\\(${ud},${ud},${ud}\\)$`), Mve = new RegExp(`^rgb\\(${Ga},${Ga},${Ga}\\)$`), Pve = new RegExp(`^rgba\\(${ud},${ud},${ud},${jg}\\)$`), Rve = new RegExp(`^rgba\\(${Ga},${Ga},${Ga},${jg}\\)$`), Nve = new RegExp(`^hsl\\(${jg},${Ga},${Ga}\\)$`), $ve = new RegExp(`^hsla\\(${jg},${Ga},${Ga},${jg}\\)$`), J9 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
WS(w0, GS, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Y9,
  // Deprecated! Use color.formatHex.
  formatHex: Y9,
  formatHex8: Ive,
  formatHsl: Bve,
  formatRgb: Z9,
  toString: Z9
});
function Y9() {
  return this.rgb().formatHex();
}
function Ive() {
  return this.rgb().formatHex8();
}
function Bve() {
  return dL(this).formatHsl();
}
function Z9() {
  return this.rgb().formatRgb();
}
function GS(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = Fve.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? eO(e) : r === 3 ? new io(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? vy(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? vy(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = Tve.exec(t)) ? new io(e[1], e[2], e[3], 1) : (e = Mve.exec(t)) ? new io(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Pve.exec(t)) ? vy(e[1], e[2], e[3], e[4]) : (e = Rve.exec(t)) ? vy(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = Nve.exec(t)) ? nO(e[1], e[2] / 100, e[3] / 100, 1) : (e = $ve.exec(t)) ? nO(e[1], e[2] / 100, e[3] / 100, e[4]) : J9.hasOwnProperty(t) ? eO(J9[t]) : t === "transparent" ? new io(NaN, NaN, NaN, 0) : null;
}
function eO(t) {
  return new io(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function vy(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new io(t, e, r, n);
}
function Lve(t) {
  return t instanceof w0 || (t = GS(t)), t ? (t = t.rgb(), new io(t.r, t.g, t.b, t.opacity)) : new io();
}
function fL(t, e, r, n) {
  return arguments.length === 1 ? Lve(t) : new io(t, e, r, n ?? 1);
}
function io(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
WS(io, fL, hL(w0, {
  brighter(t) {
    return t = t == null ? hb : Math.pow(hb, t), new io(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? zg : Math.pow(zg, t), new io(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new io(fh(this.r), fh(this.g), fh(this.b), fb(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: tO,
  // Deprecated! Use color.formatHex.
  formatHex: tO,
  formatHex8: zve,
  formatRgb: rO,
  toString: rO
}));
function tO() {
  return `#${th(this.r)}${th(this.g)}${th(this.b)}`;
}
function zve() {
  return `#${th(this.r)}${th(this.g)}${th(this.b)}${th((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rO() {
  const t = fb(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${fh(this.r)}, ${fh(this.g)}, ${fh(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function fb(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function fh(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function th(t) {
  return t = fh(t), (t < 16 ? "0" : "") + t.toString(16);
}
function nO(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new Us(t, e, r, n);
}
function dL(t) {
  if (t instanceof Us) return new Us(t.h, t.s, t.l, t.opacity);
  if (t instanceof w0 || (t = GS(t)), !t) return new Us();
  if (t instanceof Us) return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, i = Math.min(e, r, n), o = Math.max(e, r, n), s = NaN, a = o - i, l = (o + i) / 2;
  return a ? (e === o ? s = (r - n) / a + (r < n) * 6 : r === o ? s = (n - e) / a + 2 : s = (e - r) / a + 4, a /= l < 0.5 ? o + i : 2 - o - i, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new Us(s, a, l, t.opacity);
}
function jve(t, e, r, n) {
  return arguments.length === 1 ? dL(t) : new Us(t, e, r, n ?? 1);
}
function Us(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
WS(Us, jve, hL(w0, {
  brighter(t) {
    return t = t == null ? hb : Math.pow(hb, t), new Us(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? zg : Math.pow(zg, t), new Us(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new io(
      Mk(t >= 240 ? t - 240 : t + 120, i, n),
      Mk(t, i, n),
      Mk(t < 120 ? t + 240 : t - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new Us(iO(this.h), yy(this.s), yy(this.l), fb(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = fb(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${iO(this.h)}, ${yy(this.s) * 100}%, ${yy(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function iO(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function yy(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function Mk(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const oO = [
  "#1f77b4",
  "#ff7f0e",
  "#2ca02c",
  "#d62728",
  "#9467bd",
  "#8c564b",
  "#e377c2",
  "#7f7f7f",
  "#bcbd22",
  "#17becf"
], by = [
  "#1f77b4",
  "#aec7e8",
  "#ff7f0e",
  "#ffbb78",
  "#2ca02c",
  "#98df8a",
  "#d62728",
  "#ff9896",
  "#9467bd",
  "#c5b0d5",
  "#8c564b",
  "#c49c94",
  "#e377c2",
  "#f7b6d2",
  "#7f7f7f",
  "#c7c7c7",
  "#bcbd22",
  "#dbdb8d",
  "#17becf",
  "#9edae5"
];
function gp(t) {
  if (t < 1 && (t = 1), t <= oO.length)
    return oO.slice(0, t);
  if (t <= by.length)
    return by.slice(0, t);
  {
    let e = [];
    for (let r = 0; r < t; r++)
      e[r] = by[r % by.length];
    return e;
  }
}
function KS(t) {
  let { r: e, g: r, b: n, opacity: i } = fL(t);
  return { r: e / 255, g: r / 255, b: n / 255, a: i };
}
function pL() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}
function XS(t, e) {
  return [
    t[0] * e[0] + t[3] * e[1] + t[6] * e[2],
    t[1] * e[0] + t[4] * e[1] + t[7] * e[2],
    t[2] * e[0] + t[5] * e[1] + t[8] * e[2],
    t[0] * e[3] + t[3] * e[4] + t[6] * e[5],
    t[1] * e[3] + t[4] * e[4] + t[7] * e[5],
    t[2] * e[3] + t[5] * e[4] + t[8] * e[5],
    t[0] * e[6] + t[3] * e[7] + t[6] * e[8],
    t[1] * e[6] + t[4] * e[7] + t[7] * e[8],
    t[2] * e[6] + t[5] * e[7] + t[8] * e[8]
  ];
}
function mL(t, e) {
  return [
    e[0] * t[0] + e[3] * t[1] + e[6] * t[2],
    e[1] * t[0] + e[4] * t[1] + e[7] * t[2],
    e[2] * t[0] + e[5] * t[1] + e[8] * t[2]
  ];
}
function qve(t) {
  return t[0] * t[4] * t[8] - t[0] * t[5] * t[7] - t[1] * t[3] * t[8] + t[1] * t[5] * t[6] + t[2] * t[3] * t[7] - t[2] * t[4] * t[6];
}
function gL(t) {
  let e = qve(t);
  return [
    (t[4] * t[8] - t[5] * t[7]) / e,
    (t[2] * t[7] - t[1] * t[8]) / e,
    (t[1] * t[5] - t[2] * t[4]) / e,
    (t[5] * t[6] - t[3] * t[8]) / e,
    (t[0] * t[8] - t[2] * t[6]) / e,
    (t[2] * t[3] - t[0] * t[5]) / e,
    (t[3] * t[7] - t[4] * t[6]) / e,
    (t[1] * t[6] - t[0] * t[7]) / e,
    (t[0] * t[4] - t[1] * t[3]) / e
  ];
}
class Fx {
  viewport;
  width;
  height;
  _matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  _pixel_kx = 0;
  _pixel_bx = 0;
  _pixel_ky = 0;
  _pixel_by = 0;
  constructor(e, r, n) {
    this.viewport = e, this.width = r, this.height = n, this.updateCoefficients();
  }
  update(e, r, n) {
    this.viewport = e, this.width = r, this.height = n, this.updateCoefficients();
  }
  updateCoefficients() {
    let { x: e, y: r, scale: n } = this.viewport, i = n, o = n;
    this.width < this.height ? i *= this.height / this.width : o *= this.width / this.height, this._matrix = [i, 0, 0, 0, o, 0, -e * i, -r * o, 1], this._pixel_kx = this._matrix[0] * this.width / 2, this._pixel_bx = (this._matrix[6] + 1) * this.width / 2, this._pixel_ky = -this._matrix[4] * this.height / 2, this._pixel_by = (-this._matrix[7] + 1) * this.height / 2;
  }
  matrix() {
    return this._matrix;
  }
  pixelLocation(e, r) {
    return { x: e * this._pixel_kx + this._pixel_bx, y: r * this._pixel_ky + this._pixel_by };
  }
  coordinateAtPixel(e, r) {
    return { x: (e - this._pixel_bx) / this._pixel_kx, y: (r - this._pixel_by) / this._pixel_ky };
  }
  pixelLocationFunction() {
    let e = this._pixel_kx, r = this._pixel_ky, n = this._pixel_bx, i = this._pixel_by;
    return (o, s) => ({ x: o * e + n, y: s * r + i });
  }
  coordinateAtPixelFunction() {
    let e = this._pixel_kx, r = this._pixel_ky, n = this._pixel_bx, i = this._pixel_by;
    return (o, s) => ({ x: (o - n) / e, y: (s - i) / r });
  }
}
let a_ = class {
  _needsRun = !0;
  _inputs = /* @__PURE__ */ new Set();
  _targets = /* @__PURE__ */ new Set();
  constructor(t = []) {
    this._inputs = new Set(t);
    for (let e of this._inputs)
      e._targets.add(this);
  }
  addInput(t) {
    this._inputs.add(t), t._targets.add(this);
  }
  removeInput(t) {
    t._targets.delete(this), this._inputs.delete(t);
  }
  run() {
    if (this._needsRun) {
      for (let t of this._inputs)
        t.run();
      this.update(), this._needsRun = !1;
    }
  }
  setNeedsRunDownstream() {
    for (let t of this._targets)
      t._needsRun || (t._needsRun = !0, t.setNeedsRunDownstream());
  }
  update() {
  }
  destroy() {
    for (let t of this._inputs)
      t._targets.delete(this);
  }
}, vp = class extends a_ {
  _value = null;
  setValue(t) {
    this._value !== t && (this._value = t, this.setNeedsRunDownstream());
  }
  get value() {
    return this.run(), this._value;
  }
};
class vL extends vp {
  constructor(e) {
    super([]), this.setValue(e);
  }
  get value() {
    return super.value;
  }
  set value(e) {
    this.setValue(e);
  }
}
let Uve = class extends vp {
  fn;
  constructor(t, e) {
    super(e), this.fn = t;
  }
  update() {
    this.setValue(this.fn());
  }
}, Hve = class extends vp {
  fn;
  state;
  constructor(t, e) {
    super(e), this.fn = t, this.state = {};
  }
  update() {
    this.setValue(this.fn(this.state));
  }
  destroy() {
    super.destroy(), this.state.destroy && this.state.destroy(), this.state = {};
  }
}, Vve = class extends vp {
  parent;
  condition;
  buildTrue;
  buildFalse;
  context = null;
  currentCondition = null;
  currentNode = null;
  constructor(t, e, r, n) {
    super([e]), this.parent = t, this.condition = e, this.buildTrue = r, this.buildFalse = n;
  }
  update() {
    (this.currentNode == null || this.currentCondition !== this.condition.value) && (this.currentNode && this.removeInput(this.currentNode), this.context?.destroy(), this.context = new Qh(this.parent), this.currentCondition = this.condition.value, this.currentCondition ? this.currentNode = this.buildTrue(this.context) : this.currentNode = this.buildFalse(this.context), this.addInput(this.currentNode)), this.setValue(this.currentNode.value);
  }
  destroy() {
    super.destroy(), this.context?.destroy();
  }
}, Wve = class extends vp {
  parent;
  input;
  build;
  cache;
  constructor(t, e, r) {
    super([e]), this.parent = t, this.input = e, this.build = r, this.cache = /* @__PURE__ */ new Map();
  }
  update() {
    let t = /* @__PURE__ */ new Set(), e = this.input.value.map((r) => {
      if (t.add(r), this.cache.has(r)) {
        let n = this.cache.get(r);
        return n.input.value = r, n.output.value;
      } else {
        let n = new Qh(this.parent), i = new vL(r), o = this.build(n, i);
        return this.cache.set(r, { context: n, input: i, output: o }), this.addInput(o), o.value;
      }
    });
    for (let [r, n] of this.cache)
      t.has(r) || (this.cache.delete(r), this.removeInput(n.output), n.context.destroy());
    this.setValue(e);
  }
  destroy() {
    super.destroy();
    for (let t of this.cache.values())
      t.context.destroy();
  }
}, Gve = class extends vp {
  parent;
  input;
  cases;
  currentCase = null;
  currentNode = null;
  currentContext = null;
  constructor(t, e, r) {
    super([e]), this.parent = t, this.input = e, this.cases = r;
  }
  update() {
    (this.currentNode == null || this.input.value !== this.currentCase) && (this.currentNode && this.removeInput(this.currentNode), this.currentContext?.destroy(), this.currentContext = new Qh(this.parent), this.currentCase = this.input.value, this.currentNode = this.cases[this.currentCase](this.currentContext), this.addInput(this.currentNode)), this.setValue(this.currentNode.value);
  }
  destroy() {
    super.destroy(), this.currentContext?.destroy();
  }
};
class Qh {
  _children;
  _nodes;
  /** Creates a new dataflow context. */
  constructor(e = null) {
    this._children = /* @__PURE__ */ new Set(), this._nodes = /* @__PURE__ */ new Set(), e?._children.add(this);
  }
  /** Destroy the dataflow and all associated states. */
  destroy() {
    for (let e of this._children)
      e.destroy();
    for (let e of this._nodes)
      e.destroy();
    this._children.clear(), this._nodes.clear();
  }
  /** Creates a value node. */
  value(e) {
    let r = new vL(e);
    return this._nodes.add(r), r;
  }
  /** Creates a derived value. */
  derive(e, r) {
    let n = e.map((o) => o instanceof a_ ? o : this.value(o)), i = new Uve(() => r(...n.map((o) => o.value)), n);
    return this._nodes.add(i), i;
  }
  /** Creates a stateful derived value. */
  statefulDerive(e, r) {
    let n = e.map((o) => o instanceof a_ ? o : this.value(o)), i = new Hve((o) => r(o, ...n.map((s) => s.value)), n);
    return this._nodes.add(i), i;
  }
  /** Creates a true or false dataflow depending on the value of the condition. */
  if(e, r, n) {
    let i = new Vve(this, e, r, n);
    return this._nodes.add(i), i;
  }
  switch(e, r) {
    let n = new Gve(this, e, r);
    return this._nodes.add(n), n;
  }
  map(e, r) {
    let n = new Wve(this, e, r);
    return this._nodes.add(n), n;
  }
  assertNotNull(e) {
    return e;
  }
  subgraph() {
    return new Qh(this);
  }
}
function tl(t, e, r, n) {
  if (t.program == null || t.vsSource != r || t.fsSource != n) {
    t.destroy && t.destroy();
    let o = sO(e, e.VERTEX_SHADER, r), s = sO(e, e.FRAGMENT_SHADER, n), a = e.createProgram();
    if (e.attachShader(a, o), e.attachShader(a, s), e.linkProgram(a), !e.getProgramParameter(a, e.LINK_STATUS)) {
      var i = e.getProgramInfoLog(a);
      throw new Error(`failed to link program: ${i}, vertex source: ${r}, fragment source: ${n}`);
    }
    t.program = a, t.vsSource = r, t.fsSource = n, t.destroy = () => {
      e.deleteProgram(a), e.deleteShader(o), e.deleteShader(s);
    }, t.uniforms = {};
    for (let l of (r + n).matchAll(/uniform +[0-9a-zA-Z_]+ +([0-9a-zA-Z_]+) *(;|\[)/g)) {
      let u = l[1];
      t.uniforms[u] = e.getUniformLocation(a, u);
    }
  }
  return { program: t.program, uniforms: t.uniforms ?? {} };
}
function sO(t, e, r) {
  let n = t.createShader(e);
  if (t.shaderSource(n, r), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) {
    var i = t.getShaderInfoLog(n);
    throw new Error(`failed to compile shader: ${i}, source: ${r}`);
  }
  return n;
}
function Ka(t, e, r, n) {
  if (t.buffer == null) {
    let i = e.createBuffer();
    t.buffer = i, t.destroy = () => {
      e.deleteBuffer(i);
    };
  }
  if (t.data !== r) {
    if (t.data = r, e.bindBuffer(e.ARRAY_BUFFER, t.buffer), r instanceof Array)
      switch (n ?? "f32") {
        case "f32":
          e.bufferData(e.ARRAY_BUFFER, new Float32Array(r), e.STATIC_DRAW);
          break;
        case "i32":
          e.bufferData(e.ARRAY_BUFFER, new Int32Array(r), e.STATIC_DRAW);
          break;
        case "u32":
          e.bufferData(e.ARRAY_BUFFER, new Uint32Array(r), e.STATIC_DRAW);
          break;
        case "i16":
          e.bufferData(e.ARRAY_BUFFER, new Int16Array(r), e.STATIC_DRAW);
          break;
        case "u16":
          e.bufferData(e.ARRAY_BUFFER, new Uint16Array(r), e.STATIC_DRAW);
          break;
        case "i8":
          e.bufferData(e.ARRAY_BUFFER, new Int8Array(r), e.STATIC_DRAW);
          break;
        case "u8":
          e.bufferData(e.ARRAY_BUFFER, new Uint8Array(r), e.STATIC_DRAW);
          break;
        default:
          throw new Error("invalid type");
      }
    else
      e.bufferData(e.ARRAY_BUFFER, r, e.STATIC_DRAW);
    e.bindBuffer(e.ARRAY_BUFFER, null);
  }
  return t.buffer;
}
function Kve(t, e, r, n, i) {
  const o = {
    u8: {
      1: [t.R8, t.RED, t.UNSIGNED_BYTE],
      2: [t.RG8, t.RG, t.UNSIGNED_BYTE],
      3: [t.RGB8, t.RGB, t.UNSIGNED_BYTE],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_BYTE]
    },
    u16: {
      1: [t.R8, t.RED, t.UNSIGNED_SHORT],
      2: [t.RG8, t.RG, t.UNSIGNED_SHORT],
      3: [t.RGB8, t.RGB, t.UNSIGNED_SHORT],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_SHORT]
    },
    u32: {
      1: [t.R8, t.RED, t.UNSIGNED_INT],
      2: [t.RG8, t.RG, t.UNSIGNED_INT],
      3: [t.RGB8, t.RGB, t.UNSIGNED_INT],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_INT]
    },
    f32: {
      1: [t.R32F, t.RED, t.FLOAT],
      2: [t.RG32F, t.RG, t.FLOAT],
      3: [t.RGB32F, t.RGB, t.FLOAT],
      4: [t.RGBA32F, t.RGBA, t.FLOAT]
    }
  };
  let [s, a, l] = o[i][n];
  t.texImage2D(t.TEXTURE_2D, 0, s, e, r, 0, a, l, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
}
function Lu(t, e, r, n, i, o) {
  if (t.framebuffer == null || t.texture == null) {
    let a = e.createFramebuffer(), l = e.createTexture();
    e.bindFramebuffer(e.FRAMEBUFFER, a), e.bindTexture(e.TEXTURE_2D, l), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, l, 0), e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), t.framebuffer = a, t.texture = l, t.destroy = () => {
      e.deleteFramebuffer(a), e.deleteTexture(l);
    };
  }
  let s = `${r},${n},${i},${o}`;
  return t.cacheKey != s && (t.cacheKey = s, e.bindTexture(e.TEXTURE_2D, t.texture), Kve(e, r, n, i, o), e.bindTexture(e.TEXTURE_2D, null)), {
    framebuffer: t.framebuffer,
    texture: t.texture,
    width: r,
    height: n
  };
}
function Xve(t) {
  let e = t.squareMaxSize, r = t.samples, n = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, i = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;
    void main() {
      vec4 color = vec4(0.0);
      const int count = ${e};
      int i = -count;
      while(i + 1 <= count) {
        color += texture(image, uv + direction * (float(i) + 0.5) / resolution) * 2.0;
        i += 2;
      }
      if (i <= count) {
        color += texture(image, uv + direction * float(count) / resolution);
      }
      outColor = color;
    }
  `, o = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform sampler2D imageBox;
    uniform vec2 resolution;
    uniform float scaler;
    in vec2 uv;
    out vec4 outColor;

    void main() {
      vec4 color = texture(imageBox, uv);
      if (color != vec4(0.0)) {
        ${r.map(({ x: s, y: a, w: l }) => `color -= texture(image, uv + vec2(${s.toFixed(8)}, ${a.toFixed(8)}) / resolution) * (${l.toFixed(8)})`).join(";")};
      }
      outColor = color * scaler;
    }
  `;
  return { vertex: n, fragment1: i, fragment2: o };
}
function Qve(t, e, r) {
  let n = t.derive([r], Jve), i = t.derive([n], Xve), o = t.statefulDerive(
    [e, t.derive([i], (l) => l.vertex), t.derive([i], (l) => l.fragment1)],
    tl
  ), s = t.statefulDerive(
    [e, t.derive([i], (l) => l.vertex), t.derive([i], (l) => l.fragment2)],
    tl
  ), a = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ka);
  return t.derive(
    [e, a, o, s, r, n],
    (l, u, c, h, d, p) => (g, v, y) => {
      let { width: b, height: k } = v;
      l.disable(l.BLEND), l.enableVertexAttribArray(0), l.bindBuffer(l.ARRAY_BUFFER, u), l.vertexAttribPointer(0, 2, l.FLOAT, !1, 0, 0), l.bindBuffer(l.ARRAY_BUFFER, null), l.useProgram(c.program), l.uniform2f(c.uniforms.resolution, b, k), l.uniform1i(c.uniforms.image, 0), l.bindFramebuffer(l.FRAMEBUFFER, v.framebuffer), l.bindTexture(l.TEXTURE_2D, g), l.uniform2f(c.uniforms.direction, 0, 1), l.drawArrays(l.TRIANGLE_STRIP, 0, 4), l.bindFramebuffer(l.FRAMEBUFFER, y.framebuffer), l.bindTexture(l.TEXTURE_2D, v.texture), l.uniform2f(c.uniforms.direction, 1, 0), l.drawArrays(l.TRIANGLE_STRIP, 0, 4), l.bindFramebuffer(l.FRAMEBUFFER, v.framebuffer), l.activeTexture(l.TEXTURE1), l.bindTexture(l.TEXTURE_2D, y.texture), l.activeTexture(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, g), l.useProgram(h.program), l.uniform2f(h.uniforms.resolution, b, k), l.uniform1i(h.uniforms.image, 0), l.uniform1i(h.uniforms.imageBox, 1);
      let C = 1 / p.totalWeight * d * d * Math.PI;
      l.uniform1f(h.uniforms.scaler, C), l.drawArrays(l.TRIANGLE_STRIP, 0, 4), l.bindFramebuffer(l.FRAMEBUFFER, null), l.useProgram(null), l.activeTexture(l.TEXTURE1), l.bindTexture(l.TEXTURE_2D, null), l.activeTexture(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, null), l.disableVertexAttribArray(0);
    }
  );
}
function aO(t, e, r) {
  let n = Math.sqrt(e * e + r * r);
  if (n < t - Math.sqrt(2) / 2)
    return 1;
  if (n > t + Math.sqrt(2) / 2)
    return 0;
  let i = 2, o = 0;
  for (let s = 0; s < i; s++)
    for (let a = 0; a < i; a++) {
      let l = e + (s + 0.5) / i - 0.5, u = r + (a + 0.5) / i - 0.5;
      Math.sqrt(l * l + u * u) < t && (o += 1);
    }
  return o / i / i;
}
function Jve(t) {
  let e = Math.floor(t + 0.5), r = e, n = aO(t, 0, 0), i = [];
  for (let a = -e; a <= e; a++)
    for (let l = -e; l <= e; l++) {
      let u = n - aO(t, a, l);
      if (!(u <= 0))
        if (i.length > 0 && a == i[i.length - 1].x && l == i[i.length - 1].y + 1) {
          let c = i[i.length - 1].w, h = u;
          i[i.length - 1].y += 1 - c / (c + h), i[i.length - 1].w = c + h;
        } else
          i.push({ x: a, y: l, w: u });
    }
  i = i.sort((a, l) => a.y != l.y ? a.y - l.y : a.x - l.x);
  let o = [];
  for (let { x: a, y: l, w: u } of i)
    if (o.length > 0 && l == o[o.length - 1].y && a == o[o.length - 1].x + 1) {
      let c = o[o.length - 1].w, h = u;
      o[o.length - 1].x += 1 - c / (c + h), o[o.length - 1].w = c + h;
    } else
      o.push({ x: a, y: l, w: u });
  let s = -o.reduce((a, l) => a + l.w, 0);
  return s += n * (1 + r * 2) * (1 + r * 2), { squareMaxSize: r, squareWeight: n, samples: o, totalWeight: s };
}
function Yve(t) {
  let e;
  return t ? e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      layout(location=0) in float x;
      layout(location=1) in float y;
      layout(location=2) in int category;
      out vec4 color;
      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        if (category == 0) {
          color = vec4(1, 0, 0, 0);
        } else if (category == 1) {
          color = vec4(0, 1, 0, 0);
        } else if (category == 2) {
          color = vec4(0, 0, 1, 0);
        } else if (category == 3) {
          color = vec4(0, 0, 0, 1);
        }
        gl_PointSize = 1.0;
      }
    ` : e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      layout(location=0) in float x;
      layout(location=1) in float y;
      out vec4 color;
      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        color = vec4(1, 0, 0, 0);
        gl_PointSize = 1.0;
      }
    `, { vertex: e, fragment: `#version 300 es
    precision highp float;
    in vec4 color;
    out vec4 outColor;
    void main() {
      outColor = color;
    }
  ` };
}
function l_(t, e, r, n, i, o) {
  let s = i != null, a = Yve(s), l = t.statefulDerive([e, a.vertex, a.fragment], tl);
  return t.derive([e, l, r, n, i, o], (u, c, h, d, p, g) => (v) => {
    u.enable(u.BLEND), u.blendFunc(u.ONE, u.ONE), u.useProgram(c.program), u.enableVertexAttribArray(0), u.bindBuffer(u.ARRAY_BUFFER, h), u.vertexAttribPointer(0, 1, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(1), u.bindBuffer(u.ARRAY_BUFFER, d), u.vertexAttribPointer(1, 1, u.FLOAT, !1, 0, 0), p != null && (u.enableVertexAttribArray(2), u.bindBuffer(u.ARRAY_BUFFER, p), u.vertexAttribIPointer(2, 1, u.BYTE, 0, 0)), u.bindBuffer(u.ARRAY_BUFFER, null), u.uniformMatrix3fv(c.uniforms.matrix, !1, v), u.drawArrays(u.POINTS, 0, g), u.disableVertexAttribArray(0), u.disableVertexAttribArray(1), p != null && u.disableVertexAttribArray(2), u.useProgram(null);
  });
}
function Zve() {
  return { vertex: `#version 300 es
    precision highp float;
    uniform vec2 xyScaler;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy * xyScaler, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform float gamma;
    in vec2 uv;
    out vec4 outColor;
    void main() {
      vec4 color = texture(source, uv);
      color.rgb = pow(color.rgb, vec3(1.0 / gamma));
      outColor = color;
    }
  ` };
}
function yL(t, e) {
  let { vertex: r, fragment: n } = Zve(), i = t.statefulDerive([e, r, n], tl), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ka);
  return t.derive([e, i, o], (s, a, l) => (u, c, h, d) => {
    s.disable(s.BLEND), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.xyScaler, h ?? 1, d ?? 1), s.uniform1f(a.uniforms.gamma, c ?? 2.2), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
  });
}
function bL(t) {
  return Math.ceil(t * 3);
}
function eye(t) {
  let e = bL(t), r = [];
  for (let a = -e; a <= e; a++)
    r.push(Math.exp(-a * a / t / t / 2));
  let n = r.reduce((a, l) => a + l, 0);
  r = r.map((a) => a / n);
  let i = rye(r).map(([a, l]) => [a - e, l]), o = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, s = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;

    void main() {
      vec4 color = vec4(0.0);
      ${i.map(([a, l]) => `color += texture(image, uv + direction * vec2(${a.toFixed(10)}) / resolution) * ${l.toFixed(10)};`).join(`
`)}
      outColor = color;
    }
  `;
  return { vertex: o, fragment: s };
}
function tye(t, e, r) {
  let n = t.derive([r], eye), i = t.statefulDerive(
    [e, t.derive([n], (s) => s.vertex), t.derive([n], (s) => s.fragment)],
    tl
  ), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ka);
  return t.derive([e, o, i, r], (s, a, l, u) => (c, h, d) => {
    let { width: p, height: g } = h;
    s.disable(s.BLEND), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, a), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.useProgram(l.program), s.uniform2f(l.uniforms.resolution, p, g), s.uniform1i(l.uniforms.image, 0), s.bindFramebuffer(s.FRAMEBUFFER, d.framebuffer), s.bindTexture(s.TEXTURE_2D, c), s.uniform2f(l.uniforms.direction, 0, 1), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.bindFramebuffer(s.FRAMEBUFFER, h.framebuffer), s.bindTexture(s.TEXTURE_2D, d.texture), s.uniform2f(l.uniforms.direction, 1, 0), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.bindFramebuffer(s.FRAMEBUFFER, null), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
  });
}
function rye(t) {
  let e = [];
  for (let r = 0; r < t.length; r += 2)
    if (r + 1 < t.length) {
      let n = t[r], i = t[r + 1], o = 1 - n / (n + i);
      if (o >= 0 && o <= 1) {
        let s = n + i;
        s != 0 && e.push([r + o, s]);
      } else
        e.push([r, t[r]]), e.push([r + 1, t[r + 1]]);
    } else
      e.push([r, t[r]]);
  return e;
}
function nye(t) {
  return Math.ceil(t * 3);
}
function iye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;

    uniform float weight0;
    uniform vec3 distances;
    uniform vec3 weights;

    void main() {
      vec4 color = texture(image, uv) * weight0;
      if (weights.x != 0.0) {
        color += texture(image, uv + direction * vec2(distances.x) / resolution) * weights.x;
        color += texture(image, uv - direction * vec2(distances.x) / resolution) * weights.x;
      }
      if (weights.y != 0.0) {
        color += texture(image, uv + direction * vec2(distances.y) / resolution) * weights.y;
        color += texture(image, uv - direction * vec2(distances.y) / resolution) * weights.y;
      }
      if (weights.z != 0.0) {
        color += texture(image, uv + direction * vec2(distances.z) / resolution) * weights.z;
        color += texture(image, uv - direction * vec2(distances.z) / resolution) * weights.z;
      }
      outColor = color;
    }
  ` };
}
function oye(t, e, r) {
  let { vertex: n, fragment: i } = iye(), o = t.statefulDerive([e, n, i], tl), s = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ka);
  return t.derive([e, s, o], (a, l, u) => (c, h, d) => {
    let { width: p, height: g } = h;
    a.disable(a.BLEND), a.enableVertexAttribArray(0), a.bindBuffer(a.ARRAY_BUFFER, l), a.vertexAttribPointer(0, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, null), a.useProgram(u.program), a.uniform2f(u.uniforms.resolution, p, g), a.uniform1i(u.uniforms.image, 0);
    let v = c, y = d, b = h;
    for (let k = 0; k < 2; k++) {
      a.uniform2f(u.uniforms.direction, k, 1 - k);
      for (let [C, S, _] of sye) {
        a.bindFramebuffer(a.FRAMEBUFFER, y.framebuffer), a.bindTexture(a.TEXTURE_2D, v), a.uniform1fv(u.uniforms.weight0, S), a.uniform3fv(u.uniforms.distances, C), a.uniform3fv(u.uniforms.weights, _), a.drawArrays(a.TRIANGLE_STRIP, 0, 4), v = y.texture;
        let D = y;
        y = b, b = D;
      }
    }
    a.bindFramebuffer(a.FRAMEBUFFER, null), a.useProgram(null), a.bindTexture(a.TEXTURE_2D, null), a.disableVertexAttribArray(0);
  });
}
const sye = [
  [[1, 2, 3], [0.2288468365182578], [0.18230006506971572, 0.1356122230111784, 0.06766429365997693]],
  [[2, 6, 10], [0.09116254014100238], [0.23317759354726447, 0.18385867277788717, 0.03738246360434722]],
  [[3, 10, 20], [0.2950645715317288], [0.010918865853671198, 0.23773695670296047, 0.10381189167750389]],
  [[4, 16, 30], [0.20085957073474772], [0.14463019087130788, 0.17934533765938643, 0.07559468610193185]]
];
function aye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform float densityScaler;
    uniform float quantizationStep;
    uniform vec4 channelMask;
    uniform vec4 color;
    uniform float globalAlpha;

    in vec2 uv;
    out vec4 outColor;

    float sample_density(vec2 uv) {
      float d = dot(texture(source, uv), channelMask) * densityScaler;
      d = min(1.0, max(0.0, d));
      d = floor(d / quantizationStep);
      return d;
    }

    void main() {
      // Run the Sobel operator.
      float v = sample_density(uv);
      float v11 = sample_density(uv + vec2(-1, -1) / resolution);
      float v12 = sample_density(uv + vec2(-1,  0) / resolution);
      float v13 = sample_density(uv + vec2(-1, +1) / resolution);
      float v21 = sample_density(uv + vec2( 0, -1) / resolution);
      float v23 = sample_density(uv + vec2( 0, +1) / resolution);
      float v31 = sample_density(uv + vec2(+1, -1) / resolution);
      float v32 = sample_density(uv + vec2(+1,  0) / resolution);
      float v33 = sample_density(uv + vec2(+1, +1) / resolution);
      float gx = v11 + v12 * 2.0 + v13 - v31 - v32 * 2.0 - v33;
      float gy = v11 + v21 * 2.0 + v31 - v13 - v23 * 2.0 - v33;
      // Derive alpha value from the result.
      float alpha = length(vec2(gx, gy)) * 0.2;
      alpha = min(1.0, max(0.0, alpha));
      outColor = color * alpha * globalAlpha;
    }
  ` };
}
function lye(t, e) {
  let { vertex: r, fragment: n } = aye(), i = t.statefulDerive([e, r, n], tl), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ka);
  return t.derive(
    [e, i, o],
    (s, a, l) => (u, c, h, d, p, g) => {
      s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u.texture), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.resolution, u.width, u.height), s.uniform1f(a.uniforms.densityScaler, c), s.uniform1f(a.uniforms.quantizationStep, h), s.uniform1f(a.uniforms.globalAlpha, d), s.uniform4fv(a.uniforms.channelMask, p), s.uniform4fv(a.uniforms.color, g), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
    }
  );
}
function uye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
    `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform float densityScaler;
    uniform float quantizationStep;

    uniform mat4 colorMatrix;
    uniform int isDarkMode;
    uniform float globalAlpha;

    in vec2 uv;
    out vec4 outColor;

    /* Combine alphas with symmetric blending equation f(a, b) = a + b - ab. */
    float combine_alphas(vec4 alphas) {
      float r = alphas.x + alphas.y - alphas.x * alphas.y;
      r = r + alphas.z - r * alphas.z;
      r = r + alphas.w - r * alphas.w;
      return r;
    }

    void main() {
      vec4 density = texture(source, uv) * densityScaler;

      if (density.x > 1.0 || density.y > 1.0 || density.z > 1.0 || density.w > 1.0) {
        density = density / max(max(max(density.x, density.y), density.z), density.w);
      } else {
        density = floor(density / quantizationStep) * quantizationStep;
      }

      if (density.x + density.y + density.z + density.w == 0.0) {
        discard;
      }

      float alpha = combine_alphas(density);

      density *= alpha / (density.x + density.y + density.z + density.w);

      vec3 c1 = colorMatrix[0].rgb * density.x;
      vec3 c2 = colorMatrix[1].rgb * density.y;
      vec3 c3 = colorMatrix[2].rgb * density.z;
      vec3 c4 = colorMatrix[3].rgb * density.w;
      vec3 c;

      if (isDarkMode == 0) {
        c = vec3(1.0) - alpha + c1 + c2 + c3 + c4;
      } else {
        c = c1 + c2 + c3 + c4;
      }

      outColor = vec4(c, 1.0) * alpha * globalAlpha;
    }
  ` };
}
function cye(t, e) {
  let { vertex: r, fragment: n } = uye(), i = t.statefulDerive([e, r, n], tl), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ka);
  return t.derive(
    [e, i, o],
    (s, a, l) => (u, c, h, d, p, g) => {
      s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u.texture), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.resolution, u.width, u.height), s.uniform1f(a.uniforms.densityScaler, c), s.uniform1f(a.uniforms.quantizationStep, h), s.uniform1f(a.uniforms.globalAlpha, d), s.uniform1i(a.uniforms.isDarkMode, g == "dark" ? 1 : 0), s.uniformMatrix4fv(a.uniforms.colorMatrix, !1, p), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
    }
  );
}
function hye(t) {
  let e;
  return t ? e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      uniform float point_size;
      uniform float alpha;
      uniform vec4 colorScheme[64];

      layout(location=0) in float x;
      layout(location=1) in float y;
      layout(location=2) in int category;

      out vec4 color;

      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        if (category < 64) {
          color = colorScheme[category];
        } else {
          color = vec4(0.5, 0.5, 0.5, 1);
        }
        color *= alpha;
        gl_PointSize = point_size;
      }
    ` : e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      uniform float point_size;
      uniform vec4 colorScheme;
      uniform float alpha;

      layout(location=0) in float x;
      layout(location=1) in float y;

      out vec4 color;

      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        color = colorScheme;
        color *= alpha;
        gl_PointSize = point_size;
      }
    `, { vertex: e, fragment: `#version 300 es
    precision highp float;
    uniform float point_size;
    in vec4 color;
    out vec4 outColor;
    void main() {
      float r = length(gl_PointCoord.xy - vec2(0.5, 0.5)) * point_size;
      float a = max(0.0, min(1.0, point_size / 2.0 - r));
      outColor = color * a;
    }
  ` };
}
function lO(t, e, r, n, i, o) {
  let s = i != null, a = hye(s), l = t.statefulDerive([e, a.vertex, a.fragment], tl);
  return t.derive(
    [e, l, r, n, i, o],
    (u, c, h, d, p, g) => (v, y, b, k) => {
      u.enable(u.BLEND), u.blendFunc(u.ONE, u.ONE_MINUS_SRC_ALPHA), u.useProgram(c.program), u.enableVertexAttribArray(0), u.bindBuffer(u.ARRAY_BUFFER, h), u.vertexAttribPointer(0, 1, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(1), u.bindBuffer(u.ARRAY_BUFFER, d), u.vertexAttribPointer(1, 1, u.FLOAT, !1, 0, 0), p != null && (u.enableVertexAttribArray(2), u.bindBuffer(u.ARRAY_BUFFER, p), u.vertexAttribIPointer(2, 1, u.BYTE, 0, 0)), u.bindBuffer(u.ARRAY_BUFFER, null), u.uniformMatrix3fv(c.uniforms.matrix, !1, v), u.uniform1f(c.uniforms.point_size, y * 2), u.uniform1f(c.uniforms.alpha, b), s ? u.uniform4fv(c.uniforms.colorScheme, k) : u.uniform4fv(c.uniforms.colorScheme, k.slice(0, 4)), u.drawArrays(u.POINTS, 0, g), u.disableVertexAttribArray(0), u.disableVertexAttribArray(1), p != null && u.disableVertexAttribArray(2), u.useProgram(null);
    }
  );
}
function fye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform mat4 colorMatrix;
    uniform float pointAlpha;
    uniform float globalAlpha;
    uniform int isDarkMode;
    in vec2 uv;
    out vec4 outColor;

    /* Combine alphas with symmetric blending equation f(a, b) = a + b - ab. */
    float combine_alphas(vec4 alphas) {
      float r = alphas.x + alphas.y - alphas.x * alphas.y;
      r = r + alphas.z - r * alphas.z;
      r = r + alphas.w - r * alphas.w;
      return r;
    }

    void main() {
      vec4 count = texture(source, uv);
      vec4 alphas = pointAlpha >= 0.999
        ? vec4(count.x > 0.0 ? 1.0 : 0.0, count.y > 0.0 ? 1.0 : 0.0, count.z > 0.0 ? 1.0 : 0.0, count.w > 0.0 ? 1.0 : 0.0)
        : vec4(1.0) - pow(vec4(1.0 - pointAlpha), count);
      float a = combine_alphas(alphas);
      if (a <= 0.0) { discard; }
      alphas *= a / (alphas.x + alphas.y + alphas.z + alphas.w);

      vec3 c1 = colorMatrix[0].rgb * alphas.x;
      vec3 c2 = colorMatrix[1].rgb * alphas.y;
      vec3 c3 = colorMatrix[2].rgb * alphas.z;
      vec3 c4 = colorMatrix[3].rgb * alphas.w;
      vec3 c;
      if (isDarkMode == 0) {
        c = vec3(1.0) - a + c1 + c2 + c3 + c4;
      } else {
        c = c1 + c2 + c3 + c4;
      }
      outColor = vec4(c, 1.0) * a * globalAlpha;
    }
  ` };
}
function dye(t, e) {
  let { vertex: r, fragment: n } = fye(), i = t.statefulDerive([e, r, n], tl), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Ka);
  return t.derive(
    [e, i, o],
    (s, a, l) => (u, c, h, d, p) => {
      s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.enableVertexAttribArray(0), s.bindBuffer(s.ARRAY_BUFFER, l), s.vertexAttribPointer(0, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, null), s.bindTexture(s.TEXTURE_2D, u.texture), s.useProgram(a.program), s.uniform1i(a.uniforms.source, 0), s.uniform2f(a.uniforms.resolution, u.width, u.height), s.uniform1f(a.uniforms.pointAlpha, c), s.uniform1f(a.uniforms.globalAlpha, h), s.uniform1i(a.uniforms.isDarkMode, p == "dark" ? 1 : 0), s.uniformMatrix4fv(a.uniforms.colorMatrix, !1, d), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.useProgram(null), s.bindTexture(s.TEXTURE_2D, null), s.disableVertexAttribArray(0);
    }
  );
}
let pye = class {
  props;
  viewport;
  df;
  gl;
  renderInputs;
  dataBuffers;
  renderer;
  constructor(t, e, r) {
    this.props = {
      mode: "points",
      colorScheme: "light",
      x: new Float32Array(),
      y: new Float32Array(),
      category: null,
      categoryCount: 1,
      categoryColors: null,
      viewportX: 0,
      viewportY: 0,
      viewportScale: 1,
      pointSize: 1,
      pointAlpha: 1,
      pointsAlpha: 1,
      densityScaler: 1,
      densityBandwidth: 1,
      densityQuantizationStep: 0.1,
      contoursAlpha: 1,
      densityAlpha: 1,
      gamma: 2.2,
      width: e,
      height: r
    }, this.viewport = new Fx({ x: 0, y: 0, scale: 1 }, e, r);
    let n = new Qh(), i = n.value(t);
    this.df = n, this.gl = i, this.renderInputs = {
      mode: n.value(this.props.mode),
      colorScheme: n.value(this.props.colorScheme),
      xData: n.value(this.props.x),
      yData: n.value(this.props.y),
      categoryData: n.value(this.props.category),
      categoryCount: n.value(this.props.categoryCount),
      matrix: n.value(pL()),
      width: n.value(e),
      height: n.value(r),
      pointSize: n.value(this.props.pointSize),
      densityBandwidth: n.value(this.props.densityBandwidth)
    }, this.dataBuffers = mye(n, i, this.renderInputs), this.renderer = gye(n, i, this.renderInputs, this.dataBuffers);
  }
  setProps(t) {
    let e = !1, r;
    for (r in t)
      t[r] !== this.props[r] && (this.props[r] = t[r], e = !0);
    return this.viewport.update(
      { x: this.props.viewportX, y: this.props.viewportY, scale: this.props.viewportScale },
      this.props.width,
      this.props.height
    ), this.renderInputs.mode.value = this.props.mode, this.renderInputs.colorScheme.value = this.props.colorScheme, this.renderInputs.xData.value = this.props.x, this.renderInputs.yData.value = this.props.y, this.renderInputs.categoryData.value = this.props.category, this.props.category != null ? this.renderInputs.categoryCount.value = this.props.categoryCount : this.renderInputs.categoryCount.value = 1, this.renderInputs.matrix.value = this.viewport.matrix(), this.renderInputs.width.value = this.props.width, this.renderInputs.height.value = this.props.height, this.renderInputs.pointSize.value = this.props.pointSize, this.renderInputs.densityBandwidth.value = this.props.densityBandwidth, e;
  }
  render() {
    this.renderer.value(this.props);
  }
  destroy() {
    this.df.destroy();
  }
  async densityMap(t, e, r, n) {
    let i = this.df.subgraph(), o = bye(i, this.gl, this.dataBuffers, i.value(t), i.value(e), i.value(r)), { x: s, y: a, scale: l } = n, u = [l, 0, 0, 0, l, 0, -s * l, -a * l, 1], c = o.value(u), h = gL(u);
    return i.destroy(), {
      data: c,
      width: t,
      height: e,
      coordinateAtPixel: (d, p) => {
        let g = d / t * 2 - 1, v = p / e * 2 - 1, y = mL([g, v, 1], h);
        return { x: y[0], y: y[1] };
      }
    };
  }
};
function mye(t, e, r) {
  const n = t.statefulDerive([e, r.xData, "f32"], Ka), i = t.statefulDerive([e, r.yData, "f32"], Ka), o = t.if(
    t.derive([r.categoryData], (a) => a != null),
    (a) => a.statefulDerive([e, a.assertNotNull(r.categoryData), "u8"], Ka),
    (a) => a.value(null)
  ), s = t.derive([r.xData], (a) => a.length);
  return { x: n, y: i, category: o, count: s };
}
function gye(t, e, r, n) {
  return t.switch(r.mode, {
    points: (i) => vye(i, e, r, n),
    density: (i) => yye(i, e, r, n)
  });
}
function vye(t, e, r, n) {
  const i = t.derive([r.categoryCount], (l) => l > 1), o = t.statefulDerive([e, r.width, r.height, 4, "f32"], Lu);
  let s = t.if(
    i,
    (l) => lO(l, e, n.x, n.y, l.assertNotNull(n.category), n.count),
    (l) => lO(l, e, n.x, n.y, null, n.count)
  ), a = yL(t, e);
  return t.derive(
    [e, o, s, a, r.colorScheme, r.matrix, r.categoryCount],
    (l, u, c, h, d, p, g) => (v) => {
      let y = [], b = v.categoryColors ?? gp(v.categoryCount);
      for (let k = 0; k < g; k++)
        if (k < b.length) {
          let { r: C, g: S, b: _ } = KS(b[k]);
          C = Math.pow(C, v.gamma), S = Math.pow(S, v.gamma), _ = Math.pow(_, v.gamma), y = y.concat([C, S, _, 1]);
        } else
          y = y.concat([0.5, 0.5, 0.5, 1]);
      l.bindFramebuffer(l.FRAMEBUFFER, u.framebuffer), l.viewport(0, 0, u.width, u.height), d == "light" ? l.clearColor(1, 1, 1, 1) : l.clearColor(0, 0, 0, 1), l.clear(l.COLOR_BUFFER_BIT), c(p, Math.max(3, v.pointSize), v.pointAlpha * v.pointsAlpha, y), l.bindFramebuffer(l.FRAMEBUFFER, null), l.viewport(0, 0, v.width, v.height), h(u.texture, v.gamma);
    }
  );
}
function yye(t, e, r, n) {
  let i = t.derive([r.densityBandwidth], (C) => nye(C) + 1), o = t.derive([r.width, i], (C, S) => C + S * 2), s = t.derive([r.height, i], (C, S) => C + S * 2);
  const a = t.derive([r.categoryCount], (C) => C > 1), l = t.statefulDerive([e, o, s, 4, "f32"], Lu), u = t.statefulDerive([e, o, s, 4, "f32"], Lu), c = t.statefulDerive([e, o, s, 4, "f32"], Lu), h = t.statefulDerive([e, o, s, 4, "f32"], Lu);
  let d = t.if(
    a,
    (C) => l_(C, e, n.x, n.y, C.assertNotNull(n.category), n.count),
    (C) => l_(C, e, n.x, n.y, null, n.count)
  ), p = Qve(t, e, r.pointSize), g = oye(t, e, r.densityBandwidth), v = dye(t, e), y = cye(t, e), b = lye(t, e), k = yL(t, e);
  return t.derive(
    [
      e,
      l,
      u,
      c,
      h,
      r.colorScheme,
      r.matrix,
      d,
      p,
      g,
      v,
      y,
      b,
      k
    ],
    (C, S, _, D, A, O, M, z, N, P, I, B, $, j) => (U) => {
      let H = U.categoryColors ?? gp(U.categoryCount), G = [];
      for (let ie = 0; ie < 4; ie++)
        if (ie < H.length) {
          let { r: ce, g: Ce, b: Me } = KS(H[ie]);
          ce = Math.pow(ce, U.gamma), Ce = Math.pow(Ce, U.gamma), Me = Math.pow(Me, U.gamma), G = G.concat([ce, Ce, Me, 1]);
        } else
          G = G.concat([0.5, 0.5, 0.5, 1]);
      let re = U.width / _.width, ne = U.height / _.height, se = XS([re, 0, 0, 0, ne, 0, 0, 0, 1], M);
      if (C.bindFramebuffer(C.FRAMEBUFFER, S.framebuffer), C.viewport(0, 0, S.width, S.height), C.clearColor(0, 0, 0, 0), C.clear(C.COLOR_BUFFER_BIT), z(se), C.bindFramebuffer(C.FRAMEBUFFER, _.framebuffer), C.viewport(0, 0, _.width, _.height), O == "light" ? C.clearColor(1, 1, 1, 1) : C.clearColor(0, 0, 0, 1), C.clear(C.COLOR_BUFFER_BIT), U.pointAlpha > 0 && U.pointsAlpha > 0 && (N(S.texture, D, A), C.bindFramebuffer(C.FRAMEBUFFER, _.framebuffer), I(D, U.pointAlpha, U.pointsAlpha, G, O)), U.densityScaler > 0 && (U.densityAlpha > 0 || U.contoursAlpha > 0) && (P(S.texture, D, A), C.bindFramebuffer(C.FRAMEBUFFER, _.framebuffer), U.densityAlpha > 0 && B(
        D,
        U.densityScaler,
        U.densityQuantizationStep,
        U.densityAlpha,
        G,
        O
      ), U.contoursAlpha > 0))
        for (let ie = 0; ie < H.length; ie++) {
          let ce = [0, 0, 0, 0];
          ce[ie] = 1, $(
            D,
            U.densityScaler,
            U.densityQuantizationStep,
            U.contoursAlpha,
            ce,
            G.slice(ie * 4, ie * 4 + 4)
          );
        }
      C.bindFramebuffer(C.FRAMEBUFFER, null), C.viewport(0, 0, U.width, U.height), j(_.texture, U.gamma, 1 / re, 1 / ne);
    }
  );
}
function bye(t, e, r, n, i, o) {
  let s = t.derive([o], (g) => bL(g) + 1), a = t.derive([n, s], (g, v) => g + v * 2), l = t.derive([i, s], (g, v) => g + v * 2);
  const u = t.statefulDerive([e, a, l, 1, "f32"], Lu), c = t.statefulDerive([e, a, l, 1, "f32"], Lu), h = t.statefulDerive([e, a, l, 1, "f32"], Lu);
  let d = l_(t, e, r.x, r.y, null, r.count), p = tye(t, e, o);
  return t.derive(
    [e, s, n, i, u, c, h, d, p],
    (g, v, y, b, k, C, S, _, D) => (A) => {
      let O = y / k.width, M = b / k.height, z = XS([O, 0, 0, 0, M, 0, 0, 0, 1], A);
      g.bindFramebuffer(g.FRAMEBUFFER, k.framebuffer), g.viewport(0, 0, k.width, k.height), g.clearColor(0, 0, 0, 0), g.clear(g.COLOR_BUFFER_BIT), _(z), D(k.texture, C, S), g.bindFramebuffer(g.FRAMEBUFFER, C.framebuffer);
      let N = new Float32Array(y * b);
      return g.readPixels(v, v, y, b, g.RED, g.FLOAT, N), g.bindFramebuffer(g.FRAMEBUFFER, null), N;
    }
  );
}
let xye = class {
  i32View;
  u32View;
  f32View;
  offset;
  constructor(t) {
    this.i32View = new Int32Array(t), this.u32View = new Uint32Array(t), this.f32View = new Float32Array(t), this.offset = 0;
  }
  align2() {
    this.offset % 2 != 0 && (this.offset += 2 - this.offset % 2);
  }
  align4() {
    this.offset % 4 != 0 && (this.offset += 4 - this.offset % 4);
  }
  f32(t) {
    this.f32View[this.offset++] = t;
  }
  u32(t) {
    this.u32View[this.offset++] = t;
  }
  i32(t) {
    this.i32View[this.offset++] = t;
  }
  vec2f(t, e) {
    this.align2(), this.f32View[this.offset++] = t, this.f32View[this.offset++] = e;
  }
  vec3f(t, e, r) {
    this.align4(), this.f32View[this.offset++] = t, this.f32View[this.offset++] = e, this.f32View[this.offset++] = r;
  }
  vec4f(t, e, r, n) {
    this.align4(), this.f32View[this.offset++] = t, this.f32View[this.offset++] = e, this.f32View[this.offset++] = r, this.f32View[this.offset++] = n;
  }
  mat3x3f(t) {
    this.vec3f(t[0], t[1], t[2]), this.vec3f(t[3], t[4], t[5]), this.vec3f(t[6], t[7], t[8]);
  }
  byteOffset() {
    return this.offset * 4;
  }
};
function wye(t, e) {
  let r = new ArrayBuffer(4288), n = t.statefulDerive(
    [e, 4288, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.VERTEX],
    sd
  );
  return {
    buffer: n,
    update: t.derive([e, n], (i, o) => (s) => {
      let a = new xye(r);
      a.u32(s.count), a.u32(s.category_count), a.i32(s.framebuffer_width), a.i32(s.framebuffer_height), a.i32(s.density_width), a.i32(s.density_height), a.f32(s.gamma), a.f32(s.point_size), a.f32(s.point_alpha), a.f32(s.points_alpha), a.f32(s.density_scaler), a.f32(s.quantization_step), a.f32(s.density_alpha), a.f32(s.contours_alpha), a.mat3x3f(s.matrix), a.vec2f(...s.view_xy_scaler), a.vec4f(...s.kde_causal), a.vec4f(...s.kde_anticausal), a.vec4f(...s.kde_a), a.vec4f(...s.background_color);
      let l = s.gamma;
      for (let u = 0; u < Math.min(s.category_colors.length, 256); u++) {
        let { r: c, g: h, b: d, a: p } = s.category_colors[u];
        c = Math.pow(c, l), h = Math.pow(h, l), d = Math.pow(d, l), a.vec4f(c, h, d, p);
      }
      i.queue.writeBuffer(o, 0, r, 0, a.byteOffset());
    })
  };
}
const Pk = 64, Rk = 64;
function xL(t, e, r, n, i, o) {
  let s = t.derive(
    [e, r, n.layouts],
    (a, l, u) => a.createComputePipeline({
      layout: a.createPipelineLayout({ bindGroupLayouts: [u.group0, u.group1, u.group2A] }),
      compute: { module: l, entryPoint: "accumulate" }
    })
  );
  return t.derive(
    [
      s,
      n.group0,
      n.group1,
      n.group2A,
      o.countBuffer,
      i.count
    ],
    (a, l, u, c, h, d) => (p) => {
      if (p.clearBuffer(h), d == 0)
        return;
      let g = p.beginComputePass();
      g.setPipeline(a), g.setBindGroup(0, l), g.setBindGroup(1, u), g.setBindGroup(2, c), d <= Pk * Rk ? g.dispatchWorkgroups(Math.ceil(d / Pk)) : g.dispatchWorkgroups(Rk, Math.ceil(d / (Pk * Rk))), g.end();
    }
  );
}
function kye(t) {
  const { COMPUTE: e, VERTEX: r, FRAGMENT: n } = GPUShaderStage;
  return {
    // Group 0
    group0: t.createBindGroupLayout({
      entries: [{ binding: 0, visibility: e | r | n, buffer: { type: "uniform" } }]
    }),
    // Group 1
    group1: t.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: e | r, buffer: { type: "read-only-storage" } },
        { binding: 1, visibility: e | r, buffer: { type: "read-only-storage" } },
        { binding: 2, visibility: e | r, buffer: { type: "read-only-storage" } }
      ]
    }),
    // Group 2
    group2A: t.createBindGroupLayout({
      entries: [{ binding: 0, visibility: e | n, buffer: { type: "storage" } }]
    }),
    group2B: t.createBindGroupLayout({
      entries: [
        { binding: 1, visibility: e | n, buffer: { type: "storage" } },
        { binding: 2, visibility: e | n, buffer: { type: "storage" } }
      ]
    }),
    // Group 3
    group3: t.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    })
  };
}
function wL(t, e, r, n, i) {
  let o = t.derive([e], (h) => kye(h)), s = t.derive(
    [e, o, r],
    (h, d, p) => h.createBindGroup({
      layout: d.group0,
      entries: [{ binding: 0, resource: { buffer: p } }]
    })
  ), a = t.derive(
    [e, o, n.x, n.y, n.category],
    (h, d, p, g, v) => h.createBindGroup({
      layout: d.group1,
      entries: [
        { binding: 0, resource: { buffer: p } },
        { binding: 1, resource: { buffer: g } },
        { binding: 2, resource: { buffer: v ?? p } }
      ]
    })
  ), l = t.derive(
    [e, o, i.countBuffer, i.blurBuffer],
    (h, d, p, g) => h.createBindGroup({
      layout: d.group2A,
      entries: [{ binding: 0, resource: { buffer: p } }]
    })
  ), u = t.derive(
    [e, o, i.countBuffer, i.blurBuffer],
    (h, d, p, g) => h.createBindGroup({
      layout: d.group2B,
      entries: [
        { binding: 1, resource: { buffer: p } },
        { binding: 2, resource: { buffer: g } }
      ]
    })
  ), c = t.derive(
    [e, o, i.colorTexture, i.alphaTexture],
    (h, d, p, g) => h.createBindGroup({
      layout: d.group3,
      entries: [
        { binding: 0, resource: h.createSampler({}) },
        { binding: 1, resource: p.createView() },
        { binding: 2, resource: g.createView() }
      ]
    })
  );
  return {
    layouts: o,
    group0: s,
    group1: a,
    group2A: l,
    group2B: u,
    group3: c
  };
}
function Cye(t, e, r, n, i) {
  const o = t.derive(
    [e, r, n.layouts],
    (s, a, l) => s.createRenderPipeline({
      layout: s.createPipelineLayout({
        bindGroupLayouts: [l.group0, l.group1, l.group2B]
      }),
      vertex: { entryPoint: "draw_density_map_vs", module: a },
      fragment: {
        entryPoint: "draw_density_map_fs",
        module: a,
        targets: [
          {
            format: i.colorTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          },
          {
            format: i.alphaTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [
      o,
      n.group0,
      n.group1,
      n.group2B,
      i.colorTexture,
      i.alphaTexture
    ],
    (s, a, l, u, c, h) => (d) => {
      let p = d.beginRenderPass({
        colorAttachments: [
          { loadOp: "load", storeOp: "store", view: c.createView() },
          { loadOp: "load", storeOp: "store", view: h.createView() }
        ]
      });
      p.setPipeline(s), p.setBindGroup(0, a), p.setBindGroup(1, l), p.setBindGroup(2, u), p.draw(4), p.end();
    }
  );
}
function _ye(t, e, r, n, i, o) {
  const s = t.derive(
    [e, r, n.layouts],
    (a, l, u) => a.createRenderPipeline({
      layout: a.createPipelineLayout({ bindGroupLayouts: [u.group0, u.group1] }),
      vertex: { entryPoint: "points_vs", module: l },
      fragment: {
        entryPoint: "points_fs",
        module: l,
        targets: [
          {
            format: o.colorTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          },
          {
            format: o.alphaTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [
      s,
      n.group0,
      n.group1,
      i.count,
      o.colorTexture,
      o.alphaTexture
    ],
    (a, l, u, c, h, d) => (p) => {
      let g = p.beginRenderPass({
        colorAttachments: [
          { clearValue: [0, 0, 0, 0], loadOp: "clear", storeOp: "store", view: h.createView() },
          { clearValue: [0, 0, 0, 0], loadOp: "clear", storeOp: "store", view: d.createView() }
        ]
      });
      g.setPipeline(a), g.setBindGroup(0, l), g.setBindGroup(1, u), c > 0 && g.draw(4, c), g.end();
    }
  );
}
function Sye(t, e, r, n, i) {
  const o = t.derive(
    [e, r, i.layouts],
    (s, a, l) => s.createRenderPipeline({
      layout: s.createPipelineLayout({
        bindGroupLayouts: [l.group0, l.group1, l.group2B, l.group3]
      }),
      vertex: { entryPoint: "gamma_correction_vs", module: a },
      fragment: { entryPoint: "gamma_correction_fs", module: a, targets: [{ format: n }] },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [o, i.group0, i.group1, i.group2B, i.group3],
    (s, a, l, u, c) => (h, d) => {
      let p = h.beginRenderPass({
        colorAttachments: [{ clearValue: [1, 1, 1, 1], loadOp: "clear", storeOp: "store", view: d }]
      });
      p.setPipeline(s), p.setBindGroup(0, a), p.setBindGroup(1, l), p.setBindGroup(2, u), p.setBindGroup(3, c), p.draw(4), p.end();
    }
  );
}
const uO = 64;
function kL(t, e, r, n, i, o, s) {
  let a = t.derive(
    [e, r, n.layouts],
    (u, c, h) => u.createComputePipeline({
      layout: u.createPipelineLayout({
        bindGroupLayouts: [h.group0, h.group1, h.group2B, h.group3]
      }),
      compute: { module: c, entryPoint: "gaussian_blur_stage_1" }
    })
  ), l = t.derive(
    [e, r, n.layouts],
    (u, c, h) => u.createComputePipeline({
      layout: u.createPipelineLayout({
        bindGroupLayouts: [h.group0, h.group1, h.group2B, h.group3]
      }),
      compute: { module: c, entryPoint: "gaussian_blur_stage_2" }
    })
  );
  return t.derive(
    [
      a,
      l,
      n.group0,
      n.group1,
      n.group2B,
      n.group3,
      i,
      o,
      s
    ],
    (u, c, h, d, p, g, v, y, b) => (k) => {
      let C = k.beginComputePass();
      C.setBindGroup(0, h), C.setBindGroup(1, d), C.setBindGroup(2, p), C.setBindGroup(3, g), C.setPipeline(u), C.dispatchWorkgroups(Math.ceil(v / uO), b), C.setPipeline(c), C.dispatchWorkgroups(Math.ceil(y / uO), b), C.end();
    }
  );
}
function Aye(t, e = !1) {
  const r = new Float64Array(5), n = new Float64Array(4);
  Eye(r, n, t);
  const i = Float64Array.of(
    0,
    n[1] - r[1] * n[0],
    n[2] - r[2] * n[0],
    n[3] - r[3] * n[0],
    -r[4] * n[0]
  ), o = 1 + r[1] + r[2] + r[3] + r[4], s = (n[0] + n[1] + n[2] + n[3]) / o, a = (i[1] + i[2] + i[3] + i[4]) / o;
  return {
    sigma: t,
    negative: e,
    a: r,
    b_causal: n,
    b_anticausal: i,
    sum_causal: s,
    sum_anticausal: a
  };
}
function Eye(t, e, r) {
  const n = Float64Array.of(
    0.84,
    1.8675,
    0.84,
    -1.8675,
    -0.34015,
    -0.1299,
    -0.34015,
    0.1299
  ), i = Math.exp(-1.783 / r), o = Math.exp(-1.723 / r), s = 0.6318 / r, a = 1.997 / r, l = Float64Array.of(
    -i * Math.cos(s),
    i * Math.sin(s),
    -i * Math.cos(-s),
    i * Math.sin(-s),
    -o * Math.cos(a),
    o * Math.sin(a),
    -o * Math.cos(-a),
    o * Math.sin(-a)
  ), u = r * 2.5066282746310007, c = Float64Array.of(n[0], n[1], 0, 0, 0, 0, 0, 0), h = Float64Array.of(1, 0, l[0], l[1], 0, 0, 0, 0, 0, 0);
  let d, p;
  for (p = 2; p < 8; p += 2) {
    for (c[p] = l[p] * c[p - 2] - l[p + 1] * c[p - 1], c[p + 1] = l[p] * c[p - 1] + l[p + 1] * c[p - 2], d = p - 2; d > 0; d -= 2)
      c[d] += l[p] * c[d - 2] - l[p + 1] * c[d - 1], c[d + 1] += l[p] * c[d - 1] + l[p + 1] * c[d - 2];
    for (d = 0; d <= p; d += 2)
      c[d] += n[p] * h[d] - n[p + 1] * h[d + 1], c[d + 1] += n[p] * h[d + 1] + n[p + 1] * h[d];
    for (h[p + 2] = l[p] * h[p] - l[p + 1] * h[p + 1], h[p + 3] = l[p] * h[p + 1] + l[p + 1] * h[p], d = p; d > 0; d -= 2)
      h[d] += l[p] * h[d - 2] - l[p + 1] * h[d - 1], h[d + 1] += l[p] * h[d - 1] + l[p + 1] * h[d - 2];
  }
  for (p = 0; p < 4; ++p)
    d = p << 1, e[p] = c[d] / u, t[p + 1] = h[d + 2];
}
function CL(t) {
  let e = Aye(t);
  return {
    kde_causal: [e.b_causal[0], e.b_causal[1], e.b_causal[2], e.b_causal[3]],
    kde_anticausal: [e.b_anticausal[1], e.b_anticausal[2], e.b_anticausal[3], e.b_anticausal[4]],
    kde_a: [e.a[1], e.a[2], e.a[3], e.a[4]]
  };
}
const Dye = `// Copyright (c) 2025 Apple Inc. Licensed under MIT License.

enable f16;

struct Uniforms {
  count: u32,
  category_count: u32,
  framebuffer_width: i32,
  framebuffer_height: i32,
  density_width: i32,
  density_height: i32,
  gamma: f32,
  point_size: f32,
  point_alpha: f32,
  points_alpha: f32,
  density_scaler: f32,
  quantization_step: f32,
  density_alpha: f32,
  contours_alpha: f32,
  matrix: mat3x3<f32>,
  view_xy_scaler: vec2<f32>,
  kde_causal: vec4<f32>,
  kde_anticausal: vec4<f32>,
  kde_a: vec4<f32>,
  background_color: vec4<f32>,
  category_colors: array<vec4<f32>, 256>,
}

struct PointData {
  position: vec3<f32>,
  category: u32,
}

struct FragmentOutput {
  @location(0) color: vec4<f32>,
  @location(1) log1malpha: f32, // log(1 - alpha)
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@group(1) @binding(0) var<storage, read> x_buffer: array<f32>;
@group(1) @binding(1) var<storage, read> y_buffer: array<f32>;
@group(1) @binding(2) var<storage, read> category_buffer: array<u32>;

@group(2) @binding(0) var<storage, read_write> count_buffer: array<atomic<u32>>;
@group(2) @binding(1) var<storage, read_write> blur_buffer: array<f16>;
@group(2) @binding(2) var<storage, read_write> blur_swap_buffer: array<f16>;

@group(3) @binding(0) var framebuffer_sampler: sampler;
@group(3) @binding(1) var color_texture: texture_2d<f32>;
@group(3) @binding(2) var log1malpha_texture: texture_2d<f32>;

fn get_point(index: u32) -> PointData {
  var result: PointData;
  result.position = vec3(x_buffer[index], y_buffer[index], 1.0);
  if (uniforms.category_count > 1) {
    result.category = (category_buffer[index >> 2] >> ((index & 3) << 3)) & 0xff;
  } else {
    result.category = 0;
  }
  return result;
}

const ACCUMULATE_UNIT: u32 = 4096;

fn increment_count(x: i32, y: i32, category: u32, value: u32) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  if (x < 0 || x >= width || y < 0 || y >= height || category >= uniforms.category_count || value == 0) {
    return;
  }
  let offset = (y * width + x) + i32(category) * (width * height);
  atomicAdd(&count_buffer[offset], value);
}

@compute @workgroup_size(64, 1)
fn accumulate(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let index = id.y * 4096 + id.x; // 4096 = 64 * 64
  if (index >= uniforms.count) { return; }
  let point = get_point(index);
  let pos = uniforms.matrix * point.position;
  let x = (pos.x + 1.0) / 2.0 * f32(width) - 0.5;
  let y = (pos.y + 1.0) / 2.0 * f32(height) - 0.5;
  let ix = i32(x);
  let iy = i32(y);
  let tx = x - f32(ix);
  let ty = y - f32(iy);
  let w1: u32 = u32((1 - tx) * (1 - ty) * f32(ACCUMULATE_UNIT));
  let w2: u32 = u32(tx * (1 - ty) * f32(ACCUMULATE_UNIT));
  let w3: u32 = u32((1 - tx) * ty * f32(ACCUMULATE_UNIT));
  let w123 = w1 + w2 + w3;
  var w4: u32 = select(0, ACCUMULATE_UNIT - w123, w123 < ACCUMULATE_UNIT);
  increment_count(ix, iy, point.category, w1);
  increment_count(ix + 1, iy, point.category, w2);
  increment_count(ix, iy + 1, point.category, w3);
  increment_count(ix + 1, iy + 1, point.category, w4);
}

// Draw Discrete Points

struct PointsVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) dp: vec3<f32>,
  @location(1) color: vec4<f32>,
}

@vertex
fn points_vs(
  @builtin(instance_index) index: u32,
  @builtin(vertex_index) part: u32,
) -> PointsVertexOutput {
  let framebuffer_size = vec2(f32(uniforms.framebuffer_width), f32(uniforms.framebuffer_height));
  let alpha = uniforms.point_alpha * uniforms.points_alpha;
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  let point = get_point(index);
  let pos = uniforms.matrix * point.position;

  var out: PointsVertexOutput;
  out.position = vec4<f32>(pos.xy + dp * uniforms.point_size / framebuffer_size * 2.0, 0.0, 1.0);
  out.dp = vec3(dp, uniforms.point_size);
  out.color = uniforms.category_colors[point.category] * alpha;
  return out;
}

@fragment
fn points_fs(in: PointsVertexOutput) -> FragmentOutput {
  let r = length(in.dp.xy) * in.dp.z;
  let a = max(0.0, min(1.0, in.dp.z - r));
  var out: FragmentOutput;
  out.color = in.color * a;
  out.log1malpha = log(1 - out.color.a);
  return out;
}

// Draw Density Map

struct DrawDensityMapVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) texture_coord: vec2<f32>,
}

@vertex
fn draw_density_map_vs(
  @builtin(vertex_index) part: u32,
) -> DrawDensityMapVertexOutput {
  let framebuffer_size = vec2(f32(uniforms.framebuffer_width), f32(uniforms.framebuffer_height));
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  var out: DrawDensityMapVertexOutput;
  out.position = vec4(dp, 0.0, 1.0);
  out.texture_coord = (vec2(dp.x, dp.y) + 1.0) / 2.0 * framebuffer_size;
  return out;
}

fn get_density_raw(x: i32, y: i32, category: u32) -> f32 {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let density_scaler = uniforms.density_scaler;
  if (x < 0 || x >= width || y < 0 || y >= height) {
    return 0.0;
  }
  let offset = (y * width + x) + i32(category) * (width * height);
  return max(0.0, f32(blur_buffer[offset]) * density_scaler);
}

fn get_density(x: f32, y: f32, category: u32) -> f32 {
  let px = x / f32(uniforms.framebuffer_width) * f32(uniforms.density_width) - 0.5;
  let py = y / f32(uniforms.framebuffer_height) * f32(uniforms.density_height) - 0.5;
  let ix = i32(px);
  let iy = i32(py);
  let tx = px - f32(ix);
  let ty = py - f32(iy);
  let v00 = get_density_raw(ix, iy, category);
  let v10 = get_density_raw(ix + 1, iy, category);
  let v01 = get_density_raw(ix, iy + 1, category);
  let v11 = get_density_raw(ix + 1, iy + 1, category);
  return mix(mix(v00, v10, tx), mix(v01, v11, tx), ty);
}

fn get_density_quantized(x: f32, y: f32, category: u32) -> f32 {
  let v = get_density(x, y, category);
  return floor(clamp(v, 0, 1) / uniforms.quantization_step);
}

fn get_density_quantized_sobel(x: f32, y: f32, category: u32) -> vec2<f32> {
  let v11 = get_density_quantized(x - 1, y - 1, category);
  let v21 = get_density_quantized(x, y - 1, category);
  let v31 = get_density_quantized(x + 1, y - 1, category);
  let v12 = get_density_quantized(x - 1, y, category);
  let v22 = get_density_quantized(x, y, category);
  let v32 = get_density_quantized(x + 1, y, category);
  let v13 = get_density_quantized(x - 1, y + 1, category);
  let v23 = get_density_quantized(x, y + 1, category);
  let v33 = get_density_quantized(x + 1, y + 1, category);
  let gx = v11 + v12 * 2.0 + v13 - v31 - v32 * 2.0 - v33;
  let gy = v11 + v21 * 2.0 + v31 - v13 - v23 * 2.0 - v33;
  return vec2(gx, gy);
}

@fragment
fn draw_density_map_fs(in: DrawDensityMapVertexOutput) -> FragmentOutput {
  let px = in.texture_coord.x;
  let py = in.texture_coord.y;
  let quantization_step: f32 = uniforms.quantization_step;

  var sum_color: vec4<f32> = vec4(0);
  var sum_log1malpha: f32 = 0.0;

  for (var i: u32 = 0; i < uniforms.category_count; i++) {
    let density = get_density(px, py, i);
    var alpha = min(1.0, floor(density / quantization_step) * quantization_step);
    alpha *= uniforms.density_alpha;
    let color = uniforms.category_colors[i] * alpha;
    sum_color += color;
    sum_log1malpha += log(1 - color.a);
  }

  if (uniforms.contours_alpha > 0.0) {
    for (var i: u32 = 0; i < uniforms.category_count; i++) {
      let sobel = get_density_quantized_sobel(px, py, i);
      let alpha = clamp(length(sobel) * 0.2, 0.0, 1.0) * uniforms.contours_alpha;
      let color = uniforms.category_colors[i] * alpha;
      sum_color += color;
      sum_log1malpha += log(1 - color.a);
    }
  }

  var out: FragmentOutput;
  out.color = sum_color;
  out.log1malpha = sum_log1malpha;
  return out;
}

// Gamma Correction

struct GammaCorrectionVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) texture_coord: vec2<f32>,
}

@vertex
fn gamma_correction_vs(
  @builtin(vertex_index) part: u32,
) -> GammaCorrectionVertexOutput {
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  var out: GammaCorrectionVertexOutput;
  out.position = vec4(dp * uniforms.view_xy_scaler, 0.0, 1.0);
  out.texture_coord = (vec2(dp.x, -dp.y) + 1.0) / 2.0;
  return out;
}

@fragment
fn gamma_correction_fs(in: GammaCorrectionVertexOutput) -> @location(0) vec4<f32> {
  let sum_color = textureSample(color_texture, framebuffer_sampler, in.texture_coord);
  let sum_log_one_minus_alpha = textureSample(log1malpha_texture, framebuffer_sampler, in.texture_coord).r;
  var color: vec4<f32>;
  if (sum_color.a > 0.0) {
    color = sum_color / sum_color.a * (1.0 - exp(sum_log_one_minus_alpha));
    color = color + uniforms.background_color * (1 - color.a);
  } else {
    color = uniforms.background_color;
  }
  let rgb = pow(color.rgb, vec3(1.0 / uniforms.gamma));
  return vec4(rgb, 1.0);
}

// Gaussian Blur

@compute @workgroup_size(64, 1)
fn gaussian_blur_stage_1(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let x = id.x;
  if (x >= u32(width)) { return; }
  let start = x + id.y * u32(width * height);
  let count = u32(height);
  let stride = u32(width);

  deriche_conv_1d(
    &blur_buffer, &blur_swap_buffer, start, stride, count,
    uniforms.kde_causal, uniforms.kde_anticausal, uniforms.kde_a,
    true
  );
}

@compute @workgroup_size(64, 1)
fn gaussian_blur_stage_2(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let y = id.x;
  if (y >= u32(height)) { return; }
  let start = y * u32(width) + id.y * u32(width * height);
  let count = u32(width);
  let stride = u32(1);

  deriche_conv_1d(
    &blur_swap_buffer, &blur_buffer, start, stride, count,
    uniforms.kde_causal, uniforms.kde_anticausal, uniforms.kde_a,
    false
  );
}

fn deriche_conv_1d(
    src: ptr<storage, array<f16>, read_write>,
    dst: ptr<storage, array<f16>, read_write>,
    start: u32, stride: u32, count: u32,
    kde_causal: vec4<f32>, kde_anticausal: vec4<f32>, kde_a: vec4<f32>,
    src_is_u32: bool
) {
  var s: vec4<f32> = vec4(0.0);
  var y0: f32 = 0.0;
  var y1234: vec4<f32> = vec4(0.0);

  var first_nonzero: u32 = count;
  var last_nonzero: u32 = 0;

  for (var i: u32 = 0; i < count; i++) {
    let offset = start + i * stride;
    var input: f32;
    if (src_is_u32) {
      input = f32(bitcast<u32>(vec2((*src)[offset * 2], (*src)[offset * 2 + 1]))) / f32(ACCUMULATE_UNIT);
    } else {
      input = f32((*src)[offset]);
    }
    if (input != 0.0) {
      first_nonzero = min(i, first_nonzero);
      last_nonzero = max(i, last_nonzero);
    }
    s = vec4(input, s.xyz);
    y1234 = vec4(y0, y1234.xyz);
    y0 = dot(kde_causal, s) - dot(kde_a, y1234);
    (*dst)[offset] = f16(y0);
  }

  if (first_nonzero > last_nonzero) {
    return;
  }

  s = vec4(0.0);
  y0 = 0.0;
  y1234 = vec4(0.0);

  for (var i: u32 = count - 1 - last_nonzero; i < count; i++) {
    let p = count - 1 - i;
    let offset = start + p * stride;
    var input: f32 = 0.0;
    if (p >= first_nonzero) {
      if (src_is_u32) {
        input = f32(bitcast<u32>(vec2((*src)[offset * 2], (*src)[offset * 2 + 1]))) / f32(ACCUMULATE_UNIT);
      } else {
        input = f32((*src)[offset]);
      }
    }
    y1234 = vec4(y0, y1234.xyz);
    y0 = dot(kde_anticausal, s) - dot(kde_a, y1234);
    s = vec4(input, s.xyz);
    if (y0 != 0.0) {
      (*dst)[offset] = f16(f32((*dst)[offset]) + y0);
    }
  }
}
`;
class Oye {
  props;
  viewport;
  df;
  device;
  module;
  uniforms;
  context;
  renderInputs;
  dataBuffers;
  renderer;
  constructor(e, r, n, i, o) {
    this.context = e, this.props = {
      mode: "points",
      colorScheme: "light",
      x: new Float32Array(),
      y: new Float32Array(),
      category: null,
      categoryCount: 1,
      categoryColors: null,
      viewportX: 0,
      viewportY: 0,
      viewportScale: 1,
      pointSize: 1,
      pointAlpha: 1,
      pointsAlpha: 1,
      densityScaler: 1,
      densityBandwidth: 1,
      densityQuantizationStep: 0.1,
      contoursAlpha: 1,
      densityAlpha: 1,
      gamma: 2.2,
      width: i,
      height: o
    }, this.viewport = new Fx({ x: 0, y: 0, scale: 1 }, i, o), this.df = new Qh();
    let s = this.df;
    this.renderInputs = {
      mode: s.value(this.props.mode),
      colorScheme: s.value(this.props.colorScheme),
      xData: s.value(this.props.x),
      yData: s.value(this.props.y),
      categoryData: s.value(this.props.category),
      categoryCount: s.value(this.props.categoryCount),
      categoryColors: s.value(this.props.categoryColors),
      matrix: s.value(pL()),
      width: s.value(i),
      height: s.value(o),
      pointSize: s.value(this.props.pointSize),
      densityBandwidth: s.value(this.props.densityBandwidth)
    }, this.device = s.value(r), this.dataBuffers = Fye(s, this.device, this.renderInputs), this.module = s.derive([this.device], (a) => a.createShaderModule({ code: Dye })), this.uniforms = wye(s, this.device), this.renderer = Tye(
      s,
      this.device,
      this.module,
      this.uniforms,
      n,
      this.renderInputs,
      this.dataBuffers
    );
  }
  setProps(e) {
    let r = !1, n;
    for (n in e)
      e[n] !== this.props[n] && (this.props[n] = e[n], r = !0);
    return this.viewport.update(
      { x: this.props.viewportX, y: this.props.viewportY, scale: this.props.viewportScale },
      this.props.width,
      this.props.height
    ), this.renderInputs.mode.value = this.props.mode, this.renderInputs.colorScheme.value = this.props.colorScheme, this.renderInputs.xData.value = this.props.x, this.renderInputs.yData.value = this.props.y, this.renderInputs.categoryData.value = this.props.category, this.renderInputs.categoryColors.value = this.props.categoryColors, this.props.category != null ? this.renderInputs.categoryCount.value = this.props.categoryCount : this.renderInputs.categoryCount.value = 1, this.renderInputs.matrix.value = this.viewport.matrix(), this.renderInputs.width.value = this.props.width, this.renderInputs.height.value = this.props.height, this.renderInputs.pointSize.value = this.props.pointSize, this.renderInputs.densityBandwidth.value = this.props.densityBandwidth, r;
  }
  render() {
    this.renderer.value(this.props, this.context.getCurrentTexture().createView());
  }
  destroy() {
    this.df.destroy();
  }
  async densityMap(e, r, n, i) {
    let o = this.df.subgraph(), { x: s, y: a, scale: l } = i, u = [l, 0, 0, 0, l, 0, -s * l, -a * l, 1], c = gL(u), h = await Mye(
      o,
      this.device,
      this.module,
      this.uniforms,
      o.value(e),
      o.value(r),
      o.value(n),
      o.value(u),
      this.dataBuffers
    ).value();
    return o.destroy(), {
      data: h,
      width: e,
      height: r,
      coordinateAtPixel: (d, p) => {
        let g = d / e * 2 - 1, v = p / r * 2 - 1, y = mL([g, v, 1], c);
        return { x: y[0], y: y[1] };
      }
    };
  }
}
function Fye(t, e, r) {
  let n = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
  const i = t.derive([r.xData], (c) => c.length), o = t.derive([i], (c) => c * 4), s = i, a = t.statefulDerive(
    [e, t.statefulDerive([e, o, n], sd), r.xData],
    Ak
  ), l = t.statefulDerive(
    [e, t.statefulDerive([e, o, n], sd), r.yData],
    Ak
  ), u = t.statefulDerive(
    [e, t.statefulDerive([e, s, n], sd), r.categoryData],
    Ak
  );
  return { x: a, y: l, category: u, count: i };
}
function _L(t, e, r, n, i, o, s) {
  let a = "rgba16float", l = "r16float", u = GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, c = t.statefulDerive(
    [e, r, n, a, u],
    B9
  ), h = t.statefulDerive(
    [e, r, n, l, u],
    B9
  ), d = t.derive(
    [i, o, s],
    (y, b, k) => y * b * k * 4
    // w * h * categoryCount * sizeof(uint32)
  ), p = t.derive(
    [i, o, s],
    (y, b, k) => y * b * k * 2
    // w * h * categoryCount * sizeof(f16)
  ), g = t.statefulDerive(
    [e, d, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC],
    sd
  ), v = t.statefulDerive([e, p, GPUBufferUsage.STORAGE], sd);
  return {
    colorTexture: c,
    alphaTexture: h,
    colorTextureFormat: a,
    alphaTextureFormat: l,
    countBuffer: g,
    blurBuffer: v
  };
}
function Tye(t, e, r, n, i, o, s) {
  let a = t.derive([o.densityBandwidth], (_) => Math.ceil(_ * 3) + 1), l = t.derive([o.width, a], (_, D) => _ + D * 2), u = t.derive([o.height, a], (_, D) => _ + D * 2), c = t.derive([l], (_) => Math.ceil(_ / 4)), h = t.derive([u], (_) => Math.ceil(_ / 4)), d = _L(
    t,
    e,
    l,
    u,
    c,
    h,
    o.categoryCount
  ), p = wL(t, e, n.buffer, s, d), g = xL(t, e, r, p, s, d), v = _ye(t, e, r, p, s, d), y = Cye(t, e, r, p, d), b = Sye(t, e, r, i, p), k = kL(t, e, r, p, l, u, o.categoryCount), C = t.derive(
    [o.densityBandwidth, l, c],
    (_, D, A) => CL(_ / D * A)
  ), S = t.derive(
    [o.categoryColors, o.categoryCount],
    (_, D) => (_ == null && (_ = gp(D)), _.map((A) => KS(A)))
  );
  return t.derive(
    [
      e,
      l,
      u,
      c,
      h,
      n.update,
      s.count,
      o.matrix,
      S,
      v,
      b,
      g,
      k,
      y,
      C
    ],
    (_, D, A, O, M, z, N, P, I, B, $, j, U, H, G) => (re, ne) => {
      let se = re.colorScheme == "light" ? [1, 1, 1, 1] : [0, 0, 0, 1], ie = re.width / D, ce = re.height / A, Ce = XS([ie, 0, 0, 0, ce, 0, 0, 0, 1], P);
      z({
        count: N,
        category_count: re.categoryCount,
        framebuffer_width: D,
        framebuffer_height: A,
        density_width: O,
        density_height: M,
        gamma: re.gamma,
        point_size: Math.max(re.mode == "points" ? 3 : 1, re.pointSize),
        point_alpha: re.pointAlpha,
        points_alpha: re.pointsAlpha,
        density_scaler: re.densityScaler / 16,
        quantization_step: re.densityQuantizationStep,
        density_alpha: re.densityAlpha,
        contours_alpha: re.contoursAlpha,
        matrix: Ce,
        view_xy_scaler: [1 / ie, 1 / ce],
        kde_causal: G.kde_causal,
        kde_anticausal: G.kde_anticausal,
        kde_a: G.kde_a,
        background_color: se,
        category_colors: I
      });
      let Me = _.createCommandEncoder();
      B(Me), re.mode == "density" && (re.densityAlpha > 0 || re.contoursAlpha > 0) && (j(Me), U(Me), H(Me)), $(Me, ne), _.queue.submit([Me.finish()]);
    }
  );
}
function Mye(t, e, r, n, i, o, s, a, l) {
  let u = _L(t, e, i, o, i, o, t.value(1)), c = wL(t, e, n.buffer, l, u), h = xL(t, e, r, c, l, u), d = kL(t, e, r, c, i, o, t.value(1));
  return t.derive(
    [
      e,
      i,
      o,
      l.count,
      n.update,
      s,
      a,
      h,
      d,
      u.countBuffer
    ],
    (p, g, v, y, b, k, C, S, _, D) => () => {
      let A = p.createCommandEncoder(), O = CL(k);
      b({
        count: y,
        category_count: 1,
        framebuffer_width: g,
        framebuffer_height: v,
        density_width: g,
        density_height: v,
        gamma: 1,
        point_size: 0,
        point_alpha: 0,
        points_alpha: 0,
        density_scaler: 0,
        quantization_step: 0,
        density_alpha: 0,
        contours_alpha: 0,
        matrix: C,
        view_xy_scaler: [1, 1],
        kde_causal: O.kde_causal,
        kde_anticausal: O.kde_anticausal,
        kde_a: O.kde_a,
        background_color: [0, 0, 0, 0],
        category_colors: []
      }), S(A), _(A);
      let M = p.createBuffer({
        size: g * v * 2,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      return A.copyBufferToBuffer(D, 0, M, 0, g * v * 2), p.queue.submit([A.finish()]), M.mapAsync(GPUMapMode.READ, 0, g * v * 2).then(() => Pye(M.getMappedRange()));
    }
  );
}
function Pye(t) {
  let e = new Uint16Array(t), r = new Uint32Array(e.length);
  for (let n = 0; n < e.length; n++) {
    let i = e[n] & 32767, o = e[n] & 32768, s = e[n] & 31744;
    i <<= 13, o <<= 16, i += 939524096, i = s == 0 ? 0 : i, i |= o, r[n] = i;
  }
  return new Float32Array(r.buffer);
}
let om;
function Rye() {
  return om == null && (om = document.createElement("canvas"), om.width = 1, om.height = 1), om.getContext("2d");
}
function Nye(t) {
  let e = Rye();
  e.font = `${t.fontSize ?? 10}px ${t.fontFamily ?? "system-ui"}`;
  let r = t.text.split(`
`).map((i) => e.measureText(i).width), n = (t.fontSize ?? 10) * (t.lineSpacing ?? 1) * r.length;
  return {
    width: r.reduce((i, o) => Math.max(i, o)),
    height: n
  };
}
let Nk = null, u_ = /* @__PURE__ */ new Map();
function $ye() {
  return Nk == null && (Nk = new Promise((t, e) => {
    let r = new Worker(new URL("./clustering.worker.js", import.meta.url), { type: "module" });
    r.onmessage = (n) => {
      if (n.data.ready) {
        t(r);
        return;
      }
      if (n.data.id != null) {
        let i = u_.get(n.data.id);
        i != null && (u_.delete(n.data.id), i(n.data));
      }
    };
  })), Nk;
}
function yp(t, e, r = []) {
  return new Promise((n, i) => {
    $ye().then((o) => {
      let s = (/* @__PURE__ */ new Date()).getTime().toString() + "-" + Math.random().toString();
      u_.set(s, (a) => {
        n(a.payload);
      }), o.postMessage({ id: s, name: t, payload: e }, r);
    });
  });
}
let Iye = (t, e, r, n) => yp("findClusters", [t, e, r, n], [t.buffer]), Bye = (...t) => yp("dynamicLabelPlacement", t), Lye = (...t) => yp("textSummarizerCreate", t), zye = (...t) => yp("textSummarizerDestroy", t), jye = (...t) => yp("textSummarizerAdd", t), qye = (...t) => yp("textSummarizerSummarize", t);
async function cO(t, e, r, n, i) {
  let o = new Fx(r, t, e), s = n.reduce((g, v) => Math.min(g, v.level ?? 0), 0), a = n.reduce((g, v) => Math.max(g, v.level ?? 0), 0), l = r.scale, u = r.scale / 2, c = u * 4, h = l / c, d = n.map((g) => {
    let v = o.pixelLocation(g.x, g.y), y = g.level ?? 0, b = y == 0 ? 14 : 12, k = Nye({
      text: g.text,
      fontSize: b,
      fontFamily: i
    });
    return k.width += 4, k.height += 4, {
      text: g.text,
      fontSize: b,
      bounds: {
        xMin: v.x - k.width / 2,
        xMax: v.x + k.width / 2,
        yMin: v.y - k.height / 2,
        yMax: v.y + k.height / 2
      },
      locationAtZero: v,
      priority: g.priority,
      minScale: g.level == a ? null : h * Math.pow(2, -y) / 1.2,
      maxScale: g.level == s ? null : h * Math.pow(2, -y + 1),
      coordinate: { x: g.x, y: g.y },
      placement: null
    };
  }), p = await Bye(d, { globalMaxScale: l / u });
  for (let g = 0; g < p.length; g++) {
    let v = p[g];
    if (v != null) {
      let y = l / v.minScale, b = l / v.maxScale;
      d[g].placement = { minScale: b, maxScale: y };
    }
  }
  return d;
}
function Uye(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var hO = { exports: {} }, fO;
function Hye() {
  return fO || (fO = 1, (function(t) {
    (function() {
      function e(a, l) {
        var u = a.x - l.x, c = a.y - l.y;
        return u * u + c * c;
      }
      function r(a, l, u) {
        var c = l.x, h = l.y, d = u.x - c, p = u.y - h;
        if (d !== 0 || p !== 0) {
          var g = ((a.x - c) * d + (a.y - h) * p) / (d * d + p * p);
          g > 1 ? (c = u.x, h = u.y) : g > 0 && (c += d * g, h += p * g);
        }
        return d = a.x - c, p = a.y - h, d * d + p * p;
      }
      function n(a, l) {
        for (var u = a[0], c = [u], h, d = 1, p = a.length; d < p; d++)
          h = a[d], e(h, u) > l && (c.push(h), u = h);
        return u !== h && c.push(h), c;
      }
      function i(a, l, u, c, h) {
        for (var d = c, p, g = l + 1; g < u; g++) {
          var v = r(a[g], a[l], a[u]);
          v > d && (p = g, d = v);
        }
        d > c && (p - l > 1 && i(a, l, p, c, h), h.push(a[p]), u - p > 1 && i(a, p, u, c, h));
      }
      function o(a, l) {
        var u = a.length - 1, c = [a[0]];
        return i(a, 0, u, l, c), c.push(a[u]), c;
      }
      function s(a, l, u) {
        if (a.length <= 2) return a;
        var c = l !== void 0 ? l * l : 1;
        return a = u ? a : n(a, c), a = o(a, c), a;
      }
      t.exports = s, t.exports.default = s;
    })();
  })(hO)), hO.exports;
}
var Vye = Hye();
const dO = /* @__PURE__ */ Uye(Vye);
function Wye(t, e) {
  let r = t.slice();
  for (let n = 0; n < e; n++) {
    const i = [], o = r.length;
    for (let s = 0; s < o; s++) {
      const a = r[s], l = r[(s + 1) % o], u = {
        x: 0.75 * a.x + 0.25 * l.x,
        y: 0.75 * a.y + 0.25 * l.y
      }, c = {
        x: 0.25 * a.x + 0.75 * l.x,
        y: 0.25 * a.y + 0.75 * l.y
      };
      i.push(u, c);
    }
    r = i;
  }
  return r;
}
function Gye(t, e) {
  const r = Wye(t, 5), n = lL(r);
  let i = Math.max(n.xMax - n.xMin, n.yMax - n.yMin) / 100, o = dO(r, i), s = 0;
  for (; o.length > e && s < 20; )
    i *= 1.1, s += 1, o = dO(r, i);
  return o;
}
const pO = {
  light: {
    fontFamily: "system-ui,sans-serif",
    clusterLabelColor: "#000",
    clusterLabelOutlineColor: "rgba(255,255,255,0.8)",
    clusterLabelOpacity: 0.8,
    statusBar: !0,
    statusBarTextColor: "#525252",
    statusBarBackgroundColor: "rgba(255,255,255,0.9)",
    brandingLink: { text: "Embedding Atlas", href: "https://apple.github.io/embedding-atlas" }
  },
  dark: {
    fontFamily: "system-ui,sans-serif",
    clusterLabelColor: "#ccc",
    clusterLabelOutlineColor: "rgba(0,0,0,0.8)",
    clusterLabelOpacity: 0.8,
    statusBar: !0,
    statusBarTextColor: "#d9d9d9",
    statusBarBackgroundColor: "rgba(0,0,0,0.9)",
    brandingLink: { text: "Embedding Atlas", href: "https://apple.github.io/embedding-atlas" }
  }
};
function Kye(t, e) {
  return t == null ? pO[e] : { ...pO[e], ...t, ...t[e] != null ? t[e] : {} };
}
function Xye(t, e, r, n, i, o, s) {
  let a = Math.max(n, i) / o, l = t / (r * r) / (a * a), u = 1 / (l / (o * o)) * 0.2, c = Math.sqrt(t / e / (a * a)), h = Math.log(c), d = Math.log(r), p = (Math.min(Math.max((d - h) * 2, -1), 1) + 1) / 2, g;
  if (s != null)
    g = s * o;
  else {
    let b = 0.25 / Math.sqrt(l);
    g = Math.max(0.2, Math.min(5, b)) * o;
  }
  let v = 1 - p, y = 0.5 + p * 0.5;
  return {
    densityScaler: u,
    densityAlpha: v,
    contoursAlpha: v,
    pointSize: g,
    pointAlpha: 0.7,
    pointsAlpha: y,
    densityBandwidth: 20
  };
}
var Qye = /* @__PURE__ */ bc("<div></div>"), Jye = /* @__PURE__ */ cu("<circle></circle>"), Yye = /* @__PURE__ */ cu("<circle></circle>"), Zye = /* @__PURE__ */ cu('<text dominant-baseline="middle"> </text>'), e1e = /* @__PURE__ */ cu("<g></g>"), t1e = /* @__PURE__ */ cu("<g><!></g>"), r1e = /* @__PURE__ */ cu("<g></g>"), n1e = /* @__PURE__ */ bc('<div><canvas></canvas> <div><!></div> <svg role="none"><!><!><!><!></svg> <!> <!></div>');
function i1e(t, e) {
  Wh(e, !0);
  let r = Ye(e, "data", 19, () => ({ x: new Float32Array(), y: new Float32Array(), category: null })), n = Ye(e, "categoryCount", 3, 1), i = Ye(e, "categoryColors", 3, null), o = Ye(e, "width", 3, 800), s = Ye(e, "height", 3, 800), a = Ye(e, "pixelRatio", 3, 2), l = Ye(e, "theme", 3, null), u = Ye(e, "config", 3, null), c = Ye(e, "totalCount", 3, null), h = Ye(e, "maxDensity", 3, null), d = Ye(e, "labels", 3, null), p = Ye(e, "queryClusterLabels", 3, null), g = Ye(e, "tooltip", 7, null), v = Ye(e, "selection", 7, null), y = Ye(e, "querySelection", 3, null), b = Ye(e, "rangeSelection", 7, null), k = Ye(e, "defaultViewportState", 3, null), C = Ye(e, "viewportState", 7, null), S = Ye(e, "customTooltip", 3, null), _ = Ye(e, "customOverlay", 3, null), D = Ye(e, "onViewportState", 3, null), A = Ye(e, "onTooltip", 3, null), O = Ye(e, "onSelection", 3, null), M = Ye(e, "onRangeSelection", 3, null), z = Ye(e, "cache", 3, null), N = /* @__PURE__ */ mt(() => u()?.colorScheme ?? "light"), P = /* @__PURE__ */ mt(() => Kye(l(), W(N))), I = /* @__PURE__ */ mt(() => i() ?? gp(n())), B = /* @__PURE__ */ mt(() => C() ?? k() ?? { x: 0, y: 0, scale: 1 }), $ = /* @__PURE__ */ mt(() => new Fx(W(B), o(), s())), j = /* @__PURE__ */ mt(() => W($).pixelLocationFunction()), U = /* @__PURE__ */ mt(() => W($).coordinateAtPixelFunction()), H = /* @__PURE__ */ Rr(!1);
  function G(xe, Te) {
    return xe.x == Te.x && xe.y == Te.y && xe.category == Te.category && xe.text == Te.text;
  }
  let re = /* @__PURE__ */ mt(() => v()?.length == 1 && g() != null && G(v()[0], g()));
  function ne(xe) {
    Bu(C(), xe) || (C(xe), D()?.(xe));
  }
  function se(xe) {
    Bu(g(), xe) || (g(xe), A()?.(xe));
  }
  function ie(xe) {
    Bu(v(), xe) || (v(xe), O()?.(xe));
  }
  function ce(xe) {
    Bu(b(), xe) || (b(xe), M()?.(xe));
  }
  let Ce = /* @__PURE__ */ Rr(Zc([])), Me = /* @__PURE__ */ Rr(null), Pe = /* @__PURE__ */ Rr("none"), Ae = /* @__PURE__ */ mt(() => o() * a()), he = /* @__PURE__ */ mt(() => s() * a()), we = /* @__PURE__ */ Rr(null), ve = /* @__PURE__ */ Rr(null), Ge = /* @__PURE__ */ Rr(null), Xe = /* @__PURE__ */ mt(() => u()?.minimumDensity ?? 1 / 16), et = /* @__PURE__ */ mt(() => u()?.pointSize ?? null), Qe = /* @__PURE__ */ mt(() => u()?.mode ?? "points"), Wt = /* @__PURE__ */ mt(() => u()?.autoLabelEnabled), At = /* @__PURE__ */ mt(() => Xye(h() ?? (c() ?? r().x.length) / 4, W(Xe), W(B).scale, W(Ae), W(he), a(), W(et))), Xt = /* @__PURE__ */ mt(() => W(At).pointSize), Nt = !0;
  zm(() => {
    W(ve)?.setProps({
      mode: W(Qe),
      colorScheme: W(N),
      viewportX: W(B).x,
      viewportY: W(B).y,
      viewportScale: W(B).scale,
      width: W(Ae),
      height: W(he),
      x: r().x,
      y: r().y,
      category: r().category,
      categoryCount: n(),
      categoryColors: W(I),
      ...W(At)
    }) && (Bt(), (W(Wt) !== !1 || d() != null) && Nt && W(ve) != null && r().x != null && r().x.length > 0 && k() != null && (Nt = !1, ua(k())));
  });
  function Ve() {
    Ze = null, !(!W(we) || !W(ve)) && (W(we).width = W(ve).props.width, W(we).height = W(ve).props.height, W(we).style.width = `${W(ve).props.width / a()}px`, W(we).style.height = `${W(ve).props.height / a()}px`, W(ve).render());
  }
  let Ze = null;
  function Bt() {
    Ze == null && (Ze = requestAnimationFrame(Ve));
  }
  function Qt(xe) {
    let Te;
    function ze() {
      Te = xe.getContext("webgl2", { antialias: !1 }), Te.getExtension("EXT_color_buffer_float"), Te.getExtension("EXT_float_blend"), Te.getExtension("OES_texture_float_linear"), ht(ve, new pye(Te, W(Ae), W(he)), !0);
    }
    ze(), xe.addEventListener("webglcontextlost", () => {
      W(ve)?.destroy(), ht(ve, null), Te = null;
    }), xe.addEventListener("webglcontextrestored", () => {
      ze();
    });
  }
  function Sr(xe) {
    async function Te() {
      let ze = xe.getContext("webgpu");
      if (ze == null) {
        console.error("Could not get WebGPU canvas context");
        return;
      }
      let We = await navigator.gpu.requestAdapter();
      if (!We) {
        console.error("Could not request WebGPU adapter");
        return;
      }
      let Je = 512 * 1048576, ut = 512 * 1048576;
      Je = Math.min(Je, We.limits.maxBufferSize), ut = Math.min(ut, We.limits.maxStorageBufferBindingSize);
      let Gt = {
        requiredLimits: { maxBufferSize: Je, maxStorageBufferBindingSize: ut },
        requiredFeatures: ["shader-f16"]
      }, gr = await We.requestDevice(Gt);
      gr.lost.then((un) => {
        console.info(`WebGPU device was lost: ${un.message}`), un.reason != "destroyed" && (W(ve)?.destroy(), ht(ve, null), Te());
      });
      let Er = navigator.gpu.getPreferredCanvasFormat();
      ze.configure({ device: gr, format: Er, alphaMode: "premultiplied" }), ht(ve, new Oye(ze, gr, Er, W(Ae), W(he)), !0);
    }
    Te();
  }
  function pt(xe) {
    xe != null && C() == null && ne(xe);
  }
  zm(() => pt(k())), VS(() => {
    W(we) != null && (aB() ? Sr(W(we)) : (Qt(W(we)), ht(Ge, "WebGPU is unavailable. If you are using Safari, please enable the WebGPU feature flag.")));
  }), J0e(() => {
    W(ve)?.destroy(), ht(ve, null);
  });
  function _e(xe) {
    let Te = W(we)?.getBoundingClientRect() ?? { left: 0, top: 0 };
    return { x: xe.clientX - Te.left, y: xe.clientY - Te.top };
  }
  function tt(xe) {
    xe.preventDefault();
    let { x: Te, y: ze } = _e(xe), We = Math.exp(-xe.deltaY / 200);
    Ft(We, { x: Te, y: ze });
  }
  function Ft(xe, Te) {
    let { x: ze, y: We, scale: Je } = W(B);
    se(null);
    let ut = Math.min(100, Math.max(0.01, Je * xe)), Gt = W(we).getBoundingClientRect(), gr = Math.max(Gt.width, Gt.height), Er = (Te.x - Gt.width / 2) / gr * 2, un = (Gt.height / 2 - Te.y) / gr * 2, Zo = ze + Er / Je - Er / ut, Tn = We + un / Je - un / ut;
    ne({ x: Zo, y: Tn, scale: ut });
  }
  function mr(xe) {
    se(null);
    let Te = "pan";
    W(Pe) != "none" ? xe.modifiers.shift || (Te = W(Pe)) : xe.modifiers.shift && (Te = xe.modifiers.meta ? "lasso" : "marquee");
    let ze = _e(xe);
    switch (Te) {
      case "marquee":
        return {
          move: (We) => {
            if (se(null), W(ve) == null)
              return;
            let Je = _e(We), ut = W(U)(ze.x, ze.y), Gt = W(U)(Je.x, Je.y);
            ce({
              xMin: Math.min(ut.x, Gt.x),
              yMin: Math.min(ut.y, Gt.y),
              xMax: Math.max(ut.x, Gt.x),
              yMax: Math.max(ut.y, Gt.y)
            });
          }
        };
      case "lasso": {
        let We = [W(U)(ze.x, ze.y)];
        return {
          move: (Je) => {
            if (se(null), W(ve) == null)
              return;
            let ut = _e(Je);
            We = [...We, W(U)(ut.x, ut.y)], We.length >= 3 && ce(Gye(We, 24));
          }
        };
      }
      case "pan": {
        let We = W(U)(0, 0), Je = W(U)(1, 1), ut = We.x - Je.x, Gt = We.y - Je.y, gr = W(B).x, Er = W(B).y;
        return {
          move: (un) => {
            ne({
              x: gr + (un.clientX - xe.clientX) * ut,
              y: Er + (un.clientY - xe.clientY) * Gt,
              scale: W(B).scale
            });
          }
        };
      }
    }
  }
  async function Tt(xe) {
    if (b() != null)
      ce(null);
    else {
      const Te = await Ut(_e(xe));
      if (Te == null)
        ie([]), se(null);
      else if (xe.modifiers.shift || xe.modifiers.ctrl || xe.modifiers.meta) {
        let ze = v()?.findIndex((We) => We.x == Te.x && We.y == Te.y && We.category == Te.category);
        v() == null || ze == null || ze < 0 ? (ie([...v() ?? [], Te]), se(Te)) : (ie([
          ...v().slice(0, ze),
          ...v().slice(ze + 1)
        ]), se(null));
      } else
        ie([Te]), se(Te);
    }
  }
  let Et = cve(
    async (xe) => {
      let Te = xe ? _e(xe) : null;
      if (v() != null && v().length == 1) {
        let ze = W(j)(v()[0].x, v()[0].y);
        Te != null && hve(Te, ze) < 10 && se(v()[0]);
      } else
        se(await Ut(Te));
    },
    () => g() != null
  );
  function Ar(xe) {
    xe != null ? W(H) || Et(xe) : Et(null);
  }
  zm(() => {
    W(H) && Et(null);
  });
  async function Ut(xe) {
    if (W(ve) == null || xe == null || y() == null)
      return null;
    let { x: Te, y: ze } = W(U)(xe.x, xe.y), We = Math.abs(W(U)(xe.x + 1, xe.y).x - Te);
    return await y()(Te, ze, We);
  }
  async function ln(xe, Te, ze, We = 5e-3) {
    let Je = await xe.densityMap(1e3, 1e3, Te, ze), ut = await Iye(Je.data, Je.width, Je.height), Gt = [];
    for (let Er = 0; Er < ut.length; Er++) {
      let un = ut[Er], Zo = Je.coordinateAtPixel(un.meanX, un.meanY), Tn = un.boundaryRectApproximation.map(([bo, Ds, Op, Os]) => {
        let gl = Je.coordinateAtPixel(bo, Ds), vl = Je.coordinateAtPixel(Op, Os);
        return {
          xMin: Math.min(gl.x, vl.x),
          xMax: Math.max(gl.x, vl.x),
          yMin: Math.min(gl.y, vl.y),
          yMax: Math.max(gl.y, vl.y)
        };
      });
      Gt.push({
        x: Zo.x,
        y: Zo.y,
        sumDensity: un.sumDensity,
        rects: Tn,
        bandwidth: Te
      });
    }
    let gr = Gt.reduce((Er, un) => Math.max(Er, un.sumDensity), 0);
    return Gt.filter((Er) => Er.sumDensity / gr > We);
  }
  async function wi(xe) {
    if (W(ve) == null || p() == null)
      return [];
    let Te = await dve({
      autoLabel: {
        version: 1,
        viewport: xe,
        stopWords: u()?.autoLabelStopWords,
        densityThreshold: u()?.autoLabelDensityThreshold
      }
    });
    if (z() != null) {
      let Je = await z().get(Te);
      if (Je != null)
        return Je;
    }
    let ze = await ln(W(ve), 10, xe, u()?.autoLabelDensityThreshold ?? 5e-3);
    if (ze = ze.concat(await ln(W(ve), 5, xe)), p()) {
      let Je = await p()(ze.map((ut) => ut.rects));
      for (let ut = 0; ut < ze.length; ut++)
        ze[ut].label = Je[ut];
    }
    let We = ze.filter((Je) => Je.label != null && Je.label.length > 0).map((Je) => ({
      x: Je.x,
      y: Je.y,
      text: Je.label,
      priority: Je.sumDensity,
      level: Je.bandwidth == 10 ? 0 : 1
    }));
    return z() != null && await z().set(Te, We), We;
  }
  async function ua(xe) {
    if (W(ve) != null)
      if (d() != null)
        ht(Ce, await cO(o(), s(), xe, d(), W(P).fontFamily), !0);
      else {
        ht(Me, "Generating labels...");
        let Te = await wi(xe);
        ht(Ce, await cO(o(), s(), xe, Te, W(P).fontFamily), !0), ht(Me, null);
      }
  }
  class ml {
    content;
    constructor(Te, ze) {
      let We = document.createElement("div");
      this.content = We, this.update(ze), Te.appendChild(We);
    }
    update(Te) {
      let ze = this.content;
      ze.style.fontFamily = Te.fontFamily, W(N) == "light" ? (ze.style.color = "#000", ze.style.background = "#fff", ze.style.border = "1px solid #000") : (ze.style.color = "#ccc", ze.style.background = "#000", ze.style.border = "1px solid #ccc"), ze.style.borderRadius = "2px", ze.style.padding = "5px", ze.style.fontSize = "12px", ze.style.maxWidth = "300px", ze.innerText = Te.tooltip.text ?? JSON.stringify(Te.tooltip);
    }
  }
  var $r = n1e();
  let Qn;
  var Yo = In($r);
  Jt(Yo, "", {}, { position: "absolute", top: "0", left: "0" }), s_(Yo, (xe) => ht(we, xe), () => W(we));
  var yo = Vr(Yo, 2);
  let Es;
  var wc = In(yo);
  {
    var Ap = (xe) => {
      const Te = /* @__PURE__ */ mt(() => uL(_())), ze = /* @__PURE__ */ mt(() => ({
        location: W(j),
        width: o(),
        height: s()
      }));
      var We = im(), Je = Of(We);
      Y0e(Je, () => W(Te), (ut) => {
        var Gt = Qye();
        Ns(Gt, (gr, Er) => W(Te)?.(gr, Er), () => cL(_(), { proxy: W(ze) })), rn(ut, Gt);
      }), rn(xe, We);
    };
    Wi(wc, (xe) => {
      _() && xe(Ap);
    });
  }
  bn(yo);
  var ca = Vr(yo, 2);
  Jt(ca, "", {}, { position: "absolute", left: "0", top: "0" });
  var F0 = In(ca);
  {
    var T0 = (xe) => {
      const Te = /* @__PURE__ */ mt(() => {
        const { x: Gt, y: gr } = W(j)(g().x, g().y);
        return { x: Gt, y: gr };
      }), ze = /* @__PURE__ */ mt(() => Math.max(3, W(Xt) / a()) + 1);
      var We = im(), Je = Of(We);
      {
        var ut = (Gt) => {
          var gr = Jye();
          let Er;
          Lo(() => {
            je(gr, "cx", W(Te).x), je(gr, "cy", W(Te).y), je(gr, "r", W(ze)), Er = Jt(gr, "", Er, {
              stroke: W(N) == "light" ? "#000" : "#fff",
              "stroke-width": 1,
              fill: "none"
            });
          }), rn(Gt, gr);
        };
        Wi(Je, (Gt) => {
          isFinite(W(Te).x) && isFinite(W(Te).y) && isFinite(W(ze)) && Gt(ut);
        });
      }
      rn(xe, We);
    };
    Wi(F0, (xe) => {
      g() != null && W(ve) != null && xe(T0);
    });
  }
  var M0 = Vr(F0);
  {
    var Qx = (xe) => {
      var Te = im(), ze = Of(Te);
      Dk(ze, 17, v, Ek, (We, Je) => {
        const ut = /* @__PURE__ */ mt(() => {
          const { x: Tn, y: bo } = W(j)(W(Je).x, W(Je).y);
          return { x: Tn, y: bo };
        }), Gt = /* @__PURE__ */ mt(() => W(Je).category != null ? W(I)[W(Je).category] : W(I)[0]), gr = /* @__PURE__ */ mt(() => Math.max(3, W(Xt) / a()) + 1);
        var Er = im(), un = Of(Er);
        {
          var Zo = (Tn) => {
            var bo = Yye();
            let Ds;
            Lo(() => {
              je(bo, "cx", W(ut).x), je(bo, "cy", W(ut).y), je(bo, "r", W(gr)), Ds = Jt(bo, "", Ds, {
                stroke: W(N) == "light" ? "#000" : "#fff",
                "stroke-width": 2,
                fill: W(Gt)
              });
            }), rn(Tn, bo);
          };
          Wi(un, (Tn) => {
            isFinite(W(ut).x) && isFinite(W(ut).y) && isFinite(W(gr)) && Tn(Zo);
          });
        }
        rn(We, Er);
      }), rn(xe, Te);
    };
    Wi(M0, (xe) => {
      v() != null && W(ve) != null && xe(Qx);
    });
  }
  var P0 = Vr(M0);
  {
    var Ep = (xe) => {
      var Te = r1e();
      Dk(Te, 21, () => W(Ce), Ek, (ze, We) => {
        const Je = /* @__PURE__ */ mt(() => W(We).text.split(`
`)), ut = /* @__PURE__ */ mt(() => W(j)(W(We).coordinate.x, W(We).coordinate.y)), Gt = /* @__PURE__ */ mt(() => W(We).placement != null && W(We).placement.minScale <= W(B).scale && W(B).scale <= W(We).placement.maxScale);
        var gr = t1e(), Er = In(gr);
        {
          var un = (Zo) => {
            var Tn = e1e();
            Dk(Tn, 21, () => W(Je), Ek, (bo, Ds, Op) => {
              var Os = Zye();
              je(Os, "x", 0);
              let gl;
              var vl = In(Os, !0);
              bn(Os), Lo(() => {
                je(Os, "y", (Op - (W(Je).length - 1) / 2) * W(We).fontSize), je(Os, "font-size", W(We).fontSize), gl = Jt(Os, "", gl, {
                  "paint-order": "stroke",
                  "stroke-width": "4",
                  "stroke-linejoin": "round",
                  "stroke-linecap": "round",
                  "text-anchor": "middle",
                  fill: W(P).clusterLabelColor,
                  stroke: W(P).clusterLabelOutlineColor,
                  opacity: W(P).clusterLabelOpacity,
                  "user-select": "none",
                  "-webkit-user-select": "none",
                  "font-family": W(P).fontFamily
                }), jm(vl, W(Ds));
              }), rn(bo, Os);
            }), bn(Tn), rn(Zo, Tn);
          };
          Wi(Er, (Zo) => {
            W(Gt) && Zo(un);
          });
        }
        bn(gr), Lo(() => je(gr, "transform", `translate(${W(ut).x ?? ""},${W(ut).y ?? ""})`)), rn(ze, gr);
      }), bn(Te), rn(xe, Te);
    };
    Wi(P0, (xe) => {
      xe(Ep);
    });
  }
  var Jx = Vr(P0);
  {
    var Dp = (xe) => {
      var Te = im(), ze = Of(Te);
      {
        var We = (ut) => {
          vve(ut, {
            get value() {
              return b();
            },
            get pointLocation() {
              return W(j);
            }
          });
        }, Je = (ut) => {
          uve(ut, {
            get value() {
              return b();
            },
            onChange: ce,
            get pointLocation() {
              return W(j);
            },
            get coordinateAtPoint() {
              return W(U);
            },
            preventHover: (Gt) => {
              ht(H, Gt, !0);
            }
          });
        };
        Wi(ze, (ut) => {
          b() instanceof Array ? ut(We) : ut(Je, !1);
        });
      }
      rn(xe, Te);
    };
    Wi(Jx, (xe) => {
      b() != null && W(ve) != null && xe(Dp);
    });
  }
  bn(ca), Ns(ca, (xe, Te) => vn?.(xe, Te), () => ({ click: Tt, drag: mr, hover: Ar }));
  var R0 = Vr(ca, 2);
  {
    var Yx = (xe) => {
      const Te = /* @__PURE__ */ mt(() => W(j)(g().x, g().y));
      {
        let ze = /* @__PURE__ */ mt(() => Math.max(3, W(Xt) / a())), We = /* @__PURE__ */ mt(() => S() ?? {
          class: ml,
          props: {
            colorScheme: W(N),
            fontFamily: W(P).fontFamily
          }
        });
        Ove(xe, {
          get location() {
            return W(Te);
          },
          get allowInteraction() {
            return W(re);
          },
          get targetHeight() {
            return W(ze);
          },
          get customTooltip() {
            return W(We);
          },
          get tooltip() {
            return g();
          }
        });
      }
    };
    Wi(R0, (xe) => {
      g() != null && W(ve) != null && xe(Yx);
    });
  }
  var Zx = Vr(R0, 2);
  {
    var ew = (xe) => {
      {
        let Te = /* @__PURE__ */ mt(() => W(Me) ?? W(Ge)), ze = /* @__PURE__ */ mt(() => 1 / (W(j)(1, 0).x - W(j)(0, 0).x));
        Ave(xe, {
          get resolvedTheme() {
            return W(P);
          },
          get statusMessage() {
            return W(Te);
          },
          get distancePerPoint() {
            return W(ze);
          },
          get pointCount() {
            return r().x.length;
          },
          get selectionMode() {
            return W(Pe);
          },
          onSelectionMode: (We) => ht(Pe, We, !0)
        });
      }
    };
    Wi(Zx, (xe) => {
      W(P).statusBar && xe(ew);
    });
  }
  bn($r), Lo(() => {
    Qn = Jt($r, "", Qn, {
      width: `${o() ?? ""}px`,
      height: `${s() ?? ""}px`,
      position: "relative"
    }), Es = Jt(yo, "", Es, {
      width: `${o() ?? ""}px`,
      height: `${s() ?? ""}px`,
      position: "absolute",
      top: "0",
      left: "0"
    }), je(ca, "width", o()), je(ca, "height", s());
  }), j0e("wheel", ca, tt), rn(t, $r), Gh();
}
function mO(t, e) {
  if (e.length == 0)
    return T.literal(!1);
  if (t.identifier != null) {
    let r = t.identifier;
    return T.or(...e.map((n) => T.eq(T.column(r), T.literal(n.identifier))));
  } else {
    let r = t.x, n = t.y, i = t.category;
    return i != null ? T.or(
      ...e.map(
        (o) => T.and(
          T.eq(T.cast(T.column(r), "DOUBLE"), T.literal(o.x)),
          T.eq(T.cast(T.column(n), "DOUBLE"), T.literal(o.y)),
          T.eq(T.cast(T.column(i), "INTEGER"), T.literal(o.category))
        )
      )
    ) : T.or(
      ...e.map(
        (o) => T.and(
          T.eq(T.cast(T.column(r), "DOUBLE"), T.literal(o.x)),
          T.eq(T.cast(T.column(n), "DOUBLE"), T.literal(o.y))
        )
      )
    );
  }
}
function o1e(t, e, r) {
  let n = [];
  for (let o = 0; o < r.length; o++) {
    let s = (o + 1) % r.length, { x: a, y: l } = r[o], { x: u, y: c } = r[s], h = l < c ? T.and(T.lte(T.literal(l), e), T.lt(e, T.literal(c))) : T.and(T.lte(T.literal(c), e), T.lt(e, T.literal(l))), d = (l < c ? T.lt : T.gt)(
      T.sub(T.mul(T.literal(u - a), e), T.mul(T.literal(c - l), t)),
      T.literal((u - a) * l - (c - l) * a)
    );
    n.push(T.cast(T.and(h, d), "INT"));
  }
  let i = n.reduce((o, s) => T.add(o, s));
  return T.eq(T.mod(i, T.literal(2)), T.literal(1));
}
function s1e(t, e) {
  if (e instanceof Array) {
    if (e.length < 3)
      return T.literal(!1);
    let r = lL(e);
    return T.and(
      T.isBetween(T.column(t.x), [r.xMin, r.xMax]),
      T.isBetween(T.column(t.y), [r.yMin, r.yMax]),
      o1e(T.column(t.x), T.column(t.y), e)
    );
  } else
    return T.and(
      T.isBetween(T.column(t.x), [e.xMin, e.xMax]),
      T.isBetween(T.column(t.y), [e.yMin, e.yMax])
    );
}
async function a1e(t, e) {
  let { x: r, y: n, table: i } = e, o = await t.query(
    T.Query.from(i).select({
      centerX: T.sql`MEDIAN(${T.column(r)})`,
      centerY: T.sql`MEDIAN(${T.column(n)})`,
      stdX: T.sql`STDDEV(${T.column(r)})`,
      stdY: T.sql`STDDEV(${T.column(n)})`,
      ...e.category != null ? {
        maxCategory: T.sql`MAX(${T.column(e.category)}::UTINYINT)`
      } : {}
    })
  ), { centerX: s, centerY: a, stdX: l, stdY: u, maxCategory: c } = o.get(0), h = 1 / (Math.max(l, u, 1e-3) * 3), d = 0.1 / h, p = T.sql`FLOOR((${T.column(r)} - ${s}) / ${d})`, g = T.sql`FLOOR((${T.column(n)} - ${a}) / ${d})`, v = e.category != null ? T.column(e.category) : null, y = v != null ? [p, g, v] : [p, g], b = T.Query.from(
    T.Query.from(i).select({ count: T.sql`COUNT(*)` }).groupby(...y)
  ).select({
    totalCount: T.sql`SUM(count)::INT`,
    maxCount: T.sql`MAX(count)::INT`
  });
  o = await t.query(b);
  let { maxCount: k, totalCount: C } = o.get(0), S = k / (d * d);
  return {
    centerX: s,
    centerY: a,
    scaler: h,
    totalCount: C,
    categoryCount: (c ?? 0) + 1,
    maxDensity: S
  };
}
class l1e {
  coordinator;
  source;
  lastDistance;
  selectParams;
  constructor(e, r) {
    this.coordinator = e, this.source = r, this.lastDistance = 0;
    let { x: n, y: i, category: o, text: s, identifier: a } = this.source, l = {}, u = r.additionalFields ?? {};
    for (let c in u) {
      let h = u[c];
      typeof h == "string" ? l["field_" + c] = T.column(h) : l["field_" + c] = T.sql`${h.sql}`;
    }
    this.selectParams = {
      x: T.sql`${T.column(n)}::DOUBLE`,
      y: T.sql`${T.column(i)}::DOUBLE`,
      ...o != null ? { category: T.sql`${T.column(o)}::INT` } : {},
      ...s != null ? { text: T.sql`${T.column(s)}` } : {},
      ...a != null ? { identifier: T.sql`${T.column(a)}` } : {},
      ...l
    };
  }
  _convertToDataPoint(e) {
    let r = {};
    for (let n in e)
      n.startsWith("field_") && (r[n.slice(6)] = e[n]);
    return {
      x: e.x,
      y: e.y,
      category: e.category,
      text: e.text,
      identifier: e.identifier,
      fields: r
    };
  }
  async queryClosestPoint(e, r, n, i) {
    let o = i * 12, { x: s, y: a } = this.source;
    for (let l of [this.lastDistance, o]) {
      if (l == 0 || l > o)
        continue;
      let u = T.Query.from(this.source.table).select(this.selectParams);
      u = u.where(T.sql`${T.column(s)} BETWEEN ${r - l} AND ${r + l}`), u = u.where(T.sql`${T.column(a)} BETWEEN ${n - l} AND ${n + l}`), e && (u = u.where(e)), u = u.orderby(T.sql`(x - (${r}))**2 + (y - (${n}))**2`).limit(1);
      let c = (await this.coordinator.query(u)).get(0);
      if (c)
        return this.lastDistance = Math.max(Math.abs(c.x - r), Math.abs(c.y - n)) * 4, this._convertToDataPoint(c);
    }
    return null;
  }
  async queryPoints(e) {
    let { table: r, identifier: n } = this.source;
    if (n == null)
      return [];
    let i = T.Query.from(r).select(this.selectParams);
    return i = i.where(
      T.isIn(
        T.column(n),
        e.map((o) => T.literal(o))
      )
    ), Array.from(await this.coordinator.query(i)).map((o) => this._convertToDataPoint(o));
  }
}
function u1e(t, e) {
  Wh(e, !0);
  let r = Ye(e, "coordinator", 19, SF), n = Ye(e, "category", 3, null), i = Ye(e, "text", 3, null), o = Ye(e, "identifier", 3, null), s = Ye(e, "filter", 3, null), a = Ye(e, "categoryColors", 3, null), l = Ye(e, "tooltip", 3, null), u = Ye(e, "additionalFields", 3, null), c = Ye(e, "selection", 3, null), h = Ye(e, "rangeSelection", 3, null), d = Ye(e, "rangeSelectionValue", 3, null), p = Ye(e, "width", 3, null), g = Ye(e, "height", 3, null), v = Ye(e, "pixelRatio", 3, null), y = Ye(e, "config", 3, null), b = Ye(e, "theme", 3, null), k = Ye(e, "viewportState", 3, null), C = Ye(e, "labels", 3, null), S = Ye(e, "customTooltip", 3, null), _ = Ye(e, "customOverlay", 3, null), D = Ye(e, "onViewportState", 3, null), A = Ye(e, "onTooltip", 3, null), O = Ye(e, "onSelection", 3, null), M = Ye(e, "onRangeSelection", 3, null), z = Ye(e, "cache", 3, null), N = /* @__PURE__ */ Rr(new Float32Array()), P = /* @__PURE__ */ Rr(new Float32Array()), I = /* @__PURE__ */ Rr(null), B = /* @__PURE__ */ Rr(1), $ = /* @__PURE__ */ Rr(1), j = /* @__PURE__ */ Rr(1), U = /* @__PURE__ */ Rr(null), H = /* @__PURE__ */ Rr(null), G = /* @__PURE__ */ Rr(null), re = /* @__PURE__ */ Rr(null), ne = /* @__PURE__ */ Rr(null);
  Dl(() => {
    let he = {
      coordinator: r(),
      source: {
        table: e.table,
        x: e.x,
        y: e.y,
        category: n()
      }
    }, we = null, ve = !1;
    async function Ge() {
      let Xe = he.source, et = await a1e(he.coordinator, Xe);
      if (ve)
        return;
      let Qe = et.scaler * 0.95;
      ht(U, {
        x: et.centerX,
        y: et.centerY,
        scale: Qe
      }), ht($, et.totalCount), ht(j, et.maxDensity), ht(B, et.categoryCount), we = ol({
        coordinator: he.coordinator,
        selection: s() ?? void 0,
        query: (Wt) => T.Query.from(Xe.table).select({
          x: T.sql`${T.column(Xe.x)}::FLOAT`,
          y: T.sql`${T.column(Xe.y)}::FLOAT`,
          ...Xe.category != null ? { c: T.sql`${T.column(Xe.category)}::UTINYINT` } : {}
        }).where(Wt),
        queryResult: (Wt) => {
          let At = Wt.getChild("x").toArray(), Xt = Wt.getChild("y").toArray(), Nt = Wt.getChild("c")?.toArray() ?? null;
          At != null && !(At instanceof Float32Array) && (At = new Float32Array(At)), Xt != null && !(Xt instanceof Float32Array) && (Xt = new Float32Array(Xt)), Nt != null && !(Nt instanceof Uint8Array) && (Nt = new Uint8Array(Nt)), ht(N, At), ht(P, Xt), ht(I, Nt), se(null), ie(null);
        }
      }), we.reset = () => {
        ce();
      }, ht(ne, we);
    }
    return Ge(), () => {
      ht(ne, null), ve = !0, we?.destroy();
    };
  }), Dl(() => {
    if (o3(l())) {
      let he = W(ne);
      if (he == null)
        return;
      let we = l();
      ht(H, we.valueFor(he) ?? null);
      let ve = () => {
        ht(H, we.valueFor(he) ?? null);
      };
      return Dl(() => {
        let Ge = W(H), Xe = {
          x: e.x,
          y: e.y,
          category: n(),
          identifier: o()
        };
        we.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          predicate: Ge != null ? mO(Xe, [Ge]) : null,
          value: Ge
        });
      }), we.addEventListener("value", ve), () => {
        we.removeEventListener("value", ve), we.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          value: null,
          predicate: null
        });
      };
    } else if (l() == null || typeof l() == "object")
      ht(H, l());
    else {
      if (W(H)?.identifier == l())
        return;
      let he = !1;
      return Pe([l()]).then((we) => {
        he || (we.length > 0 ? ht(H, we[0]) : ht(H, null));
      }), () => {
        he = !0;
      };
    }
  });
  function se(he) {
    Bu(l(), he) || (ht(H, he), A()?.(he));
  }
  Dl(() => {
    if (o3(c())) {
      let he = W(ne);
      if (he == null)
        return;
      let we = c();
      ht(G, we.valueFor(he) ?? null);
      let ve = () => {
        ht(G, we.valueFor(he) ?? null);
      };
      return Dl(() => {
        let Ge = W(G), Xe = {
          x: e.x,
          y: e.y,
          category: n(),
          identifier: o()
        };
        we.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          predicate: Ge != null ? mO(Xe, Ge) : null,
          value: Ge
        });
      }), we.addEventListener("value", ve), () => {
        we.removeEventListener("value", ve), we.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          value: null,
          predicate: null
        });
      };
    } else if (c() == null)
      ht(G, null);
    else if (c().length == 0)
      ht(G, []);
    else if (c().every((he) => typeof he == "object"))
      ht(G, c());
    else {
      let he = !1;
      return Pe(c()).then((we) => {
        he || ht(G, we);
      }), () => {
        he = !0;
      };
    }
  });
  function ie(he) {
    Bu(c(), he) || (ht(G, he), O()?.(he));
  }
  Dl(() => {
    let he = W(ne);
    if (he == null)
      return;
    let we = h();
    if (we != null)
      return Dl(() => {
        let ve = W(re), Ge = { x: e.x, y: e.y }, Xe = {
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          predicate: ve != null ? s1e(Ge, ve) : null,
          value: ve
        };
        we.update(Xe), we.activate(Xe);
      }), () => {
        we.update({
          source: he,
          clients: (/* @__PURE__ */ new Set()).add(he),
          value: null,
          predicate: null
        });
      };
  }), Dl(() => {
    Bu(Xh(() => W(re)), d()) || ht(re, d());
  });
  function ce() {
    ie(null), se(null), M()?.(null), ht(re, null);
  }
  let Ce = /* @__PURE__ */ mt(() => new l1e(r(), {
    table: e.table,
    x: e.x,
    y: e.y,
    category: n(),
    text: i(),
    identifier: o(),
    additionalFields: u()
  }));
  async function Me(he, we, ve) {
    return await W(Ce).queryClosestPoint(s()?.predicate?.(W(ne)), he, we, ve);
  }
  async function Pe(he) {
    return await W(Ce).queryPoints(he);
  }
  async function Ae(he) {
    if (i() == null)
      return he.map(() => null);
    let we = await Lye({
      regions: he,
      stopWords: y()?.autoLabelStopWords ?? null
    }), ve = 0, Ge = 1e4, Xe = null;
    for (; ; ) {
      let Qe = await r().query(T.Query.from(e.table).select({
        x: T.column(e.x),
        y: T.column(e.y),
        text: T.column(i())
      }).offset(ve).limit(Ge)), Wt = {
        x: Qe.getChild("x").toArray(),
        y: Qe.getChild("y").toArray(),
        text: Qe.getChild("text").toArray()
      };
      if (Xe != null && await Xe, Xe = jye(we, Wt), Qe.getChild("text").length < Ge)
        break;
      ve += Ge;
    }
    Xe != null && await Xe;
    let et = await qye(we);
    return await zye(we), et.map((Qe) => Qe.length == 0 ? null : Qe.length > 2 ? Qe.slice(0, 2).join("-") + `-
` + Qe.slice(2).join("-") : Qe.join("-"));
  }
  {
    let he = /* @__PURE__ */ mt(() => p() ?? 800), we = /* @__PURE__ */ mt(() => g() ?? 800), ve = /* @__PURE__ */ mt(() => v() ?? 2), Ge = /* @__PURE__ */ mt(() => ({
      x: W(N),
      y: W(P),
      category: W(I)
    }));
    i1e(t, {
      get width() {
        return W(he);
      },
      get height() {
        return W(we);
      },
      get pixelRatio() {
        return W(ve);
      },
      get theme() {
        return b();
      },
      get config() {
        return y();
      },
      get data() {
        return W(Ge);
      },
      get totalCount() {
        return W($);
      },
      get maxDensity() {
        return W(j);
      },
      get categoryCount() {
        return W(B);
      },
      get categoryColors() {
        return a();
      },
      get defaultViewportState() {
        return W(U);
      },
      querySelection: Me,
      queryClusterLabels: Ae,
      get labels() {
        return C();
      },
      get customTooltip() {
        return S();
      },
      get customOverlay() {
        return _();
      },
      get tooltip() {
        return W(H);
      },
      onTooltip: se,
      get selection() {
        return W(G);
      },
      onSelection: ie,
      get viewportState() {
        return k();
      },
      get onViewportState() {
        return D();
      },
      get rangeSelection() {
        return W(re);
      },
      onRangeSelection: (Xe) => {
        ht(re, Xe), M()?.(Xe);
      },
      get cache() {
        return z();
      }
    });
  }
  Gh();
}
class c1e {
  component;
  currentProps;
  constructor(e, r) {
    this.currentProps = { ...r }, this.component = K0e({ component: u1e, target: e, props: r });
  }
  update(e) {
    let r = {};
    for (let n in e)
      e[n] !== this.currentProps[n] && (r[n] = e[n], this.currentProps[n] = e[n]);
    this.component.$set(r);
  }
  destroy() {
    this.component.$destroy();
  }
}
function h1e() {
  return aB() ? 32 : 4;
}
function xy(t, e = 0) {
  let r = eB(t);
  return r.l += e, r.a = 0, r.b = 0, r.rgb().formatHex8();
}
const xc = {
  light: {
    scheme: "light",
    continuousColorScheme: "YlGnBu",
    continuousColorSchemeAtZero: qge(0),
    markColor: "#3b82f6",
    markColorFade: "#dbeafe",
    markColorGray: xy("#3b82f6", 20),
    markColorGrayFade: xy("#dbeafe"),
    gridColor: Is.slate[300],
    labelColor: Is.slate[400],
    titleColor: Is.slate[400],
    brushBorder: Is.slate[500],
    brushBorderBack: "#fff",
    brushFill: "rgba(0,0,0,0.1)"
  },
  dark: {
    scheme: "dark",
    continuousColorScheme: "Inferno",
    continuousColorSchemeAtZero: sB(0),
    markColor: "#3b82f6",
    markColorFade: "#3b4d7f",
    markColorGray: xy("#3b82f6", -20),
    markColorGrayFade: xy("#1f398a"),
    gridColor: Is.slate[700],
    labelColor: Is.slate[500],
    titleColor: Is.slate[500],
    brushBorder: Is.slate[400],
    brushBorderBack: "#000",
    brushFill: "rgba(255,255,255,0.1)"
  }
};
function SL(t) {
  let e = [];
  for (let r = 0; r < t; r++)
    e.push(Uge((r + 0.5) / t));
  return e;
}
const AL = "system-ui", c_ = 11, f1e = 80;
let sm;
function d1e() {
  return sm == null && (sm = document.createElement("canvas"), sm.width = 1, sm.height = 1), sm.getContext("2d");
}
function h_(t) {
  let e = d1e();
  e.font = `${c_}px ${AL}`;
  let r = e.measureText(t);
  return {
    width: Math.min(f1e, r.width),
    height: c_
  };
}
function EL(t, e, r = 0) {
  let n = 0, i = 0;
  for (let o of t) {
    let { width: s, height: a } = o.size;
    n = Math.max(n, s), i = Math.max(i, a);
  }
  switch (e) {
    case "x":
      return { left: n / 2, right: n / 2, top: 0, bottom: i + r };
    case "y":
      return { left: n + r, right: 0, top: i / 2, bottom: i / 2 };
  }
}
function gO(t, e, r) {
  switch (t.type) {
    case "band":
      return p1e(t, e, r);
    default:
      return m1e(t, e, r);
  }
}
function p1e(t, e, r) {
  let n = [...t.domain, ...t.specialValues ?? []];
  n = Array.from(new Set(n)), r == "y" && (n = n.reverse());
  let i = VI().domain(n).padding(0.1), o = [], s = [], a = { left: 0, right: 0, top: 0, bottom: 0 };
  if (e) {
    let l = e.values ?? i.domain(), u = e.labelPadding ?? 6;
    o = l.map((c) => {
      let { width: h, height: d } = h_(c);
      return r == "y" ? {
        text: c,
        value: c,
        padding: u,
        level: 0,
        size: { width: h, height: d },
        orientation: "horizontal"
      } : {
        text: c,
        value: c,
        padding: u,
        level: 0,
        size: { width: d, height: h },
        orientation: "vertical"
      };
    }), s = l.map((c) => ({ value: c, level: 0 })), a = QS([a, EL(o, r, u)]);
  }
  return {
    extents: a,
    labels: o,
    gridLines: [],
    ticks: s,
    concrete: (l) => v1e(i, t.domain, t.specialValues ?? [], l)
  };
}
function m1e(t, e, r) {
  let n;
  switch (t.type) {
    case "linear": {
      n = hp().domain(t.domain);
      break;
    }
    case "log": {
      n = $g().domain(t.domain);
      break;
    }
    case "symlog": {
      let a = t.constant ?? 1;
      n = iB().constant(a).domain(t.domain), n.nice = () => n, n.ticks = (l) => y1e(n.domain(), a, l), n.tickFormat = () => su("~s");
      break;
    }
    default:
      throw new Error("invalid scale type");
  }
  let i = [], o = [], s = { left: 0, right: 0, top: 0, bottom: 0 };
  if (e) {
    let a = [];
    if (e.extendScaleToTicks ?? !0)
      if (e.values) {
        a = e.values;
        let h = n.domain().concat(a);
        n = n.domain([
          h.reduce((d, p) => Math.min(d, p), h[0]),
          h.reduce((d, p) => Math.max(d, p), h[0])
        ]);
      } else {
        let h = e.desiredTickCount ?? 5;
        n.nice && (n = n.nice(h)), a = n.ticks(h);
      }
    else {
      if (e.values)
        a = e.values;
      else {
        let p = e.desiredTickCount ?? 5;
        a = n.ticks(p);
      }
      let [h, d] = n.domain();
      a = a.filter((p) => p >= h && p <= d);
    }
    let l = e.labelPadding ?? 6, u = n.tickFormat(e.values ? e.values.length : e.desiredTickCount ?? 5), c = (h) => t.type == "log" || t.type == "symlog" ? Math.round(Math.log10(Math.abs(h))) == Math.log10(Math.abs(h)) ? 0 : 1 : 0;
    i = a.map((h) => {
      let d = u(h);
      return {
        text: d,
        value: h,
        padding: l,
        level: c(h),
        size: h_(d),
        orientation: "horizontal"
      };
    });
    for (let h of t.specialValues ?? [])
      i.push({
        text: h,
        value: h,
        padding: l,
        level: 0,
        size: h_(h),
        orientation: "horizontal"
      });
    o = a.map((h) => ({ value: h, level: c(h) })), s = QS([s, EL(i, r, l)]);
  }
  return {
    extents: s,
    labels: i,
    gridLines: o,
    ticks: o,
    concrete: (a) => g1e(n, t.specialValues ?? [], a)
  };
}
function QS(t) {
  let e = { left: 0, right: 0, top: 0, bottom: 0 };
  for (let r of t)
    e.left = Math.max(e.left, r.left), e.right = Math.max(e.right, r.right), e.top = Math.max(e.top, r.top), e.bottom = Math.max(e.bottom, r.bottom);
  return e;
}
function vO(t, e, r = {}) {
  let n = r.gap ?? 0, i = t.map((a, l) => ({ ...e(a), index: l })).sort((a, l) => a.priority - l.priority), o = t.map((a) => !1), s = (a, l) => Math.abs(a.center - l.center) < n + a.length / 2 + l.length / 2;
  for (let a = 0; a < i.length; a++) {
    let l = !1;
    for (let u = 0; u < a; u++)
      if (o[i[u].index] && s(i[a], i[u])) {
        l = !0;
        break;
      }
    o[i[a].index] = !l;
  }
  return t.filter((a, l) => o[l]);
}
function g1e(t, e, r) {
  e = Array.from(new Set(e));
  let n = r[0], i = r[1], o = /* @__PURE__ */ new Map(), s;
  if (e.length > 0) {
    let l = 22, u = 8, c = 20, h = e.length * c, d = 2, p = n;
    n < i ? (n = n + h + l, s = [p, p + h + l - u]) : (n = n - h - l, p = n + l, s = [p - l + u, p + h]);
    for (let g = 0; g < e.length; g++)
      o.set(e[g], [p + g * c + d, p + g * c + c - d]);
  }
  let a = t.copy().range([n, i]);
  return {
    domain: t.domain(),
    specialValues: e ?? [],
    range: [n, i],
    rangeBands: [[n, i], ...s ? [s] : []],
    apply: (l) => {
      let u = o.get(l);
      return u != null ? (u[0] + u[1]) / 2 : a(l);
    },
    applyBand: (l) => {
      let u = o.get(l);
      if (u != null)
        return u;
      if (typeof l != "number")
        return [a(l[0]), a(l[1])];
      {
        let c = a(l);
        return [c, c];
      }
    },
    invert: (l, u) => {
      if (u != "number") {
        for (let [c, h] of o.entries())
          if (l >= Math.min(...h) && l <= Math.max(...h))
            return c;
      }
      return a.invert(l);
    }
  };
}
function v1e(t, e, r, n) {
  let i = n[0], o = n[1], s = t.copy().range(n), a = s.bandwidth(), l = s.step();
  return {
    domain: e,
    specialValues: r,
    range: [i, o],
    rangeBands: [[i, o]],
    apply: (u) => (s(u) ?? 0) + a / 2,
    applyBand: (u) => {
      let c = s(u) ?? 0;
      return [c, c + a];
    },
    invert: (u) => {
      let c = (u - i) / (o - i), h = Math.floor(c * Math.abs(o - i) / l);
      return t.domain()[h];
    }
  };
}
function y1e(t, e, r) {
  r = r ?? 5;
  let n = t[0], i = t[1];
  if (n > 0 && i > 0 && n / i > 0.5 || n < 0 && i < 0 && i / n > 0.5)
    return hp().domain([n, i]).ticks(r);
  let o = e * 2, s = e * 5;
  return n < -s && i > s && (r = Math.ceil(r / 2)), [
    ...n < -s ? $g().domain([o, -n]).ticks(r).map((a) => -a) : [],
    0,
    ...i > s ? $g().domain([o, i]).ticks(r) : []
  ].filter((a) => a >= n && a <= i);
}
function b1e(t, e) {
  let { min: r, max: n, median: i, count: o, minPositive: s } = t, a = {
    type: "linear",
    domain: [r, n]
  };
  return e == null ? o >= 100 && r >= 0 && i < n * 0.05 && (a.type = r > 0 ? "log" : "symlog") : a.type = e, a.type == "log" && (a.domain[0] = s), a;
}
function x1e(t, e = {}) {
  let r = e.fade ?? [], n = e.ordinal ?? !1, i = [], o = (l) => JSON.stringify(l);
  for (let l of t) {
    let u = o(l);
    typeof l == "string" && r.indexOf(l) >= 0 || i.push(u);
  }
  let s = n ? SL(i.length) : gp(i.length), a = new Map(i.map((l, u) => [l, s[u]]));
  return {
    domain: t,
    apply: (l) => {
      let u = o(l);
      return a.get(u) ?? "#888888";
    }
  };
}
var w1e = /* @__PURE__ */ St("<g><foreignObject><div> </div></foreignObject></g>");
function yO(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => e.dimension == "x" ? {
    px: e.proxy.xScale?.apply(e.label.value) ?? 0,
    py: e.proxy.plotHeight + e.label.padding,
    anchorX: 0.5,
    anchorY: 0
  } : {
    px: -e.label.padding,
    py: e.proxy.yScale?.apply(e.label.value) ?? 0,
    anchorX: 1,
    anchorY: 0.5
  }), n = /* @__PURE__ */ K(() => x(r).px), i = /* @__PURE__ */ K(() => x(r).py), o = /* @__PURE__ */ K(() => x(r).anchorX), s = /* @__PURE__ */ K(() => x(r).anchorY), a = /* @__PURE__ */ K(() => e.label.orientation == "vertical" ? {
    rotation: 90,
    shiftX: x(o) * e.label.size.width,
    shiftY: -x(s) * e.label.size.height,
    width: e.label.size.height,
    height: e.label.size.width
  } : {
    rotation: 0,
    shiftX: -x(o) * e.label.size.width,
    shiftY: -x(s) * e.label.size.height,
    width: e.label.size.width,
    height: e.label.size.height
  }), l = /* @__PURE__ */ K(() => x(a).rotation), u = /* @__PURE__ */ K(() => x(a).shiftX), c = /* @__PURE__ */ K(() => x(a).shiftY), h = /* @__PURE__ */ K(() => x(a).width), d = /* @__PURE__ */ K(() => x(a).height), p = 4, g = 4;
  var v = w1e(), y = Y(v);
  te(y, "x", -p), te(y, "y", -g);
  var b = Y(y);
  let k;
  var C = Y(b, !0);
  J(b), J(y), J(v), Ee(() => {
    te(v, "transform", `translate(${x(n) + x(u)}, ${x(i) + x(c)}) rotate(${x(l) ?? ""})`), te(y, "width", x(h) + p * 2), te(y, "height", x(d) + g * 2), te(b, "title", e.label.text), k = ct(b, "", k, {
      width: `${x(h) + 2}px`,
      height: `${x(d) + g * 2}px`,
      "line-height": `${x(d) + g * 2}px`,
      "font-family": AL,
      "font-size": `${c_}px`,
      "margin-left": "4px",
      color: e.color,
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }), at(C, e.label.text);
  }), Q(t, v), it();
}
var k1e = /* @__PURE__ */ St('<line stroke-linecap="butt"></line>'), C1e = /* @__PURE__ */ St('<line stroke-dasharray="1,3" stroke-linecap="square"></line>'), _1e = /* @__PURE__ */ St("<g><!><!><!></g>"), S1e = /* @__PURE__ */ St('<line stroke-linecap="butt"></line>'), A1e = /* @__PURE__ */ St('<line stroke-linecap="square"></line>'), E1e = /* @__PURE__ */ St("<g><!><!><!></g>"), D1e = /* @__PURE__ */ me("<div><svg><g><!><!><!><!></g></svg></div>");
function zd(t, e) {
  nt(e, !0);
  const r = 4;
  let n = lt(e, "xAxis", 19, () => ({})), i = lt(e, "yAxis", 19, () => ({})), o = /* @__PURE__ */ K(() => e.xScale ? gO(e.xScale, n(), "x") : null), s = /* @__PURE__ */ K(() => e.yScale ? gO(e.yScale, i(), "y") : null), a = /* @__PURE__ */ K(() => QS([
    x(o)?.extents,
    x(s)?.extents,
    e.extents
  ].filter((M) => M != null))), l = /* @__PURE__ */ K(() => ({
    x: x(a).left,
    y: x(a).top,
    width: e.width - x(a).left - x(a).right,
    height: e.height - x(a).top - x(a).bottom
  })), u = /* @__PURE__ */ K(() => x(o)?.concrete([0, x(l).width])), c = /* @__PURE__ */ K(() => x(s)?.concrete([x(l).height, 0])), h = /* @__PURE__ */ K(() => x(o) && x(u) ? vO(
    x(o).labels,
    (M) => ({
      center: x(u).apply(M.value),
      length: M.size.width,
      priority: M.level
    }),
    { gap: 4 }
  ) : []), d = /* @__PURE__ */ K(() => x(s) && x(c) ? vO(
    x(s).labels,
    (M) => ({
      center: x(c).apply(M.value),
      length: M.size.height,
      priority: M.level
    }),
    { gap: 2 }
  ) : []), p = /* @__PURE__ */ K(() => xc[e.colorScheme ?? "light"]), g = /* @__PURE__ */ K(() => ({
    xScale: x(u),
    yScale: x(c),
    plotWidth: x(l).width,
    plotHeight: x(l).height
  }));
  var v = D1e();
  let y;
  var b = Y(v);
  ct(b, "", {}, { position: "absolute", left: "-4px", top: "-4px" });
  var k = Y(b), C = Y(k);
  Jl(C, () => e.childrenBelow ?? jt, () => x(g));
  var S = le(C);
  {
    var _ = (M) => {
      var z = _1e(), N = Y(z);
      It(N, 17, () => x(o).ticks, hr, (B, $) => {
        const j = /* @__PURE__ */ K(() => x(u).apply(x($).value));
        var U = k1e();
        Ee(() => {
          te(U, "x1", x(j)), te(U, "y1", x(l).height), te(U, "x2", x(j)), te(U, "y2", x(l).height + (x($).level == 0 ? 3 : 0)), te(U, "stroke", x(p).gridColor), te(U, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
        }), Q(B, U);
      });
      var P = le(N);
      It(P, 17, () => x(o).gridLines, hr, (B, $) => {
        const j = /* @__PURE__ */ K(() => x(u).apply(x($).value));
        var U = kr(), H = He(U);
        It(H, 17, () => x(c)?.rangeBands ?? [], hr, (G, re) => {
          var ne = /* @__PURE__ */ K(() => aD(x(re), 2));
          let se = () => x(ne)[0], ie = () => x(ne)[1];
          var ce = C1e();
          Ee(
            (Ce, Me) => {
              te(ce, "x1", x(j)), te(ce, "y1", Ce), te(ce, "x2", x(j)), te(ce, "y2", Me), te(ce, "stroke", x(p).gridColor), te(ce, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
            },
            [() => Math.min(se(), ie()), () => Math.max(se(), ie())]
          ), Q(G, ce);
        }), Q(B, U);
      });
      var I = le(P);
      It(I, 17, () => x(h), hr, (B, $) => {
        yO(B, {
          get label() {
            return x($);
          },
          dimension: "x",
          get proxy() {
            return x(g);
          },
          get color() {
            return x(p).labelColor;
          }
        });
      }), J(z), Q(M, z);
    };
    Fe(S, (M) => {
      x(o) && x(u) && n() && M(_);
    });
  }
  var D = le(S);
  {
    var A = (M) => {
      var z = E1e(), N = Y(z);
      It(N, 17, () => x(s).ticks, hr, (B, $) => {
        const j = /* @__PURE__ */ K(() => x(c).apply(x($).value));
        var U = S1e();
        te(U, "x2", 0), Ee(() => {
          te(U, "x1", -(x($).level == 0 ? 3 : 0)), te(U, "y1", x(j)), te(U, "y2", x(j)), te(U, "stroke", x(p).gridColor), te(U, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
        }), Q(B, U);
      });
      var P = le(N);
      It(P, 17, () => x(s).gridLines, hr, (B, $) => {
        const j = /* @__PURE__ */ K(() => x(c).apply(x($).value));
        var U = kr(), H = He(U);
        It(H, 17, () => x(u)?.rangeBands ?? [], hr, (G, re) => {
          var ne = /* @__PURE__ */ K(() => aD(x(re), 2));
          let se = () => x(ne)[0], ie = () => x(ne)[1];
          var ce = A1e();
          Ee(() => {
            te(ce, "x1", se()), te(ce, "y1", x(j)), te(ce, "x2", ie()), te(ce, "y2", x(j)), te(ce, "stroke", x(p).gridColor), te(ce, "stroke-opacity", x($).level == 0 ? 1 : 0.4);
          }), Q(G, ce);
        }), Q(B, U);
      });
      var I = le(P);
      It(I, 17, () => x(d), hr, (B, $) => {
        yO(B, {
          get label() {
            return x($);
          },
          dimension: "y",
          get proxy() {
            return x(g);
          },
          get color() {
            return x(p).labelColor;
          }
        });
      }), J(z), Q(M, z);
    };
    Fe(D, (M) => {
      x(s) && x(c) && i() && M(A);
    });
  }
  var O = le(D);
  Jl(O, () => e.children ?? jt, () => x(g)), J(k), J(b), J(v), Ee(() => {
    y = ct(v, "", y, {
      width: `${e.width ?? ""}py`,
      height: `${e.height ?? ""}px`,
      position: "relative",
      "user-select": "none",
      "-webkit-user-select": "none",
      cursor: "default"
    }), te(b, "width", e.width + r * 2), te(b, "height", e.height + r * 2), te(k, "transform", `translate(${r + x(l).x},${r + x(l).y})`);
  }), Q(t, v), it();
}
var O1e = /* @__PURE__ */ St('<rect role="none"></rect><rect role="none"></rect>', 1), F1e = /* @__PURE__ */ St('<rect role="none"></rect><rect role="none"></rect>', 1), T1e = /* @__PURE__ */ St('<rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect>', 1), M1e = /* @__PURE__ */ St('<rect></rect><rect role="none"></rect><!><!><!>', 1), P1e = /* @__PURE__ */ St('<g><rect stroke="none" fill="none" role="none"></rect><!></g>');
function Tx(t, e) {
  nt(e, !0);
  const r = 8;
  let n = /* @__PURE__ */ K(() => xc[e.colorScheme ?? "light"]), i, o = /* @__PURE__ */ K(() => e.proxy.xScale != null && e.value?.x != null ? e.proxy.xScale.applyBand(e.value.x) : [0, e.proxy.plotWidth]), s = /* @__PURE__ */ K(() => e.proxy.yScale != null && e.value?.y != null ? e.proxy.yScale.applyBand(e.value.y) : [0, e.proxy.plotHeight]);
  function a(y) {
    return y instanceof Array && y.length == 2 && typeof y[0] == "number" && typeof y[1] == "number";
  }
  function l(y, b, k) {
    let C = y.invert(b, k);
    if (y.domain.length == 2 && typeof y.domain[0] == "number" && typeof C == "number") {
      let [S, _] = y.domain;
      return Math.max(Math.min(S, _), Math.min(Math.max(S, _), C));
    }
    return C;
  }
  function u(y, b) {
    return (b == "x" || b == "xy") && y.x == null ? !1 : !((b == "y" || b == "xy") && y.y == null);
  }
  function c() {
    return (y) => {
      let b = i.getBoundingClientRect().left, k = i.getBoundingClientRect().top, C = y.clientX - b, S = y.clientY - k, _ = e.proxy.xScale ? l(e.proxy.xScale, C) : null, D = e.proxy.yScale ? l(e.proxy.yScale, S) : null;
      if (_ == null && (e.mode == "x" || e.mode == "xy") || D == null && (e.mode == "y" || e.mode == "xy"))
        return;
      let A = (M, z) => typeof M == "number" && typeof z == "number" ? M != z ? [Math.min(M, z), Math.max(M, z)] : null : z, O = (M) => {
        let z = M.clientX - b, N = M.clientY - k, P = e.proxy.xScale ? l(e.proxy.xScale, z, typeof _ == "number" ? "number" : void 0) : null, I = e.proxy.yScale ? l(e.proxy.yScale, N, typeof D == "number" ? "number" : void 0) : null, B = {};
        return (e.mode == "x" || e.mode == "xy") && (B.x = A(_, P)), (e.mode == "y" || e.mode == "xy") && (B.y = A(D, I)), u(B, e.mode) ? B : null;
      };
      return {
        move: (M) => {
          e.onChange(O(M));
        },
        up: (M) => {
          e.onChange(O(M));
        }
      };
    };
  }
  function h(y) {
    return (b) => {
      if (e.value == null)
        return;
      let k = { ...e.value }, { xScale: C, yScale: S } = e.proxy, _ = a(k.x), D = a(k.y), A = [
        ...C && k.x ? C.applyBand(k.x) : [0, 0],
        ...S && k.y ? S.applyBand(k.y) : [0, 0]
      ];
      if (!_) {
        let M = Math.max(y[0], y[1]);
        y = [M, M, y[2], y[3]];
      }
      if (!D) {
        let M = Math.max(y[2], y[3]);
        y = [y[0], y[1], M, M];
      }
      let O = (M) => {
        let z = M.pageX - b.pageX, N = M.pageY - b.pageY, P = [z, z, N, N].map((B, $) => A[$] + B * y[$]), I = { ...k };
        if (C && (e.mode == "x" || e.mode == "xy"))
          if (_) {
            let B = l(C, P[0], "number"), $ = l(C, P[1], "number");
            I.x = B == $ ? null : B < $ ? [B, $] : [$, B];
          } else
            I.x = l(C, (P[0] + P[1]) / 2), typeof I.x != "string" && (I.x = null);
        if (S != null && (e.mode == "y" || e.mode == "xy"))
          if (D) {
            let B = l(S, P[2], "number"), $ = l(S, P[3], "number");
            I.y = B == $ ? null : B < $ ? [B, $] : [$, B];
          } else
            I.y = l(S, (P[2] + P[3]) / 2), typeof I.y != "string" && (I.y = null);
        return u(I, e.mode) || (I = null), I;
      };
      return {
        move: (M) => {
          e.onChange(O(M));
        },
        up: (M) => {
          let z = O(M);
          z && !_ && !D && z.x == k.x && z.y == k.y && (z = null), e.onChange(z);
        }
      };
    };
  }
  var d = P1e(), p = Y(d);
  te(p, "x", 0), te(p, "y", 0), ct(p, "", {}, {
    "pointer-events": "fill",
    "user-select": "none",
    cursor: "crosshair"
  }), Qs(p, (y) => i = y, () => i), Mo(p, (y, b) => vn?.(y, b), () => ({
    click: () => {
      e.onChange(null);
    },
    drag: c()
  }));
  var g = le(p);
  {
    var v = (y) => {
      var b = M1e(), k = He(b);
      let C;
      var S = le(k);
      let _;
      Mo(S, (P, I) => vn?.(P, I), () => ({ drag: h([1, 1, 1, 1]) }));
      var D = le(S);
      {
        var A = (P) => {
          var I = O1e(), B = He(I);
          te(B, "width", r), ct(B, "", {}, {
            cursor: "ew-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo(B, (j, U) => vn?.(j, U), () => ({ drag: h([1, 0, 0, 0]) }));
          var $ = le(B);
          te($, "width", r), ct($, "", {}, {
            cursor: "ew-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo($, (j, U) => vn?.(j, U), () => ({ drag: h([0, 1, 0, 0]) })), Ee(
            (j, U, H, G) => {
              te(B, "x", x(o)[0] - r / 2), te(B, "y", j), te(B, "height", U), te($, "x", x(o)[1] - r / 2), te($, "y", H), te($, "height", G);
            },
            [
              () => Math.min(x(s)[0], x(s)[1]),
              () => Math.abs(x(s)[0] - x(s)[1]),
              () => Math.min(x(s)[0], x(s)[1]),
              () => Math.abs(x(s)[0] - x(s)[1])
            ]
          ), Q(P, I);
        };
        Fe(D, (P) => {
          (e.mode == "x" || e.mode == "xy") && a(e.value.x) && P(A);
        });
      }
      var O = le(D);
      {
        var M = (P) => {
          var I = F1e(), B = He(I);
          te(B, "height", r), ct(B, "", {}, {
            cursor: "ns-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo(B, (j, U) => vn?.(j, U), () => ({ drag: h([0, 0, 1, 0]) }));
          var $ = le(B);
          te($, "height", r), ct($, "", {}, {
            cursor: "ns-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo($, (j, U) => vn?.(j, U), () => ({ drag: h([0, 0, 0, 1]) })), Ee(
            (j, U, H, G) => {
              te(B, "x", j), te(B, "width", U), te(B, "y", x(s)[0] - r / 2), te($, "x", H), te($, "width", G), te($, "y", x(s)[1] - r / 2);
            },
            [
              () => Math.min(x(o)[0], x(o)[1]),
              () => Math.abs(x(o)[0] - x(o)[1]),
              () => Math.min(x(o)[0], x(o)[1]),
              () => Math.abs(x(o)[0] - x(o)[1])
            ]
          ), Q(P, I);
        };
        Fe(O, (P) => {
          (e.mode == "y" || e.mode == "xy") && a(e.value.y) && P(M);
        });
      }
      var z = le(O);
      {
        var N = (P) => {
          var I = T1e(), B = He(I);
          te(B, "width", r), te(B, "height", r), ct(B, "", {}, {
            cursor: "nesw-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo(B, (H, G) => vn?.(H, G), () => ({ drag: h([1, 0, 1, 0]) }));
          var $ = le(B);
          te($, "width", r), te($, "height", r), ct($, "", {}, {
            cursor: "nwse-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo($, (H, G) => vn?.(H, G), () => ({ drag: h([1, 0, 0, 1]) }));
          var j = le($);
          te(j, "width", r), te(j, "height", r), ct(j, "", {}, {
            cursor: "nwse-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo(j, (H, G) => vn?.(H, G), () => ({ drag: h([0, 1, 1, 0]) }));
          var U = le(j);
          te(U, "width", r), te(U, "height", r), ct(U, "", {}, {
            cursor: "nesw-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Mo(U, (H, G) => vn?.(H, G), () => ({ drag: h([0, 1, 0, 1]) })), Ee(() => {
            te(B, "x", x(o)[0] - r / 2), te(B, "y", x(s)[0] - r / 2), te($, "x", x(o)[0] - r / 2), te($, "y", x(s)[1] - r / 2), te(j, "x", x(o)[1] - r / 2), te(j, "y", x(s)[0] - r / 2), te(U, "x", x(o)[1] - r / 2), te(U, "y", x(s)[1] - r / 2);
          }), Q(P, I);
        };
        Fe(z, (P) => {
          e.mode == "xy" && a(e.value.x) && a(e.value.y) && P(N);
        });
      }
      Ee(
        (P, I, B, $, j, U, H, G) => {
          te(k, "x", P), te(k, "width", I), te(k, "y", B), te(k, "height", $), C = ct(k, "", C, {
            stroke: x(n).brushBorderBack,
            fill: "none",
            "stroke-width": 2
          }), te(S, "x", j), te(S, "width", U), te(S, "y", H), te(S, "height", G), _ = ct(S, "", _, {
            stroke: x(n).brushBorder,
            fill: x(n).brushFill,
            cursor: "move"
          });
        },
        [
          () => Math.min(x(o)[0], x(o)[1]),
          () => Math.abs(x(o)[0] - x(o)[1]),
          () => Math.min(x(s)[0], x(s)[1]),
          () => Math.abs(x(s)[0] - x(s)[1]),
          () => Math.min(x(o)[0], x(o)[1]),
          () => Math.abs(x(o)[0] - x(o)[1]),
          () => Math.min(x(s)[0], x(s)[1]),
          () => Math.abs(x(s)[0] - x(s)[1])
        ]
      ), Q(y, b);
    };
    Fe(g, (y) => {
      x(o) && x(s) && e.value && y(v);
    });
  }
  J(d), Ee(() => {
    te(p, "width", e.proxy.plotWidth), te(p, "height", e.proxy.plotHeight);
  }), Q(t, d), it();
}
const R1e = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let DL = (t = 21) => {
  let e = "", r = crypto.getRandomValues(new Uint8Array(t |= 0));
  for (; t--; )
    e += R1e[r[t] & 63];
  return e;
};
var N1e = /* @__PURE__ */ me("<option> </option>"), $1e = /* @__PURE__ */ me('<select class="form-select text-center pl-[4px] pr-[16px] py-0 my-0 border-0 rounded text-sm! text-slate-500 bg-slate-100 dark:text-slate-400 dark:bg-slate-900"></select>');
function Mx(t, e) {
  nt(e, !0);
  let r;
  const n = DL(), i = n + "_null", o = n + "_undefined", s = (d) => d === null ? i : d === void 0 ? o : d.toString(), a = (d) => d === i ? null : d === o ? void 0 : d, l = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 20">
    <path d="M 2,8 L 5,12 L 8,8" style="stroke:${Is.gray[500]};stroke-opacity:0.7;stroke-width:1.5;fill:none;stroke-linecap:round;stroke-linejoin:round" />
  </svg>`;
  var u = $1e();
  u.__change = () => {
    e.onChange(a(r.value));
  };
  let c;
  It(u, 21, () => e.options, hr, (d, p) => {
    var g = N1e(), v = Y(g, !0);
    J(g);
    var y = {};
    Ee(
      (b) => {
        at(v, x(p).label), y !== (y = b) && (g.value = (g.__value = b) ?? "");
      },
      [() => s(x(p).value)]
    ), Q(d, g);
  }), J(u), Qs(u, (d) => r = d, () => r);
  var h;
  s1(u), Ee(
    (d, p) => {
      c = ct(u, "", c, d), h !== (h = p) && (u.value = (u.__value = p) ?? "", bd(u, p));
    },
    [
      () => ({
        "background-image": `url(data:image/svg+xml;base64,${btoa(l) ?? ""})`,
        "background-position": "right center"
      }),
      () => s(e.value)
    ]
  ), Q(t, u), it();
}
nn(["change"]);
var I1e = /* @__PURE__ */ me('<span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm"> </span> <!></span>');
function Dh(t, e) {
  nt(e, !0);
  let r = lt(e, "value", 15);
  const n = ["linear", "log", "symlog"];
  var i = kr(), o = He(i);
  {
    var s = (a) => {
      var l = I1e(), u = Y(l), c = Y(u);
      J(u);
      var h = le(u, 2);
      {
        let d = /* @__PURE__ */ K(() => n.map((p) => ({ value: p, label: p })));
        Mx(h, {
          get options() {
            return x(d);
          },
          get value() {
            return r();
          },
          onChange: (p) => r(p)
        });
      }
      J(l), Ee(() => at(c, `${e.label ?? ""}:`)), Q(a, l);
    };
    Fe(o, (a) => {
      r() != null && r() != "band" && a(s);
    });
  }
  Q(t, i), it();
}
function f_(t) {
  return t == null ? null : t instanceof Array ? t.length == 0 ? null : T.and(t).toString().trim() : typeof t == "string" ? t.trim() : typeof t == "boolean" ? T.literal(t).toString() : t.toString().trim();
}
async function OL(t, e) {
  return Array.from(await t.query(`DESCRIBE ${e}`)).map((r) => ({
    name: r.column_name,
    type: r.column_type,
    jsType: JS(r.column_type)
  }));
}
async function FL(t, e, r) {
  return (await t.query(`SELECT COUNT(DISTINCT ${T.column(r)}) AS count FROM ${e}`)).get(0).count;
}
function JS(t) {
  return B1e.has(t) ? "number" : L1e.has(t) ? "string" : t.match(/^(VARCHAR|TEXT)\[\d*\]$/) ? "string[]" : null;
}
const B1e = /* @__PURE__ */ new Set([
  "REAL",
  "FLOAT4",
  "FLOAT8",
  "FLOAT",
  "DOUBLE",
  "INT",
  "TINYINT",
  "INT1",
  "SMALLINT",
  "INT2",
  "SHORT",
  "INTEGER",
  "INT4",
  "INT",
  "SIGNED",
  "INT8",
  "LONG",
  "BIGINT",
  "UTINYINT",
  "USMALLINT",
  "UINTEGER",
  "UBIGINT",
  "UHUGEINT"
]), L1e = /* @__PURE__ */ new Set(["BOOLEAN", "DATE", "VARCHAR", "CHAR", "BPCHAR", "TEXT", "STRING"]), am = {
  linear: { type: "linear", expr: (t) => t, forward: (t) => t, reverse: (t) => t },
  log: {
    type: "log",
    expr: (t) => T.cond(T.gt(t, 0), T.log(t), T.literal("nan")),
    forward: (t) => Math.log10(t),
    reverse: (t) => Math.pow(10, t)
  },
  symlog: {
    type: "symlog",
    expr: (t, e) => T.mul(T.sign(t), T.ln(T.add(1, T.abs(T.div(t, e))))),
    forward: (t, e) => Math.sign(t) * Math.log1p(Math.abs(t) / e),
    reverse: (t, e) => Math.sign(t) * Math.expm1(Math.abs(t)) * e
  }
};
function z1e(t, e) {
  let r = t, n = 1 / 0;
  for (let i of e) {
    let o = Math.abs(t - i);
    o < n && (n = o, r = i);
  }
  return r;
}
function TL(t, e = {}) {
  let { min: r, max: n, median: i, count: o } = t, s = e.scale;
  s == "band" && (s = null), s == null && (s = "linear", o >= 100 && r >= 0 && i < n * 0.05 && (s = r > 0 ? "log" : "symlog")), r <= 0 && s == "log" && (n <= 0 ? (r = 1, n = 10) : r = Math.min(t.minPositive, n / 10));
  let a = e.desiredCount ?? 5;
  switch (s) {
    case "linear": {
      let l = hp().domain([r, n]).nice(a), u = l.ticks(a);
      return {
        scale: { ...am.linear, domain: l.domain() },
        binStart: l.domain()[0],
        binSize: u[1] - u[0]
      };
    }
    case "log": {
      let l = $g().domain([r, n]).nice(), u = Math.log10(l.domain()[0]), c = (Math.log10(l.domain()[1]) - u) / a;
      return c = z1e(c, [0.05, 0.1, 0.2, 0.5, 1, 1.5, 2]), {
        scale: { ...am.log, domain: l.domain() },
        binStart: u,
        binSize: c
      };
    }
    case "symlog": {
      let l = Math.max(Math.abs(r), Math.abs(n)), u = l >= 100 ? 1 : l > 0 ? l / 1e5 : 1, c = am.symlog.forward(r, u), h = am.symlog.forward(n, u);
      return {
        scale: { ...am.symlog, domain: [r, n], constant: u },
        binStart: c,
        binSize: (h - c) / a
      };
    }
    default:
      throw new Error("invalid scale type");
  }
}
async function eu(t, e, r) {
  let n = (s) => t.query(s), i = (await n(T.Query.describe(T.Query.from(e).select({ field: T.column(r, e) })))).get(0)?.column_type;
  if (i == null)
    return null;
  let o = JS(i);
  if (o == "number") {
    let s = T.cast(T.column(r, e), "DOUBLE"), a = await n(
      T.Query.from(e).select({
        count: T.count(),
        min: T.min(s),
        minPositive: T.min(T.cond(T.gt(s, 0), s, T.literal(null))),
        max: T.max(s),
        mean: T.avg(s),
        median: T.median(s)
      }).where(T.isFinite(s))
    ), l = await n(
      T.Query.from(e).select({
        countNonFinite: T.count()
      }).where(T.or(T.not(T.isFinite(s)), T.isNull(s)))
    );
    return {
      table: e,
      field: r,
      quantitative: { ...a.get(0), ...l.get(0) }
    };
  } else if (o == "string") {
    let s = T.cast(T.column(r, e), "TEXT"), a = Array.from(
      await n(
        T.Query.from(e).select({ value: s, count: T.count() }).where(T.isNotNull(s)).groupby(s).orderby(T.desc(T.count())).limit(1e3)
      )
    ), l = (await n(T.Query.from(e).select({ count: T.count() }).where(T.isNull(s)))).get(0).count, { otherCount: u, numOtherLevels: c } = (await n(
      T.Query.from(e).select({ otherCount: T.count(), numOtherLevels: T.sql`COUNT(DISTINCT(${s}))` }).where(
        T.isNotNull(s),
        T.not(
          T.isIn(
            s,
            a.map((h) => T.literal(h.value))
          )
        )
      )
    )).get(0);
    return {
      table: e,
      field: r,
      nominal: {
        levels: a,
        numOtherLevels: c,
        otherCount: u,
        nullCount: l
      }
    };
  }
  return null;
}
function bp(...t) {
  let e = {}, r = {}, n = {}, i = {}, o = {};
  for (let l of t) {
    if (l.stats.quantitative) {
      let u = TL(l.stats.quantitative, {
        scale: l.scaleType,
        desiredCount: l.binCount ?? 20
      }), c = T.cast(T.column(l.stats.field), "DOUBLE"), h = u.scale.expr(c, u.scale.constant ?? 0);
      e[l.key] = u.scale.type == "log" ? T.cond(
        T.and(T.isFinite(c), T.gt(c, T.literal(0))),
        T.floor(T.mul(T.sub(h, u.binStart), 1 / u.binSize)),
        T.literal(null)
      ) : T.cond(
        T.isFinite(c),
        T.floor(T.mul(T.sub(h, u.binStart), 1 / u.binSize)),
        T.literal(null)
      );
      let d = (C) => Math.floor((u.scale.forward(C, u.scale.constant ?? 0) - u.binStart) / u.binSize), p = (C) => u.scale.reverse(C * u.binSize + u.binStart, u.scale.constant ?? 0);
      n[l.key] = (C) => C == null ? "n/a" : [p(C), p(C + 1)];
      let g = d(
        u.scale.type == "log" ? l.stats.quantitative.minPositive : l.stats.quantitative.min
      ), v = d(l.stats.quantitative.max), y = [p(g), p(v + 1)], b = l.stats.quantitative.countNonFinite > 0;
      u.scale.type == "log" && l.stats.quantitative.min < 0 && (b = !0), r[l.key] = {
        type: u.scale.type,
        constant: u.scale.constant,
        domain: y,
        specialValues: b ? ["n/a"] : []
      };
      let k = (C) => {
        if (typeof C == "string") {
          if (C == "n/a")
            return T.or(T.not(T.isFinite(c)), T.isNull(c));
        } else if (C instanceof Array)
          if (C.length == 2 && typeof C[0] == "number") {
            let [S, _] = C;
            if (typeof S == "number" && typeof _ == "number")
              return T.isBetween(c, [Math.min(S, _), Math.max(S, _)]);
          } else
            return T.or(...C.map(k));
        return T.literal(!1);
      };
      i[l.key] = k, o[l.key] = (C, S) => {
        let _ = typeof C == "string" ? [1, 0] : [0, C[0]], D = typeof S == "string" ? [1, 0] : [0, S[0]];
        return _[0] != D[0] ? _[0] - D[0] : _[1] - D[1];
      };
    }
    if (l.stats.nominal) {
      let u = l.binCount ?? 15, { levels: c, nullCount: h, otherCount: d, numOtherLevels: p } = l.stats.nominal;
      c.length > u && (p += c.length - u, d = c.slice(u).reduce((S, _) => S + _.count, 0), c = c.slice(0, u));
      let g = `(${p.toLocaleString()} others)`, v = "(null)", y = T.cast(T.column(l.stats.field), "TEXT");
      e[l.key] = T.cond(
        T.isIn(
          y,
          c.map((S) => T.literal(S.value))
        ),
        y,
        T.cond(T.isNull(y), T.literal(v), T.literal(g))
      );
      let b = [...d > 0 ? [g] : [], ...h > 0 ? [v] : []];
      r[l.key] = {
        type: "band",
        domain: c.map((S) => S.value),
        specialValues: b
      }, n[l.key] = (S) => S;
      let k = (S) => S == v ? T.isNull(y) : S == g ? T.and(
        T.not(
          T.isIn(
            y,
            c.map((_) => T.literal(_.value))
          )
        ),
        T.isNotNull(y)
      ) : T.isNotDistinct(y, T.literal(S));
      i[l.key] = (S) => S instanceof Array ? T.or(...S.map((_) => k(_))) : typeof S == "string" ? k(S) : null;
      let C = c.map((S) => S.value);
      o[l.key] = (S, _) => {
        if (typeof S == "string" && typeof _ == "string") {
          let D = C.indexOf(S);
          D < 0 && (D = C.length + b.indexOf(S));
          let A = C.indexOf(_);
          return A < 0 && (A = C.length + b.indexOf(_)), D - A;
        }
        return 0;
      };
    }
  }
  function s(l) {
    let u = { ...l };
    for (let c of t)
      u[c.key] = n[c.key](u[c.key]);
    return u;
  }
  function a(l) {
    let u = [];
    for (let c of t) {
      let h = l[c.key], d = h != null ? i[c.key](h) : null;
      d && u.push(d);
    }
    return {
      value: { ...l },
      predicate: u.length > 0 ? T.and(...u) : null
    };
  }
  return { select: e, collect: s, scales: r, clause: a, order: o };
}
var j1e = /* @__PURE__ */ St('<line></line><line></line><line></line><rect></rect><line stroke-linecap="butt"></line>', 1), q1e = /* @__PURE__ */ St("<!><!>", 1), U1e = /* @__PURE__ */ me('<div class="text-slate-400 mb-1 select-none"> </div> <!> <div class="text-slate-400 mb-1 select-none text-right"> </div> <div class="flex flex-col items-end gap-1"><div class="flex flex gap-2 mt-2"><!> <!></div></div>', 1);
function H1e(t, e) {
  nt(e, !0);
  const r = () => gi(o, "$colorScheme", n), [n, i] = Jo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.state.brush), a = /* @__PURE__ */ K(() => xc[r()]), l = /* @__PURE__ */ De(null), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(null);
  function h(d, p, g, v, y) {
    let b = /* @__PURE__ */ De(null);
    Promise.all([
      eu(d, p, g),
      eu(d, p, v)
    ]).then(([_, D]) => {
      ae(b, _ != null && D != null ? { x: _, y: D } : null);
    });
    let k = /* @__PURE__ */ K(() => x(b) ? bp({
      key: "x",
      stats: x(b).x,
      scaleType: e.spec.xScaleType,
      binCount: e.spec.xBinCount
    }) : null), C = /* @__PURE__ */ K(() => x(b)?.y.quantitative ? b1e(x(b).y.quantitative, e.spec.yScaleType) : null);
    dt(() => {
      x(u) == null && x(k)?.scales.x?.type != null && ae(u, x(k)?.scales.x?.type), x(c) == null && x(C)?.type != null && ae(c, x(C)?.type);
    });
    function S(_, D, A) {
      return ol({
        coordinator: d,
        selection: D ?? void 0,
        query: (O) => {
          let M = T.column(v, p);
          return T.Query.from(p).select({
            ..._.select,
            min: T.min(M),
            max: T.max(M),
            p50: T.median(M),
            p25: T.quantile(M, 0.25),
            p75: T.quantile(M, 0.75)
          }).where(O, T.isFinite(M)).groupby(_.select.x);
        },
        queryResult: (O) => {
          A(Array.from(O).map(_.collect));
        }
      });
    }
    dt(() => {
      if (x(k) == null || x(C) == null)
        return;
      let _ = x(k), D = /* @__PURE__ */ De(ps([])), A = S(_, y, (O) => {
        ae(D, O, !0);
      });
      return A.reset = () => {
        e.onStateChange({ brush: null });
      }, dt(() => {
        ae(l, {
          xScale: _.scales.x,
          yScale: x(C),
          items: x(D)
        });
      }), dt(() => {
        let O = {
          source: A,
          clients: /* @__PURE__ */ new Set([A]),
          ...x(s) != null ? _.clause(x(s)) : { value: null, predicate: null }
        };
        y.update(O), y.activate(O);
      }), () => {
        A.destroy(), y.update({
          source: A,
          clients: /* @__PURE__ */ new Set([A]),
          value: null,
          predicate: null
        });
      };
    });
  }
  dt(() => {
    h(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y, e.context.filter);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col",
    children: (d, p) => {
      var g = U1e(), v = He(g), y = Y(v);
      J(v);
      var b = le(v, 2);
      {
        const P = (B, $ = jt, j = jt) => {
          var U = kr(), H = He(U);
          {
            var G = (re) => {
              zd(re, {
                get width() {
                  return $();
                },
                get height() {
                  return j();
                },
                get xScale() {
                  return x(l).xScale;
                },
                get yScale() {
                  return x(l).yScale;
                },
                get colorScheme() {
                  return r();
                },
                children: (ne, se = jt) => {
                  const ie = /* @__PURE__ */ K(() => se().xScale), ce = /* @__PURE__ */ K(() => se().yScale), Ce = /* @__PURE__ */ K(() => r() == "dark" ? "#bbbbbb" : "black");
                  var Me = q1e(), Pe = He(Me);
                  It(Pe, 17, () => x(l)?.items ?? [], hr, (he, we) => {
                    const ve = /* @__PURE__ */ K(() => {
                      const [Qt, Sr] = x(ie).applyBand(x(we).x);
                      return { x0: Qt, x1: Sr };
                    }), Ge = /* @__PURE__ */ K(() => x(ce).apply(x(we).p50)), Xe = /* @__PURE__ */ K(() => {
                      const [Qt, Sr] = x(ce).applyBand([x(we).min, x(we).max]);
                      return { ey0: Qt, ey1: Sr };
                    }), et = /* @__PURE__ */ K(() => {
                      const [Qt, Sr] = x(ce).applyBand([x(we).p25, x(we).p75]);
                      return { by0: Qt, by1: Sr };
                    }), Qe = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ve).x1 - x(ve).x0) * 0.1, 1)), Wt = /* @__PURE__ */ K(() => Math.abs(x(ve).x1 - x(ve).x0) / 3);
                    var At = j1e(), Xt = He(At), Nt = le(Xt), Ve = le(Nt), Ze = le(Ve), Bt = le(Ze);
                    Ee(
                      (Qt, Sr, pt, _e, tt, Ft) => {
                        te(Xt, "y1", x(Xe).ey0), te(Xt, "y2", x(Xe).ey1), te(Xt, "x1", (x(ve).x0 + x(ve).x1) / 2), te(Xt, "x2", (x(ve).x0 + x(ve).x1) / 2), te(Xt, "stroke", x(Ce)), te(Nt, "y1", x(Xe).ey0), te(Nt, "y2", x(Xe).ey0), te(Nt, "x1", (x(ve).x0 + x(ve).x1) / 2 - x(Wt) / 2), te(Nt, "x2", (x(ve).x0 + x(ve).x1) / 2 + x(Wt) / 2), te(Nt, "stroke", x(Ce)), te(Ve, "y1", x(Xe).ey1), te(Ve, "y2", x(Xe).ey1), te(Ve, "x1", (x(ve).x0 + x(ve).x1) / 2 - x(Wt) / 2), te(Ve, "x2", (x(ve).x0 + x(ve).x1) / 2 + x(Wt) / 2), te(Ve, "stroke", x(Ce)), te(Ze, "x", Qt), te(Ze, "height", Sr), te(Ze, "y", pt), te(Ze, "width", _e), te(Ze, "fill", x(a).markColor), te(Bt, "y1", x(Ge)), te(Bt, "y2", x(Ge)), te(Bt, "x1", tt), te(Bt, "x2", Ft), te(Bt, "stroke", x(Ce));
                      },
                      [
                        () => Math.min(x(ve).x0, x(ve).x1) + x(Qe) / 2,
                        () => Math.abs(x(et).by0 - x(et).by1),
                        () => Math.min(x(et).by0, x(et).by1),
                        () => Math.abs(x(ve).x0 - x(ve).x1) - x(Qe),
                        () => Math.min(x(ve).x0, x(ve).x1) + x(Qe) / 2,
                        () => Math.max(x(ve).x0, x(ve).x1) - x(Qe) / 2
                      ]
                    ), Q(he, At);
                  });
                  var Ae = le(Pe);
                  {
                    let he = /* @__PURE__ */ K(() => x(s) ?? null);
                    Tx(Ae, {
                      get proxy() {
                        return se();
                      },
                      mode: "x",
                      get value() {
                        return x(he);
                      },
                      get colorScheme() {
                        return r();
                      },
                      onChange: (we) => {
                        e.onStateChange({ brush: we != null && we.x != null ? { x: we.x } : null });
                      }
                    });
                  }
                  Q(ne, Me);
                },
                $$slots: { default: !0 }
              });
            };
            Fe(H, (re) => {
              x(l) != null && re(G);
            });
          }
          Q(B, U);
        };
        let I = /* @__PURE__ */ K(() => e.height != null);
        g0(b, {
          get flexHeight() {
            return x(I);
          },
          children: P,
          $$slots: { default: !0 }
        });
      }
      var k = le(b, 2), C = Y(k);
      J(k);
      var S = le(k, 2), _ = Y(S), D = Y(_), A = () => e.spec.xScaleType ?? x(u) ?? "linear", O = (P) => {
        e.onSpecChange({ xScaleType: P });
      };
      Dh(D, {
        label: "X",
        get value() {
          return A();
        },
        set value(P) {
          O(P);
        }
      });
      var M = le(D, 2), z = () => e.spec.yScaleType ?? x(c) ?? "linear", N = (P) => {
        e.onSpecChange({ yScaleType: P });
      };
      Dh(M, {
        label: "Y",
        get value() {
          return z();
        },
        set value(P) {
          N(P);
        }
      }), J(_), J(S), Ee(() => {
        at(y, `â†‘ ${e.spec.data.y ?? ""}`), at(C, `${e.spec.data.x ?? ""} â†’`);
      }), Q(d, g);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var V1e = /* @__PURE__ */ me('<hr class="mt-1 mb-1 border-slate-300 dark:border-slate-500 border-dashed"/>'), W1e = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>'), G1e = /* @__PURE__ */ me('<!> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), K1e = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>'), X1e = /* @__PURE__ */ me('<!> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), Q1e = /* @__PURE__ */ me('<!> <button class="text-left items-center flex py-0.5"><div class="w-40 flex-none overflow-hidden whitespace-nowrap text-ellipsis pr-1"><span> </span></div> <div class="flex-1 h-4 relative"><!></div> <div class="flex-none"><span><!></span></div></button>', 1), J1e = /* @__PURE__ */ me('<button class="py-0.5 text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden"><!></button>'), Y1e = /* @__PURE__ */ me('<!> <div class="flex"><div class="flex-1 pl-40 mr-2 overflow-hidden"><!></div> <div class="flex"><!></div></div>', 1), Z1e = /* @__PURE__ */ me('<div class="flex flex-col text-sm w-full select-none"><!></div>');
function ebe(t, e) {
  nt(e, !0);
  const r = () => gi(l, "$colorScheme", n), [n, i] = Jo(), o = 10, s = 100;
  let { coordinator: a, colorScheme: l } = e.context, u = /* @__PURE__ */ K(() => e.state.selection), c = /* @__PURE__ */ K(() => e.spec.expanded), h = /* @__PURE__ */ K(() => e.spec.percentage), d = /* @__PURE__ */ De(null), p = /* @__PURE__ */ De(400), g = /* @__PURE__ */ K(() => x(d)?.items.reduce((O, M) => Math.max(O, x(h) ? M.selected : M.total), 0) ?? 0), v = /* @__PURE__ */ K(() => hp([0, Math.max(1, x(g))], [0, x(p) - 250])), y = /* @__PURE__ */ K(() => (O) => O != 0 ? Math.max(1, x(v)(O)) : 0), b = /* @__PURE__ */ K(() => xc[r()]);
  function k(O, M, z, N) {
    let P = /* @__PURE__ */ De(null);
    eu(O, M, z).then(($) => {
      ae(P, $);
    });
    let I = /* @__PURE__ */ K(() => x(P) ? bp({
      key: "x",
      stats: x(P),
      binCount: x(c) ? s : o
    }) : null);
    function B($, j, U) {
      return ol({
        coordinator: O,
        selection: j ?? void 0,
        query: (H) => T.Query.from(M).select({ ...$.select, count: T.count() }).where(H).groupby($.select.x),
        queryResult: (H) => {
          U(Array.from(H).map($.collect));
        }
      });
    }
    dt(() => {
      if (x(I) == null)
        return;
      let $ = x(I), j = /* @__PURE__ */ De([]), U = /* @__PURE__ */ De([]), H = B($, null, (ne) => {
        ae(j, ne);
      }), G = B($, N, (ne) => {
        ae(U, ne);
      }), re = {
        reset: () => {
          e.onStateChange({ selection: null });
        }
      };
      return dt(() => {
        if (x(j).length > 0) {
          let ne = (ce) => JSON.stringify(ce), se = new Map(x(j).map(({ x: ce, count: Ce }) => [ne(ce), Ce])), ie = new Map(x(U).map(({ x: ce, count: Ce }) => [ne(ce), Ce]));
          if (x(j).every((ce) => typeof ce.x == "string")) {
            let ce = $.scales.x.specialValues ?? [], Ce = ce.filter((he) => he != "(null)").length > 0, Me = [...$.scales.x.domain, ...ce].map((he) => ({
              x: he,
              total: se.get(ne(he)) ?? 0,
              selected: ie.get(ne(he)) ?? 0
            })), Pe = Me.reduce((he, we) => he + we.total, 0), Ae = Me.reduce((he, we) => he + we.selected, 0);
            ae(d, {
              items: Me,
              sumTotal: Pe,
              sumSelected: Ae,
              firstSpecialIndex: $.scales.x.domain.length,
              hasOther: Ce
            });
          } else {
            let ce = Array.from(se.keys()).map((Ae) => JSON.parse(Ae));
            ce = ce.sort((Ae, he) => {
              let we = typeof Ae == "string" ? 1 / 0 : Ae[0], ve = typeof he == "string" ? 1 / 0 : he[0];
              return we - ve;
            });
            let Ce = ce.map((Ae) => ({
              x: Ae,
              total: se.get(ne(Ae)) ?? 0,
              selected: ie.get(ne(Ae)) ?? 0
            })), Me = Ce.reduce((Ae, he) => Ae + he.total, 0), Pe = Ce.reduce((Ae, he) => Ae + he.selected, 0);
            ae(d, {
              items: Ce,
              sumTotal: Me,
              sumSelected: Pe,
              firstSpecialIndex: ce.findIndex((Ae) => typeof Ae == "string"),
              hasOther: !1
            });
          }
        }
      }), dt(() => {
        let ne = {
          source: re,
          clients: /* @__PURE__ */ new Set([G]),
          ...x(u) != null ? $.clause({ x: x(u) }) : { value: null, predicate: null }
        };
        N.update(ne), N.activate(ne);
      }), () => {
        H.destroy(), G.destroy(), N.update({
          source: re,
          clients: /* @__PURE__ */ new Set([G]),
          value: null,
          predicate: null
        });
      };
    });
  }
  dt(() => {
    k(a, e.context.table, e.spec.data.field, e.context.filter);
  });
  const C = (O, M) => JSON.stringify(O) == JSON.stringify(M);
  function S(O, M) {
    if (x(u) == null || x(u).length == 0)
      e.onStateChange({ selection: [O] });
    else {
      let z = x(u).findIndex((N) => C(N, O)) >= 0;
      M ? z ? e.onStateChange({ selection: x(u).filter((N) => !C(N, O)) }) : e.onStateChange({ selection: [...x(u), O] }) : z ? e.onStateChange({ selection: null }) : e.onStateChange({ selection: [O] });
    }
  }
  const _ = su(".6");
  function D(O) {
    return typeof O == "string" ? O : "[" + _(O[0]) + ", " + _(O[1]) + ")";
  }
  function A(O, M) {
    return M == 0 ? "-%" : (O / M * 100).toFixed(1) + "%";
  }
  yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (O, M) => {
      var z = Z1e(), N = Y(z);
      {
        var P = (I) => {
          var B = Y1e(), $ = He(B);
          It($, 17, () => x(d).items, hr, (se, ie, ce) => {
            const Ce = /* @__PURE__ */ K(() => x(u) == null || x(u).length == 0 || x(u).findIndex((pt) => C(pt, x(ie).x)) >= 0), Me = /* @__PURE__ */ K(() => !x(d).items.every((pt) => pt.total == pt.selected));
            var Pe = Q1e(), Ae = He(Pe);
            {
              var he = (pt) => {
                var _e = V1e();
                Q(pt, _e);
              };
              Fe(Ae, (pt) => {
                ce == x(d).firstSpecialIndex && pt(he);
              });
            }
            var we = le(Ae, 2);
            we.__click = (pt) => S(x(ie).x, pt.shiftKey);
            var ve = Y(we), Ge = Y(ve);
            let Xe;
            var et = Y(Ge, !0);
            J(Ge), J(ve);
            var Qe = le(ve, 2), Wt = Y(Qe);
            {
              var At = (pt) => {
                var _e = G1e(), tt = He(_e);
                {
                  var Ft = (Et) => {
                    var Ar = W1e();
                    let Ut;
                    Ee((ln) => Ut = ct(Ar, "", Ut, ln), [
                      () => ({
                        background: x(b).markColorFade,
                        width: `${x(y)(x(ie).total) ?? ""}px`
                      })
                    ]), Q(Et, Ar);
                  };
                  Fe(tt, (Et) => {
                    x(h) || Et(Ft);
                  });
                }
                var mr = le(tt, 2);
                let Tt;
                Ee((Et) => Tt = ct(mr, "", Tt, Et), [
                  () => ({
                    background: x(b).markColor,
                    width: `${x(y)(x(ie).selected) ?? ""}px`
                  })
                ]), Q(pt, _e);
              }, Xt = (pt) => {
                var _e = X1e(), tt = He(_e);
                {
                  var Ft = (Et) => {
                    var Ar = K1e();
                    let Ut;
                    Ee((ln) => Ut = ct(Ar, "", Ut, ln), [
                      () => ({
                        background: x(b).markColorGrayFade,
                        width: `${x(y)(x(ie).total) ?? ""}px`
                      })
                    ]), Q(Et, Ar);
                  };
                  Fe(tt, (Et) => {
                    x(h) || Et(Ft);
                  });
                }
                var mr = le(tt, 2);
                let Tt;
                Ee((Et) => Tt = ct(mr, "", Tt, Et), [
                  () => ({
                    background: x(b).markColorGray,
                    width: `${x(y)(x(ie).selected) ?? ""}px`
                  })
                ]), Q(pt, _e);
              };
              Fe(Wt, (pt) => {
                x(Ce) ? pt(At) : pt(Xt, !1);
              });
            }
            J(Qe);
            var Nt = le(Qe, 2), Ve = Y(Nt);
            let Ze;
            var Bt = Y(Ve);
            {
              var Qt = (pt) => {
                var _e = kr(), tt = He(_e);
                {
                  var Ft = (Tt) => {
                    var Et = No();
                    Ee((Ar) => at(Et, Ar), [
                      () => A(x(ie).selected, x(d).sumSelected)
                    ]), Q(Tt, Et);
                  }, mr = (Tt) => {
                    var Et = No();
                    Ee((Ar) => at(Et, Ar), [
                      () => x(ie).selected.toLocaleString() + " / " + x(ie).total.toLocaleString()
                    ]), Q(Tt, Et);
                  };
                  Fe(tt, (Tt) => {
                    x(h) ? Tt(Ft) : Tt(mr, !1);
                  });
                }
                Q(pt, _e);
              }, Sr = (pt) => {
                var _e = kr(), tt = He(_e);
                {
                  var Ft = (Tt) => {
                    var Et = No();
                    Ee((Ar) => at(Et, Ar), [
                      () => A(x(ie).total, x(d).sumTotal)
                    ]), Q(Tt, Et);
                  }, mr = (Tt) => {
                    var Et = No();
                    Ee((Ar) => at(Et, Ar), [() => x(ie).total.toLocaleString()]), Q(Tt, Et);
                  };
                  Fe(
                    tt,
                    (Tt) => {
                      x(h) ? Tt(Ft) : Tt(mr, !1);
                    },
                    !0
                  );
                }
                Q(pt, _e);
              };
              Fe(Bt, (pt) => {
                x(Me) ? pt(Qt) : pt(Sr, !1);
              });
            }
            J(Ve), J(Nt), J(we), Ee(
              (pt, _e) => {
                te(we, "title", x(ie).x), Xe = en(Ge, 1, "", null, Xe, {
                  "text-gray-400": !x(Ce),
                  "dark:text-gray-400": !x(Ce)
                }), at(et, pt), Ze = en(Ve, 1, "text-slate-400 dark:text-slate-500", null, Ze, {
                  "!text-gray-200": !x(Ce),
                  "dark:!text-gray-600": !x(Ce)
                }), te(Ve, "title", _e);
              },
              [
                () => D(x(ie).x),
                () => x(Me) ? `${x(ie).selected.toLocaleString()} / ${x(ie).total.toLocaleString()} (${A(x(ie).selected, x(ie).total)})
${A(x(ie).selected, x(d).sumSelected)} of selection` : `${x(ie).total.toLocaleString()}
${A(x(ie).total, x(d).sumTotal)} of all rows`
              ]
            ), Q(se, Pe);
          });
          var j = le($, 2), U = Y(j), H = Y(U);
          {
            var G = (se) => {
              var ie = J1e();
              ie.__click = () => {
                x(c) == !0 ? (e.onSpecChange({ expanded: !1 }), e.onStateChange({ selection: null })) : e.onSpecChange({ expanded: !0 });
              };
              var ce = Y(ie);
              {
                var Ce = (Pe) => {
                  var Ae = No();
                  Ae.nodeValue = "â†‘ Show up to 10 values", Q(Pe, Ae);
                }, Me = (Pe) => {
                  var Ae = No();
                  Ae.nodeValue = "â†“ Show up to 100 values", Q(Pe, Ae);
                };
                Fe(ce, (Pe) => {
                  x(c) ? Pe(Ce) : Pe(Me, !1);
                });
              }
              J(ie), Q(se, ie);
            };
            Fe(H, (se) => {
              (x(c) || x(d).hasOther) && se(G);
            });
          }
          J(U);
          var re = le(U, 2), ne = Y(re);
          {
            let se = /* @__PURE__ */ K(() => x(h)?.toString() ?? "false");
            Mx(ne, {
              options: [
                { value: "true", label: "%" },
                { value: "false", label: "#/#" }
              ],
              get value() {
                return x(se);
              },
              onChange: (ie) => e.onSpecChange({ percentage: ie == "true" })
            });
          }
          J(re), J(j), Q(I, B);
        };
        Fe(N, (I) => {
          x(d) && I(P);
        });
      }
      J(z), Xs(z, "clientWidth", (I) => ae(p, I)), Q(O, z);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
nn(["click"]);
async function tbe(t, e, r, n) {
  let i = T.column(r, e), o = await t.query(T.Query.from(T.Query.from(e).select({ value: T.sql`UNNEST(${i})` })).select({ value: "value", count: T.count() }).groupby("value").orderby(T.desc("count")).limit(n + 1)), s = Array.from(o);
  return {
    values: s.slice(0, n),
    hasOther: s.length > n
  };
}
function rbe(t, e) {
  return T.or(...e.map((r) => T.sql`${T.literal(r)} IN ${T.column(t)}`));
}
var nbe = /* @__PURE__ */ me('<hr class="mt-1 mb-1 border-slate-300 dark:border-slate-500 border-dashed"/>'), ibe = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), obe = /* @__PURE__ */ me('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), sbe = /* @__PURE__ */ me('<!> <button class="text-left items-center flex py-0.5"><div class="w-40 flex-none overflow-hidden whitespace-nowrap text-ellipsis pr-1"><span> </span></div> <div class="flex-1 h-4 relative"><!></div> <div class="flex-none"><span><!></span></div></button>', 1), abe = /* @__PURE__ */ me('<button class="py-0.5 text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden"><!></button>'), lbe = /* @__PURE__ */ me('<!> <div class="flex"><div class="flex-1 pl-40 mr-2 overflow-hidden"><!></div></div>', 1), ube = /* @__PURE__ */ me('<div class="flex flex-col text-sm w-full select-none"><!></div>');
function cbe(t, e) {
  nt(e, !0);
  const r = () => gi(a, "$colorScheme", n), [n, i] = Jo(), o = 10, s = 100;
  let a = e.context.colorScheme, l = /* @__PURE__ */ K(() => e.state.selection), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(400), h = /* @__PURE__ */ K(() => x(u)?.items.reduce((_, D) => Math.max(_, D.total), 0) ?? 0), d = /* @__PURE__ */ K(() => hp([0, Math.max(1, x(h))], [0, x(c) - 250])), p = /* @__PURE__ */ K(() => (_) => _ != 0 ? Math.max(1, x(d)(_)) : 0), g = /* @__PURE__ */ K(() => xc[r()]);
  function v(_, D, A, O, M) {
    let z = /* @__PURE__ */ De(null);
    tbe(_, D, A, M).then((P) => {
      ae(z, P);
    });
    function N(P, I, B) {
      return ol({
        coordinator: _,
        selection: P ?? void 0,
        query: ($) => {
          let j = T.column(A, D);
          return T.Query.from(T.Query.from(D).select({ value: T.sql`UNNEST(${j})` }).where($)).select({ x: "value", count: T.count() }).where(T.isIn("value", I.map((U) => T.literal(U)))).groupby("value").orderby(T.desc("count"));
        },
        queryResult: ($) => {
          B(Array.from($));
        }
      });
    }
    dt(() => {
      if (x(z) == null)
        return;
      let P = x(z).values.map((G) => G.value), I = x(z).hasOther, B = /* @__PURE__ */ De([]), $ = /* @__PURE__ */ De([]), j = N(null, P, (G) => {
        ae(B, G);
      }), U = N(O, P, (G) => {
        ae($, G);
      }), H = {
        reset: () => {
          e.onStateChange({ selection: null });
        }
      };
      return dt(() => {
        if (x(B).length > 0) {
          let G = (ie) => JSON.stringify(ie), re = new Map(x(B).map(({ x: ie, count: ce }) => [G(ie), ce])), ne = new Map(x($).map(({ x: ie, count: ce }) => [G(ie), ce])), se = P.map((ie) => ({
            x: ie,
            total: re.get(G(ie)) ?? 0,
            selected: ne.get(G(ie)) ?? 0
          }));
          ae(u, { items: se, firstSpecialIndex: P.length, hasOther: I });
        }
      }), dt(() => {
        let G = {
          source: H,
          clients: /* @__PURE__ */ new Set([U]),
          ...x(l) != null ? {
            value: x(l),
            predicate: rbe(A, x(l))
          } : { value: null, predicate: null }
        };
        O.update(G), O.activate(G);
      }), () => {
        j.destroy(), U.destroy(), O.update({
          source: H,
          clients: /* @__PURE__ */ new Set([U]),
          value: null,
          predicate: null
        });
      };
    });
  }
  dt(() => {
    v(e.context.coordinator, e.context.table, e.spec.data.field, e.context.filter, e.spec.expanded ? s : o);
  });
  const y = (_, D) => JSON.stringify(_) == JSON.stringify(D);
  function b(_, D) {
    if (x(l) == null || x(l).length == 0)
      e.onStateChange({ selection: [_] });
    else {
      let A = x(l).findIndex((O) => y(O, _)) >= 0;
      D ? A ? e.onStateChange({ selection: x(l).filter((O) => !y(O, _)) }) : e.onStateChange({ selection: [...x(l), _] }) : A ? e.onStateChange({ selection: null }) : e.onStateChange({ selection: [_] });
    }
  }
  const k = su(".6");
  function C(_) {
    return typeof _ == "string" ? _ : "[" + k(_[0]) + ", " + k(_[1]) + ")";
  }
  function S(_, D) {
    return D == 0 ? "-%" : (_ / D * 100).toFixed(1) + "%";
  }
  yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (_, D) => {
      var A = ube(), O = Y(A);
      {
        var M = (z) => {
          var N = lbe(), P = He(N);
          It(P, 17, () => x(u).items, hr, (U, H, G) => {
            const re = /* @__PURE__ */ K(() => x(l) == null || x(l).length == 0 || x(l).findIndex((Ve) => y(Ve, x(H).x)) >= 0), ne = /* @__PURE__ */ K(() => !x(u).items.every((Ve) => Ve.total == Ve.selected));
            var se = sbe(), ie = He(se);
            {
              var ce = (Ve) => {
                var Ze = nbe();
                Q(Ve, Ze);
              };
              Fe(ie, (Ve) => {
                G == x(u).firstSpecialIndex && Ve(ce);
              });
            }
            var Ce = le(ie, 2);
            Ce.__click = (Ve) => b(x(H).x, Ve.shiftKey);
            var Me = Y(Ce), Pe = Y(Me);
            let Ae;
            var he = Y(Pe, !0);
            J(Pe), J(Me);
            var we = le(Me, 2), ve = Y(we);
            {
              var Ge = (Ve) => {
                var Ze = ibe(), Bt = He(Ze);
                let Qt;
                var Sr = le(Bt, 2);
                let pt;
                Ee(
                  (_e, tt) => {
                    Qt = ct(Bt, "", Qt, _e), pt = ct(Sr, "", pt, tt);
                  },
                  [
                    () => ({
                      background: x(g).markColorFade,
                      width: `${x(p)(x(H).total) ?? ""}px`
                    }),
                    () => ({
                      background: x(g).markColor,
                      width: `${x(p)(x(H).selected) ?? ""}px`
                    })
                  ]
                ), Q(Ve, Ze);
              }, Xe = (Ve) => {
                var Ze = obe(), Bt = He(Ze);
                let Qt;
                var Sr = le(Bt, 2);
                let pt;
                Ee(
                  (_e, tt) => {
                    Qt = ct(Bt, "", Qt, _e), pt = ct(Sr, "", pt, tt);
                  },
                  [
                    () => ({
                      background: x(g).markColorGrayFade,
                      width: `${x(p)(x(H).total) ?? ""}px`
                    }),
                    () => ({
                      background: x(g).markColorGray,
                      width: `${x(p)(x(H).selected) ?? ""}px`
                    })
                  ]
                ), Q(Ve, Ze);
              };
              Fe(ve, (Ve) => {
                x(re) ? Ve(Ge) : Ve(Xe, !1);
              });
            }
            J(we);
            var et = le(we, 2), Qe = Y(et);
            let Wt;
            var At = Y(Qe);
            {
              var Xt = (Ve) => {
                var Ze = No();
                Ee((Bt) => at(Ze, Bt), [
                  () => x(H).selected.toLocaleString() + " / " + x(H).total.toLocaleString()
                ]), Q(Ve, Ze);
              }, Nt = (Ve) => {
                var Ze = No();
                Ee((Bt) => at(Ze, Bt), [() => x(H).total.toLocaleString()]), Q(Ve, Ze);
              };
              Fe(At, (Ve) => {
                x(ne) ? Ve(Xt) : Ve(Nt, !1);
              });
            }
            J(Qe), J(et), J(Ce), Ee(
              (Ve, Ze) => {
                te(Ce, "title", x(H).x), Ae = en(Pe, 1, "", null, Ae, {
                  "text-gray-400": !x(re),
                  "dark:text-gray-400": !x(re)
                }), at(he, Ve), Wt = en(Qe, 1, "text-slate-400 dark:text-slate-500", null, Wt, {
                  "!text-gray-200": !x(re),
                  "dark:!text-gray-600": !x(re)
                }), te(Qe, "title", Ze);
              },
              [
                () => C(x(H).x),
                () => x(ne) ? `${x(H).total.toLocaleString()} rows contain "${x(H).x}"; ${x(H).selected.toLocaleString()} (${S(x(H).selected, x(H).total)}) in selection` : `${x(H).total.toLocaleString()} rows contain "${x(H).x}"`
              ]
            ), Q(U, se);
          });
          var I = le(P, 2), B = Y(I), $ = Y(B);
          {
            var j = (U) => {
              var H = abe();
              H.__click = () => {
                let se = !e.spec.expanded;
                e.onSpecChange({ expanded: se }), se == !1 && e.onStateChange({ selection: null });
              };
              var G = Y(H);
              {
                var re = (se) => {
                  var ie = No();
                  ie.nodeValue = "â†‘ Show up to 10 values", Q(se, ie);
                }, ne = (se) => {
                  var ie = No();
                  ie.nodeValue = "â†“ Show up to 100 values", Q(se, ie);
                };
                Fe(G, (se) => {
                  e.spec.expanded ? se(re) : se(ne, !1);
                });
              }
              J(H), Q(U, H);
            };
            Fe($, (U) => {
              (e.spec.expanded || x(u).hasOther) && U(j);
            });
          }
          J(B), J(I), Q(z, N);
        };
        Fe(O, (z) => {
          x(u) && z(M);
        });
      }
      J(A), Xs(A, "clientWidth", (z) => ae(c, z)), Q(_, A);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
nn(["click"]);
var hbe = /* @__PURE__ */ St("<rect></rect>"), fbe = /* @__PURE__ */ St("<rect></rect>"), dbe = /* @__PURE__ */ St("<!><!><!>", 1), pbe = /* @__PURE__ */ me('<div class="flex gap items-center text-sm"><span class="flex-1 text-slate-400 dark:text-slate-500"><!></span> <!></div>'), mbe = /* @__PURE__ */ me("<!> <!>", 1);
function gbe(t, e) {
  nt(e, !0);
  const r = () => gi(s, "$colorScheme", n), [n, i] = Jo();
  let { coordinator: o, colorScheme: s } = e.context, a = /* @__PURE__ */ K(() => e.state.brush), l = /* @__PURE__ */ K(() => xc[r()]), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(null);
  function h(d, p, g, v) {
    let y = /* @__PURE__ */ De(null);
    eu(d, p, g).then((C) => {
      ae(y, C);
    });
    let b = /* @__PURE__ */ K(() => x(y) ? bp({
      key: "x",
      stats: x(y),
      scaleType: e.spec.xScaleType,
      binCount: e.spec.binCount
    }) : null);
    dt(() => {
      x(c) == null && x(b)?.scales.x?.type != null && ae(c, x(b)?.scales.x?.type, !0);
    });
    function k(C, S, _) {
      return ol({
        coordinator: d,
        selection: S ?? void 0,
        query: (D) => T.Query.from(p).select({ ...C.select, count: T.count() }).where(D).groupby(C.select.x),
        queryResult: (D) => {
          _(Array.from(D).map(C.collect));
        }
      });
    }
    dt(() => {
      if (x(b) == null)
        return;
      let C = x(b), S = /* @__PURE__ */ De(ps([])), _ = /* @__PURE__ */ De(ps([])), D = k(C, null, (M) => {
        ae(S, M, !0);
      }), A = k(C, v, (M) => {
        ae(_, M, !0);
      });
      dt(() => {
        x(S).length > 0 && ae(u, {
          xScale: C.scales.x,
          allItems: x(S),
          filteredItems: x(_)
        });
      });
      let O = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return dt(() => {
        let M = {
          source: O,
          clients: /* @__PURE__ */ new Set([A]),
          ...x(a) != null ? C.clause(x(a)) : { value: null, predicate: null }
        };
        v.update(M), v.activate(M);
      }), () => {
        D.destroy(), A.destroy(), v.update({
          source: O,
          clients: /* @__PURE__ */ new Set([A]),
          value: null,
          predicate: null
        });
      };
    });
  }
  dt(() => {
    h(o, e.context.table, e.spec.data.field, e.context.filter);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (d, p) => {
      var g = mbe(), v = He(g);
      {
        const k = (S, _ = jt, D = jt) => {
          var A = kr(), O = He(A);
          {
            var M = (z) => {
              const N = /* @__PURE__ */ K(() => x(u).allItems.reduce((P, I) => Math.max(P, I.count), 1));
              {
                const P = (B, $ = jt) => {
                  const j = /* @__PURE__ */ K(() => $().xScale), U = /* @__PURE__ */ K(() => $().yScale);
                  var H = dbe(), G = He(H);
                  It(G, 17, () => x(u)?.allItems ?? [], hr, (se, ie) => {
                    const ce = /* @__PURE__ */ K(() => {
                      const [Ae, he] = x(j).applyBand(x(ie).x);
                      return { x0: Ae, x1: he };
                    }), Ce = /* @__PURE__ */ K(() => {
                      const [Ae, he] = x(U).applyBand([0, x(ie).count]);
                      return { y0: Ae, y1: he };
                    }), Me = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ce).x1 - x(ce).x0) * 0.1, 1));
                    var Pe = hbe();
                    Ee(
                      (Ae, he, we, ve) => {
                        te(Pe, "x", Ae), te(Pe, "y", he), te(Pe, "width", we), te(Pe, "height", ve), te(Pe, "fill", x(l).markColorFade);
                      },
                      [
                        () => Math.min(x(ce).x0, x(ce).x1) + x(Me) / 2,
                        () => Math.min(x(Ce).y0, x(Ce).y1),
                        () => Math.abs(x(ce).x0 - x(ce).x1) - x(Me),
                        () => Math.abs(x(Ce).y0 - x(Ce).y1)
                      ]
                    ), Q(se, Pe);
                  });
                  var re = le(G);
                  It(re, 17, () => x(u)?.filteredItems ?? [], hr, (se, ie) => {
                    const ce = /* @__PURE__ */ K(() => {
                      const [Ae, he] = x(j).applyBand(x(ie).x);
                      return { x0: Ae, x1: he };
                    }), Ce = /* @__PURE__ */ K(() => {
                      const [Ae, he] = x(U).applyBand([0, x(ie).count]);
                      return { y0: Ae, y1: he };
                    }), Me = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ce).x1 - x(ce).x0) * 0.1, 1));
                    var Pe = fbe();
                    Ee(
                      (Ae, he, we, ve) => {
                        te(Pe, "x", Ae), te(Pe, "height", he), te(Pe, "y", we), te(Pe, "width", ve), te(Pe, "fill", x(l).markColor);
                      },
                      [
                        () => Math.min(x(ce).x0, x(ce).x1) + x(Me) / 2,
                        () => Math.abs(x(Ce).y0 - x(Ce).y1),
                        () => Math.min(x(Ce).y0, x(Ce).y1),
                        () => Math.abs(x(ce).x0 - x(ce).x1) - x(Me)
                      ]
                    ), Q(se, Pe);
                  });
                  var ne = le(re);
                  {
                    let se = /* @__PURE__ */ K(() => x(a) ?? null);
                    Tx(ne, {
                      get proxy() {
                        return $();
                      },
                      mode: "x",
                      get value() {
                        return x(se);
                      },
                      get colorScheme() {
                        return r();
                      },
                      onChange: (ie) => {
                        e.onStateChange({ brush: ie != null && ie.x != null ? { x: ie.x } : null });
                      }
                    });
                  }
                  Q(B, H);
                };
                let I = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(N)] }));
                zd(z, {
                  get width() {
                    return _();
                  },
                  get height() {
                    return D();
                  },
                  get xScale() {
                    return x(u).xScale;
                  },
                  get yScale() {
                    return x(I);
                  },
                  get colorScheme() {
                    return r();
                  },
                  children: P,
                  $$slots: { default: !0 }
                });
              }
            };
            Fe(O, (z) => {
              x(u) != null && z(M);
            });
          }
          Q(S, A);
        };
        let C = /* @__PURE__ */ K(() => e.height != null);
        g0(v, {
          get flexHeight() {
            return x(C);
          },
          children: k,
          $$slots: { default: !0 }
        });
      }
      var y = le(v, 2);
      {
        var b = (k) => {
          var C = pbe(), S = Y(C), _ = Y(S);
          {
            var D = (z) => {
              var N = kr(), P = He(N);
              {
                var I = ($) => {
                  var j = No();
                  Ee(() => at(j, `[${x(a).x ?? ""}]`)), Q($, j);
                }, B = ($) => {
                  const j = /* @__PURE__ */ K(() => su(".4"));
                  var U = No();
                  Ee((H, G) => at(U, `[${H ?? ""}, ${G ?? ""}]`), [
                    () => x(j)(x(a).x[0]),
                    () => x(j)(x(a).x[1])
                  ]), Q($, U);
                };
                Fe(P, ($) => {
                  typeof x(a).x == "string" ? $(I) : $(B, !1);
                });
              }
              Q(z, N);
            };
            Fe(_, (z) => {
              x(a) && z(D);
            });
          }
          J(S);
          var A = le(S, 2), O = () => e.spec.xScaleType ?? x(c) ?? "linear", M = (z) => {
            e.onSpecChange({ xScaleType: z });
          };
          Dh(A, {
            label: "X",
            get value() {
              return O();
            },
            set value(z) {
              M(z);
            }
          }), J(C), Q(k, C);
        };
        Fe(y, (k) => {
          x(u)?.xScale.type != "band" && k(b);
        });
      }
      Q(d, g);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var vbe = /* @__PURE__ */ St('<image preserveAspectRatio="none"></image>');
function ybe(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => e.proxy.xScale && e.xDomain ? e.proxy.xScale.apply(e.xDomain[0]) : 0), n = /* @__PURE__ */ K(() => e.proxy.xScale && e.xDomain ? e.proxy.xScale.apply(e.xDomain[1]) : e.proxy.plotWidth), i = /* @__PURE__ */ K(() => e.proxy.yScale && e.yDomain ? e.proxy.yScale.apply(e.yDomain[0]) : 0), o = /* @__PURE__ */ K(() => e.proxy.yScale && e.yDomain ? e.proxy.yScale.apply(e.yDomain[1]) : e.proxy.plotHeight), s = /* @__PURE__ */ De(null), a = document.createElement("canvas");
  dt(() => {
    a.width = e.rasterWidth, a.height = e.rasterHeight;
    let u = a.getContext("2d", { colorSpace: "srgb", willReadFrequently: !0 });
    u.clearRect(0, 0, a.width, a.height);
    let c = u.getImageData(0, 0, a.width, a.height), h = 0;
    for (let d = 0; d < a.height; d++)
      for (let p = 0; p < a.width; p++) {
        let g = (p + 0.5) / a.width * (x(n) - x(r)) + x(r), v = (d + 0.5) / a.height * (x(o) - x(i)) + x(i), y = e.proxy.xScale?.invert(g) ?? 0, b = e.proxy.yScale?.invert(v) ?? 0, { r: k, g: C, b: S, opacity: _ } = Ng(e.color(y, b));
        c.data[h++] = k, c.data[h++] = C, c.data[h++] = S, c.data[h++] = _ * 255;
      }
    u.putImageData(c, 0, 0), ae(s, a.toDataURL("image/png"), !0);
  });
  var l = vbe();
  Ee(
    (u, c, h, d) => {
      te(l, "x", u), te(l, "y", c), te(l, "width", h), te(l, "height", d), te(l, "href", x(s));
    },
    [
      () => Math.min(x(r), x(n)),
      () => Math.min(x(i), x(o)),
      () => Math.abs(x(r) - x(n)),
      () => Math.abs(x(i) - x(o))
    ]
  ), Q(t, l), it();
}
var bbe = /* @__PURE__ */ St("<rect></rect>"), xbe = /* @__PURE__ */ St("<rect></rect><!>", 1), wbe = /* @__PURE__ */ me('<div class="text-slate-400 mb-1 select-none"> </div> <!> <div class="text-slate-400 mb-1 select-none text-right"> </div> <div class="flex gap items-center text-sm"><span class="flex-1 text-slate-400 dark:text-slate-500"><!></span> <span class="flex flex-col items-end gap-1"><span class="flex gap-2"><!> <!></span> <span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm">Normalize:</span> <!></span></span></div>', 1);
function kbe(t, e) {
  nt(e, !0);
  const r = () => gi(o, "$colorScheme", n), [n, i] = Jo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.state.brush), a = /* @__PURE__ */ De(null), l = /* @__PURE__ */ K(() => x(a)?.items.reduce((v, y) => Math.max(v, y.value), 1) ?? 1);
  const u = 0.07, c = (v) => v > 0 ? u + (1 - u) * v : 0;
  let h = /* @__PURE__ */ K(() => r() == "dark" ? (v) => sB(c(v / x(l))) : (v) => zge(c(v / x(l)))), d = /* @__PURE__ */ De(null), p = /* @__PURE__ */ De(null);
  function g(v, y, b, k, C) {
    let S = /* @__PURE__ */ De(null);
    Promise.all([
      eu(v, y, b),
      eu(v, y, k)
    ]).then(([A, O]) => {
      ae(S, A != null && O != null ? { x: A, y: O } : null);
    });
    let _ = /* @__PURE__ */ K(() => x(S) ? bp(
      {
        key: "x",
        stats: x(S).x,
        scaleType: e.spec.xScaleType,
        binCount: e.spec.xBinCount
      },
      {
        key: "y",
        stats: x(S).y,
        scaleType: e.spec.yScaleType,
        binCount: e.spec.yBinCount
      }
    ) : null);
    dt(() => {
      x(d) == null && x(_)?.scales.x?.type != null && ae(d, x(_)?.scales.x?.type), x(p) == null && x(_)?.scales.y?.type != null && ae(p, x(_)?.scales.y?.type);
    });
    function D(A, O, M) {
      return ol({
        coordinator: v,
        selection: O ?? void 0,
        query: (z) => T.Query.from(T.Query.from(y).select({ ...A.select, count: T.count() }).where(z).groupby(A.select.x, A.select.y)).select({
          x: "x",
          y: "y",
          count: "count",
          normalizeByX: T.sql`count / (SUM(count) OVER (PARTITION BY x))`,
          normalizeByY: T.sql`count / (SUM(count) OVER (PARTITION BY y))`
        }),
        queryResult: (z) => {
          M(Array.from(z).map(A.collect));
        }
      });
    }
    dt(() => {
      if (x(_) == null)
        return;
      let A = x(_), O = /* @__PURE__ */ De(null), M = D(A, C, (N) => {
        ae(O, N);
      }), z = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return dt(() => {
        x(O) != null && ae(a, {
          xScale: A.scales.x,
          yScale: A.scales.y,
          items: x(O).map((N) => ({
            x: N.x,
            y: N.y,
            value: e.spec.normalization == "x" ? N.normalizeByX : e.spec.normalization == "y" ? N.normalizeByY : N.count
          }))
        });
      }), dt(() => {
        let N = {
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          ...x(s) != null ? A.clause(x(s)) : { value: null, predicate: null }
        };
        C.update(N), C.activate(N);
      }), () => {
        M.destroy(), C.update({
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          value: null,
          predicate: null
        });
      };
    });
  }
  dt(() => {
    g(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y, e.context.filter);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col",
    children: (v, y) => {
      var b = wbe(), k = He(b), C = Y(k);
      J(k);
      var S = le(k, 2);
      {
        const re = (ie, ce = jt, Ce = jt) => {
          var Me = kr(), Pe = He(Me);
          {
            var Ae = (he) => {
              zd(he, {
                get width() {
                  return ce();
                },
                get height() {
                  return Ce();
                },
                get xScale() {
                  return x(a).xScale;
                },
                get yScale() {
                  return x(a).yScale;
                },
                get colorScheme() {
                  return r();
                },
                childrenBelow: (we, ve = jt) => {
                  const Ge = /* @__PURE__ */ K(() => ve().xScale), Xe = /* @__PURE__ */ K(() => ve().yScale);
                  var et = xbe(), Qe = He(et);
                  te(Qe, "x", 0), te(Qe, "y", 0);
                  var Wt = le(Qe);
                  It(Wt, 17, () => x(a)?.items ?? [], hr, (At, Xt) => {
                    const Nt = /* @__PURE__ */ K(() => {
                      const [Qt, Sr] = x(Ge).applyBand(x(Xt).x);
                      return { x0: Qt, x1: Sr };
                    }), Ve = /* @__PURE__ */ K(() => {
                      const [Qt, Sr] = x(Xe).applyBand(x(Xt).y);
                      return { y0: Qt, y1: Sr };
                    }), Ze = /* @__PURE__ */ K(() => 0);
                    var Bt = bbe();
                    Ee(
                      (Qt, Sr, pt, _e, tt) => {
                        te(Bt, "x", Qt), te(Bt, "y", Sr), te(Bt, "width", pt), te(Bt, "height", _e), te(Bt, "fill", tt);
                      },
                      [
                        () => Math.min(x(Nt).x0, x(Nt).x1) + x(Ze) / 2,
                        () => Math.min(x(Ve).y0, x(Ve).y1) + x(Ze) / 2,
                        () => Math.abs(x(Nt).x0 - x(Nt).x1) - x(Ze),
                        () => Math.abs(x(Ve).y0 - x(Ve).y1) - x(Ze),
                        () => x(h)(x(Xt).value)
                      ]
                    ), Q(At, Bt);
                  }), Ee(
                    (At) => {
                      te(Qe, "width", ve().plotWidth), te(Qe, "height", ve().plotHeight), te(Qe, "fill", At);
                    },
                    [() => x(h)(0)]
                  ), Q(we, et);
                },
                children: (we, ve = jt) => {
                  Tx(we, {
                    get proxy() {
                      return ve();
                    },
                    mode: "xy",
                    get value() {
                      return x(s);
                    },
                    get colorScheme() {
                      return r();
                    },
                    onChange: (Ge) => {
                      e.onStateChange({
                        brush: Ge != null && Ge.x != null && Ge.y != null ? { x: Ge.x, y: Ge.y } : null
                      });
                    }
                  });
                },
                $$slots: { childrenBelow: !0, default: !0 }
              });
            };
            Fe(Pe, (he) => {
              x(a) != null && he(Ae);
            });
          }
          Q(ie, Me);
        };
        let ne = /* @__PURE__ */ K(() => e.height != null), se = /* @__PURE__ */ K(() => Math.min(300, e.width ?? 300));
        g0(S, {
          get flexHeight() {
            return x(ne);
          },
          get defaultHeight() {
            return x(se);
          },
          children: re,
          $$slots: { default: !0 }
        });
      }
      var _ = le(S, 2), D = Y(_);
      J(_);
      var A = le(_, 2), O = Y(A), M = Y(O);
      {
        const re = (se, ie = jt) => {
          {
            let ce = /* @__PURE__ */ K(() => ie().xScale?.domain);
            ybe(se, {
              get color() {
                return x(h);
              },
              rasterWidth: 100,
              rasterHeight: 1,
              get proxy() {
                return ie();
              },
              get xDomain() {
                return x(ce);
              }
            });
          }
        };
        let ne = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(l)] }));
        zd(M, {
          get xScale() {
            return x(ne);
          },
          xAxis: { extendScaleToTicks: !1 },
          width: 230,
          height: 24,
          extents: { left: 30, right: 30, top: 0, bottom: 0 },
          get colorScheme() {
            return r();
          },
          children: re,
          $$slots: { default: !0 }
        });
      }
      J(O);
      var z = le(O, 2), N = Y(z), P = Y(N), I = () => e.spec.xScaleType ?? x(d) ?? "linear", B = (re) => {
        e.onSpecChange({ xScaleType: re });
      };
      Dh(P, {
        label: "X",
        get value() {
          return I();
        },
        set value(re) {
          B(re);
        }
      });
      var $ = le(P, 2), j = () => e.spec.yScaleType ?? x(p) ?? "linear", U = (re) => {
        e.onSpecChange({ yScaleType: re });
      };
      Dh($, {
        label: "Y",
        get value() {
          return j();
        },
        set value(re) {
          U(re);
        }
      }), J(N);
      var H = le(N, 2), G = le(Y(H), 2);
      {
        let re = /* @__PURE__ */ K(() => e.spec.normalization ?? null);
        Mx(G, {
          options: [
            { value: null, label: "off" },
            { value: "x", label: "X" },
            { value: "y", label: "Y" }
          ],
          get value() {
            return x(re);
          },
          onChange: (ne) => e.onSpecChange({ normalization: ne })
        });
      }
      J(H), J(z), J(A), Ee(() => {
        at(C, `â†‘ ${e.spec.data.y ?? ""}`), at(D, `${e.spec.data.x ?? ""} â†’`);
      }), Q(v, b);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var Cbe = /* @__PURE__ */ St("<rect></rect>"), _be = /* @__PURE__ */ St("<rect></rect>"), Sbe = /* @__PURE__ */ St("<!><!><!>", 1), Abe = /* @__PURE__ */ me('<div class="flex gap-1 items-center"><div class="w-3 h-3 block rounded-sm"></div> <div class="whitespace-nowrap max-w-32 overflow-hidden text-ellipsis"> </div></div>'), Ebe = /* @__PURE__ */ me('<div class="flex gap-2 flex-wrap items-center select-none"></div>'), Dbe = /* @__PURE__ */ me('<!> <div class="flex-none flex gap-2 items-start text-sm"><div class="flex-1 text-slate-400 dark:text-slate-500"><!></div> <span class="flex flex-col items-end gap-1"><!> <span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm">Normalize:</span> <!></span></span></div>', 1);
function Obe(t, e) {
  nt(e, !0);
  const r = () => gi(o, "$colorScheme", n), [n, i] = Jo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.state.brush), a = /* @__PURE__ */ K(() => xc[r()]), l = /* @__PURE__ */ De(null), u = /* @__PURE__ */ De(null);
  function c(p, g, v, y, b) {
    let k = /* @__PURE__ */ De(null);
    Promise.all([
      eu(p, g, v),
      eu(p, g, y)
    ]).then(([_, D]) => {
      ae(k, _ != null && D != null ? { x: _, group: D } : null);
    });
    let C = /* @__PURE__ */ K(() => x(k) ? bp(
      {
        key: "x",
        stats: x(k).x,
        scaleType: e.spec.xScaleType,
        binCount: e.spec.xBinCount
      },
      {
        key: "group",
        stats: x(k).group,
        binCount: e.spec.groupBinCount
      }
    ) : null);
    dt(() => {
      x(u) == null && x(C)?.scales.x?.type != null && ae(u, x(C)?.scales.x?.type, !0);
    });
    function S(_, D, A) {
      return ol({
        coordinator: p,
        selection: D ?? void 0,
        query: (O) => T.Query.from(T.Query.from(g).select({ ..._.select, count: T.count() }).where(O).groupby(_.select.x, _.select.group)).select({
          x: "x",
          group: "group",
          count: "count",
          normalizeByX: T.sql`count / (SUM(count) OVER (PARTITION BY x))`
        }),
        queryResult: (O) => {
          A(Array.from(O).map(_.collect));
        }
      });
    }
    dt(() => {
      if (x(C) == null)
        return;
      let _ = x(C), D = /* @__PURE__ */ De(null), A = /* @__PURE__ */ De(null), O = S(_, null, (N) => {
        ae(D, N);
      }), M = S(_, b, (N) => {
        ae(A, N);
      }), z = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return dt(() => {
        if (x(D) != null && x(A) != null) {
          let N = (H) => JSON.stringify(H), P = e.spec.normalization == "x" ? "normalizeByX" : "count", I = Array.from(h(x(D), (H) => N(H.group), (H) => H[0].group).entries()).sort((H, G) => _.order.group(H[1], G[1])), B = h(x(D), (H) => N(H.x), (H) => ({
            x: H[0].x,
            total: H.reduce((G, re) => G + re[P], 0)
          })), $ = h(x(A), (H) => N(H.x), (H) => {
            H = H.sort((ne, se) => _.order.group(ne.group, se.group));
            let G = [], re = 0;
            for (let ne of H)
              G.push({ group: ne.group, y1: re, y2: re + ne[P] }), re += ne[P];
            return { x: H[0].x, groups: G };
          }), j = B.values().reduce((H, G) => Math.max(H, G.total), 1);
          e.spec.normalization && (j = 1);
          let U = x1e(Array.from(I.map((H) => H[1])), {
            fade: ["n/a", "(null)"],
            ordinal: _.scales.group.type != "band"
          });
          ae(l, {
            xScale: _.scales.x,
            yScale: { type: "linear", domain: [0, j] },
            colorScale: U,
            totals: Array.from(B.values()),
            items: Array.from($.values())
          });
        }
      }), dt(() => {
        let N = {
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          ...x(s) != null ? _.clause(x(s)) : { value: null, predicate: null }
        };
        b.update(N), b.activate(N);
      }), () => {
        O.destroy(), M.destroy(), b.update({
          source: z,
          clients: /* @__PURE__ */ new Set([M]),
          value: null,
          predicate: null
        });
      };
    });
  }
  dt(() => {
    c(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.group, e.context.filter);
  });
  function h(p, g, v) {
    let y = /* @__PURE__ */ new Map();
    for (let b of p) {
      let k = g(b), C = y.get(k);
      C || (C = [], y.set(k, C)), C.push(b);
    }
    return new Map(y.entries().map(([b, k]) => [b, v(k)]));
  }
  function d(p) {
    if (typeof p == "string")
      return p;
    {
      let g = su(".6");
      if (p.length == 2)
        return `[${g(p[0])}, ${g(p[1])})`;
    }
    return "(invalid)";
  }
  yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (p, g) => {
      var v = Dbe(), y = He(v);
      {
        const N = (I, B = jt, $ = jt) => {
          var j = kr(), U = He(j);
          {
            var H = (G) => {
              zd(G, {
                get width() {
                  return B();
                },
                get height() {
                  return $();
                },
                get xScale() {
                  return x(l).xScale;
                },
                get yScale() {
                  return x(l).yScale;
                },
                get colorScheme() {
                  return r();
                },
                children: (re, ne = jt) => {
                  const se = /* @__PURE__ */ K(() => ne().xScale), ie = /* @__PURE__ */ K(() => ne().yScale);
                  var ce = Sbe(), Ce = He(ce);
                  It(Ce, 17, () => x(l)?.totals ?? [], hr, (Ae, he) => {
                    const we = /* @__PURE__ */ K(() => {
                      const [et, Qe] = x(se).applyBand(x(he).x);
                      return { x0: et, x1: Qe };
                    }), ve = /* @__PURE__ */ K(() => {
                      const [et, Qe] = x(ie).applyBand([0, x(he).total]);
                      return { y0: et, y1: Qe };
                    }), Ge = /* @__PURE__ */ K(() => Math.min(Math.abs(x(we).x1 - x(we).x0) * 0.2, Math.abs(x(ve).y1 - x(ve).y0) * 0.2, 1));
                    var Xe = Cbe();
                    Ee(
                      (et, Qe, Wt, At) => {
                        te(Xe, "x", et), te(Xe, "y", Qe), te(Xe, "width", Wt), te(Xe, "height", At), te(Xe, "fill", x(a).markColorFade);
                      },
                      [
                        () => Math.min(x(we).x0, x(we).x1) + x(Ge) / 2,
                        () => Math.min(x(ve).y0, x(ve).y1),
                        () => Math.abs(x(we).x0 - x(we).x1) - x(Ge),
                        () => Math.abs(x(ve).y0 - x(ve).y1)
                      ]
                    ), Q(Ae, Xe);
                  });
                  var Me = le(Ce);
                  It(Me, 17, () => x(l)?.items ?? [], hr, (Ae, he) => {
                    let we = () => x(he).x, ve = () => x(he).groups;
                    const Ge = /* @__PURE__ */ K(() => {
                      const [Qe, Wt] = x(se).applyBand(we());
                      return { x0: Qe, x1: Wt };
                    });
                    var Xe = kr(), et = He(Xe);
                    It(et, 17, ve, hr, (Qe, Wt) => {
                      const At = /* @__PURE__ */ K(() => {
                        const [Ve, Ze] = x(ie).applyBand([x(Wt).y1, x(Wt).y2]);
                        return { y0: Ve, y1: Ze };
                      }), Xt = /* @__PURE__ */ K(() => Math.min(Math.abs(x(Ge).x1 - x(Ge).x0) * 0.2, Math.abs(x(At).y1 - x(At).y0) * 0.2, 1));
                      var Nt = _be();
                      Ee(
                        (Ve, Ze, Bt, Qt, Sr) => {
                          te(Nt, "x", Ve), te(Nt, "y", Ze), te(Nt, "width", Bt), te(Nt, "height", Qt), te(Nt, "fill", Sr);
                        },
                        [
                          () => Math.min(x(Ge).x0, x(Ge).x1) + x(Xt) / 2,
                          () => Math.min(x(At).y0, x(At).y1),
                          () => Math.abs(x(Ge).x0 - x(Ge).x1) - x(Xt),
                          () => Math.abs(x(At).y0 - x(At).y1),
                          () => x(l)?.colorScale.apply(x(Wt).group)
                        ]
                      ), Q(Qe, Nt);
                    }), Q(Ae, Xe);
                  });
                  var Pe = le(Me);
                  Tx(Pe, {
                    get proxy() {
                      return ne();
                    },
                    mode: "x",
                    get value() {
                      return x(s);
                    },
                    get colorScheme() {
                      return r();
                    },
                    onChange: (Ae) => {
                      e.onStateChange({ brush: Ae != null && Ae.x != null ? { x: Ae.x } : null });
                    }
                  }), Q(re, ce);
                },
                $$slots: { default: !0 }
              });
            };
            Fe(U, (G) => {
              x(l) != null && G(H);
            });
          }
          Q(I, j);
        };
        let P = /* @__PURE__ */ K(() => e.height != null);
        g0(y, {
          get flexHeight() {
            return x(P);
          },
          children: N,
          $$slots: { default: !0 }
        });
      }
      var b = le(y, 2), k = Y(b), C = Y(k);
      {
        var S = (N) => {
          var P = Ebe();
          It(P, 21, () => x(l).colorScale.domain, hr, (I, B) => {
            var $ = Abe(), j = Y($);
            let U;
            var H = le(j, 2), G = Y(H, !0);
            J(H), J($), Ee(
              (re, ne, se) => {
                te($, "title", re), U = ct(j, "", U, ne), at(G, se);
              },
              [
                () => JSON.stringify(x(B)),
                () => ({ background: x(l).colorScale.apply(x(B)) }),
                () => d(x(B))
              ]
            ), Q(I, $);
          }), J(P), Q(N, P);
        };
        Fe(C, (N) => {
          x(l) && N(S);
        });
      }
      J(k);
      var _ = le(k, 2), D = Y(_), A = () => e.spec.xScaleType ?? x(u) ?? "linear", O = (N) => {
        e.onSpecChange({ xScaleType: N });
      };
      Dh(D, {
        label: "X",
        get value() {
          return A();
        },
        set value(N) {
          O(N);
        }
      });
      var M = le(D, 2), z = le(Y(M), 2);
      Mx(z, {
        options: [{ value: null, label: "off" }, { value: "x", label: "X" }],
        get value() {
          return e.spec.normalization;
        },
        onChange: (N) => e.onSpecChange({ normalization: N })
      }), J(M), J(_), J(b), Q(p, v);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var Fbe = /* @__PURE__ */ St('<circle r="3"></circle>'), Tbe = /* @__PURE__ */ St('<path fill="none" stroke-width="2"></path><!>', 1), Mbe = /* @__PURE__ */ me('<div class="flex gap items-center text-sm"><span class="flex-1"></span> <!></div>'), Pbe = /* @__PURE__ */ me("<!> <!>", 1);
function Rbe(t, e) {
  nt(e, !0);
  const r = () => gi(s, "$colorScheme", n), [n, i] = Jo();
  let { coordinator: o, colorScheme: s } = e.context, a = /* @__PURE__ */ K(() => xc[r()]), l = /* @__PURE__ */ De(null), u = /* @__PURE__ */ De(null);
  function c(h, d, p) {
    let g = /* @__PURE__ */ De(null);
    eu(h, d, p).then((b) => {
      ae(g, b);
    });
    let v = /* @__PURE__ */ K(() => x(g) ? bp({
      key: "x",
      stats: x(g),
      scaleType: e.spec.xScaleType,
      binCount: 52
    }) : null);
    dt(() => {
      x(u) == null && x(v)?.scales.x?.type != null && ae(u, x(v)?.scales.x?.type, !0);
    });
    function y(b, k) {
      return ol({
        coordinator: h,
        selection: e.context.filter,
        query: (C) => T.Query.from(d).select({ ...b.select, count: T.count() }).where(C).groupby(b.select.x).orderby(b.select.x),
        queryResult: (C) => {
          k(Array.from(C).map(b.collect));
        }
      });
    }
    dt(() => {
      if (x(v) == null)
        return;
      let b = x(v), k = /* @__PURE__ */ De(ps([])), C = y(b, (S) => {
        ae(k, S, !0);
      });
      return dt(() => {
        x(k).length > 0 && ae(l, { xScale: b.scales.x, points: x(k) });
      }), () => {
        C.destroy();
      };
    });
  }
  dt(() => {
    c(o, e.context.table, e.spec.data.x);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (h, d) => {
      var p = Pbe(), g = He(p);
      {
        const b = (C, S = jt, _ = jt) => {
          var D = kr(), A = He(D);
          {
            var O = (M) => {
              const z = /* @__PURE__ */ K(() => x(l).points.reduce((N, P) => Math.max(N, P.count), 1));
              {
                const N = (I, B = jt) => {
                  const $ = /* @__PURE__ */ K(() => B().xScale), j = /* @__PURE__ */ K(() => B().yScale);
                  var U = kr(), H = He(U);
                  {
                    var G = (re) => {
                      const ne = /* @__PURE__ */ K(() => x(l).points.map((Ce, Me) => {
                        const Pe = x($).apply(Ce.x), Ae = x(j).apply(Ce.count);
                        return `${Me === 0 ? "M" : "L"} ${Pe} ${Ae}`;
                      }).join(" "));
                      var se = Tbe(), ie = He(se), ce = le(ie);
                      It(ce, 17, () => x(l).points, hr, (Ce, Me) => {
                        const Pe = /* @__PURE__ */ K(() => x($).apply(x(Me).x)), Ae = /* @__PURE__ */ K(() => x(j).apply(x(Me).count));
                        var he = Fbe();
                        Ee(() => {
                          te(he, "cx", x(Pe)), te(he, "cy", x(Ae)), te(he, "fill", x(a).markColor);
                        }), Q(Ce, he);
                      }), Ee(() => {
                        te(ie, "d", x(ne)), te(ie, "stroke", x(a).markColor);
                      }), Q(re, se);
                    };
                    Fe(H, (re) => {
                      x(l).points.length > 1 && re(G);
                    });
                  }
                  Q(I, U);
                };
                let P = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(z)] }));
                zd(M, {
                  get width() {
                    return S();
                  },
                  get height() {
                    return _();
                  },
                  get xScale() {
                    return x(l).xScale;
                  },
                  get yScale() {
                    return x(P);
                  },
                  get colorScheme() {
                    return r();
                  },
                  children: N,
                  $$slots: { default: !0 }
                });
              }
            };
            Fe(A, (M) => {
              x(l) != null && M(O);
            });
          }
          Q(C, D);
        };
        let k = /* @__PURE__ */ K(() => e.height != null);
        g0(g, {
          get flexHeight() {
            return x(k);
          },
          children: b,
          $$slots: { default: !0 }
        });
      }
      var v = le(g, 2);
      {
        var y = (b) => {
          var k = Mbe(), C = le(Y(k), 2);
          {
            let S = /* @__PURE__ */ K(() => e.spec.xScaleType ?? x(u) ?? "linear");
            Dh(C, {
              label: "X",
              get value() {
                return x(S);
              },
              onChange: (_) => {
                e.onSpecChange({ xScaleType: _ });
              }
            });
          }
          J(k), Q(b, k);
        };
        Fe(v, (b) => {
          x(l)?.xScale.type != "band" && b(y);
        });
      }
      Q(h, p);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
var Nbe = /* @__PURE__ */ me('<div class="p-2 w-full"></div>');
function $be(t, e) {
  nt(e, !0);
  let { coordinator: r, colorScheme: n } = e.context, i = /* @__PURE__ */ De(void 0), o = /* @__PURE__ */ De(ps(e.width ?? 800));
  function s(c, h) {
    if (!c) return !1;
    let d = h.mark?.plot?.element;
    return d == null ? !1 : c?.contains(d) ?? !1;
  }
  async function a(c, h, d, p = {}) {
    try {
      const g = _K(h), v = AK({ coordinator: c }), y = await SK(g, { params: new Map(Object.entries(p)), api: v });
      return d.innerHTML = "", y.element && d.appendChild(y.element), () => {
        for (const b in p) {
          const k = p[b];
          if (o3(k))
            for (const C of k.clauses)
              s(d, C.source) && (C.source?.reset?.(), k.update({ ...C, value: null, predicate: null }));
        }
        y.element?.remove();
      };
    } catch (g) {
      return console.error("[MosaicSpec] Failed to render vgplot spec:", g), d.innerHTML = `<div style="padding: 1rem; color: #ef4444;">
        Failed to render chart: ${g instanceof Error ? g.message : String(g)}
      </div>`, () => {
      };
    }
  }
  Qg(() => {
    dt(() => {
      let c = null;
      async function h() {
        x(i) && e.spec.spec && (c = await a(r, e.spec.spec, x(i), { filter: e.context.filter }));
      }
      return h(), () => {
        c?.();
      };
    });
  }), Ws(() => {
    e.width != null && ae(o, e.width, !0);
  });
  var l = Nbe();
  let u;
  Qs(l, (c) => ae(i, c), () => x(i)), Ee(() => u = ct(l, "", u, {
    height: e.height != null ? `${e.height}px` : "100%"
  })), Xs(l, "clientWidth", (c) => ae(o, c)), Q(t, l), it();
}
var Ibe = /* @__PURE__ */ me('<div class="bg-slate-100 p-2 rounded-md w-full h-full overflow-y-scroll"><pre> </pre></div>');
function $k(t, e) {
  nt(e, !0);
  var r = Ibe(), n = Y(r), i = Y(n, !0);
  J(n), J(r), Ee((o) => at(i, o), [() => JSON.stringify(e.spec, null, 2)]), Q(t, r), it();
}
var Bbe = /* @__PURE__ */ me('<span class="mx-1"> </span>'), Lbe = /* @__PURE__ */ me("<button><!> <!></button>");
function Mu(t, e) {
  nt(e, !0);
  let r = lt(e, "label", 3, null), n = lt(e, "icon", 3, null), i = lt(e, "title", 3, ""), o = lt(e, "order", 3, null);
  var s = Lbe();
  s.__click = () => {
    e.onClick?.();
  };
  let a;
  var l = Y(s);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(n);
      var g = kr(), v = He(g);
      Qd(v, () => x(p), (y, b) => {
        b(y, { class: "w-5 h-5" });
      }), Q(d, g);
    };
    Fe(l, (d) => {
      n() != null && d(u);
    });
  }
  var c = le(l, 2);
  {
    var h = (d) => {
      var p = Bbe(), g = Y(p, !0);
      J(p), Ee(() => at(g, r())), Q(d, p);
    };
    Fe(c, (d) => {
      r() != null && r() != "" && d(h);
    });
  }
  J(s), Ee(() => {
    en(s, 1, `rounded-md flex select-none items-center px-1.5 py-1.5 h-[28px] border bg-white dark:bg-slate-900 border-slate-300 dark:border-slate-600 dark:text-slate-400 focus-visible:outline-2 outline-blue-600 -outline-offset-1 ${e.class ?? "" ?? ""}`), te(s, "title", i()), a = ct(s, "", a, { order: o() });
  }), Q(t, s), it();
}
nn(["click"]);
var zbe = /* @__PURE__ */ me("<input/>");
function ML(t, e) {
  nt(e, !0);
  let r = lt(e, "value", 15), n = lt(e, "type", 3, "text"), i = lt(e, "placeholder", 3, ""), o = lt(e, "className", 3, "");
  function s(l) {
    l.key == "Escape" && l.stopPropagation();
  }
  var a = zbe();
  FT(a), a.__keydown = s, Ee(() => {
    te(a, "type", n()), te(a, "placeholder", i()), en(a, 1, `form-input rounded-md py-1 bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 ${o() ?? "" ?? ""}`);
  }), eQ(a, r), Q(t, a), it();
}
nn(["keydown"]);
var jbe = /* @__PURE__ */ me('<div><button class="flex-1 overflow-hidden text-left"><div class="text-ellipsis overflow-hidden w-full"> </div> <div class="text-ellipsis overflow-hidden w-full"><code class="text-xs whitespace-nowrap"> </code></div></button> <div class="flex-none flex gap-1"><!> <!></div></div>'), qbe = /* @__PURE__ */ me('<div class="mt-4"><!> <div class="text-slate-500 dark:text-slate-400 text-sm mb-1">SQL Predicate</div> <div class="w-full !h-32 mb-2"><!></div> <div class="flex gap-2"><!> <!> <div class="flex-1"></div> <button class="text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200">Current Predicate</button></div></div>'), Ube = /* @__PURE__ */ me('<div class="flex flex-col gap-1"><!> <button class="text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden">+ Add Predicate</button></div> <!>', 1);
function Hbe(t, e) {
  nt(e, !0);
  const r = () => gi(o, "$colorScheme", n), [n, i] = Jo();
  let { colorScheme: o } = e.context, s = /* @__PURE__ */ K(() => e.spec.items ?? []), a = /* @__PURE__ */ K(() => e.state.selectedPredicates ?? []), l = /* @__PURE__ */ De(!1), u = /* @__PURE__ */ De(null), c = /* @__PURE__ */ De(""), h = /* @__PURE__ */ De("");
  function d() {
    ae(l, !1), ae(u, null), ae(h, ""), ae(c, "");
  }
  function p(v) {
    e.onSpecChange({ items: v }), e.onStateChange({
      selectedPredicates: (e.state.selectedPredicates ?? []).filter((y) => v.find((b) => b.predicate == y) != null)
    });
  }
  async function g() {
    let v = x(h).trim();
    v == "" && (v = "Predicate");
    let y = x(c).trim();
    if (y == "")
      return null;
    try {
      await e.context.coordinator.query(T.Query.from(e.context.table).select({ count: T.count() }).where(y));
    } catch (b) {
      return alert(b.toString()), null;
    }
    return { name: v, predicate: y };
  }
  dt(() => {
    let v = ol({
      coordinator: e.context.coordinator,
      selection: e.context.filter,
      query: () => T.sql`SELECT 1`
    }), y = {
      reset: () => {
        e.onStateChange({ selectedPredicates: [] });
      }
    };
    return Ws(() => {
      if (x(a).length == 0)
        e.context.filter.update({
          source: y,
          clients: /* @__PURE__ */ new Set([v]),
          predicate: null,
          value: null
        });
      else {
        let b = x(a).map((k) => "(" + k + ")").join(" OR ");
        e.context.filter.update({
          source: y,
          clients: /* @__PURE__ */ new Set([v]),
          predicate: T.asVerbatim(b),
          value: b
        });
      }
    }), () => {
      v.destroy();
    };
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (v, y) => {
      var b = Ube(), k = He(b), C = Y(k);
      It(C, 17, () => x(s), hr, (A, O) => {
        const M = /* @__PURE__ */ K(() => x(a).indexOf(x(O).predicate) >= 0);
        var z = jbe();
        let N;
        var P = Y(z);
        P.__click = (ne) => {
          ne.shiftKey ? ae(a, x(M) ? x(a).filter((se) => se != x(O).predicate) : [...x(a), x(O).predicate]) : x(M) ? ae(a, []) : ae(a, [x(O).predicate]);
        };
        var I = Y(P), B = Y(I, !0);
        J(I);
        var $ = le(I, 2), j = Y($), U = Y(j, !0);
        J(j), J($), J(P);
        var H = le(P, 2), G = Y(H);
        Mu(G, {
          get icon() {
            return BI;
          },
          onClick: () => {
            ae(u, x(O)), ae(c, x(O).predicate, !0), ae(h, x(O).name, !0), ae(l, !0);
          }
        });
        var re = le(G, 2);
        Mu(re, {
          get icon() {
            return vx;
          },
          onClick: () => {
            p(x(s).filter((ne) => ne !== x(O)));
          }
        }), J(H), J(z), Ee(() => {
          N = en(z, 1, "flex gap-4 w-full bg-white dark:bg-slate-800 p-2 rounded-md border border-slate-200 dark:border-slate-600 select-none", null, N, {
            "!bg-blue-100": x(M),
            "!border-blue-400": x(M),
            "dark:!bg-blue-800": x(M),
            "dark:!border-blue-600": x(M)
          }), at(B, x(O).name), te(j, "title", x(O).predicate), at(U, x(O).predicate);
        }), Q(A, z);
      });
      var S = le(C, 2);
      S.__click = () => {
        ae(l, !0), ae(u, null);
      }, J(k);
      var _ = le(k, 2);
      {
        var D = (A) => {
          var O = qbe(), M = Y(O);
          ML(M, {
            placeholder: "name",
            className: "w-full mb-2",
            get value() {
              return x(h);
            },
            set value(H) {
              ae(h, H, !0);
            }
          });
          var z = le(M, 4), N = Y(z);
          {
            let H = /* @__PURE__ */ K(() => ({
              table: e.context.table,
              columns: e.context.columns
            }));
            ES(N, {
              language: "sql",
              get sql() {
                return x(H);
              },
              class: "w-full h-full",
              get colorScheme() {
                return r();
              },
              get value() {
                return x(c);
              },
              onChange: (G) => ae(c, G, !0)
            });
          }
          J(z);
          var P = le(z, 2), I = Y(P);
          {
            var B = (H) => {
              Mu(H, {
                label: "Update",
                onClick: async () => {
                  let G = await g();
                  G && (p(x(s).map((re) => re === x(u) ? G : re)), d());
                }
              });
            }, $ = (H) => {
              Mu(H, {
                label: "Add",
                onClick: async () => {
                  let G = await g();
                  G && (p([...x(s), G]), d());
                }
              });
            };
            Fe(I, (H) => {
              x(u) != null ? H(B) : H($, !1);
            });
          }
          var j = le(I, 2);
          Mu(j, {
            label: "Cancel",
            onClick: () => {
              ae(u, null), ae(l, !1);
            }
          });
          var U = le(j, 4);
          U.__click = () => ae(c, f_(e.context.filter.predicate(null)) ?? "", !0), J(P), J(O), Q(A, O);
        };
        Fe(_, (A) => {
          x(l) && A(D);
        });
      }
      Q(v, b);
    },
    $$slots: { default: !0 }
  }), it(), i();
}
nn(["click"]);
var Vbe = /* @__PURE__ */ me("<option disabled selected> </option>"), Wbe = /* @__PURE__ */ me("<hr/>"), Gbe = /* @__PURE__ */ me("<option> </option>"), Kbe = /* @__PURE__ */ me('<label class="select-none flex items-center gap-2"><span class="text-slate-500 dark:text-slate-400 whitespace-nowrap"> </span> <select><!><!></select></label>'), Xbe = /* @__PURE__ */ me("<option disabled selected> </option>"), Qbe = /* @__PURE__ */ me("<hr/>"), Jbe = /* @__PURE__ */ me("<option> </option>"), Ybe = /* @__PURE__ */ me("<select><!><!></select>");
function Oh(t, e) {
  nt(e, !0);
  let r = lt(e, "label", 3, void 0), n = lt(e, "disabled", 3, !1), i = lt(e, "placeholder", 3, null), o = lt(e, "options", 19, () => []), s = lt(e, "onChange", 3, void 0), a = /* @__PURE__ */ De(void 0);
  const l = DL(), u = l + "_null", c = l + "_undefined", h = (k) => k === null ? u : k === void 0 ? c : k.toString(), d = (k) => k === u ? null : k === c ? void 0 : k;
  function p(k) {
    !s() || !x(a) || s()(d(x(a).value));
  }
  var g = kr(), v = He(g);
  {
    var y = (k) => {
      var C = Kbe(), S = Y(C), _ = Y(S, !0);
      J(S);
      var D = le(S, 2);
      D.__change = p;
      var A = Y(D);
      {
        var O = (N) => {
          var P = Vbe(), I = Y(P, !0);
          J(P), P.value = (P.__value = null) ?? "", Ee(() => at(I, i())), Q(N, P);
        };
        Fe(A, (N) => {
          i() != null && N(O);
        });
      }
      var M = le(A);
      It(M, 17, o, hr, (N, P) => {
        var I = kr(), B = He(I);
        {
          var $ = (U) => {
            var H = Wbe();
            Q(U, H);
          }, j = (U) => {
            var H = Gbe(), G = Y(H, !0);
            J(H);
            var re = {};
            Ee(
              (ne) => {
                at(G, x(P).label), re !== (re = ne) && (H.value = (H.__value = ne) ?? "");
              },
              [() => h(x(P).value)]
            ), Q(U, H);
          };
          Fe(B, (U) => {
            x(P) === "---" ? U($) : U(j, !1);
          });
        }
        Q(N, I);
      }), J(D), Qs(D, (N) => ae(a, N), () => x(a));
      var z;
      s1(D), J(C), Ee(
        (N) => {
          at(_, r()), en(D, 1, `form-select rounded-md py-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 dark:text-slate-400 text-ellipsis ${e.class ?? "" ?? ""}`), D.disabled = n(), z !== (z = N) && (D.value = (D.__value = N) ?? "", bd(D, N));
        },
        [() => h(e.value)]
      ), Q(k, C);
    }, b = (k) => {
      var C = Ybe();
      C.__change = p;
      var S = Y(C);
      {
        var _ = (O) => {
          var M = Xbe(), z = Y(M, !0);
          J(M), M.value = (M.__value = null) ?? "", Ee(() => at(z, i())), Q(O, M);
        };
        Fe(S, (O) => {
          i() != null && O(_);
        });
      }
      var D = le(S);
      It(D, 17, o, hr, (O, M) => {
        var z = kr(), N = He(z);
        {
          var P = (B) => {
            var $ = Qbe();
            Q(B, $);
          }, I = (B) => {
            var $ = Jbe(), j = Y($, !0);
            J($);
            var U = {};
            Ee(
              (H) => {
                at(j, x(M).label), U !== (U = H) && ($.value = ($.__value = H) ?? "");
              },
              [() => h(x(M).value)]
            ), Q(B, $);
          };
          Fe(N, (B) => {
            x(M) === "---" ? B(P) : B(I, !1);
          });
        }
        Q(O, z);
      }), J(C), Qs(C, (O) => ae(a, O), () => x(a));
      var A;
      s1(C), Ee(
        (O) => {
          en(C, 1, `form-select rounded-md py-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 dark:text-slate-400 select-none text-ellipsis ${e.class ?? "" ?? ""}`), C.disabled = n(), A !== (A = O) && (C.value = (C.__value = O) ?? "", bd(C, O));
        },
        [() => h(e.value)]
      ), Q(k, C);
    };
    Fe(v, (k) => {
      r() != null ? k(y) : k(b, !1);
    });
  }
  Q(t, g), it();
}
nn(["change"]);
const Zbe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<line x1="15" y1="54" x2="15" y2="12" stroke="black" stroke-width="2"/>
<line x1="32" y1="53" x2="32" y2="10" stroke="black" stroke-width="2"/>
<line x1="49" y1="45" x2="49" y2="19" stroke="black" stroke-width="2"/>
<rect x="8" y="27" width="14" height="18" rx="3" fill="#007AFF"/>
<rect x="25" y="22" width="14" height="14" rx="3" fill="#007AFF"/>
<rect x="42" y="27" width="14" height="12" rx="3" fill="#007AFF"/>
</svg>
`, exe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="32" cy="28" r="2" fill="#007AFF"/>
<circle cx="32" cy="24" r="2" fill="#007AFF"/>
<circle cx="32" cy="20" r="2" fill="#007AFF"/>
<circle cx="36" cy="32" r="2" fill="#007AFF"/>
<circle cx="36" cy="28" r="2" fill="#007AFF"/>
<circle cx="36" cy="24" r="2" fill="#007AFF"/>
<circle cx="28" cy="32" r="2" fill="#007AFF"/>
<circle cx="28" cy="28" r="2" fill="#007AFF"/>
<circle cx="28" cy="24" r="2" fill="#007AFF"/>
<circle cx="28" cy="20" r="2" fill="#007AFF"/>
<circle cx="28" cy="16" r="2" fill="#007AFF"/>
<circle cx="44" cy="24" r="2" fill="#A3CFFF"/>
<circle cx="44" cy="20" r="2" fill="#A3CFFF"/>
<circle cx="44" cy="16" r="2" fill="#A3CFFF"/>
<circle cx="40" cy="20" r="2" fill="#A3CFFF"/>
<circle cx="40" cy="16" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="32" r="2" fill="#007AFF"/>
<circle cx="20" cy="28" r="2" fill="#007AFF"/>
<circle cx="20" cy="24" r="2" fill="#007AFF"/>
<circle cx="20" cy="20" r="2" fill="#3897FF"/>
<circle cx="20" cy="16" r="2" fill="#3897FF"/>
<circle cx="24" cy="32" r="2" fill="#007AFF"/>
<circle cx="24" cy="28" r="2" fill="#007AFF"/>
<circle cx="24" cy="24" r="2" fill="#007AFF"/>
<circle cx="24" cy="20" r="2" fill="#3897FF"/>
<circle cx="24" cy="16" r="2" fill="#3897FF"/>
<circle cx="16" cy="32" r="2" fill="#3897FF"/>
<circle cx="16" cy="28" r="2" fill="#3897FF"/>
<circle cx="16" cy="24" r="2" fill="#3897FF"/>
<circle cx="32" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="32" cy="36" r="2" fill="#007AFF"/>
<circle cx="36" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="36" cy="36" r="2" fill="#007AFF"/>
<circle cx="28" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="28" cy="36" r="2" fill="#007AFF"/>
<circle cx="44" cy="44" r="2" fill="#3897FF"/>
<circle cx="48" cy="44" r="2" fill="#3897FF"/>
<circle cx="48" cy="40" r="2" fill="#3897FF"/>
<circle cx="52" cy="32" r="2" fill="#A3CFFF"/>
<circle cx="52" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="32" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="28" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="52" cy="36" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="36" r="2" fill="#A3CFFF"/>
<circle cx="8" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="12" cy="32" r="2" fill="#3897FF"/>
<circle cx="12" cy="28" r="2" fill="#3897FF"/>
<circle cx="28" cy="8" r="2" fill="#A3CFFF"/>
<circle cx="48" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="48" cy="8" r="2" fill="#E0EFFF"/>
<circle cx="20" cy="12" r="2" fill="#A3CFFF"/>
<circle cx="24" cy="12" r="2" fill="#A3CFFF"/>
<circle cx="24" cy="8" r="2" fill="#A3CFFF"/>
<circle cx="52" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="8" r="2" fill="#E0EFFF"/>
<circle cx="8" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="12" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="32" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="32" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="36" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="28" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="28" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="44" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="40" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="20" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="24" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="24" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="16" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="12" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="8" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="12" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="12" cy="44" r="2" fill="#3897FF"/>
<circle cx="40" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="40" r="2" fill="#007AFF"/>
<circle cx="24" cy="36" r="2" fill="#007AFF"/>
<circle cx="16" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="16" cy="40" r="2" fill="#3897FF"/>
<circle cx="16" cy="36" r="2" fill="#3897FF"/>
</svg>
`, txe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="8" y="8" width="48" height="14" rx="3" fill="#007AFF"/>
<rect x="8" y="25" width="36" height="14" rx="3" fill="#007AFF"/>
<rect x="8" y="42" width="24" height="14" rx="3" fill="#007AFF"/>
</svg>
`, rxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="48" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="48" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.78"/>
<rect x="48" y="28" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="48" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.5"/>
<rect x="48" y="8" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="38" y="48" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.96"/>
<rect x="38" y="38" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="38" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.63"/>
<rect x="38" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.36"/>
<rect x="38" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.64"/>
<rect x="28" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="28" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.45"/>
<rect x="28" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.28"/>
<rect x="28" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.8"/>
<rect x="28" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.7"/>
<rect x="18" y="48" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.27"/>
<rect x="18" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.46"/>
<rect x="18" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.74"/>
<rect x="18" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.96"/>
<rect x="18" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.82"/>
<rect x="8" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="8" y="38" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="8" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.33"/>
<rect x="8" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.12"/>
<rect x="8" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.4"/>
</svg>
`, nxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M24.5966 37L26.2869 26.8182H29.7273C30.5227 26.8182 31.1508 26.9607 31.6115 27.2457C32.0755 27.5308 32.3887 27.9169 32.5511 28.4041C32.7169 28.8913 32.75 29.4366 32.6506 30.0398C32.5511 30.6364 32.3374 31.1799 32.0092 31.6705C31.6844 32.161 31.2436 32.5521 30.6868 32.8438C30.1333 33.1354 29.4621 33.2812 28.6733 33.2812H26.2074L26.3864 32.1875H28.8125C29.3561 32.1875 29.8101 32.093 30.1747 31.9041C30.5393 31.7152 30.8243 31.4583 31.0298 31.1335C31.2353 30.8087 31.3712 30.4441 31.4375 30.0398C31.5038 29.6288 31.4872 29.2642 31.3878 28.946C31.2917 28.6245 31.0911 28.3726 30.7862 28.1903C30.4846 28.0047 30.0587 27.9119 29.5085 27.9119H27.3409L25.8295 37H24.5966ZM33.3105 37L34.5833 29.3636H35.7168L35.5179 30.517H35.5975C35.7963 30.1392 36.0996 29.8326 36.5073 29.5973C36.915 29.362 37.3475 29.2443 37.8049 29.2443C37.8944 29.2443 38.0021 29.246 38.128 29.2493C38.254 29.2493 38.3517 29.2543 38.4213 29.2642L38.2225 30.4574C38.1827 30.4474 38.0932 30.4325 37.954 30.4126C37.8148 30.3894 37.6657 30.3778 37.5066 30.3778C37.1354 30.3778 36.7923 30.4557 36.4775 30.6115C36.1626 30.764 35.8991 30.9761 35.687 31.2479C35.4748 31.5163 35.339 31.8229 35.2793 32.1676L34.4838 37H33.3105ZM41.4963 37.1591C40.7638 37.1591 40.1589 36.9967 39.6816 36.6719C39.2044 36.3438 38.8713 35.8864 38.6824 35.2997C38.4934 34.7098 38.4636 34.0237 38.5929 33.2415C38.7221 32.4593 38.979 31.7699 39.3635 31.1733C39.7479 30.5734 40.2269 30.1061 40.8002 29.7713C41.3736 29.4332 42.0034 29.2642 42.6895 29.2642C43.0872 29.2642 43.47 29.3305 43.8379 29.4631C44.2058 29.5956 44.524 29.8111 44.7924 30.1094C45.0609 30.4044 45.2482 30.7955 45.3542 31.2827C45.4603 31.7699 45.4537 32.3698 45.3343 33.0824L45.2548 33.5795H39.3684L39.5275 32.5653H44.2207C44.2969 32.1345 44.277 31.75 44.161 31.4119C44.0484 31.0739 43.8511 30.8071 43.5694 30.6115C43.291 30.416 42.938 30.3182 42.5105 30.3182C42.0697 30.3182 41.6587 30.4375 41.2775 30.6761C40.8964 30.9115 40.5782 31.2098 40.323 31.571C40.0678 31.929 39.9087 32.2936 39.8457 32.6648L39.7065 33.5398C39.6071 34.1728 39.622 34.6766 39.7512 35.0511C39.8838 35.4257 40.1142 35.6958 40.4423 35.8615C40.7704 36.0239 41.1814 36.1051 41.6752 36.1051C41.9901 36.1051 42.2801 36.062 42.5453 35.9759C42.8104 35.8864 43.0474 35.7538 43.2562 35.5781C43.465 35.3991 43.6407 35.1771 43.7832 34.9119L44.8571 35.2301C44.6748 35.6146 44.4179 35.9527 44.0865 36.2443C43.7583 36.5327 43.3739 36.758 42.9331 36.9205C42.4956 37.0795 42.0166 37.1591 41.4963 37.1591ZM49.3638 37.1591C48.7241 37.1591 48.1872 36.9983 47.753 36.6768C47.3188 36.352 47.0123 35.8946 46.8333 35.3047C46.6576 34.7114 46.6361 34.0104 46.7686 33.2017C46.9045 32.3996 47.1581 31.7036 47.5293 31.1136C47.9038 30.5237 48.3629 30.0679 48.9064 29.7464C49.45 29.425 50.0433 29.2642 50.6863 29.2642C51.1834 29.2642 51.5629 29.3471 51.8248 29.5128C52.0899 29.6752 52.2821 29.8608 52.4015 30.0696C52.5208 30.2751 52.6119 30.4441 52.6749 30.5767H52.7743L53.4007 26.8182H54.574L52.8837 37H51.7502L51.949 35.8267H51.8098C51.7005 35.9659 51.548 36.1416 51.3525 36.3537C51.1569 36.5625 50.8984 36.7498 50.5769 36.9155C50.2587 37.0779 49.8543 37.1591 49.3638 37.1591ZM49.6522 36.1051C50.1228 36.1051 50.5437 35.9825 50.915 35.7372C51.2895 35.4886 51.601 35.1456 51.8496 34.7081C52.0982 34.2673 52.2705 33.7585 52.3667 33.1818C52.4628 32.6117 52.4595 32.1129 52.3567 31.6854C52.254 31.2545 52.0568 30.9197 51.7651 30.6811C51.4734 30.4392 51.0873 30.3182 50.6067 30.3182C50.1129 30.3182 49.6837 30.4458 49.3191 30.701C48.9545 30.9529 48.6578 31.2959 48.4292 31.7301C48.2005 32.161 48.0414 32.6449 47.9519 33.1818C47.8624 33.7254 47.8607 34.2192 47.9469 34.6634C48.0331 35.1042 48.2154 35.4555 48.4938 35.7173C48.7755 35.9759 49.1616 36.1051 49.6522 36.1051Z" fill="#007AFF"/>
<path d="M24.5966 20L26.2869 9.81818H29.7273C30.5227 9.81818 31.1508 9.9607 31.6115 10.2457C32.0755 10.5308 32.3887 10.9169 32.5511 11.4041C32.7169 11.8913 32.75 12.4366 32.6506 13.0398C32.5511 13.6364 32.3374 14.1799 32.0092 14.6705C31.6844 15.161 31.2436 15.5521 30.6868 15.8438C30.1333 16.1354 29.4621 16.2812 28.6733 16.2812H26.2074L26.3864 15.1875H28.8125C29.3561 15.1875 29.8101 15.093 30.1747 14.9041C30.5393 14.7152 30.8243 14.4583 31.0298 14.1335C31.2353 13.8087 31.3712 13.4441 31.4375 13.0398C31.5038 12.6288 31.4872 12.2642 31.3878 11.946C31.2917 11.6245 31.0911 11.3726 30.7862 11.1903C30.4846 11.0047 30.0587 10.9119 29.5085 10.9119H27.3409L25.8295 20H24.5966ZM33.3105 20L34.5833 12.3636H35.7168L35.5179 13.517H35.5975C35.7963 13.1392 36.0996 12.8326 36.5073 12.5973C36.915 12.362 37.3475 12.2443 37.8049 12.2443C37.8944 12.2443 38.0021 12.246 38.128 12.2493C38.254 12.2493 38.3517 12.2543 38.4213 12.2642L38.2225 13.4574C38.1827 13.4474 38.0932 13.4325 37.954 13.4126C37.8148 13.3894 37.6657 13.3778 37.5066 13.3778C37.1354 13.3778 36.7923 13.4557 36.4775 13.6115C36.1626 13.764 35.8991 13.9761 35.687 14.2479C35.4748 14.5163 35.339 14.8229 35.2793 15.1676L34.4838 20H33.3105ZM41.4963 20.1591C40.7638 20.1591 40.1589 19.9967 39.6816 19.6719C39.2044 19.3438 38.8713 18.8864 38.6824 18.2997C38.4934 17.7098 38.4636 17.0237 38.5929 16.2415C38.7221 15.4593 38.979 14.7699 39.3635 14.1733C39.7479 13.5734 40.2269 13.1061 40.8002 12.7713C41.3736 12.4332 42.0034 12.2642 42.6895 12.2642C43.0872 12.2642 43.47 12.3305 43.8379 12.4631C44.2058 12.5956 44.524 12.8111 44.7924 13.1094C45.0609 13.4044 45.2482 13.7955 45.3542 14.2827C45.4603 14.7699 45.4537 15.3698 45.3343 16.0824L45.2548 16.5795H39.3684L39.5275 15.5653H44.2207C44.2969 15.1345 44.277 14.75 44.161 14.4119C44.0484 14.0739 43.8511 13.8071 43.5694 13.6115C43.291 13.416 42.938 13.3182 42.5105 13.3182C42.0697 13.3182 41.6587 13.4375 41.2775 13.6761C40.8964 13.9115 40.5782 14.2098 40.323 14.571C40.0678 14.929 39.9087 15.2936 39.8457 15.6648L39.7065 16.5398C39.6071 17.1728 39.622 17.6766 39.7512 18.0511C39.8838 18.4257 40.1142 18.6958 40.4423 18.8615C40.7704 19.0239 41.1814 19.1051 41.6752 19.1051C41.9901 19.1051 42.2801 19.062 42.5453 18.9759C42.8104 18.8864 43.0474 18.7538 43.2562 18.5781C43.465 18.3991 43.6407 18.1771 43.7832 17.9119L44.8571 18.2301C44.6748 18.6146 44.4179 18.9527 44.0865 19.2443C43.7583 19.5327 43.3739 19.758 42.9331 19.9205C42.4956 20.0795 42.0166 20.1591 41.4963 20.1591ZM49.3638 20.1591C48.7241 20.1591 48.1872 19.9983 47.753 19.6768C47.3188 19.352 47.0123 18.8946 46.8333 18.3047C46.6576 17.7114 46.6361 17.0104 46.7686 16.2017C46.9045 15.3996 47.1581 14.7036 47.5293 14.1136C47.9038 13.5237 48.3629 13.0679 48.9064 12.7464C49.45 12.425 50.0433 12.2642 50.6863 12.2642C51.1834 12.2642 51.5629 12.3471 51.8248 12.5128C52.0899 12.6752 52.2821 12.8608 52.4015 13.0696C52.5208 13.2751 52.6119 13.4441 52.6749 13.5767H52.7743L53.4007 9.81818H54.574L52.8837 20H51.7502L51.949 18.8267H51.8098C51.7005 18.9659 51.548 19.1416 51.3525 19.3537C51.1569 19.5625 50.8984 19.7498 50.5769 19.9155C50.2587 20.0779 49.8543 20.1591 49.3638 20.1591ZM49.6522 19.1051C50.1228 19.1051 50.5437 18.9825 50.915 18.7372C51.2895 18.4886 51.601 18.1456 51.8496 17.7081C52.0982 17.2673 52.2705 16.7585 52.3667 16.1818C52.4628 15.6117 52.4595 15.1129 52.3567 14.6854C52.254 14.2545 52.0568 13.9197 51.7651 13.6811C51.4734 13.4392 51.0873 13.3182 50.6067 13.3182C50.1129 13.3182 49.6837 13.4458 49.3191 13.701C48.9545 13.9529 48.6578 14.2959 48.4292 14.7301C48.2005 15.161 48.0414 15.6449 47.9519 16.1818C47.8624 16.7254 47.8607 17.2192 47.9469 17.6634C48.0331 18.1042 48.2154 18.4555 48.4938 18.7173C48.7755 18.9759 49.1616 19.1051 49.6522 19.1051Z" fill="#007AFF" fill-opacity="0.25"/>
<path d="M24.5966 54L26.2869 43.8182H29.7273C30.5227 43.8182 31.1508 43.9607 31.6115 44.2457C32.0755 44.5308 32.3887 44.9169 32.5511 45.4041C32.7169 45.8913 32.75 46.4366 32.6506 47.0398C32.5511 47.6364 32.3374 48.1799 32.0092 48.6705C31.6844 49.161 31.2436 49.5521 30.6868 49.8438C30.1333 50.1354 29.4621 50.2812 28.6733 50.2812H26.2074L26.3864 49.1875H28.8125C29.3561 49.1875 29.8101 49.093 30.1747 48.9041C30.5393 48.7152 30.8243 48.4583 31.0298 48.1335C31.2353 47.8087 31.3712 47.4441 31.4375 47.0398C31.5038 46.6288 31.4872 46.2642 31.3878 45.946C31.2917 45.6245 31.0911 45.3726 30.7862 45.1903C30.4846 45.0047 30.0587 44.9119 29.5085 44.9119H27.3409L25.8295 54H24.5966ZM33.3105 54L34.5833 46.3636H35.7168L35.5179 47.517H35.5975C35.7963 47.1392 36.0996 46.8326 36.5073 46.5973C36.915 46.362 37.3475 46.2443 37.8049 46.2443C37.8944 46.2443 38.0021 46.246 38.128 46.2493C38.254 46.2493 38.3517 46.2543 38.4213 46.2642L38.2225 47.4574C38.1827 47.4474 38.0932 47.4325 37.954 47.4126C37.8148 47.3894 37.6657 47.3778 37.5066 47.3778C37.1354 47.3778 36.7923 47.4557 36.4775 47.6115C36.1626 47.764 35.8991 47.9761 35.687 48.2479C35.4748 48.5163 35.339 48.8229 35.2793 49.1676L34.4838 54H33.3105ZM41.4963 54.1591C40.7638 54.1591 40.1589 53.9967 39.6816 53.6719C39.2044 53.3438 38.8713 52.8864 38.6824 52.2997C38.4934 51.7098 38.4636 51.0237 38.5929 50.2415C38.7221 49.4593 38.979 48.7699 39.3635 48.1733C39.7479 47.5734 40.2269 47.1061 40.8002 46.7713C41.3736 46.4332 42.0034 46.2642 42.6895 46.2642C43.0872 46.2642 43.47 46.3305 43.8379 46.4631C44.2058 46.5956 44.524 46.8111 44.7924 47.1094C45.0609 47.4044 45.2482 47.7955 45.3542 48.2827C45.4603 48.7699 45.4537 49.3698 45.3343 50.0824L45.2548 50.5795H39.3684L39.5275 49.5653H44.2207C44.2969 49.1345 44.277 48.75 44.161 48.4119C44.0484 48.0739 43.8511 47.8071 43.5694 47.6115C43.291 47.416 42.938 47.3182 42.5105 47.3182C42.0697 47.3182 41.6587 47.4375 41.2775 47.6761C40.8964 47.9115 40.5782 48.2098 40.323 48.571C40.0678 48.929 39.9087 49.2936 39.8457 49.6648L39.7065 50.5398C39.6071 51.1728 39.622 51.6766 39.7512 52.0511C39.8838 52.4257 40.1142 52.6958 40.4423 52.8615C40.7704 53.0239 41.1814 53.1051 41.6752 53.1051C41.9901 53.1051 42.2801 53.062 42.5453 52.9759C42.8104 52.8864 43.0474 52.7538 43.2562 52.5781C43.465 52.3991 43.6407 52.1771 43.7832 51.9119L44.8571 52.2301C44.6748 52.6146 44.4179 52.9527 44.0865 53.2443C43.7583 53.5327 43.3739 53.758 42.9331 53.9205C42.4956 54.0795 42.0166 54.1591 41.4963 54.1591ZM49.3638 54.1591C48.7241 54.1591 48.1872 53.9983 47.753 53.6768C47.3188 53.352 47.0123 52.8946 46.8333 52.3047C46.6576 51.7114 46.6361 51.0104 46.7686 50.2017C46.9045 49.3996 47.1581 48.7036 47.5293 48.1136C47.9038 47.5237 48.3629 47.0679 48.9064 46.7464C49.45 46.425 50.0433 46.2642 50.6863 46.2642C51.1834 46.2642 51.5629 46.3471 51.8248 46.5128C52.0899 46.6752 52.2821 46.8608 52.4015 47.0696C52.5208 47.2751 52.6119 47.4441 52.6749 47.5767H52.7743L53.4007 43.8182H54.574L52.8837 54H51.7502L51.949 52.8267H51.8098C51.7005 52.9659 51.548 53.1416 51.3525 53.3537C51.1569 53.5625 50.8984 53.7498 50.5769 53.9155C50.2587 54.0779 49.8543 54.1591 49.3638 54.1591ZM49.6522 53.1051C50.1228 53.1051 50.5437 52.9825 50.915 52.7372C51.2895 52.4886 51.601 52.1456 51.8496 51.7081C52.0982 51.2673 52.2705 50.7585 52.3667 50.1818C52.4628 49.6117 52.4595 49.1129 52.3567 48.6854C52.254 48.2545 52.0568 47.9197 51.7651 47.6811C51.4734 47.4392 51.0873 47.3182 50.6067 47.3182C50.1129 47.3182 49.6837 47.4458 49.3191 47.701C48.9545 47.9529 48.6578 48.2959 48.4292 48.7301C48.2005 49.161 48.0414 49.6449 47.9519 50.1818C47.8624 50.7254 47.8607 51.2192 47.9469 51.6634C48.0331 52.1042 48.2154 52.4555 48.4938 52.7173C48.7755 52.9759 49.1616 53.1051 49.6522 53.1051Z" fill="#007AFF" fill-opacity="0.25"/>
<rect x="9" y="10" width="10" height="10" rx="3" fill="#007AFF" fill-opacity="0.25"/>
<rect x="9" y="27" width="10" height="10" rx="3" fill="#007AFF"/>
<rect x="9" y="44" width="10" height="10" rx="3" fill="#007AFF" fill-opacity="0.25"/>
</svg>
`, ixe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M28.1666 45.7042C28.9268 45.8901 29.611 45.5001 29.8329 44.7506L36.9814 20.6115C37.1728 19.9366 36.8385 19.2589 36.0783 19.0547C35.3333 18.8689 34.6979 19.1477 34.4425 20.0235L27.3365 44.0276C27.1175 44.7804 27.3579 45.5001 28.1666 45.7042Z" fill="black"/>
<path d="M12 32.3568C12 32.7499 12.1764 33.1396 12.5046 33.4216L22.0655 41.9466C22.6825 42.4776 23.4794 42.4744 23.9719 41.9287C24.4765 41.3647 24.3975 40.5639 23.829 40.0662L15.214 32.3568L23.829 24.6476C24.3975 24.1496 24.4765 23.3488 23.9719 22.7851C23.4794 22.2391 22.6825 22.2362 22.0655 22.7669L12.5046 31.2922C12.1764 31.5742 12 31.9639 12 32.3568ZM52.1638 32.3568C52.1638 31.9639 52.0027 31.5742 51.6742 31.2922L42.1015 22.7669C41.481 22.2362 40.6997 22.2391 40.1948 22.7851C39.6871 23.3488 39.7663 24.1496 40.3378 24.6476L48.968 32.3568L40.3378 40.0662C39.7663 40.5639 39.6871 41.3647 40.1948 41.9287C40.6997 42.4744 41.481 42.4776 42.1015 41.9466L51.6742 33.4216C52.0027 33.1396 52.1638 32.7499 52.1638 32.3568Z" fill="black"/>
</svg>
`, oxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 33H22V53C22 54.6569 20.6569 56 19 56H11C9.34315 56 8 54.6569 8 53V33Z" fill="#34C759"/>
<path d="M8 19C8 17.3431 9.34315 16 11 16H19C20.6569 16 22 17.3431 22 19V34H8V19Z" fill="#007AFF"/>
<path d="M25 39H39V53C39 54.6569 37.6569 56 36 56H28C26.3431 56 25 54.6569 25 53V39Z" fill="#34C759"/>
<path d="M42 32H56V53C56 54.6569 54.6569 56 53 56H45C43.3431 56 42 54.6569 42 53V32Z" fill="#34C759"/>
<path d="M25 29C25 27.3431 26.3431 26 28 26H36C37.6569 26 39 27.3431 39 29V40H25V29Z" fill="#3C82F6"/>
<path d="M42 16C42 14.3431 43.3431 13 45 13H53C54.6569 13 56 14.3431 56 16V33H42V16Z" fill="#007AFF"/>
</svg>
`, sxe = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="8" y="32" width="14" height="24" rx="3" fill="#007AFF"/>
<rect x="25" y="12" width="14" height="44" rx="3" fill="#007AFF"/>
<rect x="42" y="24" width="14" height="32" rx="3" fill="#007AFF"/>
</svg>
`, axe = {
  "chart-boxplot": Zbe,
  "chart-h-bar": txe,
  "chart-heatmap": rxe,
  "chart-embedding": exe,
  "chart-stacked": oxe,
  "chart-v-histogram": sxe,
  "chart-spec": ixe,
  "chart-predicates": nxe
};
var lxe = /* @__PURE__ */ me('<div class="w-12 h-12"><!></div>');
function uxe(t, e) {
  nt(e, !0);
  function r(o, s) {
    o = o.replace("xmlns", 'style="width:100%;height:100%" xmlns');
    let a = s == "dark" ? { black: Is.slate[400] } : { black: Is.slate[500] };
    for (let l in a)
      o = o.replaceAll(l, a[l]);
    return o;
  }
  var n = lxe(), i = Y(n);
  UX(i, () => r(axe[e.type] ?? "", e.colorScheme ?? "light")), J(n), Q(t, n), it();
}
var cxe = /* @__PURE__ */ me("<button><!></button>"), hxe = /* @__PURE__ */ me('<span class="text-slate-500 dark:text-slate-400"> </span> <!>', 1), fxe = /* @__PURE__ */ me('<div class="w-full h-64"><!></div>'), dxe = /* @__PURE__ */ me("<!> <!>", 1), pxe = /* @__PURE__ */ me('<div class="border-t border-b border-dotted border-slate-400 dark:border-slate-500 py-2 my-1"><div class="-m-2 rounded-md"><!></div></div>'), mxe = /* @__PURE__ */ me("<div> </div>"), gxe = /* @__PURE__ */ me('<div class="p-2 flex flex-col gap-2"><div class="flex flex-wrap gap-2"></div> <div> </div> <!> <!> <div><button>Confirm</button></div> <!></div>');
function vxe(t, e) {
  nt(e, !0);
  const r = () => gi(s, "$colorScheme", n), [n, i] = Jo();
  let { columns: o, colorScheme: s } = e.context, a = a_e(), l = /* @__PURE__ */ De(a[0]), u = /* @__PURE__ */ De(ps({})), c = /* @__PURE__ */ De(!1), h = /* @__PURE__ */ De(null), d = /* @__PURE__ */ De(null);
  dt(() => {
    x(l);
    let I = Ko(() => x(u)), B = {};
    for (let $ of x(l).ui)
      if ("field" in $) {
        let j = y(o, $.field.types), U = I[$.field.key];
        U != null && j.findIndex(({ name: H }) => H == U) >= 0 && (B[$.field.key] = U);
      }
    ae(u, B, !0);
  }), dt(() => {
    try {
      let I = g();
      if (I == null) {
        ae(c, !1), ae(d, null), ae(h, null);
        return;
      }
      let B = x(l).create(I, { table: e.context.table, id: e.context.id });
      ae(c, B != null), ae(d, B), ae(h, null);
    } catch (I) {
      ae(c, I.toString(), !0);
    }
  });
  function p() {
    x(d) != null && (e.onSpecChange(x(d), "replace"), e.onStateChange(x(h) ?? {}, "replace"));
  }
  function g() {
    let I = { ...x(u) };
    for (let B of x(l).ui)
      if ("field" in B) {
        let $ = v(I[B.field.key]);
        if (B.field.required && $ == null)
          return;
        I[B.field.key] = $;
      }
    return I;
  }
  function v(I) {
    let B = o.find(($) => $.name == I);
    if (B == null || B.jsType == null)
      return null;
    switch (B.jsType) {
      case "number":
        return { name: B.name, type: "continuous" };
      case "string":
        return { name: B.name, type: "discrete" };
      case "string[]":
        return { name: B.name, type: "discrete[]" };
      default:
        return null;
    }
  }
  function y(I, B) {
    return B == null ? I.filter(($) => $.jsType != null) : I.filter(($) => $.jsType != null && B.indexOf($.jsType) >= 0);
  }
  var b = gxe(), k = Y(b);
  It(k, 21, () => a, hr, (I, B) => {
    const $ = /* @__PURE__ */ K(() => x(l) == x(B));
    var j = cxe();
    j.__click = () => {
      ae(l, x(B));
    };
    let U;
    var H = Y(j);
    uxe(H, {
      get type() {
        return x(B).icon;
      },
      get colorScheme() {
        return r();
      }
    }), J(j), Ee(() => {
      te(j, "title", x(B).description), U = en(j, 1, "rounded-md border border-slate-200 dark:border-slate-700", null, U, {
        "!border-slate-600": x($),
        "dark:!border-slate-400": x($),
        "!bg-slate-100": x($),
        "dark:!bg-slate-700": x($)
      });
    }), Q(I, j);
  }), J(k);
  var C = le(k, 2), S = Y(C, !0);
  J(C);
  var _ = le(C, 2);
  It(_, 17, () => x(l).ui, hr, (I, B) => {
    var $ = dxe(), j = He($);
    {
      var U = (re) => {
        const ne = /* @__PURE__ */ K(() => x(B).field.key);
        var se = hxe(), ie = He(se), ce = Y(ie, !0);
        J(ie);
        var Ce = le(ie, 2);
        {
          let Me = /* @__PURE__ */ K(() => x(u)[x(ne)] ?? null), Pe = /* @__PURE__ */ K(() => y(o, x(B).field.types).map((Ae) => ({ value: Ae.name, label: `${Ae.name} (${Ae.type})` })));
          Oh(Ce, {
            get value() {
              return x(Me);
            },
            onChange: (Ae) => x(u)[x(ne)] = Ae,
            placeholder: "(select field)",
            class: "w-full",
            get options() {
              return x(Pe);
            }
          });
        }
        Ee(() => at(ce, x(B).field.label)), Q(re, se);
      };
      Fe(j, (re) => {
        "field" in x(B) && re(U);
      });
    }
    var H = le(j, 2);
    {
      var G = (re) => {
        const ne = /* @__PURE__ */ K(() => x(B).code.key);
        var se = fxe(), ie = Y(se);
        {
          let ce = /* @__PURE__ */ K(() => x(B).code.language ?? "plain");
          ES(ie, {
            class: "w-full h-full",
            get value() {
              return x(u)[x(ne)];
            },
            onChange: (Ce) => x(u)[x(ne)] = Ce,
            get colorScheme() {
              return r();
            },
            get language() {
              return x(ce);
            }
          });
        }
        J(se), Q(re, se);
      };
      Fe(H, (re) => {
        "code" in x(B) && re(G);
      });
    }
    Q(I, $);
  });
  var D = le(_, 2);
  {
    var A = (I) => {
      var B = kr(), $ = He(B);
      ST($, () => x(d), (j) => {
        var U = pxe(), H = Y(U), G = Y(H);
        {
          let re = /* @__PURE__ */ K(() => x(h) ?? {});
          uj(G, {
            get context() {
              return e.context;
            },
            get spec() {
              return x(d);
            },
            get state() {
              return x(re);
            },
            width: "container",
            onStateChange: (ne, se = "merge") => {
              md(x(h) ?? {}, ne, se, (ie) => ae(h, ie));
            },
            onSpecChange: (ne, se = "merge") => {
              md(x(d) ?? {}, ne, se, (ie) => ae(d, ie));
            }
          });
        }
        J(H), J(U), Q(j, U);
      }), Q(I, B);
    };
    Fe(D, (I) => {
      x(d) != null && x(l).preview !== !1 && I(A);
    });
  }
  var O = le(D, 2), M = Y(O);
  let z;
  M.__click = p, J(O);
  var N = le(O, 2);
  {
    var P = (I) => {
      var B = mxe(), $ = Y(B, !0);
      J(B), Ee(() => at($, x(c))), Q(I, B);
    };
    Fe(N, (I) => {
      typeof x(c) == "string" && x(c).trim() != "" && I(P);
    });
  }
  J(b), Ee(() => {
    at(S, x(l).description), z = en(M, 1, "px-2 h-8 w-24 rounded-md text-white text-sm", null, z, {
      "bg-blue-500": x(c) === !0,
      "bg-gray-300": x(c) !== !0,
      "dark:text-gray-500": x(c) !== !0,
      "dark:bg-gray-700": x(c) !== !0
    }), M.disabled = x(c) !== !0;
  }), Q(t, b), it(), i();
}
nn(["click"]);
var yxe = /* @__PURE__ */ St('<line class="stroke-orange-500"></line>'), bxe = /* @__PURE__ */ St('<circle class="fill-orange-500 stroke-orange-700 stroke-2"></circle>'), xxe = /* @__PURE__ */ St("<svg><g><!><!></g></svg>");
function wxe(t, e) {
  nt(e, !0);
  var r = xxe(), n = Y(r), i = Y(n);
  {
    var o = (a) => {
      const l = /* @__PURE__ */ K(() => e.proxy.location(e.center.x, e.center.y));
      var u = kr(), c = He(u);
      It(c, 17, () => e.points ?? [], hr, (h, d) => {
        const p = /* @__PURE__ */ K(() => e.proxy.location(x(d).x, x(d).y));
        var g = yxe();
        Ee(() => {
          te(g, "x1", x(l).x), te(g, "y1", x(l).y), te(g, "x2", x(p).x), te(g, "y2", x(p).y);
        }), Q(h, g);
      }), Q(a, u);
    };
    Fe(i, (a) => {
      e.center != null && a(o);
    });
  }
  var s = le(i);
  It(s, 17, () => e.points ?? [], hr, (a, l) => {
    const u = /* @__PURE__ */ K(() => e.proxy.location(x(l).x, x(l).y));
    var c = bxe();
    te(c, "r", 4), Ee(() => {
      te(c, "cx", x(u).x), te(c, "cy", x(u).y);
    }), Q(a, c);
  }), J(n), J(r), Ee(() => {
    te(r, "width", e.proxy.width), te(r, "height", e.proxy.height);
  }), Q(t, r), it();
}
function kxe(t) {
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
function Cxe(t) {
  const e = atob(t);
  return new Uint8Array([...e].map((r) => r.charCodeAt(0)));
}
function Cf(t, e) {
  if (t.length < e.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (t[r] != e[r])
      return !1;
  return !0;
}
function bO(t) {
  return Cf(t, [137, 80, 78, 71, 13, 10, 26, 10]) ? "image/png" : Cf(t, [255, 216, 255]) ? "image/jpeg" : Cf(t, [73, 73, 42, 0]) ? "image/tiff" : Cf(t, [66, 77]) ? "image/bmp" : Cf(t, [71, 73, 70, 56, 55, 97]) || Cf(t, [71, 73, 70, 56, 55, 97]) ? "image/gif" : "application/octet-stream";
}
function PL(t) {
  if (t == null)
    return null;
  if (typeof t == "string")
    return t.startsWith("data:") ? t : `data:${bO(Cxe(t))};base64,` + t;
  {
    let e = null;
    if (t.bytes && t.bytes instanceof Uint8Array && (e = t.bytes), t instanceof Uint8Array && (e = t), e != null)
      return `data:${bO(e)};base64,` + kxe(e);
  }
  return null;
}
class _xe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    if (e.value == null) {
      this.element.innerText = "(null)";
      return;
    }
    let r = PL(e.value);
    if (r != null) {
      let n = e.size ?? 100, i = document.createElement("img");
      i.src = r, i.style.maxHeight = n + "px", i.style.maxWidth = n + "px", this.element.replaceChildren(i);
    } else
      this.element.innerText = "(unknown)";
  }
}
function RL(t, e) {
  try {
    return JSON.stringify(
      t,
      (r, n) => n instanceof Object && ArrayBuffer.isView(n) ? Array.from(n) : n,
      e
    );
  } catch {
    return "(invalid)";
  }
}
class Sxe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    let r = document.createElement("pre");
    r.className = "text-sm", r.style.whiteSpace = "pre-wrap", r.style.wordBreak = "break-all", r.innerText = RL(e.value, 2), this.element.replaceChildren(r);
  }
}
function YS() {
  return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
}
var Jh = YS();
function NL(t) {
  Jh = t;
}
var qm = { exec: () => null };
function lr(t, e = "") {
  let r = typeof t == "string" ? t : t.source, n = { replace: (i, o) => {
    let s = typeof o == "string" ? o : o.source;
    return s = s.replace(Ni.caret, "$1"), r = r.replace(i, s), n;
  }, getRegex: () => new RegExp(r, e) };
  return n;
}
var Axe = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return !1;
  }
})(), Ni = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`), htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i") }, Exe = /^(?:[ \t]*(?:\n|$))+/, Dxe = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Oxe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, k0 = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Fxe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, ZS = /(?:[*+-]|\d{1,9}[.)])/, $L = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, IL = lr($L).replace(/bull/g, ZS).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Txe = lr($L).replace(/bull/g, ZS).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), e5 = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Mxe = /^[^\n]+/, t5 = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, Pxe = lr(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", t5).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Rxe = lr(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, ZS).getRegex(), Px = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", r5 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Nxe = lr("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", r5).replace("tag", Px).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), BL = lr(e5).replace("hr", k0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Px).getRegex(), $xe = lr(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", BL).getRegex(), n5 = { blockquote: $xe, code: Dxe, def: Pxe, fences: Oxe, heading: Fxe, hr: k0, html: Nxe, lheading: IL, list: Rxe, newline: Exe, paragraph: BL, table: qm, text: Mxe }, xO = lr("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", k0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Px).getRegex(), Ixe = { ...n5, lheading: Txe, table: xO, paragraph: lr(e5).replace("hr", k0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", xO).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Px).getRegex() }, Bxe = { ...n5, html: lr(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", r5).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: qm, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: lr(e5).replace("hr", k0).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", IL).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Lxe = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, zxe = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, LL = /^( {2,}|\\)\n(?!\s*$)/, jxe = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, Rx = /[\p{P}\p{S}]/u, i5 = /[\s\p{P}\p{S}]/u, zL = /[^\s\p{P}\p{S}]/u, qxe = lr(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, i5).getRegex(), jL = /(?!~)[\p{P}\p{S}]/u, Uxe = /(?!~)[\s\p{P}\p{S}]/u, Hxe = /(?:[^\s\p{P}\p{S}]|~)/u, Vxe = lr(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", Axe ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), qL = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, Wxe = lr(qL, "u").replace(/punct/g, Rx).getRegex(), Gxe = lr(qL, "u").replace(/punct/g, jL).getRegex(), UL = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Kxe = lr(UL, "gu").replace(/notPunctSpace/g, zL).replace(/punctSpace/g, i5).replace(/punct/g, Rx).getRegex(), Xxe = lr(UL, "gu").replace(/notPunctSpace/g, Hxe).replace(/punctSpace/g, Uxe).replace(/punct/g, jL).getRegex(), Qxe = lr("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, zL).replace(/punctSpace/g, i5).replace(/punct/g, Rx).getRegex(), Jxe = lr(/\\(punct)/, "gu").replace(/punct/g, Rx).getRegex(), Yxe = lr(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Zxe = lr(r5).replace("(?:-->|$)", "-->").getRegex(), ewe = lr("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Zxe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), db = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, twe = lr(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", db).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), HL = lr(/^!?\[(label)\]\[(ref)\]/).replace("label", db).replace("ref", t5).getRegex(), VL = lr(/^!?\[(ref)\](?:\[\])?/).replace("ref", t5).getRegex(), rwe = lr("reflink|nolink(?!\\()", "g").replace("reflink", HL).replace("nolink", VL).getRegex(), wO = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, o5 = { _backpedal: qm, anyPunctuation: Jxe, autolink: Yxe, blockSkip: Vxe, br: LL, code: zxe, del: qm, emStrongLDelim: Wxe, emStrongRDelimAst: Kxe, emStrongRDelimUnd: Qxe, escape: Lxe, link: twe, nolink: VL, punctuation: qxe, reflink: HL, reflinkSearch: rwe, tag: ewe, text: jxe, url: qm }, nwe = { ...o5, link: lr(/^!?\[(label)\]\((.*?)\)/).replace("label", db).getRegex(), reflink: lr(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", db).getRegex() }, d_ = { ...o5, emStrongRDelimAst: Xxe, emStrongLDelim: Gxe, url: lr(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", wO).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: lr(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", wO).getRegex() }, iwe = { ...d_, br: lr(LL).replace("{2,}", "*").getRegex(), text: lr(d_.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, wy = { normal: n5, gfm: Ixe, pedantic: Bxe }, lm = { normal: o5, gfm: d_, breaks: iwe, pedantic: nwe }, owe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, kO = (t) => owe[t];
function xa(t, e) {
  if (e) {
    if (Ni.escapeTest.test(t)) return t.replace(Ni.escapeReplace, kO);
  } else if (Ni.escapeTestNoEncode.test(t)) return t.replace(Ni.escapeReplaceNoEncode, kO);
  return t;
}
function CO(t) {
  try {
    t = encodeURI(t).replace(Ni.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function _O(t, e) {
  let r = t.replace(Ni.findPipe, (o, s, a) => {
    let l = !1, u = s;
    for (; --u >= 0 && a[u] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), n = r.split(Ni.splitPipe), i = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; i < n.length; i++) n[i] = n[i].trim().replace(Ni.slashPipe, "|");
  return n;
}
function um(t, e, r) {
  let n = t.length;
  if (n === 0) return "";
  let i = 0;
  for (; i < n && t.charAt(n - i - 1) === e; )
    i++;
  return t.slice(0, n - i);
}
function swe(t, e) {
  if (t.indexOf(e[1]) === -1) return -1;
  let r = 0;
  for (let n = 0; n < t.length; n++) if (t[n] === "\\") n++;
  else if (t[n] === e[0]) r++;
  else if (t[n] === e[1] && (r--, r < 0)) return n;
  return r > 0 ? -2 : -1;
}
function SO(t, e, r, n, i) {
  let o = e.href, s = e.title || null, a = t[1].replace(i.other.outputLinkReplace, "$1");
  n.state.inLink = !0;
  let l = { type: t[0].charAt(0) === "!" ? "image" : "link", raw: r, href: o, title: s, text: a, tokens: n.inlineTokens(a) };
  return n.state.inLink = !1, l;
}
function awe(t, e, r) {
  let n = t.match(r.other.indentCodeCompensation);
  if (n === null) return e;
  let i = n[1];
  return e.split(`
`).map((o) => {
    let s = o.match(r.other.beginningSpace);
    if (s === null) return o;
    let [a] = s;
    return a.length >= i.length ? o.slice(i.length) : o;
  }).join(`
`);
}
var pb = class {
  options;
  rules;
  lexer;
  constructor(t) {
    this.options = t || Jh;
  }
  space(t) {
    let e = this.rules.block.newline.exec(t);
    if (e && e[0].length > 0) return { type: "space", raw: e[0] };
  }
  code(t) {
    let e = this.rules.block.code.exec(t);
    if (e) {
      let r = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: e[0], codeBlockStyle: "indented", text: this.options.pedantic ? r : um(r, `
`) };
    }
  }
  fences(t) {
    let e = this.rules.block.fences.exec(t);
    if (e) {
      let r = e[0], n = awe(r, e[3] || "", this.rules);
      return { type: "code", raw: r, lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2], text: n };
    }
  }
  heading(t) {
    let e = this.rules.block.heading.exec(t);
    if (e) {
      let r = e[2].trim();
      if (this.rules.other.endingHash.test(r)) {
        let n = um(r, "#");
        (this.options.pedantic || !n || this.rules.other.endingSpaceChar.test(n)) && (r = n.trim());
      }
      return { type: "heading", raw: e[0], depth: e[1].length, text: r, tokens: this.lexer.inline(r) };
    }
  }
  hr(t) {
    let e = this.rules.block.hr.exec(t);
    if (e) return { type: "hr", raw: um(e[0], `
`) };
  }
  blockquote(t) {
    let e = this.rules.block.blockquote.exec(t);
    if (e) {
      let r = um(e[0], `
`).split(`
`), n = "", i = "", o = [];
      for (; r.length > 0; ) {
        let s = !1, a = [], l;
        for (l = 0; l < r.length; l++) if (this.rules.other.blockquoteStart.test(r[l])) a.push(r[l]), s = !0;
        else if (!s) a.push(r[l]);
        else break;
        r = r.slice(l);
        let u = a.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        n = n ? `${n}
${u}` : u, i = i ? `${i}
${c}` : c;
        let h = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(c, o, !0), this.lexer.state.top = h, r.length === 0) break;
        let d = o.at(-1);
        if (d?.type === "code") break;
        if (d?.type === "blockquote") {
          let p = d, g = p.raw + `
` + r.join(`
`), v = this.blockquote(g);
          o[o.length - 1] = v, n = n.substring(0, n.length - p.raw.length) + v.raw, i = i.substring(0, i.length - p.text.length) + v.text;
          break;
        } else if (d?.type === "list") {
          let p = d, g = p.raw + `
` + r.join(`
`), v = this.list(g);
          o[o.length - 1] = v, n = n.substring(0, n.length - d.raw.length) + v.raw, i = i.substring(0, i.length - p.raw.length) + v.raw, r = g.substring(o.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: n, tokens: o, text: i };
    }
  }
  list(t) {
    let e = this.rules.block.list.exec(t);
    if (e) {
      let r = e[1].trim(), n = r.length > 1, i = { type: "list", raw: "", ordered: n, start: n ? +r.slice(0, -1) : "", loose: !1, items: [] };
      r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = n ? r : "[*+-]");
      let o = this.rules.other.listItemRegex(r), s = !1;
      for (; t; ) {
        let l = !1, u = "", c = "";
        if (!(e = o.exec(t)) || this.rules.block.hr.test(t)) break;
        u = e[0], t = t.substring(u.length);
        let h = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (b) => " ".repeat(3 * b.length)), d = t.split(`
`, 1)[0], p = !h.trim(), g = 0;
        if (this.options.pedantic ? (g = 2, c = h.trimStart()) : p ? g = e[1].length + 1 : (g = e[2].search(this.rules.other.nonSpaceChar), g = g > 4 ? 1 : g, c = h.slice(g), g += e[1].length), p && this.rules.other.blankLine.test(d) && (u += d + `
`, t = t.substring(d.length + 1), l = !0), !l) {
          let b = this.rules.other.nextBulletRegex(g), k = this.rules.other.hrRegex(g), C = this.rules.other.fencesBeginRegex(g), S = this.rules.other.headingBeginRegex(g), _ = this.rules.other.htmlBeginRegex(g);
          for (; t; ) {
            let D = t.split(`
`, 1)[0], A;
            if (d = D, this.options.pedantic ? (d = d.replace(this.rules.other.listReplaceNesting, "  "), A = d) : A = d.replace(this.rules.other.tabCharGlobal, "    "), C.test(d) || S.test(d) || _.test(d) || b.test(d) || k.test(d)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= g || !d.trim()) c += `
` + A.slice(g);
            else {
              if (p || h.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || C.test(h) || S.test(h) || k.test(h)) break;
              c += `
` + d;
            }
            !p && !d.trim() && (p = !0), u += D + `
`, t = t.substring(D.length + 1), h = A.slice(g);
          }
        }
        i.loose || (s ? i.loose = !0 : this.rules.other.doubleBlankLine.test(u) && (s = !0));
        let v = null, y;
        this.options.gfm && (v = this.rules.other.listIsTask.exec(c), v && (y = v[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: u, task: !!v, checked: y, loose: !1, text: c, tokens: [] }), i.raw += u;
      }
      let a = i.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let l = 0; l < i.items.length; l++) if (this.lexer.state.top = !1, i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, []), !i.loose) {
        let u = i.items[l].tokens.filter((h) => h.type === "space"), c = u.length > 0 && u.some((h) => this.rules.other.anyLine.test(h.raw));
        i.loose = c;
      }
      if (i.loose) for (let l = 0; l < i.items.length; l++) i.items[l].loose = !0;
      return i;
    }
  }
  html(t) {
    let e = this.rules.block.html.exec(t);
    if (e) return { type: "html", block: !0, raw: e[0], pre: e[1] === "pre" || e[1] === "script" || e[1] === "style", text: e[0] };
  }
  def(t) {
    let e = this.rules.block.def.exec(t);
    if (e) {
      let r = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), n = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return { type: "def", tag: r, raw: e[0], href: n, title: i };
    }
  }
  table(t) {
    let e = this.rules.block.table.exec(t);
    if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
    let r = _O(e[1]), n = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = e[3]?.trim() ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], o = { type: "table", raw: e[0], header: [], align: [], rows: [] };
    if (r.length === n.length) {
      for (let s of n) this.rules.other.tableAlignRight.test(s) ? o.align.push("right") : this.rules.other.tableAlignCenter.test(s) ? o.align.push("center") : this.rules.other.tableAlignLeft.test(s) ? o.align.push("left") : o.align.push(null);
      for (let s = 0; s < r.length; s++) o.header.push({ text: r[s], tokens: this.lexer.inline(r[s]), header: !0, align: o.align[s] });
      for (let s of i) o.rows.push(_O(s, o.header.length).map((a, l) => ({ text: a, tokens: this.lexer.inline(a), header: !1, align: o.align[l] })));
      return o;
    }
  }
  lheading(t) {
    let e = this.rules.block.lheading.exec(t);
    if (e) return { type: "heading", raw: e[0], depth: e[2].charAt(0) === "=" ? 1 : 2, text: e[1], tokens: this.lexer.inline(e[1]) };
  }
  paragraph(t) {
    let e = this.rules.block.paragraph.exec(t);
    if (e) {
      let r = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return { type: "paragraph", raw: e[0], text: r, tokens: this.lexer.inline(r) };
    }
  }
  text(t) {
    let e = this.rules.block.text.exec(t);
    if (e) return { type: "text", raw: e[0], text: e[0], tokens: this.lexer.inline(e[0]) };
  }
  escape(t) {
    let e = this.rules.inline.escape.exec(t);
    if (e) return { type: "escape", raw: e[0], text: e[1] };
  }
  tag(t) {
    let e = this.rules.inline.tag.exec(t);
    if (e) return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: e[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: e[0] };
  }
  link(t) {
    let e = this.rules.inline.link.exec(t);
    if (e) {
      let r = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
        if (!this.rules.other.endAngleBracket.test(r)) return;
        let o = um(r.slice(0, -1), "\\");
        if ((r.length - o.length) % 2 === 0) return;
      } else {
        let o = swe(e[2], "()");
        if (o === -2) return;
        if (o > -1) {
          let s = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + o;
          e[2] = e[2].substring(0, o), e[0] = e[0].substring(0, s).trim(), e[3] = "";
        }
      }
      let n = e[2], i = "";
      if (this.options.pedantic) {
        let o = this.rules.other.pedanticHrefTitle.exec(n);
        o && (n = o[1], i = o[3]);
      } else i = e[3] ? e[3].slice(1, -1) : "";
      return n = n.trim(), this.rules.other.startAngleBracket.test(n) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? n = n.slice(1) : n = n.slice(1, -1)), SO(e, { href: n && n.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, e[0], this.lexer, this.rules);
    }
  }
  reflink(t, e) {
    let r;
    if ((r = this.rules.inline.reflink.exec(t)) || (r = this.rules.inline.nolink.exec(t))) {
      let n = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = e[n.toLowerCase()];
      if (!i) {
        let o = r[0].charAt(0);
        return { type: "text", raw: o, text: o };
      }
      return SO(r, i, r[0], this.lexer, this.rules);
    }
  }
  emStrong(t, e, r = "") {
    let n = this.rules.inline.emStrongLDelim.exec(t);
    if (!(!n || n[3] && r.match(this.rules.other.unicodeAlphaNumeric)) && (!(n[1] || n[2]) || !r || this.rules.inline.punctuation.exec(r))) {
      let i = [...n[0]].length - 1, o, s, a = i, l = 0, u = n[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (u.lastIndex = 0, e = e.slice(-1 * t.length + i); (n = u.exec(e)) != null; ) {
        if (o = n[1] || n[2] || n[3] || n[4] || n[5] || n[6], !o) continue;
        if (s = [...o].length, n[3] || n[4]) {
          a += s;
          continue;
        } else if ((n[5] || n[6]) && i % 3 && !((i + s) % 3)) {
          l += s;
          continue;
        }
        if (a -= s, a > 0) continue;
        s = Math.min(s, s + a + l);
        let c = [...n[0]][0].length, h = t.slice(0, i + n.index + c + s);
        if (Math.min(i, s) % 2) {
          let p = h.slice(1, -1);
          return { type: "em", raw: h, text: p, tokens: this.lexer.inlineTokens(p) };
        }
        let d = h.slice(2, -2);
        return { type: "strong", raw: h, text: d, tokens: this.lexer.inlineTokens(d) };
      }
    }
  }
  codespan(t) {
    let e = this.rules.inline.code.exec(t);
    if (e) {
      let r = e[2].replace(this.rules.other.newLineCharGlobal, " "), n = this.rules.other.nonSpaceChar.test(r), i = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r);
      return n && i && (r = r.substring(1, r.length - 1)), { type: "codespan", raw: e[0], text: r };
    }
  }
  br(t) {
    let e = this.rules.inline.br.exec(t);
    if (e) return { type: "br", raw: e[0] };
  }
  del(t) {
    let e = this.rules.inline.del.exec(t);
    if (e) return { type: "del", raw: e[0], text: e[2], tokens: this.lexer.inlineTokens(e[2]) };
  }
  autolink(t) {
    let e = this.rules.inline.autolink.exec(t);
    if (e) {
      let r, n;
      return e[2] === "@" ? (r = e[1], n = "mailto:" + r) : (r = e[1], n = r), { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  url(t) {
    let e;
    if (e = this.rules.inline.url.exec(t)) {
      let r, n;
      if (e[2] === "@") r = e[0], n = "mailto:" + r;
      else {
        let i;
        do
          i = e[0], e[0] = this.rules.inline._backpedal.exec(e[0])?.[0] ?? "";
        while (i !== e[0]);
        r = e[0], e[1] === "www." ? n = "http://" + e[0] : n = e[0];
      }
      return { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  inlineText(t) {
    let e = this.rules.inline.text.exec(t);
    if (e) {
      let r = this.lexer.state.inRawBlock;
      return { type: "text", raw: e[0], text: e[0], escaped: r };
    }
  }
}, zs = class p_ {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Jh, this.options.tokenizer = this.options.tokenizer || new pb(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    let r = { other: Ni, block: wy.normal, inline: lm.normal };
    this.options.pedantic ? (r.block = wy.pedantic, r.inline = lm.pedantic) : this.options.gfm && (r.block = wy.gfm, this.options.breaks ? r.inline = lm.breaks : r.inline = lm.gfm), this.tokenizer.rules = r;
  }
  static get rules() {
    return { block: wy, inline: lm };
  }
  static lex(e, r) {
    return new p_(r).lex(e);
  }
  static lexInline(e, r) {
    return new p_(r).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Ni.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      let n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = !1) {
    for (this.options.pedantic && (e = e.replace(Ni.tabCharGlobal, "    ").replace(Ni.spaceLine, "")); e; ) {
      let i;
      if (this.options.extensions?.block?.some((s) => (i = s.call({ lexer: this }, e, r)) ? (e = e.substring(i.raw.length), r.push(i), !0) : !1)) continue;
      if (i = this.tokenizer.space(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        i.raw.length === 1 && s !== void 0 ? s.raw += `
` : r.push(i);
        continue;
      }
      if (i = this.tokenizer.code(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (i = this.tokenizer.fences(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.heading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.hr(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.blockquote(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.list(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.html(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.def(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title }, r.push(i));
        continue;
      }
      if (i = this.tokenizer.table(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.lheading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      let o = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, a = e.slice(1), l;
        this.options.extensions.startBlock.forEach((u) => {
          l = u.call({ lexer: this }, a), typeof l == "number" && l >= 0 && (s = Math.min(s, l));
        }), s < 1 / 0 && s >= 0 && (o = e.substring(0, s + 1));
      }
      if (this.state.top && (i = this.tokenizer.paragraph(o))) {
        let s = r.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i), n = o.length !== e.length, e = e.substring(i.raw.length);
        continue;
      }
      if (i = this.tokenizer.text(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = !0, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  inlineTokens(e, r = []) {
    let n = e, i = null;
    if (this.tokens.links) {
      let l = Object.keys(this.tokens.links);
      if (l.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) l.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, i.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let o;
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) o = i[2] ? i[2].length : 0, n = n.slice(0, i.index + o) + "[" + "a".repeat(i[0].length - o - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let s = !1, a = "";
    for (; e; ) {
      s || (a = ""), s = !1;
      let l;
      if (this.options.extensions?.inline?.some((c) => (l = c.call({ lexer: this }, e, r)) ? (e = e.substring(l.raw.length), r.push(l), !0) : !1)) continue;
      if (l = this.tokenizer.escape(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.tag(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.link(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(l.raw.length);
        let c = r.at(-1);
        l.type === "text" && c?.type === "text" ? (c.raw += l.raw, c.text += l.text) : r.push(l);
        continue;
      }
      if (l = this.tokenizer.emStrong(e, n, a)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.codespan(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.br(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.del(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.autolink(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (!this.state.inLink && (l = this.tokenizer.url(e))) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      let u = e;
      if (this.options.extensions?.startInline) {
        let c = 1 / 0, h = e.slice(1), d;
        this.options.extensions.startInline.forEach((p) => {
          d = p.call({ lexer: this }, h), typeof d == "number" && d >= 0 && (c = Math.min(c, d));
        }), c < 1 / 0 && c >= 0 && (u = e.substring(0, c + 1));
      }
      if (l = this.tokenizer.inlineText(u)) {
        e = e.substring(l.raw.length), l.raw.slice(-1) !== "_" && (a = l.raw.slice(-1)), s = !0;
        let c = r.at(-1);
        c?.type === "text" ? (c.raw += l.raw, c.text += l.text) : r.push(l);
        continue;
      }
      if (e) {
        let c = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(c);
          break;
        } else throw new Error(c);
      }
    }
    return r;
  }
}, mb = class {
  options;
  parser;
  constructor(t) {
    this.options = t || Jh;
  }
  space(t) {
    return "";
  }
  code({ text: t, lang: e, escaped: r }) {
    let n = (e || "").match(Ni.notSpaceStart)?.[0], i = t.replace(Ni.endingNewline, "") + `
`;
    return n ? '<pre><code class="language-' + xa(n) + '">' + (r ? i : xa(i, !0)) + `</code></pre>
` : "<pre><code>" + (r ? i : xa(i, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: t }) {
    return `<blockquote>
${this.parser.parse(t)}</blockquote>
`;
  }
  html({ text: t }) {
    return t;
  }
  def(t) {
    return "";
  }
  heading({ tokens: t, depth: e }) {
    return `<h${e}>${this.parser.parseInline(t)}</h${e}>
`;
  }
  hr(t) {
    return `<hr>
`;
  }
  list(t) {
    let e = t.ordered, r = t.start, n = "";
    for (let s = 0; s < t.items.length; s++) {
      let a = t.items[s];
      n += this.listitem(a);
    }
    let i = e ? "ol" : "ul", o = e && r !== 1 ? ' start="' + r + '"' : "";
    return "<" + i + o + `>
` + n + "</" + i + `>
`;
  }
  listitem(t) {
    let e = "";
    if (t.task) {
      let r = this.checkbox({ checked: !!t.checked });
      t.loose ? t.tokens[0]?.type === "paragraph" ? (t.tokens[0].text = r + " " + t.tokens[0].text, t.tokens[0].tokens && t.tokens[0].tokens.length > 0 && t.tokens[0].tokens[0].type === "text" && (t.tokens[0].tokens[0].text = r + " " + xa(t.tokens[0].tokens[0].text), t.tokens[0].tokens[0].escaped = !0)) : t.tokens.unshift({ type: "text", raw: r + " ", text: r + " ", escaped: !0 }) : e += r + " ";
    }
    return e += this.parser.parse(t.tokens, !!t.loose), `<li>${e}</li>
`;
  }
  checkbox({ checked: t }) {
    return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: t }) {
    return `<p>${this.parser.parseInline(t)}</p>
`;
  }
  table(t) {
    let e = "", r = "";
    for (let i = 0; i < t.header.length; i++) r += this.tablecell(t.header[i]);
    e += this.tablerow({ text: r });
    let n = "";
    for (let i = 0; i < t.rows.length; i++) {
      let o = t.rows[i];
      r = "";
      for (let s = 0; s < o.length; s++) r += this.tablecell(o[s]);
      n += this.tablerow({ text: r });
    }
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + n + `</table>
`;
  }
  tablerow({ text: t }) {
    return `<tr>
${t}</tr>
`;
  }
  tablecell(t) {
    let e = this.parser.parseInline(t.tokens), r = t.header ? "th" : "td";
    return (t.align ? `<${r} align="${t.align}">` : `<${r}>`) + e + `</${r}>
`;
  }
  strong({ tokens: t }) {
    return `<strong>${this.parser.parseInline(t)}</strong>`;
  }
  em({ tokens: t }) {
    return `<em>${this.parser.parseInline(t)}</em>`;
  }
  codespan({ text: t }) {
    return `<code>${xa(t, !0)}</code>`;
  }
  br(t) {
    return "<br>";
  }
  del({ tokens: t }) {
    return `<del>${this.parser.parseInline(t)}</del>`;
  }
  link({ href: t, title: e, tokens: r }) {
    let n = this.parser.parseInline(r), i = CO(t);
    if (i === null) return n;
    t = i;
    let o = '<a href="' + t + '"';
    return e && (o += ' title="' + xa(e) + '"'), o += ">" + n + "</a>", o;
  }
  image({ href: t, title: e, text: r, tokens: n }) {
    n && (r = this.parser.parseInline(n, this.parser.textRenderer));
    let i = CO(t);
    if (i === null) return xa(r);
    t = i;
    let o = `<img src="${t}" alt="${r}"`;
    return e && (o += ` title="${xa(e)}"`), o += ">", o;
  }
  text(t) {
    return "tokens" in t && t.tokens ? this.parser.parseInline(t.tokens) : "escaped" in t && t.escaped ? t.text : xa(t.text);
  }
}, s5 = class {
  strong({ text: t }) {
    return t;
  }
  em({ text: t }) {
    return t;
  }
  codespan({ text: t }) {
    return t;
  }
  del({ text: t }) {
    return t;
  }
  html({ text: t }) {
    return t;
  }
  text({ text: t }) {
    return t;
  }
  link({ text: t }) {
    return "" + t;
  }
  image({ text: t }) {
    return "" + t;
  }
  br() {
    return "";
  }
}, js = class m_ {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || Jh, this.options.renderer = this.options.renderer || new mb(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new s5();
  }
  static parse(e, r) {
    return new m_(r).parse(e);
  }
  static parseInline(e, r) {
    return new m_(r).parseInline(e);
  }
  parse(e, r = !0) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.options.extensions?.renderers?.[o.type]) {
        let a = o, l = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (l !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(a.type)) {
          n += l || "";
          continue;
        }
      }
      let s = o;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let a = s, l = this.renderer.text(a);
          for (; i + 1 < e.length && e[i + 1].type === "text"; ) a = e[++i], l += `
` + this.renderer.text(a);
          r ? n += this.renderer.paragraph({ type: "paragraph", raw: l, text: l, tokens: [{ type: "text", raw: l, text: l, escaped: !0 }] }) : n += l;
          continue;
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
  parseInline(e, r = this.renderer) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.options.extensions?.renderers?.[o.type]) {
        let a = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (a !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type)) {
          n += a || "";
          continue;
        }
      }
      let s = o;
      switch (s.type) {
        case "escape": {
          n += r.text(s);
          break;
        }
        case "html": {
          n += r.html(s);
          break;
        }
        case "link": {
          n += r.link(s);
          break;
        }
        case "image": {
          n += r.image(s);
          break;
        }
        case "strong": {
          n += r.strong(s);
          break;
        }
        case "em": {
          n += r.em(s);
          break;
        }
        case "codespan": {
          n += r.codespan(s);
          break;
        }
        case "br": {
          n += r.br(s);
          break;
        }
        case "del": {
          n += r.del(s);
          break;
        }
        case "text": {
          n += r.text(s);
          break;
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
}, Cm = class {
  options;
  block;
  constructor(t) {
    this.options = t || Jh;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(t) {
    return t;
  }
  postprocess(t) {
    return t;
  }
  processAllTokens(t) {
    return t;
  }
  emStrongMask(t) {
    return t;
  }
  provideLexer() {
    return this.block ? zs.lex : zs.lexInline;
  }
  provideParser() {
    return this.block ? js.parse : js.parseInline;
  }
}, lwe = class {
  defaults = YS();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = js;
  Renderer = mb;
  TextRenderer = s5;
  Lexer = zs;
  Tokenizer = pb;
  Hooks = Cm;
  constructor(...t) {
    this.use(...t);
  }
  walkTokens(t, e) {
    let r = [];
    for (let n of t) switch (r = r.concat(e.call(this, n)), n.type) {
      case "table": {
        let i = n;
        for (let o of i.header) r = r.concat(this.walkTokens(o.tokens, e));
        for (let o of i.rows) for (let s of o) r = r.concat(this.walkTokens(s.tokens, e));
        break;
      }
      case "list": {
        let i = n;
        r = r.concat(this.walkTokens(i.items, e));
        break;
      }
      default: {
        let i = n;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((o) => {
          let s = i[o].flat(1 / 0);
          r = r.concat(this.walkTokens(s, e));
        }) : i.tokens && (r = r.concat(this.walkTokens(i.tokens, e)));
      }
    }
    return r;
  }
  use(...t) {
    let e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t.forEach((r) => {
      let n = { ...r };
      if (n.async = this.defaults.async || n.async || !1, r.extensions && (r.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let o = e.renderers[i.name];
          o ? e.renderers[i.name] = function(...s) {
            let a = i.renderer.apply(this, s);
            return a === !1 && (a = o.apply(this, s)), a;
          } : e.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let o = e[i.level];
          o ? o.unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (e.childTokens[i.name] = i.childTokens);
      }), n.extensions = e), r.renderer) {
        let i = this.defaults.renderer || new mb(this.defaults);
        for (let o in r.renderer) {
          if (!(o in i)) throw new Error(`renderer '${o}' does not exist`);
          if (["options", "parser"].includes(o)) continue;
          let s = o, a = r.renderer[s], l = i[s];
          i[s] = (...u) => {
            let c = a.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c || "";
          };
        }
        n.renderer = i;
      }
      if (r.tokenizer) {
        let i = this.defaults.tokenizer || new pb(this.defaults);
        for (let o in r.tokenizer) {
          if (!(o in i)) throw new Error(`tokenizer '${o}' does not exist`);
          if (["options", "rules", "lexer"].includes(o)) continue;
          let s = o, a = r.tokenizer[s], l = i[s];
          i[s] = (...u) => {
            let c = a.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c;
          };
        }
        n.tokenizer = i;
      }
      if (r.hooks) {
        let i = this.defaults.hooks || new Cm();
        for (let o in r.hooks) {
          if (!(o in i)) throw new Error(`hook '${o}' does not exist`);
          if (["options", "block"].includes(o)) continue;
          let s = o, a = r.hooks[s], l = i[s];
          Cm.passThroughHooks.has(o) ? i[s] = (u) => {
            if (this.defaults.async && Cm.passThroughHooksRespectAsync.has(o)) return (async () => {
              let h = await a.call(i, u);
              return l.call(i, h);
            })();
            let c = a.call(i, u);
            return l.call(i, c);
          } : i[s] = (...u) => {
            if (this.defaults.async) return (async () => {
              let h = await a.apply(i, u);
              return h === !1 && (h = await l.apply(i, u)), h;
            })();
            let c = a.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c;
          };
        }
        n.hooks = i;
      }
      if (r.walkTokens) {
        let i = this.defaults.walkTokens, o = r.walkTokens;
        n.walkTokens = function(s) {
          let a = [];
          return a.push(o.call(this, s)), i && (a = a.concat(i.call(this, s))), a;
        };
      }
      this.defaults = { ...this.defaults, ...n };
    }), this;
  }
  setOptions(t) {
    return this.defaults = { ...this.defaults, ...t }, this;
  }
  lexer(t, e) {
    return zs.lex(t, e ?? this.defaults);
  }
  parser(t, e) {
    return js.parse(t, e ?? this.defaults);
  }
  parseMarkdown(t) {
    return (e, r) => {
      let n = { ...r }, i = { ...this.defaults, ...n }, o = this.onError(!!i.silent, !!i.async);
      if (this.defaults.async === !0 && n.async === !1) return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof e > "u" || e === null) return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof e != "string") return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"));
      if (i.hooks && (i.hooks.options = i, i.hooks.block = t), i.async) return (async () => {
        let s = i.hooks ? await i.hooks.preprocess(e) : e, a = await (i.hooks ? await i.hooks.provideLexer() : t ? zs.lex : zs.lexInline)(s, i), l = i.hooks ? await i.hooks.processAllTokens(a) : a;
        i.walkTokens && await Promise.all(this.walkTokens(l, i.walkTokens));
        let u = await (i.hooks ? await i.hooks.provideParser() : t ? js.parse : js.parseInline)(l, i);
        return i.hooks ? await i.hooks.postprocess(u) : u;
      })().catch(o);
      try {
        i.hooks && (e = i.hooks.preprocess(e));
        let s = (i.hooks ? i.hooks.provideLexer() : t ? zs.lex : zs.lexInline)(e, i);
        i.hooks && (s = i.hooks.processAllTokens(s)), i.walkTokens && this.walkTokens(s, i.walkTokens);
        let a = (i.hooks ? i.hooks.provideParser() : t ? js.parse : js.parseInline)(s, i);
        return i.hooks && (a = i.hooks.postprocess(a)), a;
      } catch (s) {
        return o(s);
      }
    };
  }
  onError(t, e) {
    return (r) => {
      if (r.message += `
Please report this to https://github.com/markedjs/marked.`, t) {
        let n = "<p>An error occurred:</p><pre>" + xa(r.message + "", !0) + "</pre>";
        return e ? Promise.resolve(n) : n;
      }
      if (e) return Promise.reject(r);
      throw r;
    };
  }
}, Fh = new lwe();
function wr(t, e) {
  return Fh.parse(t, e);
}
wr.options = wr.setOptions = function(t) {
  return Fh.setOptions(t), wr.defaults = Fh.defaults, NL(wr.defaults), wr;
};
wr.getDefaults = YS;
wr.defaults = Jh;
wr.use = function(...t) {
  return Fh.use(...t), wr.defaults = Fh.defaults, NL(wr.defaults), wr;
};
wr.walkTokens = function(t, e) {
  return Fh.walkTokens(t, e);
};
wr.parseInline = Fh.parseInline;
wr.Parser = js;
wr.parser = js.parse;
wr.Renderer = mb;
wr.TextRenderer = s5;
wr.Lexer = zs;
wr.lexer = zs.lex;
wr.Tokenizer = pb;
wr.Hooks = Cm;
wr.parse = wr;
wr.options;
wr.setOptions;
wr.use;
wr.walkTokens;
wr.parseInline;
js.parse;
zs.lex;
class uwe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    this.element.innerHTML = '<div class="markdown-content">' + wr(e.value?.toString() ?? "(null)", { async: !1, gfm: !0 }) + "</div>";
  }
}
class cwe {
  element;
  constructor(e, r) {
    this.element = e, this.update(r);
  }
  update(e) {
    if (e.value != null) {
      let r = document.createElement("a");
      r.href = e.value, r.innerText = e.value, r.className = "underline", r.target = "_blank", this.element.replaceChildren(r);
    } else
      this.element.innerText = "(null)";
  }
}
let WL = {
  markdown: uwe,
  image: _xe,
  url: cwe,
  json: Sxe
}, hwe = [
  { renderer: "markdown", label: "Markdown" },
  { renderer: "image", label: "Image" },
  { renderer: "url", label: "Link" },
  { renderer: "json", label: "JSON" }
];
function AO(t) {
  if (t != null)
    return typeof t == "string" ? WL[t] : t;
}
function fwe(t) {
  return typeof t == "string" && (t.startsWith("http://") || t.startsWith("https://"));
}
function dwe(t) {
  return t == null ? !1 : !!(typeof t == "string" && t.startsWith("data:image/") || t.bytes && t.bytes instanceof Uint8Array);
}
function a5(t) {
  if (t == null)
    return "(null)";
  if (typeof t == "string")
    return t.toString();
  if (typeof t == "number")
    return t.toLocaleString();
  if (Array.isArray(t))
    return "[" + t.map((e) => a5(e)).join(", ") + "]";
  try {
    return RL(t);
  } catch {
    return t.toString();
  }
}
var pwe = /* @__PURE__ */ me('<a class="underline" target="_blank"> </a>'), mwe = /* @__PURE__ */ me('<img alt="" class="max-w-24 max-h-24"/>'), gwe = /* @__PURE__ */ me("<div></div>");
function EO(t, e) {
  nt(e, !0);
  let r = lt(e, "value", 3, ""), n = lt(e, "rendererOptions", 19, () => ({})), i = /* @__PURE__ */ K(() => e.renderer != null ? WL[e.renderer] ?? null : null);
  function o(c, h) {
    let d = new h.class(c, { value: h.value, ...h.options });
    return {
      update(p) {
        d.update?.({ value: p.value, ...p.options });
      },
      destroy() {
        d.destroy?.();
      }
    };
  }
  var s = kr(), a = He(s);
  {
    var l = (c) => {
      var h = kr(), d = He(h);
      {
        var p = (v) => {
          var y = pwe(), b = Y(y, !0);
          J(y), Ee(() => {
            te(y, "href", r()), at(b, r());
          }), Q(v, y);
        }, g = (v) => {
          var y = kr(), b = He(y);
          {
            var k = (S) => {
              var _ = mwe();
              Ee((D) => te(_, "src", D), [() => PL(r())]), Q(S, _);
            }, C = (S) => {
              var _ = No();
              Ee((D) => at(_, D), [() => a5(r())]), Q(S, _);
            };
            Fe(
              b,
              (S) => {
                dwe(r()) ? S(k) : S(C, !1);
              },
              !0
            );
          }
          Q(v, y);
        };
        Fe(d, (v) => {
          fwe(r()) ? v(p) : v(g, !1);
        });
      }
      Q(c, h);
    }, u = (c) => {
      var h = kr(), d = He(h);
      ST(d, () => x(i), (p) => {
        var g = gwe();
        Mo(g, (v, y) => o?.(v, y), () => ({
          class: x(i),
          value: r(),
          options: n() ?? {}
        })), Q(p, g);
      }), Q(c, h);
    };
    Fe(a, (c) => {
      x(i) == null ? c(l) : c(u, !1);
    });
  }
  Q(t, s), it();
}
var vwe = /* @__PURE__ */ me('<div class="flex flex-col"><div class="text-slate-400 dark:text-slate-400 font-medium text-xs"> </div> <div><!></div></div>'), ywe = /* @__PURE__ */ me('<div class="px-2 flex items-center gap-2 border border-slate-200 dark:border-slate-700 bg-slate-100/25 dark:bg-slate-700/25 text-slate-700 dark:text-slate-300 rounded-md"><div class="text-slate-400 dark:text-slate-400 font-medium text-sm"> </div> <div class="text-ellipsis whitespace-nowrap overflow-hidden max-w-72"><!></div></div>'), bwe = /* @__PURE__ */ me('<div class="flex flex-col gap-2"><!> <div class="flex-none flex flex-row gap-1 flex-wrap items-start"></div></div>');
function GL(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => Object.keys(e.columnStyles).filter((a) => e.columnStyles[a].display == "full")), n = /* @__PURE__ */ K(() => Object.keys(e.columnStyles).filter((a) => e.columnStyles[a].display == "badge"));
  var i = bwe(), o = Y(i);
  It(o, 17, () => x(r), hr, (a, l) => {
    const u = /* @__PURE__ */ K(() => e.values[x(l)]);
    var c = vwe(), h = Y(c), d = Y(h, !0);
    J(h);
    var p = le(h, 2), g = Y(p);
    EO(g, {
      get value() {
        return x(u);
      },
      get renderer() {
        return e.columnStyles[x(l)].renderer;
      },
      get rendererOptions() {
        return e.columnStyles[x(l)].rendererOptions;
      }
    }), J(p), J(c), Ee(() => at(d, x(l))), Q(a, c);
  });
  var s = le(o, 2);
  It(s, 21, () => x(n), hr, (a, l) => {
    const u = /* @__PURE__ */ K(() => e.values[x(l)]);
    var c = ywe(), h = Y(c), d = Y(h, !0);
    J(h);
    var p = le(h, 2), g = Y(p);
    EO(g, {
      get value() {
        return x(u);
      }
    }), J(p), J(c), Ee(
      (v) => {
        at(d, x(l)), te(p, "title", v);
      },
      [() => a5(x(u))]
    ), Q(a, c);
  }), J(s), J(i), Q(t, i), it();
}
var xwe = /* @__PURE__ */ me('<div><button class="text-sm flex gap-0.5 items-center text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-300"><!> Nearest Neighbors</button></div>'), wwe = /* @__PURE__ */ me('<div class="embedding-atlas-root"><div><!> <!></div></div>');
function kwe(t, e) {
  nt(e, !0);
  var r = wwe(), n = Y(r);
  let i;
  ct(n, "", {}, { "max-width": "400px", "max-height": "300px" });
  var o = Y(n);
  {
    let l = /* @__PURE__ */ K(() => e.tooltip.fields ?? {}), u = /* @__PURE__ */ K(() => e.columnStyles ?? {});
    GL(o, {
      get values() {
        return x(l);
      },
      get columnStyles() {
        return x(u);
      }
    });
  }
  var s = le(o, 2);
  {
    var a = (l) => {
      var u = xwe(), c = Y(u);
      c.__click = () => {
        e.onNearestNeighborSearch?.(e.tooltip.identifier);
      };
      var h = Y(c);
      Vpe(h, {}), U_(), J(c), J(u), Q(l, u);
    };
    Fe(s, (l) => {
      e.onNearestNeighborSearch && l(a);
    });
  }
  J(n), J(r), Ee(() => i = en(n, 1, "p-2 border flex flex-col gap-2 border-slate-300 dark:border-slate-600 shadow-md text-slate-700 dark:text-slate-300 rounded-md text-ellipsis overflow-x-hidden overflow-y-scroll bg-white/75 dark:bg-slate-800/75 backdrop-blur-sm", null, i, { dark: e.colorScheme == "dark" })), Q(t, r), it();
}
nn(["click"]);
function KL(t) {
  return class {
    component;
    constructor(e, r) {
      this.component = CT({ component: t, target: e, props: r });
    }
    update(e) {
      this.component.$set(e);
    }
    destroy() {
      this.component.$destroy();
    }
  };
}
var Cwe = /* @__PURE__ */ me("<div></div>");
function _we(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]), n;
  Qg(() => {
    let o = new c1e(n, r);
    Ws(() => {
      o.update(r);
    }), _T(() => {
      o.destroy();
    });
  });
  var i = Cwe();
  ct(i, "", {}, { display: "flex" }), Qs(i, (o) => n = o, () => n), Q(t, i), it();
}
const gb = Math.min, dh = Math.max, vb = Math.round, ky = Math.floor, Xa = (t) => ({
  x: t,
  y: t
});
function DO(t, e, r) {
  return dh(t, gb(e, r));
}
function l5(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Nx(t) {
  return t.split("-")[0];
}
function XL(t) {
  return t.split("-")[1];
}
function QL(t) {
  return t === "x" ? "y" : "x";
}
function Swe(t) {
  return t === "y" ? "height" : "width";
}
const Awe = /* @__PURE__ */ new Set(["top", "bottom"]);
function $x(t) {
  return Awe.has(Nx(t)) ? "y" : "x";
}
function Ewe(t) {
  return QL($x(t));
}
function Dwe(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Owe(t) {
  return typeof t != "number" ? Dwe(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function yb(t) {
  const {
    x: e,
    y: r,
    width: n,
    height: i
  } = t;
  return {
    width: n,
    height: i,
    top: r,
    left: e,
    right: e + n,
    bottom: r + i,
    x: e,
    y: r
  };
}
function OO(t, e, r) {
  let {
    reference: n,
    floating: i
  } = t;
  const o = $x(e), s = Ewe(e), a = Swe(s), l = Nx(e), u = o === "y", c = n.x + n.width / 2 - i.width / 2, h = n.y + n.height / 2 - i.height / 2, d = n[a] / 2 - i[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: c,
        y: n.y - i.height
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: n.y + n.height
      };
      break;
    case "right":
      p = {
        x: n.x + n.width,
        y: h
      };
      break;
    case "left":
      p = {
        x: n.x - i.width,
        y: h
      };
      break;
    default:
      p = {
        x: n.x,
        y: n.y
      };
  }
  switch (XL(e)) {
    case "start":
      p[s] -= d * (r && u ? -1 : 1);
      break;
    case "end":
      p[s] += d * (r && u ? -1 : 1);
      break;
  }
  return p;
}
const Fwe = async (t, e, r) => {
  const {
    placement: n = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = r, a = o.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let u = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: c,
    y: h
  } = OO(u, n, l), d = n, p = {}, g = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: y,
      fn: b
    } = a[v], {
      x: k,
      y: C,
      data: S,
      reset: _
    } = await b({
      x: c,
      y: h,
      initialPlacement: n,
      placement: d,
      strategy: i,
      middlewareData: p,
      rects: u,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    c = k ?? c, h = C ?? h, p = {
      ...p,
      [y]: {
        ...p[y],
        ...S
      }
    }, _ && g <= 50 && (g++, typeof _ == "object" && (_.placement && (d = _.placement), _.rects && (u = _.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: i
    }) : _.rects), {
      x: c,
      y: h
    } = OO(u, d, l)), v = -1);
  }
  return {
    x: c,
    y: h,
    placement: d,
    strategy: i,
    middlewareData: p
  };
};
async function Twe(t, e) {
  var r;
  e === void 0 && (e = {});
  const {
    x: n,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: h = "floating",
    altBoundary: d = !1,
    padding: p = 0
  } = l5(e, t), g = Owe(p), v = a[d ? h === "floating" ? "reference" : "floating" : h], y = yb(await o.getClippingRect({
    element: (r = await (o.isElement == null ? void 0 : o.isElement(v))) == null || r ? v : v.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), b = h === "floating" ? {
    x: n,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, k = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), C = await (o.isElement == null ? void 0 : o.isElement(k)) ? await (o.getScale == null ? void 0 : o.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = yb(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: b,
    offsetParent: k,
    strategy: l
  }) : b);
  return {
    top: (y.top - S.top + g.top) / C.y,
    bottom: (S.bottom - y.bottom + g.bottom) / C.y,
    left: (y.left - S.left + g.left) / C.x,
    right: (S.right - y.right + g.right) / C.x
  };
}
const Mwe = /* @__PURE__ */ new Set(["left", "top"]);
async function Pwe(t, e) {
  const {
    placement: r,
    platform: n,
    elements: i
  } = t, o = await (n.isRTL == null ? void 0 : n.isRTL(i.floating)), s = Nx(r), a = XL(r), l = $x(r) === "y", u = Mwe.has(s) ? -1 : 1, c = o && l ? -1 : 1, h = l5(e, t);
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: g
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof g == "number" && (p = a === "end" ? g * -1 : g), l ? {
    x: p * c,
    y: d * u
  } : {
    x: d * u,
    y: p * c
  };
}
const Rwe = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var r, n;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: a
      } = e, l = await Pwe(e, t);
      return s === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: i + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, Nwe = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: r,
        y: n,
        placement: i
      } = e, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (y) => {
            let {
              x: b,
              y: k
            } = y;
            return {
              x: b,
              y: k
            };
          }
        },
        ...l
      } = l5(t, e), u = {
        x: r,
        y: n
      }, c = await Twe(e, l), h = $x(Nx(i)), d = QL(h);
      let p = u[d], g = u[h];
      if (o) {
        const y = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", k = p + c[y], C = p - c[b];
        p = DO(k, p, C);
      }
      if (s) {
        const y = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", k = g + c[y], C = g - c[b];
        g = DO(k, g, C);
      }
      const v = a.fn({
        ...e,
        [d]: p,
        [h]: g
      });
      return {
        ...v,
        data: {
          x: v.x - r,
          y: v.y - n,
          enabled: {
            [d]: o,
            [h]: s
          }
        }
      };
    }
  };
};
function Ix() {
  return typeof window < "u";
}
function xp(t) {
  return JL(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Wo(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function fl(t) {
  var e;
  return (e = (JL(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function JL(t) {
  return Ix() ? t instanceof Node || t instanceof Wo(t).Node : !1;
}
function ea(t) {
  return Ix() ? t instanceof Element || t instanceof Wo(t).Element : !1;
}
function rl(t) {
  return Ix() ? t instanceof HTMLElement || t instanceof Wo(t).HTMLElement : !1;
}
function FO(t) {
  return !Ix() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Wo(t).ShadowRoot;
}
const $we = /* @__PURE__ */ new Set(["inline", "contents"]);
function C0(t) {
  const {
    overflow: e,
    overflowX: r,
    overflowY: n,
    display: i
  } = ta(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !$we.has(i);
}
const Iwe = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Bwe(t) {
  return Iwe.has(xp(t));
}
const Lwe = [":popover-open", ":modal"];
function Bx(t) {
  return Lwe.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const zwe = ["transform", "translate", "scale", "rotate", "perspective"], jwe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], qwe = ["paint", "layout", "strict", "content"];
function u5(t) {
  const e = c5(), r = ea(t) ? ta(t) : t;
  return zwe.some((n) => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || jwe.some((n) => (r.willChange || "").includes(n)) || qwe.some((n) => (r.contain || "").includes(n));
}
function Uwe(t) {
  let e = fc(t);
  for (; rl(e) && !jd(e); ) {
    if (u5(e))
      return e;
    if (Bx(e))
      return null;
    e = fc(e);
  }
  return null;
}
function c5() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const Hwe = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function jd(t) {
  return Hwe.has(xp(t));
}
function ta(t) {
  return Wo(t).getComputedStyle(t);
}
function Lx(t) {
  return ea(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function fc(t) {
  if (xp(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    FO(t) && t.host || // Fallback.
    fl(t)
  );
  return FO(e) ? e.host : e;
}
function YL(t) {
  const e = fc(t);
  return jd(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : rl(e) && C0(e) ? e : YL(e);
}
function qg(t, e, r) {
  var n;
  e === void 0 && (e = []), r === void 0 && (r = !0);
  const i = YL(t), o = i === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Wo(i);
  if (o) {
    const a = g_(s);
    return e.concat(s, s.visualViewport || [], C0(i) ? i : [], a && r ? qg(a) : []);
  }
  return e.concat(i, qg(i, [], r));
}
function g_(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function ZL(t) {
  const e = ta(t);
  let r = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const i = rl(t), o = i ? t.offsetWidth : r, s = i ? t.offsetHeight : n, a = vb(r) !== o || vb(n) !== s;
  return a && (r = o, n = s), {
    width: r,
    height: n,
    $: a
  };
}
function h5(t) {
  return ea(t) ? t : t.contextElement;
}
function cd(t) {
  const e = h5(t);
  if (!rl(e))
    return Xa(1);
  const r = e.getBoundingClientRect(), {
    width: n,
    height: i,
    $: o
  } = ZL(e);
  let s = (o ? vb(r.width) : r.width) / n, a = (o ? vb(r.height) : r.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const Vwe = /* @__PURE__ */ Xa(0);
function ez(t) {
  const e = Wo(t);
  return !c5() || !e.visualViewport ? Vwe : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function Wwe(t, e, r) {
  return e === void 0 && (e = !1), !r || e && r !== Wo(t) ? !1 : e;
}
function Th(t, e, r, n) {
  e === void 0 && (e = !1), r === void 0 && (r = !1);
  const i = t.getBoundingClientRect(), o = h5(t);
  let s = Xa(1);
  e && (n ? ea(n) && (s = cd(n)) : s = cd(t));
  const a = Wwe(o, r, n) ? ez(o) : Xa(0);
  let l = (i.left + a.x) / s.x, u = (i.top + a.y) / s.y, c = i.width / s.x, h = i.height / s.y;
  if (o) {
    const d = Wo(o), p = n && ea(n) ? Wo(n) : n;
    let g = d, v = g_(g);
    for (; v && n && p !== g; ) {
      const y = cd(v), b = v.getBoundingClientRect(), k = ta(v), C = b.left + (v.clientLeft + parseFloat(k.paddingLeft)) * y.x, S = b.top + (v.clientTop + parseFloat(k.paddingTop)) * y.y;
      l *= y.x, u *= y.y, c *= y.x, h *= y.y, l += C, u += S, g = Wo(v), v = g_(g);
    }
  }
  return yb({
    width: c,
    height: h,
    x: l,
    y: u
  });
}
function zx(t, e) {
  const r = Lx(t).scrollLeft;
  return e ? e.left + r : Th(fl(t)).left + r;
}
function tz(t, e) {
  const r = t.getBoundingClientRect(), n = r.left + e.scrollLeft - zx(t, r), i = r.top + e.scrollTop;
  return {
    x: n,
    y: i
  };
}
function Gwe(t) {
  let {
    elements: e,
    rect: r,
    offsetParent: n,
    strategy: i
  } = t;
  const o = i === "fixed", s = fl(n), a = e ? Bx(e.floating) : !1;
  if (n === s || a && o)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Xa(1);
  const c = Xa(0), h = rl(n);
  if ((h || !h && !o) && ((xp(n) !== "body" || C0(s)) && (l = Lx(n)), rl(n))) {
    const p = Th(n);
    u = cd(n), c.x = p.x + n.clientLeft, c.y = p.y + n.clientTop;
  }
  const d = s && !h && !o ? tz(s, l) : Xa(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - l.scrollLeft * u.x + c.x + d.x,
    y: r.y * u.y - l.scrollTop * u.y + c.y + d.y
  };
}
function Kwe(t) {
  return Array.from(t.getClientRects());
}
function Xwe(t) {
  const e = fl(t), r = Lx(t), n = t.ownerDocument.body, i = dh(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), o = dh(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let s = -r.scrollLeft + zx(t);
  const a = -r.scrollTop;
  return ta(n).direction === "rtl" && (s += dh(e.clientWidth, n.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
const TO = 25;
function Qwe(t, e) {
  const r = Wo(t), n = fl(t), i = r.visualViewport;
  let o = n.clientWidth, s = n.clientHeight, a = 0, l = 0;
  if (i) {
    o = i.width, s = i.height;
    const c = c5();
    (!c || c && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  const u = zx(n);
  if (u <= 0) {
    const c = n.ownerDocument, h = c.body, d = getComputedStyle(h), p = c.compatMode === "CSS1Compat" && parseFloat(d.marginLeft) + parseFloat(d.marginRight) || 0, g = Math.abs(n.clientWidth - h.clientWidth - p);
    g <= TO && (o -= g);
  } else u <= TO && (o += u);
  return {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
const Jwe = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Ywe(t, e) {
  const r = Th(t, !0, e === "fixed"), n = r.top + t.clientTop, i = r.left + t.clientLeft, o = rl(t) ? cd(t) : Xa(1), s = t.clientWidth * o.x, a = t.clientHeight * o.y, l = i * o.x, u = n * o.y;
  return {
    width: s,
    height: a,
    x: l,
    y: u
  };
}
function MO(t, e, r) {
  let n;
  if (e === "viewport")
    n = Qwe(t, r);
  else if (e === "document")
    n = Xwe(fl(t));
  else if (ea(e))
    n = Ywe(e, r);
  else {
    const i = ez(t);
    n = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return yb(n);
}
function rz(t, e) {
  const r = fc(t);
  return r === e || !ea(r) || jd(r) ? !1 : ta(r).position === "fixed" || rz(r, e);
}
function Zwe(t, e) {
  const r = e.get(t);
  if (r)
    return r;
  let n = qg(t, [], !1).filter((a) => ea(a) && xp(a) !== "body"), i = null;
  const o = ta(t).position === "fixed";
  let s = o ? fc(t) : t;
  for (; ea(s) && !jd(s); ) {
    const a = ta(s), l = u5(s);
    !l && a.position === "fixed" && (i = null), (o ? !l && !i : !l && a.position === "static" && i && Jwe.has(i.position) || C0(s) && !l && rz(t, s)) ? n = n.filter((u) => u !== s) : i = a, s = fc(s);
  }
  return e.set(t, n), n;
}
function e2e(t) {
  let {
    element: e,
    boundary: r,
    rootBoundary: n,
    strategy: i
  } = t;
  const o = [...r === "clippingAncestors" ? Bx(e) ? [] : Zwe(e, this._c) : [].concat(r), n], s = o[0], a = o.reduce((l, u) => {
    const c = MO(e, u, i);
    return l.top = dh(c.top, l.top), l.right = gb(c.right, l.right), l.bottom = gb(c.bottom, l.bottom), l.left = dh(c.left, l.left), l;
  }, MO(e, s, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function t2e(t) {
  const {
    width: e,
    height: r
  } = ZL(t);
  return {
    width: e,
    height: r
  };
}
function r2e(t, e, r) {
  const n = rl(e), i = fl(e), o = r === "fixed", s = Th(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Xa(0);
  function u() {
    l.x = zx(i);
  }
  if (n || !n && !o)
    if ((xp(e) !== "body" || C0(i)) && (a = Lx(e)), n) {
      const p = Th(e, !0, o, e);
      l.x = p.x + e.clientLeft, l.y = p.y + e.clientTop;
    } else i && u();
  o && !n && i && u();
  const c = i && !n && !o ? tz(i, a) : Xa(0), h = s.left + a.scrollLeft - l.x - c.x, d = s.top + a.scrollTop - l.y - c.y;
  return {
    x: h,
    y: d,
    width: s.width,
    height: s.height
  };
}
function Ik(t) {
  return ta(t).position === "static";
}
function PO(t, e) {
  if (!rl(t) || ta(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let r = t.offsetParent;
  return fl(t) === r && (r = r.ownerDocument.body), r;
}
function nz(t, e) {
  const r = Wo(t);
  if (Bx(t))
    return r;
  if (!rl(t)) {
    let i = fc(t);
    for (; i && !jd(i); ) {
      if (ea(i) && !Ik(i))
        return i;
      i = fc(i);
    }
    return r;
  }
  let n = PO(t, e);
  for (; n && Bwe(n) && Ik(n); )
    n = PO(n, e);
  return n && jd(n) && Ik(n) && !u5(n) ? r : n || Uwe(t) || r;
}
const n2e = async function(t) {
  const e = this.getOffsetParent || nz, r = this.getDimensions, n = await r(t.floating);
  return {
    reference: r2e(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function i2e(t) {
  return ta(t).direction === "rtl";
}
const o2e = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Gwe,
  getDocumentElement: fl,
  getClippingRect: e2e,
  getOffsetParent: nz,
  getElementRects: n2e,
  getClientRects: Kwe,
  getDimensions: t2e,
  getScale: cd,
  isElement: ea,
  isRTL: i2e
};
function iz(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function s2e(t, e) {
  let r = null, n;
  const i = fl(t);
  function o() {
    var a;
    clearTimeout(n), (a = r) == null || a.disconnect(), r = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const u = t.getBoundingClientRect(), {
      left: c,
      top: h,
      width: d,
      height: p
    } = u;
    if (a || e(), !d || !p)
      return;
    const g = ky(h), v = ky(i.clientWidth - (c + d)), y = ky(i.clientHeight - (h + p)), b = ky(c), k = {
      rootMargin: -g + "px " + -v + "px " + -y + "px " + -b + "px",
      threshold: dh(0, gb(1, l)) || 1
    };
    let C = !0;
    function S(_) {
      const D = _[0].intersectionRatio;
      if (D !== l) {
        if (!C)
          return s();
        D ? s(!1, D) : n = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !iz(u, t.getBoundingClientRect()) && s(), C = !1;
    }
    try {
      r = new IntersectionObserver(S, {
        ...k,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(S, k);
    }
    r.observe(t);
  }
  return s(!0), o;
}
function a2e(t, e, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, u = h5(t), c = i || o ? [...u ? qg(u) : [], ...qg(e)] : [];
  c.forEach((b) => {
    i && b.addEventListener("scroll", r, {
      passive: !0
    }), o && b.addEventListener("resize", r);
  });
  const h = u && a ? s2e(u, r) : null;
  let d = -1, p = null;
  s && (p = new ResizeObserver((b) => {
    let [k] = b;
    k && k.target === u && p && (p.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var C;
      (C = p) == null || C.observe(e);
    })), r();
  }), u && !l && p.observe(u), p.observe(e));
  let g, v = l ? Th(t) : null;
  l && y();
  function y() {
    const b = Th(t);
    v && !iz(v, b) && r(), v = b, g = requestAnimationFrame(y);
  }
  return r(), () => {
    var b;
    c.forEach((k) => {
      i && k.removeEventListener("scroll", r), o && k.removeEventListener("resize", r);
    }), h?.(), (b = p) == null || b.disconnect(), p = null, l && cancelAnimationFrame(g);
  };
}
const l2e = Rwe, u2e = Nwe, c2e = (t, e, r) => {
  const n = /* @__PURE__ */ new Map(), i = {
    platform: o2e,
    ...r
  }, o = {
    ...i.platform,
    _c: n
  };
  return Fwe(t, e, {
    ...i,
    platform: o
  });
};
var h2e = /* @__PURE__ */ me('<div class="relative"><!> <div class="absolute px-3 py-3 rounded-md z-20 bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-700 shadow-lg" popover=""><!></div></div>');
function oz(t, e) {
  nt(e, !0);
  let r = lt(e, "title", 3, ""), n = lt(e, "label", 3, null), i = lt(e, "icon", 3, null);
  lt(e, "anchor", 3, "right");
  let o = /* @__PURE__ */ De(!1), s;
  function a(g) {
    x(o) && g.key == "Escape" && (ae(o, !1), g.stopPropagation());
  }
  Ws(() => {
    if (s != null) {
      let g = (y) => {
        !x(o) || !s || y.target && !s.contains(y.target) && ae(o, !1);
      }, v = s.getRootNode();
      return v.addEventListener("mousedown", g), () => {
        v.removeEventListener("mousedown", g);
      };
    }
  });
  let l;
  Ws(() => {
    x(o) && Ws(() => u());
  });
  function u() {
    l.showPopover();
    function g() {
      c2e(s, l, { placement: "bottom", middleware: [l2e(3), u2e()] }).then(({ x: v, y }) => {
        l.style.left = v + "px", l.style.top = y + "px";
      });
    }
    return a2e(s, l, g);
  }
  var c = h2e();
  c.__keydown = a;
  var h = Y(c);
  Jy(h, {
    get icon() {
      return i();
    },
    get title() {
      return r();
    },
    get label() {
      return n();
    },
    get checked() {
      return x(o);
    },
    set checked(g) {
      ae(o, g, !0);
    }
  });
  var d = le(h, 2);
  ct(d, "", {}, { width: "max-content" });
  var p = Y(d);
  Jl(p, () => e.children ?? jt), J(d), Qs(d, (g) => l = g, () => l), J(c), Qs(c, (g) => s = g, () => s), Q(t, c), it();
}
nn(["keydown"]);
var f2e = /* @__PURE__ */ me('<div class="group relative" role="slider" tabindex="0"><div class="bg-slate-400 dark:bg-slate-500 rounded-full absolute"></div> <div class="bg-blue-500 rounded-full absolute group-hover:bg-blue-600 dark:group-hover:bg-blue-400"></div></div>');
function v_(t, e) {
  nt(e, !0);
  let r = lt(e, "value", 15, 0), n = lt(e, "min", 3, 0), i = lt(e, "max", 3, 100), o = lt(e, "step", 3, void 0), s = lt(e, "width", 3, 100), a = 15, l = /* @__PURE__ */ K(() => (_) => (_ - n()) / (i() - n()) * (s() - a)), u = /* @__PURE__ */ K(() => (_) => _ / (s() - a) * (i() - n()) + n()), c = /* @__PURE__ */ K(() => x(l)(r())), h = /* @__PURE__ */ De(void 0);
  function d(_) {
    let D = x(u)(_ - a / 2);
    D = Math.max(n(), Math.min(i(), D)), o() != null && (D = Math.round(D / o()) * o()), r(D);
  }
  function p(_) {
    d(_.clientX - x(h).getBoundingClientRect().left);
    let D = (O) => {
      d(O.clientX - x(h).getBoundingClientRect().left);
    }, A = () => {
      window.removeEventListener("mousemove", D), window.removeEventListener("mouseup", A);
    };
    window.addEventListener("mousemove", D), window.addEventListener("mouseup", A);
  }
  function g(_) {
    _.key == "ArrowLeft" ? r(Math.max(r() - (o() ?? 1), n())) : _.key == "ArrowRight" && r(Math.min(r() + (o() ?? 1), i()));
  }
  var v = f2e();
  v.__mousedown = p, v.__keydown = g;
  let y;
  var b = Y(v);
  let k;
  var C = le(b, 2);
  let S;
  J(v), Qs(v, (_) => ae(h, _), () => x(h)), Ee(() => {
    te(v, "aria-valuenow", r()), te(v, "aria-valuemin", n()), te(v, "aria-valuemax", i()), y = ct(v, "", y, { width: `${s() ?? ""}px`, height: "28px" }), k = ct(b, "", k, {
      left: "0px",
      top: "12px",
      width: `${s() ?? ""}px`,
      height: "4px"
    }), S = ct(C, "", S, {
      left: `${x(c) ?? ""}px`,
      top: "6.5px",
      width: "15px",
      height: "15px"
    });
  }), Q(t, v), it();
}
nn(["mousedown", "keydown"]);
var d2e = /* @__PURE__ */ me('<tr><td class="first:rounded-tl-md first:rounded-bl-md"><div class="block w-4 h-4 mx-2 rounded-full"></div></td><td><div class="whitespace-nowrap nowrap max-w-72 text-ellipsis overflow-hidden"> </div></td><td class="text-slate-400 px-2 text-xs text-right last:rounded-tr-md last:rounded-br-md" title="Count"> </td></tr>'), p2e = /* @__PURE__ */ me("<table><tbody></tbody></table>");
function m2e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => {
    let l = new Set(e.state.selection ?? []);
    return new Set(e.spec.items.filter((u) => l.has(u.label)));
  });
  class n extends F_ {
    reset() {
      e.onStateChange({ selection: void 0 });
    }
  }
  const i = new n();
  function o(l, u) {
    let c = new Set(e.state.selection ?? []);
    u.shiftKey || u.metaKey ? (c.has(l.label) ? c.delete(l.label) : c.add(l.label), e.onStateChange({ selection: Array.from(c) })) : c.has(l.label) && c.size == 1 ? e.onStateChange({ selection: void 0 }) : e.onStateChange({ selection: [l.label] });
  }
  dt(() => (dt(() => {
    let l = new Set(e.state.selection ?? []), u = e.spec.items.filter((d) => l.has(d.label)), c = u.length != 0 ? T.or(u.map((d) => d.predicate)) : null, h = {
      source: i,
      clients: /* @__PURE__ */ new Set([i]),
      value: u.length == 0 ? null : u,
      predicate: c
    };
    e.context.filter.update(h);
  }), () => {
    e.context.filter.update({
      source: i,
      clients: /* @__PURE__ */ new Set([i]),
      value: null,
      predicate: null
    });
  }));
  var s = p2e(), a = Y(s);
  It(a, 21, () => e.spec.items, hr, (l, u) => {
    const c = /* @__PURE__ */ K(() => x(r).has(x(u)) || x(r).size == 0);
    var h = d2e();
    let d;
    h.__click = (_) => {
      o(x(u), _);
    };
    var p = Y(h), g = Y(p);
    let v;
    J(p);
    var y = le(p), b = Y(y), k = Y(b, !0);
    J(b), J(y);
    var C = le(y), S = Y(C, !0);
    J(C), J(h), Ee(
      (_) => {
        d = en(h, 1, "hover:bg-slate-200 dark:hover:bg-slate-700 select-none leading-7", null, d, { "opacity-20": !x(c) }), v = ct(g, "", v, { "background-color": x(u).color }), te(b, "title", x(u).label), at(k, x(u).label), at(S, _);
      },
      [() => x(u).count.toLocaleString()]
    ), Q(l, h);
  }), J(a), J(s), Q(t, s), it();
}
nn(["click"]);
function sz(t) {
  let e = 0;
  function r(n) {
    e += 1;
    try {
      n();
    } finally {
      e -= 1;
    }
  }
  return {
    set(n) {
      r(() => {
        t.set(n);
      });
    },
    update(n) {
      r(() => {
        t.update(n);
      });
    },
    subscribe(n) {
      return t.subscribe((i) => {
        e == 0 && n(i);
      });
    }
  };
}
async function g2e(t, e, r) {
  if (r == null)
    return null;
  let [n] = Array.from(await t.query(T.Query.describe(T.Query.from(e).select(r))));
  if (n == null)
    return null;
  let i = JS(n.column_type);
  return i == "string" ? await RO(t, e, r, 10) : i == "number" ? await FL(t, e, r) <= 10 ? await RO(t, e, r, 10) : await v2e(t, e, r) : null;
}
async function RO(t, e, r, n) {
  let i = `_ev_${r}_id`, o = Array.from(
    await t.query(
      T.Query.from(e).select({ value: T.cast(T.column(r), "TEXT"), count: T.count() }).where(T.not(T.isNull(T.cast(T.column(r), "TEXT")))).groupby(T.cast(T.column(r), "TEXT")).orderby(T.desc(T.count())).limit(n)
    )
  ), s = o.length, a = o.length + 1;
  await t.exec(`
    ALTER TABLE ${e} ADD COLUMN IF NOT EXISTS ${T.column(i)} INTEGER DEFAULT 0;
    UPDATE ${e}
    SET ${T.column(i)} = CASE ${T.column(r)}::TEXT
          ${o.map(({ value: g }, v) => T.sql`WHEN ${T.literal(g)} THEN ${T.literal(v)}`).join(" ")}
          ELSE (CASE WHEN ${T.column(r)} IS NULL THEN ${T.literal(a)} ELSE ${T.literal(s)} END) END
  `);
  let l = Array.from(
    await t.query(
      T.Query.from(e).select({ index: T.column(i), count: T.cast(T.count(), "INT") }).groupby(T.column(i))
    )
  ), u = /* @__PURE__ */ new Map();
  for (let g of l)
    u.set(g.index, g.count);
  let c = u.get(s) ?? 0, h = u.get(a) ?? 0, d = gp(o.length), p = o.map(({ value: g }, v) => ({
    label: g,
    color: d[v],
    predicate: T.eq(T.cast(T.column(r), "TEXT"), T.literal(g)),
    count: u.get(v) ?? 0
  }));
  if (c > 0) {
    let { otherCategoryCount: g } = (await t.query(`
        SELECT COUNT(DISTINCT(${T.column(r)}::TEXT)) AS otherCategoryCount
        FROM ${e}
        WHERE ${T.column(i)} = ${T.literal(s)} AND ${T.column(r)} IS NOT NULL
    `)).get(0);
    p.push({
      label: `(other ${g.toLocaleString()})`,
      color: "#9eabc2",
      predicate: o.length > 0 ? T.sql`${T.column(r)} IS NOT NULL AND ${T.column(r)}::TEXT NOT IN (${o.map((v) => T.literal(v.value)).join(",")})` : T.sql`${T.column(r)} IS NOT NULL`,
      count: c
    });
  }
  return h > 0 && (c <= 0 && (await t.exec(`
          UPDATE ${e}
          SET ${T.column(i)} = ${T.column(i)} - 1 WHERE ${T.column(i)} = ${T.literal(a)}
        `), a -= 1), p.push({
    label: "(null)",
    color: "#aaaaaa",
    predicate: T.isNull(T.column(r)),
    count: h
  })), {
    indexColumn: i,
    legend: p
  };
}
async function v2e(t, e, r) {
  let n = (await t.query(
    T.Query.from(e).select({
      count: T.count(),
      min: T.min(T.column(r)),
      max: T.max(T.column(r)),
      mean: T.avg(T.column(r)),
      median: T.median(T.column(r))
    }).where(T.isFinite(T.column(r)))
  )).get(0), i = TL(n), o = `_ev_${r}_id`, s = T.cast(T.column(r), "DOUBLE");
  s = i.scale.expr(s, i.scale.constant ?? 0);
  let a = T.cond(
    T.isFinite(T.cast(T.column(r), "DOUBLE")),
    T.floor(T.mul(T.sub(s, i.binStart), 1 / i.binSize)),
    T.literal(null)
  );
  await t.exec(`
    ALTER TABLE ${e} ADD COLUMN IF NOT EXISTS ${T.column(o)} INTEGER DEFAULT 0;
    UPDATE ${e}
    SET ${T.column(o)} = ${a}
  `);
  let l = Array.from(
    await t.query(`
      SELECT ${T.column(o)} AS index, COUNT(*)::INT AS count
      FROM ${e}
      GROUP BY ${T.column(o)}
      ORDER BY ${T.column(o)} ASC
    `)
  ), u = null, c = null, h = /* @__PURE__ */ new Map(), d = (v) => i.scale.reverse(v, i.scale.constant ?? 0);
  for (let { index: v, count: y } of l)
    v != null && ((u == null || v < u) && (u = v), (c == null || v > c) && (c = v)), h.set(v, y);
  let p = [], g = su(".6");
  if (u != null && c != null) {
    let v = SL(c - u + 1);
    for (let y = u; y <= c; y++) {
      let b = d(y * i.binSize + i.binStart), k = d((y + 1) * i.binSize + i.binStart);
      p.push({
        label: `[${g(b)}, ${g(k)})`,
        color: v[y - u],
        predicate: T.eq(a, T.literal(y)),
        count: h.get(y) ?? 0
      });
    }
  }
  if (h.has(null)) {
    let v = p.length;
    await t.exec(`
        UPDATE ${e}
        SET ${T.column(o)} = ${T.literal(v)}
        WHERE ${T.column(o)} IS NULL
      `), p.push({
      label: "(null / nan / inf)",
      color: "#aaaaaa",
      predicate: T.isNull(a),
      count: h.get(null) ?? 0
    });
  }
  return {
    indexColumn: o,
    legend: p
  };
}
function Cy(t, e, r) {
  return t + (e - t) * r;
}
function y2e(t, e, r) {
  let n = Math.log(t.scale), i = Math.log(e.scale);
  if (Math.abs(i - n) < 1e-5)
    return {
      x: Cy(t.x, e.x, r),
      y: Cy(t.y, e.y, r),
      scale: Cy(t.scale, e.scale, r)
    };
  let o = Math.exp(Cy(n, i, r));
  return {
    x: (e.x * e.scale - t.x * t.scale + (t.x - e.x) * (t.scale * e.scale / o)) / (e.scale - t.scale),
    y: (e.y * e.scale - t.y * t.scale + (t.y - e.y) * (t.scale * e.scale / o)) / (e.scale - t.scale),
    scale: o
  };
}
async function b2e(t, e, r, n) {
  let { stdX: i, stdY: o } = (await t.query(T.Query.from(e).select({
    stdX: T.sql`STDDEV(${T.column(r)})::FLOAT`,
    stdY: T.sql`STDDEV(${T.column(n)})::FLOAT`
  }))).get(0);
  return 1 / (Math.max(i, o, 1e-3) * 3);
}
const x2e = KL(kwe), w2e = KL(wxe);
var k2e = /* @__PURE__ */ me('<div class="flex-none m-2 p-2 rounded-md bg-slate-100/75 dark:bg-slate-800/75 backdrop-blur-sm pointer-events-auto order-3"><!></div>'), C2e = /* @__PURE__ */ me('<div class="flex flex-col gap-2 w-64"><div class="text-slate-500 dark:text-slate-400 select-none">Display Mode</div> <div class="flex gap-2 items-center"><!> <!></div> <div class="text-slate-500 dark:text-slate-400 select-none">Point Size</div> <div class="flex gap-2 items-center"><!> <!></div></div>'), _2e = /* @__PURE__ */ me('<div class="relative"><!> <div class="absolute top-0 left-0 right-0 flex flex-wrap justify-between items-start pointer-events-none"><!> <div class="flex-none p-2 rounded-ss-md rounded-ee-md bg-white/75 dark:bg-black/75 backdrop-blur-sm flex items-center gap-2 pointer-events-auto order-1"><!> <!></div></div></div>');
function S2e(t, e) {
  nt(e, !0);
  const r = () => gi(l, "$colorScheme", i), n = () => gi(u, "$columnStyles", i), [i, o] = Jo(), s = Math.min(20, h1e()), a = 1 / 16;
  let { colorScheme: l, columnStyles: u, searchResult: c } = e.context, h = sz(e.context.highlight), d = /* @__PURE__ */ K(() => e.spec.data.category), p = /* @__PURE__ */ De(null), g = /* @__PURE__ */ De(null), v = /* @__PURE__ */ De(null), y = /* @__PURE__ */ De(null);
  dt(() => {
    e.context.cache.value(`embedding/category/${x(d)}`, () => g2e(e.context.coordinator, e.context.table, x(d))).then(($) => {
      ae(p, $), (x(p)?.legend.length ?? 0) > s && e.onSpecChange({ mode: "points" });
    });
  }), dt(() => h.subscribe(($) => {
    $ !== null && b($);
  })), dt(() => c.subscribe(async ($) => {
    if ($ == null || $.ids.length == 0) {
      ae(y, null);
      return;
    }
    let j = null;
    $.mode == "neighbors" && (j = $.query);
    let U = Array.from(await e.context.coordinator.query(T.Query.from(e.context.table).select({
      identifier: T.column(e.context.id),
      x: T.column(e.spec.data.x),
      y: T.column(e.spec.data.y)
    }).where(T.isIn(e.context.id, $.ids.concat(j != null ? [j] : []).map((H) => T.literal(H))))));
    ae(y, {
      center: U.filter((H) => H.identifier === j)[0] ?? null,
      points: U.filter((H) => H.identifier !== j)
    });
  }));
  async function b($) {
    let j = await e.context.cache.value(`embedding/default-viewport-scale/${e.spec.data.x},${e.spec.data.y}`, () => b2e(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y)) * 2, U = await e.context.coordinator.query(T.Query.from(e.context.table).select({
      x: T.column(e.spec.data.x),
      y: T.column(e.spec.data.y)
    }).where(T.eq(T.column(e.context.id), T.literal($)))), { x: H, y: G } = U.get(0);
    S({ x: H, y: G, scale: j }), ae(v, [$]), ae(g, $);
  }
  let k, C = /* @__PURE__ */ De(null);
  function S($) {
    ae(g, null);
    let j = x(C) ?? e.state.viewport;
    if (j == null) {
      e.onStateChange({ viewport: $ });
      return;
    }
    ae(C, j);
    let U = 800, H = (/* @__PURE__ */ new Date()).getTime(), G = () => {
      let re = ((/* @__PURE__ */ new Date()).getTime() - H) / U;
      re > 1 && (re = 1), ae(C, y2e(j, $, RT(re))), re < 1 ? k = requestAnimationFrame(G) : e.onStateChange({ viewport: x(C) });
    };
    k && cancelAnimationFrame(k), k = requestAnimationFrame(G);
  }
  var _ = { startViewportAnimation: S }, D = _2e(), A = Y(D);
  {
    let $ = /* @__PURE__ */ K(() => x(p)?.indexColumn), j = /* @__PURE__ */ K(() => x(p)?.legend.map((se) => se.color)), U = /* @__PURE__ */ K(() => ({
      colorScheme: r(),
      ...e.context.embeddingViewConfig,
      mode: e.spec.mode ?? "points",
      ...e.spec.minimumDensity != null ? { minimumDensity: e.spec.minimumDensity } : {},
      ...e.spec.pointSize != null ? { pointSize: e.spec.pointSize } : {}
    })), H = /* @__PURE__ */ K(() => Object.fromEntries(e.context.columns.map((se) => [se.name, se.name]))), G = /* @__PURE__ */ K(() => ({
      class: x2e,
      props: {
        darkMode: r(),
        columnStyles: n(),
        onNearestNeighborSearch: (e.context.searchModes ?? []).indexOf("neighbors") >= 0 ? (se) => e.context.search?.(se, "neighbors") : null
      }
    })), re = /* @__PURE__ */ K(() => ({
      class: w2e,
      props: { ...x(y) ?? { points: [], center: null } }
    })), ne = /* @__PURE__ */ K(() => x(C) ?? e.state.viewport);
    _we(A, {
      get width() {
        return e.width;
      },
      get height() {
        return e.height;
      },
      get coordinator() {
        return e.context.coordinator;
      },
      get table() {
        return e.context.table;
      },
      get filter() {
        return e.context.filter;
      },
      get rangeSelection() {
        return e.context.filter;
      },
      get identifier() {
        return e.context.id;
      },
      get x() {
        return e.spec.data.x;
      },
      get y() {
        return e.spec.data.y;
      },
      get text() {
        return e.spec.data.text;
      },
      get category() {
        return x($);
      },
      get categoryColors() {
        return x(j);
      },
      get config() {
        return x(U);
      },
      get labels() {
        return e.context.embeddingViewLabels;
      },
      get cache() {
        return e.context.persistentCache;
      },
      get additionalFields() {
        return x(H);
      },
      get customTooltip() {
        return x(G);
      },
      get customOverlay() {
        return x(re);
      },
      get viewportState() {
        return x(ne);
      },
      onViewportState: (se) => e.onStateChange({ viewport: se }),
      get rangeSelectionValue() {
        return e.state.brush;
      },
      onRangeSelection: (se) => e.onStateChange({ brush: se }),
      get tooltip() {
        return x(g);
      },
      onTooltip: (se) => {
        ae(g, se);
      },
      get selection() {
        return x(v);
      },
      onSelection: (se) => {
        ae(v, se), se != null && se.length == 1 && h.set(se[0].identifier);
      }
    });
  }
  var O = le(A, 2), M = Y(O);
  {
    var z = ($) => {
      var j = k2e(), U = Y(j);
      {
        let H = /* @__PURE__ */ K(() => ({ items: x(p).legend })), G = /* @__PURE__ */ K(() => e.state.legend ?? {});
        m2e(U, {
          get context() {
            return e.context;
          },
          get spec() {
            return x(H);
          },
          get state() {
            return x(G);
          },
          onSpecChange: () => {
          },
          onStateChange: (re, ne) => {
            e.onStateChange({ legend: re });
          }
        });
      }
      J(j), Q($, j);
    };
    Fe(M, ($) => {
      x(p) != null && $(z);
    });
  }
  var N = le(M, 2), P = Y(N);
  {
    let $ = /* @__PURE__ */ K(() => [
      { value: null, label: "(none)" },
      ...e.context.columns.filter((j) => j.jsType == "string" || j.jsType == "number").map((j) => ({ value: j.name, label: `${j.name} (${j.type})` }))
    ]);
    Oh(P, {
      class: "max-w-64",
      label: "Color",
      get value() {
        return x(d);
      },
      onChange: (j) => e.onSpecChange({ data: { ...e.spec.data, category: j } }),
      get options() {
        return x($);
      }
    });
  }
  var I = le(P, 2);
  oz(I, {
    get icon() {
      return LI;
    },
    title: "Options",
    children: ($, j) => {
      var U = C2e(), H = le(Y(U), 2), G = Y(H);
      {
        let Pe = /* @__PURE__ */ K(() => e.spec.mode ?? "points"), Ae = /* @__PURE__ */ K(() => x(p) != null && x(p).legend.length > s);
        Oh(G, {
          get value() {
            return x(Pe);
          },
          onChange: (he) => e.onSpecChange({ mode: he }),
          get disabled() {
            return x(Ae);
          },
          options: [
            { value: "points", label: "Points" },
            { value: "density", label: "Density" }
          ]
        });
      }
      var re = le(G, 2);
      {
        var ne = (Pe) => {
          var Ae = () => Math.log((e.spec.minimumDensity ?? a) / a), he = (we) => e.onSpecChange({ minimumDensity: a * Math.exp(we) });
          v_(Pe, {
            get value() {
              return Ae();
            },
            set value(we) {
              he(we);
            },
            min: -4,
            max: 4,
            step: 0.05
          });
        };
        Fe(re, (Pe) => {
          (e.spec.mode ?? "points") == "density" && Pe(ne);
        });
      }
      J(H);
      var se = le(H, 4), ie = Y(se), ce = () => e.spec.pointSize ?? 1, Ce = (Pe) => e.onSpecChange({ pointSize: Pe });
      v_(ie, {
        get value() {
          return ce();
        },
        set value(Pe) {
          Ce(Pe);
        },
        min: 1,
        max: 10,
        step: 0.05
      });
      var Me = le(ie, 2);
      Mu(Me, {
        label: "Auto",
        onClick: () => e.onSpecChange({ pointSize: void 0 })
      }), J(se), J(U), Q($, U);
    },
    $$slots: { default: !0 }
  }), J(N), J(O), J(D), Q(t, D);
  var B = it(_);
  return o(), B;
}
const bi = 2, jx = 4, f5 = 8, hu = 16, fu = 32, Yh = 64, qx = 128, ra = 512, li = 1024, mo = 2048, du = 4096, Go = 8192, Zu = 16384, Ux = 32768, Mh = 65536, NO = 1 << 17, az = 1 << 18, wp = 1 << 19, A2e = 1 << 20, Ug = 32768, y_ = 1 << 21, d5 = 1 << 22, ec = 1 << 23, ph = Symbol("$state"), lz = Symbol("legacy props"), E2e = Symbol(""), jf = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), p5 = 3, kp = 8, D2e = !1;
var m5 = Array.isArray, O2e = Array.prototype.indexOf, g5 = Array.from, uz = Object.defineProperty, hd = Object.getOwnPropertyDescriptor, cz = Object.getOwnPropertyDescriptors, hz = Object.prototype, F2e = Array.prototype, Hx = Object.getPrototypeOf, $O = Object.isExtensible;
function T2e(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function fz() {
  var t, e, r = new Promise((n, i) => {
    t = n, e = i;
  });
  return { promise: r, resolve: t, reject: e };
}
function dz(t) {
  return t === this.v;
}
function pz(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function mz(t) {
  return !pz(t, this.v);
}
function gz(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function M2e() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function P2e(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function R2e() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function N2e(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function $2e() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function I2e() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function B2e() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function L2e() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function z2e() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function j2e() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let _0 = !1, q2e = !1;
function U2e() {
  _0 = !0;
}
const v5 = 1, y5 = 2, vz = 4, H2e = 8, V2e = 16, W2e = 1, G2e = 2, yz = "[", Vx = "[!", b5 = "]", qd = {}, ti = Symbol(), K2e = "http://www.w3.org/1999/xhtml", X2e = [];
function bz(t, e = !1, r = !1) {
  return Zy(t, /* @__PURE__ */ new Map(), "", X2e, null, r);
}
function Zy(t, e, r, n, i = null, o = !1) {
  if (typeof t == "object" && t !== null) {
    var s = e.get(t);
    if (s !== void 0) return s;
    if (t instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(t)
    );
    if (t instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(t)
    );
    if (m5(t)) {
      var a = (
        /** @type {Snapshot<any>} */
        Array(t.length)
      );
      e.set(t, a), i !== null && e.set(i, a);
      for (var l = 0; l < t.length; l += 1) {
        var u = t[l];
        l in t && (a[l] = Zy(u, e, r, n, null, o));
      }
      return a;
    }
    if (Hx(t) === hz) {
      a = {}, e.set(t, a), i !== null && e.set(i, a);
      for (var c in t)
        a[c] = Zy(
          // @ts-expect-error
          t[c],
          e,
          r,
          n,
          null,
          o
        );
      return a;
    }
    if (t instanceof Date)
      return (
        /** @type {Snapshot<T>} */
        structuredClone(t)
      );
    if (typeof /** @type {T & { toJSON?: any } } */
    t.toJSON == "function" && !o)
      return Zy(
        /** @type {T & { toJSON(): any } } */
        t.toJSON(),
        e,
        r,
        n,
        // Associate the instance with the toJSON clone
        t
      );
  }
  if (t instanceof EventTarget)
    return (
      /** @type {Snapshot<T>} */
      t
    );
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(t)
    );
  } catch {
    return (
      /** @type {Snapshot<T>} */
      t
    );
  }
}
let Zr = null;
function Ud(t) {
  Zr = t;
}
function Qi(t) {
  return (
    /** @type {T} */
    xz().get(t)
  );
}
function fs(t, e) {
  return xz().set(t, e), e;
}
function on(t, e = !1, r) {
  Zr = {
    p: Zr,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: _0 && !e ? { s: null, u: null, $: [] } : null
  };
}
function sn(t) {
  var e = (
    /** @type {ComponentContext} */
    Zr
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      Vz(n);
  }
  return e.i = !0, Zr = e.p, /** @type {T} */
  {};
}
function Cp() {
  return !_0 || Zr !== null && Zr.l === null;
}
function xz(t) {
  return Zr === null && gz(), Zr.c ??= new Map(Q2e(Zr) || void 0);
}
function Q2e(t) {
  let e = t.p;
  for (; e !== null; ) {
    const r = e.c;
    if (r !== null)
      return r;
    e = e.p;
  }
  return null;
}
let rh = [];
function wz() {
  var t = rh;
  rh = [], T2e(t);
}
function Zh(t) {
  if (rh.length === 0 && !Um) {
    var e = rh;
    queueMicrotask(() => {
      e === rh && wz();
    });
  }
  rh.push(t);
}
function J2e() {
  for (; rh.length > 0; )
    wz();
}
function Wx(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function Y2e() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Vt = !1;
function Ul(t) {
  Vt = t;
}
let pr;
function ao(t) {
  if (t === null)
    throw Wx(), qd;
  return pr = t;
}
function S0() {
  return ao(
    /** @type {TemplateNode} */
    /* @__PURE__ */ dl(pr)
  );
}
function dr(t) {
  if (Vt) {
    if (/* @__PURE__ */ dl(pr) !== null)
      throw Wx(), qd;
    pr = t;
  }
}
function Z2e(t = 1) {
  if (Vt) {
    for (var e = t, r = pr; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ dl(r);
    pr = r;
  }
}
function bb(t = !0) {
  for (var e = 0, r = pr; ; ) {
    if (r.nodeType === kp) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === b5) {
        if (e === 0) return r;
        e -= 1;
      } else (n === yz || n === Vx) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ dl(r)
    );
    t && r.remove(), r = i;
  }
}
function kz(t) {
  if (!t || t.nodeType !== kp)
    throw Wx(), qd;
  return (
    /** @type {Comment} */
    t.data
  );
}
function ui(t) {
  if (typeof t != "object" || t === null || ph in t)
    return t;
  const e = Hx(t);
  if (e !== hz && e !== F2e)
    return t;
  var r = /* @__PURE__ */ new Map(), n = m5(t), i = /* @__PURE__ */ qe(0), o = gh, s = (a) => {
    if (gh === o)
      return a();
    var l = er, u = gh;
    oo(null), jO(o);
    var c = a();
    return oo(l), jO(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ qe(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && B2e();
        var c = r.get(l);
        return c === void 0 ? c = s(() => {
          var h = /* @__PURE__ */ qe(u.value);
          return r.set(l, h), h;
        }) : be(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = s(() => /* @__PURE__ */ qe(ti));
            r.set(l, c), Hm(i);
          }
        } else
          be(u, ti), Hm(i);
        return !0;
      },
      get(a, l, u) {
        if (l === ph)
          return t;
        var c = r.get(l), h = l in a;
        if (c === void 0 && (!h || hd(a, l)?.writable) && (c = s(() => {
          var p = ui(h ? a[l] : ti), g = /* @__PURE__ */ qe(p);
          return g;
        }), r.set(l, c)), c !== void 0) {
          var d = q(c);
          return d === ti ? void 0 : d;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = q(c));
        } else if (u === void 0) {
          var h = r.get(l), d = h?.v;
          if (h !== void 0 && d !== ti)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === ph)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== ti || Reflect.has(a, l);
        if (u !== void 0 || nr !== null && (!c || hd(a, l)?.writable)) {
          u === void 0 && (u = s(() => {
            var d = c ? ui(a[l]) : ti, p = /* @__PURE__ */ qe(d);
            return p;
          }), r.set(l, u));
          var h = q(u);
          if (h === ti)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var h = r.get(l), d = l in a;
        if (n && l === "length")
          for (var p = u; p < /** @type {Source<number>} */
          h.v; p += 1) {
            var g = r.get(p + "");
            g !== void 0 ? be(g, ti) : p in a && (g = s(() => /* @__PURE__ */ qe(ti)), r.set(p + "", g));
          }
        if (h === void 0)
          (!d || hd(a, l)?.writable) && (h = s(() => /* @__PURE__ */ qe(void 0)), be(h, ui(u)), r.set(l, h));
        else {
          d = h.v !== ti;
          var v = s(() => ui(u));
          be(h, v);
        }
        var y = Reflect.getOwnPropertyDescriptor(a, l);
        if (y?.set && y.set.call(c, u), !d) {
          if (n && typeof l == "string") {
            var b = (
              /** @type {Source<number>} */
              r.get("length")
            ), k = Number(l);
            Number.isInteger(k) && k >= b.v && be(b, k + 1);
          }
          Hm(i);
        }
        return !0;
      },
      ownKeys(a) {
        q(i);
        var l = Reflect.ownKeys(a).filter((h) => {
          var d = r.get(h);
          return d === void 0 || d.v !== ti;
        });
        for (var [u, c] of r)
          c.v !== ti && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        L2e();
      }
    }
  );
}
var b_, Cz, _z, Sz;
function x_() {
  if (b_ === void 0) {
    b_ = window, Cz = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    _z = hd(e, "firstChild").get, Sz = hd(e, "nextSibling").get, $O(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), $O(r) && (r.__t = void 0);
  }
}
function nl(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Ph(t) {
  return _z.call(t);
}
// @__NO_SIDE_EFFECTS__
function dl(t) {
  return Sz.call(t);
}
function yr(t, e) {
  if (!Vt)
    return /* @__PURE__ */ Ph(t);
  var r = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ Ph(pr)
  );
  if (r === null)
    r = pr.appendChild(nl());
  else if (e && r.nodeType !== p5) {
    var n = nl();
    return r?.before(n), ao(n), n;
  }
  return ao(r), r;
}
function zo(t, e = !1) {
  if (!Vt) {
    var r = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Ph(
        /** @type {Node} */
        t
      )
    );
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ dl(r) : r;
  }
  if (e && pr?.nodeType !== p5) {
    var n = nl();
    return pr?.before(n), ao(n), n;
  }
  return pr;
}
function vs(t, e = 1, r = !1) {
  let n = Vt ? pr : t;
  for (var i; e--; )
    i = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ dl(n);
  if (!Vt)
    return n;
  if (r && n?.nodeType !== p5) {
    var o = nl();
    return n === null ? i?.after(o) : n.before(o), ao(o), o;
  }
  return ao(n), /** @type {TemplateNode} */
  n;
}
function Az(t) {
  t.textContent = "";
}
function Ez(t) {
  var e = nr;
  if (e === null)
    return er.f |= ec, t;
  if ((e.f & Ux) === 0) {
    if ((e.f & qx) === 0)
      throw t;
    e.b.error(t);
  } else
    Hd(t, e);
}
function Hd(t, e) {
  for (; e !== null; ) {
    if ((e.f & qx) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const _y = /* @__PURE__ */ new Set();
let An = null, jo = null, Ta = [], Gx = null, w_ = !1, Um = !1;
class za {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #l = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #a = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Ta = [], this.apply();
    var r = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const n of e)
      this.#o(n, r);
    this.is_fork || this.#u(), this.#n > 0 || this.is_fork ? (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects)) : (An = null, IO(r.render_effects), IO(r.effects), this.#l?.resolve()), jo = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(e, r) {
    e.f ^= li;
    for (var n = e.first; n !== null; ) {
      var i = n.f, o = (i & (fu | Yh)) !== 0, s = o && (i & li) !== 0, a = s || (i & Go) !== 0 || this.skipped_effects.has(n);
      if ((n.f & qx) !== 0 && n.b?.is_pending() && (r = {
        parent: r,
        effect: n,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !a && n.fn !== null) {
        o ? n.f ^= li : (i & jx) !== 0 ? r.effects.push(n) : A0(n) && ((n.f & hu) !== 0 && r.block_effects.push(n), Vg(n));
        var l = n.first;
        if (l !== null) {
          n = l;
          continue;
        }
      }
      var u = n.parent;
      for (n = n.next; n === null && u !== null; )
        u === r.effect && (this.#s(r.effects), this.#s(r.render_effects), this.#s(r.block_effects), r = /** @type {EffectTarget} */
        r.parent), n = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #s(e) {
    for (const r of e)
      ((r.f & mo) !== 0 ? this.#a : this.#i).push(r), pi(r, li);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    this.previous.has(e) || this.previous.set(e, r), (e.f & ec) === 0 && (this.current.set(e, e.v), jo?.set(e, e.v));
  }
  activate() {
    An = this, this.apply();
  }
  deactivate() {
    An = null, jo = null;
  }
  flush() {
    if (this.activate(), Ta.length > 0) {
      if (Dz(), An !== null && An !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#n === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#r === 0 && this.#c();
  }
  #c() {
    if (_y.size > 1) {
      this.previous.clear();
      var e = jo, r = !0, n = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of _y) {
        if (i === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (i.current.has(a))
            if (r && l !== i.current.get(a))
              i.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const s = [...i.current.keys()].filter((a) => !this.current.has(a));
        if (s.length > 0) {
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            Oz(u, s, a, l);
          if (Ta.length > 0) {
            An = i, i.apply();
            for (const u of Ta)
              i.#o(u, n);
            Ta = [], i.deactivate();
          }
        }
      }
      An = null, jo = e;
    }
    this.committed = !0, _y.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), this.revive();
  }
  revive() {
    for (const e of this.#a)
      pi(e, mo), Rh(e);
    for (const e of this.#i)
      pi(e, du), Rh(e);
    this.#a = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#l ??= fz()).promise;
  }
  static ensure() {
    if (An === null) {
      const e = An = new za();
      _y.add(An), Um || za.enqueue(() => {
        An === e && e.flush();
      });
    }
    return An;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    Zh(e);
  }
  apply() {
  }
}
function eke(t) {
  var e = Um;
  Um = !0;
  try {
    for (var r; ; ) {
      if (J2e(), Ta.length === 0 && (An?.flush(), Ta.length === 0))
        return Gx = null, /** @type {T} */
        r;
      Dz();
    }
  } finally {
    Um = e;
  }
}
function Dz() {
  var t = mh;
  w_ = !0;
  try {
    var e = 0;
    for (LO(!0); Ta.length > 0; ) {
      var r = za.ensure();
      if (e++ > 1e3) {
        var n, i;
        tke();
      }
      r.process(Ta), tc.clear();
    }
  } finally {
    w_ = !1, LO(t), Gx = null;
  }
}
function tke() {
  try {
    $2e();
  } catch (t) {
    Hd(t, Gx);
  }
}
let Ml = null;
function IO(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (Zu | Go)) === 0 && A0(n) && (Ml = /* @__PURE__ */ new Set(), Vg(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null && n.ac === null ? Kz(n) : n.fn = null), Ml?.size > 0)) {
        tc.clear();
        for (const i of Ml) {
          if ((i.f & (Zu | Go)) !== 0) continue;
          const o = [i];
          let s = i.parent;
          for (; s !== null; )
            Ml.has(s) && (Ml.delete(s), o.push(s)), s = s.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (Zu | Go)) === 0 && Vg(l);
          }
        }
        Ml.clear();
      }
    }
    Ml = null;
  }
}
function Oz(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const o = i.f;
      (o & bi) !== 0 ? Oz(
        /** @type {Derived} */
        i,
        e,
        r,
        n
      ) : (o & (d5 | hu)) !== 0 && (o & mo) === 0 && // we may have scheduled this one already
      Fz(i, e, n) && (pi(i, mo), Rh(
        /** @type {Effect} */
        i
      ));
    }
}
function Fz(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & bi) !== 0 && Fz(
        /** @type {Derived} */
        i,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function Rh(t) {
  for (var e = Gx = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (w_ && e === nr && (r & hu) !== 0 && (r & az) === 0)
      return;
    if ((r & (Yh | fu)) !== 0) {
      if ((r & li) === 0) return;
      e.f ^= li;
    }
  }
  Ta.push(e);
}
function rke(t) {
  let e = 0, r = Nh(0), n;
  return () => {
    Xx() && (q(r), k5(() => (e === 0 && (n = E0(() => t(() => Hm(r)))), e += 1, () => {
      Zh(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Hm(r));
      });
    })));
  };
}
var nke = Mh | wp | qx;
function ike(t, e, r) {
  new oke(t, e, r);
}
class oke {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #r = Vt ? pr : null;
  /** @type {BoundaryProps} */
  #n;
  /** @type {((anchor: Node) => void)} */
  #l;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #h = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #f = null;
  #v = rke(() => (this.#f = Nh(this.#d), () => {
    this.#f = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#t = e, this.#n = r, this.#l = n, this.parent = /** @type {Effect} */
    nr.b, this.#e = !!this.#n.pending, this.#a = O0(() => {
      if (nr.b = this, Vt) {
        const o = this.#r;
        S0(), /** @type {Comment} */
        o.nodeType === kp && /** @type {Comment} */
        o.data === Vx ? this.#b() : this.#y();
      } else {
        var i = this.#x();
        try {
          this.#i = Ls(() => n(i));
        } catch (o) {
          this.error(o);
        }
        this.#h > 0 ? this.#g() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, nke), Vt && (this.#t = pr);
  }
  #y() {
    try {
      this.#i = Ls(() => this.#l(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #b() {
    const e = this.#n.pending;
    e && (this.#o = Ls(() => e(this.#t)), za.enqueue(() => {
      var r = this.#x();
      this.#i = this.#m(() => (za.ensure(), Ls(() => this.#l(r)))), this.#h > 0 ? this.#g() : (fd(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = nl(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#n.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(e) {
    var r = nr, n = er, i = Zr;
    il(this.#a), oo(this.#a), Ud(this.#a.ctx);
    try {
      return e();
    } catch (o) {
      return Ez(o), null;
    } finally {
      il(r), oo(n), Ud(i);
    }
  }
  #g() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#n.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), Jz(this.#i, this.#u)), this.#o === null && (this.#o = Ls(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#h += e, this.#h === 0 && (this.#e = !1, this.#o && fd(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#f && Vd(this.#f, this.#d);
  }
  get_effect_pending() {
    return this.#v(), q(
      /** @type {Source<number>} */
      this.#f
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#n.onerror;
    let n = this.#n.failed;
    if (this.#p || !r && !n)
      throw e;
    this.#i && (Li(this.#i), this.#i = null), this.#o && (Li(this.#o), this.#o = null), this.#s && (Li(this.#s), this.#s = null), Vt && (ao(
      /** @type {TemplateNode} */
      this.#r
    ), Z2e(), ao(bb()));
    var i = !1, o = !1;
    const s = () => {
      if (i) {
        Y2e();
        return;
      }
      i = !0, o && j2e(), za.ensure(), this.#d = 0, this.#s !== null && fd(this.#s, () => {
        this.#s = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#m(() => (this.#p = !1, Ls(() => this.#l(this.#t)))), this.#h > 0 ? this.#g() : this.#e = !1;
    };
    var a = er;
    try {
      oo(null), o = !0, r?.(e, s), o = !1;
    } catch (l) {
      Hd(l, this.#a && this.#a.parent);
    } finally {
      oo(a);
    }
    n && Zh(() => {
      this.#s = this.#m(() => {
        za.ensure(), this.#p = !0;
        try {
          return Ls(() => {
            n(
              this.#t,
              () => e,
              () => s
            );
          });
        } catch (l) {
          return Hd(
            l,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function ske(t, e, r, n) {
  const i = Cp() ? Kx : Tz;
  if (r.length === 0 && t.length === 0) {
    n(e.map(i));
    return;
  }
  var o = An, s = (
    /** @type {Effect} */
    nr
  ), a = ake();
  function l() {
    Promise.all(r.map((u) => /* @__PURE__ */ lke(u))).then((u) => {
      a();
      try {
        n([...e.map(i), ...u]);
      } catch (c) {
        (s.f & Zu) === 0 && Hd(c, s);
      }
      o?.deactivate(), xb();
    }).catch((u) => {
      Hd(u, s);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    a();
    try {
      return l();
    } finally {
      o?.deactivate(), xb();
    }
  }) : l();
}
function ake() {
  var t = nr, e = er, r = Zr, n = An;
  return function(i = !0) {
    il(t), oo(e), Ud(r), i && n?.activate();
  };
}
function xb() {
  il(null), oo(null), Ud(null);
}
// @__NO_SIDE_EFFECTS__
function Kx(t) {
  var e = bi | mo, r = er !== null && (er.f & bi) !== 0 ? (
    /** @type {Derived} */
    er
  ) : null;
  return nr !== null && (nr.f |= wp), {
    ctx: Zr,
    deps: null,
    effects: null,
    equals: dz,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      ti
    ),
    wv: 0,
    parent: r ?? nr,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function lke(t, e) {
  let r = (
    /** @type {Effect | null} */
    nr
  );
  r === null && M2e();
  var n = (
    /** @type {Boundary} */
    r.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), o = Nh(
    /** @type {V} */
    ti
  ), s = !er, a = /* @__PURE__ */ new Map();
  return bke(() => {
    var l = fz();
    i = l.promise;
    try {
      Promise.resolve(t()).then(l.resolve, l.reject).then(() => {
        u === An && u.committed && u.deactivate(), xb();
      });
    } catch (d) {
      l.reject(d), xb();
    }
    var u = (
      /** @type {Batch} */
      An
    );
    if (s) {
      var c = !n.is_pending();
      n.update_pending_count(1), u.increment(c), a.get(u)?.reject(jf), a.delete(u), a.set(u, l);
    }
    const h = (d, p = void 0) => {
      if (u.activate(), p)
        p !== jf && (o.f |= ec, Vd(o, p));
      else {
        (o.f & ec) !== 0 && (o.f ^= ec), Vd(o, d);
        for (const [g, v] of a) {
          if (a.delete(g), g === u) break;
          v.reject(jf);
        }
      }
      s && (n.update_pending_count(-1), u.decrement(c));
    };
    l.promise.then(h, (d) => h(null, d || "unknown"));
  }), Hz(() => {
    for (const l of a.values())
      l.reject(jf);
  }), new Promise((l) => {
    function u(c) {
      function h() {
        c === i ? l(o) : u(i);
      }
      c.then(h, h);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function Se(t) {
  const e = /* @__PURE__ */ Kx(t);
  return Iz(e), e;
}
// @__NO_SIDE_EFFECTS__
function Tz(t) {
  const e = /* @__PURE__ */ Kx(t);
  return e.equals = mz, e;
}
function Mz(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Li(
        /** @type {Effect} */
        e[r]
      );
  }
}
function uke(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & bi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function x5(t) {
  var e, r = nr;
  il(uke(t));
  try {
    t.f &= ~Ug, Mz(t), e = jz(t);
  } finally {
    il(r);
  }
  return e;
}
function Pz(t) {
  var e = x5(t);
  if (t.equals(e) || (t.v = e, t.wv = Lz()), !ef)
    if (jo !== null)
      Xx() && jo.set(t, t.v);
    else {
      var r = (t.f & ra) === 0 ? du : li;
      pi(t, r);
    }
}
let k_ = /* @__PURE__ */ new Set();
const tc = /* @__PURE__ */ new Map();
let Rz = !1;
function Nh(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: dz,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function qe(t, e) {
  const r = Nh(t);
  return Iz(r), r;
}
// @__NO_SIDE_EFFECTS__
function Nz(t, e = !1, r = !0) {
  const n = Nh(t);
  return e || (n.equals = mz), _0 && r && Zr !== null && Zr.l !== null && (Zr.l.s ??= []).push(n), n;
}
function be(t, e, r = !1) {
  er !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!ja || (er.f & NO) !== 0) && Cp() && (er.f & (bi | hu | d5 | NO)) !== 0 && !Xl?.includes(t) && z2e();
  let n = r ? ui(e) : e;
  return Vd(t, n);
}
function Vd(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    ef ? tc.set(t, e) : tc.set(t, r), t.v = e;
    var n = za.ensure();
    n.capture(t, r), (t.f & bi) !== 0 && ((t.f & mo) !== 0 && x5(
      /** @type {Derived} */
      t
    ), pi(t, (t.f & ra) !== 0 ? li : du)), t.wv = Lz(), $z(t, mo), Cp() && nr !== null && (nr.f & li) !== 0 && (nr.f & (fu | Yh)) === 0 && (hs === null ? fke([t]) : hs.push(t)), !n.is_fork && k_.size > 0 && !Rz && cke();
  }
  return e;
}
function cke() {
  Rz = !1;
  const t = Array.from(k_);
  for (const e of t)
    (e.f & li) !== 0 && pi(e, du), A0(e) && Vg(e);
  k_.clear();
}
function Hm(t) {
  be(t, t.v + 1);
}
function $z(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = Cp(), i = r.length, o = 0; o < i; o++) {
      var s = r[o], a = s.f;
      if (!(!n && s === nr)) {
        var l = (a & mo) === 0;
        if (l && pi(s, e), (a & bi) !== 0) {
          var u = (
            /** @type {Derived} */
            s
          );
          jo?.delete(u), (a & Ug) === 0 && (a & ra && (s.f |= Ug), $z(u, du));
        } else l && ((a & hu) !== 0 && Ml !== null && Ml.add(
          /** @type {Effect} */
          s
        ), Rh(
          /** @type {Effect} */
          s
        ));
      }
    }
}
let BO = !1;
function hke() {
  BO || (BO = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function w5(t) {
  var e = er, r = nr;
  oo(null), il(null);
  try {
    return t();
  } finally {
    oo(e), il(r);
  }
}
let mh = !1;
function LO(t) {
  mh = t;
}
let ef = !1;
function zO(t) {
  ef = t;
}
let er = null, ja = !1;
function oo(t) {
  er = t;
}
let nr = null;
function il(t) {
  nr = t;
}
let Xl = null;
function Iz(t) {
  er !== null && (Xl === null ? Xl = [t] : Xl.push(t));
}
let Oi = null, To = 0, hs = null;
function fke(t) {
  hs = t;
}
let Bz = 1, Hg = 0, gh = Hg;
function jO(t) {
  gh = t;
}
function Lz() {
  return ++Bz;
}
function A0(t) {
  var e = t.f;
  if ((e & mo) !== 0)
    return !0;
  if (e & bi && (t.f &= ~Ug), (e & du) !== 0) {
    var r = t.deps;
    if (r !== null)
      for (var n = r.length, i = 0; i < n; i++) {
        var o = r[i];
        if (A0(
          /** @type {Derived} */
          o
        ) && Pz(
          /** @type {Derived} */
          o
        ), o.wv > t.wv)
          return !0;
      }
    (e & ra) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    jo === null && pi(t, li);
  }
  return !1;
}
function zz(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !Xl?.includes(t))
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      (o.f & bi) !== 0 ? zz(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? pi(o, mo) : (o.f & li) !== 0 && pi(o, du), Rh(
        /** @type {Effect} */
        o
      ));
    }
}
function jz(t) {
  var e = Oi, r = To, n = hs, i = er, o = Xl, s = Zr, a = ja, l = gh, u = t.f;
  Oi = /** @type {null | Value[]} */
  null, To = 0, hs = null, er = (u & (fu | Yh)) === 0 ? t : null, Xl = null, Ud(t.ctx), ja = !1, gh = ++Hg, t.ac !== null && (w5(() => {
    t.ac.abort(jf);
  }), t.ac = null);
  try {
    t.f |= y_;
    var c = (
      /** @type {Function} */
      t.fn
    ), h = c(), d = t.deps;
    if (Oi !== null) {
      var p;
      if (wb(t, To), d !== null && To > 0)
        for (d.length = To + Oi.length, p = 0; p < Oi.length; p++)
          d[To + p] = Oi[p];
      else
        t.deps = d = Oi;
      if (mh && Xx() && (t.f & ra) !== 0)
        for (p = To; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && To < d.length && (wb(t, To), d.length = To);
    if (Cp() && hs !== null && !ja && d !== null && (t.f & (bi | du | mo)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      hs.length; p++)
        zz(
          hs[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (Hg++, hs !== null && (n === null ? n = hs : n.push(.../** @type {Source[]} */
    hs))), (t.f & ec) !== 0 && (t.f ^= ec), h;
  } catch (g) {
    return Ez(g);
  } finally {
    t.f ^= y_, Oi = e, To = r, hs = n, er = i, Xl = o, Ud(s), ja = a, gh = l;
  }
}
function dke(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = O2e.call(r, t);
    if (n !== -1) {
      var i = r.length - 1;
      i === 0 ? r = e.reactions = null : (r[n] = r[i], r.pop());
    }
  }
  r === null && (e.f & bi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Oi === null || !Oi.includes(e)) && (pi(e, du), (e.f & ra) !== 0 && (e.f ^= ra, e.f &= ~Ug), Mz(
    /** @type {Derived} **/
    e
  ), wb(
    /** @type {Derived} **/
    e,
    0
  ));
}
function wb(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      dke(t, r[n]);
}
function Vg(t) {
  var e = t.f;
  if ((e & Zu) === 0) {
    pi(t, li);
    var r = nr, n = mh;
    nr = t, mh = !0;
    try {
      (e & hu) !== 0 ? xke(t) : Gz(t), Wz(t);
      var i = jz(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = Bz;
      var o;
      D2e && q2e && (t.f & mo) !== 0 && t.deps;
    } finally {
      mh = n, nr = r;
    }
  }
}
function q(t) {
  var e = t.f, r = (e & bi) !== 0;
  if (er !== null && !ja) {
    var n = nr !== null && (nr.f & Zu) !== 0;
    if (!n && !Xl?.includes(t)) {
      var i = er.deps;
      if ((er.f & y_) !== 0)
        t.rv < Hg && (t.rv = Hg, Oi === null && i !== null && i[To] === t ? To++ : Oi === null ? Oi = [t] : Oi.includes(t) || Oi.push(t));
      else {
        (er.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [er] : o.includes(er) || o.push(er);
      }
    }
  }
  if (ef) {
    if (tc.has(t))
      return tc.get(t);
    if (r) {
      var s = (
        /** @type {Derived} */
        t
      ), a = s.v;
      return ((s.f & li) === 0 && s.reactions !== null || Uz(s)) && (a = x5(s)), tc.set(s, a), a;
    }
  } else if (r) {
    if (s = /** @type {Derived} */
    t, jo?.has(s))
      return jo.get(s);
    A0(s) && Pz(s), mh && Xx() && (s.f & ra) === 0 && qz(s);
  } else if (jo?.has(t))
    return jo.get(t);
  if ((t.f & ec) !== 0)
    throw t.v;
  return t.v;
}
function qz(t) {
  if (t.deps !== null) {
    t.f ^= ra;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & bi) !== 0 && (e.f & ra) === 0 && qz(
        /** @type {Derived} */
        e
      );
  }
}
function Uz(t) {
  if (t.v === ti) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (tc.has(e) || (e.f & bi) !== 0 && Uz(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function E0(t) {
  var e = ja;
  try {
    return ja = !0, t();
  } finally {
    ja = e;
  }
}
const pke = -7169;
function pi(t, e) {
  t.f = t.f & pke | e;
}
function mke(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (ph in t)
      C_(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && ph in r && C_(r);
      }
  }
}
function C_(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        C_(t[n], e);
      } catch {
      }
    const r = Hx(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = cz(r);
      for (let i in n) {
        const o = n[i].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
function gke(t) {
  nr === null && (er === null && N2e(), R2e()), ef && P2e();
}
function vke(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function pu(t, e, r, n = !0) {
  var i = nr;
  i !== null && (i.f & Go) !== 0 && (t |= Go);
  var o = {
    ctx: Zr,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | mo | ra,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      Vg(o), o.f |= Ux;
    } catch (l) {
      throw Li(o), l;
    }
  else e !== null && Rh(o);
  if (n) {
    var s = o;
    if (r && s.deps === null && s.teardown === null && s.nodes_start === null && s.first === s.last && // either `null`, or a singular child
    (s.f & wp) === 0 && (s = s.first, (t & hu) !== 0 && (t & Mh) !== 0 && s !== null && (s.f |= Mh)), s !== null && (s.parent = i, i !== null && vke(s, i), er !== null && (er.f & bi) !== 0 && (t & Yh) === 0)) {
      var a = (
        /** @type {Derived} */
        er
      );
      (a.effects ??= []).push(s);
    }
  }
  return o;
}
function Xx() {
  return er !== null && !ja;
}
function Hz(t) {
  const e = pu(f5, null, !1);
  return pi(e, li), e.teardown = t, e;
}
function Qr(t) {
  gke();
  var e = (
    /** @type {Effect} */
    nr.f
  ), r = !er && (e & fu) !== 0 && (e & Ux) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      Zr
    );
    (n.e ??= []).push(t);
  } else
    return Vz(t);
}
function Vz(t) {
  return pu(jx | A2e, t, !1);
}
function yke(t) {
  za.ensure();
  const e = pu(Yh | wp, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? fd(e, () => {
      Li(e), n(void 0);
    }) : (Li(e), n(void 0));
  });
}
function D0(t) {
  return pu(jx, t, !1);
}
function bke(t) {
  return pu(d5 | wp, t, !0);
}
function k5(t, e = 0) {
  return pu(f5 | e, t, !0);
}
function mn(t, e = [], r = [], n = [], i = !1) {
  ske(n, e, r, (o) => {
    pu(i ? jx : f5, () => t(...o.map(q)), !0);
  });
}
function O0(t, e = 0) {
  var r = pu(hu | e, t, !0);
  return r;
}
function Ls(t, e = !0) {
  return pu(fu | wp, t, !0, e);
}
function Wz(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = ef, n = er;
    zO(!0), oo(null);
    try {
      e.call(null);
    } finally {
      zO(r), oo(n);
    }
  }
}
function Gz(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const i = r.ac;
    i !== null && w5(() => {
      i.abort(jf);
    });
    var n = r.next;
    (r.f & Yh) !== 0 ? r.parent = null : Li(r, e), r = n;
  }
}
function xke(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & fu) === 0 && Li(e), e = r;
  }
}
function Li(t, e = !0) {
  var r = !1;
  (e || (t.f & az) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (wke(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), r = !0), Gz(t, e && !r), wb(t, 0), pi(t, Zu);
  var n = t.transitions;
  if (n !== null)
    for (const o of n)
      o.stop();
  Wz(t);
  var i = t.parent;
  i !== null && i.first !== null && Kz(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function wke(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ dl(t)
    );
    t.remove(), t = r;
  }
}
function Kz(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function fd(t, e, r = !0) {
  var n = [];
  C5(t, n, !0), Xz(n, () => {
    r && Li(t), e && e();
  });
}
function Xz(t, e) {
  var r = t.length;
  if (r > 0) {
    var n = () => --r || e();
    for (var i of t)
      i.out(n);
  } else
    e();
}
function C5(t, e, r) {
  if ((t.f & Go) === 0) {
    if (t.f ^= Go, t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || r) && e.push(s);
    for (var n = t.first; n !== null; ) {
      var i = n.next, o = (n.f & Mh) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (n.f & fu) !== 0 && (t.f & hu) !== 0;
      C5(n, e, o ? r : !1), n = i;
    }
  }
}
function _5(t) {
  Qz(t, !0);
}
function Qz(t, e) {
  if ((t.f & Go) !== 0) {
    t.f ^= Go, (t.f & li) === 0 && (pi(t, mo), Rh(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, i = (r.f & Mh) !== 0 || (r.f & fu) !== 0;
      Qz(r, i ? e : !1), r = n;
    }
    if (t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || e) && o.in();
  }
}
function Jz(t, e) {
  for (var r = t.nodes_start, n = t.nodes_end; r !== null; ) {
    var i = r === n ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ dl(r)
    );
    e.append(r), r = i;
  }
}
const Yz = /* @__PURE__ */ new Set(), __ = /* @__PURE__ */ new Set();
function kke(t) {
  if (!Vt) return;
  t.removeAttribute("onload"), t.removeAttribute("onerror");
  const e = t.__e;
  e !== void 0 && (t.__e = void 0, queueMicrotask(() => {
    t.isConnected && t.dispatchEvent(e);
  }));
}
function Cke(t, e, r, n = {}) {
  function i(o) {
    if (n.capture || _m.call(e, o), !o.cancelBubble)
      return w5(() => r?.call(this, o));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? Zh(() => {
    e.addEventListener(t, i, n);
  }) : e.addEventListener(t, i, n), i;
}
function Wd(t, e, r, n, i) {
  var o = { capture: n, passive: i }, s = Cke(t, e, r, o);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && Hz(() => {
    e.removeEventListener(t, s, o);
  });
}
function mu(t) {
  for (var e = 0; e < t.length; e++)
    Yz.add(t[e]);
  for (var r of __)
    r(t);
}
let qO = null;
function _m(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, i = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  qO = t;
  var s = 0, a = qO === t && t.__root;
  if (a) {
    var l = i.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    l <= u && (s = l);
  }
  if (o = /** @type {Element} */
  i[s] || t.target, o !== e) {
    uz(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = er, h = nr;
    oo(null), il(null);
    try {
      for (var d, p = []; o !== null; ) {
        var g = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var v = o["__" + n];
          v != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && v.call(o, t);
        } catch (y) {
          d ? p.push(y) : d = y;
        }
        if (t.cancelBubble || g === e || g === null)
          break;
        o = g;
      }
      if (d) {
        for (let y of p)
          queueMicrotask(() => {
            throw y;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, oo(c), il(h);
    }
  }
}
function _ke(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function dd(t, e) {
  var r = (
    /** @type {Effect} */
    nr
  );
  r.nodes_start === null && (r.nodes_start = t, r.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function ur(t, e) {
  var r = (e & W2e) !== 0, n = (e & G2e) !== 0, i, o = !t.startsWith("<!>");
  return () => {
    if (Vt)
      return dd(pr, null), pr;
    i === void 0 && (i = _ke(o ? t : "<!>" + t), r || (i = /** @type {Node} */
    /* @__PURE__ */ Ph(i)));
    var s = (
      /** @type {TemplateNode} */
      n || Cz ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Ph(s)
      ), l = (
        /** @type {TemplateNode} */
        s.lastChild
      );
      dd(a, l);
    } else
      dd(s, s);
    return s;
  };
}
function jc() {
  if (Vt)
    return dd(pr, null), pr;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = nl();
  return t.append(e, r), dd(e, r), t;
}
function Pt(t, e) {
  if (Vt) {
    var r = (
      /** @type {Effect} */
      nr
    );
    ((r.f & Ux) === 0 || r.nodes_end === null) && (r.nodes_end = pr), S0();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
const Ske = ["touchstart", "touchmove"];
function Ake(t) {
  return Ske.includes(t);
}
function pl(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function Zz(t, e) {
  return ej(t, e);
}
function Eke(t, e) {
  x_(), e.intro = e.intro ?? !1;
  const r = e.target, n = Vt, i = pr;
  try {
    for (var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Ph(r)
    ); o && (o.nodeType !== kp || /** @type {Comment} */
    o.data !== yz); )
      o = /** @type {TemplateNode} */
      /* @__PURE__ */ dl(o);
    if (!o)
      throw qd;
    Ul(!0), ao(
      /** @type {Comment} */
      o
    );
    const s = ej(t, { ...e, anchor: o });
    return Ul(!1), /**  @type {Exports} */
    s;
  } catch (s) {
    if (s instanceof Error && s.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw s;
    return s !== qd && console.warn("Failed to hydrate: ", s), e.recover === !1 && I2e(), x_(), Az(r), Ul(!1), Zz(t, e);
  } finally {
    Ul(n), ao(i);
  }
}
const _f = /* @__PURE__ */ new Map();
function ej(t, { target: e, anchor: r, props: n = {}, events: i, context: o, intro: s = !0 }) {
  x_();
  var a = /* @__PURE__ */ new Set(), l = (h) => {
    for (var d = 0; d < h.length; d++) {
      var p = h[d];
      if (!a.has(p)) {
        a.add(p);
        var g = Ake(p);
        e.addEventListener(p, _m, { passive: g });
        var v = _f.get(p);
        v === void 0 ? (document.addEventListener(p, _m, { passive: g }), _f.set(p, 1)) : _f.set(p, v + 1);
      }
    }
  };
  l(g5(Yz)), __.add(l);
  var u = void 0, c = yke(() => {
    var h = r ?? e.appendChild(nl());
    return ike(
      /** @type {TemplateNode} */
      h,
      {
        pending: () => {
        }
      },
      (d) => {
        if (o) {
          on({});
          var p = (
            /** @type {ComponentContext} */
            Zr
          );
          p.c = o;
        }
        if (i && (n.$$events = i), Vt && dd(
          /** @type {TemplateNode} */
          d,
          null
        ), u = t(d, n) || {}, Vt && (nr.nodes_end = pr, pr === null || pr.nodeType !== kp || /** @type {Comment} */
        pr.data !== b5))
          throw Wx(), qd;
        o && sn();
      }
    ), () => {
      for (var d of a) {
        e.removeEventListener(d, _m);
        var p = (
          /** @type {number} */
          _f.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, _m), _f.delete(d)) : _f.set(d, p);
      }
      __.delete(l), h !== r && h.parentNode?.removeChild(h);
    };
  });
  return S_.set(u, c), u;
}
let S_ = /* @__PURE__ */ new WeakMap();
function Dke(t, e) {
  const r = S_.get(t);
  return r ? (S_.delete(t), r(e)) : Promise.resolve();
}
function Oke(t) {
  return new Fke(t);
}
class Fke {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, s) => {
      var a = /* @__PURE__ */ Nz(s, !1, !1);
      return r.set(o, a), a;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, s) {
          return q(r.get(s) ?? n(s, Reflect.get(o, s)));
        },
        has(o, s) {
          return s === lz ? !0 : (q(r.get(s) ?? n(s, Reflect.get(o, s))), Reflect.has(o, s));
        },
        set(o, s, a) {
          return be(r.get(s) ?? n(s, a), a), Reflect.set(o, s, a);
        }
      }
    );
    this.#t = (e.hydrate ? Eke : Zz)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && eke(), this.#e = i.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || uz(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(s) {
          this.#t[o] = s;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(i, o);
    }, this.#t.$destroy = () => {
      Dke(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...i) => r.call(this, ...i);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const Tke = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(Tke);
class S5 {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #r = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#n = r;
  }
  #l = () => {
    var e = (
      /** @type {Batch} */
      An
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        _5(n);
      else {
        var i = this.#r.get(r);
        i && (this.#t.set(r, i.effect), this.#r.delete(r), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), n = i.effect);
      }
      for (const [o, s] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(s);
        a && (Li(a.effect), this.#r.delete(s));
      }
      for (const [o, s] of this.#t) {
        if (o === r) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var l = document.createDocumentFragment();
            Jz(s, l), l.append(nl()), this.#r.set(o, { effect: s, fragment: l });
          } else
            Li(s);
          this.#t.delete(o);
        };
        this.#n || !n ? fd(s, a, !1) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #a = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, i] of this.#r)
      r.includes(n) || (Li(i.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      An
    );
    r && !this.#t.has(e) && !this.#r.has(e) && this.#t.set(
      e,
      Ls(() => r(this.anchor))
    ), this.#e.set(n, e), Vt && (this.anchor = pr), this.#l();
  }
}
function A5(t, e, ...r) {
  var n = new S5(t);
  O0(() => {
    const i = e() ?? null;
    n.ensure(i, i && ((o) => i(o, ...r)));
  }, Mh);
}
function _p(t) {
  Zr === null && gz(), _0 && Zr.l !== null ? Mke(Zr).m.push(t) : Qr(() => {
    const e = E0(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function Mke(t) {
  var e = (
    /** @type {ComponentContextLegacy} */
    t.l
  );
  return e.u ??= { a: [], b: [], m: [] };
}
function Ji(t, e, r = !1) {
  Vt && S0();
  var n = new S5(t), i = r ? Mh : 0;
  function o(s, a) {
    if (Vt) {
      const u = kz(t) === Vx;
      if (s === u) {
        var l = bb();
        ao(l), n.anchor = l, Ul(!1), n.ensure(s, a), Ul(!0);
        return;
      }
    }
    n.ensure(s, a);
  }
  O0(() => {
    var s = !1;
    e((a, l = !0) => {
      s = !0, o(l, a);
    }), s || o(!1, null);
  }, i);
}
function Pke(t, e, r) {
  Vt && S0();
  var n = new S5(t), i = !Cp();
  O0(() => {
    var o = e();
    i && o !== null && typeof o == "object" && (o = /** @type {V} */
    {}), n.ensure(o, r);
  });
}
function Rke(t, e) {
  return e;
}
function Nke(t, e, r) {
  for (var n = t.items, i = [], o = e.length, s = 0; s < o; s++)
    C5(e[s].e, i, !0);
  var a = o > 0 && i.length === 0 && r !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      r.parentNode
    );
    Az(l), l.append(
      /** @type {Element} */
      r
    ), n.clear(), Ca(t, e[0].prev, e[o - 1].next);
  }
  Xz(i, () => {
    for (var u = 0; u < o; u++) {
      var c = e[u];
      a || (n.delete(c.k), Ca(t, c.prev, c.next)), Li(c.e, !a);
    }
  });
}
function Vm(t, e, r, n, i, o = null) {
  var s = t, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & vz) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    s = Vt ? ao(
      /** @type {Comment | Text} */
      /* @__PURE__ */ Ph(u)
    ) : u.appendChild(nl());
  }
  Vt && S0();
  var c = null, h = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ Tz(() => {
    var b = r();
    return m5(b) ? b : b == null ? [] : g5(b);
  }), g, v;
  function y() {
    $ke(
      v,
      g,
      a,
      d,
      s,
      i,
      e,
      n,
      r
    ), o !== null && (g.length === 0 ? c ? _5(c) : c = Ls(() => o(s)) : c !== null && fd(c, () => {
      c = null;
    }));
  }
  O0(() => {
    v ??= /** @type {Effect} */
    nr, g = /** @type {V[]} */
    q(p);
    var b = g.length;
    if (h && b === 0)
      return;
    h = b === 0;
    let k = !1;
    if (Vt) {
      var C = kz(s) === Vx;
      C !== (b === 0) && (s = bb(), ao(s), Ul(!1), k = !0);
    }
    if (Vt) {
      for (var S = null, _, D = 0; D < b; D++) {
        if (pr.nodeType === kp && /** @type {Comment} */
        pr.data === b5) {
          s = /** @type {Comment} */
          pr, k = !0, Ul(!1);
          break;
        }
        var A = g[D], O = n(A, D);
        _ = tj(
          pr,
          a,
          S,
          null,
          A,
          O,
          D,
          i,
          e,
          r
        ), a.items.set(O, _), S = _;
      }
      b > 0 && ao(bb());
    }
    Vt ? b === 0 && o && (c = Ls(() => o(s))) : y(), k && Ul(!0), q(p);
  }), Vt && (s = pr);
}
function $ke(t, e, r, n, i, o, s, a, l) {
  var u = (s & H2e) !== 0, c = (s & (v5 | y5)) !== 0, h = e.length, d = r.items, p = r.first, g = p, v, y = null, b, k = [], C = [], S, _, D, A;
  if (u)
    for (A = 0; A < h; A += 1)
      S = e[A], _ = a(S, A), D = d.get(_), D !== void 0 && (D.a?.measure(), (b ??= /* @__PURE__ */ new Set()).add(D));
  for (A = 0; A < h; A += 1) {
    if (S = e[A], _ = a(S, A), D = d.get(_), D === void 0) {
      var O = n.get(_);
      if (O !== void 0) {
        n.delete(_), d.set(_, O);
        var M = y ? y.next : g;
        Ca(r, y, O), Ca(r, O, M), Bk(O, M, i), y = O;
      } else {
        var z = g ? (
          /** @type {TemplateNode} */
          g.e.nodes_start
        ) : i;
        y = tj(
          z,
          r,
          y,
          y === null ? r.first : y.next,
          S,
          _,
          A,
          o,
          s,
          l
        );
      }
      d.set(_, y), k = [], C = [], g = y.next;
      continue;
    }
    if (c && Ike(D, S, A, s), (D.e.f & Go) !== 0 && (_5(D.e), u && (D.a?.unfix(), (b ??= /* @__PURE__ */ new Set()).delete(D))), D !== g) {
      if (v !== void 0 && v.has(D)) {
        if (k.length < C.length) {
          var N = C[0], P;
          y = N.prev;
          var I = k[0], B = k[k.length - 1];
          for (P = 0; P < k.length; P += 1)
            Bk(k[P], N, i);
          for (P = 0; P < C.length; P += 1)
            v.delete(C[P]);
          Ca(r, I.prev, B.next), Ca(r, y, I), Ca(r, B, N), g = N, y = B, A -= 1, k = [], C = [];
        } else
          v.delete(D), Bk(D, g, i), Ca(r, D.prev, D.next), Ca(r, D, y === null ? r.first : y.next), Ca(r, y, D), y = D;
        continue;
      }
      for (k = [], C = []; g !== null && g.k !== _; )
        (g.e.f & Go) === 0 && (v ??= /* @__PURE__ */ new Set()).add(g), C.push(g), g = g.next;
      if (g === null)
        continue;
      D = g;
    }
    k.push(D), y = D, g = D.next;
  }
  if (g !== null || v !== void 0) {
    for (var $ = v === void 0 ? [] : g5(v); g !== null; )
      (g.e.f & Go) === 0 && $.push(g), g = g.next;
    var j = $.length;
    if (j > 0) {
      var U = (s & vz) !== 0 && h === 0 ? i : null;
      if (u) {
        for (A = 0; A < j; A += 1)
          $[A].a?.measure();
        for (A = 0; A < j; A += 1)
          $[A].a?.fix();
      }
      Nke(r, $, U);
    }
  }
  u && Zh(() => {
    if (b !== void 0)
      for (D of b)
        D.a?.apply();
  }), t.first = r.first && r.first.e, t.last = y && y.e;
  for (var H of n.values())
    Li(H.e);
  n.clear();
}
function Ike(t, e, r, n) {
  (n & v5) !== 0 && Vd(t.v, e), (n & y5) !== 0 ? Vd(
    /** @type {Value<number>} */
    t.i,
    r
  ) : t.i = r;
}
function tj(t, e, r, n, i, o, s, a, l, u, c) {
  var h = (l & v5) !== 0, d = (l & V2e) === 0, p = h ? d ? /* @__PURE__ */ Nz(i, !1, !1) : Nh(i) : i, g = (l & y5) === 0 ? s : Nh(s), v = {
    i: g,
    v: p,
    k: o,
    a: null,
    // @ts-expect-error
    e: null,
    prev: r,
    next: n
  };
  try {
    if (t === null) {
      var y = document.createDocumentFragment();
      y.append(t = nl());
    }
    return v.e = Ls(() => a(
      /** @type {Node} */
      t,
      p,
      g,
      u
    ), Vt), v.e.prev = r && r.e, v.e.next = n && n.e, r === null ? c || (e.first = v) : (r.next = v, r.e.next = v.e), n !== null && (n.prev = v, n.e.prev = v.e), v;
  } finally {
  }
}
function Bk(t, e, r) {
  for (var n = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : r, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : r, o = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); o !== null && o !== n; ) {
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ dl(o)
    );
    i.before(o), o = s;
  }
}
function Ca(t, e, r) {
  e === null ? t.first = r : (e.next = r, e.e.next = r && r.e), r !== null && (r.prev = e, r.e.prev = e && e.e);
}
function an(t, e) {
  D0(() => {
    var r = t.getRootNode(), n = (
      /** @type {ShadowRoot} */
      r.host ? (
        /** @type {ShadowRoot} */
        r
      ) : (
        /** @type {Document} */
        r.head ?? /** @type {Document} */
        r.ownerDocument.head
      )
    );
    if (!n.querySelector("#" + e.hash)) {
      const i = document.createElement("style");
      i.id = e.hash, i.textContent = e.code, n.appendChild(i);
    }
  });
}
function E5(t, e, r) {
  D0(() => {
    var n = E0(() => e(t, r?.()) || {});
    if (r && n?.update) {
      var i = !1, o = (
        /** @type {any} */
        {}
      );
      k5(() => {
        var s = r();
        mke(s), i && pz(o, s) && (o = s, n.update(s));
      }), i = !0;
    }
    if (n?.destroy)
      return () => (
        /** @type {Function} */
        n.destroy()
      );
  });
}
function Bke(t, e, r) {
  var n = t == null ? "" : "" + t;
  return e && (n = n ? n + " " + e : e), n === "" ? null : n;
}
function UO(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var i in t) {
    var o = t[i];
    o != null && o !== "" && (n += " " + i + ": " + o + r);
  }
  return n;
}
function Lke(t, e) {
  if (e) {
    var r = "", n, i;
    return Array.isArray(e) ? (n = e[0], i = e[1]) : n = e, n && (r += UO(n)), i && (r += UO(i, !0)), r = r.trim(), r === "" ? null : r;
  }
  return String(t);
}
function dc(t, e, r, n, i, o) {
  var s = t.__className;
  if (Vt || s !== r || s === void 0) {
    var a = Bke(r, n);
    (!Vt || a !== t.getAttribute("class")) && (a == null ? t.removeAttribute("class") : t.className = a), t.__className = r;
  }
  return o;
}
function Lk(t, e = {}, r, n) {
  for (var i in r) {
    var o = r[i];
    e[i] !== o && (r[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, o, n));
  }
}
function go(t, e, r, n) {
  var i = t.__style;
  if (Vt || i !== e) {
    var o = Lke(e, n);
    (!Vt || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (Lk(t, r?.[0], n[0]), Lk(t, r?.[1], n[1], "important")) : Lk(t, r, n));
  return n;
}
const zke = Symbol("is custom element"), jke = Symbol("is html");
function qke(t) {
  if (Vt) {
    var e = !1, r = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var n = t.value;
          Wg(t, "value", null), t.value = n;
        }
        if (t.hasAttribute("checked")) {
          var i = t.checked;
          Wg(t, "checked", null), t.checked = i;
        }
      }
    };
    t.__on_r = r, Zh(r), hke();
  }
}
function Uke(t, e) {
  var r = rj(t);
  r.checked !== (r.checked = // treat null and undefined the same for the initial value
  e ?? void 0) && (t.checked = e);
}
function Wg(t, e, r, n) {
  var i = rj(t);
  Vt && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = r) && (e === "loading" && (t[E2e] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && Hke(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function rj(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [zke]: t.nodeName.includes("-"),
      [jke]: t.namespaceURI === K2e
    }
  );
}
var HO = /* @__PURE__ */ new Map();
function Hke(t) {
  var e = t.getAttribute("is") || t.nodeName, r = HO.get(e);
  if (r) return r;
  HO.set(e, r = []);
  for (var n, i = t, o = Element.prototype; o !== i; ) {
    n = cz(i);
    for (var s in n)
      n[s].set && r.push(s);
    i = Hx(i);
  }
  return r;
}
class D5 {
  /** */
  #e = /* @__PURE__ */ new WeakMap();
  /** @type {ResizeObserver | undefined} */
  #t;
  /** @type {ResizeObserverOptions} */
  #r;
  /** @static */
  static entries = /* @__PURE__ */ new WeakMap();
  /** @param {ResizeObserverOptions} options */
  constructor(e) {
    this.#r = e;
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(e, r) {
    var n = this.#e.get(e) || /* @__PURE__ */ new Set();
    return n.add(r), this.#e.set(e, n), this.#n().observe(e, this.#r), () => {
      var i = this.#e.get(e);
      i.delete(r), i.size === 0 && (this.#e.delete(e), this.#t.unobserve(e));
    };
  }
  #n() {
    return this.#t ?? (this.#t = new ResizeObserver(
      /** @param {any} entries */
      (e) => {
        for (var r of e) {
          D5.entries.set(r.target, r);
          for (var n of this.#e.get(r.target) || [])
            n(r);
        }
      }
    ));
  }
}
var Vke = /* @__PURE__ */ new D5({
  box: "border-box"
});
function na(t, e, r) {
  var n = Vke.observe(t, () => r(t[e]));
  D0(() => (E0(() => r(t[e])), n));
}
function VO(t, e) {
  return t === e || t?.[ph] === e;
}
function zi(t = {}, e, r, n) {
  return D0(() => {
    var i, o;
    return k5(() => {
      i = o, o = [], E0(() => {
        t !== r(...o) && (e(t, ...o), i && VO(r(...i), t) && e(null, ...i));
      });
    }), () => {
      Zh(() => {
        o && VO(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
let Sy = !1;
function Wke(t) {
  var e = Sy;
  try {
    return Sy = !1, [t(), Sy];
  } finally {
    Sy = e;
  }
}
function Sp(t, e, r, n) {
  var i = (
    /** @type {V} */
    n
  ), o = !0, s = () => (o && (o = !1, i = /** @type {V} */
  n), i), a;
  {
    var l = ph in t || lz in t;
    a = hd(t, e)?.set ?? (l && e in t ? (y) => t[e] = y : void 0);
  }
  var u, c = !1;
  [u, c] = Wke(() => (
    /** @type {V} */
    t[e]
  ));
  var h;
  if (h = () => {
    var y = (
      /** @type {V} */
      t[e]
    );
    return y === void 0 ? s() : (o = !0, y);
  }, a) {
    var d = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(y, b) {
        return arguments.length > 0 ? ((!b || d || c) && a(b ? h() : y), y) : h();
      })
    );
  }
  var p = !1, g = /* @__PURE__ */ Kx(() => (p = !1, h()));
  q(g);
  var v = (
    /** @type {Effect} */
    nr
  );
  return (
    /** @type {() => V} */
    (function(y, b) {
      if (arguments.length > 0) {
        const k = b ? q(g) : ui(y);
        return be(g, k), p = !0, i !== void 0 && (i = k), y;
      }
      return ef && p || (v.f & Zu) !== 0 ? g.v : q(g);
    })
  );
}
var zu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function O5(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var e1 = { exports: {} }, Gke = e1.exports, WO;
function Kke() {
  return WO || (WO = 1, (function(t, e) {
    (function() {
      var r, n = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", a = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", u = 500, c = "__lodash_placeholder__", h = 1, d = 2, p = 4, g = 1, v = 2, y = 1, b = 2, k = 4, C = 8, S = 16, _ = 32, D = 64, A = 128, O = 256, M = 512, z = 30, N = "...", P = 800, I = 16, B = 1, $ = 2, j = 3, U = 1 / 0, H = 9007199254740991, G = 17976931348623157e292, re = NaN, ne = 4294967295, se = ne - 1, ie = ne >>> 1, ce = [
        ["ary", A],
        ["bind", y],
        ["bindKey", b],
        ["curry", C],
        ["curryRight", S],
        ["flip", M],
        ["partial", _],
        ["partialRight", D],
        ["rearg", O]
      ], Ce = "[object Arguments]", Me = "[object Array]", Pe = "[object AsyncFunction]", Ae = "[object Boolean]", he = "[object Date]", we = "[object DOMException]", ve = "[object Error]", Ge = "[object Function]", Xe = "[object GeneratorFunction]", et = "[object Map]", Qe = "[object Number]", Wt = "[object Null]", At = "[object Object]", Xt = "[object Promise]", Nt = "[object Proxy]", Ve = "[object RegExp]", Ze = "[object Set]", Bt = "[object String]", Qt = "[object Symbol]", Sr = "[object Undefined]", pt = "[object WeakMap]", _e = "[object WeakSet]", tt = "[object ArrayBuffer]", Ft = "[object DataView]", mr = "[object Float32Array]", Tt = "[object Float64Array]", Et = "[object Int8Array]", Ar = "[object Int16Array]", Ut = "[object Int32Array]", ln = "[object Uint8Array]", wi = "[object Uint8ClampedArray]", ua = "[object Uint16Array]", ml = "[object Uint32Array]", $r = /\b__p \+= '';/g, Qn = /\b(__p \+=) '' \+/g, Yo = /(__e\(.*?\)|\b__t\)) \+\n'';/g, yo = /&(?:amp|lt|gt|quot|#39);/g, Es = /[&<>"']/g, wc = RegExp(yo.source), Ap = RegExp(Es.source), ca = /<%-([\s\S]+?)%>/g, F0 = /<%([\s\S]+?)%>/g, T0 = /<%=([\s\S]+?)%>/g, M0 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Qx = /^\w*$/, P0 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ep = /[\\^$.*+?()[\]{}|]/g, Jx = RegExp(Ep.source), Dp = /^\s+/, R0 = /\s/, Yx = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Zx = /\{\n\/\* \[wrapped with (.+)\] \*/, ew = /,? & /, xe = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Te = /[()=,{}\[\]\/\s]/, ze = /\\(\\)?/g, We = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Je = /\w*$/, ut = /^[-+]0x[0-9a-f]+$/i, Gt = /^0b[01]+$/i, gr = /^\[object .+?Constructor\]$/, Er = /^0o[0-7]+$/i, un = /^(?:0|[1-9]\d*)$/, Zo = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Tn = /($^)/, bo = /['\n\r\u2028\u2029\\]/g, Ds = "\\ud800-\\udfff", Op = "\\u0300-\\u036f", Os = "\\ufe20-\\ufe2f", gl = "\\u20d0-\\u20ff", vl = Op + Os + gl, T5 = "\\u2700-\\u27bf", M5 = "a-z\\xdf-\\xf6\\xf8-\\xff", dj = "\\xac\\xb1\\xd7\\xf7", pj = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", mj = "\\u2000-\\u206f", gj = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", P5 = "A-Z\\xc0-\\xd6\\xd8-\\xde", R5 = "\\ufe0e\\ufe0f", N5 = dj + pj + mj + gj, tw = "['â€™]", vj = "[" + Ds + "]", $5 = "[" + N5 + "]", N0 = "[" + vl + "]", I5 = "\\d+", yj = "[" + T5 + "]", B5 = "[" + M5 + "]", L5 = "[^" + Ds + N5 + I5 + T5 + M5 + P5 + "]", rw = "\\ud83c[\\udffb-\\udfff]", bj = "(?:" + N0 + "|" + rw + ")", z5 = "[^" + Ds + "]", nw = "(?:\\ud83c[\\udde6-\\uddff]){2}", iw = "[\\ud800-\\udbff][\\udc00-\\udfff]", tf = "[" + P5 + "]", j5 = "\\u200d", q5 = "(?:" + B5 + "|" + L5 + ")", xj = "(?:" + tf + "|" + L5 + ")", U5 = "(?:" + tw + "(?:d|ll|m|re|s|t|ve))?", H5 = "(?:" + tw + "(?:D|LL|M|RE|S|T|VE))?", V5 = bj + "?", W5 = "[" + R5 + "]?", wj = "(?:" + j5 + "(?:" + [z5, nw, iw].join("|") + ")" + W5 + V5 + ")*", kj = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Cj = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", G5 = W5 + V5 + wj, _j = "(?:" + [yj, nw, iw].join("|") + ")" + G5, Sj = "(?:" + [z5 + N0 + "?", N0, nw, iw, vj].join("|") + ")", Aj = RegExp(tw, "g"), Ej = RegExp(N0, "g"), ow = RegExp(rw + "(?=" + rw + ")|" + Sj + G5, "g"), Dj = RegExp([
        tf + "?" + B5 + "+" + U5 + "(?=" + [$5, tf, "$"].join("|") + ")",
        xj + "+" + H5 + "(?=" + [$5, tf + q5, "$"].join("|") + ")",
        tf + "?" + q5 + "+" + U5,
        tf + "+" + H5,
        Cj,
        kj,
        I5,
        _j
      ].join("|"), "g"), Oj = RegExp("[" + j5 + Ds + vl + R5 + "]"), Fj = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Tj = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], Mj = -1, Ir = {};
      Ir[mr] = Ir[Tt] = Ir[Et] = Ir[Ar] = Ir[Ut] = Ir[ln] = Ir[wi] = Ir[ua] = Ir[ml] = !0, Ir[Ce] = Ir[Me] = Ir[tt] = Ir[Ae] = Ir[Ft] = Ir[he] = Ir[ve] = Ir[Ge] = Ir[et] = Ir[Qe] = Ir[At] = Ir[Ve] = Ir[Ze] = Ir[Bt] = Ir[pt] = !1;
      var Mr = {};
      Mr[Ce] = Mr[Me] = Mr[tt] = Mr[Ft] = Mr[Ae] = Mr[he] = Mr[mr] = Mr[Tt] = Mr[Et] = Mr[Ar] = Mr[Ut] = Mr[et] = Mr[Qe] = Mr[At] = Mr[Ve] = Mr[Ze] = Mr[Bt] = Mr[Qt] = Mr[ln] = Mr[wi] = Mr[ua] = Mr[ml] = !0, Mr[ve] = Mr[Ge] = Mr[pt] = !1;
      var Pj = {
        // Latin-1 Supplement block.
        Ã€: "A",
        Ã: "A",
        Ã‚: "A",
        Ãƒ: "A",
        Ã„: "A",
        Ã…: "A",
        Ã : "a",
        Ã¡: "a",
        Ã¢: "a",
        Ã£: "a",
        Ã¤: "a",
        Ã¥: "a",
        Ã‡: "C",
        Ã§: "c",
        Ã: "D",
        Ã°: "d",
        Ãˆ: "E",
        Ã‰: "E",
        ÃŠ: "E",
        Ã‹: "E",
        Ã¨: "e",
        Ã©: "e",
        Ãª: "e",
        Ã«: "e",
        ÃŒ: "I",
        Ã: "I",
        ÃŽ: "I",
        Ã: "I",
        Ã¬: "i",
        Ã­: "i",
        Ã®: "i",
        Ã¯: "i",
        Ã‘: "N",
        Ã±: "n",
        Ã’: "O",
        Ã“: "O",
        Ã”: "O",
        Ã•: "O",
        Ã–: "O",
        Ã˜: "O",
        Ã²: "o",
        Ã³: "o",
        Ã´: "o",
        Ãµ: "o",
        Ã¶: "o",
        Ã¸: "o",
        Ã™: "U",
        Ãš: "U",
        Ã›: "U",
        Ãœ: "U",
        Ã¹: "u",
        Ãº: "u",
        Ã»: "u",
        Ã¼: "u",
        Ã: "Y",
        Ã½: "y",
        Ã¿: "y",
        Ã†: "Ae",
        Ã¦: "ae",
        Ãž: "Th",
        Ã¾: "th",
        ÃŸ: "ss",
        // Latin Extended-A block.
        Ä€: "A",
        Ä‚: "A",
        Ä„: "A",
        Ä: "a",
        Äƒ: "a",
        Ä…: "a",
        Ä†: "C",
        Äˆ: "C",
        ÄŠ: "C",
        ÄŒ: "C",
        Ä‡: "c",
        Ä‰: "c",
        Ä‹: "c",
        Ä: "c",
        ÄŽ: "D",
        Ä: "D",
        Ä: "d",
        Ä‘: "d",
        Ä’: "E",
        Ä”: "E",
        Ä–: "E",
        Ä˜: "E",
        Äš: "E",
        Ä“: "e",
        Ä•: "e",
        Ä—: "e",
        Ä™: "e",
        Ä›: "e",
        Äœ: "G",
        Äž: "G",
        Ä : "G",
        Ä¢: "G",
        Ä: "g",
        ÄŸ: "g",
        Ä¡: "g",
        Ä£: "g",
        Ä¤: "H",
        Ä¦: "H",
        Ä¥: "h",
        Ä§: "h",
        Ä¨: "I",
        Äª: "I",
        Ä¬: "I",
        Ä®: "I",
        Ä°: "I",
        Ä©: "i",
        Ä«: "i",
        Ä­: "i",
        Ä¯: "i",
        Ä±: "i",
        Ä´: "J",
        Äµ: "j",
        Ä¶: "K",
        Ä·: "k",
        Ä¸: "k",
        Ä¹: "L",
        Ä»: "L",
        Ä½: "L",
        Ä¿: "L",
        Å: "L",
        Äº: "l",
        Ä¼: "l",
        Ä¾: "l",
        Å€: "l",
        Å‚: "l",
        Åƒ: "N",
        Å…: "N",
        Å‡: "N",
        ÅŠ: "N",
        Å„: "n",
        Å†: "n",
        Åˆ: "n",
        Å‹: "n",
        ÅŒ: "O",
        ÅŽ: "O",
        Å: "O",
        Å: "o",
        Å: "o",
        Å‘: "o",
        Å”: "R",
        Å–: "R",
        Å˜: "R",
        Å•: "r",
        Å—: "r",
        Å™: "r",
        Åš: "S",
        Åœ: "S",
        Åž: "S",
        Å : "S",
        Å›: "s",
        Å: "s",
        ÅŸ: "s",
        Å¡: "s",
        Å¢: "T",
        Å¤: "T",
        Å¦: "T",
        Å£: "t",
        Å¥: "t",
        Å§: "t",
        Å¨: "U",
        Åª: "U",
        Å¬: "U",
        Å®: "U",
        Å°: "U",
        Å²: "U",
        Å©: "u",
        Å«: "u",
        Å­: "u",
        Å¯: "u",
        Å±: "u",
        Å³: "u",
        Å´: "W",
        Åµ: "w",
        Å¶: "Y",
        Å·: "y",
        Å¸: "Y",
        Å¹: "Z",
        Å»: "Z",
        Å½: "Z",
        Åº: "z",
        Å¼: "z",
        Å¾: "z",
        Ä²: "IJ",
        Ä³: "ij",
        Å’: "Oe",
        Å“: "oe",
        Å‰: "'n",
        Å¿: "s"
      }, Rj = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, Nj = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, $j = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, Ij = parseFloat, Bj = parseInt, K5 = typeof zu == "object" && zu && zu.Object === Object && zu, Lj = typeof self == "object" && self && self.Object === Object && self, Un = K5 || Lj || Function("return this")(), sw = e && !e.nodeType && e, kc = sw && !0 && t && !t.nodeType && t, X5 = kc && kc.exports === sw, aw = X5 && K5.process, es = (function() {
        try {
          var Z = kc && kc.require && kc.require("util").types;
          return Z || aw && aw.binding && aw.binding("util");
        } catch {
        }
      })(), Q5 = es && es.isArrayBuffer, J5 = es && es.isDate, Y5 = es && es.isMap, Z5 = es && es.isRegExp, eA = es && es.isSet, tA = es && es.isTypedArray;
      function xo(Z, fe, ue) {
        switch (ue.length) {
          case 0:
            return Z.call(fe);
          case 1:
            return Z.call(fe, ue[0]);
          case 2:
            return Z.call(fe, ue[0], ue[1]);
          case 3:
            return Z.call(fe, ue[0], ue[1], ue[2]);
        }
        return Z.apply(fe, ue);
      }
      function zj(Z, fe, ue, Le) {
        for (var gt = -1, cr = Z == null ? 0 : Z.length; ++gt < cr; ) {
          var Cn = Z[gt];
          fe(Le, Cn, ue(Cn), Z);
        }
        return Le;
      }
      function ts(Z, fe) {
        for (var ue = -1, Le = Z == null ? 0 : Z.length; ++ue < Le && fe(Z[ue], ue, Z) !== !1; )
          ;
        return Z;
      }
      function jj(Z, fe) {
        for (var ue = Z == null ? 0 : Z.length; ue-- && fe(Z[ue], ue, Z) !== !1; )
          ;
        return Z;
      }
      function rA(Z, fe) {
        for (var ue = -1, Le = Z == null ? 0 : Z.length; ++ue < Le; )
          if (!fe(Z[ue], ue, Z))
            return !1;
        return !0;
      }
      function vu(Z, fe) {
        for (var ue = -1, Le = Z == null ? 0 : Z.length, gt = 0, cr = []; ++ue < Le; ) {
          var Cn = Z[ue];
          fe(Cn, ue, Z) && (cr[gt++] = Cn);
        }
        return cr;
      }
      function $0(Z, fe) {
        var ue = Z == null ? 0 : Z.length;
        return !!ue && rf(Z, fe, 0) > -1;
      }
      function lw(Z, fe, ue) {
        for (var Le = -1, gt = Z == null ? 0 : Z.length; ++Le < gt; )
          if (ue(fe, Z[Le]))
            return !0;
        return !1;
      }
      function jr(Z, fe) {
        for (var ue = -1, Le = Z == null ? 0 : Z.length, gt = Array(Le); ++ue < Le; )
          gt[ue] = fe(Z[ue], ue, Z);
        return gt;
      }
      function yu(Z, fe) {
        for (var ue = -1, Le = fe.length, gt = Z.length; ++ue < Le; )
          Z[gt + ue] = fe[ue];
        return Z;
      }
      function uw(Z, fe, ue, Le) {
        var gt = -1, cr = Z == null ? 0 : Z.length;
        for (Le && cr && (ue = Z[++gt]); ++gt < cr; )
          ue = fe(ue, Z[gt], gt, Z);
        return ue;
      }
      function qj(Z, fe, ue, Le) {
        var gt = Z == null ? 0 : Z.length;
        for (Le && gt && (ue = Z[--gt]); gt--; )
          ue = fe(ue, Z[gt], gt, Z);
        return ue;
      }
      function cw(Z, fe) {
        for (var ue = -1, Le = Z == null ? 0 : Z.length; ++ue < Le; )
          if (fe(Z[ue], ue, Z))
            return !0;
        return !1;
      }
      var Uj = hw("length");
      function Hj(Z) {
        return Z.split("");
      }
      function Vj(Z) {
        return Z.match(xe) || [];
      }
      function nA(Z, fe, ue) {
        var Le;
        return ue(Z, function(gt, cr, Cn) {
          if (fe(gt, cr, Cn))
            return Le = cr, !1;
        }), Le;
      }
      function I0(Z, fe, ue, Le) {
        for (var gt = Z.length, cr = ue + (Le ? 1 : -1); Le ? cr-- : ++cr < gt; )
          if (fe(Z[cr], cr, Z))
            return cr;
        return -1;
      }
      function rf(Z, fe, ue) {
        return fe === fe ? nq(Z, fe, ue) : I0(Z, iA, ue);
      }
      function Wj(Z, fe, ue, Le) {
        for (var gt = ue - 1, cr = Z.length; ++gt < cr; )
          if (Le(Z[gt], fe))
            return gt;
        return -1;
      }
      function iA(Z) {
        return Z !== Z;
      }
      function oA(Z, fe) {
        var ue = Z == null ? 0 : Z.length;
        return ue ? dw(Z, fe) / ue : re;
      }
      function hw(Z) {
        return function(fe) {
          return fe == null ? r : fe[Z];
        };
      }
      function fw(Z) {
        return function(fe) {
          return Z == null ? r : Z[fe];
        };
      }
      function sA(Z, fe, ue, Le, gt) {
        return gt(Z, function(cr, Cn, Dr) {
          ue = Le ? (Le = !1, cr) : fe(ue, cr, Cn, Dr);
        }), ue;
      }
      function Gj(Z, fe) {
        var ue = Z.length;
        for (Z.sort(fe); ue--; )
          Z[ue] = Z[ue].value;
        return Z;
      }
      function dw(Z, fe) {
        for (var ue, Le = -1, gt = Z.length; ++Le < gt; ) {
          var cr = fe(Z[Le]);
          cr !== r && (ue = ue === r ? cr : ue + cr);
        }
        return ue;
      }
      function pw(Z, fe) {
        for (var ue = -1, Le = Array(Z); ++ue < Z; )
          Le[ue] = fe(ue);
        return Le;
      }
      function Kj(Z, fe) {
        return jr(fe, function(ue) {
          return [ue, Z[ue]];
        });
      }
      function aA(Z) {
        return Z && Z.slice(0, hA(Z) + 1).replace(Dp, "");
      }
      function wo(Z) {
        return function(fe) {
          return Z(fe);
        };
      }
      function mw(Z, fe) {
        return jr(fe, function(ue) {
          return Z[ue];
        });
      }
      function Fp(Z, fe) {
        return Z.has(fe);
      }
      function lA(Z, fe) {
        for (var ue = -1, Le = Z.length; ++ue < Le && rf(fe, Z[ue], 0) > -1; )
          ;
        return ue;
      }
      function uA(Z, fe) {
        for (var ue = Z.length; ue-- && rf(fe, Z[ue], 0) > -1; )
          ;
        return ue;
      }
      function Xj(Z, fe) {
        for (var ue = Z.length, Le = 0; ue--; )
          Z[ue] === fe && ++Le;
        return Le;
      }
      var Qj = fw(Pj), Jj = fw(Rj);
      function Yj(Z) {
        return "\\" + $j[Z];
      }
      function Zj(Z, fe) {
        return Z == null ? r : Z[fe];
      }
      function nf(Z) {
        return Oj.test(Z);
      }
      function eq(Z) {
        return Fj.test(Z);
      }
      function tq(Z) {
        for (var fe, ue = []; !(fe = Z.next()).done; )
          ue.push(fe.value);
        return ue;
      }
      function gw(Z) {
        var fe = -1, ue = Array(Z.size);
        return Z.forEach(function(Le, gt) {
          ue[++fe] = [gt, Le];
        }), ue;
      }
      function cA(Z, fe) {
        return function(ue) {
          return Z(fe(ue));
        };
      }
      function bu(Z, fe) {
        for (var ue = -1, Le = Z.length, gt = 0, cr = []; ++ue < Le; ) {
          var Cn = Z[ue];
          (Cn === fe || Cn === c) && (Z[ue] = c, cr[gt++] = ue);
        }
        return cr;
      }
      function B0(Z) {
        var fe = -1, ue = Array(Z.size);
        return Z.forEach(function(Le) {
          ue[++fe] = Le;
        }), ue;
      }
      function rq(Z) {
        var fe = -1, ue = Array(Z.size);
        return Z.forEach(function(Le) {
          ue[++fe] = [Le, Le];
        }), ue;
      }
      function nq(Z, fe, ue) {
        for (var Le = ue - 1, gt = Z.length; ++Le < gt; )
          if (Z[Le] === fe)
            return Le;
        return -1;
      }
      function iq(Z, fe, ue) {
        for (var Le = ue + 1; Le--; )
          if (Z[Le] === fe)
            return Le;
        return Le;
      }
      function of(Z) {
        return nf(Z) ? sq(Z) : Uj(Z);
      }
      function Fs(Z) {
        return nf(Z) ? aq(Z) : Hj(Z);
      }
      function hA(Z) {
        for (var fe = Z.length; fe-- && R0.test(Z.charAt(fe)); )
          ;
        return fe;
      }
      var oq = fw(Nj);
      function sq(Z) {
        for (var fe = ow.lastIndex = 0; ow.test(Z); )
          ++fe;
        return fe;
      }
      function aq(Z) {
        return Z.match(ow) || [];
      }
      function lq(Z) {
        return Z.match(Dj) || [];
      }
      var uq = (function Z(fe) {
        fe = fe == null ? Un : sf.defaults(Un.Object(), fe, sf.pick(Un, Tj));
        var ue = fe.Array, Le = fe.Date, gt = fe.Error, cr = fe.Function, Cn = fe.Math, Dr = fe.Object, vw = fe.RegExp, cq = fe.String, rs = fe.TypeError, L0 = ue.prototype, hq = cr.prototype, af = Dr.prototype, z0 = fe["__core-js_shared__"], j0 = hq.toString, br = af.hasOwnProperty, fq = 0, fA = (function() {
          var f = /[^.]+$/.exec(z0 && z0.keys && z0.keys.IE_PROTO || "");
          return f ? "Symbol(src)_1." + f : "";
        })(), q0 = af.toString, dq = j0.call(Dr), pq = Un._, mq = vw(
          "^" + j0.call(br).replace(Ep, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), U0 = X5 ? fe.Buffer : r, xu = fe.Symbol, H0 = fe.Uint8Array, dA = U0 ? U0.allocUnsafe : r, V0 = cA(Dr.getPrototypeOf, Dr), pA = Dr.create, mA = af.propertyIsEnumerable, W0 = L0.splice, gA = xu ? xu.isConcatSpreadable : r, Tp = xu ? xu.iterator : r, Cc = xu ? xu.toStringTag : r, G0 = (function() {
          try {
            var f = Dc(Dr, "defineProperty");
            return f({}, "", {}), f;
          } catch {
          }
        })(), gq = fe.clearTimeout !== Un.clearTimeout && fe.clearTimeout, vq = Le && Le.now !== Un.Date.now && Le.now, yq = fe.setTimeout !== Un.setTimeout && fe.setTimeout, K0 = Cn.ceil, X0 = Cn.floor, yw = Dr.getOwnPropertySymbols, bq = U0 ? U0.isBuffer : r, vA = fe.isFinite, xq = L0.join, wq = cA(Dr.keys, Dr), _n = Cn.max, Jn = Cn.min, kq = Le.now, Cq = fe.parseInt, yA = Cn.random, _q = L0.reverse, bw = Dc(fe, "DataView"), Mp = Dc(fe, "Map"), xw = Dc(fe, "Promise"), lf = Dc(fe, "Set"), Pp = Dc(fe, "WeakMap"), Rp = Dc(Dr, "create"), Q0 = Pp && new Pp(), uf = {}, Sq = Oc(bw), Aq = Oc(Mp), Eq = Oc(xw), Dq = Oc(lf), Oq = Oc(Pp), J0 = xu ? xu.prototype : r, Np = J0 ? J0.valueOf : r, bA = J0 ? J0.toString : r;
        function R(f) {
          if (tn(f) && !yt(f) && !(f instanceof Lt)) {
            if (f instanceof ns)
              return f;
            if (br.call(f, "__wrapped__"))
              return xE(f);
          }
          return new ns(f);
        }
        var cf = /* @__PURE__ */ (function() {
          function f() {
          }
          return function(m) {
            if (!Kr(m))
              return {};
            if (pA)
              return pA(m);
            f.prototype = m;
            var w = new f();
            return f.prototype = r, w;
          };
        })();
        function Y0() {
        }
        function ns(f, m) {
          this.__wrapped__ = f, this.__actions__ = [], this.__chain__ = !!m, this.__index__ = 0, this.__values__ = r;
        }
        R.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: ca,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: F0,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: T0,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: R
          }
        }, R.prototype = Y0.prototype, R.prototype.constructor = R, ns.prototype = cf(Y0.prototype), ns.prototype.constructor = ns;
        function Lt(f) {
          this.__wrapped__ = f, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = ne, this.__views__ = [];
        }
        function Fq() {
          var f = new Lt(this.__wrapped__);
          return f.__actions__ = ji(this.__actions__), f.__dir__ = this.__dir__, f.__filtered__ = this.__filtered__, f.__iteratees__ = ji(this.__iteratees__), f.__takeCount__ = this.__takeCount__, f.__views__ = ji(this.__views__), f;
        }
        function Tq() {
          if (this.__filtered__) {
            var f = new Lt(this);
            f.__dir__ = -1, f.__filtered__ = !0;
          } else
            f = this.clone(), f.__dir__ *= -1;
          return f;
        }
        function Mq() {
          var f = this.__wrapped__.value(), m = this.__dir__, w = yt(f), E = m < 0, F = w ? f.length : 0, L = HU(0, F, this.__views__), V = L.start, X = L.end, ee = X - V, pe = E ? X : V - 1, ge = this.__iteratees__, ke = ge.length, Ne = 0, Ue = Jn(ee, this.__takeCount__);
          if (!w || !E && F == ee && Ue == ee)
            return UA(f, this.__actions__);
          var ot = [];
          e:
            for (; ee-- && Ne < Ue; ) {
              pe += m;
              for (var Dt = -1, st = f[pe]; ++Dt < ke; ) {
                var $t = ge[Dt], Ht = $t.iteratee, _o = $t.type, _i = Ht(st);
                if (_o == $)
                  st = _i;
                else if (!_i) {
                  if (_o == B)
                    continue e;
                  break e;
                }
              }
              ot[Ne++] = st;
            }
          return ot;
        }
        Lt.prototype = cf(Y0.prototype), Lt.prototype.constructor = Lt;
        function _c(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.clear(); ++m < w; ) {
            var E = f[m];
            this.set(E[0], E[1]);
          }
        }
        function Pq() {
          this.__data__ = Rp ? Rp(null) : {}, this.size = 0;
        }
        function Rq(f) {
          var m = this.has(f) && delete this.__data__[f];
          return this.size -= m ? 1 : 0, m;
        }
        function Nq(f) {
          var m = this.__data__;
          if (Rp) {
            var w = m[f];
            return w === l ? r : w;
          }
          return br.call(m, f) ? m[f] : r;
        }
        function $q(f) {
          var m = this.__data__;
          return Rp ? m[f] !== r : br.call(m, f);
        }
        function Iq(f, m) {
          var w = this.__data__;
          return this.size += this.has(f) ? 0 : 1, w[f] = Rp && m === r ? l : m, this;
        }
        _c.prototype.clear = Pq, _c.prototype.delete = Rq, _c.prototype.get = Nq, _c.prototype.has = $q, _c.prototype.set = Iq;
        function yl(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.clear(); ++m < w; ) {
            var E = f[m];
            this.set(E[0], E[1]);
          }
        }
        function Bq() {
          this.__data__ = [], this.size = 0;
        }
        function Lq(f) {
          var m = this.__data__, w = Z0(m, f);
          if (w < 0)
            return !1;
          var E = m.length - 1;
          return w == E ? m.pop() : W0.call(m, w, 1), --this.size, !0;
        }
        function zq(f) {
          var m = this.__data__, w = Z0(m, f);
          return w < 0 ? r : m[w][1];
        }
        function jq(f) {
          return Z0(this.__data__, f) > -1;
        }
        function qq(f, m) {
          var w = this.__data__, E = Z0(w, f);
          return E < 0 ? (++this.size, w.push([f, m])) : w[E][1] = m, this;
        }
        yl.prototype.clear = Bq, yl.prototype.delete = Lq, yl.prototype.get = zq, yl.prototype.has = jq, yl.prototype.set = qq;
        function bl(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.clear(); ++m < w; ) {
            var E = f[m];
            this.set(E[0], E[1]);
          }
        }
        function Uq() {
          this.size = 0, this.__data__ = {
            hash: new _c(),
            map: new (Mp || yl)(),
            string: new _c()
          };
        }
        function Hq(f) {
          var m = hv(this, f).delete(f);
          return this.size -= m ? 1 : 0, m;
        }
        function Vq(f) {
          return hv(this, f).get(f);
        }
        function Wq(f) {
          return hv(this, f).has(f);
        }
        function Gq(f, m) {
          var w = hv(this, f), E = w.size;
          return w.set(f, m), this.size += w.size == E ? 0 : 1, this;
        }
        bl.prototype.clear = Uq, bl.prototype.delete = Hq, bl.prototype.get = Vq, bl.prototype.has = Wq, bl.prototype.set = Gq;
        function Sc(f) {
          var m = -1, w = f == null ? 0 : f.length;
          for (this.__data__ = new bl(); ++m < w; )
            this.add(f[m]);
        }
        function Kq(f) {
          return this.__data__.set(f, l), this;
        }
        function Xq(f) {
          return this.__data__.has(f);
        }
        Sc.prototype.add = Sc.prototype.push = Kq, Sc.prototype.has = Xq;
        function Ts(f) {
          var m = this.__data__ = new yl(f);
          this.size = m.size;
        }
        function Qq() {
          this.__data__ = new yl(), this.size = 0;
        }
        function Jq(f) {
          var m = this.__data__, w = m.delete(f);
          return this.size = m.size, w;
        }
        function Yq(f) {
          return this.__data__.get(f);
        }
        function Zq(f) {
          return this.__data__.has(f);
        }
        function eU(f, m) {
          var w = this.__data__;
          if (w instanceof yl) {
            var E = w.__data__;
            if (!Mp || E.length < i - 1)
              return E.push([f, m]), this.size = ++w.size, this;
            w = this.__data__ = new bl(E);
          }
          return w.set(f, m), this.size = w.size, this;
        }
        Ts.prototype.clear = Qq, Ts.prototype.delete = Jq, Ts.prototype.get = Yq, Ts.prototype.has = Zq, Ts.prototype.set = eU;
        function xA(f, m) {
          var w = yt(f), E = !w && Fc(f), F = !w && !E && Su(f), L = !w && !E && !F && pf(f), V = w || E || F || L, X = V ? pw(f.length, cq) : [], ee = X.length;
          for (var pe in f)
            (m || br.call(f, pe)) && !(V && // Safari 9 has enumerable `arguments.length` in strict mode.
            (pe == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            F && (pe == "offset" || pe == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            L && (pe == "buffer" || pe == "byteLength" || pe == "byteOffset") || // Skip index properties.
            Cl(pe, ee))) && X.push(pe);
          return X;
        }
        function wA(f) {
          var m = f.length;
          return m ? f[Tw(0, m - 1)] : r;
        }
        function tU(f, m) {
          return fv(ji(f), Ac(m, 0, f.length));
        }
        function rU(f) {
          return fv(ji(f));
        }
        function ww(f, m, w) {
          (w !== r && !Ms(f[m], w) || w === r && !(m in f)) && xl(f, m, w);
        }
        function $p(f, m, w) {
          var E = f[m];
          (!(br.call(f, m) && Ms(E, w)) || w === r && !(m in f)) && xl(f, m, w);
        }
        function Z0(f, m) {
          for (var w = f.length; w--; )
            if (Ms(f[w][0], m))
              return w;
          return -1;
        }
        function nU(f, m, w, E) {
          return wu(f, function(F, L, V) {
            m(E, F, w(F), V);
          }), E;
        }
        function kA(f, m) {
          return f && fa(m, Mn(m), f);
        }
        function iU(f, m) {
          return f && fa(m, Ui(m), f);
        }
        function xl(f, m, w) {
          m == "__proto__" && G0 ? G0(f, m, {
            configurable: !0,
            enumerable: !0,
            value: w,
            writable: !0
          }) : f[m] = w;
        }
        function kw(f, m) {
          for (var w = -1, E = m.length, F = ue(E), L = f == null; ++w < E; )
            F[w] = L ? r : r2(f, m[w]);
          return F;
        }
        function Ac(f, m, w) {
          return f === f && (w !== r && (f = f <= w ? f : w), m !== r && (f = f >= m ? f : m)), f;
        }
        function is(f, m, w, E, F, L) {
          var V, X = m & h, ee = m & d, pe = m & p;
          if (w && (V = F ? w(f, E, F, L) : w(f)), V !== r)
            return V;
          if (!Kr(f))
            return f;
          var ge = yt(f);
          if (ge) {
            if (V = WU(f), !X)
              return ji(f, V);
          } else {
            var ke = Yn(f), Ne = ke == Ge || ke == Xe;
            if (Su(f))
              return WA(f, X);
            if (ke == At || ke == Ce || Ne && !F) {
              if (V = ee || Ne ? {} : hE(f), !X)
                return ee ? NU(f, iU(V, f)) : RU(f, kA(V, f));
            } else {
              if (!Mr[ke])
                return F ? f : {};
              V = GU(f, ke, X);
            }
          }
          L || (L = new Ts());
          var Ue = L.get(f);
          if (Ue)
            return Ue;
          L.set(f, V), zE(f) ? f.forEach(function(st) {
            V.add(is(st, m, w, st, f, L));
          }) : BE(f) && f.forEach(function(st, $t) {
            V.set($t, is(st, m, w, $t, f, L));
          });
          var ot = pe ? ee ? qw : jw : ee ? Ui : Mn, Dt = ge ? r : ot(f);
          return ts(Dt || f, function(st, $t) {
            Dt && ($t = st, st = f[$t]), $p(V, $t, is(st, m, w, $t, f, L));
          }), V;
        }
        function oU(f) {
          var m = Mn(f);
          return function(w) {
            return CA(w, f, m);
          };
        }
        function CA(f, m, w) {
          var E = w.length;
          if (f == null)
            return !E;
          for (f = Dr(f); E--; ) {
            var F = w[E], L = m[F], V = f[F];
            if (V === r && !(F in f) || !L(V))
              return !1;
          }
          return !0;
        }
        function _A(f, m, w) {
          if (typeof f != "function")
            throw new rs(s);
          return Up(function() {
            f.apply(r, w);
          }, m);
        }
        function Ip(f, m, w, E) {
          var F = -1, L = $0, V = !0, X = f.length, ee = [], pe = m.length;
          if (!X)
            return ee;
          w && (m = jr(m, wo(w))), E ? (L = lw, V = !1) : m.length >= i && (L = Fp, V = !1, m = new Sc(m));
          e:
            for (; ++F < X; ) {
              var ge = f[F], ke = w == null ? ge : w(ge);
              if (ge = E || ge !== 0 ? ge : 0, V && ke === ke) {
                for (var Ne = pe; Ne--; )
                  if (m[Ne] === ke)
                    continue e;
                ee.push(ge);
              } else L(m, ke, E) || ee.push(ge);
            }
          return ee;
        }
        var wu = JA(ha), SA = JA(_w, !0);
        function sU(f, m) {
          var w = !0;
          return wu(f, function(E, F, L) {
            return w = !!m(E, F, L), w;
          }), w;
        }
        function ev(f, m, w) {
          for (var E = -1, F = f.length; ++E < F; ) {
            var L = f[E], V = m(L);
            if (V != null && (X === r ? V === V && !Co(V) : w(V, X)))
              var X = V, ee = L;
          }
          return ee;
        }
        function aU(f, m, w, E) {
          var F = f.length;
          for (w = Ct(w), w < 0 && (w = -w > F ? 0 : F + w), E = E === r || E > F ? F : Ct(E), E < 0 && (E += F), E = w > E ? 0 : qE(E); w < E; )
            f[w++] = m;
          return f;
        }
        function AA(f, m) {
          var w = [];
          return wu(f, function(E, F, L) {
            m(E, F, L) && w.push(E);
          }), w;
        }
        function Hn(f, m, w, E, F) {
          var L = -1, V = f.length;
          for (w || (w = XU), F || (F = []); ++L < V; ) {
            var X = f[L];
            m > 0 && w(X) ? m > 1 ? Hn(X, m - 1, w, E, F) : yu(F, X) : E || (F[F.length] = X);
          }
          return F;
        }
        var Cw = YA(), EA = YA(!0);
        function ha(f, m) {
          return f && Cw(f, m, Mn);
        }
        function _w(f, m) {
          return f && EA(f, m, Mn);
        }
        function tv(f, m) {
          return vu(m, function(w) {
            return _l(f[w]);
          });
        }
        function Ec(f, m) {
          m = Cu(m, f);
          for (var w = 0, E = m.length; f != null && w < E; )
            f = f[da(m[w++])];
          return w && w == E ? f : r;
        }
        function DA(f, m, w) {
          var E = m(f);
          return yt(f) ? E : yu(E, w(f));
        }
        function ki(f) {
          return f == null ? f === r ? Sr : Wt : Cc && Cc in Dr(f) ? UU(f) : rH(f);
        }
        function Sw(f, m) {
          return f > m;
        }
        function lU(f, m) {
          return f != null && br.call(f, m);
        }
        function uU(f, m) {
          return f != null && m in Dr(f);
        }
        function cU(f, m, w) {
          return f >= Jn(m, w) && f < _n(m, w);
        }
        function Aw(f, m, w) {
          for (var E = w ? lw : $0, F = f[0].length, L = f.length, V = L, X = ue(L), ee = 1 / 0, pe = []; V--; ) {
            var ge = f[V];
            V && m && (ge = jr(ge, wo(m))), ee = Jn(ge.length, ee), X[V] = !w && (m || F >= 120 && ge.length >= 120) ? new Sc(V && ge) : r;
          }
          ge = f[0];
          var ke = -1, Ne = X[0];
          e:
            for (; ++ke < F && pe.length < ee; ) {
              var Ue = ge[ke], ot = m ? m(Ue) : Ue;
              if (Ue = w || Ue !== 0 ? Ue : 0, !(Ne ? Fp(Ne, ot) : E(pe, ot, w))) {
                for (V = L; --V; ) {
                  var Dt = X[V];
                  if (!(Dt ? Fp(Dt, ot) : E(f[V], ot, w)))
                    continue e;
                }
                Ne && Ne.push(ot), pe.push(Ue);
              }
            }
          return pe;
        }
        function hU(f, m, w, E) {
          return ha(f, function(F, L, V) {
            m(E, w(F), L, V);
          }), E;
        }
        function Bp(f, m, w) {
          m = Cu(m, f), f = mE(f, m);
          var E = f == null ? f : f[da(ss(m))];
          return E == null ? r : xo(E, f, w);
        }
        function OA(f) {
          return tn(f) && ki(f) == Ce;
        }
        function fU(f) {
          return tn(f) && ki(f) == tt;
        }
        function dU(f) {
          return tn(f) && ki(f) == he;
        }
        function Lp(f, m, w, E, F) {
          return f === m ? !0 : f == null || m == null || !tn(f) && !tn(m) ? f !== f && m !== m : pU(f, m, w, E, Lp, F);
        }
        function pU(f, m, w, E, F, L) {
          var V = yt(f), X = yt(m), ee = V ? Me : Yn(f), pe = X ? Me : Yn(m);
          ee = ee == Ce ? At : ee, pe = pe == Ce ? At : pe;
          var ge = ee == At, ke = pe == At, Ne = ee == pe;
          if (Ne && Su(f)) {
            if (!Su(m))
              return !1;
            V = !0, ge = !1;
          }
          if (Ne && !ge)
            return L || (L = new Ts()), V || pf(f) ? lE(f, m, w, E, F, L) : jU(f, m, ee, w, E, F, L);
          if (!(w & g)) {
            var Ue = ge && br.call(f, "__wrapped__"), ot = ke && br.call(m, "__wrapped__");
            if (Ue || ot) {
              var Dt = Ue ? f.value() : f, st = ot ? m.value() : m;
              return L || (L = new Ts()), F(Dt, st, w, E, L);
            }
          }
          return Ne ? (L || (L = new Ts()), qU(f, m, w, E, F, L)) : !1;
        }
        function mU(f) {
          return tn(f) && Yn(f) == et;
        }
        function Ew(f, m, w, E) {
          var F = w.length, L = F, V = !E;
          if (f == null)
            return !L;
          for (f = Dr(f); F--; ) {
            var X = w[F];
            if (V && X[2] ? X[1] !== f[X[0]] : !(X[0] in f))
              return !1;
          }
          for (; ++F < L; ) {
            X = w[F];
            var ee = X[0], pe = f[ee], ge = X[1];
            if (V && X[2]) {
              if (pe === r && !(ee in f))
                return !1;
            } else {
              var ke = new Ts();
              if (E)
                var Ne = E(pe, ge, ee, f, m, ke);
              if (!(Ne === r ? Lp(ge, pe, g | v, E, ke) : Ne))
                return !1;
            }
          }
          return !0;
        }
        function FA(f) {
          if (!Kr(f) || JU(f))
            return !1;
          var m = _l(f) ? mq : gr;
          return m.test(Oc(f));
        }
        function gU(f) {
          return tn(f) && ki(f) == Ve;
        }
        function vU(f) {
          return tn(f) && Yn(f) == Ze;
        }
        function yU(f) {
          return tn(f) && yv(f.length) && !!Ir[ki(f)];
        }
        function TA(f) {
          return typeof f == "function" ? f : f == null ? Hi : typeof f == "object" ? yt(f) ? RA(f[0], f[1]) : PA(f) : ZE(f);
        }
        function Dw(f) {
          if (!qp(f))
            return wq(f);
          var m = [];
          for (var w in Dr(f))
            br.call(f, w) && w != "constructor" && m.push(w);
          return m;
        }
        function bU(f) {
          if (!Kr(f))
            return tH(f);
          var m = qp(f), w = [];
          for (var E in f)
            E == "constructor" && (m || !br.call(f, E)) || w.push(E);
          return w;
        }
        function Ow(f, m) {
          return f < m;
        }
        function MA(f, m) {
          var w = -1, E = qi(f) ? ue(f.length) : [];
          return wu(f, function(F, L, V) {
            E[++w] = m(F, L, V);
          }), E;
        }
        function PA(f) {
          var m = Hw(f);
          return m.length == 1 && m[0][2] ? dE(m[0][0], m[0][1]) : function(w) {
            return w === f || Ew(w, f, m);
          };
        }
        function RA(f, m) {
          return Ww(f) && fE(m) ? dE(da(f), m) : function(w) {
            var E = r2(w, f);
            return E === r && E === m ? n2(w, f) : Lp(m, E, g | v);
          };
        }
        function rv(f, m, w, E, F) {
          f !== m && Cw(m, function(L, V) {
            if (F || (F = new Ts()), Kr(L))
              xU(f, m, V, w, rv, E, F);
            else {
              var X = E ? E(Kw(f, V), L, V + "", f, m, F) : r;
              X === r && (X = L), ww(f, V, X);
            }
          }, Ui);
        }
        function xU(f, m, w, E, F, L, V) {
          var X = Kw(f, w), ee = Kw(m, w), pe = V.get(ee);
          if (pe) {
            ww(f, w, pe);
            return;
          }
          var ge = L ? L(X, ee, w + "", f, m, V) : r, ke = ge === r;
          if (ke) {
            var Ne = yt(ee), Ue = !Ne && Su(ee), ot = !Ne && !Ue && pf(ee);
            ge = ee, Ne || Ue || ot ? yt(X) ? ge = X : cn(X) ? ge = ji(X) : Ue ? (ke = !1, ge = WA(ee, !0)) : ot ? (ke = !1, ge = GA(ee, !0)) : ge = [] : Hp(ee) || Fc(ee) ? (ge = X, Fc(X) ? ge = UE(X) : (!Kr(X) || _l(X)) && (ge = hE(ee))) : ke = !1;
          }
          ke && (V.set(ee, ge), F(ge, ee, E, L, V), V.delete(ee)), ww(f, w, ge);
        }
        function NA(f, m) {
          var w = f.length;
          if (w)
            return m += m < 0 ? w : 0, Cl(m, w) ? f[m] : r;
        }
        function $A(f, m, w) {
          m.length ? m = jr(m, function(L) {
            return yt(L) ? function(V) {
              return Ec(V, L.length === 1 ? L[0] : L);
            } : L;
          }) : m = [Hi];
          var E = -1;
          m = jr(m, wo(rt()));
          var F = MA(f, function(L, V, X) {
            var ee = jr(m, function(pe) {
              return pe(L);
            });
            return { criteria: ee, index: ++E, value: L };
          });
          return Gj(F, function(L, V) {
            return PU(L, V, w);
          });
        }
        function wU(f, m) {
          return IA(f, m, function(w, E) {
            return n2(f, E);
          });
        }
        function IA(f, m, w) {
          for (var E = -1, F = m.length, L = {}; ++E < F; ) {
            var V = m[E], X = Ec(f, V);
            w(X, V) && zp(L, Cu(V, f), X);
          }
          return L;
        }
        function kU(f) {
          return function(m) {
            return Ec(m, f);
          };
        }
        function Fw(f, m, w, E) {
          var F = E ? Wj : rf, L = -1, V = m.length, X = f;
          for (f === m && (m = ji(m)), w && (X = jr(f, wo(w))); ++L < V; )
            for (var ee = 0, pe = m[L], ge = w ? w(pe) : pe; (ee = F(X, ge, ee, E)) > -1; )
              X !== f && W0.call(X, ee, 1), W0.call(f, ee, 1);
          return f;
        }
        function BA(f, m) {
          for (var w = f ? m.length : 0, E = w - 1; w--; ) {
            var F = m[w];
            if (w == E || F !== L) {
              var L = F;
              Cl(F) ? W0.call(f, F, 1) : Rw(f, F);
            }
          }
          return f;
        }
        function Tw(f, m) {
          return f + X0(yA() * (m - f + 1));
        }
        function CU(f, m, w, E) {
          for (var F = -1, L = _n(K0((m - f) / (w || 1)), 0), V = ue(L); L--; )
            V[E ? L : ++F] = f, f += w;
          return V;
        }
        function Mw(f, m) {
          var w = "";
          if (!f || m < 1 || m > H)
            return w;
          do
            m % 2 && (w += f), m = X0(m / 2), m && (f += f);
          while (m);
          return w;
        }
        function Mt(f, m) {
          return Xw(pE(f, m, Hi), f + "");
        }
        function _U(f) {
          return wA(mf(f));
        }
        function SU(f, m) {
          var w = mf(f);
          return fv(w, Ac(m, 0, w.length));
        }
        function zp(f, m, w, E) {
          if (!Kr(f))
            return f;
          m = Cu(m, f);
          for (var F = -1, L = m.length, V = L - 1, X = f; X != null && ++F < L; ) {
            var ee = da(m[F]), pe = w;
            if (ee === "__proto__" || ee === "constructor" || ee === "prototype")
              return f;
            if (F != V) {
              var ge = X[ee];
              pe = E ? E(ge, ee, X) : r, pe === r && (pe = Kr(ge) ? ge : Cl(m[F + 1]) ? [] : {});
            }
            $p(X, ee, pe), X = X[ee];
          }
          return f;
        }
        var LA = Q0 ? function(f, m) {
          return Q0.set(f, m), f;
        } : Hi, AU = G0 ? function(f, m) {
          return G0(f, "toString", {
            configurable: !0,
            enumerable: !1,
            value: o2(m),
            writable: !0
          });
        } : Hi;
        function EU(f) {
          return fv(mf(f));
        }
        function os(f, m, w) {
          var E = -1, F = f.length;
          m < 0 && (m = -m > F ? 0 : F + m), w = w > F ? F : w, w < 0 && (w += F), F = m > w ? 0 : w - m >>> 0, m >>>= 0;
          for (var L = ue(F); ++E < F; )
            L[E] = f[E + m];
          return L;
        }
        function DU(f, m) {
          var w;
          return wu(f, function(E, F, L) {
            return w = m(E, F, L), !w;
          }), !!w;
        }
        function nv(f, m, w) {
          var E = 0, F = f == null ? E : f.length;
          if (typeof m == "number" && m === m && F <= ie) {
            for (; E < F; ) {
              var L = E + F >>> 1, V = f[L];
              V !== null && !Co(V) && (w ? V <= m : V < m) ? E = L + 1 : F = L;
            }
            return F;
          }
          return Pw(f, m, Hi, w);
        }
        function Pw(f, m, w, E) {
          var F = 0, L = f == null ? 0 : f.length;
          if (L === 0)
            return 0;
          m = w(m);
          for (var V = m !== m, X = m === null, ee = Co(m), pe = m === r; F < L; ) {
            var ge = X0((F + L) / 2), ke = w(f[ge]), Ne = ke !== r, Ue = ke === null, ot = ke === ke, Dt = Co(ke);
            if (V)
              var st = E || ot;
            else pe ? st = ot && (E || Ne) : X ? st = ot && Ne && (E || !Ue) : ee ? st = ot && Ne && !Ue && (E || !Dt) : Ue || Dt ? st = !1 : st = E ? ke <= m : ke < m;
            st ? F = ge + 1 : L = ge;
          }
          return Jn(L, se);
        }
        function zA(f, m) {
          for (var w = -1, E = f.length, F = 0, L = []; ++w < E; ) {
            var V = f[w], X = m ? m(V) : V;
            if (!w || !Ms(X, ee)) {
              var ee = X;
              L[F++] = V === 0 ? 0 : V;
            }
          }
          return L;
        }
        function jA(f) {
          return typeof f == "number" ? f : Co(f) ? re : +f;
        }
        function ko(f) {
          if (typeof f == "string")
            return f;
          if (yt(f))
            return jr(f, ko) + "";
          if (Co(f))
            return bA ? bA.call(f) : "";
          var m = f + "";
          return m == "0" && 1 / f == -U ? "-0" : m;
        }
        function ku(f, m, w) {
          var E = -1, F = $0, L = f.length, V = !0, X = [], ee = X;
          if (w)
            V = !1, F = lw;
          else if (L >= i) {
            var pe = m ? null : LU(f);
            if (pe)
              return B0(pe);
            V = !1, F = Fp, ee = new Sc();
          } else
            ee = m ? [] : X;
          e:
            for (; ++E < L; ) {
              var ge = f[E], ke = m ? m(ge) : ge;
              if (ge = w || ge !== 0 ? ge : 0, V && ke === ke) {
                for (var Ne = ee.length; Ne--; )
                  if (ee[Ne] === ke)
                    continue e;
                m && ee.push(ke), X.push(ge);
              } else F(ee, ke, w) || (ee !== X && ee.push(ke), X.push(ge));
            }
          return X;
        }
        function Rw(f, m) {
          return m = Cu(m, f), f = mE(f, m), f == null || delete f[da(ss(m))];
        }
        function qA(f, m, w, E) {
          return zp(f, m, w(Ec(f, m)), E);
        }
        function iv(f, m, w, E) {
          for (var F = f.length, L = E ? F : -1; (E ? L-- : ++L < F) && m(f[L], L, f); )
            ;
          return w ? os(f, E ? 0 : L, E ? L + 1 : F) : os(f, E ? L + 1 : 0, E ? F : L);
        }
        function UA(f, m) {
          var w = f;
          return w instanceof Lt && (w = w.value()), uw(m, function(E, F) {
            return F.func.apply(F.thisArg, yu([E], F.args));
          }, w);
        }
        function Nw(f, m, w) {
          var E = f.length;
          if (E < 2)
            return E ? ku(f[0]) : [];
          for (var F = -1, L = ue(E); ++F < E; )
            for (var V = f[F], X = -1; ++X < E; )
              X != F && (L[F] = Ip(L[F] || V, f[X], m, w));
          return ku(Hn(L, 1), m, w);
        }
        function HA(f, m, w) {
          for (var E = -1, F = f.length, L = m.length, V = {}; ++E < F; ) {
            var X = E < L ? m[E] : r;
            w(V, f[E], X);
          }
          return V;
        }
        function $w(f) {
          return cn(f) ? f : [];
        }
        function Iw(f) {
          return typeof f == "function" ? f : Hi;
        }
        function Cu(f, m) {
          return yt(f) ? f : Ww(f, m) ? [f] : bE(vr(f));
        }
        var OU = Mt;
        function _u(f, m, w) {
          var E = f.length;
          return w = w === r ? E : w, !m && w >= E ? f : os(f, m, w);
        }
        var VA = gq || function(f) {
          return Un.clearTimeout(f);
        };
        function WA(f, m) {
          if (m)
            return f.slice();
          var w = f.length, E = dA ? dA(w) : new f.constructor(w);
          return f.copy(E), E;
        }
        function Bw(f) {
          var m = new f.constructor(f.byteLength);
          return new H0(m).set(new H0(f)), m;
        }
        function FU(f, m) {
          var w = m ? Bw(f.buffer) : f.buffer;
          return new f.constructor(w, f.byteOffset, f.byteLength);
        }
        function TU(f) {
          var m = new f.constructor(f.source, Je.exec(f));
          return m.lastIndex = f.lastIndex, m;
        }
        function MU(f) {
          return Np ? Dr(Np.call(f)) : {};
        }
        function GA(f, m) {
          var w = m ? Bw(f.buffer) : f.buffer;
          return new f.constructor(w, f.byteOffset, f.length);
        }
        function KA(f, m) {
          if (f !== m) {
            var w = f !== r, E = f === null, F = f === f, L = Co(f), V = m !== r, X = m === null, ee = m === m, pe = Co(m);
            if (!X && !pe && !L && f > m || L && V && ee && !X && !pe || E && V && ee || !w && ee || !F)
              return 1;
            if (!E && !L && !pe && f < m || pe && w && F && !E && !L || X && w && F || !V && F || !ee)
              return -1;
          }
          return 0;
        }
        function PU(f, m, w) {
          for (var E = -1, F = f.criteria, L = m.criteria, V = F.length, X = w.length; ++E < V; ) {
            var ee = KA(F[E], L[E]);
            if (ee) {
              if (E >= X)
                return ee;
              var pe = w[E];
              return ee * (pe == "desc" ? -1 : 1);
            }
          }
          return f.index - m.index;
        }
        function XA(f, m, w, E) {
          for (var F = -1, L = f.length, V = w.length, X = -1, ee = m.length, pe = _n(L - V, 0), ge = ue(ee + pe), ke = !E; ++X < ee; )
            ge[X] = m[X];
          for (; ++F < V; )
            (ke || F < L) && (ge[w[F]] = f[F]);
          for (; pe--; )
            ge[X++] = f[F++];
          return ge;
        }
        function QA(f, m, w, E) {
          for (var F = -1, L = f.length, V = -1, X = w.length, ee = -1, pe = m.length, ge = _n(L - X, 0), ke = ue(ge + pe), Ne = !E; ++F < ge; )
            ke[F] = f[F];
          for (var Ue = F; ++ee < pe; )
            ke[Ue + ee] = m[ee];
          for (; ++V < X; )
            (Ne || F < L) && (ke[Ue + w[V]] = f[F++]);
          return ke;
        }
        function ji(f, m) {
          var w = -1, E = f.length;
          for (m || (m = ue(E)); ++w < E; )
            m[w] = f[w];
          return m;
        }
        function fa(f, m, w, E) {
          var F = !w;
          w || (w = {});
          for (var L = -1, V = m.length; ++L < V; ) {
            var X = m[L], ee = E ? E(w[X], f[X], X, w, f) : r;
            ee === r && (ee = f[X]), F ? xl(w, X, ee) : $p(w, X, ee);
          }
          return w;
        }
        function RU(f, m) {
          return fa(f, Vw(f), m);
        }
        function NU(f, m) {
          return fa(f, uE(f), m);
        }
        function ov(f, m) {
          return function(w, E) {
            var F = yt(w) ? zj : nU, L = m ? m() : {};
            return F(w, f, rt(E, 2), L);
          };
        }
        function hf(f) {
          return Mt(function(m, w) {
            var E = -1, F = w.length, L = F > 1 ? w[F - 1] : r, V = F > 2 ? w[2] : r;
            for (L = f.length > 3 && typeof L == "function" ? (F--, L) : r, V && Ci(w[0], w[1], V) && (L = F < 3 ? r : L, F = 1), m = Dr(m); ++E < F; ) {
              var X = w[E];
              X && f(m, X, E, L);
            }
            return m;
          });
        }
        function JA(f, m) {
          return function(w, E) {
            if (w == null)
              return w;
            if (!qi(w))
              return f(w, E);
            for (var F = w.length, L = m ? F : -1, V = Dr(w); (m ? L-- : ++L < F) && E(V[L], L, V) !== !1; )
              ;
            return w;
          };
        }
        function YA(f) {
          return function(m, w, E) {
            for (var F = -1, L = Dr(m), V = E(m), X = V.length; X--; ) {
              var ee = V[f ? X : ++F];
              if (w(L[ee], ee, L) === !1)
                break;
            }
            return m;
          };
        }
        function $U(f, m, w) {
          var E = m & y, F = jp(f);
          function L() {
            var V = this && this !== Un && this instanceof L ? F : f;
            return V.apply(E ? w : this, arguments);
          }
          return L;
        }
        function ZA(f) {
          return function(m) {
            m = vr(m);
            var w = nf(m) ? Fs(m) : r, E = w ? w[0] : m.charAt(0), F = w ? _u(w, 1).join("") : m.slice(1);
            return E[f]() + F;
          };
        }
        function ff(f) {
          return function(m) {
            return uw(JE(QE(m).replace(Aj, "")), f, "");
          };
        }
        function jp(f) {
          return function() {
            var m = arguments;
            switch (m.length) {
              case 0:
                return new f();
              case 1:
                return new f(m[0]);
              case 2:
                return new f(m[0], m[1]);
              case 3:
                return new f(m[0], m[1], m[2]);
              case 4:
                return new f(m[0], m[1], m[2], m[3]);
              case 5:
                return new f(m[0], m[1], m[2], m[3], m[4]);
              case 6:
                return new f(m[0], m[1], m[2], m[3], m[4], m[5]);
              case 7:
                return new f(m[0], m[1], m[2], m[3], m[4], m[5], m[6]);
            }
            var w = cf(f.prototype), E = f.apply(w, m);
            return Kr(E) ? E : w;
          };
        }
        function IU(f, m, w) {
          var E = jp(f);
          function F() {
            for (var L = arguments.length, V = ue(L), X = L, ee = df(F); X--; )
              V[X] = arguments[X];
            var pe = L < 3 && V[0] !== ee && V[L - 1] !== ee ? [] : bu(V, ee);
            if (L -= pe.length, L < w)
              return iE(
                f,
                m,
                sv,
                F.placeholder,
                r,
                V,
                pe,
                r,
                r,
                w - L
              );
            var ge = this && this !== Un && this instanceof F ? E : f;
            return xo(ge, this, V);
          }
          return F;
        }
        function eE(f) {
          return function(m, w, E) {
            var F = Dr(m);
            if (!qi(m)) {
              var L = rt(w, 3);
              m = Mn(m), w = function(X) {
                return L(F[X], X, F);
              };
            }
            var V = f(m, w, E);
            return V > -1 ? F[L ? m[V] : V] : r;
          };
        }
        function tE(f) {
          return kl(function(m) {
            var w = m.length, E = w, F = ns.prototype.thru;
            for (f && m.reverse(); E--; ) {
              var L = m[E];
              if (typeof L != "function")
                throw new rs(s);
              if (F && !V && cv(L) == "wrapper")
                var V = new ns([], !0);
            }
            for (E = V ? E : w; ++E < w; ) {
              L = m[E];
              var X = cv(L), ee = X == "wrapper" ? Uw(L) : r;
              ee && Gw(ee[0]) && ee[1] == (A | C | _ | O) && !ee[4].length && ee[9] == 1 ? V = V[cv(ee[0])].apply(V, ee[3]) : V = L.length == 1 && Gw(L) ? V[X]() : V.thru(L);
            }
            return function() {
              var pe = arguments, ge = pe[0];
              if (V && pe.length == 1 && yt(ge))
                return V.plant(ge).value();
              for (var ke = 0, Ne = w ? m[ke].apply(this, pe) : ge; ++ke < w; )
                Ne = m[ke].call(this, Ne);
              return Ne;
            };
          });
        }
        function sv(f, m, w, E, F, L, V, X, ee, pe) {
          var ge = m & A, ke = m & y, Ne = m & b, Ue = m & (C | S), ot = m & M, Dt = Ne ? r : jp(f);
          function st() {
            for (var $t = arguments.length, Ht = ue($t), _o = $t; _o--; )
              Ht[_o] = arguments[_o];
            if (Ue)
              var _i = df(st), So = Xj(Ht, _i);
            if (E && (Ht = XA(Ht, E, F, Ue)), L && (Ht = QA(Ht, L, V, Ue)), $t -= So, Ue && $t < pe) {
              var hn = bu(Ht, _i);
              return iE(
                f,
                m,
                sv,
                st.placeholder,
                w,
                Ht,
                hn,
                X,
                ee,
                pe - $t
              );
            }
            var Ps = ke ? w : this, Al = Ne ? Ps[f] : f;
            return $t = Ht.length, X ? Ht = nH(Ht, X) : ot && $t > 1 && Ht.reverse(), ge && ee < $t && (Ht.length = ee), this && this !== Un && this instanceof st && (Al = Dt || jp(Al)), Al.apply(Ps, Ht);
          }
          return st;
        }
        function rE(f, m) {
          return function(w, E) {
            return hU(w, f, m(E), {});
          };
        }
        function av(f, m) {
          return function(w, E) {
            var F;
            if (w === r && E === r)
              return m;
            if (w !== r && (F = w), E !== r) {
              if (F === r)
                return E;
              typeof w == "string" || typeof E == "string" ? (w = ko(w), E = ko(E)) : (w = jA(w), E = jA(E)), F = f(w, E);
            }
            return F;
          };
        }
        function Lw(f) {
          return kl(function(m) {
            return m = jr(m, wo(rt())), Mt(function(w) {
              var E = this;
              return f(m, function(F) {
                return xo(F, E, w);
              });
            });
          });
        }
        function lv(f, m) {
          m = m === r ? " " : ko(m);
          var w = m.length;
          if (w < 2)
            return w ? Mw(m, f) : m;
          var E = Mw(m, K0(f / of(m)));
          return nf(m) ? _u(Fs(E), 0, f).join("") : E.slice(0, f);
        }
        function BU(f, m, w, E) {
          var F = m & y, L = jp(f);
          function V() {
            for (var X = -1, ee = arguments.length, pe = -1, ge = E.length, ke = ue(ge + ee), Ne = this && this !== Un && this instanceof V ? L : f; ++pe < ge; )
              ke[pe] = E[pe];
            for (; ee--; )
              ke[pe++] = arguments[++X];
            return xo(Ne, F ? w : this, ke);
          }
          return V;
        }
        function nE(f) {
          return function(m, w, E) {
            return E && typeof E != "number" && Ci(m, w, E) && (w = E = r), m = Sl(m), w === r ? (w = m, m = 0) : w = Sl(w), E = E === r ? m < w ? 1 : -1 : Sl(E), CU(m, w, E, f);
          };
        }
        function uv(f) {
          return function(m, w) {
            return typeof m == "string" && typeof w == "string" || (m = as(m), w = as(w)), f(m, w);
          };
        }
        function iE(f, m, w, E, F, L, V, X, ee, pe) {
          var ge = m & C, ke = ge ? V : r, Ne = ge ? r : V, Ue = ge ? L : r, ot = ge ? r : L;
          m |= ge ? _ : D, m &= ~(ge ? D : _), m & k || (m &= -4);
          var Dt = [
            f,
            m,
            F,
            Ue,
            ke,
            ot,
            Ne,
            X,
            ee,
            pe
          ], st = w.apply(r, Dt);
          return Gw(f) && gE(st, Dt), st.placeholder = E, vE(st, f, m);
        }
        function zw(f) {
          var m = Cn[f];
          return function(w, E) {
            if (w = as(w), E = E == null ? 0 : Jn(Ct(E), 292), E && vA(w)) {
              var F = (vr(w) + "e").split("e"), L = m(F[0] + "e" + (+F[1] + E));
              return F = (vr(L) + "e").split("e"), +(F[0] + "e" + (+F[1] - E));
            }
            return m(w);
          };
        }
        var LU = lf && 1 / B0(new lf([, -0]))[1] == U ? function(f) {
          return new lf(f);
        } : l2;
        function oE(f) {
          return function(m) {
            var w = Yn(m);
            return w == et ? gw(m) : w == Ze ? rq(m) : Kj(m, f(m));
          };
        }
        function wl(f, m, w, E, F, L, V, X) {
          var ee = m & b;
          if (!ee && typeof f != "function")
            throw new rs(s);
          var pe = E ? E.length : 0;
          if (pe || (m &= -97, E = F = r), V = V === r ? V : _n(Ct(V), 0), X = X === r ? X : Ct(X), pe -= F ? F.length : 0, m & D) {
            var ge = E, ke = F;
            E = F = r;
          }
          var Ne = ee ? r : Uw(f), Ue = [
            f,
            m,
            w,
            E,
            F,
            ge,
            ke,
            L,
            V,
            X
          ];
          if (Ne && eH(Ue, Ne), f = Ue[0], m = Ue[1], w = Ue[2], E = Ue[3], F = Ue[4], X = Ue[9] = Ue[9] === r ? ee ? 0 : f.length : _n(Ue[9] - pe, 0), !X && m & (C | S) && (m &= -25), !m || m == y)
            var ot = $U(f, m, w);
          else m == C || m == S ? ot = IU(f, m, X) : (m == _ || m == (y | _)) && !F.length ? ot = BU(f, m, w, E) : ot = sv.apply(r, Ue);
          var Dt = Ne ? LA : gE;
          return vE(Dt(ot, Ue), f, m);
        }
        function sE(f, m, w, E) {
          return f === r || Ms(f, af[w]) && !br.call(E, w) ? m : f;
        }
        function aE(f, m, w, E, F, L) {
          return Kr(f) && Kr(m) && (L.set(m, f), rv(f, m, r, aE, L), L.delete(m)), f;
        }
        function zU(f) {
          return Hp(f) ? r : f;
        }
        function lE(f, m, w, E, F, L) {
          var V = w & g, X = f.length, ee = m.length;
          if (X != ee && !(V && ee > X))
            return !1;
          var pe = L.get(f), ge = L.get(m);
          if (pe && ge)
            return pe == m && ge == f;
          var ke = -1, Ne = !0, Ue = w & v ? new Sc() : r;
          for (L.set(f, m), L.set(m, f); ++ke < X; ) {
            var ot = f[ke], Dt = m[ke];
            if (E)
              var st = V ? E(Dt, ot, ke, m, f, L) : E(ot, Dt, ke, f, m, L);
            if (st !== r) {
              if (st)
                continue;
              Ne = !1;
              break;
            }
            if (Ue) {
              if (!cw(m, function($t, Ht) {
                if (!Fp(Ue, Ht) && (ot === $t || F(ot, $t, w, E, L)))
                  return Ue.push(Ht);
              })) {
                Ne = !1;
                break;
              }
            } else if (!(ot === Dt || F(ot, Dt, w, E, L))) {
              Ne = !1;
              break;
            }
          }
          return L.delete(f), L.delete(m), Ne;
        }
        function jU(f, m, w, E, F, L, V) {
          switch (w) {
            case Ft:
              if (f.byteLength != m.byteLength || f.byteOffset != m.byteOffset)
                return !1;
              f = f.buffer, m = m.buffer;
            case tt:
              return !(f.byteLength != m.byteLength || !L(new H0(f), new H0(m)));
            case Ae:
            case he:
            case Qe:
              return Ms(+f, +m);
            case ve:
              return f.name == m.name && f.message == m.message;
            case Ve:
            case Bt:
              return f == m + "";
            case et:
              var X = gw;
            case Ze:
              var ee = E & g;
              if (X || (X = B0), f.size != m.size && !ee)
                return !1;
              var pe = V.get(f);
              if (pe)
                return pe == m;
              E |= v, V.set(f, m);
              var ge = lE(X(f), X(m), E, F, L, V);
              return V.delete(f), ge;
            case Qt:
              if (Np)
                return Np.call(f) == Np.call(m);
          }
          return !1;
        }
        function qU(f, m, w, E, F, L) {
          var V = w & g, X = jw(f), ee = X.length, pe = jw(m), ge = pe.length;
          if (ee != ge && !V)
            return !1;
          for (var ke = ee; ke--; ) {
            var Ne = X[ke];
            if (!(V ? Ne in m : br.call(m, Ne)))
              return !1;
          }
          var Ue = L.get(f), ot = L.get(m);
          if (Ue && ot)
            return Ue == m && ot == f;
          var Dt = !0;
          L.set(f, m), L.set(m, f);
          for (var st = V; ++ke < ee; ) {
            Ne = X[ke];
            var $t = f[Ne], Ht = m[Ne];
            if (E)
              var _o = V ? E(Ht, $t, Ne, m, f, L) : E($t, Ht, Ne, f, m, L);
            if (!(_o === r ? $t === Ht || F($t, Ht, w, E, L) : _o)) {
              Dt = !1;
              break;
            }
            st || (st = Ne == "constructor");
          }
          if (Dt && !st) {
            var _i = f.constructor, So = m.constructor;
            _i != So && "constructor" in f && "constructor" in m && !(typeof _i == "function" && _i instanceof _i && typeof So == "function" && So instanceof So) && (Dt = !1);
          }
          return L.delete(f), L.delete(m), Dt;
        }
        function kl(f) {
          return Xw(pE(f, r, CE), f + "");
        }
        function jw(f) {
          return DA(f, Mn, Vw);
        }
        function qw(f) {
          return DA(f, Ui, uE);
        }
        var Uw = Q0 ? function(f) {
          return Q0.get(f);
        } : l2;
        function cv(f) {
          for (var m = f.name + "", w = uf[m], E = br.call(uf, m) ? w.length : 0; E--; ) {
            var F = w[E], L = F.func;
            if (L == null || L == f)
              return F.name;
          }
          return m;
        }
        function df(f) {
          var m = br.call(R, "placeholder") ? R : f;
          return m.placeholder;
        }
        function rt() {
          var f = R.iteratee || s2;
          return f = f === s2 ? TA : f, arguments.length ? f(arguments[0], arguments[1]) : f;
        }
        function hv(f, m) {
          var w = f.__data__;
          return QU(m) ? w[typeof m == "string" ? "string" : "hash"] : w.map;
        }
        function Hw(f) {
          for (var m = Mn(f), w = m.length; w--; ) {
            var E = m[w], F = f[E];
            m[w] = [E, F, fE(F)];
          }
          return m;
        }
        function Dc(f, m) {
          var w = Zj(f, m);
          return FA(w) ? w : r;
        }
        function UU(f) {
          var m = br.call(f, Cc), w = f[Cc];
          try {
            f[Cc] = r;
            var E = !0;
          } catch {
          }
          var F = q0.call(f);
          return E && (m ? f[Cc] = w : delete f[Cc]), F;
        }
        var Vw = yw ? function(f) {
          return f == null ? [] : (f = Dr(f), vu(yw(f), function(m) {
            return mA.call(f, m);
          }));
        } : u2, uE = yw ? function(f) {
          for (var m = []; f; )
            yu(m, Vw(f)), f = V0(f);
          return m;
        } : u2, Yn = ki;
        (bw && Yn(new bw(new ArrayBuffer(1))) != Ft || Mp && Yn(new Mp()) != et || xw && Yn(xw.resolve()) != Xt || lf && Yn(new lf()) != Ze || Pp && Yn(new Pp()) != pt) && (Yn = function(f) {
          var m = ki(f), w = m == At ? f.constructor : r, E = w ? Oc(w) : "";
          if (E)
            switch (E) {
              case Sq:
                return Ft;
              case Aq:
                return et;
              case Eq:
                return Xt;
              case Dq:
                return Ze;
              case Oq:
                return pt;
            }
          return m;
        });
        function HU(f, m, w) {
          for (var E = -1, F = w.length; ++E < F; ) {
            var L = w[E], V = L.size;
            switch (L.type) {
              case "drop":
                f += V;
                break;
              case "dropRight":
                m -= V;
                break;
              case "take":
                m = Jn(m, f + V);
                break;
              case "takeRight":
                f = _n(f, m - V);
                break;
            }
          }
          return { start: f, end: m };
        }
        function VU(f) {
          var m = f.match(Zx);
          return m ? m[1].split(ew) : [];
        }
        function cE(f, m, w) {
          m = Cu(m, f);
          for (var E = -1, F = m.length, L = !1; ++E < F; ) {
            var V = da(m[E]);
            if (!(L = f != null && w(f, V)))
              break;
            f = f[V];
          }
          return L || ++E != F ? L : (F = f == null ? 0 : f.length, !!F && yv(F) && Cl(V, F) && (yt(f) || Fc(f)));
        }
        function WU(f) {
          var m = f.length, w = new f.constructor(m);
          return m && typeof f[0] == "string" && br.call(f, "index") && (w.index = f.index, w.input = f.input), w;
        }
        function hE(f) {
          return typeof f.constructor == "function" && !qp(f) ? cf(V0(f)) : {};
        }
        function GU(f, m, w) {
          var E = f.constructor;
          switch (m) {
            case tt:
              return Bw(f);
            case Ae:
            case he:
              return new E(+f);
            case Ft:
              return FU(f, w);
            case mr:
            case Tt:
            case Et:
            case Ar:
            case Ut:
            case ln:
            case wi:
            case ua:
            case ml:
              return GA(f, w);
            case et:
              return new E();
            case Qe:
            case Bt:
              return new E(f);
            case Ve:
              return TU(f);
            case Ze:
              return new E();
            case Qt:
              return MU(f);
          }
        }
        function KU(f, m) {
          var w = m.length;
          if (!w)
            return f;
          var E = w - 1;
          return m[E] = (w > 1 ? "& " : "") + m[E], m = m.join(w > 2 ? ", " : " "), f.replace(Yx, `{
/* [wrapped with ` + m + `] */
`);
        }
        function XU(f) {
          return yt(f) || Fc(f) || !!(gA && f && f[gA]);
        }
        function Cl(f, m) {
          var w = typeof f;
          return m = m ?? H, !!m && (w == "number" || w != "symbol" && un.test(f)) && f > -1 && f % 1 == 0 && f < m;
        }
        function Ci(f, m, w) {
          if (!Kr(w))
            return !1;
          var E = typeof m;
          return (E == "number" ? qi(w) && Cl(m, w.length) : E == "string" && m in w) ? Ms(w[m], f) : !1;
        }
        function Ww(f, m) {
          if (yt(f))
            return !1;
          var w = typeof f;
          return w == "number" || w == "symbol" || w == "boolean" || f == null || Co(f) ? !0 : Qx.test(f) || !M0.test(f) || m != null && f in Dr(m);
        }
        function QU(f) {
          var m = typeof f;
          return m == "string" || m == "number" || m == "symbol" || m == "boolean" ? f !== "__proto__" : f === null;
        }
        function Gw(f) {
          var m = cv(f), w = R[m];
          if (typeof w != "function" || !(m in Lt.prototype))
            return !1;
          if (f === w)
            return !0;
          var E = Uw(w);
          return !!E && f === E[0];
        }
        function JU(f) {
          return !!fA && fA in f;
        }
        var YU = z0 ? _l : c2;
        function qp(f) {
          var m = f && f.constructor, w = typeof m == "function" && m.prototype || af;
          return f === w;
        }
        function fE(f) {
          return f === f && !Kr(f);
        }
        function dE(f, m) {
          return function(w) {
            return w == null ? !1 : w[f] === m && (m !== r || f in Dr(w));
          };
        }
        function ZU(f) {
          var m = gv(f, function(E) {
            return w.size === u && w.clear(), E;
          }), w = m.cache;
          return m;
        }
        function eH(f, m) {
          var w = f[1], E = m[1], F = w | E, L = F < (y | b | A), V = E == A && w == C || E == A && w == O && f[7].length <= m[8] || E == (A | O) && m[7].length <= m[8] && w == C;
          if (!(L || V))
            return f;
          E & y && (f[2] = m[2], F |= w & y ? 0 : k);
          var X = m[3];
          if (X) {
            var ee = f[3];
            f[3] = ee ? XA(ee, X, m[4]) : X, f[4] = ee ? bu(f[3], c) : m[4];
          }
          return X = m[5], X && (ee = f[5], f[5] = ee ? QA(ee, X, m[6]) : X, f[6] = ee ? bu(f[5], c) : m[6]), X = m[7], X && (f[7] = X), E & A && (f[8] = f[8] == null ? m[8] : Jn(f[8], m[8])), f[9] == null && (f[9] = m[9]), f[0] = m[0], f[1] = F, f;
        }
        function tH(f) {
          var m = [];
          if (f != null)
            for (var w in Dr(f))
              m.push(w);
          return m;
        }
        function rH(f) {
          return q0.call(f);
        }
        function pE(f, m, w) {
          return m = _n(m === r ? f.length - 1 : m, 0), function() {
            for (var E = arguments, F = -1, L = _n(E.length - m, 0), V = ue(L); ++F < L; )
              V[F] = E[m + F];
            F = -1;
            for (var X = ue(m + 1); ++F < m; )
              X[F] = E[F];
            return X[m] = w(V), xo(f, this, X);
          };
        }
        function mE(f, m) {
          return m.length < 2 ? f : Ec(f, os(m, 0, -1));
        }
        function nH(f, m) {
          for (var w = f.length, E = Jn(m.length, w), F = ji(f); E--; ) {
            var L = m[E];
            f[E] = Cl(L, w) ? F[L] : r;
          }
          return f;
        }
        function Kw(f, m) {
          if (!(m === "constructor" && typeof f[m] == "function") && m != "__proto__")
            return f[m];
        }
        var gE = yE(LA), Up = yq || function(f, m) {
          return Un.setTimeout(f, m);
        }, Xw = yE(AU);
        function vE(f, m, w) {
          var E = m + "";
          return Xw(f, KU(E, iH(VU(E), w)));
        }
        function yE(f) {
          var m = 0, w = 0;
          return function() {
            var E = kq(), F = I - (E - w);
            if (w = E, F > 0) {
              if (++m >= P)
                return arguments[0];
            } else
              m = 0;
            return f.apply(r, arguments);
          };
        }
        function fv(f, m) {
          var w = -1, E = f.length, F = E - 1;
          for (m = m === r ? E : m; ++w < m; ) {
            var L = Tw(w, F), V = f[L];
            f[L] = f[w], f[w] = V;
          }
          return f.length = m, f;
        }
        var bE = ZU(function(f) {
          var m = [];
          return f.charCodeAt(0) === 46 && m.push(""), f.replace(P0, function(w, E, F, L) {
            m.push(F ? L.replace(ze, "$1") : E || w);
          }), m;
        });
        function da(f) {
          if (typeof f == "string" || Co(f))
            return f;
          var m = f + "";
          return m == "0" && 1 / f == -U ? "-0" : m;
        }
        function Oc(f) {
          if (f != null) {
            try {
              return j0.call(f);
            } catch {
            }
            try {
              return f + "";
            } catch {
            }
          }
          return "";
        }
        function iH(f, m) {
          return ts(ce, function(w) {
            var E = "_." + w[0];
            m & w[1] && !$0(f, E) && f.push(E);
          }), f.sort();
        }
        function xE(f) {
          if (f instanceof Lt)
            return f.clone();
          var m = new ns(f.__wrapped__, f.__chain__);
          return m.__actions__ = ji(f.__actions__), m.__index__ = f.__index__, m.__values__ = f.__values__, m;
        }
        function oH(f, m, w) {
          (w ? Ci(f, m, w) : m === r) ? m = 1 : m = _n(Ct(m), 0);
          var E = f == null ? 0 : f.length;
          if (!E || m < 1)
            return [];
          for (var F = 0, L = 0, V = ue(K0(E / m)); F < E; )
            V[L++] = os(f, F, F += m);
          return V;
        }
        function sH(f) {
          for (var m = -1, w = f == null ? 0 : f.length, E = 0, F = []; ++m < w; ) {
            var L = f[m];
            L && (F[E++] = L);
          }
          return F;
        }
        function aH() {
          var f = arguments.length;
          if (!f)
            return [];
          for (var m = ue(f - 1), w = arguments[0], E = f; E--; )
            m[E - 1] = arguments[E];
          return yu(yt(w) ? ji(w) : [w], Hn(m, 1));
        }
        var lH = Mt(function(f, m) {
          return cn(f) ? Ip(f, Hn(m, 1, cn, !0)) : [];
        }), uH = Mt(function(f, m) {
          var w = ss(m);
          return cn(w) && (w = r), cn(f) ? Ip(f, Hn(m, 1, cn, !0), rt(w, 2)) : [];
        }), cH = Mt(function(f, m) {
          var w = ss(m);
          return cn(w) && (w = r), cn(f) ? Ip(f, Hn(m, 1, cn, !0), r, w) : [];
        });
        function hH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (m = w || m === r ? 1 : Ct(m), os(f, m < 0 ? 0 : m, E)) : [];
        }
        function fH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (m = w || m === r ? 1 : Ct(m), m = E - m, os(f, 0, m < 0 ? 0 : m)) : [];
        }
        function dH(f, m) {
          return f && f.length ? iv(f, rt(m, 3), !0, !0) : [];
        }
        function pH(f, m) {
          return f && f.length ? iv(f, rt(m, 3), !0) : [];
        }
        function mH(f, m, w, E) {
          var F = f == null ? 0 : f.length;
          return F ? (w && typeof w != "number" && Ci(f, m, w) && (w = 0, E = F), aU(f, m, w, E)) : [];
        }
        function wE(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = w == null ? 0 : Ct(w);
          return F < 0 && (F = _n(E + F, 0)), I0(f, rt(m, 3), F);
        }
        function kE(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = E - 1;
          return w !== r && (F = Ct(w), F = w < 0 ? _n(E + F, 0) : Jn(F, E - 1)), I0(f, rt(m, 3), F, !0);
        }
        function CE(f) {
          var m = f == null ? 0 : f.length;
          return m ? Hn(f, 1) : [];
        }
        function gH(f) {
          var m = f == null ? 0 : f.length;
          return m ? Hn(f, U) : [];
        }
        function vH(f, m) {
          var w = f == null ? 0 : f.length;
          return w ? (m = m === r ? 1 : Ct(m), Hn(f, m)) : [];
        }
        function yH(f) {
          for (var m = -1, w = f == null ? 0 : f.length, E = {}; ++m < w; ) {
            var F = f[m];
            E[F[0]] = F[1];
          }
          return E;
        }
        function _E(f) {
          return f && f.length ? f[0] : r;
        }
        function bH(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = w == null ? 0 : Ct(w);
          return F < 0 && (F = _n(E + F, 0)), rf(f, m, F);
        }
        function xH(f) {
          var m = f == null ? 0 : f.length;
          return m ? os(f, 0, -1) : [];
        }
        var wH = Mt(function(f) {
          var m = jr(f, $w);
          return m.length && m[0] === f[0] ? Aw(m) : [];
        }), kH = Mt(function(f) {
          var m = ss(f), w = jr(f, $w);
          return m === ss(w) ? m = r : w.pop(), w.length && w[0] === f[0] ? Aw(w, rt(m, 2)) : [];
        }), CH = Mt(function(f) {
          var m = ss(f), w = jr(f, $w);
          return m = typeof m == "function" ? m : r, m && w.pop(), w.length && w[0] === f[0] ? Aw(w, r, m) : [];
        });
        function _H(f, m) {
          return f == null ? "" : xq.call(f, m);
        }
        function ss(f) {
          var m = f == null ? 0 : f.length;
          return m ? f[m - 1] : r;
        }
        function SH(f, m, w) {
          var E = f == null ? 0 : f.length;
          if (!E)
            return -1;
          var F = E;
          return w !== r && (F = Ct(w), F = F < 0 ? _n(E + F, 0) : Jn(F, E - 1)), m === m ? iq(f, m, F) : I0(f, iA, F, !0);
        }
        function AH(f, m) {
          return f && f.length ? NA(f, Ct(m)) : r;
        }
        var EH = Mt(SE);
        function SE(f, m) {
          return f && f.length && m && m.length ? Fw(f, m) : f;
        }
        function DH(f, m, w) {
          return f && f.length && m && m.length ? Fw(f, m, rt(w, 2)) : f;
        }
        function OH(f, m, w) {
          return f && f.length && m && m.length ? Fw(f, m, r, w) : f;
        }
        var FH = kl(function(f, m) {
          var w = f == null ? 0 : f.length, E = kw(f, m);
          return BA(f, jr(m, function(F) {
            return Cl(F, w) ? +F : F;
          }).sort(KA)), E;
        });
        function TH(f, m) {
          var w = [];
          if (!(f && f.length))
            return w;
          var E = -1, F = [], L = f.length;
          for (m = rt(m, 3); ++E < L; ) {
            var V = f[E];
            m(V, E, f) && (w.push(V), F.push(E));
          }
          return BA(f, F), w;
        }
        function Qw(f) {
          return f == null ? f : _q.call(f);
        }
        function MH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (w && typeof w != "number" && Ci(f, m, w) ? (m = 0, w = E) : (m = m == null ? 0 : Ct(m), w = w === r ? E : Ct(w)), os(f, m, w)) : [];
        }
        function PH(f, m) {
          return nv(f, m);
        }
        function RH(f, m, w) {
          return Pw(f, m, rt(w, 2));
        }
        function NH(f, m) {
          var w = f == null ? 0 : f.length;
          if (w) {
            var E = nv(f, m);
            if (E < w && Ms(f[E], m))
              return E;
          }
          return -1;
        }
        function $H(f, m) {
          return nv(f, m, !0);
        }
        function IH(f, m, w) {
          return Pw(f, m, rt(w, 2), !0);
        }
        function BH(f, m) {
          var w = f == null ? 0 : f.length;
          if (w) {
            var E = nv(f, m, !0) - 1;
            if (Ms(f[E], m))
              return E;
          }
          return -1;
        }
        function LH(f) {
          return f && f.length ? zA(f) : [];
        }
        function zH(f, m) {
          return f && f.length ? zA(f, rt(m, 2)) : [];
        }
        function jH(f) {
          var m = f == null ? 0 : f.length;
          return m ? os(f, 1, m) : [];
        }
        function qH(f, m, w) {
          return f && f.length ? (m = w || m === r ? 1 : Ct(m), os(f, 0, m < 0 ? 0 : m)) : [];
        }
        function UH(f, m, w) {
          var E = f == null ? 0 : f.length;
          return E ? (m = w || m === r ? 1 : Ct(m), m = E - m, os(f, m < 0 ? 0 : m, E)) : [];
        }
        function HH(f, m) {
          return f && f.length ? iv(f, rt(m, 3), !1, !0) : [];
        }
        function VH(f, m) {
          return f && f.length ? iv(f, rt(m, 3)) : [];
        }
        var WH = Mt(function(f) {
          return ku(Hn(f, 1, cn, !0));
        }), GH = Mt(function(f) {
          var m = ss(f);
          return cn(m) && (m = r), ku(Hn(f, 1, cn, !0), rt(m, 2));
        }), KH = Mt(function(f) {
          var m = ss(f);
          return m = typeof m == "function" ? m : r, ku(Hn(f, 1, cn, !0), r, m);
        });
        function XH(f) {
          return f && f.length ? ku(f) : [];
        }
        function QH(f, m) {
          return f && f.length ? ku(f, rt(m, 2)) : [];
        }
        function JH(f, m) {
          return m = typeof m == "function" ? m : r, f && f.length ? ku(f, r, m) : [];
        }
        function Jw(f) {
          if (!(f && f.length))
            return [];
          var m = 0;
          return f = vu(f, function(w) {
            if (cn(w))
              return m = _n(w.length, m), !0;
          }), pw(m, function(w) {
            return jr(f, hw(w));
          });
        }
        function AE(f, m) {
          if (!(f && f.length))
            return [];
          var w = Jw(f);
          return m == null ? w : jr(w, function(E) {
            return xo(m, r, E);
          });
        }
        var YH = Mt(function(f, m) {
          return cn(f) ? Ip(f, m) : [];
        }), ZH = Mt(function(f) {
          return Nw(vu(f, cn));
        }), eV = Mt(function(f) {
          var m = ss(f);
          return cn(m) && (m = r), Nw(vu(f, cn), rt(m, 2));
        }), tV = Mt(function(f) {
          var m = ss(f);
          return m = typeof m == "function" ? m : r, Nw(vu(f, cn), r, m);
        }), rV = Mt(Jw);
        function nV(f, m) {
          return HA(f || [], m || [], $p);
        }
        function iV(f, m) {
          return HA(f || [], m || [], zp);
        }
        var oV = Mt(function(f) {
          var m = f.length, w = m > 1 ? f[m - 1] : r;
          return w = typeof w == "function" ? (f.pop(), w) : r, AE(f, w);
        });
        function EE(f) {
          var m = R(f);
          return m.__chain__ = !0, m;
        }
        function sV(f, m) {
          return m(f), f;
        }
        function dv(f, m) {
          return m(f);
        }
        var aV = kl(function(f) {
          var m = f.length, w = m ? f[0] : 0, E = this.__wrapped__, F = function(L) {
            return kw(L, f);
          };
          return m > 1 || this.__actions__.length || !(E instanceof Lt) || !Cl(w) ? this.thru(F) : (E = E.slice(w, +w + (m ? 1 : 0)), E.__actions__.push({
            func: dv,
            args: [F],
            thisArg: r
          }), new ns(E, this.__chain__).thru(function(L) {
            return m && !L.length && L.push(r), L;
          }));
        });
        function lV() {
          return EE(this);
        }
        function uV() {
          return new ns(this.value(), this.__chain__);
        }
        function cV() {
          this.__values__ === r && (this.__values__ = jE(this.value()));
          var f = this.__index__ >= this.__values__.length, m = f ? r : this.__values__[this.__index__++];
          return { done: f, value: m };
        }
        function hV() {
          return this;
        }
        function fV(f) {
          for (var m, w = this; w instanceof Y0; ) {
            var E = xE(w);
            E.__index__ = 0, E.__values__ = r, m ? F.__wrapped__ = E : m = E;
            var F = E;
            w = w.__wrapped__;
          }
          return F.__wrapped__ = f, m;
        }
        function dV() {
          var f = this.__wrapped__;
          if (f instanceof Lt) {
            var m = f;
            return this.__actions__.length && (m = new Lt(this)), m = m.reverse(), m.__actions__.push({
              func: dv,
              args: [Qw],
              thisArg: r
            }), new ns(m, this.__chain__);
          }
          return this.thru(Qw);
        }
        function pV() {
          return UA(this.__wrapped__, this.__actions__);
        }
        var mV = ov(function(f, m, w) {
          br.call(f, w) ? ++f[w] : xl(f, w, 1);
        });
        function gV(f, m, w) {
          var E = yt(f) ? rA : sU;
          return w && Ci(f, m, w) && (m = r), E(f, rt(m, 3));
        }
        function vV(f, m) {
          var w = yt(f) ? vu : AA;
          return w(f, rt(m, 3));
        }
        var yV = eE(wE), bV = eE(kE);
        function xV(f, m) {
          return Hn(pv(f, m), 1);
        }
        function wV(f, m) {
          return Hn(pv(f, m), U);
        }
        function kV(f, m, w) {
          return w = w === r ? 1 : Ct(w), Hn(pv(f, m), w);
        }
        function DE(f, m) {
          var w = yt(f) ? ts : wu;
          return w(f, rt(m, 3));
        }
        function OE(f, m) {
          var w = yt(f) ? jj : SA;
          return w(f, rt(m, 3));
        }
        var CV = ov(function(f, m, w) {
          br.call(f, w) ? f[w].push(m) : xl(f, w, [m]);
        });
        function _V(f, m, w, E) {
          f = qi(f) ? f : mf(f), w = w && !E ? Ct(w) : 0;
          var F = f.length;
          return w < 0 && (w = _n(F + w, 0)), bv(f) ? w <= F && f.indexOf(m, w) > -1 : !!F && rf(f, m, w) > -1;
        }
        var SV = Mt(function(f, m, w) {
          var E = -1, F = typeof m == "function", L = qi(f) ? ue(f.length) : [];
          return wu(f, function(V) {
            L[++E] = F ? xo(m, V, w) : Bp(V, m, w);
          }), L;
        }), AV = ov(function(f, m, w) {
          xl(f, w, m);
        });
        function pv(f, m) {
          var w = yt(f) ? jr : MA;
          return w(f, rt(m, 3));
        }
        function EV(f, m, w, E) {
          return f == null ? [] : (yt(m) || (m = m == null ? [] : [m]), w = E ? r : w, yt(w) || (w = w == null ? [] : [w]), $A(f, m, w));
        }
        var DV = ov(function(f, m, w) {
          f[w ? 0 : 1].push(m);
        }, function() {
          return [[], []];
        });
        function OV(f, m, w) {
          var E = yt(f) ? uw : sA, F = arguments.length < 3;
          return E(f, rt(m, 4), w, F, wu);
        }
        function FV(f, m, w) {
          var E = yt(f) ? qj : sA, F = arguments.length < 3;
          return E(f, rt(m, 4), w, F, SA);
        }
        function TV(f, m) {
          var w = yt(f) ? vu : AA;
          return w(f, vv(rt(m, 3)));
        }
        function MV(f) {
          var m = yt(f) ? wA : _U;
          return m(f);
        }
        function PV(f, m, w) {
          (w ? Ci(f, m, w) : m === r) ? m = 1 : m = Ct(m);
          var E = yt(f) ? tU : SU;
          return E(f, m);
        }
        function RV(f) {
          var m = yt(f) ? rU : EU;
          return m(f);
        }
        function NV(f) {
          if (f == null)
            return 0;
          if (qi(f))
            return bv(f) ? of(f) : f.length;
          var m = Yn(f);
          return m == et || m == Ze ? f.size : Dw(f).length;
        }
        function $V(f, m, w) {
          var E = yt(f) ? cw : DU;
          return w && Ci(f, m, w) && (m = r), E(f, rt(m, 3));
        }
        var IV = Mt(function(f, m) {
          if (f == null)
            return [];
          var w = m.length;
          return w > 1 && Ci(f, m[0], m[1]) ? m = [] : w > 2 && Ci(m[0], m[1], m[2]) && (m = [m[0]]), $A(f, Hn(m, 1), []);
        }), mv = vq || function() {
          return Un.Date.now();
        };
        function BV(f, m) {
          if (typeof m != "function")
            throw new rs(s);
          return f = Ct(f), function() {
            if (--f < 1)
              return m.apply(this, arguments);
          };
        }
        function FE(f, m, w) {
          return m = w ? r : m, m = f && m == null ? f.length : m, wl(f, A, r, r, r, r, m);
        }
        function TE(f, m) {
          var w;
          if (typeof m != "function")
            throw new rs(s);
          return f = Ct(f), function() {
            return --f > 0 && (w = m.apply(this, arguments)), f <= 1 && (m = r), w;
          };
        }
        var Yw = Mt(function(f, m, w) {
          var E = y;
          if (w.length) {
            var F = bu(w, df(Yw));
            E |= _;
          }
          return wl(f, E, m, w, F);
        }), ME = Mt(function(f, m, w) {
          var E = y | b;
          if (w.length) {
            var F = bu(w, df(ME));
            E |= _;
          }
          return wl(m, E, f, w, F);
        });
        function PE(f, m, w) {
          m = w ? r : m;
          var E = wl(f, C, r, r, r, r, r, m);
          return E.placeholder = PE.placeholder, E;
        }
        function RE(f, m, w) {
          m = w ? r : m;
          var E = wl(f, S, r, r, r, r, r, m);
          return E.placeholder = RE.placeholder, E;
        }
        function NE(f, m, w) {
          var E, F, L, V, X, ee, pe = 0, ge = !1, ke = !1, Ne = !0;
          if (typeof f != "function")
            throw new rs(s);
          m = as(m) || 0, Kr(w) && (ge = !!w.leading, ke = "maxWait" in w, L = ke ? _n(as(w.maxWait) || 0, m) : L, Ne = "trailing" in w ? !!w.trailing : Ne);
          function Ue(hn) {
            var Ps = E, Al = F;
            return E = F = r, pe = hn, V = f.apply(Al, Ps), V;
          }
          function ot(hn) {
            return pe = hn, X = Up($t, m), ge ? Ue(hn) : V;
          }
          function Dt(hn) {
            var Ps = hn - ee, Al = hn - pe, eD = m - Ps;
            return ke ? Jn(eD, L - Al) : eD;
          }
          function st(hn) {
            var Ps = hn - ee, Al = hn - pe;
            return ee === r || Ps >= m || Ps < 0 || ke && Al >= L;
          }
          function $t() {
            var hn = mv();
            if (st(hn))
              return Ht(hn);
            X = Up($t, Dt(hn));
          }
          function Ht(hn) {
            return X = r, Ne && E ? Ue(hn) : (E = F = r, V);
          }
          function _o() {
            X !== r && VA(X), pe = 0, E = ee = F = X = r;
          }
          function _i() {
            return X === r ? V : Ht(mv());
          }
          function So() {
            var hn = mv(), Ps = st(hn);
            if (E = arguments, F = this, ee = hn, Ps) {
              if (X === r)
                return ot(ee);
              if (ke)
                return VA(X), X = Up($t, m), Ue(ee);
            }
            return X === r && (X = Up($t, m)), V;
          }
          return So.cancel = _o, So.flush = _i, So;
        }
        var LV = Mt(function(f, m) {
          return _A(f, 1, m);
        }), zV = Mt(function(f, m, w) {
          return _A(f, as(m) || 0, w);
        });
        function jV(f) {
          return wl(f, M);
        }
        function gv(f, m) {
          if (typeof f != "function" || m != null && typeof m != "function")
            throw new rs(s);
          var w = function() {
            var E = arguments, F = m ? m.apply(this, E) : E[0], L = w.cache;
            if (L.has(F))
              return L.get(F);
            var V = f.apply(this, E);
            return w.cache = L.set(F, V) || L, V;
          };
          return w.cache = new (gv.Cache || bl)(), w;
        }
        gv.Cache = bl;
        function vv(f) {
          if (typeof f != "function")
            throw new rs(s);
          return function() {
            var m = arguments;
            switch (m.length) {
              case 0:
                return !f.call(this);
              case 1:
                return !f.call(this, m[0]);
              case 2:
                return !f.call(this, m[0], m[1]);
              case 3:
                return !f.call(this, m[0], m[1], m[2]);
            }
            return !f.apply(this, m);
          };
        }
        function qV(f) {
          return TE(2, f);
        }
        var UV = OU(function(f, m) {
          m = m.length == 1 && yt(m[0]) ? jr(m[0], wo(rt())) : jr(Hn(m, 1), wo(rt()));
          var w = m.length;
          return Mt(function(E) {
            for (var F = -1, L = Jn(E.length, w); ++F < L; )
              E[F] = m[F].call(this, E[F]);
            return xo(f, this, E);
          });
        }), Zw = Mt(function(f, m) {
          var w = bu(m, df(Zw));
          return wl(f, _, r, m, w);
        }), $E = Mt(function(f, m) {
          var w = bu(m, df($E));
          return wl(f, D, r, m, w);
        }), HV = kl(function(f, m) {
          return wl(f, O, r, r, r, m);
        });
        function VV(f, m) {
          if (typeof f != "function")
            throw new rs(s);
          return m = m === r ? m : Ct(m), Mt(f, m);
        }
        function WV(f, m) {
          if (typeof f != "function")
            throw new rs(s);
          return m = m == null ? 0 : _n(Ct(m), 0), Mt(function(w) {
            var E = w[m], F = _u(w, 0, m);
            return E && yu(F, E), xo(f, this, F);
          });
        }
        function GV(f, m, w) {
          var E = !0, F = !0;
          if (typeof f != "function")
            throw new rs(s);
          return Kr(w) && (E = "leading" in w ? !!w.leading : E, F = "trailing" in w ? !!w.trailing : F), NE(f, m, {
            leading: E,
            maxWait: m,
            trailing: F
          });
        }
        function KV(f) {
          return FE(f, 1);
        }
        function XV(f, m) {
          return Zw(Iw(m), f);
        }
        function QV() {
          if (!arguments.length)
            return [];
          var f = arguments[0];
          return yt(f) ? f : [f];
        }
        function JV(f) {
          return is(f, p);
        }
        function YV(f, m) {
          return m = typeof m == "function" ? m : r, is(f, p, m);
        }
        function ZV(f) {
          return is(f, h | p);
        }
        function eW(f, m) {
          return m = typeof m == "function" ? m : r, is(f, h | p, m);
        }
        function tW(f, m) {
          return m == null || CA(f, m, Mn(m));
        }
        function Ms(f, m) {
          return f === m || f !== f && m !== m;
        }
        var rW = uv(Sw), nW = uv(function(f, m) {
          return f >= m;
        }), Fc = OA(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? OA : function(f) {
          return tn(f) && br.call(f, "callee") && !mA.call(f, "callee");
        }, yt = ue.isArray, iW = Q5 ? wo(Q5) : fU;
        function qi(f) {
          return f != null && yv(f.length) && !_l(f);
        }
        function cn(f) {
          return tn(f) && qi(f);
        }
        function oW(f) {
          return f === !0 || f === !1 || tn(f) && ki(f) == Ae;
        }
        var Su = bq || c2, sW = J5 ? wo(J5) : dU;
        function aW(f) {
          return tn(f) && f.nodeType === 1 && !Hp(f);
        }
        function lW(f) {
          if (f == null)
            return !0;
          if (qi(f) && (yt(f) || typeof f == "string" || typeof f.splice == "function" || Su(f) || pf(f) || Fc(f)))
            return !f.length;
          var m = Yn(f);
          if (m == et || m == Ze)
            return !f.size;
          if (qp(f))
            return !Dw(f).length;
          for (var w in f)
            if (br.call(f, w))
              return !1;
          return !0;
        }
        function uW(f, m) {
          return Lp(f, m);
        }
        function cW(f, m, w) {
          w = typeof w == "function" ? w : r;
          var E = w ? w(f, m) : r;
          return E === r ? Lp(f, m, r, w) : !!E;
        }
        function e2(f) {
          if (!tn(f))
            return !1;
          var m = ki(f);
          return m == ve || m == we || typeof f.message == "string" && typeof f.name == "string" && !Hp(f);
        }
        function hW(f) {
          return typeof f == "number" && vA(f);
        }
        function _l(f) {
          if (!Kr(f))
            return !1;
          var m = ki(f);
          return m == Ge || m == Xe || m == Pe || m == Nt;
        }
        function IE(f) {
          return typeof f == "number" && f == Ct(f);
        }
        function yv(f) {
          return typeof f == "number" && f > -1 && f % 1 == 0 && f <= H;
        }
        function Kr(f) {
          var m = typeof f;
          return f != null && (m == "object" || m == "function");
        }
        function tn(f) {
          return f != null && typeof f == "object";
        }
        var BE = Y5 ? wo(Y5) : mU;
        function fW(f, m) {
          return f === m || Ew(f, m, Hw(m));
        }
        function dW(f, m, w) {
          return w = typeof w == "function" ? w : r, Ew(f, m, Hw(m), w);
        }
        function pW(f) {
          return LE(f) && f != +f;
        }
        function mW(f) {
          if (YU(f))
            throw new gt(o);
          return FA(f);
        }
        function gW(f) {
          return f === null;
        }
        function vW(f) {
          return f == null;
        }
        function LE(f) {
          return typeof f == "number" || tn(f) && ki(f) == Qe;
        }
        function Hp(f) {
          if (!tn(f) || ki(f) != At)
            return !1;
          var m = V0(f);
          if (m === null)
            return !0;
          var w = br.call(m, "constructor") && m.constructor;
          return typeof w == "function" && w instanceof w && j0.call(w) == dq;
        }
        var t2 = Z5 ? wo(Z5) : gU;
        function yW(f) {
          return IE(f) && f >= -H && f <= H;
        }
        var zE = eA ? wo(eA) : vU;
        function bv(f) {
          return typeof f == "string" || !yt(f) && tn(f) && ki(f) == Bt;
        }
        function Co(f) {
          return typeof f == "symbol" || tn(f) && ki(f) == Qt;
        }
        var pf = tA ? wo(tA) : yU;
        function bW(f) {
          return f === r;
        }
        function xW(f) {
          return tn(f) && Yn(f) == pt;
        }
        function wW(f) {
          return tn(f) && ki(f) == _e;
        }
        var kW = uv(Ow), CW = uv(function(f, m) {
          return f <= m;
        });
        function jE(f) {
          if (!f)
            return [];
          if (qi(f))
            return bv(f) ? Fs(f) : ji(f);
          if (Tp && f[Tp])
            return tq(f[Tp]());
          var m = Yn(f), w = m == et ? gw : m == Ze ? B0 : mf;
          return w(f);
        }
        function Sl(f) {
          if (!f)
            return f === 0 ? f : 0;
          if (f = as(f), f === U || f === -U) {
            var m = f < 0 ? -1 : 1;
            return m * G;
          }
          return f === f ? f : 0;
        }
        function Ct(f) {
          var m = Sl(f), w = m % 1;
          return m === m ? w ? m - w : m : 0;
        }
        function qE(f) {
          return f ? Ac(Ct(f), 0, ne) : 0;
        }
        function as(f) {
          if (typeof f == "number")
            return f;
          if (Co(f))
            return re;
          if (Kr(f)) {
            var m = typeof f.valueOf == "function" ? f.valueOf() : f;
            f = Kr(m) ? m + "" : m;
          }
          if (typeof f != "string")
            return f === 0 ? f : +f;
          f = aA(f);
          var w = Gt.test(f);
          return w || Er.test(f) ? Bj(f.slice(2), w ? 2 : 8) : ut.test(f) ? re : +f;
        }
        function UE(f) {
          return fa(f, Ui(f));
        }
        function _W(f) {
          return f ? Ac(Ct(f), -H, H) : f === 0 ? f : 0;
        }
        function vr(f) {
          return f == null ? "" : ko(f);
        }
        var SW = hf(function(f, m) {
          if (qp(m) || qi(m)) {
            fa(m, Mn(m), f);
            return;
          }
          for (var w in m)
            br.call(m, w) && $p(f, w, m[w]);
        }), HE = hf(function(f, m) {
          fa(m, Ui(m), f);
        }), xv = hf(function(f, m, w, E) {
          fa(m, Ui(m), f, E);
        }), AW = hf(function(f, m, w, E) {
          fa(m, Mn(m), f, E);
        }), EW = kl(kw);
        function DW(f, m) {
          var w = cf(f);
          return m == null ? w : kA(w, m);
        }
        var OW = Mt(function(f, m) {
          f = Dr(f);
          var w = -1, E = m.length, F = E > 2 ? m[2] : r;
          for (F && Ci(m[0], m[1], F) && (E = 1); ++w < E; )
            for (var L = m[w], V = Ui(L), X = -1, ee = V.length; ++X < ee; ) {
              var pe = V[X], ge = f[pe];
              (ge === r || Ms(ge, af[pe]) && !br.call(f, pe)) && (f[pe] = L[pe]);
            }
          return f;
        }), FW = Mt(function(f) {
          return f.push(r, aE), xo(VE, r, f);
        });
        function TW(f, m) {
          return nA(f, rt(m, 3), ha);
        }
        function MW(f, m) {
          return nA(f, rt(m, 3), _w);
        }
        function PW(f, m) {
          return f == null ? f : Cw(f, rt(m, 3), Ui);
        }
        function RW(f, m) {
          return f == null ? f : EA(f, rt(m, 3), Ui);
        }
        function NW(f, m) {
          return f && ha(f, rt(m, 3));
        }
        function $W(f, m) {
          return f && _w(f, rt(m, 3));
        }
        function IW(f) {
          return f == null ? [] : tv(f, Mn(f));
        }
        function BW(f) {
          return f == null ? [] : tv(f, Ui(f));
        }
        function r2(f, m, w) {
          var E = f == null ? r : Ec(f, m);
          return E === r ? w : E;
        }
        function LW(f, m) {
          return f != null && cE(f, m, lU);
        }
        function n2(f, m) {
          return f != null && cE(f, m, uU);
        }
        var zW = rE(function(f, m, w) {
          m != null && typeof m.toString != "function" && (m = q0.call(m)), f[m] = w;
        }, o2(Hi)), jW = rE(function(f, m, w) {
          m != null && typeof m.toString != "function" && (m = q0.call(m)), br.call(f, m) ? f[m].push(w) : f[m] = [w];
        }, rt), qW = Mt(Bp);
        function Mn(f) {
          return qi(f) ? xA(f) : Dw(f);
        }
        function Ui(f) {
          return qi(f) ? xA(f, !0) : bU(f);
        }
        function UW(f, m) {
          var w = {};
          return m = rt(m, 3), ha(f, function(E, F, L) {
            xl(w, m(E, F, L), E);
          }), w;
        }
        function HW(f, m) {
          var w = {};
          return m = rt(m, 3), ha(f, function(E, F, L) {
            xl(w, F, m(E, F, L));
          }), w;
        }
        var VW = hf(function(f, m, w) {
          rv(f, m, w);
        }), VE = hf(function(f, m, w, E) {
          rv(f, m, w, E);
        }), WW = kl(function(f, m) {
          var w = {};
          if (f == null)
            return w;
          var E = !1;
          m = jr(m, function(L) {
            return L = Cu(L, f), E || (E = L.length > 1), L;
          }), fa(f, qw(f), w), E && (w = is(w, h | d | p, zU));
          for (var F = m.length; F--; )
            Rw(w, m[F]);
          return w;
        });
        function GW(f, m) {
          return WE(f, vv(rt(m)));
        }
        var KW = kl(function(f, m) {
          return f == null ? {} : wU(f, m);
        });
        function WE(f, m) {
          if (f == null)
            return {};
          var w = jr(qw(f), function(E) {
            return [E];
          });
          return m = rt(m), IA(f, w, function(E, F) {
            return m(E, F[0]);
          });
        }
        function XW(f, m, w) {
          m = Cu(m, f);
          var E = -1, F = m.length;
          for (F || (F = 1, f = r); ++E < F; ) {
            var L = f == null ? r : f[da(m[E])];
            L === r && (E = F, L = w), f = _l(L) ? L.call(f) : L;
          }
          return f;
        }
        function QW(f, m, w) {
          return f == null ? f : zp(f, m, w);
        }
        function JW(f, m, w, E) {
          return E = typeof E == "function" ? E : r, f == null ? f : zp(f, m, w, E);
        }
        var GE = oE(Mn), KE = oE(Ui);
        function YW(f, m, w) {
          var E = yt(f), F = E || Su(f) || pf(f);
          if (m = rt(m, 4), w == null) {
            var L = f && f.constructor;
            F ? w = E ? new L() : [] : Kr(f) ? w = _l(L) ? cf(V0(f)) : {} : w = {};
          }
          return (F ? ts : ha)(f, function(V, X, ee) {
            return m(w, V, X, ee);
          }), w;
        }
        function ZW(f, m) {
          return f == null ? !0 : Rw(f, m);
        }
        function eG(f, m, w) {
          return f == null ? f : qA(f, m, Iw(w));
        }
        function tG(f, m, w, E) {
          return E = typeof E == "function" ? E : r, f == null ? f : qA(f, m, Iw(w), E);
        }
        function mf(f) {
          return f == null ? [] : mw(f, Mn(f));
        }
        function rG(f) {
          return f == null ? [] : mw(f, Ui(f));
        }
        function nG(f, m, w) {
          return w === r && (w = m, m = r), w !== r && (w = as(w), w = w === w ? w : 0), m !== r && (m = as(m), m = m === m ? m : 0), Ac(as(f), m, w);
        }
        function iG(f, m, w) {
          return m = Sl(m), w === r ? (w = m, m = 0) : w = Sl(w), f = as(f), cU(f, m, w);
        }
        function oG(f, m, w) {
          if (w && typeof w != "boolean" && Ci(f, m, w) && (m = w = r), w === r && (typeof m == "boolean" ? (w = m, m = r) : typeof f == "boolean" && (w = f, f = r)), f === r && m === r ? (f = 0, m = 1) : (f = Sl(f), m === r ? (m = f, f = 0) : m = Sl(m)), f > m) {
            var E = f;
            f = m, m = E;
          }
          if (w || f % 1 || m % 1) {
            var F = yA();
            return Jn(f + F * (m - f + Ij("1e-" + ((F + "").length - 1))), m);
          }
          return Tw(f, m);
        }
        var sG = ff(function(f, m, w) {
          return m = m.toLowerCase(), f + (w ? XE(m) : m);
        });
        function XE(f) {
          return i2(vr(f).toLowerCase());
        }
        function QE(f) {
          return f = vr(f), f && f.replace(Zo, Qj).replace(Ej, "");
        }
        function aG(f, m, w) {
          f = vr(f), m = ko(m);
          var E = f.length;
          w = w === r ? E : Ac(Ct(w), 0, E);
          var F = w;
          return w -= m.length, w >= 0 && f.slice(w, F) == m;
        }
        function lG(f) {
          return f = vr(f), f && Ap.test(f) ? f.replace(Es, Jj) : f;
        }
        function uG(f) {
          return f = vr(f), f && Jx.test(f) ? f.replace(Ep, "\\$&") : f;
        }
        var cG = ff(function(f, m, w) {
          return f + (w ? "-" : "") + m.toLowerCase();
        }), hG = ff(function(f, m, w) {
          return f + (w ? " " : "") + m.toLowerCase();
        }), fG = ZA("toLowerCase");
        function dG(f, m, w) {
          f = vr(f), m = Ct(m);
          var E = m ? of(f) : 0;
          if (!m || E >= m)
            return f;
          var F = (m - E) / 2;
          return lv(X0(F), w) + f + lv(K0(F), w);
        }
        function pG(f, m, w) {
          f = vr(f), m = Ct(m);
          var E = m ? of(f) : 0;
          return m && E < m ? f + lv(m - E, w) : f;
        }
        function mG(f, m, w) {
          f = vr(f), m = Ct(m);
          var E = m ? of(f) : 0;
          return m && E < m ? lv(m - E, w) + f : f;
        }
        function gG(f, m, w) {
          return w || m == null ? m = 0 : m && (m = +m), Cq(vr(f).replace(Dp, ""), m || 0);
        }
        function vG(f, m, w) {
          return (w ? Ci(f, m, w) : m === r) ? m = 1 : m = Ct(m), Mw(vr(f), m);
        }
        function yG() {
          var f = arguments, m = vr(f[0]);
          return f.length < 3 ? m : m.replace(f[1], f[2]);
        }
        var bG = ff(function(f, m, w) {
          return f + (w ? "_" : "") + m.toLowerCase();
        });
        function xG(f, m, w) {
          return w && typeof w != "number" && Ci(f, m, w) && (m = w = r), w = w === r ? ne : w >>> 0, w ? (f = vr(f), f && (typeof m == "string" || m != null && !t2(m)) && (m = ko(m), !m && nf(f)) ? _u(Fs(f), 0, w) : f.split(m, w)) : [];
        }
        var wG = ff(function(f, m, w) {
          return f + (w ? " " : "") + i2(m);
        });
        function kG(f, m, w) {
          return f = vr(f), w = w == null ? 0 : Ac(Ct(w), 0, f.length), m = ko(m), f.slice(w, w + m.length) == m;
        }
        function CG(f, m, w) {
          var E = R.templateSettings;
          w && Ci(f, m, w) && (m = r), f = vr(f), m = xv({}, m, E, sE);
          var F = xv({}, m.imports, E.imports, sE), L = Mn(F), V = mw(F, L), X, ee, pe = 0, ge = m.interpolate || Tn, ke = "__p += '", Ne = vw(
            (m.escape || Tn).source + "|" + ge.source + "|" + (ge === T0 ? We : Tn).source + "|" + (m.evaluate || Tn).source + "|$",
            "g"
          ), Ue = "//# sourceURL=" + (br.call(m, "sourceURL") ? (m.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Mj + "]") + `
`;
          f.replace(Ne, function(st, $t, Ht, _o, _i, So) {
            return Ht || (Ht = _o), ke += f.slice(pe, So).replace(bo, Yj), $t && (X = !0, ke += `' +
__e(` + $t + `) +
'`), _i && (ee = !0, ke += `';
` + _i + `;
__p += '`), Ht && (ke += `' +
((__t = (` + Ht + `)) == null ? '' : __t) +
'`), pe = So + st.length, st;
          }), ke += `';
`;
          var ot = br.call(m, "variable") && m.variable;
          if (!ot)
            ke = `with (obj) {
` + ke + `
}
`;
          else if (Te.test(ot))
            throw new gt(a);
          ke = (ee ? ke.replace($r, "") : ke).replace(Qn, "$1").replace(Yo, "$1;"), ke = "function(" + (ot || "obj") + `) {
` + (ot ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (X ? ", __e = _.escape" : "") + (ee ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ke + `return __p
}`;
          var Dt = YE(function() {
            return cr(L, Ue + "return " + ke).apply(r, V);
          });
          if (Dt.source = ke, e2(Dt))
            throw Dt;
          return Dt;
        }
        function _G(f) {
          return vr(f).toLowerCase();
        }
        function SG(f) {
          return vr(f).toUpperCase();
        }
        function AG(f, m, w) {
          if (f = vr(f), f && (w || m === r))
            return aA(f);
          if (!f || !(m = ko(m)))
            return f;
          var E = Fs(f), F = Fs(m), L = lA(E, F), V = uA(E, F) + 1;
          return _u(E, L, V).join("");
        }
        function EG(f, m, w) {
          if (f = vr(f), f && (w || m === r))
            return f.slice(0, hA(f) + 1);
          if (!f || !(m = ko(m)))
            return f;
          var E = Fs(f), F = uA(E, Fs(m)) + 1;
          return _u(E, 0, F).join("");
        }
        function DG(f, m, w) {
          if (f = vr(f), f && (w || m === r))
            return f.replace(Dp, "");
          if (!f || !(m = ko(m)))
            return f;
          var E = Fs(f), F = lA(E, Fs(m));
          return _u(E, F).join("");
        }
        function OG(f, m) {
          var w = z, E = N;
          if (Kr(m)) {
            var F = "separator" in m ? m.separator : F;
            w = "length" in m ? Ct(m.length) : w, E = "omission" in m ? ko(m.omission) : E;
          }
          f = vr(f);
          var L = f.length;
          if (nf(f)) {
            var V = Fs(f);
            L = V.length;
          }
          if (w >= L)
            return f;
          var X = w - of(E);
          if (X < 1)
            return E;
          var ee = V ? _u(V, 0, X).join("") : f.slice(0, X);
          if (F === r)
            return ee + E;
          if (V && (X += ee.length - X), t2(F)) {
            if (f.slice(X).search(F)) {
              var pe, ge = ee;
              for (F.global || (F = vw(F.source, vr(Je.exec(F)) + "g")), F.lastIndex = 0; pe = F.exec(ge); )
                var ke = pe.index;
              ee = ee.slice(0, ke === r ? X : ke);
            }
          } else if (f.indexOf(ko(F), X) != X) {
            var Ne = ee.lastIndexOf(F);
            Ne > -1 && (ee = ee.slice(0, Ne));
          }
          return ee + E;
        }
        function FG(f) {
          return f = vr(f), f && wc.test(f) ? f.replace(yo, oq) : f;
        }
        var TG = ff(function(f, m, w) {
          return f + (w ? " " : "") + m.toUpperCase();
        }), i2 = ZA("toUpperCase");
        function JE(f, m, w) {
          return f = vr(f), m = w ? r : m, m === r ? eq(f) ? lq(f) : Vj(f) : f.match(m) || [];
        }
        var YE = Mt(function(f, m) {
          try {
            return xo(f, r, m);
          } catch (w) {
            return e2(w) ? w : new gt(w);
          }
        }), MG = kl(function(f, m) {
          return ts(m, function(w) {
            w = da(w), xl(f, w, Yw(f[w], f));
          }), f;
        });
        function PG(f) {
          var m = f == null ? 0 : f.length, w = rt();
          return f = m ? jr(f, function(E) {
            if (typeof E[1] != "function")
              throw new rs(s);
            return [w(E[0]), E[1]];
          }) : [], Mt(function(E) {
            for (var F = -1; ++F < m; ) {
              var L = f[F];
              if (xo(L[0], this, E))
                return xo(L[1], this, E);
            }
          });
        }
        function RG(f) {
          return oU(is(f, h));
        }
        function o2(f) {
          return function() {
            return f;
          };
        }
        function NG(f, m) {
          return f == null || f !== f ? m : f;
        }
        var $G = tE(), IG = tE(!0);
        function Hi(f) {
          return f;
        }
        function s2(f) {
          return TA(typeof f == "function" ? f : is(f, h));
        }
        function BG(f) {
          return PA(is(f, h));
        }
        function LG(f, m) {
          return RA(f, is(m, h));
        }
        var zG = Mt(function(f, m) {
          return function(w) {
            return Bp(w, f, m);
          };
        }), jG = Mt(function(f, m) {
          return function(w) {
            return Bp(f, w, m);
          };
        });
        function a2(f, m, w) {
          var E = Mn(m), F = tv(m, E);
          w == null && !(Kr(m) && (F.length || !E.length)) && (w = m, m = f, f = this, F = tv(m, Mn(m)));
          var L = !(Kr(w) && "chain" in w) || !!w.chain, V = _l(f);
          return ts(F, function(X) {
            var ee = m[X];
            f[X] = ee, V && (f.prototype[X] = function() {
              var pe = this.__chain__;
              if (L || pe) {
                var ge = f(this.__wrapped__), ke = ge.__actions__ = ji(this.__actions__);
                return ke.push({ func: ee, args: arguments, thisArg: f }), ge.__chain__ = pe, ge;
              }
              return ee.apply(f, yu([this.value()], arguments));
            });
          }), f;
        }
        function qG() {
          return Un._ === this && (Un._ = pq), this;
        }
        function l2() {
        }
        function UG(f) {
          return f = Ct(f), Mt(function(m) {
            return NA(m, f);
          });
        }
        var HG = Lw(jr), VG = Lw(rA), WG = Lw(cw);
        function ZE(f) {
          return Ww(f) ? hw(da(f)) : kU(f);
        }
        function GG(f) {
          return function(m) {
            return f == null ? r : Ec(f, m);
          };
        }
        var KG = nE(), XG = nE(!0);
        function u2() {
          return [];
        }
        function c2() {
          return !1;
        }
        function QG() {
          return {};
        }
        function JG() {
          return "";
        }
        function YG() {
          return !0;
        }
        function ZG(f, m) {
          if (f = Ct(f), f < 1 || f > H)
            return [];
          var w = ne, E = Jn(f, ne);
          m = rt(m), f -= ne;
          for (var F = pw(E, m); ++w < f; )
            m(w);
          return F;
        }
        function eK(f) {
          return yt(f) ? jr(f, da) : Co(f) ? [f] : ji(bE(vr(f)));
        }
        function tK(f) {
          var m = ++fq;
          return vr(f) + m;
        }
        var rK = av(function(f, m) {
          return f + m;
        }, 0), nK = zw("ceil"), iK = av(function(f, m) {
          return f / m;
        }, 1), oK = zw("floor");
        function sK(f) {
          return f && f.length ? ev(f, Hi, Sw) : r;
        }
        function aK(f, m) {
          return f && f.length ? ev(f, rt(m, 2), Sw) : r;
        }
        function lK(f) {
          return oA(f, Hi);
        }
        function uK(f, m) {
          return oA(f, rt(m, 2));
        }
        function cK(f) {
          return f && f.length ? ev(f, Hi, Ow) : r;
        }
        function hK(f, m) {
          return f && f.length ? ev(f, rt(m, 2), Ow) : r;
        }
        var fK = av(function(f, m) {
          return f * m;
        }, 1), dK = zw("round"), pK = av(function(f, m) {
          return f - m;
        }, 0);
        function mK(f) {
          return f && f.length ? dw(f, Hi) : 0;
        }
        function gK(f, m) {
          return f && f.length ? dw(f, rt(m, 2)) : 0;
        }
        return R.after = BV, R.ary = FE, R.assign = SW, R.assignIn = HE, R.assignInWith = xv, R.assignWith = AW, R.at = EW, R.before = TE, R.bind = Yw, R.bindAll = MG, R.bindKey = ME, R.castArray = QV, R.chain = EE, R.chunk = oH, R.compact = sH, R.concat = aH, R.cond = PG, R.conforms = RG, R.constant = o2, R.countBy = mV, R.create = DW, R.curry = PE, R.curryRight = RE, R.debounce = NE, R.defaults = OW, R.defaultsDeep = FW, R.defer = LV, R.delay = zV, R.difference = lH, R.differenceBy = uH, R.differenceWith = cH, R.drop = hH, R.dropRight = fH, R.dropRightWhile = dH, R.dropWhile = pH, R.fill = mH, R.filter = vV, R.flatMap = xV, R.flatMapDeep = wV, R.flatMapDepth = kV, R.flatten = CE, R.flattenDeep = gH, R.flattenDepth = vH, R.flip = jV, R.flow = $G, R.flowRight = IG, R.fromPairs = yH, R.functions = IW, R.functionsIn = BW, R.groupBy = CV, R.initial = xH, R.intersection = wH, R.intersectionBy = kH, R.intersectionWith = CH, R.invert = zW, R.invertBy = jW, R.invokeMap = SV, R.iteratee = s2, R.keyBy = AV, R.keys = Mn, R.keysIn = Ui, R.map = pv, R.mapKeys = UW, R.mapValues = HW, R.matches = BG, R.matchesProperty = LG, R.memoize = gv, R.merge = VW, R.mergeWith = VE, R.method = zG, R.methodOf = jG, R.mixin = a2, R.negate = vv, R.nthArg = UG, R.omit = WW, R.omitBy = GW, R.once = qV, R.orderBy = EV, R.over = HG, R.overArgs = UV, R.overEvery = VG, R.overSome = WG, R.partial = Zw, R.partialRight = $E, R.partition = DV, R.pick = KW, R.pickBy = WE, R.property = ZE, R.propertyOf = GG, R.pull = EH, R.pullAll = SE, R.pullAllBy = DH, R.pullAllWith = OH, R.pullAt = FH, R.range = KG, R.rangeRight = XG, R.rearg = HV, R.reject = TV, R.remove = TH, R.rest = VV, R.reverse = Qw, R.sampleSize = PV, R.set = QW, R.setWith = JW, R.shuffle = RV, R.slice = MH, R.sortBy = IV, R.sortedUniq = LH, R.sortedUniqBy = zH, R.split = xG, R.spread = WV, R.tail = jH, R.take = qH, R.takeRight = UH, R.takeRightWhile = HH, R.takeWhile = VH, R.tap = sV, R.throttle = GV, R.thru = dv, R.toArray = jE, R.toPairs = GE, R.toPairsIn = KE, R.toPath = eK, R.toPlainObject = UE, R.transform = YW, R.unary = KV, R.union = WH, R.unionBy = GH, R.unionWith = KH, R.uniq = XH, R.uniqBy = QH, R.uniqWith = JH, R.unset = ZW, R.unzip = Jw, R.unzipWith = AE, R.update = eG, R.updateWith = tG, R.values = mf, R.valuesIn = rG, R.without = YH, R.words = JE, R.wrap = XV, R.xor = ZH, R.xorBy = eV, R.xorWith = tV, R.zip = rV, R.zipObject = nV, R.zipObjectDeep = iV, R.zipWith = oV, R.entries = GE, R.entriesIn = KE, R.extend = HE, R.extendWith = xv, a2(R, R), R.add = rK, R.attempt = YE, R.camelCase = sG, R.capitalize = XE, R.ceil = nK, R.clamp = nG, R.clone = JV, R.cloneDeep = ZV, R.cloneDeepWith = eW, R.cloneWith = YV, R.conformsTo = tW, R.deburr = QE, R.defaultTo = NG, R.divide = iK, R.endsWith = aG, R.eq = Ms, R.escape = lG, R.escapeRegExp = uG, R.every = gV, R.find = yV, R.findIndex = wE, R.findKey = TW, R.findLast = bV, R.findLastIndex = kE, R.findLastKey = MW, R.floor = oK, R.forEach = DE, R.forEachRight = OE, R.forIn = PW, R.forInRight = RW, R.forOwn = NW, R.forOwnRight = $W, R.get = r2, R.gt = rW, R.gte = nW, R.has = LW, R.hasIn = n2, R.head = _E, R.identity = Hi, R.includes = _V, R.indexOf = bH, R.inRange = iG, R.invoke = qW, R.isArguments = Fc, R.isArray = yt, R.isArrayBuffer = iW, R.isArrayLike = qi, R.isArrayLikeObject = cn, R.isBoolean = oW, R.isBuffer = Su, R.isDate = sW, R.isElement = aW, R.isEmpty = lW, R.isEqual = uW, R.isEqualWith = cW, R.isError = e2, R.isFinite = hW, R.isFunction = _l, R.isInteger = IE, R.isLength = yv, R.isMap = BE, R.isMatch = fW, R.isMatchWith = dW, R.isNaN = pW, R.isNative = mW, R.isNil = vW, R.isNull = gW, R.isNumber = LE, R.isObject = Kr, R.isObjectLike = tn, R.isPlainObject = Hp, R.isRegExp = t2, R.isSafeInteger = yW, R.isSet = zE, R.isString = bv, R.isSymbol = Co, R.isTypedArray = pf, R.isUndefined = bW, R.isWeakMap = xW, R.isWeakSet = wW, R.join = _H, R.kebabCase = cG, R.last = ss, R.lastIndexOf = SH, R.lowerCase = hG, R.lowerFirst = fG, R.lt = kW, R.lte = CW, R.max = sK, R.maxBy = aK, R.mean = lK, R.meanBy = uK, R.min = cK, R.minBy = hK, R.stubArray = u2, R.stubFalse = c2, R.stubObject = QG, R.stubString = JG, R.stubTrue = YG, R.multiply = fK, R.nth = AH, R.noConflict = qG, R.noop = l2, R.now = mv, R.pad = dG, R.padEnd = pG, R.padStart = mG, R.parseInt = gG, R.random = oG, R.reduce = OV, R.reduceRight = FV, R.repeat = vG, R.replace = yG, R.result = XW, R.round = dK, R.runInContext = Z, R.sample = MV, R.size = NV, R.snakeCase = bG, R.some = $V, R.sortedIndex = PH, R.sortedIndexBy = RH, R.sortedIndexOf = NH, R.sortedLastIndex = $H, R.sortedLastIndexBy = IH, R.sortedLastIndexOf = BH, R.startCase = wG, R.startsWith = kG, R.subtract = pK, R.sum = mK, R.sumBy = gK, R.template = CG, R.times = ZG, R.toFinite = Sl, R.toInteger = Ct, R.toLength = qE, R.toLower = _G, R.toNumber = as, R.toSafeInteger = _W, R.toString = vr, R.toUpper = SG, R.trim = AG, R.trimEnd = EG, R.trimStart = DG, R.truncate = OG, R.unescape = FG, R.uniqueId = tK, R.upperCase = TG, R.upperFirst = i2, R.each = DE, R.eachRight = OE, R.first = _E, a2(R, (function() {
          var f = {};
          return ha(R, function(m, w) {
            br.call(R.prototype, w) || (f[w] = m);
          }), f;
        })(), { chain: !1 }), R.VERSION = n, ts(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(f) {
          R[f].placeholder = R;
        }), ts(["drop", "take"], function(f, m) {
          Lt.prototype[f] = function(w) {
            w = w === r ? 1 : _n(Ct(w), 0);
            var E = this.__filtered__ && !m ? new Lt(this) : this.clone();
            return E.__filtered__ ? E.__takeCount__ = Jn(w, E.__takeCount__) : E.__views__.push({
              size: Jn(w, ne),
              type: f + (E.__dir__ < 0 ? "Right" : "")
            }), E;
          }, Lt.prototype[f + "Right"] = function(w) {
            return this.reverse()[f](w).reverse();
          };
        }), ts(["filter", "map", "takeWhile"], function(f, m) {
          var w = m + 1, E = w == B || w == j;
          Lt.prototype[f] = function(F) {
            var L = this.clone();
            return L.__iteratees__.push({
              iteratee: rt(F, 3),
              type: w
            }), L.__filtered__ = L.__filtered__ || E, L;
          };
        }), ts(["head", "last"], function(f, m) {
          var w = "take" + (m ? "Right" : "");
          Lt.prototype[f] = function() {
            return this[w](1).value()[0];
          };
        }), ts(["initial", "tail"], function(f, m) {
          var w = "drop" + (m ? "" : "Right");
          Lt.prototype[f] = function() {
            return this.__filtered__ ? new Lt(this) : this[w](1);
          };
        }), Lt.prototype.compact = function() {
          return this.filter(Hi);
        }, Lt.prototype.find = function(f) {
          return this.filter(f).head();
        }, Lt.prototype.findLast = function(f) {
          return this.reverse().find(f);
        }, Lt.prototype.invokeMap = Mt(function(f, m) {
          return typeof f == "function" ? new Lt(this) : this.map(function(w) {
            return Bp(w, f, m);
          });
        }), Lt.prototype.reject = function(f) {
          return this.filter(vv(rt(f)));
        }, Lt.prototype.slice = function(f, m) {
          f = Ct(f);
          var w = this;
          return w.__filtered__ && (f > 0 || m < 0) ? new Lt(w) : (f < 0 ? w = w.takeRight(-f) : f && (w = w.drop(f)), m !== r && (m = Ct(m), w = m < 0 ? w.dropRight(-m) : w.take(m - f)), w);
        }, Lt.prototype.takeRightWhile = function(f) {
          return this.reverse().takeWhile(f).reverse();
        }, Lt.prototype.toArray = function() {
          return this.take(ne);
        }, ha(Lt.prototype, function(f, m) {
          var w = /^(?:filter|find|map|reject)|While$/.test(m), E = /^(?:head|last)$/.test(m), F = R[E ? "take" + (m == "last" ? "Right" : "") : m], L = E || /^find/.test(m);
          F && (R.prototype[m] = function() {
            var V = this.__wrapped__, X = E ? [1] : arguments, ee = V instanceof Lt, pe = X[0], ge = ee || yt(V), ke = function($t) {
              var Ht = F.apply(R, yu([$t], X));
              return E && Ne ? Ht[0] : Ht;
            };
            ge && w && typeof pe == "function" && pe.length != 1 && (ee = ge = !1);
            var Ne = this.__chain__, Ue = !!this.__actions__.length, ot = L && !Ne, Dt = ee && !Ue;
            if (!L && ge) {
              V = Dt ? V : new Lt(this);
              var st = f.apply(V, X);
              return st.__actions__.push({ func: dv, args: [ke], thisArg: r }), new ns(st, Ne);
            }
            return ot && Dt ? f.apply(this, X) : (st = this.thru(ke), ot ? E ? st.value()[0] : st.value() : st);
          });
        }), ts(["pop", "push", "shift", "sort", "splice", "unshift"], function(f) {
          var m = L0[f], w = /^(?:push|sort|unshift)$/.test(f) ? "tap" : "thru", E = /^(?:pop|shift)$/.test(f);
          R.prototype[f] = function() {
            var F = arguments;
            if (E && !this.__chain__) {
              var L = this.value();
              return m.apply(yt(L) ? L : [], F);
            }
            return this[w](function(V) {
              return m.apply(yt(V) ? V : [], F);
            });
          };
        }), ha(Lt.prototype, function(f, m) {
          var w = R[m];
          if (w) {
            var E = w.name + "";
            br.call(uf, E) || (uf[E] = []), uf[E].push({ name: m, func: w });
          }
        }), uf[sv(r, b).name] = [{
          name: "wrapper",
          func: r
        }], Lt.prototype.clone = Fq, Lt.prototype.reverse = Tq, Lt.prototype.value = Mq, R.prototype.at = aV, R.prototype.chain = lV, R.prototype.commit = uV, R.prototype.next = cV, R.prototype.plant = fV, R.prototype.reverse = dV, R.prototype.toJSON = R.prototype.valueOf = R.prototype.value = pV, R.prototype.first = R.prototype.head, Tp && (R.prototype[Tp] = hV), R;
      }), sf = uq();
      kc ? ((kc.exports = sf)._ = sf, sw._ = sf) : Un._ = sf;
    }).call(Gke);
  })(e1, e1.exports)), e1.exports;
}
var A_ = Kke();
const nj = /* @__PURE__ */ O5(A_), Xke = {
  headerHeight: null,
  columnConfigs: {},
  onColumnConfigsChange: () => {
  },
  minColumnWidths: {},
  rowRenderBatchSize: 4,
  minFetchSize: 1,
  renderWindowOffset: 400,
  verticalScrollbarPillHeight: 4,
  verticalScrollbarWidth: 24,
  horizontalScrollbarHeight: 16,
  lineHeight: 20,
  textMaxLines: 3,
  betweenRowPadding: 8,
  betweenColPadding: 24,
  scrollOverflowValue: 1e6,
  // keep this below chrome's maximum translate value
  onRowClick: null,
  highlightedRows: null,
  firstColLeftPadding: 8,
  showRowNumber: !0,
  onShowRowNumberChange: () => {
  },
  highlightHoveredRow: !1,
  get rowHeight() {
    return this.textMaxLines * this.lineHeight + this.betweenRowPadding;
  },
  DEFAULT_TEXT_MAX_LINES: 3,
  DEFAULT_LINE_HEIGHT: 20,
  DEFAULT_ROW_NUMBER_COL_WIDTH: 60
};
class Qke {
  #e = /* @__PURE__ */ qe(ui(Xke));
  get config() {
    return q(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const GO = Symbol("config");
class xr {
  static initialize() {
    fs(GO, new Qke());
  }
  static get config() {
    const e = Qi(GO);
    if (e == null)
      throw new Error("config context not yet set");
    return e.config;
  }
}
class Jke {
  tableModel;
  tableController;
  margin = 2;
  isDragging = !1;
  lastDragX = 0;
  #e = /* @__PURE__ */ qe(0);
  get elementWidth() {
    return q(this.#e);
  }
  set elementWidth(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ Se(() => this.elementWidth - this.margin * 2);
  get scrollbarWidth() {
    return q(this.#t);
  }
  set scrollbarWidth(e) {
    be(this.#t, e);
  }
  #r = /* @__PURE__ */ Se(() => this.tableController.viewWidth / this.tableModel.colsRightmostPosition * this.scrollbarWidth);
  get pillWidth() {
    return q(this.#r);
  }
  set pillWidth(e) {
    be(this.#r, e);
  }
  #n = /* @__PURE__ */ Se(() => -this.tableController.xScroll / this.tableModel.colsRightmostPosition * this.scrollbarWidth);
  get pillLeft() {
    return q(this.#n);
  }
  set pillLeft(e) {
    be(this.#n, e);
  }
  constructor({ tableModel: e, tableController: r }) {
    this.tableModel = e, this.tableController = r;
  }
  handlePointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0, this.lastDragX = e.offsetX;
  };
  handlePointerMove = (e) => {
    this.isDragging && this.lastDragX !== null && this.tableController.scroll({ deltaX: e.offsetX - this.lastDragX, deltaY: 0 });
  };
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.lastDragX = null;
  };
}
const KO = Symbol("mosaic-coordinator");
class E_ {
  static get coordinator() {
    return Qi(KO) ?? SF();
  }
  static set coordinator(e) {
    fs(KO, e);
  }
}
const Gi = "__oid", Yke = 120;
class Zke {
  schema;
  #e = /* @__PURE__ */ qe(ui({}));
  get data() {
    return q(this.#e);
  }
  set data(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ qe(ui({}));
  get defaultColWidths() {
    return q(this.#t);
  }
  set defaultColWidths(e) {
    be(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ qe(ui([]));
  get columns() {
    return q(this.#r);
  }
  set columns(e) {
    be(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ qe(0);
  get numRows() {
    return q(this.#n);
  }
  set numRows(e) {
    be(this.#n, e, !0);
  }
  #l = /* @__PURE__ */ qe(0);
  get renderOffset() {
    return q(this.#l);
  }
  set renderOffset(e) {
    be(this.#l, e, !0);
  }
  #a = /* @__PURE__ */ qe(ui({}));
  get rowHeightAddition() {
    return q(this.#a);
  }
  set rowHeightAddition(e) {
    be(this.#a, e, !0);
  }
  #i = /* @__PURE__ */ Se(() => this.columns.reduce(
    (e, r) => (xr.config.columnConfigs[r]?.hidden && e.add(r), r === Gi && xr.config.showRowNumber === !1 && e.add(Gi), e),
    /* @__PURE__ */ new Set()
  ));
  get hiddenColumns() {
    return q(this.#i);
  }
  set hiddenColumns(e) {
    be(this.#i, e);
  }
  rowKeyColumn = null;
  constructor(e) {
    this.schema = e;
  }
  #o = /* @__PURE__ */ Se(() => Object.keys(this.data).sort((e, r) => this.data[e][Gi] - this.data[r][Gi]));
  get renderableRows() {
    return q(this.#o);
  }
  set renderableRows(e) {
    be(this.#o, e);
  }
  #s = /* @__PURE__ */ Se(() => this.columns.filter((e) => !this.hiddenColumns.has(e)));
  get renderableCols() {
    return q(this.#s);
  }
  set renderableCols(e) {
    be(this.#s, e);
  }
  #u = /* @__PURE__ */ Se(() => this.renderableRows.length === 0 ? this.zeroRowPosition : Math.min(...this.renderableRows.map((e) => this.rowPositions[e])));
  get minRowPosition() {
    return q(this.#u);
  }
  set minRowPosition(e) {
    be(this.#u, e);
  }
  #c = /* @__PURE__ */ Se(() => this.renderableRows.length === 0 ? this.finalRowPosition : Math.max(...this.renderableRows.map((e) => this.rowPositions[e])));
  get maxRowPosition() {
    return q(this.#c);
  }
  set maxRowPosition(e) {
    be(this.#c, e);
  }
  #d = /* @__PURE__ */ Se(() => {
    const e = Math.min(...this.renderableRows.map((r) => this.data[r][Gi]));
    return Number.isSafeInteger(e) ? e : 0;
  });
  get minRowOID() {
    return q(this.#d);
  }
  set minRowOID(e) {
    be(this.#d, e);
  }
  #h = /* @__PURE__ */ Se(() => {
    const e = Math.max(...this.renderableRows.map((r) => this.data[r][Gi]));
    return Number.isSafeInteger(e) ? e : 0;
  });
  get maxRowOID() {
    return q(this.#h);
  }
  set maxRowOID(e) {
    be(this.#h, e);
  }
  #p = /* @__PURE__ */ Se(() => 0);
  get zeroRowPosition() {
    return q(this.#p);
  }
  set zeroRowPosition(e) {
    be(this.#p, e);
  }
  #f = /* @__PURE__ */ Se(() => (this.numRows - 1) * xr.config.rowHeight + this.rowPositionOffsets.cumulative);
  get finalRowPosition() {
    return q(this.#f);
  }
  set finalRowPosition(e) {
    be(this.#f, e);
  }
  colsLeftmostPosition = 0;
  #v = /* @__PURE__ */ Se(() => {
    const e = this.renderableCols[this.renderableCols.length - 1];
    return this.colPositions[e] + this.colWidths[e];
  });
  get colsRightmostPosition() {
    return q(this.#v);
  }
  set colsRightmostPosition(e) {
    be(this.#v, e);
  }
  #y = /* @__PURE__ */ Se(() => this.renderableRows.reduce(
    ({ offsets: e, cumulative: r }, n) => {
      e[n] = r;
      const i = this.rowHeightAddition[n] ?? 0;
      return { offsets: e, cumulative: r + i };
    },
    { offsets: {}, cumulative: 0 }
  ));
  get rowPositionOffsets() {
    return q(this.#y);
  }
  set rowPositionOffsets(e) {
    be(this.#y, e);
  }
  #b = /* @__PURE__ */ Se(() => this.renderableRows.reduce(
    (e, r) => {
      const n = (this.data[r][Gi] - 1) * xr.config.rowHeight + this.rowPositionOffsets.offsets[r];
      return e[r] = n, e;
    },
    {}
  ));
  get rowPositions() {
    return q(this.#b);
  }
  set rowPositions(e) {
    be(this.#b, e);
  }
  #x = /* @__PURE__ */ Se(() => {
    let e = 0;
    return this.columns.reduce(
      (r, n, i) => (this.hiddenColumns.has(n) || (r[n] = e, e += this.colWidths[n]), r),
      {}
    );
  });
  get colPositions() {
    return q(this.#x);
  }
  set colPositions(e) {
    be(this.#x, e);
  }
  #m = /* @__PURE__ */ Se(() => this.renderableRows.reduce(
    (e, r) => (e[r] = xr.config.rowHeight + (this.rowHeightAddition[r] ?? 0), e),
    {}
  ));
  get rowHeights() {
    return q(this.#m);
  }
  set rowHeights(e) {
    be(this.#m, e);
  }
  #g = /* @__PURE__ */ Se(() => this.columns.reduce(
    (e, r, n) => (e[r] = Math.max(xr.config.columnConfigs[r]?.width ?? this.defaultColWidths[r] ?? Yke, xr.config.minColumnWidths[r] ?? 0), this.isFirstCol(r) && (e[r] += xr.config.firstColLeftPadding), this.isLastCol(r) && (e[r] += xr.config.verticalScrollbarWidth), e),
    {}
  ));
  get colWidths() {
    return q(this.#g);
  }
  set colWidths(e) {
    be(this.#g, e);
  }
  getContent({ row: e, col: r }) {
    return this.data[e] ? this.data[e][r] : null;
  }
  getRowData(e) {
    return this.data[e] ? this.data[e] : null;
  }
  getPosition({ row: e, col: r }) {
    const n = this.colPositions[r], i = this.rowPositions[e];
    return { x: n, y: i };
  }
  getDimensions({ row: e, col: r }) {
    const n = this.colWidths[r], i = this.rowHeights[e];
    return { width: n, height: i };
  }
  getRowParity(e) {
    return this.data[e] && this.data[e][Gi] % 2 === 0 ? "even" : "odd";
  }
  isFirstCol(e) {
    return this.renderableCols.indexOf(e) === 0;
  }
  isLastCol(e) {
    return this.renderableCols.indexOf(e) === this.renderableCols.length - 1;
  }
  // Deletes the given row and returns the offset necessary to remove from scroll position.
  deleteRow(e) {
    delete this.data[e];
    const r = this.rowHeightAddition[e] ?? 0;
    return delete this.rowHeightAddition[e], r;
  }
  collapseRow(e) {
    const r = this.rowHeightAddition[e] ?? 0;
    return delete this.rowHeightAddition[e], r;
  }
  reset() {
    this.data = {}, this.rowHeightAddition = {};
  }
  teardown() {
    this.reset();
  }
}
class e3e extends F_ {
  tableName;
  onResult;
  constructor(e, r, n) {
    super(r ?? void 0), this.tableName = e, this.onResult = n;
  }
  queryResult(e) {
    const r = e.toArray()[0].count;
    return this.onResult(r), this;
  }
  query(e = []) {
    return pd.from(this.tableName).select({ count: CK() }).where(e);
  }
}
const Ki = "__oid";
class t3e extends F_ {
  tableName;
  columns;
  onResult;
  onColumnInfo;
  limit = 20;
  offset = 0;
  sort = null;
  info = null;
  columnInfo = null;
  isReady = !1;
  constructor(e, r, n, i, o) {
    super(n ?? void 0), this.tableName = e, this.columns = r, this.onResult = i, this.onColumnInfo = o;
  }
  async prepare() {
    if (this.coordinator == null)
      return;
    const e = (await yK(this.coordinator, [{ table: this.tableName, column: "*" }])).reduce((r, n) => (r[n.column] = n, r), {});
    this.columnInfo = e, this.onColumnInfo(e), this.isReady = !0;
  }
  getSelect({ includeRowNumber: e } = { includeRowNumber: !0 }) {
    const r = this.columns.reduce((n, i) => (this.columnInfo?.[i]?.sqlType === "BIGINT" ? n[i] = rD(cm(i), "TEXT") : n[i] = cm(i), n), {});
    return e || delete r[Ki], r;
  }
  queryResult(e) {
    return this.onResult(e), this;
  }
  query(e = []) {
    if (!this.isReady)
      return null;
    const r = this.columns.reduce((n, i) => (this.columnInfo?.[i]?.sqlType === "BIGINT" ? n[i] = rD(cm(i), "TEXT") : n[i] = cm(i), n), {});
    if (r[Ki] = wK(), this.sort) {
      const n = this.sort.direction === "ascending" ? this.sort.column : kK(this.sort.column);
      r[Ki] = r[Ki].orderby(n);
    }
    return pd.from(this.tableName).select(r).where(e).limit(this.limit).offset(this.offset);
  }
  fetchRows(e, r) {
    this.offset = e, this.limit = r, this.requestUpdate();
  }
}
class r3e {
  model;
  schema;
  config;
  #e = /* @__PURE__ */ Se(() => E_.coordinator);
  get coordinator() {
    return q(this.#e);
  }
  set coordinator(e) {
    be(this.#e, e);
  }
  filterBy = null;
  rowsClient = null;
  numRowsClient = null;
  rowKeyColumn = null;
  #t = /* @__PURE__ */ qe(null);
  get element() {
    return q(this.#t);
  }
  set element(e) {
    be(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ qe(0);
  get viewHeight() {
    return q(this.#r);
  }
  set viewHeight(e) {
    be(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ qe(0);
  get viewWidth() {
    return q(this.#n);
  }
  set viewWidth(e) {
    be(this.#n, e, !0);
  }
  #l = /* @__PURE__ */ qe(0);
  get yScroll() {
    return q(this.#l);
  }
  set yScroll(e) {
    be(this.#l, e, !0);
  }
  #a = /* @__PURE__ */ qe(0);
  get xScroll() {
    return q(this.#a);
  }
  set xScroll(e) {
    be(this.#a, e, !0);
  }
  #i = /* @__PURE__ */ qe(!1);
  get isFetching() {
    return q(this.#i);
  }
  set isFetching(e) {
    be(this.#i, e, !0);
  }
  #o = /* @__PURE__ */ qe(!1);
  get isJumping() {
    return q(this.#o);
  }
  set isJumping(e) {
    be(this.#o, e, !0);
  }
  #s = /* @__PURE__ */ qe(null);
  get sort() {
    return q(this.#s);
  }
  set sort(e) {
    be(this.#s, e, !0);
  }
  #u = /* @__PURE__ */ qe(!1);
  get isReady() {
    return q(this.#u);
  }
  set isReady(e) {
    be(this.#u, e, !0);
  }
  #c = /* @__PURE__ */ qe(0);
  get updateKey() {
    return q(this.#c);
  }
  set updateKey(e) {
    be(this.#c, e, !0);
  }
  #d = /* @__PURE__ */ qe(!1);
  get isStale() {
    return q(this.#d);
  }
  set isStale(e) {
    be(this.#d, e, !0);
  }
  #h = /* @__PURE__ */ qe(null);
  get flashedRowId() {
    return q(this.#h);
  }
  set flashedRowId(e) {
    be(this.#h, e, !0);
  }
  #p = /* @__PURE__ */ qe(null);
  get hoveredRowId() {
    return q(this.#p);
  }
  set hoveredRowId(e) {
    be(this.#p, e, !0);
  }
  #f = /* @__PURE__ */ Se(() => Math.ceil(this.viewHeight / xr.config.rowHeight));
  get rowsOnScreen() {
    return q(this.#f);
  }
  set rowsOnScreen(e) {
    be(this.#f, e);
  }
  #v = /* @__PURE__ */ Se(() => this.isJumping ? 0 : xr.config.renderWindowOffset);
  get renderWindowOffset() {
    return q(this.#v);
  }
  set renderWindowOffset(e) {
    be(this.#v, e);
  }
  #y = /* @__PURE__ */ Se(() => {
    if (this.model.renderableRows.length === 0)
      return null;
    const e = this.model.renderableRows.filter((n) => {
      const i = this.model.rowPositions[n] + this.yScroll;
      return i + this.model.rowHeights[n] > 0 && i < this.viewHeight;
    });
    if (e.length === 0)
      return null;
    const r = e[0];
    return this.model.data[r][Ki];
  });
  get firstVisibleRowOID() {
    return q(this.#y);
  }
  set firstVisibleRowOID(e) {
    be(this.#y, e);
  }
  #b = /* @__PURE__ */ Se(() => Math.max(0, Math.floor(-this.yScroll / xr.config.rowHeight)));
  get offset() {
    return q(this.#b);
  }
  set offset(e) {
    be(this.#b, e);
  }
  onFetchResolveBegin = null;
  onFetchResolveEnd = null;
  constructor(e, r) {
    this.model = e, this.schema = r, this.config = xr.config;
  }
  handleFilterBy = () => {
    this.rowsClient && (this.rowsClient.offset = 0, this.rowsClient.limit = this.rowsOnScreen, this.isJumping = !0, this.markStale());
  };
  updateData = (e) => {
    if (!this.model || !this.rowKeyColumn)
      return;
    this.onFetchResolveBegin && (this.onFetchResolveBegin(), this.onFetchResolveBegin = null);
    const r = e.toArray(), n = {};
    for (const i of r) {
      const o = i[this.rowKeyColumn];
      n[o] = i;
    }
    this.model.data = { ...this.model.data, ...n }, this.onFetchResolveEnd && (this.onFetchResolveEnd(), this.onFetchResolveEnd = null), this.isFetching = !1;
  };
  initialize({ tableName: e, rowKey: r, columns: n, filterBy: i }) {
    if (this.model.columns = n, this.model.rowKeyColumn = r, this.rowKeyColumn = r, i && (this.filterBy = i, this.filterBy.addEventListener("value", this.handleFilterBy)), !this.rowKeyColumn)
      throw new Error("rowkey cannot be null");
    let o = n.includes(this.rowKeyColumn) ? n : [...n, this.rowKeyColumn];
    this.rowsClient = new t3e(
      e,
      o,
      i,
      (s) => {
        this.updateData(s);
      },
      (s) => {
        this.schema.columnInfo = s, this.computeColWidths(e, n), this.isReady = !0;
      }
    ), this.coordinator.connect(this.rowsClient), this.numRowsClient = new e3e(e, i, (s) => {
      this.model && (this.model.numRows = s);
    }), this.coordinator.connect(this.numRowsClient), Qr(() => {
      if (!this.rowsClient || this.isFetching || !this.isReady)
        return;
      const s = -this.renderWindowOffset, a = this.viewHeight + this.renderWindowOffset, l = this.model.maxRowPosition + this.yScroll + this.config.rowHeight, u = this.model.minRowPosition + this.yScroll;
      if (u < 0 && l < 0 || u > this.viewHeight && l > this.viewHeight) {
        const v = this.rowsOnScreen;
        this.isFetching = !0, this.rowsClient.fetchRows(this.offset, v);
      } else {
        if (l < a) {
          const y = A_.clamp(Math.ceil((a - l) / this.config.rowHeight), this.config.minFetchSize, this.rowsOnScreen);
          y > 0 && this.model.maxRowOID !== this.model.numRows && (this.isFetching = !0, this.rowsClient.fetchRows(this.model.maxRowOID, y));
        }
        const v = this.model.minRowPosition + this.yScroll;
        if (v > s && this.model.minRowOID !== 1) {
          const y = A_.clamp(Math.ceil((v - s) / this.config.rowHeight), this.config.minFetchSize, this.rowsOnScreen);
          y > 0 && (this.isFetching = !0, this.rowsClient.fetchRows(Math.max(0, this.model.minRowOID - 1 - y), y));
        }
      }
      const c = bz(this.model.renderableRows);
      let h = 0;
      for (; this.model.rowPositions[c[h]] + this.yScroll + this.model.rowHeights[c[h]] < 0; )
        this.yScroll += this.model.collapseRow(c[h]), h += 1;
      let d = c.length - 1;
      for (; this.model.rowPositions[c[d]] + this.yScroll > this.viewHeight; )
        this.model.collapseRow(c[d]), d -= 1;
      let p = 0;
      for (; this.model.rowPositions[c[p]] + this.yScroll + this.model.rowHeights[c[p]] < s; )
        this.model.deleteRow(c[p]), p += 1;
      let g = c.length - 1;
      for (; this.model.rowPositions[c[g]] + this.yScroll > a; )
        this.model.deleteRow(c[g]), g -= 1;
    });
  }
  teardown() {
    this.filterBy && this.filterBy.removeEventListener("value", this.handleFilterBy);
  }
  cellIsVisible(e) {
    const { x: r, y: n } = this.model.getPosition(e), { width: i, height: o } = this.model.getDimensions(e), s = r + this.xScroll, a = n + this.yScroll;
    return s + i >= 0 && s <= this.viewWidth && a + o >= 0 && a <= this.viewHeight;
  }
  rowIsVisible(e) {
    const r = this.model.rowPositions[e], n = this.model.rowHeights[e], i = r + this.yScroll;
    return i + n >= 0 && i <= this.viewHeight;
  }
  rowStillExists(e) {
    return this.model.data[e] != null;
  }
  colIsVisible(e) {
    const r = this.model.colPositions[e], n = this.model.colWidths[e], i = r + this.xScroll;
    return i + n >= 0 && i <= this.viewWidth;
  }
  scroll({ deltaX: e, deltaY: r }) {
    if (Math.abs(r) > Math.abs(e)) {
      const n = this.yScroll - r;
      this.model.zeroRowPosition + n > 0 ? this.yScroll = -this.model.zeroRowPosition : this.model.finalRowPosition + n < 0 ? this.yScroll = -this.model.finalRowPosition : this.yScroll = n;
    } else {
      const n = this.xScroll - e;
      -n < 0 ? this.xScroll = 0 : -n > Math.max(this.model.colsRightmostPosition, this.viewWidth) - this.viewWidth ? this.xScroll = -Math.max(this.model.colsRightmostPosition, this.viewWidth) + this.viewWidth : this.xScroll = n;
    }
  }
  handleWheel = (e) => {
    e.preventDefault(), this.isJumping = !1, this.scroll({ deltaX: e.deltaX, deltaY: e.deltaY });
  };
  jumpToOffset(e) {
    if (!this.rowsClient)
      return;
    this.isFetching = !0;
    const r = this.rowsOnScreen, n = this.onFetchResolveEnd;
    this.onFetchResolveEnd = () => {
      n && n(), this.yScroll = -(e * this.config.rowHeight);
    }, this.markStale(), this.rowsClient.fetchRows(e, r);
  }
  handleSort = (e) => {
    this.rowsClient && (this.sort = e, this.rowsClient.sort = e, this.resetRows());
  };
  resetRows() {
    this.model.reset(), this.yScroll = 0;
  }
  flashRow(e) {
    this.flashedRowId = e, setTimeout(
      () => {
        this.flashedRowId = null;
      },
      400
    );
  }
  async scrollToRow(e, r = !0) {
    if (!this.rowsClient)
      return;
    this.isFetching = !0;
    const n = pd.with({
      original: this.rowsClient.query(this.rowsClient.filterBy?.predicate(this.rowsClient)).offset(0).limit(this.model.numRows)
    }).select([Ki]).from("original").where(bK(cm(this.rowKeyColumn), xK(e))), i = (await this.coordinator.query(n)).toArray();
    if (i.length > 0) {
      const o = i[0][Ki] - 1;
      this.onFetchResolveEnd = () => {
        r && this.flashRow(e);
      }, this.jumpToOffset(o);
    } else
      this.isFetching = !1, console.error("no row", e, "found");
  }
  addHeightToRow(e, r) {
    this.model.rowHeightAddition[e] = (this.model.rowHeightAddition[e] ?? 0) + r;
  }
  hideColumn(e) {
    e === Ki ? this.config.onShowRowNumberChange ? this.config.onShowRowNumberChange(!1) : this.config.showRowNumber = !1 : (this.config.columnConfigs[e] || (this.config.columnConfigs[e] = {}), this.config.columnConfigs[e].hidden = !0);
  }
  showColumn(e) {
    e === Ki ? this.config.onShowRowNumberChange ? this.config.onShowRowNumberChange(!0) : this.config.showRowNumber = !0 : (this.config.columnConfigs[e] || (this.config.columnConfigs[e] = {}), this.config.columnConfigs[e].hidden = !1);
  }
  // Marks the current state stale, telling the view to destroy any existing cells on next render.
  markStale() {
    this.isStale = !0;
    const e = this.onFetchResolveBegin;
    this.onFetchResolveBegin = () => {
      e && e(), this.resetRows();
    };
    const r = this.onFetchResolveEnd;
    this.onFetchResolveEnd = () => {
      r && r(), this.updateKey += 1, this.isStale = !1;
    };
  }
  async computeColWidths(e, r) {
    const n = r.filter((l) => l !== Ki), i = this.rowsClient?.getSelect({ includeRowNumber: !1 }), o = n.reduce(
      (l, u) => (l[u] = 0, l),
      {}
    ), s = pd.from(e).select(i).offset(0).limit(10), a = (await this.coordinator.query(s)).toArray();
    for (const l of a)
      for (const u of n)
        o[u] = Math.max(o[u], n3e(l[u]));
    r.includes(Ki) && (o[Ki] = this.config.DEFAULT_ROW_NUMBER_COL_WIDTH), this.model.defaultColWidths = o;
  }
}
function n3e(t) {
  const e = String(t).length;
  return e > 200 ? 600 : e > 100 ? 300 : e > 20 ? 200 : e > 10 ? 150 : 120;
}
class i3e {
  tableController;
  #e = /* @__PURE__ */ Se(() => this.tableController.element);
  get tableElement() {
    return q(this.#e);
  }
  set tableElement(e) {
    be(this.#e, e);
  }
  constructor(e) {
    this.tableController = e;
  }
  mount(e, r, n, i, o) {
    if (!this.tableElement)
      return;
    const s = r.getBoundingClientRect(), a = this.tableElement.getBoundingClientRect(), l = a.top, u = a.left;
    switch (n) {
      case "inside":
        switch (o) {
          case "top":
            e.style.top = s.top - l + "px";
            break;
          case "middle":
          case "bottom":
            throw new Error("not yet implemented" + n + o);
        }
        switch (i) {
          case "left":
            e.style.left = s.left - u + "px";
          case "center":
          case "right":
            throw new Error("not yet implemented" + n + i);
        }
        break;
      case "outside":
        switch (o) {
          case "top":
            e.style.top = s.bottom - l + "px";
            break;
          case "middle":
          case "bottom":
            throw new Error("not yet implemented" + n + o);
        }
        switch (i) {
          case "left":
            e.style.left = s.left - u + "px";
            break;
          case "center":
          case "right":
            throw new Error("not yet implemented" + n + i);
        }
        break;
    }
    this.tableElement.appendChild(e);
  }
  destroy(e) {
    this.tableElement && this.tableElement.contains(e) && this.tableElement.removeChild(e);
  }
}
var zk, XO;
function o3e() {
  if (XO) return zk;
  XO = 1;
  function t(e, r, n) {
    return e === e && (n !== void 0 && (e = e <= n ? e : n), r !== void 0 && (e = e >= r ? e : r)), e;
  }
  return zk = t, zk;
}
var jk, QO;
function s3e() {
  if (QO) return jk;
  QO = 1;
  var t = /\s/;
  function e(r) {
    for (var n = r.length; n-- && t.test(r.charAt(n)); )
      ;
    return n;
  }
  return jk = e, jk;
}
var qk, JO;
function a3e() {
  if (JO) return qk;
  JO = 1;
  var t = s3e(), e = /^\s+/;
  function r(n) {
    return n && n.slice(0, t(n) + 1).replace(e, "");
  }
  return qk = r, qk;
}
var Uk, YO;
function F5() {
  if (YO) return Uk;
  YO = 1;
  function t(e) {
    var r = typeof e;
    return e != null && (r == "object" || r == "function");
  }
  return Uk = t, Uk;
}
var Hk, ZO;
function l3e() {
  if (ZO) return Hk;
  ZO = 1;
  var t = typeof zu == "object" && zu && zu.Object === Object && zu;
  return Hk = t, Hk;
}
var Vk, eF;
function ij() {
  if (eF) return Vk;
  eF = 1;
  var t = l3e(), e = typeof self == "object" && self && self.Object === Object && self, r = t || e || Function("return this")();
  return Vk = r, Vk;
}
var Wk, tF;
function oj() {
  if (tF) return Wk;
  tF = 1;
  var t = ij(), e = t.Symbol;
  return Wk = e, Wk;
}
var Gk, rF;
function u3e() {
  if (rF) return Gk;
  rF = 1;
  var t = oj(), e = Object.prototype, r = e.hasOwnProperty, n = e.toString, i = t ? t.toStringTag : void 0;
  function o(s) {
    var a = r.call(s, i), l = s[i];
    try {
      s[i] = void 0;
      var u = !0;
    } catch {
    }
    var c = n.call(s);
    return u && (a ? s[i] = l : delete s[i]), c;
  }
  return Gk = o, Gk;
}
var Kk, nF;
function c3e() {
  if (nF) return Kk;
  nF = 1;
  var t = Object.prototype, e = t.toString;
  function r(n) {
    return e.call(n);
  }
  return Kk = r, Kk;
}
var Xk, iF;
function h3e() {
  if (iF) return Xk;
  iF = 1;
  var t = oj(), e = u3e(), r = c3e(), n = "[object Null]", i = "[object Undefined]", o = t ? t.toStringTag : void 0;
  function s(a) {
    return a == null ? a === void 0 ? i : n : o && o in Object(a) ? e(a) : r(a);
  }
  return Xk = s, Xk;
}
var Qk, oF;
function f3e() {
  if (oF) return Qk;
  oF = 1;
  function t(e) {
    return e != null && typeof e == "object";
  }
  return Qk = t, Qk;
}
var Jk, sF;
function d3e() {
  if (sF) return Jk;
  sF = 1;
  var t = h3e(), e = f3e(), r = "[object Symbol]";
  function n(i) {
    return typeof i == "symbol" || e(i) && t(i) == r;
  }
  return Jk = n, Jk;
}
var Yk, aF;
function sj() {
  if (aF) return Yk;
  aF = 1;
  var t = a3e(), e = F5(), r = d3e(), n = NaN, i = /^[-+]0x[0-9a-f]+$/i, o = /^0b[01]+$/i, s = /^0o[0-7]+$/i, a = parseInt;
  function l(u) {
    if (typeof u == "number")
      return u;
    if (r(u))
      return n;
    if (e(u)) {
      var c = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(c) ? c + "" : c;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = t(u);
    var h = o.test(u);
    return h || s.test(u) ? a(u.slice(2), h ? 2 : 8) : i.test(u) ? n : +u;
  }
  return Yk = l, Yk;
}
var Zk, lF;
function p3e() {
  if (lF) return Zk;
  lF = 1;
  var t = o3e(), e = sj();
  function r(n, i, o) {
    return o === void 0 && (o = i, i = void 0), o !== void 0 && (o = e(o), o = o === o ? o : 0), i !== void 0 && (i = e(i), i = i === i ? i : 0), t(e(n), i, o);
  }
  return Zk = r, Zk;
}
var m3e = p3e();
const g3e = /* @__PURE__ */ O5(m3e);
var e3, uF;
function v3e() {
  if (uF) return e3;
  uF = 1;
  var t = ij(), e = function() {
    return t.Date.now();
  };
  return e3 = e, e3;
}
var t3, cF;
function y3e() {
  if (cF) return t3;
  cF = 1;
  var t = F5(), e = v3e(), r = sj(), n = "Expected a function", i = Math.max, o = Math.min;
  function s(a, l, u) {
    var c, h, d, p, g, v, y = 0, b = !1, k = !1, C = !0;
    if (typeof a != "function")
      throw new TypeError(n);
    l = r(l) || 0, t(u) && (b = !!u.leading, k = "maxWait" in u, d = k ? i(r(u.maxWait) || 0, l) : d, C = "trailing" in u ? !!u.trailing : C);
    function S(I) {
      var B = c, $ = h;
      return c = h = void 0, y = I, p = a.apply($, B), p;
    }
    function _(I) {
      return y = I, g = setTimeout(O, l), b ? S(I) : p;
    }
    function D(I) {
      var B = I - v, $ = I - y, j = l - B;
      return k ? o(j, d - $) : j;
    }
    function A(I) {
      var B = I - v, $ = I - y;
      return v === void 0 || B >= l || B < 0 || k && $ >= d;
    }
    function O() {
      var I = e();
      if (A(I))
        return M(I);
      g = setTimeout(O, D(I));
    }
    function M(I) {
      return g = void 0, C && c ? S(I) : (c = h = void 0, p);
    }
    function z() {
      g !== void 0 && clearTimeout(g), y = 0, c = v = h = g = void 0;
    }
    function N() {
      return g === void 0 ? p : M(e());
    }
    function P() {
      var I = e(), B = A(I);
      if (c = arguments, h = this, v = I, B) {
        if (g === void 0)
          return _(v);
        if (k)
          return clearTimeout(g), g = setTimeout(O, l), S(v);
      }
      return g === void 0 && (g = setTimeout(O, l)), p;
    }
    return P.cancel = z, P.flush = N, P;
  }
  return t3 = s, t3;
}
var r3, hF;
function b3e() {
  if (hF) return r3;
  hF = 1;
  var t = y3e(), e = F5(), r = "Expected a function";
  function n(i, o, s) {
    var a = !0, l = !0;
    if (typeof i != "function")
      throw new TypeError(r);
    return e(s) && (a = "leading" in s ? !!s.leading : a, l = "trailing" in s ? !!s.trailing : l), t(i, o, {
      leading: a,
      maxWait: o,
      trailing: l
    });
  }
  return r3 = n, r3;
}
var x3e = b3e();
const fF = /* @__PURE__ */ O5(x3e);
class w3e {
  tableModel;
  tableController;
  isDragging = !1;
  #e = /* @__PURE__ */ qe(0);
  get elementHeight() {
    return q(this.#e);
  }
  set elementHeight(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ qe(0);
  get labelHeight() {
    return q(this.#t);
  }
  set labelHeight(e) {
    be(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ Se(() => xr.config.verticalScrollbarPillHeight);
  get pillHeight() {
    return q(this.#r);
  }
  set pillHeight(e) {
    be(this.#r, e);
  }
  #n = /* @__PURE__ */ Se(() => this.elementHeight - this.pillHeight);
  get scrollbarHeight() {
    return q(this.#n);
  }
  set scrollbarHeight(e) {
    be(this.#n, e);
  }
  #l = /* @__PURE__ */ Se(() => this.tableController.firstVisibleRowOID ? this.tableController.firstVisibleRowOID : this.tableController.offset + 1);
  get displayRow() {
    return q(this.#l);
  }
  set displayRow(e) {
    be(this.#l, e);
  }
  #a = /* @__PURE__ */ Se(() => (this.displayRow - 1) / (this.tableModel.numRows - 1) * this.scrollbarHeight);
  get pillPosition() {
    return q(this.#a);
  }
  set pillPosition(e) {
    be(this.#a, e);
  }
  #i = /* @__PURE__ */ Se(() => {
    if (this.pillPosition === null)
      return 0;
    const e = this.pillPosition + this.pillHeight / 2 - this.labelHeight / 2;
    if (e < 0)
      return e;
    const r = this.pillPosition + this.pillHeight / 2 + this.labelHeight / 2;
    return r > this.elementHeight ? r - this.elementHeight : 0;
  });
  get labelOffset() {
    return q(this.#i);
  }
  set labelOffset(e) {
    be(this.#i, e);
  }
  constructor({ tableModel: e, tableController: r }) {
    this.tableModel = e, this.tableController = r;
  }
  computeOffsetFromPointer = (e) => {
    this.isDragging = !0;
    let r = Math.round(e.offsetY / this.scrollbarHeight * (this.tableModel.numRows - 1));
    return g3e(r, 0, this.tableModel.numRows - 1);
  };
  pointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0;
    const r = this.computeOffsetFromPointer(e);
    this.tableController.isJumping = !0, this.tableController.jumpToOffset(r);
  };
  handlePointerDown = fF(this.pointerDown, 50);
  pointerMove = (e) => {
    if (this.isDragging) {
      const r = this.computeOffsetFromPointer(e);
      this.tableController.jumpToOffset(r);
    }
  };
  handlePointerMove = fF(this.pointerMove, 50);
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.tableController.isJumping = !1;
  };
}
class k3e {
  #e = /* @__PURE__ */ qe(null);
  get columnInfo() {
    return q(this.#e);
  }
  set columnInfo(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ Se(() => this.columnInfo ? Object.keys(this.columnInfo).reduce(
    (e, r) => (e[r] = this.columnInfo[r].type, e),
    {}
  ) : {});
  get dataType() {
    return q(this.#t);
  }
  set dataType(e) {
    be(this.#t, e);
  }
  #r = /* @__PURE__ */ Se(() => this.columnInfo ? Object.keys(this.columnInfo).reduce(
    (e, r) => (e[r] = this.columnInfo[r].sqlType, e),
    {}
  ) : {});
  get sqlType() {
    return q(this.#r);
  }
  set sqlType(e) {
    be(this.#r, e);
  }
}
class C3e {
  tableController;
  #e = /* @__PURE__ */ Se(() => Math.floor(-this.tableController.yScroll / xr.config.scrollOverflowValue) * xr.config.scrollOverflowValue);
  get offset() {
    return q(this.#e);
  }
  set offset(e) {
    be(this.#e, e);
  }
  constructor(e) {
    this.tableController = e;
  }
  y(e) {
    return e - this.offset;
  }
  yScroll(e) {
    return e + this.offset;
  }
}
const dF = Symbol("schema"), pF = Symbol("model"), mF = Symbol("controller"), gF = Symbol("vertical-scrollbar-controller"), vF = Symbol("horizontal-scrollbar-controller"), yF = Symbol("table-portal-controller"), bF = Symbol("overscroll-modifier");
class Cr {
  static initialize() {
    const e = new k3e(), r = new Zke(e), n = new r3e(r, e), i = new w3e({ tableModel: r, tableController: n }), o = new Jke({ tableModel: r, tableController: n }), s = new i3e(n), a = new C3e(n);
    fs(dF, e), fs(pF, r), fs(mF, n), fs(gF, i), fs(vF, o), fs(yF, s), fs(bF, a);
  }
  static get schema() {
    return Qi(dF);
  }
  static get model() {
    return Qi(pF);
  }
  static get controller() {
    return Qi(mF);
  }
  static get verticalScrollbarController() {
    return Qi(gF);
  }
  static get horizontalScrollbarController() {
    return Qi(vF);
  }
  static get tablePortalController() {
    return Qi(yF);
  }
  static get overscrollModifier() {
    return Qi(bF);
  }
}
var _3e = /* @__PURE__ */ ur('<div class="horizontal-scrollbar svelte-csucem"><div class="pill svelte-csucem"></div></div>');
const S3e = {
  hash: "svelte-csucem",
  code: ".horizontal-scrollbar.svelte-csucem {position:absolute;bottom:0;left:0;width:100%;height:var(--height);transition:opacity 200ms linear;background-color:var(--scrollbar-bg);}.horizontal-scrollbar.svelte-csucem:hover {opacity:1 !important;}.pill.svelte-csucem {width:var(--width);height:calc(var(--height) - var(--margin) * 2);margin:var(--margin);border-radius:2px;background-color:var(--scrollbar-pill-bg);}"
};
function A3e(t, e) {
  on(e, !0), an(t, S3e);
  const r = Cr.horizontalScrollbarController, n = Cr.controller, i = xr.config;
  let o = /* @__PURE__ */ qe(0), s = /* @__PURE__ */ qe(null), a = /* @__PURE__ */ qe(null), l = 0;
  _p(() => (l = requestAnimationFrame(h), () => {
    cancelAnimationFrame(l);
  }));
  function u() {
    q(s) && (q(s).style.opacity = "0");
  }
  const c = nj.debounce(u, 1e3);
  Qr(() => {
    q(s) && (n.xScroll, q(s).style.opacity = "1", c());
  });
  function h() {
    be(o, r.pillWidth, !0), q(a) && (q(a).style.transform = `translate(${r.pillLeft}px, 0)`), l = requestAnimationFrame(h);
  }
  var d = _3e();
  let p;
  var g = yr(d);
  g.__pointerdown = function(...y) {
    r.handlePointerDown?.apply(this, y);
  }, g.__pointermove = function(...y) {
    r.handlePointerMove?.apply(this, y);
  }, g.__pointerup = function(...y) {
    r.handlePointerUp?.apply(this, y);
  };
  let v;
  zi(g, (y) => be(a, y), () => q(a)), dr(d), zi(d, (y) => be(s, y), () => q(s)), mn(() => {
    p = go(d, "", p, { "--height": i.horizontalScrollbarHeight + "px" }), v = go(g, "", v, {
      "--width": q(o) + "px",
      "--margin": r.margin + "px"
    });
  }), na(d, "clientWidth", (y) => r.elementWidth = y), Pt(t, d), sn();
}
mu(["pointerdown", "pointermove", "pointerup"]);
var E3e = /* @__PURE__ */ ur('<div class="vertical-scrollbar svelte-d1fz7o"><div class="pill svelte-d1fz7o"><div class="label svelte-d1fz7o"> </div></div></div>');
const D3e = {
  hash: "svelte-d1fz7o",
  code: ".vertical-scrollbar.svelte-d1fz7o {position:absolute;right:0;top:0;width:var(--width);height:calc(100% - var(--offset-bottom));contain:layout;cursor:row-resize;transition:opacity 200ms linear;user-select:none;background-color:var(--scrollbar-bg);}.vertical-scrollbar.svelte-d1fz7o:hover {opacity:1 !important;}.pill.svelte-d1fz7o {--pill-height: 4px;position:relative;pointer-events:none; /* let the container respond to pointer events */top:0;left:0;width:calc(var(--width) - 2px);margin-left:1px;margin-right:1px;height:var(--pill-height);border-radius:2px;will-change:transform;background-color:var(--scrollbar-pill-bg);}.label.svelte-d1fz7o {--offset: 0;position:absolute;pointer-events:none;top:0;left:-4px;font-family:var(--font-family);font-size:14px;white-space:nowrap;padding:2px 4px;box-shadow:var(--shadow);transform:translate(-100%, calc(-50% + var(--pill-height) / 2 - var(--offset)));border-radius:2px;color:var(--secondary-text-color);background-color:var(--scrollbar-label-bg);border:var(--outline);}"
};
function O3e(t, e) {
  on(e, !0), an(t, D3e);
  const r = Cr.verticalScrollbarController, n = Cr.controller, i = xr.config;
  let o = /* @__PURE__ */ qe(0), s = /* @__PURE__ */ qe(0), a = /* @__PURE__ */ qe(null), l = /* @__PURE__ */ qe(null), u = /* @__PURE__ */ qe(null), c = /* @__PURE__ */ Se(() => new Intl.NumberFormat().format(q(s))), h = 0;
  _p(() => (h = requestAnimationFrame(g), () => {
    cancelAnimationFrame(h);
  }));
  function d() {
    q(a) && (q(a).style.opacity = "0");
  }
  const p = nj.debounce(d, 1e3);
  Qr(() => {
    q(a) && (n.yScroll, q(a).style.opacity = "1", p());
  });
  function g() {
    be(o, r.pillPosition ?? q(o), !0), be(s, r.displayRow ?? q(s), !0), q(l) && (q(l).style.transform = `translate3d(0, ${q(o)}px, 0)`), q(u) && q(u).style.setProperty("--offset", r.labelOffset - 1 + "px"), h = requestAnimationFrame(g);
  }
  var v = E3e();
  v.__pointerdown = function(..._) {
    r.handlePointerDown?.apply(this, _);
  }, v.__pointermove = function(..._) {
    r.handlePointerMove?.apply(this, _);
  }, v.__pointerup = function(..._) {
    r.handlePointerUp?.apply(this, _);
  };
  let y;
  var b = yr(v);
  let k;
  var C = yr(b), S = yr(C, !0);
  dr(C), zi(C, (_) => be(u, _), () => q(u)), dr(b), zi(b, (_) => be(l, _), () => q(l)), dr(v), zi(v, (_) => be(a, _), () => q(a)), mn(() => {
    y = go(v, "", y, {
      "--offset-bottom": i.horizontalScrollbarHeight + "px",
      "--width": i.verticalScrollbarWidth + "px"
    }), k = go(b, "", k, {
      "--pill-height": r.pillHeight + "px"
    }), pl(S, q(c));
  }), na(C, "clientHeight", (_) => r.labelHeight = _), na(v, "clientHeight", (_) => r.elementHeight = _), Pt(t, v), sn();
}
mu(["pointerdown", "pointermove", "pointerup"]);
var F3e = /* @__PURE__ */ ur('<div class="bigint-content svelte-1x1osq0"> </div>');
const T3e = {
  hash: "svelte-1x1osq0",
  code: ".bigint-content.svelte-1x1osq0 {text-align:right;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function M3e(t, e) {
  on(e, !0), an(t, T3e);
  let r = Sp(e, "height");
  function n(s) {
    return s === null ? null : s.toLocaleString();
  }
  var i = F3e(), o = yr(i, !0);
  dr(i), mn((s) => pl(o, s), [() => n(e.bigint)]), na(i, "clientHeight", r), Pt(t, i), sn();
}
var P3e = /* @__PURE__ */ ur("<div></div>");
const R3e = { hash: "svelte-ubqfz9", code: "" };
function N3e(t, e) {
  on(e, !0), an(t, R3e);
  let r = Sp(e, "height");
  const n = Cr.model, i = (u) => typeof u == "function" ? (c, h) => {
    let d = new u(c, h);
    return {
      ...d.update ? { update: d.update.bind(d) } : {},
      ...d.destroy ? { destroy: d.destroy.bind(d) } : {}
    };
  } : (c, h) => {
    let d = new u.class(c, h);
    return {
      ...d.update ? { update: d.update.bind(d) } : {},
      ...d.destroy ? { destroy: d.destroy.bind(d) } : {}
    };
  };
  let o = /* @__PURE__ */ Se(() => i(e.customCell)), s = /* @__PURE__ */ Se(() => n.getContent({ row: e.row, col: e.col })), a = /* @__PURE__ */ Se(() => n.getRowData(e.row));
  var l = P3e();
  E5(l, (u, c) => q(o)?.(u, c), () => ({ value: q(s), rowData: q(a) })), D0(() => na(l, "clientHeight", r)), Pt(t, l), sn();
}
var $3e = /* @__PURE__ */ ur('<img alt=""/>');
function I3e(t, e) {
  on(e, !0);
  let r = Sp(e, "height");
  xr.config;
  let n = /* @__PURE__ */ qe(null);
  function i(c) {
    let h = "";
    for (let d = 0; d < c.length; d++)
      h += String.fromCharCode(c[d]);
    return btoa(h);
  }
  function o(c) {
    const h = atob(c);
    return new Uint8Array([...h].map((d) => d.charCodeAt(0)));
  }
  function s(c, h) {
    if (c.length < h.length)
      return !1;
    for (let d = 0; d < h.length; d++)
      if (c[d] != h[d])
        return !1;
    return !0;
  }
  function a(c) {
    return s(c, [137, 80, 78, 71, 13, 10, 26, 10]) ? "image/png" : s(c, [255, 216, 255]) ? "image/jpeg" : s(c, [73, 73, 42, 0]) ? "image/tiff" : s(c, [66, 77]) ? "image/bmp" : s(c, [71, 73, 70, 56, 55, 97]) || s(c, [71, 73, 70, 56, 55, 97]) ? "image/gif" : "application/octet-stream";
  }
  function l(c) {
    if (c == null)
      return null;
    if (typeof c == "string")
      return c.startsWith("data:") ? c : `data:${a(o(c))};base64,` + c;
    {
      let h = null;
      if (c.bytes && c.bytes instanceof Uint8Array && (h = c.bytes), c instanceof Uint8Array && (h = c), h != null)
        return `data:${a(h)};base64,` + i(h);
    }
    return null;
  }
  var u = $3e();
  zi(u, (c) => be(n, c), () => q(n)), mn((c) => Wg(u, "src", c), [() => l(e.image)]), Wd("load", u, () => {
    q(n) && r(q(n).scrollHeight);
  }), kke(u), Pt(t, u), sn();
}
var B3e = /* @__PURE__ */ ur('<a target="_blank"> </a>'), L3e = /* @__PURE__ */ ur('<div class="link-content"><!></div>');
const z3e = { hash: "svelte-1wimtwv", code: "" };
function j3e(t, e) {
  on(e, !0), an(t, z3e);
  let r = Sp(e, "height");
  var n = L3e(), i = yr(n);
  {
    var o = (s) => {
      var a = B3e(), l = yr(a, !0);
      dr(a), mn(() => {
        Wg(a, "href", e.url), pl(l, e.url);
      }), Pt(s, a);
    };
    Ji(i, (s) => {
      e.url && s(o);
    });
  }
  dr(n), na(n, "clientHeight", r), Pt(t, n), sn();
}
var q3e = /* @__PURE__ */ ur('<div class="number-content svelte-1xfvszy"> </div>');
const U3e = {
  hash: "svelte-1xfvszy",
  code: ".number-content.svelte-1xfvszy {text-align:right;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function H3e(t, e) {
  on(e, !0), an(t, U3e);
  let r = Sp(e, "height");
  function n(s) {
    return s === null ? null : Number.isInteger(s) ? s.toString() : s.toPrecision(4).toString();
  }
  var i = q3e(), o = yr(i, !0);
  dr(i), mn((s) => pl(o, s), [() => n(e.number)]), na(i, "clientHeight", r), Pt(t, i), sn();
}
var V3e = /* @__PURE__ */ ur("<div> </div>");
const W3e = {
  hash: "svelte-1ngffx0",
  code: ".clamped.svelte-1ngffx0 {display:-webkit-box;-webkit-box-orient:vertical;line-clamp:var(--lines, var(--num-lines)); /* fallback to numlines from parent */-webkit-line-clamp:var(--lines, var(--num-lines));overflow:hidden;text-overflow:ellipsis;}"
};
function xF(t, e) {
  on(e, !0), an(t, W3e);
  let r = Sp(e, "height");
  const n = xr.config;
  let i = /* @__PURE__ */ qe(null), o = /* @__PURE__ */ qe(null);
  Qr(() => {
    q(i) && (r(q(i).scrollHeight), be(o, Math.floor(e.parentHeight / n.lineHeight), !0));
  });
  var s = V3e();
  let a;
  var l = yr(s, !0);
  dr(s), zi(s, (u) => be(i, u), () => q(i)), mn(() => {
    dc(s, 1, `text-content ${(e.clamped ? "clamped" : null) ?? ""}`, "svelte-1ngffx0"), a = go(s, "", a, { "--lines": q(o) }), pl(l, e.text);
  }), Pt(t, s), sn();
}
class G3e {
  #e = /* @__PURE__ */ qe(ui({}));
  get config() {
    return q(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const n3 = Symbol("custom-cells");
class t1 {
  static initialize() {
    fs(n3, new G3e());
  }
  static set config(e) {
    const r = Qi(n3);
    r.config = e;
  }
  static get config() {
    return Qi(n3).config;
  }
}
var K3e = /* @__PURE__ */ ur("<button>â†˜</button>"), X3e = /* @__PURE__ */ ur('<div class="cell-content clamp svelte-8bpcsh"><!> <!></div>');
const Q3e = {
  hash: "svelte-8bpcsh",
  code: ".cell-content.svelte-8bpcsh {position:relative;flex-grow:1;line-height:var(--lineHeight);overflow-wrap:anywhere;overflow:hidden;}.expand-button.svelte-8bpcsh {all:unset;visibility:hidden;position:absolute;bottom:0;right:0;cursor:pointer;font-size:12px;line-height:18px;padding-left:4px;padding-right:4px;border-radius:2px;color:var(--secondary-text-color);background-color:var(--background-color);border:var(--outline);}.expand-button.show.svelte-8bpcsh {visibility:visible;}"
};
function J3e(t, e) {
  on(e, !0), an(t, Q3e);
  const r = Cr.model, n = Cr.controller, i = Cr.schema, o = xr.config;
  let s = /* @__PURE__ */ Se(() => t1.config), a = /* @__PURE__ */ qe(0), l = /* @__PURE__ */ qe(0), u = /* @__PURE__ */ Se(() => q(l) > q(a));
  const c = r.getContent({ row: e.row, col: e.col }), h = i.dataType[e.col] ?? "string", d = i.sqlType[e.col] ?? "TEXT";
  function p(D) {
    return typeof D == "string" && (D.startsWith("http://") || D.startsWith("https://"));
  }
  function g(D) {
    return D == null ? !1 : !!(typeof D == "string" && D.startsWith("data:image/") || D.bytes && D.bytes instanceof Uint8Array);
  }
  var v = X3e();
  let y;
  var b = yr(v);
  {
    var k = (D) => {
      N3e(D, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        },
        get customCell() {
          return q(s)[e.col];
        },
        get height() {
          return q(l);
        },
        set height(A) {
          be(l, A, !0);
        }
      });
    }, C = (D) => {
      var A = jc(), O = zo(A);
      {
        var M = (N) => {
          var P = jc(), I = zo(P);
          {
            var B = (j) => {
              j3e(j, {
                get url() {
                  return c;
                },
                get height() {
                  return q(l);
                },
                set height(U) {
                  be(l, U, !0);
                }
              });
            }, $ = (j) => {
              xF(j, {
                get text() {
                  return c;
                },
                get clamped() {
                  return q(u);
                },
                get parentHeight() {
                  return q(a);
                },
                get height() {
                  return q(l);
                },
                set height(U) {
                  be(l, U, !0);
                }
              });
            };
            Ji(I, (j) => {
              c && p(c) ? j(B) : j($, !1);
            });
          }
          Pt(N, P);
        }, z = (N) => {
          var P = jc(), I = zo(P);
          {
            var B = (j) => {
              var U = jc(), H = zo(U);
              {
                var G = (ne) => {
                  {
                    let se = /* @__PURE__ */ Se(() => BigInt(c ?? ""));
                    M3e(ne, {
                      get bigint() {
                        return q(se);
                      },
                      get height() {
                        return q(l);
                      },
                      set height(ie) {
                        be(l, ie, !0);
                      }
                    });
                  }
                }, re = (ne) => {
                  H3e(ne, {
                    get number() {
                      return c;
                    },
                    get height() {
                      return q(l);
                    },
                    set height(se) {
                      be(l, se, !0);
                    }
                  });
                };
                Ji(H, (ne) => {
                  d === "BIGINT" ? ne(G) : ne(re, !1);
                });
              }
              Pt(j, U);
            }, $ = (j) => {
              var U = jc(), H = zo(U);
              {
                var G = (ne) => {
                  I3e(ne, {
                    get image() {
                      return c;
                    },
                    get height() {
                      return q(l);
                    },
                    set height(se) {
                      be(l, se, !0);
                    }
                  });
                }, re = (ne) => {
                  xF(ne, {
                    get text() {
                      return c;
                    },
                    get clamped() {
                      return q(u);
                    },
                    get parentHeight() {
                      return q(a);
                    },
                    get height() {
                      return q(l);
                    },
                    set height(se) {
                      be(l, se, !0);
                    }
                  });
                };
                Ji(
                  H,
                  (ne) => {
                    g(c) ? ne(G) : ne(re, !1);
                  },
                  !0
                );
              }
              Pt(j, U);
            };
            Ji(
              I,
              (j) => {
                h === "number" ? j(B) : j($, !1);
              },
              !0
            );
          }
          Pt(N, P);
        };
        Ji(
          O,
          (N) => {
            h === "string" ? N(M) : N(z, !1);
          },
          !0
        );
      }
      Pt(D, A);
    };
    Ji(b, (D) => {
      q(s)[e.col] ? D(k) : D(C, !1);
    });
  }
  var S = vs(b, 2);
  {
    var _ = (D) => {
      var A = K3e();
      A.__click = () => {
        n.addHeightToRow(e.row, q(l) - q(a));
      }, mn(() => dc(A, 1, `expand-button ${e.hovered ? "show" : "hide"}`, "svelte-8bpcsh")), Pt(D, A);
    };
    Ji(S, (D) => {
      q(u) && D(_);
    });
  }
  dr(v), mn(() => y = go(v, "", y, {
    "--lineHeight": o.lineHeight + "px",
    "--num-lines": o.textMaxLines
  })), na(v, "clientHeight", (D) => be(a, D)), Pt(t, v), sn();
}
mu(["click"]);
var Y3e = /* @__PURE__ */ ur('<div class="row-number svelte-1e2x749"> </div>');
const Z3e = {
  hash: "svelte-1e2x749",
  code: ".row-number.svelte-1e2x749 {flex-grow:1;text-align:right;color:var(--secondary-text-color);text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function eCe(t, e) {
  on(e, !0), an(t, Z3e);
  const r = Cr.model.getContent({ row: e.row, col: e.col }), n = /* @__PURE__ */ Se(() => new Intl.NumberFormat().format(r ?? 0));
  var i = Y3e(), o = yr(i, !0);
  dr(i), mn(() => pl(o, q(n))), Pt(t, i), sn();
}
var tCe = /* @__PURE__ */ ur('<div class="cell svelte-16dgxhm"><!></div>');
const rCe = {
  hash: "svelte-16dgxhm",
  code: ".cell.svelte-16dgxhm {--x: 0px;--y: 0px;--width: 0px;--height: 0px;display:flex;box-sizing:border-box;padding-top:calc(var(--padding-y) / 2);padding-bottom:calc(var(--padding-y) / 2);padding-right:calc(calc(var(--padding-x) / 2) + var(--extra-right-padding));padding-left:calc(calc(var(--padding-x) / 2) + var(--extra-left-padding));position:absolute;left:0;top:0;width:var(--width);height:var(--height);transform:translate(var(--x), var(--y));contain:layout paint;color:var(--primary-text-color);font-family:var(--cell-font-family);font-size:var(--cell-font-size);}"
};
function nCe(t, e) {
  on(e, !0), an(t, rCe);
  const r = Cr.model, n = Cr.controller, i = Cr.overscrollModifier, o = xr.config;
  let s = /* @__PURE__ */ Se(() => r.getPosition({ row: e.row, col: e.col })), a = /* @__PURE__ */ Se(() => q(s).x), l = /* @__PURE__ */ Se(() => q(s).y), u = /* @__PURE__ */ Se(() => i.y(q(l))), c = /* @__PURE__ */ Se(() => r.getDimensions({ row: e.row, col: e.col })), h = /* @__PURE__ */ Se(() => q(c).width), d = /* @__PURE__ */ Se(() => q(c).height), p = /* @__PURE__ */ Se(() => r.isFirstCol(e.col)), g = /* @__PURE__ */ Se(() => r.isLastCol(e.col)), v = /* @__PURE__ */ Se(() => r.getRowParity(e.row) === "even" ? "var(--primary-bg)" : "var(--secondary-bg)"), y = () => {
    o.onRowClick && o.onRowClick(e.row);
  }, b = /* @__PURE__ */ qe(!1);
  var k = tCe();
  k.__click = y, k.__keydown = (A) => {
    A.key === "Enter" && y();
  };
  let C;
  var S = yr(k);
  {
    var _ = (A) => {
      J3e(A, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        },
        get hovered() {
          return q(b);
        }
      });
    }, D = (A) => {
      eCe(A, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        }
      });
    };
    Ji(S, (A) => {
      e.col !== Gi ? A(_) : A(D, !1);
    });
  }
  dr(k), mn(() => C = go(k, "", C, {
    "--x": q(a) + "px",
    "--y": q(u) + "px",
    "--width": q(h) + "px",
    "--height": q(d) + "px",
    "--padding-x": o.betweenColPadding + "px",
    "--padding-y": o.betweenRowPadding + "px",
    "--extra-right-padding": (q(g) ? o.verticalScrollbarWidth : 0) + "px",
    "--extra-left-padding": (q(p) ? o.firstColLeftPadding : 0) + "px",
    "--background-color": q(v)
  })), Wd("pointerenter", k, () => {
    be(b, !0), n.hoveredRowId = e.row;
  }), Wd("pointerleave", k, () => {
    be(b, !1), n.hoveredRowId = null;
  }), Pt(t, k), sn();
}
mu(["click", "keydown"]);
var iCe = /* @__PURE__ */ ur('<div class="header-title svelte-1si5830"> </div>');
const oCe = {
  hash: "svelte-1si5830",
  code: ".header-title.svelte-1si5830 {flex-shrink:1;margin-right:2px;}"
};
function sCe(t, e) {
  on(e, !0), an(t, oCe);
  const r = xr.config;
  var n = iCe(), i = yr(n, !0);
  dr(n), mn(() => pl(i, r.columnConfigs[e.col]?.title ?? e.col)), Pt(t, n), sn();
}
U2e();
var aCe = /* @__PURE__ */ ur('<div class="row-number-header svelte-v1uha2">#</div>');
const lCe = {
  hash: "svelte-v1uha2",
  code: ".row-number-header.svelte-v1uha2 {flex-grow:1;text-align:right;margin-right:4px;box-sizing:border-box;color:var(--secondary-text-color);}"
};
function uCe(t) {
  an(t, lCe);
  var e = aCe();
  Pt(t, e);
}
var cCe = /* @__PURE__ */ ur('<button class="sort-buttons svelte-mgubjs"><div> </div></button>');
const hCe = {
  hash: "svelte-mgubjs",
  code: ".sort-buttons.svelte-mgubjs {all:unset;flex-shrink:0;width:16px;cursor:pointer;display:flex;justify-content:center;flex-direction:row;margin-left:4px;border-radius:2px;padding-left:4px;padding-right:4px;color:var(--tertiary-text-color);}.sort-buttons.svelte-mgubjs:hover {--placeholder: 0;background-color:var(--hover-bg);}.sort-glyph.svelte-mgubjs {color:var(--tertiary-text-color);}.sort-buttons.svelte-mgubjs:hover .sort-glyph:where(.svelte-mgubjs) {color:var(--tertiary-text-color);}.selected.svelte-mgubjs {color:var(--primary-text-color) !important;}"
};
function fCe(t, e) {
  on(e, !0), an(t, hCe);
  const r = Cr.controller;
  let n = /* @__PURE__ */ Se(() => r.sort ? r.sort.column === e.col : !1), i = /* @__PURE__ */ Se(() => r.sort ? r.sort.direction : null), o = /* @__PURE__ */ Se(() => q(n) ? q(i) === "ascending" ? "â†‘" : "â†“" : "â‡…");
  var s = cCe();
  s.__click = () => {
    const u = q(n) ? q(i) === "ascending" ? "descending" : null : "ascending";
    u ? r.handleSort({ column: e.col, direction: u }) : r.handleSort(null);
  };
  var a = yr(s), l = yr(a, !0);
  dr(a), dr(s), mn(() => {
    dc(a, 1, `sort-button ${(q(n) ? "selected" : null) ?? ""} sort-glyph`, "svelte-mgubjs"), pl(l, q(o));
  }), Pt(t, s), sn();
}
mu(["click"]);
class dCe {
  #e = /* @__PURE__ */ qe(ui({}));
  get config() {
    return q(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const i3 = Symbol("custom-headers");
class r1 {
  static initialize() {
    fs(i3, new dCe());
  }
  static set config(e) {
    const r = Qi(i3);
    r.config = e;
  }
  static get config() {
    return Qi(i3).config;
  }
}
var pCe = /* @__PURE__ */ ur("<div></div>");
const mCe = { hash: "svelte-v680az", code: "" };
function gCe(t, e) {
  on(e, !0), an(t, mCe), Cr.model;
  const r = (o) => typeof o == "function" ? (s, a) => {
    let l = new o(s, a);
    return {
      ...l.update ? { update: l.update.bind(l) } : {},
      ...l.destroy ? { destroy: l.destroy.bind(l) } : {}
    };
  } : (s, a) => {
    let l = new o.class(s, a);
    return {
      ...l.update ? { update: l.update.bind(l) } : {},
      ...l.destroy ? { destroy: l.destroy.bind(l) } : {}
    };
  };
  let n = /* @__PURE__ */ Se(() => r(e.customHeader));
  var i = pCe();
  E5(i, (o, s) => q(n)?.(o, s), () => ({ column: e.col })), Pt(t, i), sn();
}
var vCe = /* @__PURE__ */ ur("<!> <!>", 1), yCe = /* @__PURE__ */ ur('<div><div class="header-content svelte-1vl6s3u"><!> <div class="header-title svelte-1vl6s3u"><!></div></div></div>');
const bCe = {
  hash: "svelte-1vl6s3u",
  code: ".header-cell.svelte-1vl6s3u {position:relative;display:flex;flex-direction:row;align-items:end;width:var(--width);min-height:var(--height);flex-shrink:0;box-sizing:border-box;padding:0.25em;padding-right:calc(calc(var(--padding-x) / 2) + var(--extra-padding-right));padding-left:calc(calc(var(--padding-x) / 2) + var(--extra-padding-left));color:var(--secondary-text-color);font-family:var(--header-font-family);font-size:var(--header-font-size);}.header-cell.number.svelte-1vl6s3u {justify-content:end;}.header-content.svelte-1vl6s3u {display:flex;flex-direction:column;flex-shrink:0;}.header-title.svelte-1vl6s3u {height:1.5em;align-items:center;display:flex;flex-direction:row;flex-shrink:0;}"
};
function xCe(t, e) {
  on(e, !0), an(t, bCe);
  const r = Cr.model, n = Cr.schema, i = xr.config;
  let o = /* @__PURE__ */ Se(() => r1.config), s = /* @__PURE__ */ qe(null), a = /* @__PURE__ */ qe(0);
  Qr(() => {
    i.minColumnWidths[e.col] = q(a) + i.betweenColPadding;
  });
  const l = /* @__PURE__ */ Se(() => r.colWidths[e.col]), u = /* @__PURE__ */ Se(() => (n.dataType[e.col] ?? "string") === "number"), c = /* @__PURE__ */ Se(() => q(u) || e.col === Gi ? "number" : ""), h = /* @__PURE__ */ Se(() => r.isFirstCol(e.col)), d = /* @__PURE__ */ Se(() => r.isLastCol(e.col));
  let p = /* @__PURE__ */ Se(() => i.headerHeight ? i.headerHeight + "px" : "auto");
  var g = yCe();
  let v;
  var y = yr(g), b = yr(y);
  {
    var k = (A) => {
      gCe(A, {
        get col() {
          return e.col;
        },
        get customHeader() {
          return q(o)[e.col];
        }
      });
    };
    Ji(b, (A) => {
      q(o)[e.col] && A(k);
    });
  }
  var C = vs(b, 2), S = yr(C);
  {
    var _ = (A) => {
      var O = vCe(), M = zo(O);
      sCe(M, {
        get col() {
          return e.col;
        }
      });
      var z = vs(M, 2);
      fCe(z, {
        get col() {
          return e.col;
        }
      }), Pt(A, O);
    }, D = (A) => {
      uCe(A);
    };
    Ji(S, (A) => {
      e.col !== Gi ? A(_) : A(D, !1);
    });
  }
  dr(C), dr(y), dr(g), zi(g, (A) => be(s, A), () => q(s)), mn(() => {
    dc(g, 1, `header-cell ${q(c) ?? ""}`, "svelte-1vl6s3u"), v = go(g, "", v, {
      "--width": q(l) + "px",
      "--height": q(p),
      "--padding-x": i.betweenColPadding + "px",
      "--extra-padding-right": (q(d) ? i.verticalScrollbarWidth : 0) + "px",
      "--extra-padding-left": (q(h) ? i.firstColLeftPadding : 0) + "px"
    });
  }), na(y, "clientWidth", (A) => be(a, A)), Pt(t, g), sn();
}
class wCe {
  tableModel;
  tableController;
  col;
  config;
  isDragging = !1;
  startDragX = 0;
  constructor({ tableModel: e, tableController: r, col: n }) {
    this.tableModel = e, this.tableController = r, this.col = n, this.config = xr.config;
  }
  handlePointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0, this.startDragX = e.offsetX;
  };
  handlePointerMove = (e) => {
    if (this.isDragging && this.startDragX !== null) {
      const r = e.offsetX - this.startDragX, n = this.tableModel.colWidths[this.col], i = Math.max(0, Math.round(n + r));
      this.config.columnConfigs[this.col] || (this.config.columnConfigs[this.col] = {}), this.config.columnConfigs[this.col].width = i, this.config.onColumnConfigsChange(this.col, bz(this.config.columnConfigs));
    }
  };
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.startDragX = null;
  };
}
var kCe = /* @__PURE__ */ ur('<div class="header-resize-indicator svelte-1y4d3p9"><div class="pill svelte-1y4d3p9"></div></div>');
const CCe = {
  hash: "svelte-1y4d3p9",
  code: ".header-resize-indicator.svelte-1y4d3p9 {position:absolute;z-index:2;box-sizing:border-box;width:12px;height:calc(100% - 0.25rem);margin:2px;cursor:col-resize;justify-content:center;display:flex;align-items:center;justify-content:center;transform:translateX(calc(var(--x) - 4px - 50%));}.pill.svelte-1y4d3p9 {width:2px;height:calc(100% - 4px);margin-top:2px;margin-bottom:2px;background-color:var(--secondary-text-color);opacity:0.2;border-radius:2px;}"
};
function _Ce(t, e) {
  on(e, !0), an(t, CCe);
  const r = Cr.model;
  let n = new wCe({
    tableModel: r,
    tableController: Cr.controller,
    col: e.col
  });
  const i = /* @__PURE__ */ Se(() => r.colPositions[e.col] + r.colWidths[e.col]);
  var o = kCe();
  o.__pointerdown = function(...a) {
    n.handlePointerDown?.apply(this, a);
  }, o.__pointermove = function(...a) {
    n.handlePointerMove?.apply(this, a);
  }, o.__pointerup = function(...a) {
    n.handlePointerUp?.apply(this, a);
  };
  let s;
  mn(() => s = go(o, "", s, { "--x": q(i) + "px" })), Pt(t, o), sn();
}
mu(["pointerdown", "pointermove", "pointerup"]);
var SCe = /* @__PURE__ */ ur('<div class="table-portal svelte-i8g41o" tabindex="-1"><!></div>');
const ACe = {
  hash: "svelte-i8g41o",
  code: ".table-portal.svelte-i8g41o {position:absolute;}"
};
function ECe(t, e) {
  on(e, !0), an(t, ACe);
  const r = Cr.controller, n = Cr.tablePortalController;
  let i = /* @__PURE__ */ qe(null);
  const o = (c) => {
    Qr(() => (n.mount(c, e.relativeTo, e.anchor, e.horizontalAlign, e.verticalAlign), c.focus(), () => {
      n.destroy(c);
    }));
  };
  let s = 0;
  _p(() => {
    s = r.xScroll, requestAnimationFrame(a);
  });
  function a() {
    q(i) && e.stickyX && (q(i).style.transform = `translateX(${r.xScroll - s}px)`), requestAnimationFrame(a);
  }
  var l = SCe();
  l.__click = (c) => {
    c.stopPropagation();
  };
  var u = yr(l);
  A5(u, () => e.children), dr(l), zi(l, (c) => be(i, c), () => q(i)), E5(l, (c) => o?.(c)), Wd("wheel", l, (c) => {
    c.stopPropagation();
  }), Pt(t, l), sn();
}
mu(["click"]);
var DCe = /* @__PURE__ */ ur("<button> </button> <!>", 1);
const OCe = {
  hash: "svelte-3t0u29",
  code: '.dropdown.svelte-3t0u29 {all:unset;padding-left:8px;padding-right:8px;border-radius:2px;cursor:pointer;color:var(--secondary-text-color);position:relative;user-select:none;}.dropdown.svelte-3t0u29::before {content:"";position:absolute;top:0;left:0;height:100%;width:100%;background-color:var(--primary-bg);z-index:-1;}.dropdown.svelte-3t0u29:hover {background-color:var(--hover-bg);}.unclickable.svelte-3t0u29 {pointer-events:none;}'
};
function FCe(t, e) {
  an(t, OCe);
  let r = /* @__PURE__ */ qe(!1), n = /* @__PURE__ */ qe(null), i = /* @__PURE__ */ qe(null);
  var o = DCe();
  Wd("click", b_, (c) => {
    q(r) && c.target !== q(n) && be(r, !1);
  });
  var s = zo(o);
  s.__click = (c) => {
    be(r, !0);
  };
  var a = yr(s, !0);
  dr(s), zi(s, (c) => be(n, c), () => q(n));
  var l = vs(s, 2);
  {
    var u = (c) => {
      ECe(c, {
        get relativeTo() {
          return e.relativeTo;
        },
        anchor: "outside",
        horizontalAlign: "left",
        verticalAlign: "top",
        stickyX: !1,
        get element() {
          return q(i);
        },
        set element(h) {
          be(i, h, !0);
        },
        children: (h, d) => {
          var p = jc(), g = zo(p);
          A5(g, () => e.children), Pt(h, p);
        },
        $$slots: { default: !0 }
      });
    };
    Ji(l, (c) => {
      q(r) && c(u);
    });
  }
  mn(() => {
    dc(s, 1, `dropdown ${q(r) ? "unclickable" : "clickable"}`, "svelte-3t0u29"), pl(a, e.label);
  }), Pt(t, o);
}
mu(["click"]);
var TCe = /* @__PURE__ */ ur('<li class="column-entry svelte-bmvlb6"><label class="column-label svelte-bmvlb6"> <input type="checkbox"/></label></li>'), MCe = /* @__PURE__ */ ur('<ul class="column-toggle svelte-bmvlb6"></ul>'), PCe = /* @__PURE__ */ ur("<!> <!>", 1), RCe = /* @__PURE__ */ ur('<div class="header-row svelte-bmvlb6"><div class="scroll-container svelte-bmvlb6"><div class="dropdown-label-container svelte-bmvlb6"><div class="dropdown-label svelte-bmvlb6"><!></div></div> <!></div></div>');
const NCe = {
  hash: "svelte-bmvlb6",
  code: ".header-row.svelte-bmvlb6 {flex-shrink:0;border-bottom:1px solid var(--secondary-bg);background-color:var(--primary-bg);}.scroll-container.svelte-bmvlb6 {display:flex;flex-direction:row;}.dropdown-label-container.svelte-bmvlb6 {position:absolute;z-index:20;left:0px;box-sizing:border-box;height:100%;padding:0.25em;display:flex;flex-direction:row;align-items:end;}.dropdown-label.svelte-bmvlb6 {height:1.5em;align-items:center;display:flex;}.column-toggle.svelte-bmvlb6 {margin:0;margin-top:4px;margin-left:8px;padding:12px;background-color:var(--primary-bg);border-radius:4px;box-shadow:var(--shadow);border:var(--outline);max-height:var(--max-height);max-width:var(--max-width);overflow:scroll;}.column-entry.svelte-bmvlb6 {list-style-type:none;padding:4px;user-select:none;}.column-label.svelte-bmvlb6 {display:flex;align-items:center;justify-content:space-between;gap:16px;color:var(--secondary-text-color);}"
};
function $Ce(t, e) {
  on(e, !0), an(t, NCe);
  const r = Cr.model, n = Cr.controller, i = xr.config;
  let o = /* @__PURE__ */ qe(null), s = /* @__PURE__ */ qe(null), a = /* @__PURE__ */ qe(null), l = /* @__PURE__ */ Se(() => r.renderableCols), u = 0;
  _p(() => (u = requestAnimationFrame(c), () => {
    cancelAnimationFrame(u);
  }));
  function c() {
    q(s) && (q(s).style.transform = `translate3d(${n.xScroll}px, 0, 0)`), q(a) && (q(a).style.transform = `translate3d(${-n.xScroll}px, 0, 0)`), u = requestAnimationFrame(c);
  }
  var h = RCe(), d = yr(h), p = yr(d), g = yr(p), v = yr(g);
  FCe(v, {
    label: "â‹®",
    get relativeTo() {
      return q(o);
    },
    children: (b, k) => {
      var C = MCe();
      let S;
      Vm(C, 21, () => r.columns, Rke, (_, D) => {
        var A = TCe(), O = yr(A), M = yr(O), z = vs(M);
        qke(z), z.__change = (N) => {
          N.target.checked ? n.showColumn(q(D)) : n.hideColumn(q(D));
        }, go(z, "", {}, { float: "right" }), dr(O), dr(A), mn(() => {
          pl(M, `${(q(D) === Gi ? "row #" : i.columnConfigs[q(D)]?.title ?? q(D)) ?? ""} `), Wg(z, "id", `${q(D) ?? ""}-checkbox`), Uke(z, q(D) === Gi ? i.showRowNumber !== !1 : !i.columnConfigs[q(D)]?.hidden);
        }), Pt(_, A);
      }), dr(C), mn(() => S = go(C, "", S, {
        "--max-height": n.viewHeight - 48 + "px",
        "--max-width": n.viewWidth - 48 + "px"
      })), Pt(b, C);
    }
  }), dr(g), zi(g, (b) => be(a, b), () => q(a)), dr(p);
  var y = vs(p, 2);
  Vm(y, 16, () => q(l), (b) => b, (b, k) => {
    var C = PCe(), S = zo(C);
    xCe(S, {
      get col() {
        return k;
      }
    });
    var _ = vs(S, 2);
    _Ce(_, {
      get col() {
        return k;
      }
    }), Pt(b, C);
  }), dr(d), zi(d, (b) => be(s, b), () => q(s)), dr(h), zi(h, (b) => be(o, b), () => q(o)), Pt(t, h), sn();
}
mu(["change"]);
class ICe {
  #e = /* @__PURE__ */ qe(null);
  get colorScheme() {
    return q(this.#e);
  }
  set colorScheme(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ qe(ui({}));
  get theme() {
    return q(this.#t);
  }
  set theme(e) {
    be(this.#t, e, !0);
  }
}
const wF = Symbol("style");
class D_ {
  static initialize() {
    fs(wF, new ICe());
  }
  static get style() {
    return Qi(wF);
  }
}
function BCe(t, e) {
  return { ...t, ...t[e] != null ? t[e] : {} };
}
var LCe = /* @__PURE__ */ ur("<div><!></div>");
const zCe = {
  hash: "svelte-c7n1rn",
  code: ".table-defaults.light.svelte-c7n1rn {--default-primary-text-color: black;--default-secondary-text-color: gray;--default-tertiary-text-color: lightgray;--default-font-family: sans-serif;--default-font-size: 1rem;--default-primary-bg: white;--default-secondary-bg: rgb(246, 246, 247);--default-tertiary-bg: rgb(234, 234, 235);--default-hover-bg: rgba(0, 0, 0, 0.05);--default-scrollbar-bg: rgba(0, 0, 0, 0.05);--default-scrollbar-pill-bg: rgba(0, 0, 0, 0.5);--default-scrollbar-label-bg: rgba(255, 255, 255, 0.9);--default-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--default-outline-color: rgb(0 0 0 / 0.2);--default-dimmed-row-color: rgb(0 0 0 / 0.2);--default-row-scroll-to-color: rgb(202 225 255);--default-row-hover-color: rgb(220, 235, 255);}.table-defaults.dark.svelte-c7n1rn {--default-primary-text-color: lightgray;--default-secondary-text-color: gray;--default-tertiary-text-color: dimgray;--default-font-family: sans-serif;--default-font-size: 1rem;--default-primary-bg: #060607;--default-secondary-bg: #161617;--default-hover-bg: rgba(255, 255, 255, 0.05);--default-scrollbar-bg: rgba(255, 255, 255, 0.05);--default-scrollbar-pill-bg: rgba(255, 255, 255, 0.5);--default-scrollbar-label-bg: rgba(0, 0, 0, 0.9);--default-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--default-outline-color: rgb(255 255 255 / 0.2);--default-dimmed-row-color: rgb(0 0 0 / 0.6);--default-row-scroll-to-color: rgb(1, 24, 106);--default-row-hover-color: rgb(0, 6, 35);}.style-wrapper.svelte-c7n1rn {width:100%;height:100%;--primary-text-color: var(--user-primary-text-color, var(--default-primary-text-color));--secondary-text-color: var(--user-secondary-text-color, var(--default-secondary-text-color));--tertiary-text-color: var(--user-tertiary-text-color, var(--default-tertiary-text-color));--font-family: var(--user-font-family, var(--default-font-family));--font-size: var(--user-font-size, var(--default-font-size));--primary-bg: var(--user-primary-bg, var(--default-primary-bg));--secondary-bg: var(--user-secondary-bg, var(--default-secondary-bg));--tertiary-bg: var(--user-tertiarty-bg, var(--default-tertiary-bg));--hover-bg: var(--user-hover-bg, var(--default-hover-bg));--header-font-family: var(--user-header-font-family, var(--font-family));--header-font-size: var(--user-header-font-size, var(--font-size));--cell-font-family: var(--user-cell-font-family, var(--font-family));--cell-font-size: var(--user-cell-font-size, var(--font-size));--scrollbar-bg: var(--user-scrollbar-bg, var(--default-scrollbar-bg));--scrollbar-pill-bg: var(--user-scrollbar-pill-bg, var(--default-scrollbar-pill-bg));--scrollbar-label-bg: var(--user-scrollbar-label-bg, var(--default-scrollbar-label-bg));--shadow: var(--user-shadow, var(--default-shadow));--outline-color: var(--user-outline-color, var(--default-outline-color));--outline: 0.5px solid var(--outline-color);--dimmed-row-color: var(--user-dimmed-row-color, var(--default-dimmed-row-color));--row-scroll-to-color: var(--user-row-scroll-to-color, var(--default-row-scroll-to-color));--row-hover-color: var(--user-row-hover-color, var(--default-row-hover-color));}"
};
function jCe(t, e) {
  on(e, !0), an(t, zCe);
  const r = D_.style;
  let n = /* @__PURE__ */ Se(() => r.colorScheme), i = /* @__PURE__ */ Se(() => r.theme), o = /* @__PURE__ */ qe(null), s = /* @__PURE__ */ Se(() => q(n) ?? q(o) ?? "light");
  const a = (U) => {
    U.matches ? be(o, "dark") : be(o, "light");
  }, l = "(prefers-color-scheme: dark";
  _p(() => (be(o, window.matchMedia(l).matches ? "dark" : "light", !0), window.matchMedia(l).addEventListener("change", a), () => {
    window.matchMedia(l).removeEventListener("change", a);
  }));
  let u = /* @__PURE__ */ Se(() => BCe(q(i), q(s))), c = /* @__PURE__ */ Se(() => q(u).primaryTextColor), h = /* @__PURE__ */ Se(() => q(u).secondaryTextColor), d = /* @__PURE__ */ Se(() => q(u).tertiaryTextColor), p = /* @__PURE__ */ Se(() => q(u).fontFamily), g = /* @__PURE__ */ Se(() => q(u).fontSize), v = /* @__PURE__ */ Se(() => q(u).primaryBackgroundColor), y = /* @__PURE__ */ Se(() => q(u).secondaryBackgroundColor), b = /* @__PURE__ */ Se(() => q(u).hoverBackgroundColor), k = /* @__PURE__ */ Se(() => q(u).headerFontFamily), C = /* @__PURE__ */ Se(() => q(u).headerFontSize), S = /* @__PURE__ */ Se(() => q(u).cellFontFamily), _ = /* @__PURE__ */ Se(() => q(u).cellFontSize), D = /* @__PURE__ */ Se(() => q(u).scrollbarBackgroundColor), A = /* @__PURE__ */ Se(() => q(u).scrollbarPillColor), O = /* @__PURE__ */ Se(() => q(u).scrollbarLabelBackgroundColor), M = /* @__PURE__ */ Se(() => q(u).shadow), z = /* @__PURE__ */ Se(() => q(u).outlineColor), N = /* @__PURE__ */ Se(() => q(u).dimmedRowColor), P = /* @__PURE__ */ Se(() => q(u).rowScrollToColor), I = /* @__PURE__ */ Se(() => q(u).rowHoverColor);
  Qr(() => {
  });
  var B = LCe();
  let $;
  var j = yr(B);
  A5(j, () => e.children), dr(B), mn(() => {
    dc(B, 1, `style-wrapper table-defaults ${q(s) ?? ""}`, "svelte-c7n1rn"), $ = go(B, "", $, {
      "--user-primary-text-color": q(c),
      "--user-secondary-text-color": q(h),
      "--user-tertiary-text-color": q(d),
      "--user-font-family": q(p),
      "--user-font-size": q(g),
      "--user-primary-bg": q(v),
      "--user-secondary-bg": q(y),
      "--user-hover-bg": q(b),
      "--user-header-font-family": q(k),
      "--user-header-font-size": q(C),
      "--user-cell-font-family": q(S),
      "--user-cell-font-size": q(_),
      "--user-scrollbar-bg": q(D),
      "--user-scrollbar-pill-bg": q(A),
      "--user-scrollbar-label-bg": q(O),
      "--user-shadow": q(M),
      "--user-outline-color": q(z),
      "--user-dimmed-row-color": q(N),
      "--user-row-scroll-to-color": q(P),
      "--user-row-hover-color": q(I)
    });
  }), Pt(t, B), sn();
}
function qCe() {
  return Gi;
}
function UCe(t, e) {
  const r = new Set(t), n = new Set(e);
  return {
    left: t.filter((i) => !n.has(i)),
    right: e.filter((i) => !r.has(i))
  };
}
function HCe(t, e) {
  const r = new Set(e);
  return t.filter((n) => !r.has(n));
}
function VCe(t, e) {
  return t.concat(e);
}
var WCe = /* @__PURE__ */ ur("<div></div>"), GCe = /* @__PURE__ */ ur("<div></div> <!>", 1);
const KCe = {
  hash: "svelte-14dgpd0",
  code: ".row-background.svelte-14dgpd0 {position:absolute;width:var(--width);height:var(--height);box-sizing:border-box;z-index:-1;transform:translate3d(0, var(--y), 0);transition:background-color 100ms linear;}.odd.svelte-14dgpd0 {background-color:var(--secondary-bg);}.even.svelte-14dgpd0 {background-color:var(--primary-bg);}.dimmer.svelte-14dgpd0 {background-color:var(--dimmed-row-color);z-index:10;pointer-events:none;}.flashed.svelte-14dgpd0 {background-color:var(--row-scroll-to-color);}.hovered.svelte-14dgpd0 {background-color:var(--row-hover-color);}"
};
function XCe(t, e) {
  on(e, !0), an(t, KCe);
  const r = Cr.controller, n = Cr.model, i = Cr.overscrollModifier, o = xr.config;
  let s = /* @__PURE__ */ Se(() => n.rowHeights[e.row]), a = /* @__PURE__ */ Se(() => Math.max(n.colsRightmostPosition, r.viewWidth)), l = /* @__PURE__ */ Se(() => i.y(n.rowPositions[e.row])), u = /* @__PURE__ */ Se(() => n.getRowParity(e.row)), c = /* @__PURE__ */ Se(() => r.flashedRowId === e.row), h = /* @__PURE__ */ Se(() => r.hoveredRowId === e.row), d = /* @__PURE__ */ Se(() => o.highlightedRows ? o.highlightedRows?.has(e.row) : null);
  var p = GCe(), g = zo(p);
  let v;
  var y = vs(g, 2);
  {
    var b = (k) => {
      var C = WCe();
      let S;
      mn(() => {
        dc(C, 1, `row-background ${q(u) ?? ""} dimmer`, "svelte-14dgpd0"), S = go(C, "", S, {
          "--width": q(a) + "px",
          "--height": q(s) + "px",
          "--y": q(l) + "px"
        });
      }), Pt(k, C);
    };
    Ji(y, (k) => {
      q(d) !== null && !q(d) && k(b);
    });
  }
  mn(() => {
    dc(g, 1, `row-background ${q(u) ?? ""} ${(q(c) ? "flashed" : null) ?? ""} ${(q(h) && o.highlightHoveredRow ? "hovered" : null) ?? ""}`, "svelte-14dgpd0"), v = go(g, "", v, {
      "--width": q(a) + "px",
      "--height": q(s) + "px",
      "--y": q(l) + "px"
    });
  }), Pt(t, p), sn();
}
var QCe = /* @__PURE__ */ ur("<!> <!>", 1), JCe = /* @__PURE__ */ ur('<div class="scroll-container svelte-1v3p82v"><!></div> <!> <!>', 1), YCe = /* @__PURE__ */ ur('<div class="table svelte-1v3p82v"><!> <div class="table-contents svelte-1v3p82v"><!></div></div>');
const ZCe = {
  hash: "svelte-1v3p82v",
  code: ".table.svelte-1v3p82v {width:100%;max-width:var(--max-width);height:100%;display:flex;flex-direction:column;position:relative;}.table-contents.svelte-1v3p82v {position:relative;overflow:hidden;flex-grow:1;}.scroll-container.svelte-1v3p82v {position:absolute;width:0;height:0;will-change:transform;contain:layout size;}"
};
function e_e(t, e) {
  on(e, !0), an(t, ZCe), xr.initialize(), t1.initialize(), r1.initialize(), D_.initialize(), Cr.initialize();
  const r = Cr.controller, n = Cr.model, i = Cr.overscrollModifier, o = xr.config, s = D_.style;
  Qr(() => {
    e.scrollTo != null && r.scrollToRow(String(e.scrollTo));
  }), Qr(() => {
    e.highlightedRows && e.highlightedRows.length > 0 ? o.highlightedRows = new Set(e.highlightedRows.map((k) => String(k))) : o.highlightedRows = null;
  }), Qr(() => {
    e.onRowClick != null ? o.onRowClick = e.onRowClick : o.onRowClick = null;
  }), Qr(() => {
    e.coordinator ? E_.coordinator = e.coordinator : E_.coordinator = null;
  }), Qr(() => {
    e.numLines != null ? o.textMaxLines = e.numLines : o.textMaxLines = o.DEFAULT_TEXT_MAX_LINES, e.lineHeight != null ? o.lineHeight = e.lineHeight : o.lineHeight = o.DEFAULT_LINE_HEIGHT;
  }), Qr(() => {
    e.colorScheme != null ? s.colorScheme = e.colorScheme : s.colorScheme = null;
  }), Qr(() => {
    e.theme != null ? s.theme = e.theme : s.theme = {}, e.colorScheme != null ? s.colorScheme = e.colorScheme : s.colorScheme = null;
  }), Qr(() => {
    e.columnConfigs != null ? o.columnConfigs = e.columnConfigs : o.columnConfigs = {}, e.onColumnConfigsChange != null ? o.onColumnConfigsChange = e.onColumnConfigsChange : o.onColumnConfigsChange = () => {
    };
  }), Qr(() => {
    o.showRowNumber = e.showRowNumber ?? null;
  }), Qr(() => {
    o.onShowRowNumberChange = e.onShowRowNumberChange ?? null;
  }), Qr(() => {
    r.initialize({
      tableName: e.table,
      rowKey: e.rowKey,
      columns: [qCe(), ...e.columns],
      filterBy: e.filter ?? null
    });
  }), Qr(() => {
    e.customCells != null ? t1.config = e.customCells : t1.config = {};
  }), Qr(() => {
    e.additionalHeaderContents != null ? r1.config = e.additionalHeaderContents : r1.config = {};
  }), Qr(() => {
    e.headerHeight != null ? o.headerHeight = e.headerHeight : o.headerHeight = null;
  }), Qr(() => {
    e.highlightHoveredRow != null ? o.highlightHoveredRow = e.highlightHoveredRow : o.highlightHoveredRow = !1;
  });
  let a = /* @__PURE__ */ qe([]), l = /* @__PURE__ */ qe(0), u = /* @__PURE__ */ qe(null), c = /* @__PURE__ */ qe(ui([])), h = /* @__PURE__ */ qe(ui([])), d = /* @__PURE__ */ Se(() => q(c).filter((k) => r.rowStillExists(k))), p = /* @__PURE__ */ Se(() => q(h)), g = 0;
  _p(() => (g = requestAnimationFrame(b), () => {
    r.teardown(), n.teardown(), cancelAnimationFrame(g);
  }));
  function v(k, C) {
    if (C.length > 0) {
      const S = C[C.length - 1];
      return Math.abs(n.data[k][Ki] - n.data[S][Ki]);
    }
    return 0;
  }
  function y() {
    const { left: k, right: C } = UCe(q(a), n.renderableRows);
    k.length === 0 && C.length === 0 || (be(a, HCe(q(
      a
      // remove the rows that have been deleted from the model
    ), k)), be(a, VCe(q(
      a
      // add the rows that have been added by the model
    ), C.sort((S, _) => v(S, q(a)) - v(_, q(a))).slice(0, r.isJumping ? r.rowsOnScreen : o.rowRenderBatchSize))));
  }
  function b() {
    y(), be(c, q(a).filter((S) => r.rowIsVisible(S)), !0), be(h, n.renderableCols.filter((S) => r.colIsVisible(S)), !0);
    const k = r.xScroll, C = i.yScroll(r.yScroll);
    q(u) && (q(u).style.transform = `translate3d(${k}px, ${C}px, 0)`), be(l, r.updateKey, !0), g = requestAnimationFrame(b);
  }
  jCe(t, {
    children: (k, C) => {
      var S = YCe(), _ = yr(S);
      $Ce(_, {});
      var D = vs(_, 2), A = yr(D);
      {
        var O = (M) => {
          var z = JCe(), N = zo(z), P = yr(N);
          Pke(P, () => q(l), ($) => {
            var j = QCe(), U = zo(j);
            Vm(U, 16, () => q(d), (G) => G, (G, re) => {
              var ne = jc(), se = zo(ne);
              Vm(se, 16, () => q(p), (ie) => ie, (ie, ce) => {
                nCe(ie, {
                  get row() {
                    return re;
                  },
                  get col() {
                    return ce;
                  }
                });
              }), Pt(G, ne);
            });
            var H = vs(U, 2);
            Vm(H, 16, () => n.renderableRows, (G) => G, (G, re) => {
              XCe(G, {
                get row() {
                  return re;
                }
              });
            }), Pt($, j);
          }), dr(N), zi(N, ($) => be(u, $), () => q(u));
          var I = vs(N, 2);
          O3e(I, {});
          var B = vs(I, 2);
          A3e(B, {}), Pt(M, z);
        };
        Ji(A, (M) => {
          r.isReady && M(O);
        });
      }
      dr(D), dr(S), zi(S, (M) => r.element = M, () => r?.element), Wd("wheel", S, function(...M) {
        r.handleWheel?.apply(this, M);
      }), na(D, "clientHeight", (M) => r.viewHeight = M), na(D, "clientWidth", (M) => r.viewWidth = M), Pt(k, S);
    },
    $$slots: { default: !0 }
  }), sn();
}
class t_e {
  component;
  currentProps;
  constructor(e, r) {
    this.currentProps = { ...r }, this.component = Oke({ component: e_e, target: e, props: r });
  }
  update(e) {
    let r = {};
    for (let n in e)
      e[n] !== this.currentProps[n] && (r[n] = e[n], this.currentProps[n] = e[n]);
    this.component.$set(r);
  }
  destroy() {
    this.component.$destroy();
  }
}
var r_e = /* @__PURE__ */ me("<div></div>");
function n_e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]), n;
  Qg(() => {
    let o = new t_e(n, r);
    Ws(() => {
      o.update(r);
    }), _T(() => {
      o.destroy();
    });
  });
  var i = r_e();
  ct(i, "", {}, { width: "100%", height: "100%" }), Qs(i, (o) => n = o, () => n), Q(t, i), it();
}
const i_e = {
  fontSize: "13px",
  fontFamily: "system-ui",
  light: {
    primaryBackgroundColor: "white",
    secondaryBackgroundColor: "var(--color-slate-100)",
    // bg-slate-100
    primaryTextColor: "var(--color-slate-500)",
    // text-slate-500
    secondaryTextColor: "var(--color-slate-400)",
    // text-slate-400
    tertiaryTextColor: "var(--color-slate-300)",
    // text-slate-300
    scrollbarPillColor: "var(--color-slate-400)",
    // bg-slate-400
    scrollbarLabelBackgroundColor: "white",
    rowScrollToColor: "var(--color-blue-200)",
    // bg-blue-200
    rowHoverColor: "var(--color-blue-100)"
    // bg-blue-100
  },
  dark: {
    primaryBackgroundColor: "black",
    secondaryBackgroundColor: "var(--color-slate-900)",
    // bg-slate-900
    primaryTextColor: "var(--color-slate-400)",
    // bg-slate-400
    secondaryTextColor: "var(--color-slate-500)",
    // bg-slate-500
    tertiaryTextColor: "var(--color-slate-600)",
    // bg-slate-600
    scrollbarPillColor: "var(--color-slate-500)",
    // bg-slate-500
    scrollbarLabelBackgroundColor: "var(--color-slate-900)",
    // bg-slate-900
    rowScrollToColor: "var(--color-blue-900)",
    // bg-slate-900
    rowHoverColor: "var(--color-blue-950)"
    // bg-slate-950
  }
};
function o_e(t, e) {
  nt(e, !0);
  const r = () => gi(a, "$columnStyles", i), n = () => gi(s, "$colorScheme", i), [i, o] = Jo();
  let { colorScheme: s, columnStyles: a } = e.context, l = sz(e.context.highlight), u = /* @__PURE__ */ De(null);
  dt(() => l.subscribe((d) => {
    x(u) !== d && ae(u, d, !0);
  }));
  function c(d, p, g) {
    let v = {};
    for (let y of d)
      g?.[y.name] != null && (v[y.name] = AO(g[y.name])), p[y.name]?.renderer != null && (v[y.name] = AO(p[y.name]?.renderer));
    return v;
  }
  let h = /* @__PURE__ */ K(() => c(e.context.columns, r(), e.context.tableCellRenderers));
  n_e(t, {
    get coordinator() {
      return e.context.coordinator;
    },
    get table() {
      return e.context.table;
    },
    get rowKey() {
      return e.context.id;
    },
    get columns() {
      return e.spec.columns;
    },
    get filter() {
      return e.context.filter;
    },
    get scrollTo() {
      return x(u);
    },
    onRowClick: async (d) => {
      l.set(d);
    },
    numLines: 3,
    get colorScheme() {
      return n();
    },
    get theme() {
      return i_e;
    },
    highlightHoveredRow: !0,
    get customCells() {
      return x(h);
    }
  }), it(), o();
}
const aj = {}, lj = [];
function As(t, e) {
  aj[t] = e;
}
function gu(t) {
  lj.push(t);
}
function s_e(t) {
  return typeof t != "object" ? $k : typeof t.type == "string" ? aj[t.type] ?? $k : $k;
}
function a_e() {
  return lj;
}
As("builder", vxe);
As("count-plot", ebe);
As("count-plot-list", cbe);
As("histogram", gbe);
As("histogram-stack", Obe);
As("histogram-2d", kbe);
As("box-plot", H1e);
As("mosaic-spec", $be);
As("line-plot", Rbe);
As("embedding", S2e);
As("predicates", Hbe);
As("table", o_e);
gu({
  icon: "chart-h-bar",
  description: "Create a count plot of a categorical field",
  ui: [
    { field: { key: "x", label: "Field", types: ["number", "string", "string[]"], required: !0 } }
    //
  ],
  create: ({ x: t }) => t.type == "discrete[]" ? {
    title: t.name,
    type: "count-plot-list",
    data: { field: t.name }
  } : {
    title: t.name,
    type: "count-plot",
    data: { field: t.name }
  }
});
gu({
  icon: "chart-v-histogram",
  description: "Create a histogram of a field",
  ui: [
    { field: { key: "x", label: "Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t }) => ({
    type: "histogram",
    title: t.name,
    data: { field: t.name },
    binCount: 20
  })
});
gu({
  icon: "chart-line",
  description: "Create a line plot over time",
  ui: [
    { field: { key: "x", label: "Time Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t }, e) => ({
    type: "line-plot",
    title: `${t.name} over time`,
    data: { table: e.table, x: t.name }
  })
});
gu({
  icon: "chart-stacked",
  description: "Create a stacked histogram",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number", "string"], required: !0 } },
    //
    { field: { key: "y", label: "Group Field", types: ["number", "string"] } }
    //
  ],
  create: ({ x: t, y: e }) => e == null ? {
    type: "histogram",
    title: `${t.name}`,
    data: {
      field: t.name
    },
    binCount: 20
  } : {
    type: "histogram-stack",
    title: `${t.name} by ${e.name}`,
    data: {
      x: t.name,
      group: e.name
    },
    xBinCount: 20,
    groupBinCount: 5
  }
});
gu({
  icon: "chart-heatmap",
  description: "Create a 2D heatmap of two fields",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number", "string"], required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t, y: e }) => ({
    type: "histogram-2d",
    title: `${t.name}, ${e.name}`,
    data: { x: t.name, y: e.name },
    xBinCount: 20,
    yBinCount: 20
  })
});
gu({
  icon: "chart-boxplot",
  description: "Create a box plot",
  ui: [
    { field: { key: "x", label: "X Field", required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number"], required: !0 } }
    //
  ],
  create: ({ x: t, y: e }) => ({
    type: "box-plot",
    title: `${e.name} by ${t.name}`,
    data: { x: t.name, y: e.name },
    xBinCount: 20
  })
});
gu({
  icon: "chart-embedding",
  description: "Create an embedding view",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number"], required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number"], required: !0 } },
    //
    { field: { key: "text", label: "Text Field", types: ["string"] } },
    //
    { field: { key: "category", label: "Category Field", types: ["string", "number"] } }
    //
  ],
  preview: !1,
  create: ({ x: t, y: e, text: r, category: n }, i) => ({
    type: "embedding",
    title: "Embedding",
    data: {
      x: t.name,
      y: e.name,
      text: r?.name,
      category: n?.name
    }
  })
});
gu({
  icon: "chart-predicates",
  description: "Create a filter with custom SQL predicates",
  ui: [],
  create: () => ({
    type: "predicates",
    title: "SQL Predicates"
  })
});
gu({
  icon: "chart-spec",
  description: "Create a chart with custom spec",
  preview: !1,
  ui: [{ code: { key: "spec", language: "json" } }],
  create: ({ spec: t }) => JSON.parse(t)
});
var l_e = /* @__PURE__ */ me("<button>An occured with this chart. Click to retry.</button>"), u_e = /* @__PURE__ */ me("<div><!></div>");
function uj(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]), n = /* @__PURE__ */ K(() => s_e(e.spec)), i = /* @__PURE__ */ De(100), o = /* @__PURE__ */ De(100);
  function s(c, h) {
    console.trace("Error happened in chart with spec", h.spec, h.error);
  }
  var a = u_e();
  let l;
  var u = Y(a);
  XF(u, { failed: (c, h = jt, d = jt) => {
    var p = l_e();
    p.__click = function(...g) {
      d()?.apply(this, g);
    }, Mo(p, (g, v) => s?.(g, v), () => ({ spec: e.spec, error: h() })), Q(c, p);
  } }, (c) => {
    var h = kr(), d = He(h);
    {
      let p = /* @__PURE__ */ K(() => e.width == "container" ? x(i) : e.width), g = /* @__PURE__ */ K(() => e.height == "container" ? x(o) : e.height);
      Qd(d, () => x(n), (v, y) => {
        y(v, lQ(() => r, {
          get width() {
            return x(p);
          },
          get height() {
            return x(g);
          }
        }));
      });
    }
    Q(c, h);
  }), J(a), Ee(() => l = ct(a, "", l, {
    width: e.width == "container" ? "100%" : e.width != null ? `${e.width}px` : "fit-content",
    height: e.height == "container" ? "100%" : e.height != null ? `${e.height}px` : "fit-content"
  })), Xs(a, "clientWidth", (c) => ae(i, c)), Xs(a, "clientHeight", (c) => ae(o, c)), Q(t, a), it();
}
nn(["click"]);
function c_e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ K(() => vme(e.layout)), n = /* @__PURE__ */ K(() => e.layoutStates[e.layout] ?? {});
  function i(h, d, p = "merge") {
    Ay(e.charts, h, d, p, (g) => e.onChartsChange?.(g));
  }
  function o(h, d, p = "merge") {
    Ay(e.chartStates, h, d, p, (g) => e.onChartStatesChange?.(g));
  }
  function s(h, d = "merge") {
    md(e.charts, h, d, (p) => e.onChartsChange?.(p));
  }
  function a(h, d = "merge") {
    md(e.chartStates, h, d, (p) => e.onChartStatesChange?.(p));
  }
  function l(h, d, p = "merge") {
    Ay(e.layoutStates, h, d, p, (g) => e.onLayoutStatesChange?.(g));
  }
  var u = kr(), c = He(u);
  {
    const h = (p, g) => {
      let v = () => g?.().id, y = () => g?.().width, b = () => g?.().height;
      {
        let k = /* @__PURE__ */ K(() => e.chartStates[v()] ?? {}), C = /* @__PURE__ */ K(() => i.bind(null, v())), S = /* @__PURE__ */ K(() => o.bind(null, v()));
        uj(p, {
          get context() {
            return e.context;
          },
          get width() {
            return y();
          },
          get height() {
            return b();
          },
          get spec() {
            return e.charts[v()];
          },
          get state() {
            return x(k);
          },
          get onSpecChange() {
            return x(C);
          },
          get onStateChange() {
            return x(S);
          }
        });
      }
    };
    let d = /* @__PURE__ */ K(() => l.bind(null, e.layout));
    Qd(c, () => x(r), (p, g) => {
      g(p, {
        get context() {
          return e.context;
        },
        get charts() {
          return e.charts;
        },
        get state() {
          return x(n);
        },
        get onStateChange() {
          return x(d);
        },
        onChartsChange: s,
        onChartStatesChange: a,
        chartView: h,
        $$slots: { chartView: !0 }
      });
    });
  }
  Q(t, u), it();
}
var h_e = /* @__PURE__ */ me('<tr class="leading-10"><td class="w-full"><div class="max-w-80 whitespace-nowrap text-ellipsis overflow-x-hidden"> </div></td><td class="pr-2"><div class="flex items-center gap-2"><!> <!></div></td><td><div class="flex items-center gap-2"><!></div></td></tr>');
function f_e(t, e) {
  nt(e, !0);
  function r(v) {
    e.onChange({ ...e.style, ...v });
  }
  var n = h_e(), i = Y(n), o = Y(i), s = Y(o, !0);
  J(o), J(i);
  var a = le(i), l = Y(a), u = Y(l);
  {
    let v = /* @__PURE__ */ K(() => e.style.renderer ?? null), y = /* @__PURE__ */ K(() => [
      { value: null, label: "(default)" },
      ...hwe.map((b) => ({ value: b.renderer, label: b.label }))
    ]);
    Oh(u, {
      get value() {
        return x(v);
      },
      onChange: (b) => r({ renderer: b }),
      get options() {
        return x(y);
      }
    });
  }
  var c = le(u, 2);
  {
    var h = (v) => {
      var y = () => e.style.rendererOptions?.size ?? 100, b = (k) => {
        r({ rendererOptions: { size: k } });
      };
      v_(v, {
        get value() {
          return y();
        },
        set value(k) {
          b(k);
        },
        width: 80,
        min: 16,
        max: 400,
        step: 1
      });
    };
    Fe(c, (v) => {
      e.style.renderer == "image" && v(h);
    });
  }
  J(l), J(a);
  var d = le(a), p = Y(d), g = Y(p);
  {
    let v = /* @__PURE__ */ K(() => e.style.display ?? "badge");
    Oh(g, {
      get value() {
        return x(v);
      },
      onChange: (y) => {
        r({ display: y });
      },
      options: [
        { value: "full", label: "Full" },
        { value: "badge", label: "Badge" },
        { value: "hidden", label: "Hidden" }
      ]
    });
  }
  J(p), J(d), J(n), Ee(() => at(s, e.column.name)), Q(t, n), it();
}
var d_e = /* @__PURE__ */ me('<div class="max-h-60 overflow-x-hidden overflow-y-scroll border border-slate-300 dark:border-slate-700 p-2 rounded-md"><table><thead><tr class="select-none"><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Column</th><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Format</th><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Style</th></tr></thead><tbody></tbody></table></div>');
function p_e(t, e) {
  nt(e, !0);
  var r = d_e(), n = Y(r), i = le(Y(n));
  It(i, 21, () => e.columns, hr, (o, s) => {
    {
      let a = /* @__PURE__ */ K(() => e.styles[x(s).name] ?? {});
      f_e(o, {
        get column() {
          return x(s);
        },
        get style() {
          return x(a);
        },
        onChange: (l) => {
          let u = { ...e.styles };
          u[x(s).name] = l, e.onStylesChange(u);
        }
      });
    }
  }), J(i), J(n), J(r), Q(t, r), it();
}
var m_e = /* @__PURE__ */ me('<div> <span class="text-slate-500"> </span></div>');
function g_e(t, e) {
  nt(e, !0);
  let r = /* @__PURE__ */ De(null), n = /* @__PURE__ */ De(null);
  Ws(() => {
    ae(r, null), ae(n, null);
    let l = ol({
      coordinator: e.coordinator,
      selection: e.filter,
      prepare: async () => {
        let u = await e.coordinator.query(pd.from(e.table).select({ count: tD`COUNT(*)::INT` }));
        ae(r, u.get(0).count, !0);
      },
      query: (u) => pd.from(e.table).select({ count: tD`COUNT(*)::INT` }).where(u),
      queryResult: (u) => {
        ae(n, u.getChild("count").get(0), !0);
      }
    });
    return () => {
      l.destroy();
    };
  });
  var i = m_e(), o = Y(i), s = le(o), a = Y(s);
  J(s), J(i), Ee(
    (l, u) => {
      at(o, `${l ?? ""} `), at(a, `/ ${u ?? ""} points`);
    },
    [
      () => x(n)?.toLocaleString() ?? "",
      () => x(r)?.toLocaleString() ?? ""
    ]
  ), Q(t, i), it();
}
var O_ = { exports: {} }, v_e = O_.exports, kF;
function y_e() {
  return kF || (kF = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(v_e, (function() {
      var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
        return typeof u;
      } : function(u) {
        return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
      }, n = function(u, c) {
        if (!(u instanceof c))
          throw new TypeError("Cannot call a class as a function");
      }, i = /* @__PURE__ */ (function() {
        function u(c, h) {
          for (var d = 0; d < h.length; d++) {
            var p = h[d];
            p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(c, p.key, p);
          }
        }
        return function(c, h, d) {
          return h && u(c.prototype, h), d && u(c, d), c;
        };
      })(), o = Object.assign || function(u) {
        for (var c = 1; c < arguments.length; c++) {
          var h = arguments[c];
          for (var d in h)
            Object.prototype.hasOwnProperty.call(h, d) && (u[d] = h[d]);
        }
        return u;
      }, s = (function() {
        function u(c) {
          var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          n(this, u), this.ctx = c, this.iframes = h, this.exclude = d, this.iframesTimeout = p;
        }
        return i(u, [{
          key: "getContexts",
          value: function() {
            var c = void 0, h = [];
            return typeof this.ctx > "u" || !this.ctx ? c = [] : NodeList.prototype.isPrototypeOf(this.ctx) ? c = Array.prototype.slice.call(this.ctx) : Array.isArray(this.ctx) ? c = this.ctx : typeof this.ctx == "string" ? c = Array.prototype.slice.call(document.querySelectorAll(this.ctx)) : c = [this.ctx], c.forEach(function(d) {
              var p = h.filter(function(g) {
                return g.contains(d);
              }).length > 0;
              h.indexOf(d) === -1 && !p && h.push(d);
            }), h;
          }
        }, {
          key: "getIframeContents",
          value: function(c, h) {
            var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            }, p = void 0;
            try {
              var g = c.contentWindow;
              if (p = g.document, !g || !p)
                throw new Error("iframe inaccessible");
            } catch {
              d();
            }
            p && h(p);
          }
        }, {
          key: "isIframeBlank",
          value: function(c) {
            var h = "about:blank", d = c.getAttribute("src").trim(), p = c.contentWindow.location.href;
            return p === h && d !== h && d;
          }
        }, {
          key: "observeIframeLoad",
          value: function(c, h, d) {
            var p = this, g = !1, v = null, y = function b() {
              if (!g) {
                g = !0, clearTimeout(v);
                try {
                  p.isIframeBlank(c) || (c.removeEventListener("load", b), p.getIframeContents(c, h, d));
                } catch {
                  d();
                }
              }
            };
            c.addEventListener("load", y), v = setTimeout(y, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function(c, h, d) {
            try {
              c.contentWindow.document.readyState === "complete" ? this.isIframeBlank(c) ? this.observeIframeLoad(c, h, d) : this.getIframeContents(c, h, d) : this.observeIframeLoad(c, h, d);
            } catch {
              d();
            }
          }
        }, {
          key: "waitForIframes",
          value: function(c, h) {
            var d = this, p = 0;
            this.forEachIframe(c, function() {
              return !0;
            }, function(g) {
              p++, d.waitForIframes(g.querySelector("html"), function() {
                --p || h();
              });
            }, function(g) {
              g || h();
            });
          }
        }, {
          key: "forEachIframe",
          value: function(c, h, d) {
            var p = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, v = c.querySelectorAll("iframe"), y = v.length, b = 0;
            v = Array.prototype.slice.call(v);
            var k = function() {
              --y <= 0 && g(b);
            };
            y || k(), v.forEach(function(C) {
              u.matches(C, p.exclude) ? k() : p.onIframeReady(C, function(S) {
                h(C) && (b++, d(S)), k();
              }, k);
            });
          }
        }, {
          key: "createIterator",
          value: function(c, h, d) {
            return document.createNodeIterator(c, h, d, !1);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function(c) {
            return new u(c.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function(c, h, d) {
            var p = c.compareDocumentPosition(d), g = Node.DOCUMENT_POSITION_PRECEDING;
            if (p & g)
              if (h !== null) {
                var v = h.compareDocumentPosition(d), y = Node.DOCUMENT_POSITION_FOLLOWING;
                if (v & y)
                  return !0;
              } else
                return !0;
            return !1;
          }
        }, {
          key: "getIteratorNode",
          value: function(c) {
            var h = c.previousNode(), d = void 0;
            return h === null ? d = c.nextNode() : d = c.nextNode() && c.nextNode(), {
              prevNode: h,
              node: d
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function(c, h, d, p) {
            var g = !1, v = !1;
            return p.forEach(function(y, b) {
              y.val === d && (g = b, v = y.handled);
            }), this.compareNodeIframe(c, h, d) ? (g === !1 && !v ? p.push({
              val: d,
              handled: !0
            }) : g !== !1 && !v && (p[g].handled = !0), !0) : (g === !1 && p.push({
              val: d,
              handled: !1
            }), !1);
          }
        }, {
          key: "handleOpenIframes",
          value: function(c, h, d, p) {
            var g = this;
            c.forEach(function(v) {
              v.handled || g.getIframeContents(v.val, function(y) {
                g.createInstanceOnIframe(y).forEachNode(h, d, p);
              });
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function(c, h, d, p, g) {
            for (var v = this, y = this.createIterator(h, c, p), b = [], k = [], C = void 0, S = void 0, _ = function() {
              var D = v.getIteratorNode(y);
              return S = D.prevNode, C = D.node, C;
            }; _(); )
              this.iframes && this.forEachIframe(h, function(D) {
                return v.checkIframeFilter(C, S, D, b);
              }, function(D) {
                v.createInstanceOnIframe(D).forEachNode(c, function(A) {
                  return k.push(A);
                }, p);
              }), k.push(C);
            k.forEach(function(D) {
              d(D);
            }), this.iframes && this.handleOpenIframes(b, c, d, p), g();
          }
        }, {
          key: "forEachNode",
          value: function(c, h, d) {
            var p = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, v = this.getContexts(), y = v.length;
            y || g(), v.forEach(function(b) {
              var k = function() {
                p.iterateThroughNodes(c, b, h, d, function() {
                  --y <= 0 && g();
                });
              };
              p.iframes ? p.waitForIframes(b, k) : k();
            });
          }
        }], [{
          key: "matches",
          value: function(c, h) {
            var d = typeof h == "string" ? [h] : h, p = c.matches || c.matchesSelector || c.msMatchesSelector || c.mozMatchesSelector || c.oMatchesSelector || c.webkitMatchesSelector;
            if (p) {
              var g = !1;
              return d.every(function(v) {
                return p.call(c, v) ? (g = !0, !1) : !0;
              }), g;
            } else
              return !1;
          }
        }]), u;
      })(), a = (function() {
        function u(c) {
          n(this, u), this.ctx = c, this.ie = !1;
          var h = window.navigator.userAgent;
          (h.indexOf("MSIE") > -1 || h.indexOf("Trident") > -1) && (this.ie = !0);
        }
        return i(u, [{
          key: "log",
          value: function(c) {
            var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug", d = this.opt.log;
            this.opt.debug && (typeof d > "u" ? "undefined" : r(d)) === "object" && typeof d[h] == "function" && d[h]("mark.js: " + c);
          }
        }, {
          key: "escapeStr",
          value: function(c) {
            return c.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function(c) {
            return this.opt.wildcards !== "disabled" && (c = this.setupWildcardsRegExp(c)), c = this.escapeStr(c), Object.keys(this.opt.synonyms).length && (c = this.createSynonymsRegExp(c)), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (c = this.setupIgnoreJoinersRegExp(c)), this.opt.diacritics && (c = this.createDiacriticsRegExp(c)), c = this.createMergedBlanksRegExp(c), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (c = this.createJoinersRegExp(c)), this.opt.wildcards !== "disabled" && (c = this.createWildcardsRegExp(c)), c = this.createAccuracyRegExp(c), c;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function(c) {
            var h = this.opt.synonyms, d = this.opt.caseSensitive ? "" : "i", p = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var g in h)
              if (h.hasOwnProperty(g)) {
                var v = h[g], y = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(g) : this.escapeStr(g), b = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(v) : this.escapeStr(v);
                y !== "" && b !== "" && (c = c.replace(new RegExp("(" + this.escapeStr(y) + "|" + this.escapeStr(b) + ")", "gm" + d), p + ("(" + this.processSynomyms(y) + "|") + (this.processSynomyms(b) + ")") + p));
              }
            return c;
          }
        }, {
          key: "processSynomyms",
          value: function(c) {
            return (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (c = this.setupIgnoreJoinersRegExp(c)), c;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function(c) {
            return c = c.replace(/(?:\\)*\?/g, function(h) {
              return h.charAt(0) === "\\" ? "?" : "";
            }), c.replace(/(?:\\)*\*/g, function(h) {
              return h.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function(c) {
            var h = this.opt.wildcards === "withSpaces";
            return c.replace(/\u0001/g, h ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, h ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function(c) {
            return c.replace(/[^(|)\\]/g, function(h, d, p) {
              var g = p.charAt(d + 1);
              return /[(|)\\]/.test(g) || g === "" ? h : h + "\0";
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function(c) {
            var h = [], d = this.opt.ignorePunctuation;
            return Array.isArray(d) && d.length && h.push(this.escapeStr(d.join(""))), this.opt.ignoreJoiners && h.push("\\u00ad\\u200b\\u200c\\u200d"), h.length ? c.split(/\u0000+/).join("[" + h.join("") + "]*") : c;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function(c) {
            var h = this.opt.caseSensitive ? "" : "i", d = this.opt.caseSensitive ? ["aÃ Ã¡áº£Ã£áº¡Äƒáº±áº¯áº³áºµáº·Ã¢áº§áº¥áº©áº«áº­Ã¤Ã¥ÄÄ…", "AÃ€Ãáº¢Ãƒáº Ä‚áº°áº®áº²áº´áº¶Ã‚áº¦áº¤áº¨áºªáº¬Ã„Ã…Ä€Ä„", "cÃ§Ä‡Ä", "CÃ‡Ä†ÄŒ", "dÄ‘Ä", "DÄÄŽ", "eÃ¨Ã©áº»áº½áº¹Ãªá»áº¿á»ƒá»…á»‡Ã«Ä›Ä“Ä™", "EÃˆÃ‰áººáº¼áº¸ÃŠá»€áº¾á»‚á»„á»†Ã‹ÄšÄ’Ä˜", "iÃ¬Ã­á»‰Ä©á»‹Ã®Ã¯Ä«", "IÃŒÃá»ˆÄ¨á»ŠÃŽÃÄª", "lÅ‚", "LÅ", "nÃ±ÅˆÅ„", "NÃ‘Å‡Åƒ", "oÃ²Ã³á»Ãµá»Ã´á»“á»‘á»•á»—á»™Æ¡á»Ÿá»¡á»›á»á»£Ã¶Ã¸Å", "OÃ’Ã“á»ŽÃ•á»ŒÃ”á»’á»á»”á»–á»˜Æ á»žá» á»šá»œá»¢Ã–Ã˜ÅŒ", "rÅ™", "RÅ˜", "sÅ¡Å›È™ÅŸ", "SÅ ÅšÈ˜Åž", "tÅ¥È›Å£", "TÅ¤ÈšÅ¢", "uÃ¹Ãºá»§Å©á»¥Æ°á»«á»©á»­á»¯á»±Ã»Ã¼Å¯Å«", "UÃ™Ãšá»¦Å¨á»¤Æ¯á»ªá»¨á»¬á»®á»°Ã›ÃœÅ®Åª", "yÃ½á»³á»·á»¹á»µÃ¿", "YÃá»²á»¶á»¸á»´Å¸", "zÅ¾Å¼Åº", "ZÅ½Å»Å¹"] : ["aÃ Ã¡áº£Ã£áº¡Äƒáº±áº¯áº³áºµáº·Ã¢áº§áº¥áº©áº«áº­Ã¤Ã¥ÄÄ…AÃ€Ãáº¢Ãƒáº Ä‚áº°áº®áº²áº´áº¶Ã‚áº¦áº¤áº¨áºªáº¬Ã„Ã…Ä€Ä„", "cÃ§Ä‡ÄCÃ‡Ä†ÄŒ", "dÄ‘ÄDÄÄŽ", "eÃ¨Ã©áº»áº½áº¹Ãªá»áº¿á»ƒá»…á»‡Ã«Ä›Ä“Ä™EÃˆÃ‰áººáº¼áº¸ÃŠá»€áº¾á»‚á»„á»†Ã‹ÄšÄ’Ä˜", "iÃ¬Ã­á»‰Ä©á»‹Ã®Ã¯Ä«IÃŒÃá»ˆÄ¨á»ŠÃŽÃÄª", "lÅ‚LÅ", "nÃ±ÅˆÅ„NÃ‘Å‡Åƒ", "oÃ²Ã³á»Ãµá»Ã´á»“á»‘á»•á»—á»™Æ¡á»Ÿá»¡á»›á»á»£Ã¶Ã¸ÅOÃ’Ã“á»ŽÃ•á»ŒÃ”á»’á»á»”á»–á»˜Æ á»žá» á»šá»œá»¢Ã–Ã˜ÅŒ", "rÅ™RÅ˜", "sÅ¡Å›È™ÅŸSÅ ÅšÈ˜Åž", "tÅ¥È›Å£TÅ¤ÈšÅ¢", "uÃ¹Ãºá»§Å©á»¥Æ°á»«á»©á»­á»¯á»±Ã»Ã¼Å¯Å«UÃ™Ãšá»¦Å¨á»¤Æ¯á»ªá»¨á»¬á»®á»°Ã›ÃœÅ®Åª", "yÃ½á»³á»·á»¹á»µÃ¿YÃá»²á»¶á»¸á»´Å¸", "zÅ¾Å¼ÅºZÅ½Å»Å¹"], p = [];
            return c.split("").forEach(function(g) {
              d.every(function(v) {
                if (v.indexOf(g) !== -1) {
                  if (p.indexOf(v) > -1)
                    return !1;
                  c = c.replace(new RegExp("[" + v + "]", "gm" + h), "[" + v + "]"), p.push(v);
                }
                return !0;
              });
            }), c;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function(c) {
            return c.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function(c) {
            var h = this, d = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~Â¡Â¿", p = this.opt.accuracy, g = typeof p == "string" ? p : p.value, v = typeof p == "string" ? [] : p.limiters, y = "";
            switch (v.forEach(function(b) {
              y += "|" + h.escapeStr(b);
            }), g) {
              case "partially":
              default:
                return "()(" + c + ")";
              case "complementary":
                return y = "\\s" + (y || this.escapeStr(d)), "()([^" + y + "]*" + c + "[^" + y + "]*)";
              case "exactly":
                return "(^|\\s" + y + ")(" + c + ")(?=$|\\s" + y + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function(c) {
            var h = this, d = [];
            return c.forEach(function(p) {
              h.opt.separateWordSearch ? p.split(" ").forEach(function(g) {
                g.trim() && d.indexOf(g) === -1 && d.push(g);
              }) : p.trim() && d.indexOf(p) === -1 && d.push(p);
            }), {
              keywords: d.sort(function(p, g) {
                return g.length - p.length;
              }),
              length: d.length
            };
          }
        }, {
          key: "isNumeric",
          value: function(c) {
            return Number(parseFloat(c)) == c;
          }
        }, {
          key: "checkRanges",
          value: function(c) {
            var h = this;
            if (!Array.isArray(c) || Object.prototype.toString.call(c[0]) !== "[object Object]")
              return this.log("markRanges() will only accept an array of objects"), this.opt.noMatch(c), [];
            var d = [], p = 0;
            return c.sort(function(g, v) {
              return g.start - v.start;
            }).forEach(function(g) {
              var v = h.callNoMatchOnInvalidRanges(g, p), y = v.start, b = v.end, k = v.valid;
              k && (g.start = y, g.length = b - y, d.push(g), p = b);
            }), d;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function(c, h) {
            var d = void 0, p = void 0, g = !1;
            return c && typeof c.start < "u" ? (d = parseInt(c.start, 10), p = d + parseInt(c.length, 10), this.isNumeric(c.start) && this.isNumeric(c.length) && p - h > 0 && p - d > 0 ? g = !0 : (this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(c))), this.opt.noMatch(c))) : (this.log("Ignoring invalid range: " + JSON.stringify(c)), this.opt.noMatch(c)), {
              start: d,
              end: p,
              valid: g
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function(c, h, d) {
            var p = void 0, g = !0, v = d.length, y = h - v, b = parseInt(c.start, 10) - y;
            return b = b > v ? v : b, p = b + parseInt(c.length, 10), p > v && (p = v, this.log("End range automatically set to the max value of " + v)), b < 0 || p - b < 0 || b > v || p > v ? (g = !1, this.log("Invalid range: " + JSON.stringify(c)), this.opt.noMatch(c)) : d.substring(b, p).replace(/\s+/g, "") === "" && (g = !1, this.log("Skipping whitespace only range: " + JSON.stringify(c)), this.opt.noMatch(c)), {
              start: b,
              end: p,
              valid: g
            };
          }
        }, {
          key: "getTextNodes",
          value: function(c) {
            var h = this, d = "", p = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(g) {
              p.push({
                start: d.length,
                end: (d += g.textContent).length,
                node: g
              });
            }, function(g) {
              return h.matchesExclude(g.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, function() {
              c({
                value: d,
                nodes: p
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function(c) {
            return s.matches(c, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function(c, h, d) {
            var p = this.opt.element ? this.opt.element : "mark", g = c.splitText(h), v = g.splitText(d - h), y = document.createElement(p);
            return y.setAttribute("data-markjs", "true"), this.opt.className && y.setAttribute("class", this.opt.className), y.textContent = g.textContent, g.parentNode.replaceChild(y, g), v;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function(c, h, d, p, g) {
            var v = this;
            c.nodes.every(function(y, b) {
              var k = c.nodes[b + 1];
              if (typeof k > "u" || k.start > h) {
                if (!p(y.node))
                  return !1;
                var C = h - y.start, S = (d > y.end ? y.end : d) - y.start, _ = c.value.substr(0, y.start), D = c.value.substr(S + y.start);
                if (y.node = v.wrapRangeInTextNode(y.node, C, S), c.value = _ + D, c.nodes.forEach(function(A, O) {
                  O >= b && (c.nodes[O].start > 0 && O !== b && (c.nodes[O].start -= S), c.nodes[O].end -= S);
                }), d -= S, g(y.node.previousSibling, y.start), d > y.end)
                  h = y.end;
                else
                  return !1;
              }
              return !0;
            });
          }
        }, {
          key: "wrapMatches",
          value: function(c, h, d, p, g) {
            var v = this, y = h === 0 ? 0 : h + 1;
            this.getTextNodes(function(b) {
              b.nodes.forEach(function(k) {
                k = k.node;
                for (var C = void 0; (C = c.exec(k.textContent)) !== null && C[y] !== ""; )
                  if (d(C[y], k)) {
                    var S = C.index;
                    if (y !== 0)
                      for (var _ = 1; _ < y; _++)
                        S += C[_].length;
                    k = v.wrapRangeInTextNode(k, S, S + C[y].length), p(k.previousSibling), c.lastIndex = 0;
                  }
              }), g();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function(c, h, d, p, g) {
            var v = this, y = h === 0 ? 0 : h + 1;
            this.getTextNodes(function(b) {
              for (var k = void 0; (k = c.exec(b.value)) !== null && k[y] !== ""; ) {
                var C = k.index;
                if (y !== 0)
                  for (var S = 1; S < y; S++)
                    C += k[S].length;
                var _ = C + k[y].length;
                v.wrapRangeInMappedTextNode(b, C, _, function(D) {
                  return d(k[y], D);
                }, function(D, A) {
                  c.lastIndex = A, p(D);
                });
              }
              g();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function(c, h, d, p) {
            var g = this;
            this.getTextNodes(function(v) {
              var y = v.value.length;
              c.forEach(function(b, k) {
                var C = g.checkWhitespaceRanges(b, y, v.value), S = C.start, _ = C.end, D = C.valid;
                D && g.wrapRangeInMappedTextNode(v, S, _, function(A) {
                  return h(A, b, v.value.substring(S, _), k);
                }, function(A) {
                  d(A, b);
                });
              }), p();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function(c) {
            for (var h = c.parentNode, d = document.createDocumentFragment(); c.firstChild; )
              d.appendChild(c.removeChild(c.firstChild));
            h.replaceChild(d, c), this.ie ? this.normalizeTextNode(h) : h.normalize();
          }
        }, {
          key: "normalizeTextNode",
          value: function(c) {
            if (c) {
              if (c.nodeType === 3)
                for (; c.nextSibling && c.nextSibling.nodeType === 3; )
                  c.nodeValue += c.nextSibling.nodeValue, c.parentNode.removeChild(c.nextSibling);
              else
                this.normalizeTextNode(c.firstChild);
              this.normalizeTextNode(c.nextSibling);
            }
          }
        }, {
          key: "markRegExp",
          value: function(c, h) {
            var d = this;
            this.opt = h, this.log('Searching with expression "' + c + '"');
            var p = 0, g = "wrapMatches", v = function(y) {
              p++, d.opt.each(y);
            };
            this.opt.acrossElements && (g = "wrapMatchesAcrossElements"), this[g](c, this.opt.ignoreGroups, function(y, b) {
              return d.opt.filter(b, y, p);
            }, v, function() {
              p === 0 && d.opt.noMatch(c), d.opt.done(p);
            });
          }
        }, {
          key: "mark",
          value: function(c, h) {
            var d = this;
            this.opt = h;
            var p = 0, g = "wrapMatches", v = this.getSeparatedKeywords(typeof c == "string" ? [c] : c), y = v.keywords, b = v.length, k = this.opt.caseSensitive ? "" : "i", C = function S(_) {
              var D = new RegExp(d.createRegExp(_), "gm" + k), A = 0;
              d.log('Searching with expression "' + D + '"'), d[g](D, 1, function(O, M) {
                return d.opt.filter(M, _, p, A);
              }, function(O) {
                A++, p++, d.opt.each(O);
              }, function() {
                A === 0 && d.opt.noMatch(_), y[b - 1] === _ ? d.opt.done(p) : S(y[y.indexOf(_) + 1]);
              });
            };
            this.opt.acrossElements && (g = "wrapMatchesAcrossElements"), b === 0 ? this.opt.done(p) : C(y[0]);
          }
        }, {
          key: "markRanges",
          value: function(c, h) {
            var d = this;
            this.opt = h;
            var p = 0, g = this.checkRanges(c);
            g && g.length ? (this.log("Starting to mark with the following ranges: " + JSON.stringify(g)), this.wrapRangeFromIndex(g, function(v, y, b, k) {
              return d.opt.filter(v, y, b, k);
            }, function(v, y) {
              p++, d.opt.each(v, y);
            }, function() {
              d.opt.done(p);
            })) : this.opt.done(p);
          }
        }, {
          key: "unmark",
          value: function(c) {
            var h = this;
            this.opt = c;
            var d = this.opt.element ? this.opt.element : "*";
            d += "[data-markjs]", this.opt.className && (d += "." + this.opt.className), this.log('Removal selector "' + d + '"'), this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(p) {
              h.unwrapMatches(p);
            }, function(p) {
              var g = s.matches(p, d), v = h.matchesExclude(p);
              return !g || v ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function(c) {
            this._opt = o({}, {
              element: "",
              className: "",
              exclude: [],
              iframes: !1,
              iframesTimeout: 5e3,
              separateWordSearch: !0,
              diacritics: !0,
              synonyms: {},
              accuracy: "partially",
              acrossElements: !1,
              caseSensitive: !1,
              ignoreJoiners: !1,
              ignoreGroups: 0,
              ignorePunctuation: [],
              wildcards: "disabled",
              each: function() {
              },
              noMatch: function() {
              },
              filter: function() {
                return !0;
              },
              done: function() {
              },
              debug: !1,
              log: window.console
            }, c);
          },
          get: function() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function() {
            return new s(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]), u;
      })();
      function l(u) {
        var c = this, h = new a(u);
        return this.mark = function(d, p) {
          return h.mark(d, p), c;
        }, this.markRegExp = function(d, p) {
          return h.markRegExp(d, p), c;
        }, this.markRanges = function(d, p) {
          return h.markRanges(d, p), c;
        }, this.unmark = function(d) {
          return h.unmark(d), c;
        }, this;
      }
      return l;
    }));
  })(O_)), O_.exports;
}
var b_e = y_e();
const x_e = /* @__PURE__ */ zh(b_e);
var w_e = /* @__PURE__ */ me('<div class="flex pb-1 text-sm"><span class="px-2 flex gap-2 bg-slate-200 text-slate-500 dark:bg-slate-600 dark:text-slate-300 rounded-md"><div class="text-slate-400 dark:text-slate-400 font-medium">Distance</div> <div class="text-ellipsis whitespace-nowrap overflow-hidden max-w-72"> </div></span></div>'), k_e = /* @__PURE__ */ me('<button class="m-1 p-2 text-left rounded-md hover:outline outline-slate-500"><!> <div class="overflow-hidden text-ellipsis line-clamp-4 leading-5"><!></div></button> <hr class="border-slate-300 dark:border-slate-600"/>', 1), C_e = /* @__PURE__ */ me('<div class="flex flex-col w-full h-full"><div class="ml-3 mr-2 my-1 flex items-center text-slate-400 dark:text-slate-500 items-start"><div class="flex-1"><div> </div> <div> </div></div> <div class="flex-none mt-1"><button class="block hover:text-slate-500 dark:hover:text-slate-400"><!></button></div></div> <hr class="border-slate-300 dark:border-slate-600"/> <div class="flex flex-col overflow-x-hidden overflow-y-scroll"></div></div>');
function __e(t, e) {
  nt(e, !0);
  let r = lt(e, "limit", 3, 100);
  function n(y, b) {
    new x_e(y).mark(b);
  }
  let i = /* @__PURE__ */ K(() => e.items.length == 0 ? "No result found." : e.items.length == 1 ? `${e.items.length.toLocaleString()} result.` : e.items.length >= r() ? `More than ${e.items.length.toLocaleString()} results, showing top ${r().toLocaleString()}.` : `${e.items.length.toLocaleString()} results.`);
  var o = C_e(), s = Y(o), a = Y(s), l = Y(a), u = Y(l, !0);
  J(l);
  var c = le(l, 2), h = Y(c, !0);
  J(c), J(a);
  var d = le(a, 2), p = Y(d);
  p.__click = () => {
    e.onClose?.();
  };
  var g = Y(p);
  vx(g, {}), J(p), J(d), J(s);
  var v = le(s, 4);
  It(v, 20, () => e.items, (y) => y, (y, b) => {
    var k = k_e(), C = He(k);
    C.__click = () => {
      e.onClick?.(b);
    };
    var S = Y(C);
    {
      var _ = (O) => {
        var M = w_e(), z = Y(M), N = le(Y(z), 2), P = Y(N, !0);
        J(N), J(z), J(M), Ee((I) => at(P, I), [() => b.distance.toFixed(5)]), Q(O, M);
      };
      Fe(S, (O) => {
        b.distance != null && O(_);
      });
    }
    var D = le(S, 2), A = Y(D);
    {
      let O = /* @__PURE__ */ K(() => e.columnStyles ?? {});
      GL(A, {
        get values() {
          return b.fields;
        },
        get columnStyles() {
          return x(O);
        }
      });
    }
    J(D), Mo(D, (O, M) => n?.(O, M), () => e.highlight), J(C), U_(2), Q(y, k);
  }), J(v), J(o), Ee(() => {
    at(u, e.label), at(h, x(i));
  }), Q(t, o), it();
}
nn(["click"]);
var S_e = /* @__PURE__ */ St('<svg><path fill="currentColor" d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z" opacity=".25"></path><path fill="currentColor" d="M10.72,19.9a8,8,0,0,1-6.5-9.79A7.77,7.77,0,0,1,10.4,4.16a8,8,0,0,1,9.49,6.52A1.54,1.54,0,0,0,21.38,12h.13a1.37,1.37,0,0,0,1.38-1.54,11,11,0,1,0-12.7,12.39A1.54,1.54,0,0,0,12,21.34h0A1.47,1.47,0,0,0,10.72,19.9Z"><animateTransform attributeName="transform" dur="0.75s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"></animateTransform></path></svg>');
function cj(t, e) {
  const r = /* @__PURE__ */ jn(e, ["$$slots", "$$events", "$$legacy"]);
  var n = S_e();
  Qo(n, () => ({ viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ...r })), Q(t, n);
}
function CF(t, e) {
  nt(e, !0);
  let r = lt(e, "label", 3, null), n = lt(e, "icon", 3, null), i = lt(e, "title", 3, ""), o = lt(e, "order", 3, null), s = /* @__PURE__ */ De("ready");
  async function a() {
    if (e.onClick) {
      ae(s, "running");
      try {
        await e.onClick(), ae(s, "ready");
      } catch {
        ae(s, "error");
      }
    }
  }
  {
    let l = /* @__PURE__ */ K(() => x(s) == "ready" ? n() : x(s) == "running" ? cj : vx);
    Mu(t, {
      get label() {
        return r();
      },
      get icon() {
        return x(l);
      },
      get title() {
        return i();
      },
      get order() {
        return o();
      },
      get class() {
        return e.class;
      },
      onClick: a
    });
  }
  it();
}
var A_e = /* @__PURE__ */ me('<span class="pl-2 text-slate-500 dark:text-slate-500"> </span>'), E_e = /* @__PURE__ */ me('<div role="status" class="flex flex-row items-center"><!> <!></div>');
function D_e(t, e) {
  let r = lt(e, "status", 3, "Loading...");
  var n = E_e(), i = Y(n);
  cj(i, { class: "text-blue-500" });
  var o = le(i, 2);
  {
    var s = (a) => {
      var l = A_e(), u = Y(l, !0);
      J(l), Ee(() => at(u, r())), Q(a, l);
    };
    Fe(o, (a) => {
      r() != null && a(s);
    });
  }
  J(n), Q(t, n);
}
class O_e {
  contents;
  constructor() {
    this.contents = /* @__PURE__ */ new Map();
  }
  get(e) {
    return this.contents.get(e) ?? null;
  }
  set(e, r) {
    this.contents.set(e, r);
  }
  value(e, r) {
    if (this.contents.has(e))
      return this.contents.get(e);
    const n = r();
    return this.contents.set(e, n), n;
  }
}
async function F_e(t, e, r, n = {}) {
  let i = n.exclude ?? [], o = (await OL(t, e)).filter((a) => !a.name.startsWith("__")), s = [];
  n?.projection != null && s.push({
    type: "embedding",
    title: "Embedding",
    data: {
      x: n.projection.x,
      y: n.projection.y,
      text: n.projection.text
    }
  }), s.push({ type: "predicates", title: "SQL Predicates" }), s.push({ type: "table", title: "Table", columns: o.map((a) => a.name) });
  for (let a of o) {
    if (a.jsType == null || i.indexOf(a.name) >= 0)
      continue;
    let l = await FL(t, e, a.name);
    if (!(l <= 1))
      switch (a.jsType) {
        case "string":
          l <= 1e3 && s.push({
            type: "count-plot",
            title: a.name,
            data: { field: a.name }
          });
          break;
        case "string[]":
          s.push({
            type: "count-plot-list",
            title: a.name,
            data: { field: a.name }
          });
          break;
        case "number":
          l <= 10 ? s.push({
            type: "count-plot",
            title: a.name,
            data: { field: a.name }
          }) : s.push({
            type: "histogram",
            title: a.name,
            data: { field: a.name },
            binCount: 20
          });
          break;
      }
  }
  return s;
}
const _F = "0.12.0";
class T_e {
  worker;
  callbacks;
  constructor() {
    this.worker = new Worker(new URL("./search.worker.js", import.meta.url), { type: "module" }), this.callbacks = /* @__PURE__ */ new Map(), this.worker.onmessage = (e) => {
      let r = this.callbacks.get(e.data.identifier);
      r != null && (this.callbacks.delete(e.data.identifier), r(e.data));
    };
  }
  rpc(e) {
    return new Promise((r, n) => {
      let i = (/* @__PURE__ */ new Date()).getTime() + "-" + Math.random();
      this.callbacks.set(i, r), this.worker.postMessage({ ...e, identifier: i });
    });
  }
  async clear() {
    await this.rpc({ type: "clear" });
  }
  async addPoints(e) {
    await this.rpc({ type: "points", points: e });
  }
  async query(e, r) {
    return (await this.rpc({ type: "query", query: e, limit: r })).result;
  }
}
class M_e {
  coordinator;
  table;
  columns;
  backend;
  currentIndex = null;
  constructor(e, r, n) {
    this.coordinator = e, this.table = r, this.columns = n, this.currentIndex = null, this.backend = new T_e();
  }
  predicateString(e) {
    return e != null && e.toString() != "" ? e.toString() : null;
  }
  async buildIndexIfNeeded(e) {
    let r = this.predicateString(e);
    if (this.currentIndex != null && this.currentIndex.predicate == r)
      return;
    let n;
    r != null ? n = await this.coordinator.query(`
        SELECT
          ${T.column(this.columns.id)} AS id,
          ${T.column(this.columns.text)} AS text
        FROM ${this.table}
        WHERE ${r}
      `) : n = await this.coordinator.query(`
        SELECT
          ${T.column(this.columns.id)} AS id,
          ${T.column(this.columns.text)} AS text
        FROM ${this.table}
      `), await this.backend.clear(), await this.backend.addPoints(Array.from(n)), this.currentIndex = { predicate: r };
  }
  async fullTextSearch(e, r = {}) {
    let n = r.limit ?? 100, i = r.predicate;
    return await this.buildIndexIfNeeded(i), (await this.backend.query(e, n)).map((o) => ({ id: o }));
  }
}
async function P_e(t, e, r, n, i, o) {
  let s = [`${T.column(r.id, e)} AS id`];
  r.x && s.push(`${T.column(r.x, e)} AS x`), r.y && s.push(`${T.column(r.y, e)} AS y`), r.text && s.push(`${T.column(r.text, e)} AS text`);
  let a = n ?? {};
  for (let p in a) {
    let g = a[p];
    typeof g == "string" ? s.push(`${T.column(g, e)} AS "field_${p}"`) : s.push(`${T.sql(g.sql)} AS "field_${p}"`);
  }
  let l = o.map((p) => p.id), u = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
  for (let p = 0; p < l.length; p++)
    u.set(l[p], p), c.set(l[p], o[p]);
  let h = await t.query(`
    SELECT
      ${s.join(", ")}
    FROM (
      SELECT ${T.column(r.id, e)} AS __search_result_id__
      FROM ${e}
      WHERE
        ${T.column(r.id, e)} IN [${l.map((p) => T.literal(p)).join(", ")}]
        ${i ? `AND (${i})` : ""}
    )
    LEFT JOIN ${e} ON ${T.column(r.id, e)} = __search_result_id__
  `), d = Array.from(h).map((p) => {
    let g = { id: p.id, distance: c.get(p.id)?.distance, fields: {} };
    for (let v in p)
      v.startsWith("field_") ? g.fields[v.substring(6)] = p[v] : g[v] = p[v];
    return g;
  });
  return d = d.sort((p, g) => (u.get(p.id) ?? 0) - (u.get(g.id) ?? 0)), d;
}
function R_e(t) {
  let { coordinator: e, table: r, idColumn: n, searcher: i, textColumn: o, neighborsColumn: s } = t, a = {};
  if (i != null && i.fullTextSearch != null)
    a.fullTextSearch = i.fullTextSearch.bind(i);
  else if (o != null) {
    let l = new M_e(e, r, { id: n, text: o });
    a.fullTextSearch = l.fullTextSearch.bind(l);
  }
  return i != null && i.vectorSearch != null && (a.vectorSearch = i.vectorSearch.bind(i)), i != null && i.nearestNeighbors != null ? a.nearestNeighbors = i.nearestNeighbors.bind(i) : s != null && (a.nearestNeighbors = async (l) => {
    let u = T.Query.from(r).select({ knn: T.column(s) }).where(T.eq(T.column(n), T.literal(l))), c = await e.query(u), h = Array.from(c);
    if (h.length != 1)
      return [];
    let { distances: d, ids: p } = h[0].knn;
    return Array.from(p).map((g, v) => ({ id: g, distance: d[v] })).filter((g) => g.id != l);
  }), a;
}
let hj = typeof window < "u" ? window.matchMedia?.("(prefers-color-scheme: dark)") : null, fj = Uf(hj?.matches ? "dark" : "light");
hj?.addEventListener("change", (t) => {
  fj.set(t.matches ? "dark" : "light");
});
function N_e() {
  let t = Uf(null);
  return { colorScheme: nQ([fj, t], ([e, r]) => r ?? e), userColorScheme: t };
}
var $_e = /* @__PURE__ */ me('<div class="p-2"><!></div>'), I_e = /* @__PURE__ */ me('<div class="absolute w-96 left-0 top-[32px] rounded-md right-0 z-20 border border-slate-300 dark:border-slate-600 overflow-hidden resize shadow-lg bg-white/75 dark:bg-slate-800/75 backdrop-blur-sm"><!></div>'), B_e = /* @__PURE__ */ me('<div class="relative w-full"><!> <!> <!></div>'), L_e = /* @__PURE__ */ me('<div class="text-slate-500 dark:text-slate-400">Embedding Atlas</div>'), z_e = /* @__PURE__ */ me('<h4 class="text-slate-500 dark:text-slate-400 select-none">Column Styles</h4> <!>', 1), j_e = /* @__PURE__ */ me('<div class="flex flex-row gap-2"><!> <!></div>'), q_e = /* @__PURE__ */ me('<div class="min-w-[420px] flex flex-col gap-2"><!> <h4 class="text-slate-500 dark:text-slate-400 select-none">Export</h4> <div class="flex flex-col gap-2"><!> <!></div> <h4 class="text-slate-500 dark:text-slate-400 select-none">About</h4> <div> </div></div>'), U_e = /* @__PURE__ */ me('<div class="embedding-atlas-root"><div><div class="m-2 flex flex-row items-center gap-2 flex-wrap"><div class="flex flex-row flex-1 justify-between min-w-[180px]"><!></div> <div class="flex flex-none gap-2 items-center"><!> <div class="flex flex-row gap-1 items-center"><button class="flex px-2.5 mr-1 select-none items-center justify-center text-slate-500 dark:text-slate-300 rounded-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 focus-visible:outline-2 outline-blue-600 -outline-offset-1" title="Clear filters">Clear</button></div></div> <div class="flex flex-none flex-row gap-0.5"><!> <!> <!></div></div> <div class="flex-1 overflow-hidden h-full ml-2 mr-2 mb-2"><!></div></div></div>');
function H_e(t, e) {
  nt(e, !0);
  const r = () => gi(u, "$colorScheme", i), n = () => gi(C, "$resolvedColumnStyles", i), [i, o] = Jo(), s = 500;
  let a = lt(e, "embeddingViewConfig", 3, null), l = lt(e, "embeddingViewLabels", 3, null);
  const { colorScheme: u, userColorScheme: c } = N_e();
  dt(() => {
    kD(c, e.colorScheme);
  });
  let h = /* @__PURE__ */ De(!1), d = /* @__PURE__ */ De("parquet");
  const p = vK.crossfilter();
  function g() {
    return f_(p.predicate(null));
  }
  let v = /* @__PURE__ */ De(null);
  function y() {
    try {
      const _e = f_(p.predicate(null));
      ae(v, _e || null, !0);
    } catch {
      ae(v, null);
    }
  }
  let b = /* @__PURE__ */ De([]), k = /* @__PURE__ */ De({}), C = Uf({});
  dt(() => {
    let _e = S(x(b), x(k));
    C.set(_e);
  });
  function S(_e, tt) {
    let Ft = {};
    for (let mr of _e) {
      let Tt = tt[mr.name];
      Tt == null && (Tt = { display: e.data.text == mr.name ? "full" : "badge" }), Ft[mr.name] = Tt;
    }
    return Ft;
  }
  let _ = R_e({
    coordinator: e.coordinator,
    table: e.data.table,
    idColumn: e.data.id,
    textColumn: e.data.text,
    neighborsColumn: e.data.neighbors,
    searcher: e.searcher
  }), D = [
    ..._.fullTextSearch != null ? ["full-text"] : [],
    ..._.vectorSearch != null ? ["vector"] : [],
    ..._.nearestNeighbors != null ? ["neighbors"] : []
  ];
  const A = {
    "full-text": { value: "full-text", label: "Full Text" },
    vector: { value: "vector", label: "Vector" },
    neighbors: { value: "neighbors", label: "Neighbors" }
  };
  let O = /* @__PURE__ */ De("full-text"), M = /* @__PURE__ */ De(""), z = /* @__PURE__ */ De(""), N = /* @__PURE__ */ De(!1), P = /* @__PURE__ */ De(null), I = Uf(null);
  async function B(_e, tt) {
    if (_ == null || D.indexOf(tt) < 0) {
      j();
      return;
    }
    ae(N, !0), ae(z, "Searching...");
    let Ft = g(), mr = [], Tt = "", Et = _e.toString();
    tt == "full-text" && _.fullTextSearch != null ? (_e = _e.trim(), mr = await _.fullTextSearch(_e, {
      limit: s,
      predicate: Ft,
      onStatus: (Ut) => {
        ae(z, Ut, !0);
      }
    }), Tt = _e) : tt == "vector" && _.vectorSearch != null ? (_e = _e.trim(), mr = await _.vectorSearch(_e, {
      limit: s,
      predicate: Ft,
      onStatus: (Ut) => {
        ae(z, Ut, !0);
      }
    }), Tt = _e) : tt == "neighbors" && _.nearestNeighbors != null && (Et = "Neighbors of #" + _e.toString(), mr = await _.nearestNeighbors(_e, {
      limit: s,
      predicate: Ft,
      onStatus: (Ut) => {
        ae(z, Ut, !0);
      }
    }));
    let Ar = await P_e(
      e.coordinator,
      e.data.table,
      {
        id: e.data.id,
        x: e.data.projection?.x,
        y: e.data.projection?.y,
        text: e.data.text
      },
      Object.fromEntries(x(b).map((Ut) => [Ut.name, Ut.name])),
      Ft,
      mr
    );
    ae(z, ""), ae(P, { label: Et, highlight: Tt, items: Ar }), I.set({ query: _e, mode: tt, ids: Ar.map((Ut) => Ut.id) });
  }
  const $ = EK(B, 500);
  function j() {
    ae(P, null), I.set(null), ae(N, !1);
  }
  dt(() => {
    x(M) == "" ? j() : $(x(M), x(O));
  });
  function U() {
    for (let _e of p.clauses)
      _e.source?.reset?.(), p.update({ ..._e, value: null, predicate: null });
  }
  function H(_e) {
    typeof _e.version == "string" && (ae(ne, _e.charts ?? {}), ae(se, _e.chartStates ?? {}), ae(ie, _e.layout ?? "list"), ae(ce, _e.layoutStates ?? {}));
  }
  Ws(() => {
    if (!x(h))
      return;
    let _e = {
      version: _F,
      timestamp: (/* @__PURE__ */ new Date()).getTime() / 1e3,
      charts: x(ne),
      chartStates: x(se),
      layout: x(ie),
      layoutStates: x(ce),
      // Use tracked predicate so this effect re-runs on crossfilter changes
      predicate: x(v)
    };
    e.onStateChange?.(_e);
  }), Qg(async () => {
    y();
    const _e = () => y();
    try {
      p?.addEventListener?.("value", _e);
    } catch {
    }
    try {
      p?.on?.("change", _e);
    } catch {
    }
    try {
      p?.on?.("update", _e);
    } catch {
    }
    let tt = [e.data.projection?.x, e.data.projection?.y].filter((Ft) => Ft != null);
    if (ae(b, (await OL(e.coordinator, e.data.table)).filter((Ft) => !Ft.name.startsWith("__"))), re.columns = x(b), e.initialState && H(e.initialState), Object.keys(x(ne)).length == 0) {
      let Ft = await F_e(e.coordinator, e.data.table, e.data.id, {
        exclude: tt,
        projection: e.data.projection ? {
          ...e.data.projection,
          text: e.data.text ?? void 0
        } : void 0
      });
      ae(ne, Object.fromEntries(Ft.map((mr, Tt) => [`${Tt + 1}`, mr])));
    }
    return ae(h, !0), () => {
      try {
        p?.removeEventListener?.("value", _e);
      } catch {
      }
      try {
        p?.off?.("change", _e);
      } catch {
      }
      try {
        p?.off?.("update", _e);
      } catch {
      }
    };
  });
  function G(_e) {
    if (_e.key == "Escape") {
      U(), _e.preventDefault();
      try {
        document.activeElement?.blur?.();
      } catch {
      }
    }
  }
  let re = {
    coordinator: e.coordinator,
    filter: p,
    table: e.data.table,
    id: e.data.id,
    columns: [],
    colorScheme: u,
    columnStyles: C,
    cache: new O_e(),
    persistentCache: e.cache ?? { get: async () => null, set: async (_e, tt) => {
    } },
    searchModes: D,
    search: B,
    searchResult: I,
    highlight: Uf(null),
    embeddingViewConfig: a(),
    embeddingViewLabels: l(),
    tableCellRenderers: e.tableCellRenderers
  }, ne = /* @__PURE__ */ De({}), se = /* @__PURE__ */ De({}), ie = /* @__PURE__ */ De("list"), ce = /* @__PURE__ */ De({});
  var Ce = U_e();
  EX("keydown", a3, G), ct(Ce, "", {}, { width: "100%", height: "100%" });
  var Me = Y(Ce);
  let Pe, Ae;
  var he = Y(Me), we = Y(he), ve = Y(we);
  {
    var Ge = (_e) => {
      var tt = B_e(), Ft = Y(tt);
      ML(Ft, {
        type: "search",
        placeholder: "Search...",
        className: "w-full max-w-[400px] ",
        get value() {
          return x(M);
        },
        set value(Ut) {
          ae(M, Ut, !0);
        }
      });
      var mr = le(Ft, 2);
      {
        var Tt = (Ut) => {
          {
            let ln = /* @__PURE__ */ K(() => D.filter((wi) => wi != "neighbors").map((wi) => A[wi]));
            Oh(Ut, {
              get options() {
                return x(ln);
              },
              get value() {
                return x(O);
              },
              onChange: (wi) => ae(O, wi, !0)
            });
          }
        };
        Fe(mr, (Ut) => {
          D.filter((ln) => ln != "neighbors").length > 1 && Ut(Tt);
        });
      }
      var Et = le(mr, 2);
      {
        var Ar = (Ut) => {
          var ln = I_e();
          ct(ln, "", {}, { height: "48em" });
          var wi = Y(ln);
          {
            var ua = ($r) => {
              __e($r, {
                get items() {
                  return x(P).items;
                },
                get label() {
                  return x(P).label;
                },
                get highlight() {
                  return x(P).highlight;
                },
                limit: s,
                onClick: async (Qn) => {
                  re.highlight.set(Qn.id);
                },
                onClose: j,
                get columnStyles() {
                  return n();
                }
              });
            }, ml = ($r) => {
              var Qn = kr(), Yo = He(Qn);
              {
                var yo = (Es) => {
                  var wc = $_e(), Ap = Y(wc);
                  D_e(Ap, {
                    get status() {
                      return x(z);
                    }
                  }), J(wc), Q(Es, wc);
                };
                Fe(
                  Yo,
                  (Es) => {
                    x(z) != null && Es(yo);
                  },
                  !0
                );
              }
              Q($r, Qn);
            };
            Fe(wi, ($r) => {
              x(P) != null ? $r(ua) : $r(ml, !1);
            });
          }
          J(ln), Q(Ut, ln);
        };
        Fe(Et, (Ut) => {
          x(N) && Ut(Ar);
        });
      }
      J(tt), Q(_e, tt);
    }, Xe = (_e) => {
      var tt = L_e();
      Q(_e, tt);
    };
    Fe(ve, (_e) => {
      _ ? _e(Ge) : _e(Xe, !1);
    });
  }
  J(we);
  var et = le(we, 2), Qe = Y(et);
  g_e(Qe, {
    get coordinator() {
      return e.coordinator;
    },
    get filter() {
      return p;
    },
    get table() {
      return e.data.table;
    }
  });
  var Wt = le(Qe, 2), At = Y(Wt);
  At.__click = U, J(Wt), J(et);
  var Xt = le(et, 2), Nt = Y(Xt);
  oz(Nt, {
    get icon() {
      return LI;
    },
    title: "Options",
    children: (_e, tt) => {
      var Ft = q_e(), mr = Y(Ft);
      {
        var Tt = ($r) => {
          var Qn = z_e(), Yo = le(He(Qn), 2);
          p_e(Yo, {
            get columns() {
              return x(b);
            },
            get styles() {
              return n();
            },
            onStylesChange: (yo) => {
              ae(k, yo);
            }
          }), Q($r, Qn);
        };
        Fe(mr, ($r) => {
          x(b).length > 0 && $r(Tt);
        });
      }
      var Et = le(mr, 4), Ar = Y(Et);
      {
        var Ut = ($r) => {
          var Qn = j_e(), Yo = Y(Qn);
          CF(Yo, {
            get icon() {
              return f9;
            },
            label: "Export Selection",
            title: "Export the selected points",
            class: "w-48",
            onClick: () => e.onExportSelection(g(), x(d))
          });
          var yo = le(Yo, 2);
          Oh(yo, {
            label: "Format",
            get value() {
              return x(d);
            },
            onChange: (Es) => ae(d, Es, !0),
            options: [
              { value: "parquet", label: "Parquet" },
              { value: "jsonl", label: "JSONL" },
              { value: "json", label: "JSON" },
              { value: "csv", label: "CSV" }
            ]
          }), J(Qn), Q($r, Qn);
        };
        Fe(Ar, ($r) => {
          e.onExportSelection && $r(Ut);
        });
      }
      var ln = le(Ar, 2);
      {
        var wi = ($r) => {
          CF($r, {
            get icon() {
              return f9;
            },
            label: "Export Application",
            title: "Download a self-contained static web application",
            class: "w-48",
            get onClick() {
              return e.onExportApplication;
            }
          });
        };
        Fe(ln, ($r) => {
          e.onExportApplication && $r(wi);
        });
      }
      J(Et);
      var ua = le(Et, 4), ml = Y(ua);
      J(ua), J(Ft), Ee(() => at(ml, `Embedding Atlas, ${_F}`)), Q(_e, Ft);
    },
    $$slots: { default: !0 }
  });
  var Ve = le(Nt, 2);
  {
    var Ze = (_e) => {
      {
        let tt = /* @__PURE__ */ K(() => r() == "dark" ? Qpe : Kpe);
        Mu(_e, {
          get icon() {
            return x(tt);
          },
          title: "Toggle dark mode",
          onClick: () => {
            kD(c, r() == "light" ? "dark" : "light");
          }
        });
      }
    };
    Fe(Ve, (_e) => {
      e.colorScheme == null && _e(Ze);
    });
  }
  var Bt = le(Ve, 2);
  bme(Bt, {
    get context() {
      return re;
    },
    get charts() {
      return x(ne);
    },
    get chartStates() {
      return x(se);
    },
    get layout() {
      return x(ie);
    },
    get layoutStates() {
      return x(ce);
    },
    onChartsChange: (_e) => ae(ne, _e),
    onChartStatesChange: (_e) => ae(se, _e),
    onLayoutStatesChange: (_e) => ae(ce, _e)
  }), J(Xt), J(he);
  var Qt = le(he, 2), Sr = Y(Qt);
  {
    var pt = (_e) => {
      c_e(_e, {
        get context() {
          return re;
        },
        get layout() {
          return x(ie);
        },
        get layoutStates() {
          return x(ce);
        },
        get charts() {
          return x(ne);
        },
        get chartStates() {
          return x(se);
        },
        onChartsChange: (tt) => ae(ne, tt),
        onChartStatesChange: (tt) => ae(se, tt),
        onLayoutStatesChange: (tt) => ae(ce, tt)
      });
    };
    Fe(Sr, (_e) => {
      x(h) && _e(pt);
    });
  }
  J(Qt), J(Me), J(Ce), Ee(() => {
    Pe = en(Me, 1, "w-full h-full flex flex-col text-slate-800 bg-slate-200 dark:text-slate-200 dark:bg-slate-800", null, Pe, { dark: r() == "dark" }), Ae = ct(Me, "", Ae, { "color-scheme": r() });
  }), Q(t, Ce), it(), o();
}
nn(["click"]);
const V_e = `@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-ease:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-400:oklch(70.4% .191 22.216);--color-red-600:oklch(57.7% .245 27.325);--color-orange-500:oklch(70.5% .213 47.604);--color-orange-700:oklch(55.3% .195 38.402);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-800:oklch(42.4% .199 265.638);--color-blue-900:oklch(37.9% .146 265.522);--color-blue-950:oklch(28.2% .091 267.935);--color-slate-50:oklch(98.4% .003 247.858);--color-slate-100:oklch(96.8% .007 247.896);--color-slate-200:oklch(92.9% .013 255.508);--color-slate-300:oklch(86.9% .022 252.894);--color-slate-400:oklch(70.4% .04 256.788);--color-slate-500:oklch(55.4% .046 257.417);--color-slate-600:oklch(44.6% .043 257.281);--color-slate-700:oklch(37.2% .044 257.287);--color-slate-800:oklch(27.9% .041 260.031);--color-slate-900:oklch(20.8% .042 265.755);--color-slate-950:oklch(12.9% .042 264.695);--color-gray-200:oklch(92.8% .006 264.531);--color-gray-300:oklch(87.2% .01 258.338);--color-gray-400:oklch(70.7% .022 261.325);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-black:#000;--color-white:#fff;--spacing:.25rem;--font-weight-normal:400;--font-weight-medium:500;--ease-in-out:cubic-bezier(.4,0,.2,1);--blur-sm:8px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root,:host{overscroll-behavior:none;--tw-border-style:solid;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;font-size:13px}}@layer components;@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.sticky{position:sticky}.top-0{top:calc(var(--spacing)*0)}.top-\\[32px\\]{top:32px}.right-0{right:calc(var(--spacing)*0)}.bottom-0{bottom:calc(var(--spacing)*0)}.left-0{left:calc(var(--spacing)*0)}.left-1{left:3.25px}.isolate{isolation:isolate}.z-10{z-index:10}.z-20{z-index:20}.order-1{order:1}.order-3{order:3}.container{width:100%}@media(min-width:520px){.container{max-width:520px}}@media(min-width:624px){.container{max-width:624px}}@media(min-width:832px){.container{max-width:832px}}@media(min-width:1040px){.container{max-width:1040px}}@media(min-width:1248px){.container{max-width:1248px}}.container\\!{width:100%!important}@media(min-width:520px){.container\\!{max-width:520px!important}}@media(min-width:624px){.container\\!{max-width:624px!important}}@media(min-width:832px){.container\\!{max-width:832px!important}}@media(min-width:1040px){.container\\!{max-width:1040px!important}}@media(min-width:1248px){.container\\!{max-width:1248px!important}}.-m-2{margin:-6.5px}.m-1{margin:3.25px}.m-2{margin:6.5px}.mx-1{margin-inline:3.25px}.mx-2{margin-inline:6.5px}.my-0{margin-block:calc(var(--spacing)*0)}.my-1{margin-block:3.25px}.my-2{margin-block:6.5px}.mt-1{margin-top:3.25px}.mt-2{margin-top:6.5px}.mt-4{margin-top:13px}.mr-1{margin-right:3.25px}.mr-2{margin-right:6.5px}.mb-1{margin-bottom:3.25px}.mb-2{margin-bottom:6.5px}.ml-2{margin-left:6.5px}.ml-3{margin-left:9.75px}.form-input{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-input:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-input::placeholder{color:#6a7282;opacity:1}.form-input::-webkit-datetime-edit-fields-wrapper{padding:0}.form-input::-webkit-date-and-time-value{min-height:1.5em}.form-input::-webkit-date-and-time-value{text-align:inherit}.form-input::-webkit-datetime-edit{display:inline-flex}.form-input::-webkit-datetime-edit{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-year-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-month-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-day-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-hour-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-minute-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-second-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-millisecond-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-meridiem-field{padding-top:0;padding-bottom:0}.line-clamp-4{-webkit-line-clamp:4;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.block{display:block}.contents{display:contents}.contents\\!{display:contents!important}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.list-item{display:list-item}.table{display:table}.size-fit{width:fit-content;height:fit-content}.\\!h-32{height:104px!important}.h-2{height:6.5px}.h-3{height:9.75px}.h-4{height:13px}.h-5{height:16.25px}.h-8{height:26px}.h-12{height:39px}.h-64{height:208px}.h-96{height:312px}.h-\\[28px\\]{height:28px}.h-full{height:100%}.max-h-24{max-height:78px}.max-h-60{max-height:195px}.min-h-0{min-height:calc(var(--spacing)*0)}.w-0{width:calc(var(--spacing)*0)}.w-2{width:6.5px}.w-3{width:9.75px}.w-4{width:13px}.w-5{width:16.25px}.w-7{width:22.75px}.w-12{width:39px}.w-24{width:78px}.w-40{width:130px}.w-48{width:156px}.w-64{width:208px}.w-72{width:234px}.w-96{width:312px}.w-\\[4rem\\]{width:4rem}.w-\\[40rem\\]{width:40rem}.w-\\[420px\\]{width:420px}.w-full{width:100%}.max-w-24{max-width:78px}.max-w-32{max-width:104px}.max-w-64{max-width:208px}.max-w-72{max-width:234px}.max-w-80{max-width:260px}.max-w-\\[400px\\]{max-width:400px}.min-w-\\[180px\\]{min-width:180px}.min-w-\\[420px\\]{min-width:420px}.flex-1{flex:1}.flex-none{flex:none}.flex-shrink{flex-shrink:1}.grow{flex-grow:1}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.transform\\!{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)!important}.cursor-col-resize{cursor:col-resize}.cursor-row-resize{cursor:row-resize}.resize{resize:both}.resize\\!{resize:both!important}.form-select{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-select:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-select{print-color-adjust:exact;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='oklch(55.1%25 0.027 264.364)' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");background-position:right .5rem center;background-repeat:no-repeat;background-size:1.5em 1.5em;padding-right:2.5rem}.form-select:where([size]:not([size="1"])){background-image:initial;background-position:initial;background-repeat:unset;background-size:initial;print-color-adjust:unset;padding-right:.75rem}.form-textarea{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-textarea:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-textarea::placeholder{color:#6a7282;opacity:1}.flex-col{flex-direction:column}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.place-content-center{place-content:center}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-0\\.5{gap:1.625px}.gap-1{gap:3.25px}.gap-2{gap:6.5px}.gap-4{gap:13px}.gap-\\[1px\\]{gap:1px}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(6.5px*var(--tw-space-y-reverse));margin-block-end:calc(6.5px*calc(1 - var(--tw-space-y-reverse)))}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-scroll{overflow-y:scroll}.rounded{border-radius:3.25px}.rounded-full{border-radius:3.40282e38px}.rounded-md{border-radius:4.875px}.rounded-sm{border-radius:1.625px}.rounded-ss-md{border-start-start-radius:4.875px}.rounded-ee-md{border-end-end-radius:4.875px}.border{border-style:var(--tw-border-style);border-width:1px}.border-0{border-style:var(--tw-border-style);border-width:0}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-dotted{--tw-border-style:dotted;border-style:dotted}.\\!border-blue-400{border-color:var(--color-blue-400)!important}.\\!border-slate-600{border-color:var(--color-slate-600)!important}.border-slate-200{border-color:var(--color-slate-200)}.border-slate-300{border-color:var(--color-slate-300)}.border-slate-400{border-color:var(--color-slate-400)}.border-slate-500{border-color:var(--color-slate-500)}.\\!bg-blue-100{background-color:var(--color-blue-100)!important}.\\!bg-slate-100{background-color:var(--color-slate-100)!important}.\\!bg-slate-500{background-color:var(--color-slate-500)!important}.bg-blue-100{background-color:var(--color-blue-100)}.bg-blue-200{background-color:var(--color-blue-200)}.bg-blue-500{background-color:var(--color-blue-500)}.bg-gray-300{background-color:var(--color-gray-300)}.bg-slate-50{background-color:var(--color-slate-50)}.bg-slate-100{background-color:var(--color-slate-100)}.bg-slate-100\\/25{background-color:#f1f5f940}@supports (color:color-mix(in lab,red,red)){.bg-slate-100\\/25{background-color:color-mix(in oklab,var(--color-slate-100)25%,transparent)}}.bg-slate-100\\/75{background-color:#f1f5f9bf}@supports (color:color-mix(in lab,red,red)){.bg-slate-100\\/75{background-color:color-mix(in oklab,var(--color-slate-100)75%,transparent)}}.bg-slate-200{background-color:var(--color-slate-200)}.bg-slate-400{background-color:var(--color-slate-400)}.bg-slate-500{background-color:var(--color-slate-500)}.bg-slate-600{background-color:var(--color-slate-600)}.bg-slate-900{background-color:var(--color-slate-900)}.bg-slate-950{background-color:var(--color-slate-950)}.bg-white{background-color:var(--color-white)}.bg-white\\/75{background-color:#ffffffbf}@supports (color:color-mix(in lab,red,red)){.bg-white\\/75{background-color:color-mix(in oklab,var(--color-white)75%,transparent)}}.fill-orange-500{fill:var(--color-orange-500)}.stroke-orange-500{stroke:var(--color-orange-500)}.stroke-orange-700{stroke:var(--color-orange-700)}.stroke-2{stroke-width:2px}.p-1{padding:3.25px}.p-2{padding:6.5px}.p-4{padding:13px}.px-1{padding-inline:3.25px}.px-1\\.5{padding-inline:4.875px}.px-2{padding-inline:6.5px}.px-2\\.5{padding-inline:8.125px}.px-3{padding-inline:9.75px}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\\.5{padding-block:1.625px}.py-1{padding-block:3.25px}.py-1\\.5{padding-block:4.875px}.py-2{padding-block:6.5px}.py-3{padding-block:9.75px}.py-20{padding-block:65px}.pt-2{padding-top:6.5px}.pr-0\\.5{padding-right:1.625px}.pr-1{padding-right:3.25px}.pr-2{padding-right:6.5px}.pr-\\[16px\\]{padding-right:16px}.pb-1{padding-bottom:3.25px}.pb-2{padding-bottom:6.5px}.pb-4{padding-bottom:13px}.pl-2{padding-left:6.5px}.pl-40{padding-left:130px}.pl-\\[4px\\]{padding-left:4px}.text-center{text-align:center}.text-left{text-align:left}.text-right{text-align:right}.font-mono{font-family:var(--font-mono)}.text-sm{font-size:11.375px;line-height:var(--tw-leading,16.25px)}.text-sm\\!{font-size:11.375px!important;line-height:var(--tw-leading,16.25px)!important}.text-xs{font-size:9.75px;line-height:var(--tw-leading,13px)}.leading-5{--tw-leading:16.25px;line-height:16.25px}.leading-7{--tw-leading:22.75px;line-height:22.75px}.leading-10{--tw-leading:32.5px;line-height:32.5px}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.text-nowrap{text-wrap:nowrap}.break-all{word-break:break-all}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.\\!text-gray-200{color:var(--color-gray-200)!important}.\\!text-slate-100{color:var(--color-slate-100)!important}.text-blue-500{color:var(--color-blue-500)}.text-gray-400{color:var(--color-gray-400)}.text-red-400{color:var(--color-red-400)}.text-red-600{color:var(--color-red-600)}.text-slate-300{color:var(--color-slate-300)}.text-slate-400{color:var(--color-slate-400)}.text-slate-500{color:var(--color-slate-500)}.text-slate-600{color:var(--color-slate-600)}.text-slate-700{color:var(--color-slate-700)}.text-slate-800{color:var(--color-slate-800)}.text-white{color:var(--color-white)}.capitalize{text-transform:capitalize}.italic{font-style:italic}.ordinal{--tw-ordinal:ordinal;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.tabular-nums{--tw-numeric-spacing:tabular-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.line-through{text-decoration-line:line-through}.underline{text-decoration-line:underline}.opacity-20{opacity:.2}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.-outline-offset-1{outline-offset:-1px}.outline-blue-600{outline-color:var(--color-blue-600)}.outline-slate-500{outline-color:var(--color-slate-500)}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.invert{--tw-invert:invert(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter\\!{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)!important}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.select-none{-webkit-user-select:none;user-select:none}@media(hover:hover){.group-hover\\:bg-blue-600:is(:where(.group):hover *){background-color:var(--color-blue-600)}.group-hover\\:opacity-100:is(:where(.group):hover *){opacity:1}}.first\\:rounded-tl-md:first-child{border-top-left-radius:4.875px}.first\\:rounded-bl-md:first-child{border-bottom-left-radius:4.875px}.last\\:rounded-tr-md:last-child{border-top-right-radius:4.875px}.last\\:rounded-br-md:last-child{border-bottom-right-radius:4.875px}@media(hover:hover){.hover\\:bg-slate-200:hover{background-color:var(--color-slate-200)}.hover\\:text-slate-500:hover{color:var(--color-slate-500)}.hover\\:text-slate-800:hover{color:var(--color-slate-800)}.hover\\:text-slate-900:hover{color:var(--color-slate-900)}.hover\\:outline:hover{outline-style:var(--tw-outline-style);outline-width:1px}}.focus-visible\\:outline-2:focus-visible{outline-style:var(--tw-outline-style);outline-width:2px}@media(min-width:520px){.sm\\:opacity-0{opacity:0}}.dark\\:\\!border-blue-600:where(.dark,.dark *){border-color:var(--color-blue-600)!important}.dark\\:\\!border-slate-400:where(.dark,.dark *){border-color:var(--color-slate-400)!important}.dark\\:border-slate-500:where(.dark,.dark *){border-color:var(--color-slate-500)}.dark\\:border-slate-600:where(.dark,.dark *){border-color:var(--color-slate-600)}.dark\\:border-slate-700:where(.dark,.dark *){border-color:var(--color-slate-700)}.dark\\:\\!bg-blue-800:where(.dark,.dark *){background-color:var(--color-blue-800)!important}.dark\\:\\!bg-slate-700:where(.dark,.dark *){background-color:var(--color-slate-700)!important}.dark\\:bg-black:where(.dark,.dark *){background-color:var(--color-black)}.dark\\:bg-black\\/75:where(.dark,.dark *){background-color:#000000bf}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-black\\/75:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-black)75%,transparent)}}.dark\\:bg-gray-700:where(.dark,.dark *){background-color:var(--color-gray-700)}.dark\\:bg-slate-500:where(.dark,.dark *){background-color:var(--color-slate-500)}.dark\\:bg-slate-600:where(.dark,.dark *){background-color:var(--color-slate-600)}.dark\\:bg-slate-700:where(.dark,.dark *){background-color:var(--color-slate-700)}.dark\\:bg-slate-700\\/25:where(.dark,.dark *){background-color:#31415840}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-slate-700\\/25:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-slate-700)25%,transparent)}}.dark\\:bg-slate-800:where(.dark,.dark *){background-color:var(--color-slate-800)}.dark\\:bg-slate-800\\/75:where(.dark,.dark *){background-color:#1d293dbf}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-slate-800\\/75:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-slate-800)75%,transparent)}}.dark\\:bg-slate-900:where(.dark,.dark *){background-color:var(--color-slate-900)}.dark\\:\\!text-gray-600:where(.dark,.dark *){color:var(--color-gray-600)!important}.dark\\:text-gray-400:where(.dark,.dark *){color:var(--color-gray-400)}.dark\\:text-gray-500:where(.dark,.dark *){color:var(--color-gray-500)}.dark\\:text-slate-200:where(.dark,.dark *){color:var(--color-slate-200)}.dark\\:text-slate-300:where(.dark,.dark *){color:var(--color-slate-300)}.dark\\:text-slate-400:where(.dark,.dark *){color:var(--color-slate-400)}.dark\\:text-slate-500:where(.dark,.dark *){color:var(--color-slate-500)}.dark\\:text-slate-600:where(.dark,.dark *){color:var(--color-slate-600)}@media(hover:hover){.dark\\:group-hover\\:bg-blue-400:where(.dark,.dark *):is(:where(.group):hover *){background-color:var(--color-blue-400)}.dark\\:hover\\:bg-slate-700:where(.dark,.dark *):hover{background-color:var(--color-slate-700)}.dark\\:hover\\:text-slate-100:where(.dark,.dark *):hover{color:var(--color-slate-100)}.dark\\:hover\\:text-slate-200:where(.dark,.dark *):hover{color:var(--color-slate-200)}.dark\\:hover\\:text-slate-300:where(.dark,.dark *):hover{color:var(--color-slate-300)}.dark\\:hover\\:text-slate-400:where(.dark,.dark *):hover{color:var(--color-slate-400)}}}.form-input,.form-textarea,.form-select,.form-multiselect{font-size:13px;line-height:19.5px}mark{background-color:#f9ceaf}.markdown-content{line-height:1.2em}.markdown-content a{text-decoration:underline}.markdown-content pre,.markdown-content code{font-family:Menlo,monospace;font-size:11px}.markdown-content pre{margin-bottom:.5em}.markdown-content h1,.markdown-content h2,.markdown-content h3,.markdown-content h4{margin-bottom:.5em;font-weight:700}.markdown-content p{margin-bottom:.5em;list-style:outside}.markdown-content ul{margin-bottom:.5em;margin-left:2em;list-style:outside}.markdown-content ol{margin-bottom:.5em;margin-left:2em;list-style:decimal}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-ordinal{syntax:"*";inherits:false}@property --tw-slashed-zero{syntax:"*";inherits:false}@property --tw-numeric-figure{syntax:"*";inherits:false}@property --tw-numeric-spacing{syntax:"*";inherits:false}@property --tw-numeric-fraction{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}`;
class J_e {
  component;
  container;
  currentProps;
  constructor(e, r) {
    this.currentProps = { ...r }, this.container = document.createElement("div"), this.container.style.display = "flex", this.container.style.width = "100%", this.container.style.height = "100%", e.appendChild(this.container);
    let n = this.container.attachShadow({ mode: "open" }), i = document.createElement("style");
    i.innerText = V_e, n.appendChild(i);
    let o = document.createElement("div");
    o.style.display = "flex", o.style.width = "100%", o.style.height = "100%", n.appendChild(o), this.component = CT({ component: H_e, target: o, props: r });
  }
  update(e) {
    let r = {};
    for (let n in e)
      e[n] !== this.currentProps[n] && (r[n] = e[n], this.currentProps[n] = e[n]);
    this.component.$set(r);
  }
  destroy() {
    this.component.$destroy(), this.container.remove();
  }
}
export {
  F_e as O,
  J_e as g
};
