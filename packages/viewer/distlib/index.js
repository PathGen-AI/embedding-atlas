import { deepMemo as nA, applyUpdatesIfNeeded as dd, applyUpdatesForKeyIfNeeded as Cy, interactionHandler as mr, debounce as yK } from "@embedding-atlas/utils";
import { coordinator as _F, makeClient as ia, isSelection as g_, MosaicClient as Nk, queryFieldInfo as bK, Selection as vK } from "@uwdata/mosaic-core";
import * as R from "@uwdata/mosaic-sql";
import { Query as pd, eq as xK, column as ap, literal as wK, cast as rA, row_number as _K, desc as kK, count as CK, sql as iA } from "@uwdata/mosaic-sql";
import { parseSpec as SK, astToDOM as AK } from "@uwdata/mosaic-spec";
import { createAPIContext as EK } from "@uwdata/vgplot";
const pi = 2, Sv = 4, Av = 8, sa = 16, eu = 32, Nf = 64, Ev = 128, Go = 512, ii = 1024, as = 2048, tu = 4096, js = 8192, zu = 16384, Vg = 32768, Ya = 65536, sA = 1 << 17, kF = 1 << 18, Wd = 1 << 19, CF = 1 << 20, Hp = 32768, m_ = 1 << 21, Bk = 1 << 22, ju = 1 << 23, jl = Symbol("$state"), Lk = Symbol("legacy props"), DK = Symbol(""), Oh = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), Dv = 3, Bf = 8, SF = !1;
var $k = Array.isArray, OK = Array.prototype.indexOf, zk = Array.from, jk = Object.defineProperty, qu = Object.getOwnPropertyDescriptor, AF = Object.getOwnPropertyDescriptors, FK = Object.prototype, TK = Array.prototype, qk = Object.getPrototypeOf, oA = Object.isExtensible;
function Ch(t) {
  return typeof t == "function";
}
const zt = () => {
};
function EF(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function DF() {
  var t, e, n = new Promise((r, i) => {
    t = r, e = i;
  });
  return { promise: n, resolve: t, reject: e };
}
function lA(t, e) {
  if (Array.isArray(t))
    return t;
  if (!(Symbol.iterator in t))
    return Array.from(t);
  const n = [];
  for (const r of t)
    if (n.push(r), n.length === e) break;
  return n;
}
function OF(t) {
  return t === this.v;
}
function Uk(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function FF(t) {
  return !Uk(t, this.v);
}
function TF(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function RK() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function MK(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function PK() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function IK(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function NK() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function BK() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function LK(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function $K() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function zK() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function jK() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function qK() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let UK = !1;
const Ov = 1, Fv = 2, RF = 4, HK = 8, VK = 16, WK = 1, GK = 4, KK = 8, YK = 16, XK = 1, QK = 2, JK = 4, MF = 1, ZK = 2, PF = "[", Tv = "[!", Hk = "]", yf = {}, Vr = Symbol(), eY = "http://www.w3.org/1999/xhtml", tY = "@attach";
let us = null;
function gd(t) {
  us = t;
}
function it(t, e = !1, n) {
  us = {
    p: us,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: null
  };
}
function st(t) {
  var e = (
    /** @type {ComponentContext} */
    us
  ), n = e.e;
  if (n !== null) {
    e.e = null;
    for (var r of n)
      cT(r);
  }
  return t !== void 0 && (e.x = t), e.i = !0, us = e.p, t ?? /** @type {T} */
  {};
}
function IF() {
  return !0;
}
let jc = [];
function NF() {
  var t = jc;
  jc = [], EF(t);
}
function nu(t) {
  if (jc.length === 0 && !kp) {
    var e = jc;
    queueMicrotask(() => {
      e === jc && NF();
    });
  }
  jc.push(t);
}
function nY() {
  for (; jc.length > 0; )
    NF();
}
function Wg(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function rY() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function iY() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Ct = !1;
function Uo(t) {
  Ct = t;
}
let jt;
function ui(t) {
  if (t === null)
    throw Wg(), yf;
  return jt = t;
}
function tc() {
  return ui(
    /** @type {TemplateNode} */
    /* @__PURE__ */ rl(jt)
  );
}
function Q(t) {
  if (Ct) {
    if (/* @__PURE__ */ rl(jt) !== null)
      throw Wg(), yf;
    jt = t;
  }
}
function Vk(t = 1) {
  if (Ct) {
    for (var e = t, n = jt; e--; )
      n = /** @type {TemplateNode} */
      /* @__PURE__ */ rl(n);
    jt = n;
  }
}
function sb(t = !0) {
  for (var e = 0, n = jt; ; ) {
    if (n.nodeType === Bf) {
      var r = (
        /** @type {Comment} */
        n.data
      );
      if (r === Hk) {
        if (e === 0) return n;
        e -= 1;
      } else (r === PF || r === Tv) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ rl(n)
    );
    t && n.remove(), n = i;
  }
}
function BF(t) {
  if (!t || t.nodeType !== Bf)
    throw Wg(), yf;
  return (
    /** @type {Comment} */
    t.data
  );
}
function ho(t) {
  if (typeof t != "object" || t === null || jl in t)
    return t;
  const e = qk(t);
  if (e !== FK && e !== TK)
    return t;
  var n = /* @__PURE__ */ new Map(), r = $k(t), i = /* @__PURE__ */ Ee(0), s = rf, o = (l) => {
    if (rf === s)
      return l();
    var a = Yt, u = rf;
    ts(null), dA(s);
    var c = l();
    return ts(a), dA(u), c;
  };
  return r && n.set("length", /* @__PURE__ */ Ee(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(l, a, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && $K();
        var c = n.get(a);
        return c === void 0 ? c = o(() => {
          var f = /* @__PURE__ */ Ee(u.value);
          return n.set(a, f), f;
        }) : ae(c, u.value, !0), !0;
      },
      deleteProperty(l, a) {
        var u = n.get(a);
        if (u === void 0) {
          if (a in l) {
            const c = o(() => /* @__PURE__ */ Ee(Vr));
            n.set(a, c), Cp(i);
          }
        } else
          ae(u, Vr), Cp(i);
        return !0;
      },
      get(l, a, u) {
        if (a === jl)
          return t;
        var c = n.get(a), f = a in l;
        if (c === void 0 && (!f || qu(l, a)?.writable) && (c = o(() => {
          var p = ho(f ? l[a] : Vr), m = /* @__PURE__ */ Ee(p);
          return m;
        }), n.set(a, c)), c !== void 0) {
          var d = x(c);
          return d === Vr ? void 0 : d;
        }
        return Reflect.get(l, a, u);
      },
      getOwnPropertyDescriptor(l, a) {
        var u = Reflect.getOwnPropertyDescriptor(l, a);
        if (u && "value" in u) {
          var c = n.get(a);
          c && (u.value = x(c));
        } else if (u === void 0) {
          var f = n.get(a), d = f?.v;
          if (f !== void 0 && d !== Vr)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(l, a) {
        if (a === jl)
          return !0;
        var u = n.get(a), c = u !== void 0 && u.v !== Vr || Reflect.has(l, a);
        if (u !== void 0 || Vt !== null && (!c || qu(l, a)?.writable)) {
          u === void 0 && (u = o(() => {
            var d = c ? ho(l[a]) : Vr, p = /* @__PURE__ */ Ee(d);
            return p;
          }), n.set(a, u));
          var f = x(u);
          if (f === Vr)
            return !1;
        }
        return c;
      },
      set(l, a, u, c) {
        var f = n.get(a), d = a in l;
        if (r && a === "length")
          for (var p = u; p < /** @type {Source<number>} */
          f.v; p += 1) {
            var m = n.get(p + "");
            m !== void 0 ? ae(m, Vr) : p in l && (m = o(() => /* @__PURE__ */ Ee(Vr)), n.set(p + "", m));
          }
        if (f === void 0)
          (!d || qu(l, a)?.writable) && (f = o(() => /* @__PURE__ */ Ee(void 0)), ae(f, ho(u)), n.set(a, f));
        else {
          d = f.v !== Vr;
          var y = o(() => ho(u));
          ae(f, y);
        }
        var b = Reflect.getOwnPropertyDescriptor(l, a);
        if (b?.set && b.set.call(c, u), !d) {
          if (r && typeof a == "string") {
            var v = (
              /** @type {Source<number>} */
              n.get("length")
            ), _ = Number(a);
            Number.isInteger(_) && _ >= v.v && ae(v, _ + 1);
          }
          Cp(i);
        }
        return !0;
      },
      ownKeys(l) {
        x(i);
        var a = Reflect.ownKeys(l).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== Vr;
        });
        for (var [u, c] of n)
          c.v !== Vr && !(u in l) && a.push(u);
        return a;
      },
      setPrototypeOf() {
        zK();
      }
    }
  );
}
function aA(t) {
  try {
    if (t !== null && typeof t == "object" && jl in t)
      return t[jl];
  } catch {
  }
  return t;
}
function sY(t, e) {
  return Object.is(aA(t), aA(e));
}
var y_, LF, $F, zF;
function b_() {
  if (y_ === void 0) {
    y_ = window, LF = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, n = Text.prototype;
    $F = qu(e, "firstChild").get, zF = qu(e, "nextSibling").get, oA(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), oA(n) && (n.__t = void 0);
  }
}
function Ws(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function ni(t) {
  return $F.call(t);
}
// @__NO_SIDE_EFFECTS__
function rl(t) {
  return zF.call(t);
}
function J(t, e) {
  if (!Ct)
    return /* @__PURE__ */ ni(t);
  var n = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ ni(jt)
  );
  if (n === null)
    n = jt.appendChild(Ws());
  else if (e && n.nodeType !== Dv) {
    var r = Ws();
    return n?.before(r), ui(r), r;
  }
  return ui(n), n;
}
function We(t, e = !1) {
  if (!Ct) {
    var n = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ ni(
        /** @type {Node} */
        t
      )
    );
    return n instanceof Comment && n.data === "" ? /* @__PURE__ */ rl(n) : n;
  }
  if (e && jt?.nodeType !== Dv) {
    var r = Ws();
    return jt?.before(r), ui(r), r;
  }
  return jt;
}
function ue(t, e = 1, n = !1) {
  let r = Ct ? jt : t;
  for (var i; e--; )
    i = r, r = /** @type {TemplateNode} */
    /* @__PURE__ */ rl(r);
  if (!Ct)
    return r;
  if (n && r?.nodeType !== Dv) {
    var s = Ws();
    return r === null ? i?.after(s) : r.before(s), ui(s), s;
  }
  return ui(r), /** @type {TemplateNode} */
  r;
}
function jF(t) {
  t.textContent = "";
}
function qF() {
  return !1;
}
function UF(t) {
  var e = Vt;
  if (e === null)
    return Yt.f |= ju, t;
  if ((e.f & Vg) === 0) {
    if ((e.f & Ev) === 0)
      throw t;
    e.b.error(t);
  } else
    md(t, e);
}
function md(t, e) {
  for (; e !== null; ) {
    if ((e.f & Ev) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (n) {
        t = n;
      }
    e = e.parent;
  }
  throw t;
}
const v1 = /* @__PURE__ */ new Set();
let $n = null, Sy = null, Ps = null, Cl = [], Rv = null, v_ = !1, kp = !1;
class Tl {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #n = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #r = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #a = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #l = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Cl = [], Sy = null, this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const r of e)
      this.#s(r, n);
    this.is_fork || this.#u(), this.#r > 0 || this.is_fork ? (this.#o(n.effects), this.#o(n.render_effects), this.#o(n.block_effects)) : (Sy = this, $n = null, uA(n.render_effects), uA(n.effects), Sy = null, this.#a?.resolve()), Ps = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #s(e, n) {
    e.f ^= ii;
    for (var r = e.first; r !== null; ) {
      var i = r.f, s = (i & (eu | Nf)) !== 0, o = s && (i & ii) !== 0, l = o || (i & js) !== 0 || this.skipped_effects.has(r);
      if ((r.f & Ev) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !l && r.fn !== null) {
        s ? r.f ^= ii : (i & Sv) !== 0 ? n.effects.push(r) : Gg(r) && ((r.f & sa) !== 0 && n.block_effects.push(r), Wp(r));
        var a = r.first;
        if (a !== null) {
          r = a;
          continue;
        }
      }
      var u = r.parent;
      for (r = r.next; r === null && u !== null; )
        u === n.effect && (this.#o(n.effects), this.#o(n.render_effects), this.#o(n.block_effects), n = /** @type {EffectTarget} */
        n.parent), r = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #o(e) {
    for (const n of e)
      ((n.f & as) !== 0 ? this.#l : this.#i).push(n), ci(n, ii);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, n) {
    this.previous.has(e) || this.previous.set(e, n), (e.f & ju) === 0 && (this.current.set(e, e.v), Ps?.set(e, e.v));
  }
  activate() {
    $n = this, this.apply();
  }
  deactivate() {
    $n = null, Ps = null;
  }
  flush() {
    if (this.activate(), Cl.length > 0) {
      if (VF(), $n !== null && $n !== this)
        return;
    } else this.#n === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#r === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#n === 0 && this.#c();
  }
  #c() {
    if (v1.size > 1) {
      this.previous.clear();
      var e = Ps, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of v1) {
        if (i === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [l, a] of this.current) {
          if (i.current.has(l))
            if (n && a !== i.current.get(l))
              i.current.set(l, a);
            else
              continue;
          s.push(l);
        }
        if (s.length === 0)
          continue;
        const o = [...i.current.keys()].filter((l) => !this.current.has(l));
        if (o.length > 0) {
          const l = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Map();
          for (const u of s)
            WF(u, o, l, a);
          if (Cl.length > 0) {
            $n = i, i.apply();
            for (const u of Cl)
              i.#s(u, r);
            Cl = [], i.deactivate();
          }
        }
      }
      $n = null, Ps = e;
    }
    this.committed = !0, v1.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#n += 1, e && (this.#r += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#n -= 1, e && (this.#r -= 1), this.revive();
  }
  revive() {
    for (const e of this.#l)
      ci(e, as), bf(e);
    for (const e of this.#i)
      ci(e, tu), bf(e);
    this.#l = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#a ??= DF()).promise;
  }
  static ensure() {
    if ($n === null) {
      const e = $n = new Tl();
      v1.add($n), kp || Tl.enqueue(() => {
        $n === e && e.flush();
      });
    }
    return $n;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    nu(e);
  }
  apply() {
  }
}
function HF(t) {
  var e = kp;
  kp = !0;
  try {
    for (var n; ; ) {
      if (nY(), Cl.length === 0 && ($n?.flush(), Cl.length === 0))
        return Rv = null, /** @type {T} */
        n;
      VF();
    }
  } finally {
    kp = e;
  }
}
function VF() {
  var t = nf;
  v_ = !0;
  try {
    var e = 0;
    for (fA(!0); Cl.length > 0; ) {
      var n = Tl.ensure();
      if (e++ > 1e3) {
        var r, i;
        oY();
      }
      n.process(Cl), Uu.clear();
    }
  } finally {
    v_ = !1, fA(t), Rv = null;
  }
}
function oY() {
  try {
    NK();
  } catch (t) {
    md(t, Rv);
  }
}
let Da = null;
function uA(t) {
  var e = t.length;
  if (e !== 0) {
    for (var n = 0; n < e; ) {
      var r = t[n++];
      if ((r.f & (zu | js)) === 0 && Gg(r) && (Da = /* @__PURE__ */ new Set(), Wp(r), r.deps === null && r.first === null && r.nodes_start === null && (r.teardown === null && r.ac === null ? pT(r) : r.fn = null), Da?.size > 0)) {
        Uu.clear();
        for (const i of Da) {
          if ((i.f & (zu | js)) !== 0) continue;
          const s = [i];
          let o = i.parent;
          for (; o !== null; )
            Da.has(o) && (Da.delete(o), s.push(o)), o = o.parent;
          for (let l = s.length - 1; l >= 0; l--) {
            const a = s[l];
            (a.f & (zu | js)) === 0 && Wp(a);
          }
        }
        Da.clear();
      }
    }
    Da = null;
  }
}
function WF(t, e, n, r) {
  if (!n.has(t) && (n.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const s = i.f;
      (s & pi) !== 0 ? WF(
        /** @type {Derived} */
        i,
        e,
        n,
        r
      ) : (s & (Bk | sa)) !== 0 && (s & as) === 0 && // we may have scheduled this one already
      GF(i, e, r) && (ci(i, as), bf(
        /** @type {Effect} */
        i
      ));
    }
}
function GF(t, e, n) {
  const r = n.get(t);
  if (r !== void 0) return r;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & pi) !== 0 && GF(
        /** @type {Derived} */
        i,
        e,
        n
      ))
        return n.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return n.set(t, !1), !1;
}
function bf(t) {
  for (var e = Rv = t; e.parent !== null; ) {
    e = e.parent;
    var n = e.f;
    if (v_ && e === Vt && (n & sa) !== 0 && (n & kF) === 0)
      return;
    if ((n & (Nf | eu)) !== 0) {
      if ((n & ii) === 0) return;
      e.f ^= ii;
    }
  }
  Cl.push(e);
}
function lY(t) {
  let e = 0, n = vf(0), r;
  return () => {
    Pv() && (x(n), Nv(() => (e === 0 && (r = Gs(() => t(() => Cp(n)))), e += 1, () => {
      nu(() => {
        e -= 1, e === 0 && (r?.(), r = void 0, Cp(n));
      });
    })));
  };
}
var aY = Ya | Wd | Ev;
function KF(t, e, n) {
  new uY(t, e, n);
}
class uY {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #n = Ct ? jt : null;
  /** @type {BoundaryProps} */
  #r;
  /** @type {((anchor: Node) => void)} */
  #a;
  /** @type {Effect} */
  #l;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #f = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #h = null;
  #y = lY(() => (this.#h = vf(this.#d), () => {
    this.#h = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, n, r) {
    this.#t = e, this.#r = n, this.#a = r, this.parent = /** @type {Effect} */
    Vt.b, this.#e = !!this.#r.pending, this.#l = dc(() => {
      if (Vt.b = this, Ct) {
        const s = this.#n;
        tc(), /** @type {Comment} */
        s.nodeType === Bf && /** @type {Comment} */
        s.data === Tv ? this.#v() : this.#b();
      } else {
        var i = this.#x();
        try {
          this.#i = Ki(() => r(i));
        } catch (s) {
          this.error(s);
        }
        this.#f > 0 ? this.#m() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, aY), Ct && (this.#t = jt);
  }
  #b() {
    try {
      this.#i = Ki(() => this.#a(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #v() {
    const e = this.#r.pending;
    e && (this.#s = Ki(() => e(this.#t)), Tl.enqueue(() => {
      var n = this.#x();
      this.#i = this.#g(() => (Tl.ensure(), Ki(() => this.#a(n)))), this.#f > 0 ? this.#m() : (jh(
        /** @type {Effect} */
        this.#s,
        () => {
          this.#s = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = Ws(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #g(e) {
    var n = Vt, r = Yt, i = us;
    Yl(this.#l), ts(this.#l), gd(this.#l.ctx);
    try {
      return e();
    } catch (s) {
      return UF(s), null;
    } finally {
      Yl(n), ts(r), gd(i);
    }
  }
  #m() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#r.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), yT(this.#i, this.#u)), this.#s === null && (this.#s = Ki(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#f += e, this.#f === 0 && (this.#e = !1, this.#s && jh(this.#s, () => {
      this.#s = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#h && yd(this.#h, this.#d);
  }
  get_effect_pending() {
    return this.#y(), x(
      /** @type {Source<number>} */
      this.#h
    );
  }
  /** @param {unknown} error */
  error(e) {
    var n = this.#r.onerror;
    let r = this.#r.failed;
    if (this.#p || !n && !r)
      throw e;
    this.#i && ($r(this.#i), this.#i = null), this.#s && ($r(this.#s), this.#s = null), this.#o && ($r(this.#o), this.#o = null), Ct && (ui(
      /** @type {TemplateNode} */
      this.#n
    ), Vk(), ui(sb()));
    var i = !1, s = !1;
    const o = () => {
      if (i) {
        iY();
        return;
      }
      i = !0, s && qK(), Tl.ensure(), this.#d = 0, this.#o !== null && jh(this.#o, () => {
        this.#o = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#g(() => (this.#p = !1, Ki(() => this.#a(this.#t)))), this.#f > 0 ? this.#m() : this.#e = !1;
    };
    var l = Yt;
    try {
      ts(null), s = !0, n?.(e, o), s = !1;
    } catch (a) {
      md(a, this.#l && this.#l.parent);
    } finally {
      ts(l);
    }
    r && nu(() => {
      this.#o = this.#g(() => {
        Tl.ensure(), this.#p = !0;
        try {
          return Ki(() => {
            r(
              this.#t,
              () => e,
              () => o
            );
          });
        } catch (a) {
          return md(
            a,
            /** @type {Effect} */
            this.#l.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function YF(t, e, n, r) {
  const i = Mv;
  if (n.length === 0 && t.length === 0) {
    r(e.map(i));
    return;
  }
  var s = $n, o = (
    /** @type {Effect} */
    Vt
  ), l = cY();
  function a() {
    Promise.all(n.map((u) => /* @__PURE__ */ fY(u))).then((u) => {
      l();
      try {
        r([...e.map(i), ...u]);
      } catch (c) {
        (o.f & zu) === 0 && md(c, o);
      }
      s?.deactivate(), ob();
    }).catch((u) => {
      md(u, o);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    l();
    try {
      return a();
    } finally {
      s?.deactivate(), ob();
    }
  }) : a();
}
function cY() {
  var t = Vt, e = Yt, n = us, r = $n;
  return function(s = !0) {
    Yl(t), ts(e), gd(n), s && r?.activate();
  };
}
function ob() {
  Yl(null), ts(null), gd(null);
}
// @__NO_SIDE_EFFECTS__
function Mv(t) {
  var e = pi | as, n = Yt !== null && (Yt.f & pi) !== 0 ? (
    /** @type {Derived} */
    Yt
  ) : null;
  return Vt !== null && (Vt.f |= Wd), {
    ctx: us,
    deps: null,
    effects: null,
    equals: OF,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      Vr
    ),
    wv: 0,
    parent: n ?? Vt,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function fY(t, e) {
  let n = (
    /** @type {Effect | null} */
    Vt
  );
  n === null && RK();
  var r = (
    /** @type {Boundary} */
    n.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), s = vf(
    /** @type {V} */
    Vr
  ), o = !Yt, l = /* @__PURE__ */ new Map();
  return kY(() => {
    var a = DF();
    i = a.promise;
    try {
      Promise.resolve(t()).then(a.resolve, a.reject).then(() => {
        u === $n && u.committed && u.deactivate(), ob();
      });
    } catch (d) {
      a.reject(d), ob();
    }
    var u = (
      /** @type {Batch} */
      $n
    );
    if (o) {
      var c = !r.is_pending();
      r.update_pending_count(1), u.increment(c), l.get(u)?.reject(Oh), l.delete(u), l.set(u, a);
    }
    const f = (d, p = void 0) => {
      if (u.activate(), p)
        p !== Oh && (s.f |= ju, yd(s, p));
      else {
        (s.f & ju) !== 0 && (s.f ^= ju), yd(s, d);
        for (const [m, y] of l) {
          if (l.delete(m), m === u) break;
          y.reject(Oh);
        }
      }
      o && (r.update_pending_count(-1), u.decrement(c));
    };
    a.promise.then(f, (d) => f(null, d || "unknown"));
  }), Iv(() => {
    for (const a of l.values())
      a.reject(Oh);
  }), new Promise((a) => {
    function u(c) {
      function f() {
        c === i ? a(s) : u(i);
      }
      c.then(f, f);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function K(t) {
  const e = /* @__PURE__ */ Mv(t);
  return nT(e), e;
}
// @__NO_SIDE_EFFECTS__
function XF(t) {
  const e = /* @__PURE__ */ Mv(t);
  return e.equals = FF, e;
}
function QF(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var n = 0; n < e.length; n += 1)
      $r(
        /** @type {Effect} */
        e[n]
      );
  }
}
function hY(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & pi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function Wk(t) {
  var e, n = Vt;
  Yl(hY(t));
  try {
    t.f &= ~Hp, QF(t), e = oT(t);
  } finally {
    Yl(n);
  }
  return e;
}
function JF(t) {
  var e = Wk(t);
  if (t.equals(e) || (t.v = e, t.wv = iT()), !Lf)
    if (Ps !== null)
      Pv() && Ps.set(t, t.v);
    else {
      var n = (t.f & Go) === 0 ? tu : ii;
      ci(t, n);
    }
}
let x_ = /* @__PURE__ */ new Set();
const Uu = /* @__PURE__ */ new Map();
let ZF = !1;
function vf(t, e) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: OF,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function Ee(t, e) {
  const n = vf(t);
  return nT(n), n;
}
// @__NO_SIDE_EFFECTS__
function Gk(t, e = !1, n = !0) {
  const r = vf(t);
  return e || (r.equals = FF), r;
}
function ae(t, e, n = !1) {
  Yt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Rl || (Yt.f & sA) !== 0) && IF() && (Yt.f & (pi | sa | Bk | sA)) !== 0 && !Ua?.includes(t) && jK();
  let r = n ? ho(e) : e;
  return yd(t, r);
}
function yd(t, e) {
  if (!t.equals(e)) {
    var n = t.v;
    Lf ? Uu.set(t, e) : Uu.set(t, n), t.v = e;
    var r = Tl.ensure();
    r.capture(t, n), (t.f & pi) !== 0 && ((t.f & as) !== 0 && Wk(
      /** @type {Derived} */
      t
    ), ci(t, (t.f & Go) !== 0 ? ii : tu)), t.wv = iT(), eT(t, as), Vt !== null && (Vt.f & ii) !== 0 && (Vt.f & (eu | Nf)) === 0 && (lo === null ? mY([t]) : lo.push(t)), !r.is_fork && x_.size > 0 && !ZF && dY();
  }
  return e;
}
function dY() {
  ZF = !1;
  const t = Array.from(x_);
  for (const e of t)
    (e.f & ii) !== 0 && ci(e, tu), Gg(e) && Wp(e);
  x_.clear();
}
function Cp(t) {
  ae(t, t.v + 1);
}
function eT(t, e) {
  var n = t.reactions;
  if (n !== null)
    for (var r = n.length, i = 0; i < r; i++) {
      var s = n[i], o = s.f, l = (o & as) === 0;
      if (l && ci(s, e), (o & pi) !== 0) {
        var a = (
          /** @type {Derived} */
          s
        );
        Ps?.delete(a), (o & Hp) === 0 && (o & Go && (s.f |= Hp), eT(a, tu));
      } else l && ((o & sa) !== 0 && Da !== null && Da.add(
        /** @type {Effect} */
        s
      ), bf(
        /** @type {Effect} */
        s
      ));
    }
}
function pY(t, e) {
  if (e) {
    const n = document.body;
    t.autofocus = !0, nu(() => {
      document.activeElement === n && t.focus();
    });
  }
}
let cA = !1;
function tT() {
  cA || (cA = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function Gd(t) {
  var e = Yt, n = Vt;
  ts(null), Yl(null);
  try {
    return t();
  } finally {
    ts(e), Yl(n);
  }
}
function gY(t, e, n, r = n) {
  t.addEventListener(e, () => Gd(n));
  const i = t.__on_r;
  i ? t.__on_r = () => {
    i(), r(!0);
  } : t.__on_r = () => r(!0), tT();
}
let nf = !1;
function fA(t) {
  nf = t;
}
let Lf = !1;
function hA(t) {
  Lf = t;
}
let Yt = null, Rl = !1;
function ts(t) {
  Yt = t;
}
let Vt = null;
function Yl(t) {
  Vt = t;
}
let Ua = null;
function nT(t) {
  Yt !== null && (Ua === null ? Ua = [t] : Ua.push(t));
}
let Si = null, Ds = 0, lo = null;
function mY(t) {
  lo = t;
}
let rT = 1, Vp = 0, rf = Vp;
function dA(t) {
  rf = t;
}
function iT() {
  return ++rT;
}
function Gg(t) {
  var e = t.f;
  if ((e & as) !== 0)
    return !0;
  if (e & pi && (t.f &= ~Hp), (e & tu) !== 0) {
    var n = t.deps;
    if (n !== null)
      for (var r = n.length, i = 0; i < r; i++) {
        var s = n[i];
        if (Gg(
          /** @type {Derived} */
          s
        ) && JF(
          /** @type {Derived} */
          s
        ), s.wv > t.wv)
          return !0;
      }
    (e & Go) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Ps === null && ci(t, ii);
  }
  return !1;
}
function sT(t, e, n = !0) {
  var r = t.reactions;
  if (r !== null && !Ua?.includes(t))
    for (var i = 0; i < r.length; i++) {
      var s = r[i];
      (s.f & pi) !== 0 ? sT(
        /** @type {Derived} */
        s,
        e,
        !1
      ) : e === s && (n ? ci(s, as) : (s.f & ii) !== 0 && ci(s, tu), bf(
        /** @type {Effect} */
        s
      ));
    }
}
function oT(t) {
  var e = Si, n = Ds, r = lo, i = Yt, s = Ua, o = us, l = Rl, a = rf, u = t.f;
  Si = /** @type {null | Value[]} */
  null, Ds = 0, lo = null, Yt = (u & (eu | Nf)) === 0 ? t : null, Ua = null, gd(t.ctx), Rl = !1, rf = ++Vp, t.ac !== null && (Gd(() => {
    t.ac.abort(Oh);
  }), t.ac = null);
  try {
    t.f |= m_;
    var c = (
      /** @type {Function} */
      t.fn
    ), f = c(), d = t.deps;
    if (Si !== null) {
      var p;
      if (lb(t, Ds), d !== null && Ds > 0)
        for (d.length = Ds + Si.length, p = 0; p < Si.length; p++)
          d[Ds + p] = Si[p];
      else
        t.deps = d = Si;
      if (nf && Pv() && (t.f & Go) !== 0)
        for (p = Ds; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Ds < d.length && (lb(t, Ds), d.length = Ds);
    if (IF() && lo !== null && !Rl && d !== null && (t.f & (pi | tu | as)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      lo.length; p++)
        sT(
          lo[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (Vp++, lo !== null && (r === null ? r = lo : r.push(.../** @type {Source[]} */
    lo))), (t.f & ju) !== 0 && (t.f ^= ju), f;
  } catch (m) {
    return UF(m);
  } finally {
    t.f ^= m_, Si = e, Ds = n, lo = r, Yt = i, Ua = s, gd(o), Rl = l, rf = a;
  }
}
function yY(t, e) {
  let n = e.reactions;
  if (n !== null) {
    var r = OK.call(n, t);
    if (r !== -1) {
      var i = n.length - 1;
      i === 0 ? n = e.reactions = null : (n[r] = n[i], n.pop());
    }
  }
  n === null && (e.f & pi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Si === null || !Si.includes(e)) && (ci(e, tu), (e.f & Go) !== 0 && (e.f ^= Go, e.f &= ~Hp), QF(
    /** @type {Derived} **/
    e
  ), lb(
    /** @type {Derived} **/
    e,
    0
  ));
}
function lb(t, e) {
  var n = t.deps;
  if (n !== null)
    for (var r = e; r < n.length; r++)
      yY(t, n[r]);
}
function Wp(t) {
  var e = t.f;
  if ((e & zu) === 0) {
    ci(t, ii);
    var n = Vt, r = nf;
    Vt = t, nf = !0;
    try {
      (e & sa) !== 0 ? CY(t) : hT(t), fT(t);
      var i = oT(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = rT;
      var s;
      SF && UK && (t.f & as) !== 0 && t.deps;
    } finally {
      nf = r, Vt = n;
    }
  }
}
async function bY() {
  await Promise.resolve(), HF();
}
function x(t) {
  var e = t.f, n = (e & pi) !== 0;
  if (Yt !== null && !Rl) {
    var r = Vt !== null && (Vt.f & zu) !== 0;
    if (!r && !Ua?.includes(t)) {
      var i = Yt.deps;
      if ((Yt.f & m_) !== 0)
        t.rv < Vp && (t.rv = Vp, Si === null && i !== null && i[Ds] === t ? Ds++ : Si === null ? Si = [t] : Si.includes(t) || Si.push(t));
      else {
        (Yt.deps ??= []).push(t);
        var s = t.reactions;
        s === null ? t.reactions = [Yt] : s.includes(Yt) || s.push(Yt);
      }
    }
  }
  if (Lf) {
    if (Uu.has(t))
      return Uu.get(t);
    if (n) {
      var o = (
        /** @type {Derived} */
        t
      ), l = o.v;
      return ((o.f & ii) === 0 && o.reactions !== null || aT(o)) && (l = Wk(o)), Uu.set(o, l), l;
    }
  } else if (n) {
    if (o = /** @type {Derived} */
    t, Ps?.has(o))
      return Ps.get(o);
    Gg(o) && JF(o), nf && Pv() && (o.f & Go) === 0 && lT(o);
  } else if (Ps?.has(t))
    return Ps.get(t);
  if ((t.f & ju) !== 0)
    throw t.v;
  return t.v;
}
function lT(t) {
  if (t.deps !== null) {
    t.f ^= Go;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & pi) !== 0 && (e.f & Go) === 0 && lT(
        /** @type {Derived} */
        e
      );
  }
}
function aT(t) {
  if (t.v === Vr) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Uu.has(e) || (e.f & pi) !== 0 && aT(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function Gs(t) {
  var e = Rl;
  try {
    return Rl = !0, t();
  } finally {
    Rl = e;
  }
}
const vY = -7169;
function ci(t, e) {
  t.f = t.f & vY | e;
}
function xY(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (jl in t)
      w_(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const n = t[e];
        typeof n == "object" && n && jl in n && w_(n);
      }
  }
}
function w_(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let r in t)
      try {
        w_(t[r], e);
      } catch {
      }
    const n = qk(t);
    if (n !== Object.prototype && n !== Array.prototype && n !== Map.prototype && n !== Set.prototype && n !== Date.prototype) {
      const r = AF(n);
      for (let i in r) {
        const s = r[i].get;
        if (s)
          try {
            s.call(t);
          } catch {
          }
      }
    }
  }
}
function uT(t) {
  Vt === null && (Yt === null && IK(), PK()), Lf && MK();
}
function wY(t, e) {
  var n = e.last;
  n === null ? e.last = e.first = t : (n.next = t, t.prev = n, e.last = t);
}
function oa(t, e, n, r = !0) {
  var i = Vt;
  i !== null && (i.f & js) !== 0 && (t |= js);
  var s = {
    ctx: us,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | as | Go,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (n)
    try {
      Wp(s), s.f |= Vg;
    } catch (a) {
      throw $r(s), a;
    }
  else e !== null && bf(s);
  if (r) {
    var o = s;
    if (n && o.deps === null && o.teardown === null && o.nodes_start === null && o.first === o.last && // either `null`, or a singular child
    (o.f & Wd) === 0 && (o = o.first, (t & sa) !== 0 && (t & Ya) !== 0 && o !== null && (o.f |= Ya)), o !== null && (o.parent = i, i !== null && wY(o, i), Yt !== null && (Yt.f & pi) !== 0 && (t & Nf) === 0)) {
      var l = (
        /** @type {Derived} */
        Yt
      );
      (l.effects ??= []).push(o);
    }
  }
  return s;
}
function Pv() {
  return Yt !== null && !Rl;
}
function Iv(t) {
  const e = oa(Av, null, !1);
  return ci(e, ii), e.teardown = t, e;
}
function Vo(t) {
  uT();
  var e = (
    /** @type {Effect} */
    Vt.f
  ), n = !Yt && (e & eu) !== 0 && (e & Vg) === 0;
  if (n) {
    var r = (
      /** @type {ComponentContext} */
      us
    );
    (r.e ??= []).push(t);
  } else
    return cT(t);
}
function cT(t) {
  return oa(Sv | CF, t, !1);
}
function pt(t) {
  return uT(), oa(Av | CF, t, !0);
}
function _Y(t) {
  Tl.ensure();
  const e = oa(Nf | Wd, t, !0);
  return (n = {}) => new Promise((r) => {
    n.outro ? jh(e, () => {
      $r(e), r(void 0);
    }) : ($r(e), r(void 0));
  });
}
function Kd(t) {
  return oa(Sv, t, !1);
}
function kY(t) {
  return oa(Bk | Wd, t, !0);
}
function Nv(t, e = 0) {
  return oa(Av | e, t, !0);
}
function ke(t, e = [], n = [], r = [], i = !1) {
  YF(r, e, n, (s) => {
    oa(i ? Sv : Av, () => t(...s.map(x)), !0);
  });
}
function dc(t, e = 0) {
  var n = oa(sa | e, t, !0);
  return n;
}
function Ki(t, e = !0) {
  return oa(eu | Wd, t, !0, e);
}
function fT(t) {
  var e = t.teardown;
  if (e !== null) {
    const n = Lf, r = Yt;
    hA(!0), ts(null);
    try {
      e.call(null);
    } finally {
      hA(n), ts(r);
    }
  }
}
function hT(t, e = !1) {
  var n = t.first;
  for (t.first = t.last = null; n !== null; ) {
    const i = n.ac;
    i !== null && Gd(() => {
      i.abort(Oh);
    });
    var r = n.next;
    (n.f & Nf) !== 0 ? n.parent = null : $r(n, e), n = r;
  }
}
function CY(t) {
  for (var e = t.first; e !== null; ) {
    var n = e.next;
    (e.f & eu) === 0 && $r(e), e = n;
  }
}
function $r(t, e = !0) {
  var n = !1;
  (e || (t.f & kF) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (dT(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), n = !0), hT(t, e && !n), lb(t, 0), ci(t, zu);
  var r = t.transitions;
  if (r !== null)
    for (const s of r)
      s.stop();
  fT(t);
  var i = t.parent;
  i !== null && i.first !== null && pT(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function dT(t, e) {
  for (; t !== null; ) {
    var n = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ rl(t)
    );
    t.remove(), t = n;
  }
}
function pT(t) {
  var e = t.parent, n = t.prev, r = t.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), e !== null && (e.first === t && (e.first = r), e.last === t && (e.last = n));
}
function jh(t, e, n = !0) {
  var r = [];
  Kk(t, r, !0), gT(r, () => {
    n && $r(t), e && e();
  });
}
function gT(t, e) {
  var n = t.length;
  if (n > 0) {
    var r = () => --n || e();
    for (var i of t)
      i.out(r);
  } else
    e();
}
function Kk(t, e, n) {
  if ((t.f & js) === 0) {
    if (t.f ^= js, t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || n) && e.push(o);
    for (var r = t.first; r !== null; ) {
      var i = r.next, s = (r.f & Ya) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (r.f & eu) !== 0 && (t.f & sa) !== 0;
      Kk(r, e, s ? n : !1), r = i;
    }
  }
}
function Yk(t) {
  mT(t, !0);
}
function mT(t, e) {
  if ((t.f & js) !== 0) {
    t.f ^= js, (t.f & ii) === 0 && (ci(t, as), bf(t));
    for (var n = t.first; n !== null; ) {
      var r = n.next, i = (n.f & Ya) !== 0 || (n.f & eu) !== 0;
      mT(n, i ? e : !1), n = r;
    }
    if (t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || e) && s.in();
  }
}
function yT(t, e) {
  for (var n = t.nodes_start, r = t.nodes_end; n !== null; ) {
    var i = n === r ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ rl(n)
    );
    e.append(n), n = i;
  }
}
const bT = /* @__PURE__ */ new Set(), __ = /* @__PURE__ */ new Set();
function vT(t, e, n, r = {}) {
  function i(s) {
    if (r.capture || up.call(e, s), !s.cancelBubble)
      return Gd(() => n?.call(this, s));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? nu(() => {
    e.addEventListener(t, i, r);
  }) : e.addEventListener(t, i, r), i;
}
function SY(t, e, n, r, i) {
  var s = { capture: r, passive: i }, o = vT(t, e, n, s);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && Iv(() => {
    e.removeEventListener(t, o, s);
  });
}
function ir(t) {
  for (var e = 0; e < t.length; e++)
    bT.add(t[e]);
  for (var n of __)
    n(t);
}
let pA = null;
function up(t) {
  var e = this, n = (
    /** @type {Node} */
    e.ownerDocument
  ), r = t.type, i = t.composedPath?.() || [], s = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  pA = t;
  var o = 0, l = pA === t && t.__root;
  if (l) {
    var a = i.indexOf(l);
    if (a !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    a <= u && (o = a);
  }
  if (s = /** @type {Element} */
  i[o] || t.target, s !== e) {
    jk(t, "currentTarget", {
      configurable: !0,
      get() {
        return s || n;
      }
    });
    var c = Yt, f = Vt;
    ts(null), Yl(null);
    try {
      for (var d, p = []; s !== null; ) {
        var m = s.assignedSlot || s.parentNode || /** @type {any} */
        s.host || null;
        try {
          var y = s["__" + r];
          y != null && (!/** @type {any} */
          s.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === s) && y.call(s, t);
        } catch (b) {
          d ? p.push(b) : d = b;
        }
        if (t.cancelBubble || m === e || m === null)
          break;
        s = m;
      }
      if (d) {
        for (let b of p)
          queueMicrotask(() => {
            throw b;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, ts(c), Yl(f);
    }
  }
}
function Xk(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function qs(t, e) {
  var n = (
    /** @type {Effect} */
    Vt
  );
  n.nodes_start === null && (n.nodes_start = t, n.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function ge(t, e) {
  var n = (e & MF) !== 0, r = (e & ZK) !== 0, i, s = !t.startsWith("<!>");
  return () => {
    if (Ct)
      return qs(jt, null), jt;
    i === void 0 && (i = Xk(s ? t : "<!>" + t), n || (i = /** @type {Node} */
    /* @__PURE__ */ ni(i)));
    var o = (
      /** @type {TemplateNode} */
      r || LF ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (n) {
      var l = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ni(o)
      ), a = (
        /** @type {TemplateNode} */
        o.lastChild
      );
      qs(l, a);
    } else
      qs(o, o);
    return o;
  };
}
// @__NO_SIDE_EFFECTS__
function AY(t, e, n = "svg") {
  var r = !t.startsWith("<!>"), i = (e & MF) !== 0, s = `<${n}>${r ? t : "<!>" + t}</${n}>`, o;
  return () => {
    if (Ct)
      return qs(jt, null), jt;
    if (!o) {
      var l = (
        /** @type {DocumentFragment} */
        Xk(s)
      ), a = (
        /** @type {Element} */
        /* @__PURE__ */ ni(l)
      );
      if (i)
        for (o = document.createDocumentFragment(); /* @__PURE__ */ ni(a); )
          o.appendChild(
            /** @type {Node} */
            /* @__PURE__ */ ni(a)
          );
      else
        o = /** @type {Element} */
        /* @__PURE__ */ ni(a);
    }
    var u = (
      /** @type {TemplateNode} */
      o.cloneNode(!0)
    );
    if (i) {
      var c = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ni(u)
      ), f = (
        /** @type {TemplateNode} */
        u.lastChild
      );
      qs(c, f);
    } else
      qs(u, u);
    return u;
  };
}
// @__NO_SIDE_EFFECTS__
function Dt(t, e) {
  return /* @__PURE__ */ AY(t, e, "svg");
}
function Ms(t = "") {
  if (!Ct) {
    var e = Ws(t + "");
    return qs(e, e), e;
  }
  var n = jt;
  return n.nodeType !== Dv && (n.before(n = Ws()), ui(n)), qs(n, n), n;
}
function kn() {
  if (Ct)
    return qs(jt, null), jt;
  var t = document.createDocumentFragment(), e = document.createComment(""), n = Ws();
  return t.append(e, n), qs(e, n), t;
}
function X(t, e) {
  if (Ct) {
    var n = (
      /** @type {Effect} */
      Vt
    );
    ((n.f & Vg) === 0 || n.nodes_end === null) && (n.nodes_end = jt), tc();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
function EY(t) {
  return t.endsWith("capture") && t !== "gotpointercapture" && t !== "lostpointercapture";
}
const DY = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function OY(t) {
  return DY.includes(t);
}
const FY = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function TY(t) {
  return t = t.toLowerCase(), FY[t] ?? t;
}
const RY = ["touchstart", "touchmove"];
function MY(t) {
  return RY.includes(t);
}
let k_ = !0;
function ut(t, e) {
  var n = e == null ? "" : typeof e == "object" ? e + "" : e;
  n !== (t.__t ??= t.nodeValue) && (t.__t = n, t.nodeValue = n + "");
}
function xT(t, e) {
  return wT(t, e);
}
function PY(t, e) {
  b_(), e.intro = e.intro ?? !1;
  const n = e.target, r = Ct, i = jt;
  try {
    for (var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ni(n)
    ); s && (s.nodeType !== Bf || /** @type {Comment} */
    s.data !== PF); )
      s = /** @type {TemplateNode} */
      /* @__PURE__ */ rl(s);
    if (!s)
      throw yf;
    Uo(!0), ui(
      /** @type {Comment} */
      s
    );
    const o = wT(t, { ...e, anchor: s });
    return Uo(!1), /**  @type {Exports} */
    o;
  } catch (o) {
    if (o instanceof Error && o.message.split(`
`).some((l) => l.startsWith("https://svelte.dev/e/")))
      throw o;
    return o !== yf && console.warn("Failed to hydrate: ", o), e.recover === !1 && BK(), b_(), jF(n), Uo(!1), xT(t, e);
  } finally {
    Uo(r), ui(i);
  }
}
const gh = /* @__PURE__ */ new Map();
function wT(t, { target: e, anchor: n, props: r = {}, events: i, context: s, intro: o = !0 }) {
  b_();
  var l = /* @__PURE__ */ new Set(), a = (f) => {
    for (var d = 0; d < f.length; d++) {
      var p = f[d];
      if (!l.has(p)) {
        l.add(p);
        var m = MY(p);
        e.addEventListener(p, up, { passive: m });
        var y = gh.get(p);
        y === void 0 ? (document.addEventListener(p, up, { passive: m }), gh.set(p, 1)) : gh.set(p, y + 1);
      }
    }
  };
  a(zk(bT)), __.add(a);
  var u = void 0, c = _Y(() => {
    var f = n ?? e.appendChild(Ws());
    return KF(
      /** @type {TemplateNode} */
      f,
      {
        pending: () => {
        }
      },
      (d) => {
        if (s) {
          it({});
          var p = (
            /** @type {ComponentContext} */
            us
          );
          p.c = s;
        }
        if (i && (r.$$events = i), Ct && qs(
          /** @type {TemplateNode} */
          d,
          null
        ), k_ = o, u = t(d, r) || {}, k_ = !0, Ct && (Vt.nodes_end = jt, jt === null || jt.nodeType !== Bf || /** @type {Comment} */
        jt.data !== Hk))
          throw Wg(), yf;
        s && st();
      }
    ), () => {
      for (var d of l) {
        e.removeEventListener(d, up);
        var p = (
          /** @type {number} */
          gh.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, up), gh.delete(d)) : gh.set(d, p);
      }
      __.delete(a), f !== n && f.parentNode?.removeChild(f);
    };
  });
  return C_.set(u, c), u;
}
let C_ = /* @__PURE__ */ new WeakMap();
function IY(t, e) {
  const n = C_.get(t);
  return n ? (C_.delete(t), n(e)) : Promise.resolve();
}
function _T(t) {
  return new NY(t);
}
class NY {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var n = /* @__PURE__ */ new Map(), r = (s, o) => {
      var l = /* @__PURE__ */ Gk(o, !1, !1);
      return n.set(s, l), l;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(s, o) {
          return x(n.get(o) ?? r(o, Reflect.get(s, o)));
        },
        has(s, o) {
          return o === Lk ? !0 : (x(n.get(o) ?? r(o, Reflect.get(s, o))), Reflect.has(s, o));
        },
        set(s, o, l) {
          return ae(n.get(o) ?? r(o, l), l), Reflect.set(s, o, l);
        }
      }
    );
    this.#t = (e.hydrate ? PY : xT)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && HF(), this.#e = i.$$events;
    for (const s of Object.keys(this.#t))
      s === "$set" || s === "$destroy" || s === "$on" || jk(this, s, {
        get() {
          return this.#t[s];
        },
        /** @param {any} value */
        set(o) {
          this.#t[s] = o;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (s) => {
      Object.assign(i, s);
    }, this.#t.$destroy = () => {
      IY(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, n) {
    this.#e[e] = this.#e[e] || [];
    const r = (...i) => n.call(this, ...i);
    return this.#e[e].push(r), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== r
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const BY = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(BY);
class Bv {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #n = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #r = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, n = !0) {
    this.anchor = e, this.#r = n;
  }
  #a = () => {
    var e = (
      /** @type {Batch} */
      $n
    );
    if (this.#e.has(e)) {
      var n = (
        /** @type {Key} */
        this.#e.get(e)
      ), r = this.#t.get(n);
      if (r)
        Yk(r);
      else {
        var i = this.#n.get(n);
        i && (this.#t.set(n, i.effect), this.#n.delete(n), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), r = i.effect);
      }
      for (const [s, o] of this.#e) {
        if (this.#e.delete(s), s === e)
          break;
        const l = this.#n.get(o);
        l && ($r(l.effect), this.#n.delete(o));
      }
      for (const [s, o] of this.#t) {
        if (s === n) continue;
        const l = () => {
          if (Array.from(this.#e.values()).includes(s)) {
            var u = document.createDocumentFragment();
            yT(o, u), u.append(Ws()), this.#n.set(s, { effect: o, fragment: u });
          } else
            $r(o);
          this.#t.delete(s);
        };
        this.#r || !r ? jh(o, l, !1) : l();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #l = (e) => {
    this.#e.delete(e);
    const n = Array.from(this.#e.values());
    for (const [r, i] of this.#n)
      n.includes(r) || ($r(i.effect), this.#n.delete(r));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, n) {
    var r = (
      /** @type {Batch} */
      $n
    ), i = qF();
    if (n && !this.#t.has(e) && !this.#n.has(e))
      if (i) {
        var s = document.createDocumentFragment(), o = Ws();
        s.append(o), this.#n.set(e, {
          effect: Ki(() => n(o)),
          fragment: s
        });
      } else
        this.#t.set(
          e,
          Ki(() => n(this.anchor))
        );
    if (this.#e.set(r, e), i) {
      for (const [l, a] of this.#t)
        l === e ? r.skipped_effects.delete(a) : r.skipped_effects.add(a);
      for (const [l, a] of this.#n)
        l === e ? r.skipped_effects.delete(a.effect) : r.skipped_effects.add(a.effect);
      r.oncommit(this.#a), r.ondiscard(this.#l);
    } else
      Ct && (this.anchor = jt), this.#a();
  }
}
function Xa(t, e, ...n) {
  var r = new Bv(t);
  dc(() => {
    const i = e() ?? null;
    r.ensure(i, i && ((s) => i(s, ...n)));
  }, Ya);
}
function Kg(t) {
  us === null && TF(), Vo(() => {
    const e = Gs(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function kT(t) {
  us === null && TF(), Kg(() => () => Gs(t));
}
function Fe(t, e, n = !1) {
  Ct && tc();
  var r = new Bv(t), i = n ? Ya : 0;
  function s(o, l) {
    if (Ct) {
      const u = BF(t) === Tv;
      if (o === u) {
        var a = sb();
        ui(a), r.anchor = a, Uo(!1), r.ensure(o, l), Uo(!0);
        return;
      }
    }
    r.ensure(o, l);
  }
  dc(() => {
    var o = !1;
    e((l, a = !0) => {
      o = !0, s(a, l);
    }), o || s(!1, null);
  }, i);
}
function CT(t, e, n) {
  Ct && tc();
  var r = new Bv(t);
  dc(() => {
    var i = e();
    r.ensure(i, n);
  });
}
let Ay = null;
function fn(t, e) {
  return e;
}
function LY(t, e, n) {
  for (var r = t.items, i = [], s = e.length, o = 0; o < s; o++)
    Kk(e[o].e, i, !0);
  var l = s > 0 && i.length === 0 && n !== null;
  if (l) {
    var a = (
      /** @type {Element} */
      /** @type {Element} */
      n.parentNode
    );
    jF(a), a.append(
      /** @type {Element} */
      n
    ), r.clear(), xl(t, e[0].prev, e[s - 1].next);
  }
  gT(i, () => {
    for (var u = 0; u < s; u++) {
      var c = e[u];
      l || (r.delete(c.k), xl(t, c.prev, c.next)), $r(c.e, !l);
    }
  });
}
function Bt(t, e, n, r, i, s = null) {
  var o = t, l = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, a = (e & RF) !== 0;
  if (a) {
    var u = (
      /** @type {Element} */
      t
    );
    o = Ct ? ui(
      /** @type {Comment | Text} */
      /* @__PURE__ */ ni(u)
    ) : u.appendChild(Ws());
  }
  Ct && tc();
  var c = null, f = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ XF(() => {
    var v = n();
    return $k(v) ? v : v == null ? [] : zk(v);
  }), m, y;
  function b() {
    $Y(
      y,
      m,
      l,
      d,
      o,
      i,
      e,
      r,
      n
    ), s !== null && (m.length === 0 ? c ? Yk(c) : c = Ki(() => s(o)) : c !== null && jh(c, () => {
      c = null;
    }));
  }
  dc(() => {
    y ??= /** @type {Effect} */
    Vt, m = /** @type {V[]} */
    x(p);
    var v = m.length;
    if (f && v === 0)
      return;
    f = v === 0;
    let _ = !1;
    if (Ct) {
      var k = BF(o) === Tv;
      k !== (v === 0) && (o = sb(), ui(o), Uo(!1), _ = !0);
    }
    if (Ct) {
      for (var S = null, C, E = 0; E < v; E++) {
        if (jt.nodeType === Bf && /** @type {Comment} */
        jt.data === Hk) {
          o = /** @type {Comment} */
          jt, _ = !0, Uo(!1);
          break;
        }
        var A = m[E], O = r(A, E);
        C = S_(
          jt,
          l,
          S,
          null,
          A,
          O,
          E,
          i,
          e,
          n
        ), l.items.set(O, C), S = C;
      }
      v > 0 && ui(sb());
    }
    if (Ct)
      v === 0 && s && (c = Ki(() => s(o)));
    else if (qF()) {
      var T = /* @__PURE__ */ new Set(), $ = (
        /** @type {Batch} */
        $n
      );
      for (E = 0; E < v; E += 1) {
        A = m[E], O = r(A, E);
        var P = l.items.get(O) ?? d.get(O);
        P ? (e & (Ov | Fv)) !== 0 && ST(P, A, E, e) : (C = S_(
          null,
          l,
          null,
          null,
          A,
          O,
          E,
          i,
          e,
          n,
          !0
        ), d.set(O, C)), T.add(O);
      }
      for (const [B, M] of l.items)
        T.has(B) || $.skipped_effects.add(M.e);
      $.oncommit(b);
    } else
      b();
    _ && Uo(!0), x(p);
  }), Ct && (o = jt);
}
function $Y(t, e, n, r, i, s, o, l, a) {
  var u = (o & HK) !== 0, c = (o & (Ov | Fv)) !== 0, f = e.length, d = n.items, p = n.first, m = p, y, b = null, v, _ = [], k = [], S, C, E, A;
  if (u)
    for (A = 0; A < f; A += 1)
      S = e[A], C = l(S, A), E = d.get(C), E !== void 0 && (E.a?.measure(), (v ??= /* @__PURE__ */ new Set()).add(E));
  for (A = 0; A < f; A += 1) {
    if (S = e[A], C = l(S, A), E = d.get(C), E === void 0) {
      var O = r.get(C);
      if (O !== void 0) {
        r.delete(C), d.set(C, O);
        var T = b ? b.next : m;
        xl(n, b, O), xl(n, O, T), bw(O, T, i), b = O;
      } else {
        var $ = m ? (
          /** @type {TemplateNode} */
          m.e.nodes_start
        ) : i;
        b = S_(
          $,
          n,
          b,
          b === null ? n.first : b.next,
          S,
          C,
          A,
          s,
          o,
          a
        );
      }
      d.set(C, b), _ = [], k = [], m = b.next;
      continue;
    }
    if (c && ST(E, S, A, o), (E.e.f & js) !== 0 && (Yk(E.e), u && (E.a?.unfix(), (v ??= /* @__PURE__ */ new Set()).delete(E))), E !== m) {
      if (y !== void 0 && y.has(E)) {
        if (_.length < k.length) {
          var P = k[0], B;
          b = P.prev;
          var M = _[0], L = _[_.length - 1];
          for (B = 0; B < _.length; B += 1)
            bw(_[B], P, i);
          for (B = 0; B < k.length; B += 1)
            y.delete(k[B]);
          xl(n, M.prev, L.next), xl(n, b, M), xl(n, L, P), m = P, b = L, A -= 1, _ = [], k = [];
        } else
          y.delete(E), bw(E, m, i), xl(n, E.prev, E.next), xl(n, E, b === null ? n.first : b.next), xl(n, b, E), b = E;
        continue;
      }
      for (_ = [], k = []; m !== null && m.k !== C; )
        (m.e.f & js) === 0 && (y ??= /* @__PURE__ */ new Set()).add(m), k.push(m), m = m.next;
      if (m === null)
        continue;
      E = m;
    }
    _.push(E), b = E, m = E.next;
  }
  if (m !== null || y !== void 0) {
    for (var N = y === void 0 ? [] : zk(y); m !== null; )
      (m.e.f & js) === 0 && N.push(m), m = m.next;
    var j = N.length;
    if (j > 0) {
      var U = (o & RF) !== 0 && f === 0 ? i : null;
      if (u) {
        for (A = 0; A < j; A += 1)
          N[A].a?.measure();
        for (A = 0; A < j; A += 1)
          N[A].a?.fix();
      }
      LY(n, N, U);
    }
  }
  u && nu(() => {
    if (v !== void 0)
      for (E of v)
        E.a?.apply();
  }), t.first = n.first && n.first.e, t.last = b && b.e;
  for (var H of r.values())
    $r(H.e);
  r.clear();
}
function ST(t, e, n, r) {
  (r & Ov) !== 0 && yd(t.v, e), (r & Fv) !== 0 ? yd(
    /** @type {Value<number>} */
    t.i,
    n
  ) : t.i = n;
}
function S_(t, e, n, r, i, s, o, l, a, u, c) {
  var f = Ay, d = (a & Ov) !== 0, p = (a & VK) === 0, m = d ? p ? /* @__PURE__ */ Gk(i, !1, !1) : vf(i) : i, y = (a & Fv) === 0 ? o : vf(o), b = {
    i: y,
    v: m,
    k: s,
    a: null,
    // @ts-expect-error
    e: null,
    prev: n,
    next: r
  };
  Ay = b;
  try {
    if (t === null) {
      var v = document.createDocumentFragment();
      v.append(t = Ws());
    }
    return b.e = Ki(() => l(
      /** @type {Node} */
      t,
      m,
      y,
      u
    ), Ct), b.e.prev = n && n.e, b.e.next = r && r.e, n === null ? c || (e.first = b) : (n.next = b, n.e.next = b.e), r !== null && (r.prev = b, r.e.prev = b.e), b;
  } finally {
    Ay = f;
  }
}
function bw(t, e, n) {
  for (var r = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : n, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : n, s = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); s !== null && s !== r; ) {
    var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ rl(s)
    );
    i.before(s), s = o;
  }
}
function xl(t, e, n) {
  e === null ? t.first = n : (e.next = n, e.e.next = n && n.e), n !== null && (n.prev = e, n.e.prev = e && e.e);
}
function zY(t, e, n = !1, r = !1, i = !1) {
  var s = t, o = "";
  ke(() => {
    var l = (
      /** @type {Effect} */
      Vt
    );
    if (o === (o = e() ?? "")) {
      Ct && tc();
      return;
    }
    if (l.nodes_start !== null && (dT(
      l.nodes_start,
      /** @type {TemplateNode} */
      l.nodes_end
    ), l.nodes_start = l.nodes_end = null), o !== "") {
      if (Ct) {
        jt.data;
        for (var a = tc(), u = a; a !== null && (a.nodeType !== Bf || /** @type {Comment} */
        a.data !== ""); )
          u = a, a = /** @type {TemplateNode} */
          /* @__PURE__ */ rl(a);
        if (a === null)
          throw Wg(), yf;
        qs(jt, u), s = ui(a);
        return;
      }
      var c = o + "";
      n ? c = `<svg>${c}</svg>` : r && (c = `<math>${c}</math>`);
      var f = Xk(c);
      if ((n || r) && (f = /** @type {Element} */
      /* @__PURE__ */ ni(f)), qs(
        /** @type {TemplateNode} */
        /* @__PURE__ */ ni(f),
        /** @type {TemplateNode} */
        f.lastChild
      ), n || r)
        for (; /* @__PURE__ */ ni(f); )
          s.before(
            /** @type {Node} */
            /* @__PURE__ */ ni(f)
          );
      else
        s.before(f);
    }
  });
}
function Yd(t, e, n) {
  Ct && tc();
  var r = new Bv(t);
  dc(() => {
    var i = e() ?? null;
    r.ensure(i, i && ((s) => n(s, i)));
  }, Ya);
}
function Ts(t, e, n) {
  Kd(() => {
    var r = Gs(() => e(t, n?.()) || {});
    if (n && r?.update) {
      var i = !1, s = (
        /** @type {any} */
        {}
      );
      Nv(() => {
        var o = n();
        xY(o), i && Uk(s, o) && (s = o, r.update(o));
      }), i = !0;
    }
    if (r?.destroy)
      return () => (
        /** @type {Function} */
        r.destroy()
      );
  });
}
function jY(t, e) {
  var n = void 0, r;
  dc(() => {
    n !== (n = e()) && (r && ($r(r), r = null), n && (r = Ki(() => {
      Kd(() => (
        /** @type {(node: Element) => void} */
        n(t)
      ));
    })));
  });
}
function AT(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (n = AT(t[e])) && (r && (r += " "), r += n);
  } else for (n in t) t[n] && (r && (r += " "), r += n);
  return r;
}
function qY() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++) (t = arguments[n]) && (e = AT(t)) && (r && (r += " "), r += e);
  return r;
}
function Lv(t) {
  return typeof t == "object" ? qY(t) : t ?? "";
}
const gA = [...` 	
\r\fÂ \v\uFEFF`];
function UY(t, e, n) {
  var r = t == null ? "" : "" + t;
  if (e && (r = r ? r + " " + e : e), n) {
    for (var i in n)
      if (n[i])
        r = r ? r + " " + i : i;
      else if (r.length)
        for (var s = i.length, o = 0; (o = r.indexOf(i, o)) >= 0; ) {
          var l = o + s;
          (o === 0 || gA.includes(r[o - 1])) && (l === r.length || gA.includes(r[l])) ? r = (o === 0 ? "" : r.substring(0, o)) + r.substring(l + 1) : o = l;
        }
  }
  return r === "" ? null : r;
}
function mA(t, e = !1) {
  var n = e ? " !important;" : ";", r = "";
  for (var i in t) {
    var s = t[i];
    s != null && s !== "" && (r += " " + i + ": " + s + n);
  }
  return r;
}
function vw(t) {
  return t[0] !== "-" || t[1] !== "-" ? t.toLowerCase() : t;
}
function HY(t, e) {
  if (e) {
    var n = "", r, i;
    if (Array.isArray(e) ? (r = e[0], i = e[1]) : r = e, t) {
      t = String(t).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var s = !1, o = 0, l = !1, a = [];
      r && a.push(...Object.keys(r).map(vw)), i && a.push(...Object.keys(i).map(vw));
      var u = 0, c = -1;
      const y = t.length;
      for (var f = 0; f < y; f++) {
        var d = t[f];
        if (l ? d === "/" && t[f - 1] === "*" && (l = !1) : s ? s === d && (s = !1) : d === "/" && t[f + 1] === "*" ? l = !0 : d === '"' || d === "'" ? s = d : d === "(" ? o++ : d === ")" && o--, !l && s === !1 && o === 0) {
          if (d === ":" && c === -1)
            c = f;
          else if (d === ";" || f === y - 1) {
            if (c !== -1) {
              var p = vw(t.substring(u, c).trim());
              if (!a.includes(p)) {
                d !== ";" && f++;
                var m = t.substring(u, f).trim();
                n += " " + m + ";";
              }
            }
            u = f + 1, c = -1;
          }
        }
      }
    }
    return r && (n += mA(r)), i && (n += mA(i, !0)), n = n.trim(), n === "" ? null : n;
  }
  return t == null ? null : String(t);
}
function er(t, e, n, r, i, s) {
  var o = t.__className;
  if (Ct || o !== n || o === void 0) {
    var l = UY(n, r, s);
    (!Ct || l !== t.getAttribute("class")) && (l == null ? t.removeAttribute("class") : e ? t.className = l : t.setAttribute("class", l)), t.__className = n;
  } else if (s && i !== s)
    for (var a in s) {
      var u = !!s[a];
      (i == null || u !== !!i[a]) && t.classList.toggle(a, u);
    }
  return s;
}
function xw(t, e = {}, n, r) {
  for (var i in n) {
    var s = n[i];
    e[i] !== s && (n[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, s, r));
  }
}
function ht(t, e, n, r) {
  var i = t.__style;
  if (Ct || i !== e) {
    var s = HY(e, r);
    (!Ct || s !== t.getAttribute("style")) && (s == null ? t.removeAttribute("style") : t.style.cssText = s), t.__style = e;
  } else r && (Array.isArray(r) ? (xw(t, n?.[0], r[0]), xw(t, n?.[1], r[1], "important")) : xw(t, n, r));
  return r;
}
function bd(t, e, n = !1) {
  if (t.multiple) {
    if (e == null)
      return;
    if (!$k(e))
      return rY();
    for (var r of t.options)
      r.selected = e.includes(yA(r));
    return;
  }
  for (r of t.options) {
    var i = yA(r);
    if (sY(i, e)) {
      r.selected = !0;
      return;
    }
  }
  (!n || e !== void 0) && (t.selectedIndex = -1);
}
function ab(t) {
  var e = new MutationObserver(() => {
    bd(t, t.__value);
  });
  e.observe(t, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), Iv(() => {
    e.disconnect();
  });
}
function yA(t) {
  return "__value" in t ? t.__value : t.value;
}
const U0 = Symbol("class"), H0 = Symbol("style"), ET = Symbol("is custom element"), DT = Symbol("is html");
function OT(t) {
  if (Ct) {
    var e = !1, n = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var r = t.value;
          te(t, "value", null), t.value = r;
        }
        if (t.hasAttribute("checked")) {
          var i = t.checked;
          te(t, "checked", null), t.checked = i;
        }
      }
    };
    t.__on_r = n, nu(n), tT();
  }
}
function VY(t, e) {
  e ? t.hasAttribute("selected") || t.setAttribute("selected", "") : t.removeAttribute("selected");
}
function te(t, e, n, r) {
  var i = FT(t);
  Ct && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = n) && (e === "loading" && (t[DK] = n), n == null ? t.removeAttribute(e) : typeof n != "string" && TT(t).includes(e) ? t[e] = n : t.setAttribute(e, n));
}
function WY(t, e, n, r, i = !1, s = !1) {
  if (Ct && i && t.tagName === "INPUT") {
    var o = (
      /** @type {HTMLInputElement} */
      t
    ), l = o.type === "checkbox" ? "defaultChecked" : "defaultValue";
    l in n || OT(o);
  }
  var a = FT(t), u = a[ET], c = !a[DT];
  let f = Ct && u;
  f && Uo(!1);
  var d = e || {}, p = t.tagName === "OPTION";
  for (var m in e)
    m in n || (n[m] = null);
  n.class ? n.class = Lv(n.class) : n[U0] && (n.class = null), n[H0] && (n.style ??= null);
  var y = TT(t);
  for (const E in n) {
    let A = n[E];
    if (p && E === "value" && A == null) {
      t.value = t.__value = "", d[E] = A;
      continue;
    }
    if (E === "class") {
      var b = t.namespaceURI === "http://www.w3.org/1999/xhtml";
      er(t, b, A, r, e?.[U0], n[U0]), d[E] = A, d[U0] = n[U0];
      continue;
    }
    if (E === "style") {
      ht(t, A, e?.[H0], n[H0]), d[E] = A, d[H0] = n[H0];
      continue;
    }
    var v = d[E];
    if (!(A === v && !(A === void 0 && t.hasAttribute(E)))) {
      d[E] = A;
      var _ = E[0] + E[1];
      if (_ !== "$$")
        if (_ === "on") {
          const O = {}, T = "$$" + E;
          let $ = E.slice(2);
          var k = OY($);
          if (EY($) && ($ = $.slice(0, -7), O.capture = !0), !k && v) {
            if (A != null) continue;
            t.removeEventListener($, d[T], O), d[T] = null;
          }
          if (A != null)
            if (k)
              t[`__${$}`] = A, ir([$]);
            else {
              let P = function(B) {
                d[E].call(this, B);
              };
              d[T] = vT($, t, P, O);
            }
          else k && (t[`__${$}`] = void 0);
        } else if (E === "style")
          te(t, E, A);
        else if (E === "autofocus")
          pY(
            /** @type {HTMLElement} */
            t,
            !!A
          );
        else if (!u && (E === "__value" || E === "value" && A != null))
          t.value = t.__value = A;
        else if (E === "selected" && p)
          VY(
            /** @type {HTMLOptionElement} */
            t,
            A
          );
        else {
          var S = E;
          c || (S = TY(S));
          var C = S === "defaultValue" || S === "defaultChecked";
          if (A == null && !u && !C)
            if (a[E] = null, S === "value" || S === "checked") {
              let O = (
                /** @type {HTMLInputElement} */
                t
              );
              const T = e === void 0;
              if (S === "value") {
                let $ = O.defaultValue;
                O.removeAttribute(S), O.defaultValue = $, O.value = O.__value = T ? $ : null;
              } else {
                let $ = O.defaultChecked;
                O.removeAttribute(S), O.defaultChecked = $, O.checked = T ? $ : !1;
              }
            } else
              t.removeAttribute(E);
          else C || y.includes(S) && (u || typeof A != "string") ? (t[S] = A, S in a && (a[S] = Vr)) : typeof A != "function" && te(t, S, A);
        }
    }
  }
  return f && Uo(!0), d;
}
function Ys(t, e, n = [], r = [], i = [], s, o = !1, l = !1) {
  YF(i, n, r, (a) => {
    var u = void 0, c = {}, f = t.nodeName === "SELECT", d = !1;
    if (dc(() => {
      var m = e(...a.map(x)), y = WY(
        t,
        u,
        m,
        s,
        o,
        l
      );
      d && f && "value" in m && bd(
        /** @type {HTMLSelectElement} */
        t,
        m.value
      );
      for (let v of Object.getOwnPropertySymbols(c))
        m[v] || $r(c[v]);
      for (let v of Object.getOwnPropertySymbols(m)) {
        var b = m[v];
        v.description === tY && (!u || b !== u[v]) && (c[v] && $r(c[v]), c[v] = Ki(() => jY(t, () => b))), y[v] = b;
      }
      u = y;
    }), f) {
      var p = (
        /** @type {HTMLSelectElement} */
        t
      );
      Kd(() => {
        bd(
          p,
          /** @type {Record<string | symbol, any>} */
          u.value,
          !0
        ), ab(p);
      });
    }
    d = !0;
  });
}
function FT(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [ET]: t.nodeName.includes("-"),
      [DT]: t.namespaceURI === eY
    }
  );
}
var bA = /* @__PURE__ */ new Map();
function TT(t) {
  var e = t.getAttribute("is") || t.nodeName, n = bA.get(e);
  if (n) return n;
  bA.set(e, n = []);
  for (var r, i = t, s = Element.prototype; s !== i; ) {
    r = AF(i);
    for (var o in r)
      r[o].set && n.push(o);
    i = qk(i);
  }
  return n;
}
const GY = () => performance.now(), Ma = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (t) => requestAnimationFrame(t)
  ),
  now: () => GY(),
  tasks: /* @__PURE__ */ new Set()
};
function RT() {
  const t = Ma.now();
  Ma.tasks.forEach((e) => {
    e.c(t) || (Ma.tasks.delete(e), e.f());
  }), Ma.tasks.size !== 0 && Ma.tick(RT);
}
function KY(t) {
  let e;
  return Ma.tasks.size === 0 && Ma.tick(RT), {
    promise: new Promise((n) => {
      Ma.tasks.add(e = { c: t, f: n });
    }),
    abort() {
      Ma.tasks.delete(e);
    }
  };
}
function x1(t, e) {
  Gd(() => {
    t.dispatchEvent(new CustomEvent(e));
  });
}
function YY(t) {
  if (t === "float") return "cssFloat";
  if (t === "offset") return "cssOffset";
  if (t.startsWith("--")) return t;
  const e = t.split("-");
  return e.length === 1 ? e[0] : e[0] + e.slice(1).map(
    /** @param {any} word */
    (n) => n[0].toUpperCase() + n.slice(1)
  ).join("");
}
function vA(t) {
  const e = {}, n = t.split(";");
  for (const r of n) {
    const [i, s] = r.split(":");
    if (!i || s === void 0) break;
    const o = YY(i.trim());
    e[o] = s.trim();
  }
  return e;
}
const XY = (t) => t;
function xA(t, e, n) {
  var r = (
    /** @type {EachItem} */
    Ay
  ), i, s, o, l = null;
  r.a ??= {
    element: t,
    measure() {
      i = this.element.getBoundingClientRect();
    },
    apply() {
      if (o?.abort(), s = this.element.getBoundingClientRect(), i.left !== s.left || i.right !== s.right || i.top !== s.top || i.bottom !== s.bottom) {
        const a = e()(this.element, { from: i, to: s }, n?.());
        o = ub(this.element, a, void 0, 1, () => {
          o?.abort(), o = void 0;
        });
      }
    },
    fix() {
      if (!t.getAnimations().length) {
        var { position: a, width: u, height: c } = getComputedStyle(t);
        if (a !== "absolute" && a !== "fixed") {
          var f = (
            /** @type {HTMLElement | SVGElement} */
            t.style
          );
          l = {
            position: f.position,
            width: f.width,
            height: f.height,
            transform: f.transform
          }, f.position = "absolute", f.width = u, f.height = c;
          var d = t.getBoundingClientRect();
          if (i.left !== d.left || i.top !== d.top) {
            var p = `translate(${i.left - d.left}px, ${i.top - d.top}px)`;
            f.transform = f.transform ? `${f.transform} ${p}` : p;
          }
        }
      }
    },
    unfix() {
      if (l) {
        var a = (
          /** @type {HTMLElement | SVGElement} */
          t.style
        );
        a.position = l.position, a.width = l.width, a.height = l.height, a.transform = l.transform;
      }
    }
  }, r.a.element = t;
}
function cp(t, e, n, r) {
  var i = (t & XK) !== 0, s = (t & QK) !== 0, o = i && s, l = (t & JK) !== 0, a = o ? "both" : i ? "in" : "out", u, c = e.inert, f = e.style.overflow, d, p;
  function m() {
    return Gd(() => u ??= n()(e, r?.() ?? /** @type {P} */
    {}, {
      direction: a
    }));
  }
  var y = {
    is_global: l,
    in() {
      if (e.inert = c, !i) {
        p?.abort(), p?.reset?.();
        return;
      }
      s || d?.abort(), x1(e, "introstart"), d = ub(e, m(), p, 1, () => {
        x1(e, "introend"), d?.abort(), d = u = void 0, e.style.overflow = f;
      });
    },
    out(k) {
      if (!s) {
        k?.(), u = void 0;
        return;
      }
      e.inert = !0, x1(e, "outrostart"), p = ub(e, m(), d, 0, () => {
        x1(e, "outroend"), k?.();
      });
    },
    stop: () => {
      d?.abort(), p?.abort();
    }
  }, b = (
    /** @type {Effect} */
    Vt
  );
  if ((b.transitions ??= []).push(y), i && k_) {
    var v = l;
    if (!v) {
      for (var _ = (
        /** @type {Effect | null} */
        b.parent
      ); _ && (_.f & Ya) !== 0; )
        for (; (_ = _.parent) && (_.f & sa) === 0; )
          ;
      v = !_ || (_.f & Vg) !== 0;
    }
    v && Kd(() => {
      Gs(() => y.in());
    });
  }
}
function ub(t, e, n, r, i) {
  var s = r === 1;
  if (Ch(e)) {
    var o, l = !1;
    return nu(() => {
      if (!l) {
        var b = e({ direction: s ? "in" : "out" });
        o = ub(t, b, n, r, i);
      }
    }), {
      abort: () => {
        l = !0, o?.abort();
      },
      deactivate: () => o.deactivate(),
      reset: () => o.reset(),
      t: () => o.t()
    };
  }
  if (n?.deactivate(), !e?.duration)
    return i(), {
      abort: zt,
      deactivate: zt,
      reset: zt,
      t: () => r
    };
  const { delay: a = 0, css: u, tick: c, easing: f = XY } = e;
  var d = [];
  if (s && n === void 0 && (c && c(0, 1), u)) {
    var p = vA(u(0, 1));
    d.push(p, p);
  }
  var m = () => 1 - r, y = t.animate(d, { duration: a, fill: "forwards" });
  return y.onfinish = () => {
    y.cancel();
    var b = n?.t() ?? 1 - r;
    n?.abort();
    var v = r - b, _ = (
      /** @type {number} */
      e.duration * Math.abs(v)
    ), k = [];
    if (_ > 0) {
      var S = !1;
      if (u)
        for (var C = Math.ceil(_ / 16.666666666666668), E = 0; E <= C; E += 1) {
          var A = b + v * f(E / C), O = vA(u(A, 1 - A));
          k.push(O), S ||= O.overflow === "hidden";
        }
      S && (t.style.overflow = "hidden"), m = () => {
        var T = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          y.currentTime
        );
        return b + v * f(T / _);
      }, c && KY(() => {
        if (y.playState !== "running") return !1;
        var T = m();
        return c(T, 1 - T), !0;
      });
    }
    y = t.animate(k, { duration: _, fill: "forwards" }), y.onfinish = () => {
      m = () => r, c?.(r, 1 - r), i();
    };
  }, {
    abort: () => {
      y && (y.cancel(), y.effect = null, y.onfinish = zt);
    },
    deactivate: () => {
      i = zt;
    },
    reset: () => {
      r === 0 && c?.(1, 0);
    },
    t: () => m()
  };
}
function QY(t, e, n = e) {
  var r = /* @__PURE__ */ new WeakSet();
  gY(t, "input", async (i) => {
    var s = i ? t.defaultValue : t.value;
    if (s = ww(t) ? _w(s) : s, n(s), $n !== null && r.add($n), await bY(), s !== (s = e())) {
      var o = t.selectionStart, l = t.selectionEnd, a = t.value.length;
      if (t.value = s ?? "", l !== null) {
        var u = t.value.length;
        o === l && l === a && u > a ? (t.selectionStart = u, t.selectionEnd = u) : (t.selectionStart = o, t.selectionEnd = Math.min(l, u));
      }
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (Ct && t.defaultValue !== t.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  Gs(e) == null && t.value) && (n(ww(t) ? _w(t.value) : t.value), $n !== null && r.add($n)), Nv(() => {
    var i = e();
    if (t === document.activeElement) {
      var s = (
        /** @type {Batch} */
        Sy ?? $n
      );
      if (r.has(s))
        return;
    }
    ww(t) && i === _w(t.value) || t.type === "date" && !i && !t.value || i !== t.value && (t.value = i ?? "");
  });
}
function ww(t) {
  var e = t.type;
  return e === "number" || e === "range";
}
function _w(t) {
  return t === "" ? null : +t;
}
class Qk {
  /** */
  #e = /* @__PURE__ */ new WeakMap();
  /** @type {ResizeObserver | undefined} */
  #t;
  /** @type {ResizeObserverOptions} */
  #n;
  /** @static */
  static entries = /* @__PURE__ */ new WeakMap();
  /** @param {ResizeObserverOptions} options */
  constructor(e) {
    this.#n = e;
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(e, n) {
    var r = this.#e.get(e) || /* @__PURE__ */ new Set();
    return r.add(n), this.#e.set(e, r), this.#r().observe(e, this.#n), () => {
      var i = this.#e.get(e);
      i.delete(n), i.size === 0 && (this.#e.delete(e), this.#t.unobserve(e));
    };
  }
  #r() {
    return this.#t ?? (this.#t = new ResizeObserver(
      /** @param {any} entries */
      (e) => {
        for (var n of e) {
          Qk.entries.set(n.target, n);
          for (var r of this.#e.get(n.target) || [])
            r(n);
        }
      }
    ));
  }
}
var JY = /* @__PURE__ */ new Qk({
  box: "border-box"
});
function Ko(t, e, n) {
  var r = JY.observe(t, () => n(t[e]));
  Kd(() => (Gs(() => n(t[e])), r));
}
function wA(t, e) {
  return t === e || t?.[jl] === e;
}
function Yo(t = {}, e, n, r) {
  return Kd(() => {
    var i, s;
    return Nv(() => {
      i = s, s = [], Gs(() => {
        t !== n(...s) && (e(t, ...s), i && wA(n(...i), t) && e(null, ...i));
      });
    }), () => {
      nu(() => {
        s && wA(n(...s), t) && e(null, ...s);
      });
    };
  }), t;
}
function Jk(t, e, n) {
  if (t == null)
    return e(void 0), n && n(void 0), zt;
  const r = Gs(
    () => t.subscribe(
      e,
      // @ts-expect-error
      n
    )
  );
  return r.unsubscribe ? () => r.unsubscribe() : r;
}
const mh = [];
function ZY(t, e) {
  return {
    subscribe: qh(t, e).subscribe
  };
}
function qh(t, e = zt) {
  let n = null;
  const r = /* @__PURE__ */ new Set();
  function i(l) {
    if (Uk(t, l) && (t = l, n)) {
      const a = !mh.length;
      for (const u of r)
        u[1](), mh.push(u, t);
      if (a) {
        for (let u = 0; u < mh.length; u += 2)
          mh[u][0](mh[u + 1]);
        mh.length = 0;
      }
    }
  }
  function s(l) {
    i(l(
      /** @type {T} */
      t
    ));
  }
  function o(l, a = zt) {
    const u = [l, a];
    return r.add(u), r.size === 1 && (n = e(i, s) || zt), l(
      /** @type {T} */
      t
    ), () => {
      r.delete(u), r.size === 0 && n && (n(), n = null);
    };
  }
  return { set: i, update: s, subscribe: o };
}
function eX(t, e, n) {
  const r = !Array.isArray(t), i = r ? [t] : t;
  if (!i.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const s = e.length < 2;
  return ZY(n, (o, l) => {
    let a = !1;
    const u = [];
    let c = 0, f = zt;
    const d = () => {
      if (c)
        return;
      f();
      const m = e(r ? u[0] : u, o, l);
      s ? o(m) : f = typeof m == "function" ? m : zt;
    }, p = i.map(
      (m, y) => Jk(
        m,
        (b) => {
          u[y] = b, c &= ~(1 << y), a && d();
        },
        () => {
          c |= 1 << y;
        }
      )
    );
    return a = !0, d(), function() {
      EF(p), f(), a = !1;
    };
  });
}
function tX(t) {
  let e;
  return Jk(t, (n) => e = n)(), e;
}
let w1 = !1, A_ = Symbol();
function gi(t, e, n) {
  const r = n[e] ??= {
    store: null,
    source: /* @__PURE__ */ Gk(void 0),
    unsubscribe: zt
  };
  if (r.store !== t && !(A_ in n))
    if (r.unsubscribe(), r.store = t ?? null, t == null)
      r.source.v = void 0, r.unsubscribe = zt;
    else {
      var i = !0;
      r.unsubscribe = Jk(t, (s) => {
        i ? r.source.v = s : ae(r.source, s);
      }), i = !1;
    }
  return t && A_ in n ? tX(t) : x(r.source);
}
function _A(t, e) {
  return t.set(e), e;
}
function Xs() {
  const t = {};
  function e() {
    Iv(() => {
      for (var n in t)
        t[n].unsubscribe();
      jk(t, A_, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [t, e];
}
function nX(t) {
  var e = w1;
  try {
    return w1 = !1, [t(), w1];
  } finally {
    w1 = e;
  }
}
const rX = {
  get(t, e) {
    if (!t.exclude.includes(e))
      return t.props[e];
  },
  set(t, e) {
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    if (!t.exclude.includes(e) && e in t.props)
      return {
        enumerable: !0,
        configurable: !0,
        value: t.props[e]
      };
  },
  has(t, e) {
    return t.exclude.includes(e) ? !1 : e in t.props;
  },
  ownKeys(t) {
    return Reflect.ownKeys(t.props).filter((e) => !t.exclude.includes(e));
  }
};
// @__NO_SIDE_EFFECTS__
function zr(t, e, n) {
  return new Proxy(
    { props: t, exclude: e },
    rX
  );
}
const iX = {
  get(t, e) {
    let n = t.props.length;
    for (; n--; ) {
      let r = t.props[n];
      if (Ch(r) && (r = r()), typeof r == "object" && r !== null && e in r) return r[e];
    }
  },
  set(t, e, n) {
    let r = t.props.length;
    for (; r--; ) {
      let i = t.props[r];
      Ch(i) && (i = i());
      const s = qu(i, e);
      if (s && s.set)
        return s.set(n), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    let n = t.props.length;
    for (; n--; ) {
      let r = t.props[n];
      if (Ch(r) && (r = r()), typeof r == "object" && r !== null && e in r) {
        const i = qu(r, e);
        return i && !i.configurable && (i.configurable = !0), i;
      }
    }
  },
  has(t, e) {
    if (e === jl || e === Lk) return !1;
    for (let n of t.props)
      if (Ch(n) && (n = n()), n != null && e in n) return !0;
    return !1;
  },
  ownKeys(t) {
    const e = [];
    for (let n of t.props)
      if (Ch(n) && (n = n()), !!n) {
        for (const r in n)
          e.includes(r) || e.push(r);
        for (const r of Object.getOwnPropertySymbols(n))
          e.includes(r) || e.push(r);
      }
    return e;
  }
};
function sX(...t) {
  return new Proxy({ props: t }, iX);
}
function ct(t, e, n, r) {
  var i = (n & KK) !== 0, s = (n & YK) !== 0, o = (
    /** @type {V} */
    r
  ), l = !0, a = () => (l && (l = !1, o = s ? Gs(
    /** @type {() => V} */
    r
  ) : (
    /** @type {V} */
    r
  )), o), u;
  if (i) {
    var c = jl in t || Lk in t;
    u = qu(t, e)?.set ?? (c && e in t ? (_) => t[e] = _ : void 0);
  }
  var f, d = !1;
  i ? [f, d] = nX(() => (
    /** @type {V} */
    t[e]
  )) : f = /** @type {V} */
  t[e], f === void 0 && r !== void 0 && (f = a(), u && (LK(), u(f)));
  var p;
  if (p = () => {
    var _ = (
      /** @type {V} */
      t[e]
    );
    return _ === void 0 ? a() : (l = !0, _);
  }, (n & GK) === 0)
    return p;
  if (u) {
    var m = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(_, k) {
        return arguments.length > 0 ? ((!k || m || d) && u(k ? p() : _), _) : p();
      })
    );
  }
  var y = !1, b = ((n & WK) !== 0 ? Mv : XF)(() => (y = !1, p()));
  i && x(b);
  var v = (
    /** @type {Effect} */
    Vt
  );
  return (
    /** @type {() => V} */
    (function(_, k) {
      if (arguments.length > 0) {
        const S = k ? x(b) : i ? ho(_) : _;
        return ae(b, S), y = !0, o !== void 0 && (o = S), _;
      }
      return Lf && y || (v.f & zu) !== 0 ? b.v : x(b);
    })
  );
}
var oX = /* @__PURE__ */ ge('<div class="bg-white dark:bg-black rounded-md flex flex-col overflow-hidden"><div class="p-2 bg-slate-100"> </div> <!></div>'), lX = /* @__PURE__ */ ge('<div class="w-full h-full flex flex-row flex-wrap gap-2 overflow-y-scroll"></div>');
function aX(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ Ee(100), r = /* @__PURE__ */ Ee(100), i = /* @__PURE__ */ K(() => Object.keys(e.charts)), s = /* @__PURE__ */ K(() => x(n) / 3 - 10), o = 300;
  var l = lX();
  Bt(l, 20, () => x(i), (a) => a, (a, u) => {
    var c = oX();
    let f;
    var d = J(c), p = J(d, !0);
    Q(d);
    var m = ue(d, 2);
    Xa(m, () => e.chartView, () => ({ id: u, width: x(s), height: o })), Q(c), ke(() => {
      f = ht(c, "", f, { width: `${x(s) ?? ""}px` }), ut(p, e.charts[u].title);
    }), X(a, c);
  }), Q(l), Ko(l, "clientWidth", (a) => ae(n, a)), Ko(l, "clientHeight", (a) => ae(r, a)), X(t, l), st();
}
function MT(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function kA(t, { from: e, to: n }, r = {}) {
  var { delay: i = 0, duration: s = (E) => Math.sqrt(E) * 120, easing: o = MT } = r, l = getComputedStyle(t), a = l.transform === "none" ? "" : l.transform, [u, c] = l.transformOrigin.split(" ").map(parseFloat);
  u /= t.clientWidth, c /= t.clientHeight;
  var f = uX(t), d = t.clientWidth / n.width / f, p = t.clientHeight / n.height / f, m = e.left + e.width * u, y = e.top + e.height * c, b = n.left + n.width * u, v = n.top + n.height * c, _ = (m - b) * d, k = (y - v) * p, S = e.width / n.width, C = e.height / n.height;
  return {
    delay: i,
    duration: typeof s == "function" ? s(Math.sqrt(_ * _ + k * k)) : s,
    easing: o,
    css: (E, A) => {
      var O = A * _, T = A * k, $ = E + A * S, P = E + A * C;
      return `transform: ${a} translate(${O}px, ${T}px) scale(${$}, ${P});`;
    }
  };
}
function uX(t) {
  if ("currentCSSZoom" in t)
    return (
      /** @type {number} */
      t.currentCSSZoom
    );
  for (var e = t, n = 1; e !== null; )
    n *= +getComputedStyle(e).zoom, e = /** @type {Element | null} */
    e.parentElement;
  return n;
}
function cX(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function fp(t, { delay: e = 0, duration: n = 400, easing: r = cX, axis: i = "y" } = {}) {
  const s = getComputedStyle(t), o = +s.opacity, l = i === "y" ? "height" : "width", a = parseFloat(s[l]), u = i === "y" ? ["top", "bottom"] : ["left", "right"], c = u.map(
    (v) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${v[0].toUpperCase()}${v.slice(1)}`
    )
  ), f = parseFloat(s[`padding${c[0]}`]), d = parseFloat(s[`padding${c[1]}`]), p = parseFloat(s[`margin${c[0]}`]), m = parseFloat(s[`margin${c[1]}`]), y = parseFloat(
    s[`border${c[0]}Width`]
  ), b = parseFloat(
    s[`border${c[1]}Width`]
  );
  return {
    delay: e,
    duration: n,
    easing: r,
    css: (v) => `overflow: hidden;opacity: ${Math.min(v * 20, 1) * o};${l}: ${v * a}px;padding-${u[0]}: ${v * f}px;padding-${u[1]}: ${v * d}px;margin-${u[0]}: ${v * p}px;margin-${u[1]}: ${v * m}px;border-${u[0]}-width: ${v * y}px;border-${u[1]}-width: ${v * b}px;min-${l}: 0`
  };
}
var fX = /* @__PURE__ */ ge("<div></div>");
function CA(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  function r(s, o) {
    s.preventDefault();
    let l = s.pageX, a = s.pageY, u = (f) => {
      f.preventDefault();
      let d = f.pageX - l, p = f.pageY - a;
      o(d, p);
    }, c = () => {
      window.removeEventListener("mousemove", u), window.removeEventListener("mouseup", c);
    };
    window.addEventListener("mousemove", u), window.addEventListener("mouseup", c);
  }
  var i = fX();
  i.__mousedown = (s) => {
    let o = e.value;
    r(s, (l, a) => {
      let u = o + (e.axis == "x" ? l : a) * e.scaler;
      u < e.min && (u = n.min), u > e.max && (u = n.max), e.onChange(u);
    });
  }, ke(() => er(i, 1, `${e.class ?? ""} ${e.axis == "x" ? "cursor-col-resize" : "cursor-row-resize"}`)), X(t, i), st();
}
ir(["mousedown"]);
function hX(t, e = "") {
  let n = 1, r;
  do
    r = e + n, n++;
  while (r in t);
  return r;
}
let E_ = [], PT = [];
(() => {
  let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, n = 0; e < t.length; e++)
    (e % 2 ? PT : E_).push(n = n + t[e]);
})();
function dX(t) {
  if (t < 768) return !1;
  for (let e = 0, n = E_.length; ; ) {
    let r = e + n >> 1;
    if (t < E_[r]) n = r;
    else if (t >= PT[r]) e = r + 1;
    else return !0;
    if (e == n) return !1;
  }
}
function SA(t) {
  return t >= 127462 && t <= 127487;
}
const AA = 8205;
function pX(t, e, n = !0, r = !0) {
  return (n ? IT : gX)(t, e, r);
}
function IT(t, e, n) {
  if (e == t.length) return e;
  e && NT(t.charCodeAt(e)) && BT(t.charCodeAt(e - 1)) && e--;
  let r = kw(t, e);
  for (e += EA(r); e < t.length; ) {
    let i = kw(t, e);
    if (r == AA || i == AA || n && dX(i))
      e += EA(i), r = i;
    else if (SA(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && SA(kw(t, o)); )
        s++, o -= 2;
      if (s % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function gX(t, e, n) {
  for (; e > 0; ) {
    let r = IT(t, e - 2, n);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function kw(t, e) {
  let n = t.charCodeAt(e);
  if (!BT(n) || e + 1 == t.length) return n;
  let r = t.charCodeAt(e + 1);
  return NT(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function NT(t) {
  return t >= 56320 && t < 57344;
}
function BT(t) {
  return t >= 55296 && t < 56320;
}
function EA(t) {
  return t < 65536 ? 1 : 2;
}
let rn = class LT {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, n, r) {
    [e, n] = vd(this, e, n);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      i,
      1
      /* Open.From */
    ), Sl.from(i, this.length - (n - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, n = this.length) {
    [e, n] = vd(this, e, n);
    let r = [];
    return this.decompose(e, n, r, 0), Sl.from(r, n - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Sp(this), s = new Sp(e);
    for (let o = n, l = n; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (l += i.value.length, i.done || l >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Sp(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, n = this.length) {
    return new $T(this, e, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, n) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new zT(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? LT.empty : e.length <= 32 ? new hr(e) : Sl.from(hr.split(e, []));
  }
};
class hr extends rn {
  constructor(e, n = mX(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = i + o.length;
      if ((n ? r : l) >= e)
        return new yX(i, l, r, o);
      i = l + 1, r++;
    }
  }
  decompose(e, n, r, i) {
    let s = e <= 0 && n >= this.length ? this : new hr(DA(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(), l = Ey(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        r.push(new hr(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        r.push(new hr(l.slice(0, a)), new hr(l.slice(a)));
      }
    } else
      r.push(s);
  }
  replace(e, n, r) {
    if (!(r instanceof hr))
      return super.replace(e, n, r);
    [e, n] = vd(this, e, n);
    let i = Ey(this.text, Ey(r.text, DA(this.text, 0, e)), n), s = this.length + r.length - (n - e);
    return i.length <= 32 ? new hr(i, s) : Sl.from(hr.split(i, []), s);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = vd(this, e, n);
    let i = "";
    for (let s = 0, o = 0; s <= n && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (i += r), e < a && n > s && (i += l.slice(Math.max(0, e - s), n - s)), s = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let r = [], i = -1;
    for (let s of e)
      r.push(s), i += s.length + 1, r.length == 32 && (n.push(new hr(r, i)), r = [], i = -1);
    return i > -1 && n.push(new hr(r, i)), n;
  }
}
class Sl extends rn {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = i + o.length, a = r + o.lines - 1;
      if ((n ? a : l) >= e)
        return o.lineInner(e, n, r, i);
      i = l + 1, r = a + 1;
    }
  }
  decompose(e, n, r, i) {
    for (let s = 0, o = 0; o <= n && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && n >= o) {
        let u = i & ((o <= e ? 1 : 0) | (a >= n ? 2 : 0));
        o >= e && a <= n && !u ? r.push(l) : l.decompose(e - o, n - o, r, u);
      }
      o = a + 1;
    }
  }
  replace(e, n, r) {
    if ([e, n] = vd(this, e, n), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], l = s + o.length;
        if (e >= s && n <= l) {
          let a = o.replace(e - s, n - s, r), u = this.lines - o.lines + a.lines;
          if (a.lines < u >> 4 && a.lines > u >> 6) {
            let c = this.children.slice();
            return c[i] = a, new Sl(c, this.length - (n - e) + r.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, n, r);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = vd(this, e, n);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= n; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (i += r), e < a && n > o && (i += l.sliceString(e - o, n - o, r)), o = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof Sl))
      return 0;
    let r = 0, [i, s, o, l] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += n, s += n) {
      if (i == o || s == l)
        return r;
      let a = this.children[i], u = e.children[s];
      if (a != u)
        return r + a.scanIdentical(u, n);
      r += a.length + 1;
    }
  }
  static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let p of e)
      r += p.lines;
    if (r < 32) {
      let p = [];
      for (let m of e)
        m.flatten(p);
      return new hr(p, n);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, l = [], a = 0, u = -1, c = [];
    function f(p) {
      let m;
      if (p.lines > s && p instanceof Sl)
        for (let y of p.children)
          f(y);
      else p.lines > o && (a > o || !a) ? (d(), l.push(p)) : p instanceof hr && a && (m = c[c.length - 1]) instanceof hr && p.lines + m.lines <= 32 ? (a += p.lines, u += p.length + 1, c[c.length - 1] = new hr(m.text.concat(p.text), m.length + 1 + p.length)) : (a + p.lines > i && d(), a += p.lines, u += p.length + 1, c.push(p));
    }
    function d() {
      a != 0 && (l.push(c.length == 1 ? c[0] : Sl.from(c, u)), u = -1, a = c.length = 0);
    }
    for (let p of e)
      f(p);
    return d(), l.length == 1 ? l[0] : new Sl(l, n);
  }
}
rn.empty = /* @__PURE__ */ new hr([""], 0);
function mX(t) {
  let e = -1;
  for (let n of t)
    e += n.length + 1;
  return e;
}
function Ey(t, e, n = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < t.length && i <= r; s++) {
    let l = t[s], a = i + l.length;
    a >= n && (a > r && (l = l.slice(0, r - i)), i < n && (l = l.slice(n - i)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), i = a + 1;
  }
  return e;
}
function DA(t, e, n) {
  return Ey(t, [""], e, n);
}
class Sp {
  constructor(e, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof hr ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, l = i instanceof hr ? i.text.length : i.children.length;
      if (o == (n > 0 ? l : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[r] += n, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof hr) {
        let a = i.text[o + (n < 0 ? -1 : 0)];
        if (this.offsets[r] += n, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : n > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = i.children[o + (n < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(a), this.offsets.push(n > 0 ? 1 : (a instanceof hr ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class $T {
  constructor(e, n, r) {
    this.value = "", this.done = !1, this.cursor = new Sp(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class zT {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (rn.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Sp.prototype[Symbol.iterator] = $T.prototype[Symbol.iterator] = zT.prototype[Symbol.iterator] = function() {
  return this;
});
class yX {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function vd(t, e, n) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))];
}
function Yr(t, e, n = !0, r = !0) {
  return pX(t, e, n, r);
}
function bX(t) {
  return t >= 56320 && t < 57344;
}
function vX(t) {
  return t >= 55296 && t < 56320;
}
function Ji(t, e) {
  let n = t.charCodeAt(e);
  if (!vX(n) || e + 1 == t.length)
    return n;
  let r = t.charCodeAt(e + 1);
  return bX(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function Zk(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Al(t) {
  return t < 65536 ? 1 : 2;
}
const D_ = /\r\n?|\n/;
var Kr = /* @__PURE__ */ (function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
})(Kr || (Kr = {}));
class ql {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      e += r < 0 ? this.sections[n] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let s = this.sections[n++], o = this.sections[n++];
      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, n = !1) {
    O_(this, e, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new ql(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : jT(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, n = !1) {
    return e.empty ? this : F_(this, e, n);
  }
  mapPos(e, n = -1, r = Kr.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], u = i + l;
      if (a < 0) {
        if (u > e)
          return s + (e - i);
        s += l;
      } else {
        if (r != Kr.Simple && u >= e && (r == Kr.TrackDel && i < e && u > e || r == Kr.TrackBefore && i < e || r == Kr.TrackAfter && u > e))
          return null;
        if (u > e || u == e && n < 0 && !l)
          return e == i || n < 0 ? s : s + a;
        s += a;
      }
      i = u;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, n = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let s = this.sections[r++], o = this.sections[r++], l = i + s;
      if (o >= 0 && i <= n && l >= e)
        return i < e && l > n ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ql(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new ql(e);
  }
}
class Er extends ql {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return O_(this, (n, r, i, s, o) => e = e.replace(i, i + (r - n), o), !1), e;
  }
  mapDesc(e, n = !1) {
    return F_(this, e, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let n = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < n.length; i += 2) {
      let o = n[i], l = n[i + 1];
      if (l >= 0) {
        n[i] = l, n[i + 1] = o;
        let a = i >> 1;
        for (; r.length < a; )
          r.push(rn.empty);
        r.push(o ? e.slice(s, s + o) : rn.empty);
      }
      s += o;
    }
    return new Er(n, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the
  returned value will represent the change `docA` â†’ `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : jT(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, n = !1) {
    return e.empty ? this : F_(this, e, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, n = !1) {
    O_(this, e, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ql.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let n = [], r = [], i = [], s = new Gp(this);
    e: for (let o = 0, l = 0; ; ) {
      let a = o == e.length ? 1e9 : e[o++];
      for (; l < a || l == a && s.len == 0; ) {
        if (s.done)
          break e;
        let c = Math.min(s.len, a - l);
        ti(i, c, -1);
        let f = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        ti(n, c, f), f > 0 && Ru(r, n, s.text), s.forward(c), l += c;
      }
      let u = e[o++];
      for (; l < u; ) {
        if (s.done)
          break e;
        let c = Math.min(s.len, u - l);
        ti(n, c, -1), ti(i, c, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(c), l += c;
      }
    }
    return {
      changes: new Er(n, r),
      filtered: ql.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n], i = this.sections[n + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, n, r) {
    let i = [], s = [], o = 0, l = null;
    function a(c = !1) {
      if (!c && !i.length)
        return;
      o < n && ti(i, n - o, -1);
      let f = new Er(i, s);
      l = l ? l.compose(f.map(l)) : f, i = [], s = [], o = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let f of c)
          u(f);
      else if (c instanceof Er) {
        if (c.length != n)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${n})`);
        a(), l = l ? l.compose(c.map(l)) : c;
      } else {
        let { from: f, to: d = f, insert: p } = c;
        if (f > d || f < 0 || d > n)
          throw new RangeError(`Invalid change range ${f} to ${d} (in doc of length ${n})`);
        let m = p ? typeof p == "string" ? rn.of(p.split(r || D_)) : p : rn.empty, y = m.length;
        if (f == d && y == 0)
          return;
        f < o && a(), f > o && ti(i, f - o, -1), ti(i, d - f, y), Ru(s, i, m), o = d;
      }
    }
    return u(e), a(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Er(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        n.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          n.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(rn.empty);
          r[i] = rn.of(s.slice(1)), n.push(s[0], r[i].length);
        }
      }
    }
    return new Er(n, r);
  }
  /**
  @internal
  */
  static createSet(e, n) {
    return new Er(e, n);
  }
}
function ti(t, e, n, r = !1) {
  if (e == 0 && n <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e, t[i + 1] += n) : t.push(e, n);
}
function Ru(t, e, n) {
  if (n.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < t.length)
    t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < r; )
      t.push(rn.empty);
    t.push(n);
  }
}
function O_(t, e, n) {
  let r = t.inserted;
  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
    let l = t.sections[o++], a = t.sections[o++];
    if (a < 0)
      i += l, s += l;
    else {
      let u = i, c = s, f = rn.empty;
      for (; u += l, c += a, a && r && (f = f.append(r[o - 2 >> 1])), !(n || o == t.sections.length || t.sections[o + 1] < 0); )
        l = t.sections[o++], a = t.sections[o++];
      e(i, u, s, c, f), i = u, s = c;
    }
  }
}
function F_(t, e, n, r = !1) {
  let i = [], s = r ? [] : null, o = new Gp(t), l = new Gp(e);
  for (let a = -1; ; ) {
    if (o.done && l.len || l.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && l.ins == -1) {
      let u = Math.min(o.len, l.len);
      ti(i, u, -1), o.forward(u), l.forward(u);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !n))) {
      let u = l.len;
      for (ti(i, l.ins, -1); u; ) {
        let c = Math.min(o.len, u);
        o.ins >= 0 && a < o.i && o.len <= c && (ti(i, 0, o.ins), s && Ru(s, i, o.text), a = o.i), o.forward(c), u -= c;
      }
      l.next();
    } else if (o.ins >= 0) {
      let u = 0, c = o.len;
      for (; c; )
        if (l.ins == -1) {
          let f = Math.min(c, l.len);
          u += f, c -= f, l.forward(f);
        } else if (l.ins == 0 && l.len < c)
          c -= l.len, l.next();
        else
          break;
      ti(i, u, a < o.i ? o.ins : 0), s && a < o.i && Ru(s, i, o.text), a = o.i, o.forward(o.len - c);
    } else {
      if (o.done && l.done)
        return s ? Er.createSet(i, s) : ql.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function jT(t, e, n = !1) {
  let r = [], i = n ? [] : null, s = new Gp(t), o = new Gp(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return i ? Er.createSet(r, i) : ql.create(r);
    if (s.ins == 0)
      ti(r, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      ti(r, 0, o.ins, l), i && Ru(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), u = r.length;
        if (s.ins == -1) {
          let c = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          ti(r, a, c, l), i && c && Ru(i, r, o.text);
        } else o.ins == -1 ? (ti(r, s.off ? 0 : s.len, a, l), i && Ru(i, r, s.textBit(a))) : (ti(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && Ru(i, r, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || r.length > u), s.forward2(a), o.forward(a);
      }
    }
  }
}
class Gp {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? rn.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, r = this.i - 2 >> 1;
    return r >= n.length && !e ? rn.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class qc {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.flags = r;
  }
  /**
  The anchor of the rangeâ€”the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, n = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new qc(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return de.range(e, n);
    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return de.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return de.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new qc(e, n, r);
  }
}
class de {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, n = -1) {
    return e.empty ? this : de.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new de([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, n = !0) {
    return de.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, n = this.mainIndex) {
    let r = this.ranges.slice();
    return r[n] = e, de.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new de(e.ranges.map((n) => qc.fromJSON(n)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, n = e) {
    return new de([de.range(e, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r)
        return de.normalized(e.slice(), n);
      r = s.to;
    }
    return new de(e, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, n = 0, r, i) {
    return qc.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, n, r, i) {
    let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return n < e ? qc.create(n, e, 48 | s) : qc.create(e, n, (n > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, n = 0) {
    let r = e[n];
    e.sort((i, s) => i.from - s.from), n = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        i <= n && n--, e.splice(--i, 2, s.anchor > s.head ? de.range(a, l) : de.range(l, a));
      }
    }
    return new de(e, n);
  }
}
function qT(t, e) {
  for (let n of t.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
let e6 = 0;
class ze {
  constructor(e, n, r, i, s) {
    this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = e6++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ze(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : t6), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Dy([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Dy(e, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Dy(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));
  }
}
function t6(t, e) {
  return t == e || t.length == e.length && t.every((n, r) => n === e[r]);
}
class Dy {
  constructor(e, n, r, i) {
    this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = e6++;
  }
  dynamicSlot(e) {
    var n;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, u = !1, c = [];
    for (let f of this.dependencies)
      f == "doc" ? a = !0 : f == "selection" ? u = !0 : (((n = e[f.id]) !== null && n !== void 0 ? n : 1) & 1) == 0 && c.push(e[f.id]);
    return {
      create(f) {
        return f.values[o] = r(f), 1;
      },
      update(f, d) {
        if (a && d.docChanged || u && (d.docChanged || d.selection) || T_(f, c)) {
          let p = r(f);
          if (l ? !OA(p, f.values[o], i) : !i(p, f.values[o]))
            return f.values[o] = p, 1;
        }
        return 0;
      },
      reconfigure: (f, d) => {
        let p, m = d.config.address[s];
        if (m != null) {
          let y = fb(d, m);
          if (this.dependencies.every((b) => b instanceof ze ? d.facet(b) === f.facet(b) : b instanceof jr ? d.field(b, !1) == f.field(b, !1) : !0) || (l ? OA(p = r(f), y, i) : i(p = r(f), y)))
            return f.values[o] = y, 0;
        } else
          p = r(f);
        return f.values[o] = p, 1;
      }
    };
  }
}
function OA(t, e, n) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!n(t[r], e[r]))
      return !1;
  return !0;
}
function T_(t, e) {
  let n = !1;
  for (let r of e)
    Ap(t, r) & 1 && (n = !0);
  return n;
}
function xX(t, e, n) {
  let r = n.map((a) => t[a.id]), i = n.map((a) => a.type), s = r.filter((a) => !(a & 1)), o = t[e.id] >> 1;
  function l(a) {
    let u = [];
    for (let c = 0; c < r.length; c++) {
      let f = fb(a, r[c]);
      if (i[c] == 2)
        for (let d of f)
          u.push(d);
      else
        u.push(f);
    }
    return e.combine(u);
  }
  return {
    create(a) {
      for (let u of r)
        Ap(a, u);
      return a.values[o] = l(a), 1;
    },
    update(a, u) {
      if (!T_(a, s))
        return 0;
      let c = l(a);
      return e.compare(c, a.values[o]) ? 0 : (a.values[o] = c, 1);
    },
    reconfigure(a, u) {
      let c = T_(a, r), f = u.config.facets[e.id], d = u.facet(e);
      if (f && !c && t6(n, f))
        return a.values[o] = d, 0;
      let p = l(a);
      return e.compare(p, d) ? (a.values[o] = d, 0) : (a.values[o] = p, 1);
    }
  };
}
const _1 = /* @__PURE__ */ ze.define({ static: !0 });
class jr {
  constructor(e, n, r, i, s) {
    this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let n = new jr(e6++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(_1).find((r) => r.field == this);
    return (n?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (r) => (r.values[n] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[n], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[n] = o, 1);
      },
      reconfigure: (r, i) => {
        let s = r.facet(_1), o = i.facet(_1), l;
        return (l = s.find((a) => a.field == this)) && l != o.find((a) => a.field == this) ? (r.values[n] = l.create(r), 1) : i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, _1.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Lc = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function V0(t) {
  return (e) => new UT(e, t);
}
const pc = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ V0(Lc.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ V0(Lc.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ V0(Lc.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ V0(Lc.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ V0(Lc.lowest)
};
class UT {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
}
class $v {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new R_(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return $v.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class R_ {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
}
class cb {
  constructor(e, n, r, i, s, o) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let d of wX(e, n, o))
      d instanceof jr ? i.push(d) : (s[d.facet.id] || (s[d.facet.id] = [])).push(d);
    let l = /* @__PURE__ */ Object.create(null), a = [], u = [];
    for (let d of i)
      l[d.id] = u.length << 1, u.push((p) => d.slot(p));
    let c = r?.config.facets;
    for (let d in s) {
      let p = s[d], m = p[0].facet, y = c && c[d] || [];
      if (p.every(
        (b) => b.type == 0
        /* Provider.Static */
      ))
        if (l[m.id] = a.length << 1 | 1, t6(y, p))
          a.push(r.facet(m));
        else {
          let b = m.combine(p.map((v) => v.value));
          a.push(r && m.compare(b, r.facet(m)) ? r.facet(m) : b);
        }
      else {
        for (let b of p)
          b.type == 0 ? (l[b.id] = a.length << 1 | 1, a.push(b.value)) : (l[b.id] = u.length << 1, u.push((v) => b.dynamicSlot(v)));
        l[m.id] = u.length << 1, u.push((b) => xX(b, m, p));
      }
    }
    let f = u.map((d) => d(l));
    return new cb(e, o, f, l, a, s);
  }
}
function wX(t, e, n) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = i.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let u = r[a].indexOf(o);
      u > -1 && r[a].splice(u, 1), o instanceof R_ && n.delete(o.compartment);
    }
    if (i.set(o, l), Array.isArray(o))
      for (let u of o)
        s(u, l);
    else if (o instanceof R_) {
      if (n.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(o.compartment) || o.inner;
      n.set(o.compartment, u), s(u, l);
    } else if (o instanceof UT)
      s(o.inner, o.prec);
    else if (o instanceof jr)
      r[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof Dy)
      r[l].push(o), o.facet.extensions && s(o.facet.extensions, Lc.default);
    else {
      let u = o.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(u, l);
    }
  }
  return s(t, Lc.default), r.reduce((o, l) => o.concat(l));
}
function Ap(t, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, r = t.status[n];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  t.status[n] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[n]);
  return t.status[n] = 2 | i;
}
function fb(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const HT = /* @__PURE__ */ ze.define(), M_ = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), VT = /* @__PURE__ */ ze.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), WT = /* @__PURE__ */ ze.define(), GT = /* @__PURE__ */ ze.define(), KT = /* @__PURE__ */ ze.define(), YT = /* @__PURE__ */ ze.define({
  combine: (t) => t.length ? t[0] : !1
});
class ru {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new _X();
  }
}
class _X {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new ru(this, e);
  }
}
class kX {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new St(this, e);
  }
}
class St {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new St(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new kX(e.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let s = i.map(n);
      s && r.push(s);
    }
    return r;
  }
}
St.reconfigure = /* @__PURE__ */ St.define();
St.appendConfig = /* @__PURE__ */ St.define();
class vr {
  constructor(e, n, r, i, s, o) {
    this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && qT(r, n.newLength), s.some((l) => l.type == vr.time) || (this.annotations = s.concat(vr.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, n, r, i, s, o) {
    return new vr(e, n, r, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let n = this.annotation(vr.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
}
vr.time = /* @__PURE__ */ ru.define();
vr.userEvent = /* @__PURE__ */ ru.define();
vr.addToHistory = /* @__PURE__ */ ru.define();
vr.remote = /* @__PURE__ */ ru.define();
function CX(t, e) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < t.length && (i == e.length || e[i] >= t[r]))
      s = t[r++], o = t[r++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return n;
    !n.length || n[n.length - 1] < s ? n.push(s, o) : n[n.length - 1] < o && (n[n.length - 1] = o);
  }
}
function XT(t, e, n) {
  var r;
  let i, s, o;
  return n ? (i = e.changes, s = Er.empty(e.changes.length), o = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: St.mapEffects(t.effects, i).concat(St.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function P_(t, e, n) {
  let r = e.selection, i = Uh(e.annotations);
  return e.userEvent && (i = i.concat(vr.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Er ? e.changes : Er.of(e.changes || [], n, t.facet(VT)),
    selection: r && (r instanceof de ? r : de.single(r.anchor, r.head)),
    effects: Uh(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function QT(t, e, n) {
  let r = P_(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (n = !1);
    let o = !!e[s].sequential;
    r = XT(r, P_(t, e[s], o ? r.changes.newLength : t.doc.length), o);
  }
  let i = vr.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return AX(n ? SX(i) : i);
}
function SX(t) {
  let e = t.startState, n = !0;
  for (let i of e.facet(WT)) {
    let s = i(t);
    if (s === !1) {
      n = !1;
      break;
    }
    Array.isArray(s) && (n = n === !0 ? s : CX(n, s));
  }
  if (n !== !0) {
    let i, s;
    if (n === !1)
      s = t.changes.invertedDesc, i = Er.empty(e.doc.length);
    else {
      let o = t.changes.filter(n);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    t = vr.create(e, i, t.selection && t.selection.map(s), St.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let r = e.facet(GT);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s instanceof vr ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof vr ? t = s[0] : t = QT(e, Uh(s), !1);
  }
  return t;
}
function AX(t) {
  let e = t.startState, n = e.facet(KT), r = t;
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s && Object.keys(s).length && (r = XT(r, P_(e, s, t.changes.newLength), !0));
  }
  return r == t ? t : vr.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
}
const EX = [];
function Uh(t) {
  return t == null ? EX : Array.isArray(t) ? t : [t];
}
var Wn = /* @__PURE__ */ (function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
})(Wn || (Wn = {}));
const DX = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let I_;
try {
  I_ = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function OX(t) {
  if (I_)
    return I_.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || n > "Â€" && (n.toUpperCase() != n.toLowerCase() || DX.test(n)))
      return !0;
  }
  return !1;
}
function FX(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Wn.Space;
    if (OX(e))
      return Wn.Word;
    for (let n = 0; n < t.length; n++)
      if (e.indexOf(t[n]) > -1)
        return Wn.Word;
    return Wn.Other;
  };
}
class nn {
  constructor(e, n, r, i, s, o) {
    this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Ap(this, l << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Ap(this, r), fb(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return QT(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let n = this.config, { base: r, compartments: i } = n;
    for (let l of e.effects)
      l.is($v.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((a, u) => i.set(u, a)), n = null), i.set(l.value.compartment, l.value.extension)) : l.is(St.reconfigure) ? (n = null, r = l.value) : l.is(St.appendConfig) && (n = null, r = Uh(r).concat(l.value));
    let s;
    n ? s = e.startState.values.slice() : (n = cb.resolve(r, i, this), s = new nn(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (a, u) => u.reconfigure(a, this), null).values);
    let o = e.startState.facet(M_) ? e.newSelection : e.newSelection.asSingle();
    new nn(n, e.newDoc, o, s, (l, a) => a.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: de.cursor(n.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), s = [r.range], o = Uh(r.effects);
    for (let l = 1; l < n.ranges.length; l++) {
      let a = e(n.ranges[l]), u = this.changes(a.changes), c = u.map(i);
      for (let d = 0; d < l; d++)
        s[d] = s[d].map(c);
      let f = i.mapDesc(u, !0);
      s.push(a.range.map(f)), i = i.compose(c), o = St.mapEffects(o, c).concat(St.mapEffects(Uh(a.effects), f));
    }
    return {
      changes: i,
      selection: de.create(s, n.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Er ? e : Er.of(e, this.doc.length, this.facet(nn.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return rn.of(e.split(this.facet(nn.lineSeparator) || D_));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (Ap(this, n), fb(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof jr && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, n = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s], l = e[s];
          i.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return nn.create({
      doc: e.doc,
      selection: de.fromJSON(e.selection),
      extensions: n.extensions ? i.concat([n.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorâ€”updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let n = cb.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof rn ? e.doc : rn.of((e.doc || "").split(n.staticFacet(nn.lineSeparator) || D_)), i = e.selection ? e.selection instanceof de ? e.selection : de.single(e.selection.anchor, e.selection.head) : de.single(0);
    return qT(i, r.length), n.staticFacet(M_) || (i = i.asSingle()), new nn(n, r, i, n.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(nn.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(nn.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(YT);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...n) {
    for (let r of this.facet(nn.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > n.length ? r : n[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, n, r = -1) {
    let i = [];
    for (let s of this.facet(HT))
      for (let o of s(this, n, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return FX(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: n, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, l = e - r;
    for (; o > 0; ) {
      let a = Yr(n, o, !1);
      if (s(n.slice(a, o)) != Wn.Word)
        break;
      o = a;
    }
    for (; l < i; ) {
      let a = Yr(n, l);
      if (s(n.slice(l, a)) != Wn.Word)
        break;
      l = a;
    }
    return o == l ? null : de.range(o + r, l + r);
  }
}
nn.allowMultipleSelections = M_;
nn.tabSize = /* @__PURE__ */ ze.define({
  combine: (t) => t.length ? t[0] : 4
});
nn.lineSeparator = VT;
nn.readOnly = YT;
nn.phrases = /* @__PURE__ */ ze.define({
  compare(t, e) {
    let n = Object.keys(t), r = Object.keys(e);
    return n.length == r.length && n.every((i) => t[i] == e[i]);
  }
});
nn.languageData = HT;
nn.changeFilter = WT;
nn.transactionFilter = GT;
nn.transactionExtender = KT;
$v.reconfigure = /* @__PURE__ */ St.define();
function iu(t, e, n = {}) {
  let r = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let o = i[s], l = r[s];
      if (l === void 0)
        r[s] = o;
      else if (!(l === o || o === void 0)) if (Object.hasOwnProperty.call(n, s))
        r[s] = n[s](l, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class xf {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, n = e) {
    return N_.create(e, n, this);
  }
}
xf.prototype.startSide = xf.prototype.endSide = 0;
xf.prototype.point = !1;
xf.prototype.mapMode = Kr.TrackDel;
let N_ = class JT {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.value = r;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new JT(e, n, r);
  }
};
function B_(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class n6 {
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, n, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, u = s[a] - e || (r ? this.value[a].endSide : this.value[a].startSide) - n;
      if (a == o)
        return u >= 0 ? o : l;
      u >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, n, r, i) {
    for (let s = this.findIndex(n, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, n) {
    let r = [], i = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let u = this.value[a], c = this.from[a] + e, f = this.to[a] + e, d, p;
      if (c == f) {
        let m = n.mapPos(c, u.startSide, u.mapMode);
        if (m == null || (d = p = m, u.startSide != u.endSide && (p = n.mapPos(c, u.endSide), p < d)))
          continue;
      } else if (d = n.mapPos(c, u.startSide), p = n.mapPos(f, u.endSide), d > p || d == p && u.startSide > 0 && u.endSide <= 0)
        continue;
      (p - d || u.endSide - u.startSide) < 0 || (o < 0 && (o = d), u.point && (l = Math.max(l, p - d)), r.push(u), i.push(d - o), s.push(p - o));
    }
    return { mapped: r.length ? new n6(i, s, r, l) : null, pos: o };
  }
}
class hn {
  constructor(e, n, r, i) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, n, r, i) {
    return new hn(e, n, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (n.length == 0 && !o)
      return this;
    if (r && (n = n.slice().sort(B_)), this.isEmpty)
      return n.length ? hn.of(n) : this;
    let l = new ZT(this, null, -1).goto(0), a = 0, u = [], c = new nc();
    for (; l.value || a < n.length; )
      if (a < n.length && (l.from - n[a].from || l.startSide - n[a].value.startSide) >= 0) {
        let f = n[a++];
        c.addInner(f.from, f.to, f.value) || u.push(f);
      } else l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == n.length || this.chunkEnd(l.chunkIndex) < n[a].from) && (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && c.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) && (c.addInner(l.from, l.to, l.value) || u.push(N_.create(l.from, l.to, l.value))), l.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? hn.empty : this.nextLayer.update({ add: u, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], u = e.touchesRange(l, l + a.length);
      if (u === !1)
        i = Math.max(i, a.maxPoint), n.push(a), r.push(e.mapPos(l));
      else if (u === !0) {
        let { mapped: c, pos: f } = a.map(l, e);
        c && (i = Math.max(i, c.maxPoint), n.push(c), r.push(f));
      }
    }
    let s = this.nextLayer.map(e);
    return n.length == 0 ? s : new hn(r, n, s || hn.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (n >= s && e <= s + o.length && o.between(s, e - s, n - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, n, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Kp.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, n = 0) {
    return Kp.from(e).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, n, r, i, s = -1) {
    let o = e.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= s), l = n.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= s), a = FA(o, l, r), u = new W0(o, a, s), c = new W0(l, a, s);
    r.iterGaps((f, d, p) => TA(u, f, c, d, p, i)), r.empty && r.length == 0 && TA(u, 0, c, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, n, r = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((c) => !c.isEmpty && n.indexOf(c) < 0), o = n.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = FA(s, o), a = new W0(s, l, 0).goto(r), u = new W0(o, l, 0).goto(r);
    for (; ; ) {
      if (a.to != u.to || !L_(a.active, u.active) || a.point && (!u.point || !a.point.eq(u.point)))
        return !1;
      if (a.to > i)
        return !0;
      a.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, n, r, i, s = -1) {
    let o = new W0(e, null, s).goto(n), l = n, a = o.openStart;
    for (; ; ) {
      let u = Math.min(o.to, r);
      if (o.point) {
        let c = o.activeForPoint(o.to), f = o.pointFrom < n ? c.length + 1 : o.point.startSide < 0 ? c.length : Math.min(c.length, a);
        i.point(l, u, o.point, c, f, o.pointRank), a = Math.min(o.openEnd(u), c.length);
      } else u > l && (i.span(l, u, o.active, a), a = o.openEnd(u));
      if (o.to > r)
        return a + (o.point && o.to > r ? 1 : 0);
      l = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, n = !1) {
    let r = new nc();
    for (let i of e instanceof N_ ? [e] : n ? TX(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return hn.empty;
    let n = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != hn.empty; i = i.nextLayer)
        n = new hn(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
    return n;
  }
}
hn.empty = /* @__PURE__ */ new hn([], [], null, -1);
function TX(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let r = t[n];
      if (B_(e, r) > 0)
        return t.slice().sort(B_);
      e = r;
    }
  return t;
}
hn.empty.nextLayer = hn.empty;
class nc {
  finishChunk(e) {
    this.chunks.push(new n6(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, n, r) {
    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new nc())).add(e, n, r);
  }
  /**
  @internal
  */
  addInner(e, n, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let r = n.value.length - 1;
    return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(hn.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let n = hn.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
}
function FA(t, e, n) {
  let r = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = r.get(s.chunk[o]);
      l != null && (n ? n.mapPos(l) : l) == s.chunkPos[o] && !n?.touchesRange(l, l + s.chunk[o].length) && i.add(s.chunk[o]);
    }
  return i;
}
class ZT {
  constructor(e, n, r, i = 0) {
    this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
        if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Kp {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new ZT(o, n, r, s));
    return i.length == 1 ? i[0] : new Kp(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let r of this.heap)
      r.goto(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Cw(this.heap, r);
    return this.next(), this;
  }
  forward(e, n) {
    for (let r of this.heap)
      r.forward(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Cw(this.heap, r);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Cw(this.heap, 0);
    }
  }
}
function Cw(t, e) {
  for (let n = t[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= t.length)
      break;
    let i = t[r];
    if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1], r++), n.compare(i) < 0)
      break;
    t[r] = n, t[e] = i, e = r;
  }
}
class W0 {
  constructor(e, n, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Kp.from(e, n, r);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    k1(this.active, e), k1(this.activeTo, e), k1(this.activeRank, e), this.minActive = RA(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; n < this.activeRank.length && (s - this.activeRank[n] || i - this.activeTo[n]) > 0; )
      n++;
    C1(this.active, n, r), C1(this.activeTo, n, i), C1(this.activeRank, n, s), e && C1(e, n, this.cursor.from), this.minActive = RA(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && k1(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      n++;
    return n;
  }
}
function TA(t, e, n, r, i, s) {
  t.goto(e), n.goto(r);
  let o = r + i, l = r, a = r - e;
  for (; ; ) {
    let u = t.to + a - n.to, c = u || t.endSide - n.endSide, f = c < 0 ? t.to + a : n.to, d = Math.min(f, o);
    if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && L_(t.activeForPoint(t.to), n.activeForPoint(n.to)) || s.comparePoint(l, d, t.point, n.point) : d > l && !L_(t.active, n.active) && s.compareRange(l, d, t.active, n.active), f > o)
      break;
    (u || t.openEnd != n.openEnd) && s.boundChange && s.boundChange(f), l = f, c <= 0 && t.next(), c >= 0 && n.next();
  }
}
function L_(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] != e[n] && !t[n].eq(e[n]))
      return !1;
  return !0;
}
function k1(t, e) {
  for (let n = e, r = t.length - 1; n < r; n++)
    t[n] = t[n + 1];
  t.pop();
}
function C1(t, e, n) {
  for (let r = t.length - 1; r >= e; r--)
    t[r + 1] = t[r];
  t[e] = n;
}
function RA(t, e) {
  let n = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i, r = e[i]);
  return n;
}
function Xd(t, e, n = t.length) {
  let r = 0;
  for (let i = 0; i < n && i < t.length; )
    t.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = Yr(t, i));
  return r;
}
function $_(t, e, n, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == t.length)
      break;
    s += t.charCodeAt(i) == 9 ? n - s % n : 1, i = Yr(t, i);
  }
  return r === !0 ? -1 : t.length;
}
const z_ = "Í¼", MA = typeof Symbol > "u" ? "__" + z_ : Symbol.for(z_), j_ = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), PA = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class rc {
  // :: (Object<Style>, ?{finish: ?(string) â†’ string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, u) {
      let c = [], f = /^@(\w+)\b/.exec(o[0]), d = f && f[1] == "keyframes";
      if (f && l == null) return a.push(o[0] + ";");
      for (let p in l) {
        let m = l[p];
        if (/&/.test(p))
          s(
            p.split(/,\s*/).map((y) => o.map((b) => y.replace(/&/, b))).reduce((y, b) => y.concat(b)),
            m,
            a
          );
        else if (m && typeof m == "object") {
          if (!f) throw new RangeError("The value of a property (" + p + ") should be a primitive value.");
          s(i(p), m, c, d);
        } else m != null && c.push(p.replace(/_.*/, "").replace(/[A-Z]/g, (y) => "-" + y.toLowerCase()) + ": " + m + ";");
      }
      (c.length || d) && a.push((r && !f && !u ? o.map(r) : o).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  // :: () â†’ string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () â†’ string
  // Generate a new unique CSS class name.
  static newName() {
    let e = PA[MA] || 1;
    return PA[MA] = e + 1, z_ + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, n, r) {
    let i = e[j_], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new RX(e, s), i.mount(Array.isArray(n) ? n : [n], e);
  }
}
let IA = /* @__PURE__ */ new Map();
class RX {
  constructor(e, n) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = IA.get(r);
      if (s) return e[j_] = s;
      this.sheet = new i.CSSStyleSheet(), IA.set(r, this);
    } else
      this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], e[j_] = this;
  }
  mount(e, n) {
    let r = this.sheet, i = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = this.modules.indexOf(l);
      if (a < s && a > -1 && (this.modules.splice(a, 1), s--, a = -1), a == -1) {
        if (this.modules.splice(s++, 0, l), r) for (let u = 0; u < l.rules.length; u++)
          r.insertRule(l.rules[u], i++);
      } else {
        for (; s < a; ) i += this.modules[s++].rules.length;
        i += l.rules.length, s++;
      }
    }
    if (r)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let o = "";
      for (let a = 0; a < this.modules.length; a++)
        o += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = o;
      let l = n.head || n;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var ic = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Yp = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, MX = typeof navigator < "u" && /Mac/.test(navigator.platform), PX = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Gr = 0; Gr < 10; Gr++) ic[48 + Gr] = ic[96 + Gr] = String(Gr);
for (var Gr = 1; Gr <= 24; Gr++) ic[Gr + 111] = "F" + Gr;
for (var Gr = 65; Gr <= 90; Gr++)
  ic[Gr] = String.fromCharCode(Gr + 32), Yp[Gr] = String.fromCharCode(Gr);
for (var Sw in ic) Yp.hasOwnProperty(Sw) || (Yp[Sw] = ic[Sw]);
function IX(t) {
  var e = MX && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || PX && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Yp : ic)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function Dn() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n) if (Object.prototype.hasOwnProperty.call(n, r)) {
      var i = n[r];
      typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) eR(t, arguments[e]);
  return t;
}
function eR(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var n = 0; n < e.length; n++) eR(t, e[n]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
let Oi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, q_ = typeof document < "u" ? document : { documentElement: { style: {} } };
const U_ = /* @__PURE__ */ /Edge\/(\d+)/.exec(Oi.userAgent), tR = /* @__PURE__ */ /MSIE \d/.test(Oi.userAgent), H_ = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Oi.userAgent), zv = !!(tR || H_ || U_), NA = !zv && /* @__PURE__ */ /gecko\/(\d+)/i.test(Oi.userAgent), Aw = !zv && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Oi.userAgent), NX = "webkitFontSmoothing" in q_.documentElement.style, V_ = !zv && /* @__PURE__ */ /Apple Computer/.test(Oi.vendor), BA = V_ && (/* @__PURE__ */ /Mobile\/\w+/.test(Oi.userAgent) || Oi.maxTouchPoints > 2);
var Le = {
  mac: BA || /* @__PURE__ */ /Mac/.test(Oi.platform),
  windows: /* @__PURE__ */ /Win/.test(Oi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Oi.platform),
  ie: zv,
  ie_version: tR ? q_.documentMode || 6 : H_ ? +H_[1] : U_ ? +U_[1] : 0,
  gecko: NA,
  gecko_version: NA ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Oi.userAgent) || [0, 0])[1] : 0,
  chrome: !!Aw,
  chrome_version: Aw ? +Aw[1] : 0,
  ios: BA,
  android: /* @__PURE__ */ /Android\b/.test(Oi.userAgent),
  webkit_version: NX ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Oi.userAgent) || [0, 0])[1] : 0,
  safari: V_,
  safari_version: V_ ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(Oi.userAgent) || [0, 0])[1] : 0,
  tabSize: q_.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function Xp(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function W_(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Oy(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return W_(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Qp(t) {
  return t.nodeType == 3 ? _f(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Ep(t, e, n, r) {
  return n ? LA(t, e, n, r, -1) || LA(t, e, n, r, 1) : !1;
}
function wf(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function hb(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function LA(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Xl(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = wf(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? Xl(t) : 0;
    } else
      return !1;
  }
}
function Xl(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function jv(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function BX(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function nR(t, e) {
  let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };
}
function LX(t, e, n, r, i, s, o, l) {
  let a = t.ownerDocument, u = a.defaultView || window;
  for (let c = t, f = !1; c && !f; )
    if (c.nodeType == 1) {
      let d, p = c == a.body, m = 1, y = 1;
      if (p)
        d = BX(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (f = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let _ = c.getBoundingClientRect();
        ({ scaleX: m, scaleY: y } = nR(c, _)), d = {
          left: _.left,
          right: _.left + c.clientWidth * m,
          top: _.top,
          bottom: _.top + c.clientHeight * y
        };
      }
      let b = 0, v = 0;
      if (i == "nearest")
        e.top < d.top ? (v = e.top - (d.top + o), n > 0 && e.bottom > d.bottom + v && (v = e.bottom - d.bottom + o)) : e.bottom > d.bottom && (v = e.bottom - d.bottom + o, n < 0 && e.top - v < d.top && (v = e.top - (d.top + o)));
      else {
        let _ = e.bottom - e.top, k = d.bottom - d.top;
        v = (i == "center" && _ <= k ? e.top + _ / 2 - k / 2 : i == "start" || i == "center" && n < 0 ? e.top - o : e.bottom - k + o) - d.top;
      }
      if (r == "nearest" ? e.left < d.left ? (b = e.left - (d.left + s), n > 0 && e.right > d.right + b && (b = e.right - d.right + s)) : e.right > d.right && (b = e.right - d.right + s, n < 0 && e.left < d.left + b && (b = e.left - (d.left + s))) : b = (r == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : r == "start" == l ? e.left - s : e.right - (d.right - d.left) + s) - d.left, b || v)
        if (p)
          u.scrollBy(b, v);
        else {
          let _ = 0, k = 0;
          if (v) {
            let S = c.scrollTop;
            c.scrollTop += v / y, k = (c.scrollTop - S) * y;
          }
          if (b) {
            let S = c.scrollLeft;
            c.scrollLeft += b / m, _ = (c.scrollLeft - S) * m;
          }
          e = {
            left: e.left - _,
            top: e.top - k,
            right: e.right - _,
            bottom: e.bottom - k
          }, _ && Math.abs(_ - b) < 1 && (r = "nearest"), k && Math.abs(k - v) < 1 && (i = "nearest");
        }
      if (p)
        break;
      (e.top < d.top || e.bottom > d.bottom || e.left < d.left || e.right > d.right) && (e = {
        left: Math.max(e.left, d.left),
        right: Math.min(e.right, d.right),
        top: Math.max(e.top, d.top),
        bottom: Math.min(e.bottom, d.bottom)
      }), c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function $X(t) {
  let e = t.ownerDocument, n, r;
  for (let i = t.parentNode; i && !(i == e.body || n && r); )
    if (i.nodeType == 1)
      !r && i.scrollHeight > i.clientHeight && (r = i), !n && i.scrollWidth > i.clientWidth && (n = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: n, y: r };
}
class zX {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: r } = e;
    this.set(n, Math.min(e.anchorOffset, n ? Xl(n) : 0), r, Math.min(e.focusOffset, r ? Xl(r) : 0));
  }
  set(e, n, r, i) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
  }
}
let Pc = null;
Le.safari && Le.safari_version >= 26 && (Pc = !1);
function rR(t) {
  if (t.setActive)
    return t.setActive();
  if (Pc)
    return t.focus(Pc);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (t.focus(Pc == null ? {
    get preventScroll() {
      return Pc = { preventScroll: !0 }, !0;
    }
  } : void 0), !Pc) {
    Pc = !1;
    for (let n = 0; n < e.length; ) {
      let r = e[n++], i = e[n++], s = e[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let $A;
function _f(t, e, n = e) {
  let r = $A || ($A = document.createRange());
  return r.setEnd(t, n), r.setStart(t, e), r;
}
function Hh(t, e, n, r) {
  let i = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let s = new KeyboardEvent("keydown", i);
  s.synthetic = !0, t.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", i);
  return o.synthetic = !0, t.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function jX(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function iR(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function qX(t, e) {
  let n = e.focusNode, r = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, Xl(n)); ; )
    if (r) {
      if (n.nodeType != 1)
        return !1;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (n = i, r = Xl(n));
    } else {
      if (n == t)
        return !0;
      r = wf(n), n = n.parentNode;
    }
}
function sR(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function oR(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r > 0)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r - 1], r = Xl(n);
    } else if (n.parentNode && !hb(n))
      r = wf(n), n = n.parentNode;
    else
      return null;
  }
}
function lR(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r < n.nodeValue.length)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r], r = 0;
    } else if (n.parentNode && !hb(n))
      r = wf(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class ri {
  constructor(e, n, r = !0) {
    this.node = e, this.offset = n, this.precise = r;
  }
  static before(e, n) {
    return new ri(e.parentNode, wf(e), n);
  }
  static after(e, n) {
    return new ri(e.parentNode, wf(e) + 1, n);
  }
}
const r6 = [];
class Sn {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let l = Sn.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, n), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && s != o.dom && (n.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = zA(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && n && n.node == r && (n.written = !0); s; )
        s = zA(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, n), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[n];
    else {
      let i = Xl(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Sn.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, n, r = 0) {
    let i = -1, s = -1, o = -1, l = -1;
    for (let a = 0, u = r, c = r; a < this.children.length; a++) {
      let f = this.children[a], d = u + f.length;
      if (u < e && d > n)
        return f.domBoundsAround(e, n, u);
      if (d >= e && i == -1 && (i = a, s = u), u > n && f.dom.parentNode == this.dom) {
        o = a, l = c;
        break;
      }
      c = d, u = d + f.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? r + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, r = r6) {
    this.markDirty();
    for (let i = e; i < n; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    r.length < 250 ? this.children.splice(e, n - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(n));
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new aR(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Sn.prototype.breakAfter = 0;
function zA(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class aR {
  constructor(e, n, r) {
    this.children = e, this.pos = n, this.i = r, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function uR(t, e, n, r, i, s, o, l, a) {
  let { children: u } = t, c = u.length ? u[e] : null, f = s.length ? s[s.length - 1] : null, d = f ? f.breakAfter : o;
  if (!(e == r && c && !o && !d && s.length < 2 && c.merge(n, i, s.length ? f : null, n == 0, l, a))) {
    if (r < u.length) {
      let p = u[r];
      p && (i < p.length || p.breakAfter && f?.breakAfter) ? (e == r && (p = p.split(i), i = 0), !d && f && p.merge(0, i, f, !0, 0, a) ? s[s.length - 1] = p : ((i || p.children.length && !p.children[0].length) && p.merge(0, i, null, !1, 0, a), s.push(p))) : p?.breakAfter && (f ? f.breakAfter = 1 : o = 1), r++;
    }
    for (c && (c.breakAfter = o, n > 0 && (!o && s.length && c.merge(n, c.length, s[0], !1, l, 0) ? c.breakAfter = s.shift().breakAfter : (n < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(n, c.length, null, !1, l, 0), e++)); e < r && s.length; )
      if (u[r - 1].become(s[s.length - 1]))
        r--, s.pop(), a = s.length ? 0 : l;
      else if (u[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && r < u.length && !u[e - 1].breakAfter && u[r].merge(0, 0, u[e - 1], !1, l, a) && e--, (e < r || s.length) && t.replaceChildren(e, r, s);
  }
}
function cR(t, e, n, r, i, s) {
  let o = t.childCursor(), { i: l, off: a } = o.findPos(n, 1), { i: u, off: c } = o.findPos(e, -1), f = e - n;
  for (let d of r)
    f += d.length;
  t.length += f, uR(t, u, c, l, a, r, 0, i, s);
}
const UX = 256;
class Xo extends Sn {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, r) {
    return this.flags & 8 || r && (!(r instanceof Xo) || this.length - (n - e) + r.length > UX || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(e) {
    let n = new Xo(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new ri(this.dom, e);
  }
  domBoundsAround(e, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return HX(this.dom, e, n);
  }
}
class Qa extends Sn {
  constructor(e, n = [], r = 0) {
    super(), this.mark = e, this.children = n, this.length = r;
    for (let i of n)
      i.setParent(this);
  }
  setAttrs(e) {
    if (iR(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof Qa && r.mark.eq(this.mark)) || e && s <= 0 || n < this.length && o <= 0) ? !1 : (cR(this, e, n, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [], r = 0, i = -1, s = 0;
    for (let l of this.children) {
      let a = r + l.length;
      a > e && n.push(r < e ? l.split(e - r) : l), i < 0 && r >= e && (i = s), r = a, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Qa(this.mark, n, o);
  }
  domAtPos(e) {
    return fR(this, e);
  }
  coordsAt(e, n) {
    return dR(this, e, n);
  }
}
function HX(t, e, n) {
  let r = t.nodeValue.length;
  e > r && (e = r);
  let i = e, s = e, o = 0;
  e == 0 && n < 0 || e == r && n >= 0 ? Le.chrome || Le.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : n < 0 ? i-- : s < r && s++;
  let l = _f(t, i, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : n >= 0) ? 0 : l.length - 1];
  return Le.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (u) => u.width) || a), o ? jv(a, o < 0) : a || null;
}
class Mu extends Sn {
  static create(e, n, r) {
    return new Mu(e, n, r);
  }
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let n = Mu.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof Mu) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  become(e) {
    return e instanceof Mu && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return rn.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, r = n && n.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : rn.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? ri.before(this.dom) : ri.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? i.length - 1 : 0; s = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return jv(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class xd extends Sn {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof xd && e.side == this.side;
  }
  split() {
    return new xd(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? ri.before(this.dom) : ri.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return rn.empty;
  }
  get isHidden() {
    return !0;
  }
}
Xo.prototype.children = Mu.prototype.children = xd.prototype.children = r6;
function fR(t, e) {
  let n = t.dom, { children: r } = t, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == n)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == n)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == n)
      return o.domAtPos(0);
  }
  return new ri(n, 0);
}
function hR(t, e, n) {
  let r, { children: i } = t;
  n > 0 && e instanceof Qa && i.length && (r = i[i.length - 1]) instanceof Qa && r.mark.eq(e.mark) ? hR(r, e.children[0], n - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function dR(t, e, n) {
  let r = null, i = -1, s = null, o = -1;
  function l(u, c) {
    for (let f = 0, d = 0; f < u.children.length && d <= c; f++) {
      let p = u.children[f], m = d + p.length;
      m >= c && (p.children.length ? l(p, c - d) : (!s || s.isHidden && (n > 0 || WX(s, p))) && (m > c || d == m && p.getSide() > 0) ? (s = p, o = c - d) : (d < c || d == m && p.getSide() < 0 && !p.isHidden) && (r = p, i = c - d)), d = m;
    }
  }
  l(t, e);
  let a = (n < 0 ? r : s) || r || s;
  return a ? a.coordsAt(Math.max(0, a == r ? i : o), n) : VX(t);
}
function VX(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let n = Qp(e);
  return n[n.length - 1] || null;
}
function WX(t, e) {
  let n = t.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return n && r && r.top < n.bottom;
}
function G_(t, e) {
  for (let n in t)
    n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
  return e;
}
const jA = /* @__PURE__ */ Object.create(null);
function db(t, e, n) {
  if (t == e)
    return !0;
  t || (t = jA), e || (e = jA);
  let r = Object.keys(t), i = Object.keys(e);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != n && (i.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function K_(t, e, n) {
  let r = !1;
  if (e)
    for (let i in e)
      n && i in n || (r = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (n)
    for (let i in n)
      e && e[i] == n[i] || (r = !0, i == "style" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));
  return r;
}
function GX(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let r = t.attributes[n];
    e[r.name] = r.value;
  }
  return e;
}
class $f {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, n, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Ii = /* @__PURE__ */ (function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
})(Ii || (Ii = {}));
class at extends xf {
  constructor(e, n, r, i) {
    super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Yg(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new sc(e, n, n, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let n = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = pR(e, n);
      r = (s ? n ? -3e8 : -1 : 5e8) - 1, i = (o ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new sc(e, r, i, n, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Xg(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, n = !1) {
    return hn.of(e, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
at.none = hn.empty;
class Yg extends at {
  constructor(e) {
    let { start: n, end: r } = pR(e);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, r;
    return this == e || e instanceof Yg && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && db(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
Yg.prototype.point = !1;
class Xg extends at {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Xg && this.spec.class == e.spec.class && db(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
Xg.prototype.mapMode = Kr.TrackBefore;
Xg.prototype.point = !0;
class sc extends at {
  constructor(e, n, r, i, s, o) {
    super(n, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? n <= 0 ? Kr.TrackBefore : Kr.TrackAfter : Kr.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Ii.WidgetRange : this.startSide <= 0 ? Ii.WidgetBefore : Ii.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof sc && KX(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
sc.prototype.point = !0;
function pR(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = t;
  return n == null && (n = t.inclusive), r == null && (r = t.inclusive), { start: n ?? e, end: r ?? e };
}
function KX(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Fy(t, e, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e);
}
class yr extends Sn {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, n, r, i, s, o) {
    if (r) {
      if (!(r instanceof yr))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), cR(this, e, n, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let n = new yr();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: r, off: i } = this.childPos(e);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      n.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    db(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    hR(this, e, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let n = e.spec.attributes, r = e.spec.class;
    n && (this.attrs = G_(n, this.attrs || {})), r && (this.attrs = G_({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return fR(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var r;
    this.dom ? this.flags & 4 && (iR(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (K_(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let i = this.dom.lastChild;
    for (; i && Sn.get(i) instanceof Qa; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = Sn.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!Le.ios || !this.children.some((s) => s instanceof Xo))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let r of this.children) {
      if (!(r instanceof Xo) || /[^ -~]/.test(r.text))
        return null;
      let i = Qp(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, n = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let r = dR(this, e, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof yr && this.children.length == 0 && e.children.length == 0 && db(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r], o = i + s.length;
      if (o >= n) {
        if (s instanceof yr)
          return s;
        if (o > n)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class Ha extends Sn {
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof Ha) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  domAtPos(e) {
    return e == 0 ? ri.before(this.dom) : ri.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let r = new Ha(this.widget, n, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return r6;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : rn.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Ha && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    return r || (this.widget instanceof Y_ ? null : jv(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : e < 0 ? n < 0 : r > 0;
  }
}
class Y_ extends $f {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Dp {
  constructor(e, n, r, i) {
    this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Ha && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new yr()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(S1(new xd(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Ha) && this.getLine();
  }
  buildText(e, n, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: l, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (l) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(this.text.length - this.textOff, e), s = Math.min(
        i,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(S1(new Xo(this.text.slice(this.textOff, this.textOff + s)), n), r), this.atCursorPos = !0, this.textOff += s, e -= s, r = i <= s ? 0 : n.length;
    }
  }
  span(e, n, r, i) {
    this.buildText(n - e, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
  }
  point(e, n, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof sc) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = n - e;
    if (r instanceof sc)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Ha(r.widget || wd.block, l, r));
      else {
        let a = Mu.create(r.widget || wd.inline, l, l ? 0 : r.startSide), u = this.atCursorPos && !a.isEditable && s <= i.length && (e < n || r.startSide > 0), c = !a.isEditable && (e < n || s > i.length || r.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !u && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), u && (f.append(S1(new xd(1), i), s), s = i.length + Math.max(0, s - i.length)), f.append(S1(a, i), s), this.atCursorPos = c, this.pendingBuffer = c ? e < n || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, n, r, i, s) {
    let o = new Dp(e, n, r, s);
    return o.openEnd = hn.spans(i, n, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function S1(t, e) {
  for (let n of e)
    t = new Qa(n, [t], t.length);
  return t;
}
class wd extends $f {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
wd.inline = /* @__PURE__ */ new wd("span");
wd.block = /* @__PURE__ */ new wd("div");
var jn = /* @__PURE__ */ (function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
})(jn || (jn = {}));
const kf = jn.LTR, i6 = jn.RTL;
function gR(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    e.push(1 << +t[n]);
  return e;
}
const YX = /* @__PURE__ */ gR("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), XX = /* @__PURE__ */ gR("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), X_ = /* @__PURE__ */ Object.create(null), dl = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), n = /* @__PURE__ */ t.charCodeAt(1);
  X_[e] = n, X_[n] = -e;
}
function mR(t) {
  return t <= 247 ? YX[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? XX[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const QX = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Pu {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? i6 : kf;
  }
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.level = r;
  }
  /**
  @internal
  */
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, n) {
    return e == (this.dir == n);
  }
  /**
  @internal
  */
  static find(e, n, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= n && l.to >= n) {
        if (l.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? l.from < n : l.to > n : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function yR(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++) {
    let r = t[n], i = e[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !yR(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const On = [];
function JX(t, e, n, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e, l = s < r.length ? r[s].from : n, a = s ? 256 : i;
    for (let u = o, c = a, f = a; u < l; u++) {
      let d = mR(t.charCodeAt(u));
      d == 512 ? d = c : d == 8 && f == 4 && (d = 16), On[u] = d == 4 ? 2 : d, d & 7 && (f = d), c = d;
    }
    for (let u = o, c = a, f = a; u < l; u++) {
      let d = On[u];
      if (d == 128)
        u < l - 1 && c == On[u + 1] && c & 24 ? d = On[u] = c : On[u] = 256;
      else if (d == 64) {
        let p = u + 1;
        for (; p < l && On[p] == 64; )
          p++;
        let m = u && c == 8 || p < n && On[p] == 8 ? f == 1 ? 1 : 8 : 256;
        for (let y = u; y < p; y++)
          On[y] = m;
        u = p - 1;
      } else d == 8 && f == 1 && (On[u] = 1);
      c = d, d & 7 && (f = d);
    }
  }
}
function ZX(t, e, n, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= r.length; o++) {
    let u = o ? r[o - 1].to : e, c = o < r.length ? r[o].from : n;
    for (let f = u, d, p, m; f < c; f++)
      if (p = X_[d = t.charCodeAt(f)])
        if (p < 0) {
          for (let y = l - 3; y >= 0; y -= 3)
            if (dl[y + 1] == -p) {
              let b = dl[y + 2], v = b & 2 ? i : b & 4 ? b & 1 ? s : i : 0;
              v && (On[f] = On[dl[y]] = v), l = y;
              break;
            }
        } else {
          if (dl.length == 189)
            break;
          dl[l++] = f, dl[l++] = d, dl[l++] = a;
        }
      else if ((m = On[f]) == 2 || m == 1) {
        let y = m == i;
        a = y ? 0 : 1;
        for (let b = l - 3; b >= 0; b -= 3) {
          let v = dl[b + 2];
          if (v & 2)
            break;
          if (y)
            dl[b + 2] |= 2;
          else {
            if (v & 4)
              break;
            dl[b + 2] |= 4;
          }
        }
      }
  }
}
function eQ(t, e, n, r) {
  for (let i = 0, s = r; i <= n.length; i++) {
    let o = i ? n[i - 1].to : t, l = i < n.length ? n[i].from : e;
    for (let a = o; a < l; ) {
      let u = On[a];
      if (u == 256) {
        let c = a + 1;
        for (; ; )
          if (c == l) {
            if (i == n.length)
              break;
            c = n[i++].to, l = i < n.length ? n[i].from : e;
          } else if (On[c] == 256)
            c++;
          else
            break;
        let f = s == 1, d = (c < e ? On[c] : r) == 1, p = f == d ? f ? 1 : 2 : r;
        for (let m = c, y = i, b = y ? n[y - 1].to : t; m > a; )
          m == b && (m = n[--y].from, b = y ? n[y - 1].to : t), On[--m] = p;
        a = c;
      } else
        s = u, a++;
    }
  }
}
function Q_(t, e, n, r, i, s, o) {
  let l = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let a = e, u = 0; a < n; ) {
      let c = !0, f = !1;
      if (u == s.length || a < s[u].from) {
        let y = On[a];
        y != l && (c = !1, f = y == 16);
      }
      let d = !c && l == 1 ? [] : null, p = c ? r : r + 1, m = a;
      e: for (; ; )
        if (u < s.length && m == s[u].from) {
          if (f)
            break e;
          let y = s[u];
          if (!c)
            for (let b = y.to, v = u + 1; ; ) {
              if (b == n)
                break e;
              if (v < s.length && s[v].from == b)
                b = s[v++].to;
              else {
                if (On[b] == l)
                  break e;
                break;
              }
            }
          if (u++, d)
            d.push(y);
          else {
            y.from > a && o.push(new Pu(a, y.from, p));
            let b = y.direction == kf != !(p % 2);
            J_(t, b ? r + 1 : r, i, y.inner, y.from, y.to, o), a = y.to;
          }
          m = y.to;
        } else {
          if (m == n || (c ? On[m] != l : On[m] == l))
            break;
          m++;
        }
      d ? Q_(t, a, m, r + 1, i, d, o) : a < m && o.push(new Pu(a, m, p)), a = m;
    }
  else
    for (let a = n, u = s.length; a > e; ) {
      let c = !0, f = !1;
      if (!u || a > s[u - 1].to) {
        let y = On[a - 1];
        y != l && (c = !1, f = y == 16);
      }
      let d = !c && l == 1 ? [] : null, p = c ? r : r + 1, m = a;
      e: for (; ; )
        if (u && m == s[u - 1].to) {
          if (f)
            break e;
          let y = s[--u];
          if (!c)
            for (let b = y.from, v = u; ; ) {
              if (b == e)
                break e;
              if (v && s[v - 1].to == b)
                b = s[--v].from;
              else {
                if (On[b - 1] == l)
                  break e;
                break;
              }
            }
          if (d)
            d.push(y);
          else {
            y.to < a && o.push(new Pu(y.to, a, p));
            let b = y.direction == kf != !(p % 2);
            J_(t, b ? r + 1 : r, i, y.inner, y.from, y.to, o), a = y.from;
          }
          m = y.from;
        } else {
          if (m == e || (c ? On[m - 1] != l : On[m - 1] == l))
            break;
          m--;
        }
      d ? Q_(t, m, a, r + 1, i, d, o) : m < a && o.push(new Pu(m, a, p)), a = m;
    }
}
function J_(t, e, n, r, i, s, o) {
  let l = e % 2 ? 2 : 1;
  JX(t, i, s, r, l), ZX(t, i, s, r, l), eQ(i, s, r, l), Q_(t, i, s, e, n, r, o);
}
function tQ(t, e, n) {
  if (!t)
    return [new Pu(0, 0, e == i6 ? 1 : 0)];
  if (e == kf && !n.length && !QX.test(t))
    return bR(t.length);
  if (n.length)
    for (; t.length > On.length; )
      On[On.length] = 256;
  let r = [], i = e == kf ? 0 : 1;
  return J_(t, i, i, n, 0, t.length, r), r;
}
function bR(t) {
  return [new Pu(0, t, 0)];
}
let vR = "";
function nQ(t, e, n, r, i) {
  var s;
  let o = r.head - t.from, l = Pu.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc), a = e[l], u = a.side(i, n);
  if (o == u) {
    let d = l += i ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    a = e[l = d], o = a.side(!i, n), u = a.side(i, n);
  }
  let c = Yr(t.text, o, a.forward(i, n));
  (c < a.from || c > a.to) && (c = u), vR = t.text.slice(Math.min(o, c), Math.max(o, c));
  let f = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return f && c == u && f.level + (i ? 0 : 1) < a.level ? de.cursor(f.side(!i, n) + t.from, f.forward(i, n) ? 1 : -1, f.level) : de.cursor(c + t.from, a.forward(i, n) ? -1 : 1, a.level);
}
function rQ(t, e, n) {
  for (let r = e; r < n; r++) {
    let i = mR(t.charCodeAt(r));
    if (i == 1)
      return kf;
    if (i == 2 || i == 4)
      return i6;
  }
  return kf;
}
const xR = /* @__PURE__ */ ze.define(), wR = /* @__PURE__ */ ze.define(), _R = /* @__PURE__ */ ze.define(), kR = /* @__PURE__ */ ze.define(), Z_ = /* @__PURE__ */ ze.define(), CR = /* @__PURE__ */ ze.define(), SR = /* @__PURE__ */ ze.define(), s6 = /* @__PURE__ */ ze.define(), o6 = /* @__PURE__ */ ze.define(), AR = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e)
}), ER = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e)
}), DR = /* @__PURE__ */ ze.define();
class Vh {
  constructor(e, n = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new Vh(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Vh(de.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const A1 = /* @__PURE__ */ St.define({ map: (t, e) => t.map(e) }), OR = /* @__PURE__ */ St.define();
function Mi(t, e, n) {
  let r = t.facet(kR);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), n, void 0, void 0, e) || (n ? console.error(n + ":", e) : console.error(e));
}
const Pa = /* @__PURE__ */ ze.define({ combine: (t) => t.length ? t[0] : !0 });
let iQ = 0;
const Fh = /* @__PURE__ */ ze.define({
  combine(t) {
    return t.filter((e, n) => {
      for (let r = 0; r < n; r++)
        if (t[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class wr {
  constructor(e, n, r, i, s) {
    this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(Fh.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(Fh.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, n) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = n || {};
    return new wr(iQ++, e, r, i, (l) => {
      let a = [];
      return o && a.push(Jp.of((u) => {
        let c = u.plugin(l);
        return c ? o(c) : at.none;
      })), s && a.push(s(l)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, n) {
    return wr.define((r, i) => new e(r, i), n);
  }
}
class Ew {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (r) {
            if (Mi(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (n) {
        Mi(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Mi(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const FR = /* @__PURE__ */ ze.define(), l6 = /* @__PURE__ */ ze.define(), Jp = /* @__PURE__ */ ze.define(), TR = /* @__PURE__ */ ze.define(), Qg = /* @__PURE__ */ ze.define(), RR = /* @__PURE__ */ ze.define();
function qA(t, e) {
  let n = t.state.facet(RR);
  if (!n.length)
    return n;
  let r = n.map((s) => s instanceof Function ? s(t) : s), i = [];
  return hn.spans(r, e.from, e.to, {
    point() {
    },
    span(s, o, l, a) {
      let u = s - e.from, c = o - e.from, f = i;
      for (let d = l.length - 1; d >= 0; d--, a--) {
        let p = l[d].spec.bidiIsolate, m;
        if (p == null && (p = rQ(e.text, u, c)), a > 0 && f.length && (m = f[f.length - 1]).to == u && m.direction == p)
          m.to = c, f = m.inner;
        else {
          let y = { from: u, to: c, direction: p, inner: [] };
          f.push(y), f = y.inner;
        }
      }
    }
  }), i;
}
const MR = /* @__PURE__ */ ze.define();
function a6(t) {
  let e = 0, n = 0, r = 0, i = 0;
  for (let s of t.state.facet(MR)) {
    let o = s(t);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (n = Math.max(n, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: n, top: r, bottom: i };
}
const hp = /* @__PURE__ */ ze.define();
class yo {
  constructor(e, n, r, i) {
    this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new yo(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, r = this;
    for (; n > 0; n--) {
      let i = e[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, r), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let a = i == e.length ? null : e[i], u = o - l, c = a ? a.fromB : 1e9;
      for (; s < n.length && n[s] < c; ) {
        let f = n[s], d = n[s + 1], p = Math.max(l, f), m = Math.min(c, d);
        if (p <= m && new yo(p + u, m + u, p, m).addToSet(r), d > c)
          break;
        s += 2;
      }
      if (!a)
        return r;
      new yo(a.fromA, a.toA, a.fromB, a.toB).addToSet(r), o = a.toA, l = a.toB;
    }
  }
}
class pb {
  constructor(e, n, r) {
    this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Er.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, a) => i.push(new yo(s, o, l, a))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new pb(e, n, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class UA extends Sn {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = at.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new yr()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new yo(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var n;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !fQ(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? oQ(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      r = new yo(u, c, e.changes.mapPos(u, -1), e.changes.mapPos(c, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (Le.ie || Le.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = uQ(o, l, e.changes);
    return r = yo.extendWithRanges(r, a), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, n, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = Le.chrome || Le.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Ha && o.widget instanceof Y_ && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, n, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(n);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: u, fromB: c, toB: f } = l, d, p, m, y;
      if (r && r.range.fromB < f && r.range.toB > c) {
        let S = Dp.build(this.view.state.doc, c, r.range.fromB, this.decorations, this.dynamicDecorationMap), C = Dp.build(this.view.state.doc, r.range.toB, f, this.decorations, this.dynamicDecorationMap);
        p = S.breakAtStart, m = S.openStart, y = C.openEnd;
        let E = this.compositionView(r);
        C.breakAtStart ? E.breakAfter = 1 : C.content.length && E.merge(E.length, E.length, C.content[0], !1, C.openStart, 0) && (E.breakAfter = C.content[0].breakAfter, C.content.shift()), S.content.length && E.merge(0, 0, S.content[S.content.length - 1], !0, 0, S.openEnd) && S.content.pop(), d = S.content.concat(E).concat(C.content);
      } else
        ({ content: d, breakAtStart: p, openStart: m, openEnd: y } = Dp.build(this.view.state.doc, c, f, this.decorations, this.dynamicDecorationMap));
      let { i: b, off: v } = s.findPos(u, 1), { i: _, off: k } = s.findPos(a, -1);
      uR(this, _, k, b, v, d, p, m, y);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(OR) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let n = new Xo(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of e.marks)
      n = new Qa(i, [n], n.length);
    let r = new yr();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(e) {
    let n = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (a) => a.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let l = Sn.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    n(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], n(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && !(this.view.state.facet(Pa) || this.dom.tabIndex > -1) && Oy(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), u = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (Le.gecko && l.empty && !this.hasComposition && sQ(a)) {
      let f = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(f, a.node.childNodes[a.offset] || null)), a = u = new ri(f, 0), o = !0;
    }
    let c = this.view.observer.selectionRange;
    (o || !c.focusNode || (!Ep(a.node, a.offset, c.anchorNode, c.anchorOffset) || !Ep(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, l)) && (this.view.observer.ignore(() => {
      Le.android && Le.chrome && this.dom.contains(c.focusNode) && cQ(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let f = Xp(this.view.root);
      if (f) if (l.empty) {
        if (Le.gecko) {
          let d = lQ(a.node, a.offset);
          if (d && d != 3) {
            let p = (d == 1 ? oR : lR)(a.node, a.offset);
            p && (a = new ri(p.node, p.offset));
          }
        }
        f.collapse(a.node, a.offset), l.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = l.bidiLevel);
      } else if (f.extend) {
        f.collapse(a.node, a.offset);
        try {
          f.extend(u.node, u.offset);
        } catch {
        }
      } else {
        let d = document.createRange();
        l.anchor > l.head && ([a, u] = [u, a]), d.setEnd(u.node, u.offset), d.setStart(a.node, a.offset), f.removeAllRanges(), f.addRange(d);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(a, u)), this.impreciseAnchor = a.precise ? null : new ri(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new ri(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, n) {
    return this.hasComposition && n.empty && Ep(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, r = Xp(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify)
      return;
    let o = yr.find(this, n.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (n.head == l || n.head == l + o.length)
      return;
    let a = this.coordsAt(n.head, -1), u = this.coordsAt(n.head, 1);
    if (!a || !u || a.bottom > u.top)
      return;
    let c = this.domAtPos(n.head + n.assoc);
    r.collapse(c.node, c.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let f = e.observer.selectionRange;
    e.docView.posFromDOM(f.anchorNode, f.anchorOffset) != n.from && r.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let n = this.dom, r;
    if (e.node != n)
      return e;
    for (let i = e.offset; !r && i < n.childNodes.length; i++) {
      let s = Sn.get(n.childNodes[i]);
      s instanceof yr && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = Sn.get(n.childNodes[i]);
      s instanceof yr && (r = s.domAtPos(s.length));
    }
    return r ? new ri(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let r = Sn.get(n);
      if (r && r.rootView == this)
        return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, n) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: r } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof yr)
        break;
      n++, r = 0;
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(e, n) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, u = a - l.length;
      if (a < e)
        break;
      if (u <= e && (u < e || l.covers(-1)) && (a > e || l.covers(1)) && (!r || l instanceof yr && !(r instanceof yr && n >= 0)))
        r = l, i = u;
      else if (r && u == e && a == e && l instanceof Ha && Math.abs(n) < 2) {
        if (l.deco.startSide < 0)
          break;
        o && (r = null);
      }
      s = u;
    }
    return r ? r.coordsAt(e - i, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: r } = this.childPos(e, 1), i = this.children[n];
    if (!(i instanceof yr))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: a } = i.childPos(r, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      r = a;
    }
    if (!(i instanceof Xo))
      return null;
    let s = Yr(i.text, r);
    if (s == r)
      return null;
    let o = _f(i.dom, r, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == jn.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let f = this.children[c], d = u + f.length;
      if (d > i)
        break;
      if (u >= r) {
        let p = f.dom.getBoundingClientRect();
        if (n.push(p.height), o) {
          let m = f.dom.lastChild, y = m ? Qp(m) : [];
          if (y.length) {
            let b = y[y.length - 1], v = a ? b.right - p.left : p.right - b.left;
            v > l && (l = v, this.minWidth = s, this.minWidthFrom = u, this.minWidthTo = d);
          }
        }
      }
      u = d + f.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? jn.RTL : jn.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof yr) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), n, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Qp(e.firstChild)[0];
      n = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : n, e.remove();
    }), { lineHeight: n, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new aR(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == n.viewports.length ? null : n.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let l = (n.lineBlockAt(o).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        e.push(at.replace({
          widget: new Y_(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return at.set(e);
  }
  updateDeco() {
    let e = 1, n = this.view.state.facet(Jp).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), r = !1, i = this.view.state.facet(TR).map((s, o) => {
      let l = typeof s == "function";
      return l && (r = !0), l ? s(this.view) : s;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, n.push(hn.join(i))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = u.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let u of this.view.state.facet(DR))
      try {
        if (u(this.view, e.range, e))
          return !0;
      } catch (c) {
        Mi(this.view.state, c, "scroll handler");
      }
    let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
    if (!r)
      return;
    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = a6(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    LX(this.view.scrollDOM, o, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == jn.LTR);
  }
}
function sQ(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
function PR(t, e) {
  let n = t.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let r = oR(n.focusNode, n.focusOffset), i = lR(n.focusNode, n.focusOffset), s = r || i;
  if (i && r && i.node != r.node) {
    let l = Sn.get(i.node);
    if (!l || l instanceof Xo && l.text != i.node.nodeValue)
      s = i;
    else if (t.docView.lastCompositionAfterCursor) {
      let a = Sn.get(r.node);
      !a || a instanceof Xo && a.text != r.node.nodeValue || (s = i);
    }
  }
  if (t.docView.lastCompositionAfterCursor = s != r, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function oQ(t, e, n) {
  let r = PR(t, n);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, l = i.nodeValue;
  if (/[\n\r]/.test(l) || t.state.doc.sliceString(r.from, r.to) != l)
    return null;
  let a = e.invertedDesc, u = new yo(a.mapPos(s), a.mapPos(o), s, o), c = [];
  for (let f = i.parentNode; ; f = f.parentNode) {
    let d = Sn.get(f);
    if (d instanceof Qa)
      c.push({ node: f, deco: d.mark });
    else {
      if (d instanceof yr || f.nodeName == "DIV" && f.parentNode == t.contentDOM)
        return { range: u, text: i, marks: c, line: f };
      if (f != t.contentDOM)
        c.push({ node: f, deco: new Yg({
          inclusive: !0,
          attributes: GX(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function lQ(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let aQ = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    Fy(e, n, this.changes);
  }
  comparePoint(e, n) {
    Fy(e, n, this.changes);
  }
  boundChange(e) {
    Fy(e, e, this.changes);
  }
};
function uQ(t, e, n) {
  let r = new aQ();
  return hn.compare(t, e, n, r), r.changes;
}
function cQ(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function fQ(t, e) {
  let n = !1;
  return e && t.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (n = !0);
  }), n;
}
function hQ(t, e, n = 1) {
  let r = t.charCategorizer(e), i = t.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return de.cursor(e);
  s == 0 ? n = 1 : s == i.length && (n = -1);
  let o = s, l = s;
  n < 0 ? o = Yr(i.text, s, !1) : l = Yr(i.text, s);
  let a = r(i.text.slice(o, l));
  for (; o > 0; ) {
    let u = Yr(i.text, o, !1);
    if (r(i.text.slice(u, o)) != a)
      break;
    o = u;
  }
  for (; l < i.length; ) {
    let u = Yr(i.text, l);
    if (r(i.text.slice(l, u)) != a)
      break;
    l = u;
  }
  return de.range(o + i.from, l + i.from);
}
function dQ(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function pQ(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Dw(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function HA(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function VA(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function e4(t, e, n) {
  let r, i, s, o, l = !1, a, u, c, f;
  for (let m = t.firstChild; m; m = m.nextSibling) {
    let y = Qp(m);
    for (let b = 0; b < y.length; b++) {
      let v = y[b];
      i && Dw(i, v) && (v = HA(VA(v, i.bottom), i.top));
      let _ = dQ(e, v), k = pQ(n, v);
      if (_ == 0 && k == 0)
        return m.nodeType == 3 ? WA(m, e, n) : e4(m, e, n);
      (!r || o > k || o == k && s > _) && (r = m, i = v, s = _, o = k, l = _ ? e < v.left ? b > 0 : b < y.length - 1 : !0), _ == 0 ? n > v.bottom && (!c || c.bottom < v.bottom) ? (a = m, c = v) : n < v.top && (!f || f.top > v.top) && (u = m, f = v) : c && Dw(c, v) ? c = VA(c, v.bottom) : f && Dw(f, v) && (f = HA(f, v.top));
    }
  }
  if (c && c.bottom >= n ? (r = a, i = c) : f && f.top <= n && (r = u, i = f), !r)
    return { node: t, offset: 0 };
  let d = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return WA(r, d, n);
  if (l && r.contentEditable != "false")
    return e4(r, d, n);
  let p = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: p };
}
function WA(t, e, n) {
  let r = t.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let l = 0; l < r; l++) {
    let a = _f(t, l, l + 1).getClientRects();
    for (let u = 0; u < a.length; u++) {
      let c = a[u];
      if (c.top == c.bottom)
        continue;
      o || (o = e - c.left);
      let f = (c.top > n ? c.top - n : n - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && f < s) {
        let d = e >= (c.left + c.right) / 2, p = d;
        if ((Le.chrome || Le.gecko) && _f(t, l).getBoundingClientRect().left == c.right && (p = !d), f <= 0)
          return { node: t, offset: l + (p ? 1 : 0) };
        i = l + (p ? 1 : 0), s = f;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };
}
function IR(t, e, n, r = -1) {
  var i, s;
  let o = t.contentDOM.getBoundingClientRect(), l = o.top + t.viewState.paddingTop, a, { docHeight: u } = t.viewState, { x: c, y: f } = e, d = f - l;
  if (d < 0)
    return 0;
  if (d > u)
    return t.state.doc.length;
  for (let S = t.viewState.heightOracle.textHeight / 2, C = !1; a = t.elementAtHeight(d), a.type != Ii.Text; )
    for (; d = r > 0 ? a.bottom + S : a.top - S, !(d >= 0 && d <= u); ) {
      if (C)
        return n ? null : 0;
      C = !0, r = -r;
    }
  f = l + d;
  let p = a.from;
  if (p < t.viewport.from)
    return t.viewport.from == 0 ? 0 : n ? null : GA(t, o, a, c, f);
  if (p > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : GA(t, o, a, c, f);
  let m = t.dom.ownerDocument, y = t.root.elementFromPoint ? t.root : m, b = y.elementFromPoint(c, f);
  b && !t.contentDOM.contains(b) && (b = null), b || (c = Math.max(o.left + 1, Math.min(o.right - 1, c)), b = y.elementFromPoint(c, f), b && !t.contentDOM.contains(b) && (b = null));
  let v, _ = -1;
  if (b && ((i = t.docView.nearest(b)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (m.caretPositionFromPoint) {
      let S = m.caretPositionFromPoint(c, f);
      S && ({ offsetNode: v, offset: _ } = S);
    } else if (m.caretRangeFromPoint) {
      let S = m.caretRangeFromPoint(c, f);
      S && ({ startContainer: v, startOffset: _ } = S);
    }
    v && (!t.contentDOM.contains(v) || Le.safari && gQ(v, _, c) || Le.chrome && mQ(v, _, c)) && (v = void 0), v && (_ = Math.min(Xl(v), _));
  }
  if (!v || !t.docView.dom.contains(v)) {
    let S = yr.find(t.docView, p);
    if (!S)
      return d > a.top + a.height / 2 ? a.to : a.from;
    ({ node: v, offset: _ } = e4(S.dom, c, f));
  }
  let k = t.docView.nearest(v);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let S = k.dom.getBoundingClientRect();
    return e.y < S.top || e.y <= S.bottom && e.x <= (S.left + S.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(v, _) + k.posAtStart;
}
function GA(t, e, n, r, i) {
  let s = Math.round((r - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let l = t.viewState.heightOracle.textHeight, a = Math.floor((i - n.top - (t.defaultLineHeight - l) * 0.5) / l);
    s += a * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(n.from, n.to);
  return n.from + $_(o, s, t.state.tabSize);
}
function NR(t, e, n) {
  let r, i = t;
  if (t.nodeType != 3 || e != (r = t.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = i.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let o = i.parentNode;
      if (!o || o.nodeName == "DIV")
        break;
      i = o;
    }
  }
  return _f(t, r - 1, r).getBoundingClientRect().right > n;
}
function gQ(t, e, n) {
  return NR(t, e, n);
}
function mQ(t, e, n) {
  if (e != 0)
    return NR(t, e, n);
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = t.nodeType == 1 ? t.getBoundingClientRect() : _f(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function t4(t, e, n) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let i;
    for (let s of r.type) {
      if (s.from > e)
        break;
      if (!(s.to < e)) {
        if (s.from < e && s.to > e)
          return s;
        (!i || s.type == Ii.Text && (i.type != s.type || (n < 0 ? s.from < e : s.to > e))) && (i = s);
      }
    }
    return i || r;
  }
  return r;
}
function yQ(t, e, n, r) {
  let i = t4(t, e.head, e.assoc || -1), s = !r || i.type != Ii.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(), l = t.textDirectionAt(i.from), a = t.posAtCoords({
      x: n == (l == jn.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return de.cursor(a, n ? -1 : 1);
  }
  return de.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function KA(t, e, n, r) {
  let i = t.state.doc.lineAt(e.head), s = t.bidiSpans(i), o = t.textDirectionAt(i.from);
  for (let l = e, a = null; ; ) {
    let u = nQ(i, s, o, l, n), c = vR;
    if (!u) {
      if (i.number == (n ? t.state.doc.lines : 1))
        return l;
      c = `
`, i = t.state.doc.line(i.number + (n ? 1 : -1)), s = t.bidiSpans(i), u = t.visualLineSide(i, !n);
    }
    if (a) {
      if (!a(c))
        return l;
    } else {
      if (!r)
        return u;
      a = r(c);
    }
    l = u;
  }
}
function bQ(t, e, n) {
  let r = t.state.charCategorizer(e), i = r(n);
  return (s) => {
    let o = r(s);
    return i == Wn.Space && (i = o), i == o;
  };
}
function vQ(t, e, n, r) {
  let i = e.head, s = n ? 1 : -1;
  if (i == (n ? t.state.doc.length : 0))
    return de.cursor(i, e.assoc);
  let o = e.goalColumn, l, a = t.contentDOM.getBoundingClientRect(), u = t.coordsAtPos(i, e.assoc || -1), c = t.documentTop;
  if (u)
    o == null && (o = u.left - a.left), l = s < 0 ? u.top : u.bottom;
  else {
    let p = t.viewState.lineBlockAt(i);
    o == null && (o = Math.min(a.right - a.left, t.defaultCharacterWidth * (i - p.from))), l = (s < 0 ? p.top : p.bottom) + c;
  }
  let f = a.left + o, d = r ?? t.viewState.heightOracle.textHeight >> 1;
  for (let p = 0; ; p += 10) {
    let m = l + (d + p) * s, y = IR(t, { x: f, y: m }, !1, s);
    if (m < a.top || m > a.bottom || (s < 0 ? y < i : y > i)) {
      let b = t.docView.coordsForChar(y), v = !b || m < b.top ? -1 : 1;
      return de.cursor(y, v, void 0, o);
    }
  }
}
function Op(t, e, n) {
  for (; ; ) {
    let r = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = r || n || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, r = a;
        }
      });
    if (!r)
      return e;
  }
}
function BR(t, e) {
  let n = null;
  for (let r = 0; r < e.ranges.length; r++) {
    let i = e.ranges[r], s = null;
    if (i.empty) {
      let o = Op(t, i.from, 0);
      o != i.from && (s = de.cursor(o, -1));
    } else {
      let o = Op(t, i.from, -1), l = Op(t, i.to, 1);
      (o != i.from || l != i.to) && (s = de.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
    }
    s && (n || (n = e.ranges.slice()), n[r] = s);
  }
  return n ? de.create(n, e.mainIndex) : e;
}
function Ow(t, e, n) {
  let r = Op(t.state.facet(Qg).map((i) => i(t)), n.from, e.head > n.from ? -1 : 1);
  return r == n.from ? n : de.cursor(r, r < n.from ? 1 : -1);
}
const dp = "ï¿¿";
class xQ {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(nn.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += dp;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == n)
        break;
      let l = Sn.get(i), a = Sn.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : hb(i)) || hb(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && !_Q(o, n) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = n.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (l = i.exec(n)) && (s = l.index, o = l[0].length), this.append(n.slice(r, s < 0 ? n.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = Sn.get(e), r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (wQ(e, r.node, r.offset) ? n : 0));
  }
}
function wQ(t, e, n) {
  for (; ; ) {
    if (!e || n < Xl(e))
      return !1;
    if (e == t)
      return !0;
    n = wf(e) + 1, e = e.parentNode;
  }
}
function _Q(t, e) {
  let n;
  for (; !(t == e || !t); t = t.nextSibling) {
    let r = Sn.get(t);
    if (!(r?.isWidget || t.cmIgnore))
      return !1;
    r && (n || (n = [])).push(r);
  }
  if (n)
    for (let r of n) {
      let i = r.overrideDOMText;
      if (i?.length)
        return !1;
    }
  return !0;
}
class YA {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
}
class kQ {
  constructor(e, n, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
      let l = s || o ? [] : SQ(e), a = new xQ(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = AQ(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !W_(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), u = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !W_(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), c = e.viewport;
      if ((Le.ios || Le.chrome) && e.state.selection.main.empty && a != u && (c.from > 0 || c.to < e.state.doc.length)) {
        let f = Math.min(a, u), d = Math.max(a, u), p = c.from - f, m = c.to - d;
        (p == 0 || p == 1 || f == 0) && (m == 0 || m == -1 || d == e.state.doc.length) && (a = 0, u = e.state.doc.length);
      }
      this.newSel = de.single(u, a);
    }
  }
}
function LR(t, e) {
  let n, { newSel: r } = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = i.from, u = null;
    (s === 8 || Le.android && e.text.length < l - o) && (a = i.to, u = "end");
    let c = $R(t.state.doc.sliceString(o, l, dp), e.text, a - o, u);
    c && (Le.chrome && s == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == dp + dp && c.toB--, n = {
      from: o + c.from,
      to: o + c.toA,
      insert: rn.of(e.text.slice(c.from, c.toB).split(dp))
    });
  } else r && (!t.hasFocus && t.state.facet(Pa) || r.main.eq(i)) && (r = null);
  if (!n && !r)
    return !1;
  if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : (Le.mac || Le.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = de.single(r.main.anchor - 1, r.main.head - 1)), n = { from: n.from, to: n.to, insert: rn.of([n.insert.toString().replace(".", " ")]) }) : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))
  } : Le.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = de.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: rn.of([" "]) }), n)
    return u6(t, n, r, s);
  if (r && !r.main.eq(i)) {
    let o = !1, l = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0), l = t.inputState.lastSelectionOrigin, l == "select.pointer" && (r = BR(t.state.facet(Qg).map((a) => a(t)), r))), t.dispatch({ selection: r, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function u6(t, e, n, r = -1) {
  if (Le.ios && t.inputState.flushIOSKey(e))
    return !0;
  let i = t.state.selection.main;
  if (Le.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Hh(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && Hh(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Hh(t.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let o, l = () => o || (o = CQ(t, e, n));
  return t.state.facet(CR).some((a) => a(t, e.from, e.to, s, l)) || t.dispatch(l()), !0;
}
function CQ(t, e, n) {
  let r, i = t.state, s = i.selection.main, o = -1;
  if (e.from == e.to && e.from < s.from || e.from > s.to) {
    let a = e.from < s.from ? -1 : 1, u = a < 0 ? s.from : s.to, c = Op(i.facet(Qg).map((f) => f(t)), u, a);
    e.from == c && (o = c);
  }
  if (o > -1)
    r = {
      changes: e,
      selection: de.cursor(e.from + e.insert.length, -1)
    };
  else if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", u = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + u));
  } else {
    let a = i.changes(e), u = n && n.main.to <= a.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), f, d = n && PR(t, n.main.head);
      if (d) {
        let y = e.insert.length - (e.to - e.from);
        f = { from: d.from, to: d.to - y };
      } else
        f = t.state.doc.lineAt(s.head);
      let p = s.to - e.to, m = s.to - s.from;
      r = i.changeByRange((y) => {
        if (y.from == s.from && y.to == s.to)
          return { changes: a, range: u || y.map(a) };
        let b = y.to - p, v = b - c.length;
        if (y.to - y.from != m || t.state.sliceDoc(v, b) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        y.to >= f.from && y.from <= f.to)
          return { range: y };
        let _ = i.changes({ from: v, to: b, insert: e.insert }), k = y.to - s.to;
        return {
          changes: _,
          range: u ? de.range(Math.max(0, u.anchor + k), Math.max(0, u.head + k)) : y.map(_)
        };
      });
    } else
      r = {
        changes: a,
        selection: u && i.selection.replaceRange(u)
      };
  }
  let l = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, l += ".compose", t.inputState.compositionFirstChange && (l += ".start", t.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: l, scrollIntoView: !0 });
}
function $R(t, e, n, r) {
  let i = Math.min(t.length, e.length), s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && t.length == e.length)
    return null;
  let o = t.length, l = e.length;
  for (; o > 0 && l > 0 && t.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (r == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    n -= o + a - s;
  }
  if (o < s && t.length < e.length) {
    let a = n <= s && n >= o ? s - n : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = n <= s && n >= l ? s - n : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function SQ(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return n && (e.push(new YA(n, r)), (i != n || s != r) && e.push(new YA(i, s))), e;
}
function AQ(t, e) {
  if (t.length == 0)
    return null;
  let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;
  return n > -1 && r > -1 ? de.single(n + e, r + e) : null;
}
class EQ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, Le.safari && e.contentDOM.addEventListener("input", () => null), Le.gecko && UQ(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !IQ(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, n) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented)
          break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = DQ(e), r = this.handlers, i = this.view.contentDOM;
    for (let s in n)
      if (s != "scroll") {
        let o = !n[s].handlers.length, l = r[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), l = null), l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !n[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && jR.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), Le.android && Le.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return Le.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = zR.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || OQ.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Hh(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return !/^key/.test(e.type) || e.synthetic ? !1 : this.composing > 0 ? !0 : Le.safari && !Le.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function XA(t, e) {
  return (n, r) => {
    try {
      return e.call(t, r, n);
    } catch (i) {
      Mi(n.state, i);
    }
  };
}
function DQ(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of t) {
    let i = r.spec, s = i && i.plugin.domEventHandlers, o = i && i.plugin.domEventObservers;
    if (s)
      for (let l in s) {
        let a = s[l];
        a && n(l).handlers.push(XA(r.value, a));
      }
    if (o)
      for (let l in o) {
        let a = o[l];
        a && n(l).observers.push(XA(r.value, a));
      }
  }
  for (let r in Qo)
    n(r).handlers.push(Qo[r]);
  for (let r in xo)
    n(r).observers.push(xo[r]);
  return e;
}
const zR = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], OQ = "dthko", jR = [16, 17, 18, 20, 91, 92, 224, 225], E1 = 6;
function D1(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function FQ(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class TQ {
  constructor(e, n, r, i) {
    this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = $X(e.contentDOM), this.atoms = e.state.facet(Qg).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(nn.allowMultipleSelections) && RQ(e, n), this.dragging = PQ(e, n) && HR(n) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && FQ(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, r = 0, i = 0, s = 0, o = this.view.win.innerWidth, l = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: l } = this.scrollParents.y.getBoundingClientRect());
    let a = a6(this.view);
    e.clientX - a.left <= i + E1 ? n = -D1(i - e.clientX) : e.clientX + a.right >= o - E1 && (n = D1(e.clientX - o)), e.clientY - a.top <= s + E1 ? r = -D1(s - e.clientY) : e.clientY + a.bottom >= l - E1 && (r = D1(e.clientY - l)), this.setScrollSpeed(n, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: n } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: n } = this, r = BR(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function RQ(t, e) {
  let n = t.state.facet(xR);
  return n.length ? n[0](e) : Le.mac ? e.metaKey : e.ctrlKey;
}
function MQ(t, e) {
  let n = t.state.facet(wR);
  return n.length ? n[0](e) : Le.mac ? !e.altKey : !e.ctrlKey;
}
function PQ(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty)
    return !1;
  let r = Xp(t.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function IQ(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (r = Sn.get(n)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const Qo = /* @__PURE__ */ Object.create(null), xo = /* @__PURE__ */ Object.create(null), qR = Le.ie && Le.ie_version < 15 || Le.ios && Le.webkit_version < 604;
function NQ(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    t.focus(), n.remove(), UR(t, n.value);
  }, 50);
}
function qv(t, e, n) {
  for (let r of t.facet(e))
    n = r(n, t);
  return n;
}
function UR(t, e) {
  e = qv(t.state, s6, e);
  let { state: n } = t, r, i = 1, s = n.toText(e), o = s.lines == n.selection.ranges.length;
  if (n4 != null && n.selection.ranges.every((a) => a.empty) && n4 == s.toString()) {
    let a = -1;
    r = n.changeByRange((u) => {
      let c = n.doc.lineAt(u.from);
      if (c.from == a)
        return { range: u };
      a = c.from;
      let f = n.toText((o ? s.line(i++).text : e) + n.lineBreak);
      return {
        changes: { from: c.from, insert: f },
        range: de.cursor(u.from + f.length)
      };
    });
  } else o ? r = n.changeByRange((a) => {
    let u = s.line(i++);
    return {
      changes: { from: a.from, to: a.to, insert: u.text },
      range: de.cursor(a.from + u.length)
    };
  }) : r = n.replaceSelection(s);
  t.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
xo.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
Qo.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
xo.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
xo.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Qo.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let r of t.state.facet(_R))
    if (n = r(t, e), n)
      break;
  if (!n && e.button == 0 && (n = $Q(t, e)), n) {
    let r = !t.hasFocus;
    t.inputState.startMouseSelection(new TQ(t, e, n, r)), r && t.observer.ignore(() => {
      rR(t.contentDOM);
      let s = t.root.activeElement;
      s && !s.contains(t.contentDOM) && s.blur();
    });
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    t.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function QA(t, e, n, r) {
  if (r == 1)
    return de.cursor(e, n);
  if (r == 2)
    return hQ(t.state, e, n);
  {
    let i = yr.find(t.docView, e), s = t.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, l = i ? i.posAtEnd : s.to;
    return l < t.state.doc.length && l == s.to && l++, de.range(o, l);
  }
}
let JA = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right;
function BQ(t, e, n, r) {
  let i = yr.find(t.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && JA(n, r, o))
    return -1;
  let l = i.coordsAt(s, 1);
  return l && JA(n, r, l) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function ZA(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: BQ(t, n, e.clientX, e.clientY) };
}
const LQ = Le.ie && Le.ie_version <= 11;
let eE = null, tE = 0, nE = 0;
function HR(t) {
  if (!LQ)
    return t.detail;
  let e = eE, n = nE;
  return eE = t, nE = Date.now(), tE = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (tE + 1) % 3 : 1;
}
function $Q(t, e) {
  let n = ZA(t, e), r = HR(e), i = t.state.selection;
  return {
    update(s) {
      s.docChanged && (n.pos = s.changes.mapPos(n.pos), i = i.map(s.changes));
    },
    get(s, o, l) {
      let a = ZA(t, s), u, c = QA(t, a.pos, a.bias, r);
      if (n.pos != a.pos && !o) {
        let f = QA(t, n.pos, n.bias, r), d = Math.min(f.from, c.from), p = Math.max(f.to, c.to);
        c = d < c.from ? de.range(d, p) : de.range(p, d);
      }
      return o ? i.replaceRange(i.main.extend(c.from, c.to)) : l && r == 1 && i.ranges.length > 1 && (u = zQ(i, a.pos)) ? u : l ? i.addRange(c) : de.create([c]);
    }
  };
}
function zQ(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: r, to: i } = t.ranges[n];
    if (r <= e && i >= e)
      return de.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
Qo.dragstart = (t, e) => {
  let { selection: { main: n } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= n.to || o <= n.from) && (n = de.range(s, o));
    }
  }
  let { inputState: r } = t;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", qv(t.state, o6, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Qo.dragend = (t) => (t.inputState.draggedContent = null, !1);
function rE(t, e, n, r) {
  if (n = qv(t.state, s6, n), !n)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, o = r && s && MQ(t, e) ? { from: s.from, to: s.to } : null, l = { from: i, insert: n }, a = t.state.changes(o ? [o, l] : l);
  t.focus(), t.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
Qo.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length), i = 0, s = () => {
      ++i == n.length && rE(t, e, r.filter((o) => o != null).join(t.state.lineBreak), !1);
    };
    for (let o = 0; o < n.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (r[o] = l.result), s();
      }, l.readAsText(n[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return rE(t, e, r, !0), !0;
  }
  return !1;
};
Qo.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let n = qR ? null : e.clipboardData;
  return n ? (UR(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (NQ(t), !1);
};
function jQ(t, e) {
  let n = t.dom.parentNode;
  if (!n)
    return;
  let r = n.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), t.focus();
  }, 50);
}
function qQ(t) {
  let e = [], n = [], r = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > i && (e.push(o.text), n.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: qv(t, o6, e.join(t.lineBreak)), ranges: n, linewise: r };
}
let n4 = null;
Qo.copy = Qo.cut = (t, e) => {
  let { text: n, ranges: r, linewise: i } = qQ(t.state);
  if (!n && !i)
    return !1;
  n4 = i ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = qR ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", n), !0) : (jQ(t, n), !1);
};
const VR = /* @__PURE__ */ ru.define();
function WR(t, e) {
  let n = [];
  for (let r of t.facet(SR)) {
    let i = r(t, e);
    i && n.push(i);
  }
  return n.length ? t.update({ effects: n, annotations: VR.of(!0) }) : null;
}
function GR(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = WR(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
xo.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), GR(t);
};
xo.blur = (t) => {
  t.observer.clearSelectionRange(), GR(t);
};
xo.compositionstart = xo.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
xo.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, Le.chrome && Le.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
xo.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Qo.beforeinput = (t, e) => {
  var n, r;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let s = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), o = e.getTargetRanges();
    if (s && o.length) {
      let l = o[0], a = t.posAtDOM(l.startContainer, l.startOffset), u = t.posAtDOM(l.endContainer, l.endOffset);
      return u6(t, { from: a, to: u, insert: t.state.toText(s) }, null), !0;
    }
  }
  let i;
  if (Le.chrome && Le.android && (i = zR.find((s) => s.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let s = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > s + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return Le.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), Le.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => xo.compositionend(t, e), 20), !1;
};
const iE = /* @__PURE__ */ new Set();
function UQ(t) {
  iE.has(t) || (iE.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const sE = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let _d = !1;
function oE() {
  _d = !1;
}
class HQ {
  constructor(e) {
    this.lineWrapping = e, this.doc = rn.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return sE.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return n;
  }
  refresh(e, n, r, i, s, o) {
    let l = sE.indexOf(e) > -1, a = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let u = 0; u < o.length; u++) {
        let c = o[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return a;
  }
}
class VQ {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class El {
  /**
  @internal
  */
  constructor(e, n, r, i, s) {
    this.from = e, this.length = n, this.top = r, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Ii.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof sc ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new El(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var zn = /* @__PURE__ */ (function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
})(zn || (zn = {}));
const Ty = 1e-3;
class Ni {
  constructor(e, n, r = 2) {
    this.length = e, this.height = n, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Ty && (_d = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, n, r) {
    return Ni.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, r, i) {
    let s = this, o = r.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: a, toA: u, fromB: c, toB: f } = i[l], d = s.lineAt(a, zn.ByPosNoHeight, r.setDoc(n), 0, 0), p = d.to >= u ? d : s.lineAt(u, zn.ByPosNoHeight, r, 0, 0);
      for (f += p.to - u, u = p.to; l > 0 && d.from <= i[l - 1].toA; )
        a = i[l - 1].fromA, c = i[l - 1].fromB, l--, a < d.from && (d = s.lineAt(a, zn.ByPosNoHeight, r, 0, 0));
      c += d.from - a, a = d.from;
      let m = c6.build(r.setDoc(o), e, c, f);
      s = gb(s, s.replace(a, u, m));
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new Rs(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, r = e.length, i = 0, s = 0;
    for (; ; )
      if (n == r)
        if (i > s * 2) {
          let l = e[n - 1];
          l.break ? e.splice(--n, 1, l.left, null, l.right) : e.splice(--n, 1, l.left, l.right), r += 1 + l.break, i -= l.size;
        } else if (s > i * 2) {
          let l = e[r];
          l.break ? e.splice(r, 1, l.left, null, l.right) : e.splice(r, 1, l.left, l.right), r += 2 + l.break, s -= l.size;
        } else
          break;
      else if (i < s) {
        let l = e[n++];
        l && (i += l.size);
      } else {
        let l = e[--r];
        l && (s += l.size);
      }
    let o = 0;
    return e[n - 1] == null ? (o = 1, n--) : e[n] == null && (o = 1, r++), new WQ(Ni.of(e.slice(0, n)), o, Ni.of(e.slice(r)));
  }
}
function gb(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (_d = !0), e);
}
Ni.prototype.size = 1;
class KR extends Ni {
  constructor(e, n, r) {
    super(e, n), this.deco = r;
  }
  blockAt(e, n, r, i) {
    return new El(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, n, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, n, r, i, s, o) {
    e <= s + this.length && n >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Rs extends KR {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, r, i) {
    return new El(i, this.length, r, this.height, this.breaks);
  }
  replace(e, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof Rs || i instanceof Wr && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Wr ? i = new Rs(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Ni.of(r);
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Wr extends Ni {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, s = i - r + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, n, r, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let u = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), c = n.doc.lineAt(u), f = l + c.length * a, d = Math.max(r, e - f / 2);
      return new El(c.from, c.length, d, f, 0);
    } else {
      let u = Math.max(0, Math.min(o - s, Math.floor((e - r) / l))), { from: c, length: f } = n.doc.line(s + u);
      return new El(c, f, r + l * u, l, 0);
    }
  }
  lineAt(e, n, r, i, s) {
    if (n == zn.ByHeight)
      return this.blockAt(e, r, i, s);
    if (n == zn.ByPosNoHeight) {
      let { from: p, to: m } = r.doc.lineAt(e);
      return new El(p, m - p, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(r, s), u = r.doc.lineAt(e), c = l + u.length * a, f = u.number - o, d = i + l * f + a * (u.from - s - f);
    return new El(u.from, u.length, Math.max(i, Math.min(d, i + this.height - c)), c, 0);
  }
  forEachLine(e, n, r, i, s, o) {
    e = Math.max(e, s), n = Math.min(n, s + this.length);
    let { firstLine: l, perLine: a, perChar: u } = this.heightMetrics(r, s);
    for (let c = e, f = i; c <= n; ) {
      let d = r.doc.lineAt(c);
      if (c == e) {
        let m = d.number - l;
        f += a * m + u * (e - s - m);
      }
      let p = a + u * d.length;
      o(new El(d.from, d.length, f, p, 0)), f += p, c = d.to + 1;
    }
  }
  replace(e, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof Wr ? r[r.length - 1] = new Wr(s.length + i) : r.push(null, new Wr(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof Wr ? r[0] = new Wr(e + s.length) : r.unshift(new Wr(e - 1), null);
    }
    return Ni.of(r);
  }
  decomposeLeft(e, n) {
    n.push(new Wr(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new Wr(this.length - e - 1));
  }
  updateHeight(e, n = 0, r = !1, i) {
    let s = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let o = [], l = Math.max(n, i.from), a = -1;
      for (i.from > n && o.push(new Wr(i.from - n - 1).updateHeight(e, n)); l <= s && i.more; ) {
        let c = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let f = i.heights[i.index++];
        a == -1 ? a = f : Math.abs(f - a) >= Ty && (a = -2);
        let d = new Rs(c, f);
        d.outdated = !1, o.push(d), l += c + 1;
      }
      l <= s && o.push(null, new Wr(s - l).updateHeight(e, l));
      let u = Ni.of(o);
      return (a < 0 || Math.abs(u.height - this.height) >= Ty || Math.abs(a - this.heightMetrics(e, n).perLine) >= Ty) && (_d = !0), gb(this, u);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class WQ extends Ni {
  constructor(e, n, r) {
    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, s, i + this.left.length + this.break);
  }
  lineAt(e, n, r, i, s) {
    let o = i + this.left.height, l = s + this.left.length + this.break, a = n == zn.ByHeight ? e < o : e < l, u = a ? this.left.lineAt(e, n, r, i, s) : this.right.lineAt(e, n, r, o, l);
    if (this.break || (a ? u.to < l : u.from > l))
      return u;
    let c = n == zn.ByPosNoHeight ? zn.ByPosNoHeight : zn.ByPos;
    return a ? u.join(this.right.lineAt(l, c, r, o, l)) : this.left.lineAt(l, c, r, i, s).join(u);
  }
  forEachLine(e, n, r, i, s, o) {
    let l = i + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, n, r, i, s, o), n >= a && this.right.forEachLine(e, n, r, l, a, o);
    else {
      let u = this.lineAt(a, zn.ByPos, r, i, s);
      e < u.from && this.left.forEachLine(e, u.from - 1, r, i, s, o), u.to >= e && u.from <= n && o(u), n > u.to && this.right.forEachLine(u.to + 1, n, r, l, a, o);
    }
  }
  replace(e, n, r) {
    let i = this.left.length + this.break;
    if (n < i)
      return this.balanced(this.left.replace(e, n, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, n - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of r)
      s.push(l);
    if (e > 0 && lE(s, o - 1), n < this.length) {
      let l = s.length;
      this.decomposeRight(n, s), lE(s, l);
    }
    return Ni.of(s);
  }
  decomposeLeft(e, n) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
  }
  decomposeRight(e, n) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, n);
    e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? Ni.of(this.break ? [e, null, n] : [e, n]) : (this.left = gb(this.left, e), this.right = gb(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, r = !1, i) {
    let { left: s, right: o } = this, l = n + s.length + this.break, a = null;
    return i && i.from <= n + s.length && i.more ? a = s = s.updateHeight(e, n, r, i) : s.updateHeight(e, n, r), i && i.from <= l + o.length && i.more ? a = o = o.updateHeight(e, l, r, i) : o.updateHeight(e, l, r), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function lE(t, e) {
  let n, r;
  t[e] == null && (n = t[e - 1]) instanceof Wr && (r = t[e + 1]) instanceof Wr && t.splice(e - 1, 3, new Wr(n.length + 1 + r.length));
}
const GQ = 5;
class c6 {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Rs ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Rs(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, r) {
    if (e < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = n - e;
      r.block ? this.addBlock(new KR(o, i, r)) : (o || s || i >= GQ) && this.addLineDeco(i, s, o);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Rs(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let r = new Wr(n - e);
    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Rs)
      return e;
    let n = new Rs(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Rs) && !this.isCovered ? this.nodes.push(new Rs(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof Rs && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, n, r, i) {
    let s = new c6(r, e);
    return hn.spans(n, r, i, s, 0), s.finish(r);
  }
}
function KQ(t, e, n) {
  let r = new YQ();
  return hn.compare(t, e, n, r, 0), r.changes;
}
class YQ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, r, i) {
    (e < n || r && r.heightRelevant || i && i.heightRelevant) && Fy(e, n, this.changes, 5);
  }
}
function XQ(t, e) {
  let n = t.getBoundingClientRect(), r = t.ownerDocument, i = r.defaultView || window, s = Math.max(0, n.left), o = Math.min(i.innerWidth, n.right), l = Math.max(0, n.top), a = Math.min(i.innerHeight, n.bottom);
  for (let u = t.parentNode; u && u != r.body; )
    if (u.nodeType == 1) {
      let c = u, f = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && f.overflow != "visible") {
        let d = c.getBoundingClientRect();
        s = Math.max(s, d.left), o = Math.min(o, d.right), l = Math.max(l, d.top), a = Math.min(u == t.parentNode ? i.innerHeight : a, d.bottom);
      }
      u = f.position == "absolute" || f.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: s - n.left,
    right: Math.max(s, o) - n.left,
    top: l - (n.top + e),
    bottom: Math.max(l, a) - (n.top + e)
  };
}
function QQ(t) {
  let e = t.getBoundingClientRect(), n = t.ownerDocument.defaultView || window;
  return e.left < n.innerWidth && e.right > 0 && e.top < n.innerHeight && e.bottom > 0;
}
function JQ(t, e) {
  let n = t.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
class Fw {
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.size = r, this.displaySize = i;
  }
  static same(e, n) {
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = n[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, n) {
    return at.replace({
      widget: new ZQ(this.displaySize * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
}
class ZQ extends $f {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class aE {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = uE, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = jn.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = e.facet(l6).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new HQ(n), this.stateDeco = e.facet(Jp).filter((r) => typeof r != "function"), this.heightMap = Ni.empty().applyChanges(this.stateDeco, rn.empty, this.heightOracle.setDoc(e.doc), [new yo(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = at.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new O1(s, o));
      }
    }
    return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? uE : new f6(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(pp(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(Jp).filter((c) => typeof c != "function");
    let i = e.changedRanges, s = yo.extendWithRanges(i, KQ(r, this.stateDeco, e ? e.changes : Er.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    oE(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || _d) && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < a.from || n.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, n));
    let u = a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, e.flags |= this.updateForViewport(), (u || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(ER) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? jn.RTL : jn.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = n.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (l.width && l.height) {
      let { scaleX: S, scaleY: C } = nR(n, l);
      (S > 5e-3 && Math.abs(this.scaleX - S) > 5e-3 || C > 5e-3 && Math.abs(this.scaleY - C) > 5e-3) && (this.scaleX = S, this.scaleY = C, u |= 16, o = a = !0);
    }
    let f = (parseInt(r.paddingTop) || 0) * this.scaleY, d = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != f || this.paddingBottom != d) && (this.paddingTop = f, this.paddingBottom = d, u |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 16);
    let p = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != p && (this.scrollAnchorHeight = -1, this.scrollTop = p), this.scrolledToBottom = sR(e.scrollDOM);
    let m = (this.printing ? JQ : XQ)(n, this.paddingTop), y = m.top - this.pixelViewport.top, b = m.bottom - this.pixelViewport.bottom;
    this.pixelViewport = m;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v != this.inView && (this.inView = v, v && (a = !0)), !this.inView && !this.scrollTarget && !QQ(e.dom))
      return 0;
    let _ = l.width;
    if ((this.contentDOMWidth != _ || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 16), a) {
      let S = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(S) && (o = !0), o || i.lineWrapping && Math.abs(_ - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: C, charWidth: E, textHeight: A } = e.docView.measureTextSize();
        o = C > 0 && i.refresh(s, C, E, A, Math.max(5, _ / E), S), o && (e.docView.minWidth = 0, u |= 16);
      }
      y > 0 && b > 0 ? c = Math.max(y, b) : y < 0 && b < 0 && (c = Math.min(y, b)), oE();
      for (let C of this.viewports) {
        let E = C.from == this.viewport.from ? S : e.docView.measureVisibleLineHeights(C);
        this.heightMap = (o ? Ni.empty().applyChanges(this.stateDeco, rn.empty, this.heightOracle, [new yo(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new VQ(C.from, E));
      }
      _d && (u |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (u & 2 && (u |= this.updateScaler()), this.viewport = this.getViewport(c, this.scrollTarget), u |= this.updateForViewport()), (u & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new O1(i.lineAt(o - r * 1e3, zn.ByHeight, s, 0, 0).from, i.lineAt(l + (1 - r) * 1e3, zn.ByHeight, s, 0, 0).to);
    if (n) {
      let { head: u } = n.range;
      if (u < a.from || u > a.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = i.lineAt(u, zn.ByPos, s, 0, 0), d;
        n.y == "center" ? d = (f.top + f.bottom) / 2 - c / 2 : n.y == "start" || n.y == "nearest" && u < a.from ? d = f.top : d = f.bottom - c, a = new O1(i.lineAt(d - 1e3 / 2, zn.ByHeight, s, 0, 0).from, i.lineAt(d + c + 1e3 / 2, zn.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, n) {
    let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);
    return new O1(this.heightMap.lineAt(r, zn.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, zn.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: n }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, zn.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(n, zn.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || s >= l + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let r = [];
    for (let i of e)
      n.touchesRange(i.from, i.to) || r.push(new Fw(n.mapPos(i.from), n.mapPos(i.to), i.size, i.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, n) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != jn.LTR && !r)
      return [];
    let l = [], a = (c, f, d, p) => {
      if (f - c < s)
        return;
      let m = this.state.selection.main, y = [m.from];
      m.empty || y.push(m.to);
      for (let v of y)
        if (v > c && v < f) {
          a(c, v - 10, d, p), a(v + 10, f, d, p);
          return;
        }
      let b = tJ(e, (v) => v.from >= d.from && v.to <= d.to && Math.abs(v.from - c) < s && Math.abs(v.to - f) < s && !y.some((_) => v.from < _ && v.to > _));
      if (!b) {
        if (f < d.to && n && r && n.visibleRanges.some((k) => k.from <= f && k.to >= f)) {
          let k = n.moveToLineBoundary(de.cursor(f), !1, !0).head;
          k > c && (f = k);
        }
        let v = this.gapSize(d, c, f, p), _ = r || v < 2e6 ? v : 2e6;
        b = new Fw(c, f, v, _);
      }
      l.push(b);
    }, u = (c) => {
      if (c.length < o || c.type != Ii.Text)
        return;
      let f = eJ(c.from, c.to, this.stateDeco);
      if (f.total < o)
        return;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, p, m;
      if (r) {
        let y = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, b, v;
        if (d != null) {
          let _ = T1(f, d), k = ((this.visibleBottom - this.visibleTop) / 2 + y) / c.height;
          b = _ - k, v = _ + k;
        } else
          b = (this.visibleTop - c.top - y) / c.height, v = (this.visibleBottom - c.top + y) / c.height;
        p = F1(f, b), m = F1(f, v);
      } else {
        let y = f.total * this.heightOracle.charWidth, b = i * this.heightOracle.charWidth, v = 0;
        if (y > 2e6)
          for (let E of e)
            E.from >= c.from && E.from < c.to && E.size != E.displaySize && E.from * this.heightOracle.charWidth + v < this.pixelViewport.left && (v = E.size - E.displaySize);
        let _ = this.pixelViewport.left + v, k = this.pixelViewport.right + v, S, C;
        if (d != null) {
          let E = T1(f, d), A = ((k - _) / 2 + b) / y;
          S = E - A, C = E + A;
        } else
          S = (_ - b) / y, C = (k + b) / y;
        p = F1(f, S), m = F1(f, C);
      }
      p > c.from && a(c.from, p, c, f), m < c.to && a(m, c.to, c, f);
    };
    for (let c of this.viewportLines)
      Array.isArray(c.type) ? c.type.forEach(u) : u(c);
    return l;
  }
  gapSize(e, n, r, i) {
    let s = T1(i, r) - T1(i, n);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Fw.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = at.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let n = this.stateDeco;
    this.lineGaps.length && (n = n.concat(this.lineGapDeco));
    let r = [];
    hn.spans(n, this.viewport.from, this.viewport.to, {
      span(s, o) {
        r.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (r.length != this.visibleRanges.length)
      i = 12;
    else
      for (let s = 0; s < r.length && !(i & 8); s++) {
        let o = this.visibleRanges[s], l = r[s];
        (o.from != l.from || o.to != l.to) && (i |= 4, e && e.mapPos(o.from, -1) == l.from && e.mapPos(o.to, 1) == l.to || (i |= 8));
      }
    return this.visibleRanges = r, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || pp(this.heightMap.lineAt(e, zn.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || pp(this.heightMap.lineAt(this.scaler.fromDOM(e), zn.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return pp(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class O1 {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
function eJ(t, e, n) {
  let r = [], i = t, s = 0;
  return hn.spans(n, t, e, {
    span() {
    },
    point(o, l) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = l;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };
}
function F1({ total: t, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(t * n);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], l = o - s;
    if (r <= l)
      return s + r;
    r -= l;
  }
}
function T1(t, e) {
  let n = 0;
  for (let { from: r, to: i } of t.ranges) {
    if (e <= i) {
      n += e - r;
      break;
    }
    n += i - r;
  }
  return n / t.total;
}
function tJ(t, e) {
  for (let n of t)
    if (e(n))
      return n;
}
const uE = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class f6 {
  constructor(e, n, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: l, to: a }) => {
      let u = n.lineAt(l, zn.ByPos, e, 0, 0).top, c = n.lineAt(a, zn.ByPos, e, 0, 0).bottom;
      return i += c - u, { from: l, to: a, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (n.height - i);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.top)
        return i + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.domTop)
        return r + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof f6 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to) : !1;
  }
}
function pp(t, e) {
  if (e.scale == 1)
    return t;
  let n = e.toDOM(t.top), r = e.toDOM(t.bottom);
  return new El(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => pp(i, e)) : t._content);
}
const R1 = /* @__PURE__ */ ze.define({ combine: (t) => t.join(" ") }), r4 = /* @__PURE__ */ ze.define({ combine: (t) => t.indexOf(!0) > -1 }), i4 = /* @__PURE__ */ rc.newName(), YR = /* @__PURE__ */ rc.newName(), XR = /* @__PURE__ */ rc.newName(), QR = { "&light": "." + YR, "&dark": "." + XR };
function s4(t, e, n) {
  return new rc(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!n || !n[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return n[i];
      }) : t + " " + r;
    }
  });
}
const nJ = /* @__PURE__ */ s4("." + i4, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, QR), rJ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Tw = Le.ie && Le.ie_version <= 11;
class iJ {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new zX(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (Le.ie && Le.ie_version <= 11 || Le.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && Le.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(Le.chrome && Le.chrome_version < 126) && (this.editContext = new oJ(e), e.state.facet(Pa) && (e.contentDOM.editContext = this.editContext.editContext)), Tw && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(Pa) ? r.root.activeElement != this.dom : !Oy(this.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (Le.ie && Le.ie_version <= 11 || Le.android && Le.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Ep(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, n = Xp(e.root);
    if (!n)
      return !1;
    let r = Le.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && sJ(this.view, n) || n;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = Oy(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && qX(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = n)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, rJ), Tw && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Tw && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Hh(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, r = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), n == -1 ? { from: n, to: r } = o : (n = Math.min(o.from, n), r = Math.max(o.to, r)));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && Oy(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new kQ(this.view, e, n, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = LR(this.view, n);
    return this.view.state == r && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let r = cE(n, e.previousSibling || e.target.previousSibling, -1), i = cE(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? n.posAfter(r) : n.posAtStart,
        to: i ? n.posBefore(i) : n.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Pa) != e.state.facet(Pa) && (e.view.contentDOM.editContext = e.state.facet(Pa) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function cE(t, e, n) {
  for (; e; ) {
    let r = Sn.get(e);
    if (r && r.parent == t)
      return r;
    let i = e.parentNode;
    e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function fE(t, e) {
  let n = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = t.docView.domAtPos(t.state.selection.main.anchor);
  return Ep(o.node, o.offset, i, s) && ([n, r, i, s] = [i, s, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s };
}
function sJ(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return fE(t, i);
  }
  let n = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), n ? fE(t, n) : null;
}
class oJ {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let n = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let i = e.state.selection.main, { anchor: s, head: o } = i, l = this.toEditorPos(r.updateRangeStart), a = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: l, drifted: !1 });
      let u = a - l > r.text.length;
      l == this.from && s < this.from ? l = s : a == this.to && s > this.to && (a = s);
      let c = $R(e.state.sliceDoc(l, a), r.text, (u ? i.from : i.to) - l, u ? "end" : null);
      if (!c) {
        let d = de.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        d.main.eq(i) || e.dispatch({ selection: d, userEvent: "select" });
        return;
      }
      let f = {
        from: c.from + l,
        to: c.toA + l,
        insert: rn.of(r.text.slice(c.from, c.toB).split(`
`))
      };
      if ((Le.mac || Le.android) && f.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (f = { from: l, to: a, insert: rn.of([r.text.replace(".", " ")]) }), this.pendingContextChange = f, !e.state.readOnly) {
        let d = this.to - this.from + (f.to - f.from + f.insert.length);
        u6(e, f, de.single(this.toEditorPos(r.selectionStart, d), this.toEditorPos(r.selectionEnd, d)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), f.from < f.to && !f.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(n.text.slice(Math.max(0, r.updateRangeStart - 1), Math.min(n.text.length, r.updateRangeStart + 1))) && this.handlers.compositionend(r);
    }, this.handlers.characterboundsupdate = (r) => {
      let i = [], s = null;
      for (let o = this.toEditorPos(r.rangeStart), l = this.toEditorPos(r.rangeEnd); o < l; o++) {
        let a = e.coordsForChar(o);
        s = a && new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top) || s || new DOMRect(), i.push(s);
      }
      n.updateCharacterBounds(r.rangeStart, i);
    }, this.handlers.textformatupdate = (r) => {
      let i = [];
      for (let s of r.getTextFormats()) {
        let o = s.underlineStyle, l = s.underlineThickness;
        if (!/none/i.test(o) && !/none/i.test(l)) {
          let a = this.toEditorPos(s.rangeStart), u = this.toEditorPos(s.rangeEnd);
          if (a < u) {
            let c = `text-decoration: underline ${/^[a-z]/.test(o) ? o + " " : o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${/thin/i.test(l) ? 1 : 2}px`;
            i.push(at.mark({ attributes: { style: c } }).range(a, u));
          }
        }
      }
      e.dispatch({ effects: OR.of(at.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      n.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let i = Xp(r.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let n = 0, r = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((s, o, l, a, u) => {
      if (r)
        return;
      let c = u.length - (o - s);
      if (i && o >= i.to)
        if (i.from == s && i.to == o && i.insert.eq(u)) {
          i = this.pendingContextChange = null, n += c, this.to += c;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (s += n, o += n, o <= this.from)
        this.from += c, this.to += c;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + u.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), u.toString()), this.to += c;
      }
      n += c;
    }), i && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let n = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), i = this.toContextPos(n.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, n = this.to - this.from) {
    e = Math.min(e, n);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let n = this.composing;
    return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class $e {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var n;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((s) => r(s, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || jX(e.parent) || document, this.viewState = new aE(e.state || nn.create(e)), e.scrollTo && e.scrollTo.is(A1) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Fh).map((i) => new Ew(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new iJ(this), this.inputState = new EQ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new UA(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof vr ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, r = !1, i, s = this.state;
    for (let d of e) {
      if (d.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((d) => d.annotation(VR)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = WR(s, o), a || (l = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (c = null)) : this.observer.clear(), s.facet(nn.phrases) != this.state.facet(nn.phrases))
      return this.setState(s);
    i = pb.create(this, s, e), i.flags |= l;
    let f = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (f && (f = f.map(d.changes)), d.scrollIntoView) {
          let { main: p } = d.state.selection;
          f = new Vh(p.empty ? p : de.cursor(p.head, p.head > p.anchor ? -1 : 1));
        }
        for (let p of d.effects)
          p.is(A1) && (f = p.value.clip(this.state));
      }
      this.viewState.update(i, f), this.bidiCache = mb.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(hp) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(R1) != i.state.facet(R1) && (this.viewState.mustMeasureContent = !0), (n || r || f || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
      for (let d of this.state.facet(Z_))
        try {
          d(i);
        } catch (p) {
          Mi(this.state, p, "update listener");
        }
    (a || c) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), c && !LR(this, c) && u.force && Hh(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new aE(e), this.plugins = e.facet(Fh).map((r) => new Ew(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new UA(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(Fh), r = e.state.facet(Fh);
    if (n != r) {
      let i = [];
      for (let s of r) {
        let o = n.indexOf(s);
        if (o < 0)
          i.push(new Ew(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (r) {
          Mi(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (sR(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let p = this.viewState.scrollAnchorAt(i);
            s = p.from, o = p.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        a & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((p) => {
          try {
            return p.read(this);
          } catch (m) {
            return Mi(this.state, m), hE;
          }
        }), f = pb.create(this, this.state, []), d = !1;
        f.flags |= a, n ? n.flags |= a : n = f, this.updateState = 2, f.empty || (this.updatePlugins(f), this.inputState.update(f), this.updateAttrs(), d = this.docView.update(f), d && this.docViewUpdate());
        for (let p = 0; p < u.length; p++)
          if (c[p] != hE)
            try {
              let m = u[p];
              m.write && m.write(c[p], this);
            } catch (m) {
              Mi(this.state, m);
            }
        if (d && this.docView.updateSelection(!0), !f.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let m = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (m > 1 || m < -1) {
                i = i + m, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let l of this.state.facet(Z_))
        l(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return i4 + " " + (this.state.facet(r4) ? XR : YR) + " " + this.state.facet(R1);
  }
  updateAttrs() {
    let e = dE(this, FR, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Pa) ? "true" : "false",
      class: "cm-content",
      style: `${Le.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), dE(this, l6, n);
    let r = this.observer.ignore(() => {
      let i = K_(this.contentDOM, this.contentAttrs, n), s = K_(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = n, r;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is($e.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(hp);
    let e = this.state.facet($e.cspNonce);
    rc.mount(this.root, this.styleModules.concat(nJ).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.plugin != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.plugin == e) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, n, r) {
    return Ow(this, e, KA(this, e, n, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, n) {
    return Ow(this, e, KA(this, e, n, (r) => bQ(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, n) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = r[n ? r.length - 1 : 0];
    return de.cursor(s.side(n, i) + e.from, s.forward(!n, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, n, r = !0) {
    return yQ(this, e, n, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, n, r) {
    return Ow(this, e, vQ(this, e, n, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), IR(this, e, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, n);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Pu.find(s, e - i.from, -1, n)];
    return jv(r, o.dir == jn.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(AR) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > lJ)
      return bR(e.length);
    let n = this.textDirectionAt(e.from), r;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == n && (s.fresh || yR(s.isolates, r = qA(this, e))))
        return s.order;
    r || (r = qA(this, e));
    let i = tQ(e.text, n, r);
    return this.bidiCache.push(new mb(e.from, e.to, n, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Le.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      rR(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, n = {}) {
    return A1.of(new Vh(typeof e == "number" ? de.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return A1.of(new Vh(de.cursor(r.from), "start", "start", r.top - e, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return wr.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return wr.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, n) {
    let r = rc.newName(), i = [R1.of(r), hp.of(s4(`.${r}`, e))];
    return n && n.dark && i.push(r4.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return pc.lowest(hp.of(s4("." + i4, e, QR)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var n;
    let r = e.querySelector(".cm-content"), i = r && Sn.get(r) || Sn.get(e);
    return ((n = i?.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
$e.styleModule = hp;
$e.inputHandler = CR;
$e.clipboardInputFilter = s6;
$e.clipboardOutputFilter = o6;
$e.scrollHandler = DR;
$e.focusChangeEffect = SR;
$e.perLineTextDirection = AR;
$e.exceptionSink = kR;
$e.updateListener = Z_;
$e.editable = Pa;
$e.mouseSelectionStyle = _R;
$e.dragMovesSelection = wR;
$e.clickAddsSelectionRange = xR;
$e.decorations = Jp;
$e.outerDecorations = TR;
$e.atomicRanges = Qg;
$e.bidiIsolatedRanges = RR;
$e.scrollMargins = MR;
$e.darkTheme = r4;
$e.cspNonce = /* @__PURE__ */ ze.define({ combine: (t) => t.length ? t[0] : "" });
$e.contentAttributes = l6;
$e.editorAttributes = FR;
$e.lineWrapping = /* @__PURE__ */ $e.contentAttributes.of({ class: "cm-lineWrapping" });
$e.announce = /* @__PURE__ */ St.define();
const lJ = 4096, hE = {};
class mb {
  constructor(e, n, r, i, s, o) {
    this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, n) {
    if (n.empty && !e.some((s) => s.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : jn.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !n.touchesRange(o.from, o.to) && r.push(new mb(n.mapPos(o.from, 1), n.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function dE(t, e, n) {
  for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(t) : s;
    o && G_(o, n);
  }
  return n;
}
const aJ = Le.mac ? "mac" : Le.windows ? "win" : Le.linux ? "linux" : "key";
function uJ(t, e) {
  const n = t.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, l;
  for (let a = 0; a < n.length - 1; ++a) {
    const u = n[a];
    if (/^(cmd|meta|m)$/i.test(u))
      l = !0;
    else if (/^a(lt)?$/i.test(u))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      s = !0;
    else if (/^s(hift)?$/i.test(u))
      o = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), l && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function M1(t, e, n) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const cJ = /* @__PURE__ */ pc.default(/* @__PURE__ */ $e.domEventHandlers({
  keydown(t, e) {
    return ZR(JR(e.state), t, e, "editor");
  }
})), Uv = /* @__PURE__ */ ze.define({ enables: cJ }), pE = /* @__PURE__ */ new WeakMap();
function JR(t) {
  let e = t.facet(Uv), n = pE.get(e);
  return n || pE.set(e, n = dJ(e.reduce((r, i) => r.concat(i), []))), n;
}
function fJ(t, e, n) {
  return ZR(JR(t.state), e, t, n);
}
let Ou = null;
const hJ = 4e3;
function dJ(t, e = aJ) {
  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, l) => {
    let a = r[o];
    if (a == null)
      r[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, u, c) => {
    var f, d;
    let p = n[o] || (n[o] = /* @__PURE__ */ Object.create(null)), m = l.split(/ (?!$)/).map((v) => uJ(v, e));
    for (let v = 1; v < m.length; v++) {
      let _ = m.slice(0, v).join(" ");
      i(_, !0), p[_] || (p[_] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let S = Ou = { view: k, prefix: _, scope: o };
          return setTimeout(() => {
            Ou == S && (Ou = null);
          }, hJ), !0;
        }]
      });
    }
    let y = m.join(" ");
    i(y, !1);
    let b = p[y] || (p[y] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (f = p._any) === null || f === void 0 ? void 0 : f.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    a && b.run.push(a), u && (b.preventDefault = !0), c && (b.stopPropagation = !0);
  };
  for (let o of t) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let u of l) {
        let c = n[u] || (n[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: f } = o;
        for (let d in c)
          c[d].run.push((p) => f(p, o4));
      }
    let a = o[e] || o.key;
    if (a)
      for (let u of l)
        s(u, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(u, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return n;
}
let o4 = null;
function ZR(t, e, n, r) {
  o4 = e;
  let i = IX(e), s = Ji(i, 0), o = Al(s) == i.length && i != " ", l = "", a = !1, u = !1, c = !1;
  Ou && Ou.view == n && Ou.scope == r && (l = Ou.prefix + " ", jR.indexOf(e.keyCode) < 0 && (u = !0, Ou = null));
  let f = /* @__PURE__ */ new Set(), d = (b) => {
    if (b) {
      for (let v of b.run)
        if (!f.has(v) && (f.add(v), v(n)))
          return b.stopPropagation && (c = !0), !0;
      b.preventDefault && (b.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, p = t[r], m, y;
  return p && (d(p[l + M1(i, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Le.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(Le.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (m = ic[e.keyCode]) && m != i ? (d(p[l + M1(m, e, !0)]) || e.shiftKey && (y = Yp[e.keyCode]) != i && y != m && d(p[l + M1(y, e, !1)])) && (a = !0) : o && e.shiftKey && d(p[l + M1(i, e, !0)]) && (a = !0), !a && d(p._any) && (a = !0)), u && (a = !0), a && c && e.stopPropagation(), o4 = null, a;
}
class Jg {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, n, r, i, s) {
    this.className = e, this.left = n, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, n, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = eM(e);
      return [new Jg(n, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return pJ(e, n, r);
  }
}
function eM(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == jn.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function gE(t, e, n, r) {
  let i = t.coordsAtPos(e, n * 2);
  if (!i)
    return r;
  let s = t.dom.getBoundingClientRect(), o = (i.top + i.bottom) / 2, l = t.posAtCoords({ x: s.left + 1, y: o }), a = t.posAtCoords({ x: s.right - 1, y: o });
  return l == null || a == null ? r : { from: Math.max(r.from, Math.min(l, a)), to: Math.min(r.to, Math.max(l, a)) };
}
function pJ(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to)
    return [];
  let r = Math.max(n.from, t.viewport.from), i = Math.min(n.to, t.viewport.to), s = t.textDirection == jn.LTR, o = t.contentDOM, l = o.getBoundingClientRect(), a = eM(t), u = o.querySelector(".cm-line"), c = u && window.getComputedStyle(u), f = l.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), d = l.right - (c ? parseInt(c.paddingRight) : 0), p = t4(t, r, 1), m = t4(t, i, -1), y = p.type == Ii.Text ? p : null, b = m.type == Ii.Text ? m : null;
  if (y && (t.lineWrapping || p.widgetLineBreaks) && (y = gE(t, r, 1, y)), b && (t.lineWrapping || m.widgetLineBreaks) && (b = gE(t, i, -1, b)), y && b && y.from == b.from && y.to == b.to)
    return _(k(n.from, n.to, y));
  {
    let C = y ? k(n.from, null, y) : S(p, !1), E = b ? k(null, n.to, b) : S(m, !0), A = [];
    return (y || p).to < (b || m).from - (y && b ? 1 : 0) || p.widgetLineBreaks > 1 && C.bottom + t.defaultLineHeight / 2 < E.top ? A.push(v(f, C.bottom, d, E.top)) : C.bottom < E.top && t.elementAtHeight((C.bottom + E.top) / 2).type == Ii.Text && (C.bottom = E.top = (C.bottom + E.top) / 2), _(C).concat(A).concat(_(E));
  }
  function v(C, E, A, O) {
    return new Jg(e, C - a.left, E - a.top, A - C, O - E);
  }
  function _({ top: C, bottom: E, horizontal: A }) {
    let O = [];
    for (let T = 0; T < A.length; T += 2)
      O.push(v(A[T], C, A[T + 1], E));
    return O;
  }
  function k(C, E, A) {
    let O = 1e9, T = -1e9, $ = [];
    function P(L, N, j, U, H) {
      let G = t.coordsAtPos(L, L == A.to ? -2 : 2), re = t.coordsAtPos(j, j == A.from ? 2 : -2);
      !G || !re || (O = Math.min(G.top, re.top, O), T = Math.max(G.bottom, re.bottom, T), H == jn.LTR ? $.push(s && N ? f : G.left, s && U ? d : re.right) : $.push(!s && U ? f : re.left, !s && N ? d : G.right));
    }
    let B = C ?? A.from, M = E ?? A.to;
    for (let L of t.visibleRanges)
      if (L.to > B && L.from < M)
        for (let N = Math.max(L.from, B), j = Math.min(L.to, M); ; ) {
          let U = t.state.doc.lineAt(N);
          for (let H of t.bidiSpans(U)) {
            let G = H.from + U.from, re = H.to + U.from;
            if (G >= j)
              break;
            re > N && P(Math.max(G, N), C == null && G <= B, Math.min(re, j), E == null && re >= M, H.dir);
          }
          if (N = U.to + 1, N >= j)
            break;
        }
    return $.length == 0 && P(B, C == null, M, E == null, t.textDirection), { top: O, bottom: T, horizontal: $ };
  }
  function S(C, E) {
    let A = l.top + (E ? C.top : C.bottom);
    return { top: A, bottom: A, horizontal: [] };
  }
}
function gJ(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class mJ {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Ry) != e.state.facet(Ry) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0, r = e.facet(Ry);
    for (; n < r.length && r[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, r) => !gJ(n, this.drawn[r]))) {
      let n = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), n = i;
      }
      this.drawn = e, Le.safari && Le.safari_version >= 26 && (this.dom.style.display = this.dom.firstChild ? "" : "none");
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Ry = /* @__PURE__ */ ze.define();
function tM(t) {
  return [
    wr.define((e) => new mJ(e, t)),
    Ry.of(t)
  ];
}
const Zp = /* @__PURE__ */ ze.define({
  combine(t) {
    return iu(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function yJ(t = {}) {
  return [
    Zp.of(t),
    bJ,
    vJ,
    xJ,
    ER.of(!0)
  ];
}
function nM(t) {
  return t.startState.facet(Zp) != t.state.facet(Zp);
}
const bJ = /* @__PURE__ */ tM({
  above: !0,
  markers(t) {
    let { state: e } = t, n = e.facet(Zp), r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty || n.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : de.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of Jg.forRange(t, o, l))
          r.push(a);
      }
    }
    return r;
  },
  update(t, e) {
    t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = nM(t);
    return n && mE(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    mE(e.state, t);
  },
  class: "cm-cursorLayer"
});
function mE(t, e) {
  e.style.animationDuration = t.facet(Zp).cursorBlinkRate + "ms";
}
const vJ = /* @__PURE__ */ tM({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Jg.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || nM(t);
  },
  class: "cm-selectionLayer"
}), xJ = /* @__PURE__ */ pc.highest(/* @__PURE__ */ $e.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), rM = /* @__PURE__ */ St.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), gp = /* @__PURE__ */ jr.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => r.is(rM) ? r.value : n, t);
  }
}), wJ = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let n = t.state.field(gp);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(gp) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(gp), n = e != null && t.coordsAtPos(e);
    if (!n)
      return null;
    let r = t.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(gp) != t && this.view.dispatch({ effects: rM.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function _J() {
  return [gp, wJ];
}
function yE(t, e, n, r, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(n, r), o = n, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        i(o + l.index, l);
}
function kJ(t, e) {
  let n = t.visibleRanges;
  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
    return n;
  let r = [];
  for (let { from: i, to: s } of n)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class CJ {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: n, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, i)
      this.addMatch = (l, a, u, c) => i(c, u, u + l[0].length, l, a);
    else if (typeof r == "function")
      this.addMatch = (l, a, u, c) => {
        let f = r(l, a, u);
        f && c(u, u + l[0].length, f);
      };
    else if (r)
      this.addMatch = (l, a, u, c) => c(u, u + l[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let n = new nc(), r = n.add.bind(n);
    for (let { from: i, to: s } of kJ(e, this.maxLength))
      yE(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, r));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, n) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a >= e.view.viewport.from && l <= e.view.viewport.to && (r = Math.min(l, r), i = Math.max(a, i));
    }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;
  }
  updateRange(e, n, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r), l = Math.min(s.to, i);
      if (l >= o) {
        let a = e.state.doc.lineAt(o), u = a.to < l ? e.state.doc.lineAt(l) : a, c = Math.max(s.from, a.from), f = Math.min(s.to, u.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              c = o;
              break;
            }
          for (; l < u.to; l++)
            if (this.boundary.test(u.text[l - u.from])) {
              f = l;
              break;
            }
        }
        let d = [], p, m = (y, b, v) => d.push(v.range(y, b));
        if (a == u)
          for (this.regexp.lastIndex = c - a.from; (p = this.regexp.exec(a.text)) && p.index < f - a.from; )
            this.addMatch(p, e, p.index + a.from, m);
        else
          yE(e.state.doc, this.regexp, c, f, (y, b) => this.addMatch(b, e, y, m));
        n = n.update({ filterFrom: c, filterTo: f, filter: (y, b) => y < c || b > f, add: d });
      }
    }
    return n;
  }
}
const l4 = /x/.unicode != null ? "gu" : "g", SJ = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, l4), AJ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Rw = null;
function EJ() {
  var t;
  if (Rw == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Rw = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return Rw || !1;
}
const My = /* @__PURE__ */ ze.define({
  combine(t) {
    let e = iu(t, {
      render: null,
      specialChars: SJ,
      addSpecialChars: null
    });
    return (e.replaceTabs = !EJ()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, l4)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, l4)), e;
  }
});
function DJ(t = {}) {
  return [My.of(t), OJ()];
}
let bE = null;
function OJ() {
  return bE || (bE = wr.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = at.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(My)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new CJ({
        regexp: t.specialChars,
        decoration: (e, n, r) => {
          let { doc: i } = n.state, s = Ji(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), l = n.state.tabSize, a = Xd(o.text, l, r - o.from);
            return at.replace({
              widget: new MJ((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = at.replace({ widget: new RJ(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(My);
      t.startState.facet(My) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const FJ = "â€¢";
function TJ(t) {
  return t >= 32 ? FJ : t == 10 ? "â¤" : String.fromCharCode(9216 + t);
}
class RJ extends $f {
  constructor(e, n) {
    super(), this.options = e, this.code = n;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = TJ(this.code), r = e.state.phrase("Control character") + " " + (AJ[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = n, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class MJ extends $f {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function PJ() {
  return NJ;
}
const IJ = /* @__PURE__ */ at.line({ class: "cm-activeLine" }), NJ = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, n = [];
    for (let r of t.state.selection.ranges) {
      let i = t.lineBlockAt(r.head);
      i.from > e && (n.push(IJ.range(i.from)), e = i.from);
    }
    return at.set(n);
  }
}, {
  decorations: (t) => t.decorations
}), a4 = 2e3;
function BJ(t, e, n) {
  let r = Math.min(e.line, n.line), i = Math.max(e.line, n.line), s = [];
  if (e.off > a4 || n.off > a4 || e.col < 0 || n.col < 0) {
    let o = Math.min(e.off, n.off), l = Math.max(e.off, n.off);
    for (let a = r; a <= i; a++) {
      let u = t.doc.line(a);
      u.length <= l && s.push(de.range(u.from + o, u.to + l));
    }
  } else {
    let o = Math.min(e.col, n.col), l = Math.max(e.col, n.col);
    for (let a = r; a <= i; a++) {
      let u = t.doc.line(a), c = $_(u.text, o, t.tabSize, !0);
      if (c < 0)
        s.push(de.cursor(u.to));
      else {
        let f = $_(u.text, l, t.tabSize);
        s.push(de.range(u.from + c, u.from + f));
      }
    }
  }
  return s;
}
function LJ(t, e) {
  let n = t.coordsAtPos(t.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
}
function vE(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = t.state.doc.lineAt(n), i = n - r.from, s = i > a4 ? -1 : i == r.length ? LJ(t, e.clientX) : Xd(r.text, t.state.tabSize, n - r.from);
  return { line: r.number, col: s, off: i };
}
function $J(t, e) {
  let n = vE(t, e), r = t.state.selection;
  return n ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(n.line).from), o = i.state.doc.lineAt(s);
        n = { line: o.number, col: n.col, off: Math.min(n.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let l = vE(t, i);
      if (!l)
        return r;
      let a = BJ(t.state, n, l);
      return a.length ? o ? de.create(a.concat(r.ranges)) : de.create(a) : r;
    }
  } : null;
}
function zJ(t) {
  let e = ((n) => n.altKey && n.button == 0);
  return $e.mouseSelectionStyle.of((n, r) => e(r) ? $J(n, r) : null);
}
const jJ = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, qJ = { style: "cursor: crosshair" };
function UJ(t = {}) {
  let [e, n] = jJ[t.key || "Alt"], r = wr.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || n(i));
      },
      keyup(i) {
        (i.keyCode == e || !n(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(n(i));
      }
    }
  });
  return [
    r,
    $e.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? qJ : null;
    })
  ];
}
const G0 = "-10000px";
class iM {
  constructor(e, n, r, i) {
    this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(n), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = r(o, s));
  }
  update(e, n) {
    var r;
    let i = e.state.facet(this.facet), s = i.filter((a) => a);
    if (i === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return !1;
    }
    let o = [], l = n ? [] : null;
    for (let a = 0; a < s.length; a++) {
      let u = s[a], c = -1;
      if (u) {
        for (let f = 0; f < this.tooltips.length; f++) {
          let d = this.tooltips[f];
          d && d.create == u.create && (c = f);
        }
        if (c < 0)
          o[a] = this.createTooltipView(u, a ? o[a - 1] : null), l && (l[a] = !!u.above);
        else {
          let f = o[a] = this.tooltipViews[c];
          l && (l[a] = n[c]), f.update && f.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      o.indexOf(a) < 0 && (this.removeTooltipView(a), (r = a.destroy) === null || r === void 0 || r.call(a));
    return n && (l.forEach((a, u) => n[u] = a), n.length = l.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function HJ(t = {}) {
  return Py.of(t);
}
function VJ(t) {
  let e = t.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const Py = /* @__PURE__ */ ze.define({
  combine: (t) => {
    var e, n, r;
    return {
      position: Le.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || VJ
    };
  }
}), xE = /* @__PURE__ */ new WeakMap(), h6 = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Py);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new iM(t, d6, (n, r) => this.createTooltip(n, r), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let n = e || t.geometryChanged, r = t.state.facet(Py);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      n = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      n = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let n = t.create(this.view), r = e ? e.dom : null;
    if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
    }
    return n.dom.style.position = this.position, n.dom.style.top = G0, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var t, e, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = 1, e = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (Le.gecko)
        n = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == G0 && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        n = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (t = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), i = a6(this.view);
    return {
      visible: {
        left: r.left + i.left,
        top: r.top + i.top,
        right: r.right - i.right,
        bottom: r.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, o) => {
        let l = this.manager.tooltipViews[o];
        return l.getCoords ? l.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(Py).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { visible: n, space: r, scaleX: i, scaleY: s } = t, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let a = this.manager.tooltips[l], u = this.manager.tooltipViews[l], { dom: c } = u, f = t.pos[l], d = t.size[l];
      if (!f || a.clip !== !1 && (f.bottom <= Math.max(n.top, r.top) || f.top >= Math.min(n.bottom, r.bottom) || f.right < Math.max(n.left, r.left) - 0.1 || f.left > Math.min(n.right, r.right) + 0.1)) {
        c.style.top = G0;
        continue;
      }
      let p = a.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, m = p ? 7 : 0, y = d.right - d.left, b = (e = xE.get(u)) !== null && e !== void 0 ? e : d.bottom - d.top, v = u.offset || GJ, _ = this.view.textDirection == jn.LTR, k = d.width > r.right - r.left ? _ ? r.left : r.right - d.width : _ ? Math.max(r.left, Math.min(f.left - (p ? 14 : 0) + v.x, r.right - y)) : Math.min(Math.max(r.left, f.left - y + (p ? 14 : 0) - v.x), r.right - y), S = this.above[l];
      !a.strictSide && (S ? f.top - b - m - v.y < r.top : f.bottom + b + m + v.y > r.bottom) && S == r.bottom - f.bottom > f.top - r.top && (S = this.above[l] = !S);
      let C = (S ? f.top - r.top : r.bottom - f.bottom) - m;
      if (C < b && u.resize !== !1) {
        if (C < this.view.defaultLineHeight) {
          c.style.top = G0;
          continue;
        }
        xE.set(u, b), c.style.height = (b = C) / s + "px";
      } else c.style.height && (c.style.height = "");
      let E = S ? f.top - b - m - v.y : f.bottom + m + v.y, A = k + y;
      if (u.overlap !== !0)
        for (let O of o)
          O.left < A && O.right > k && O.top < E + b && O.bottom > E && (E = S ? O.top - b - 2 - m : O.bottom + m + 2);
      if (this.position == "absolute" ? (c.style.top = (E - t.parent.top) / s + "px", wE(c, (k - t.parent.left) / i)) : (c.style.top = E / s + "px", wE(c, k / i)), p) {
        let O = f.left + (_ ? v.x : -v.x) - (k + 14 - 7);
        p.style.left = O / i + "px";
      }
      u.overlap !== !0 && o.push({ left: k, top: E, right: A, bottom: E + b }), c.classList.toggle("cm-tooltip-above", S), c.classList.toggle("cm-tooltip-below", !S), u.positioned && u.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = G0;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function wE(t, e) {
  let n = parseInt(t.style.left, 10);
  (isNaN(n) || Math.abs(e - n) > 1) && (t.style.left = e + "px");
}
const WJ = /* @__PURE__ */ $e.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), GJ = { x: 0, y: 0 }, d6 = /* @__PURE__ */ ze.define({
  enables: [h6, WJ]
}), yb = /* @__PURE__ */ ze.define({
  combine: (t) => t.reduce((e, n) => e.concat(n), [])
});
class Hv {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Hv(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new iM(e, yb, (n, r) => this.createHostedView(n, r), (n) => n.dom.remove());
  }
  createHostedView(e, n) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews)
      (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (n === void 0)
          n = i;
        else if (n !== i)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const KJ = /* @__PURE__ */ d6.compute([yb], (t) => {
  let e = t.facet(yb);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((n) => n.pos)),
    end: Math.max(...e.map((n) => {
      var r;
      return (r = n.end) !== null && r !== void 0 ? r : n.pos;
    })),
    create: Hv.create,
    above: e[0].above,
    arrow: e.some((n) => n.arrow)
  };
});
class YJ {
  constructor(e, n, r, i, s) {
    this.view = e, this.source = n, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this, r = e.docView.nearest(n.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof Mu)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(n), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || n.y < l.top || n.y > l.bottom || n.x < l.left - e.defaultCharacterWidth || n.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(i)).find((c) => c.from <= i && c.to >= i), u = a && a.dir == jn.RTL ? -1 : 1;
      s = n.x < l.left ? -u : u;
    }
    let o = this.source(e, i, s);
    if (o?.then) {
      let l = this.pending = { pos: i };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) }));
      }, (a) => Mi(e.state, a, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(h6), n = e ? e.manager.tooltips.findIndex((r) => r.create == Hv.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !XJ(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, l = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : o;
      (o == l ? this.view.posAtCoords(this.lastMove) != o : !QJ(this.view, o, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (r) => {
      e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const P1 = 4;
function XJ(t, e) {
  let { left: n, right: r, top: i, bottom: s } = t.getBoundingClientRect(), o;
  if (o = t.querySelector(".cm-tooltip-arrow")) {
    let l = o.getBoundingClientRect();
    i = Math.min(l.top, i), s = Math.max(l.bottom, s);
  }
  return e.clientX >= n - P1 && e.clientX <= r + P1 && e.clientY >= i - P1 && e.clientY <= s + P1;
}
function QJ(t, e, n, r, i, s) {
  let o = t.scrollDOM.getBoundingClientRect(), l = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, l) < i)
    return !1;
  let a = t.posAtCoords({ x: r, y: i }, !1);
  return a >= e && a <= n;
}
function sM(t, e = {}) {
  let n = St.define(), r = jr.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let l of i) {
          let a = s.changes.mapPos(l.pos, -1, Kr.TrackDel);
          if (a != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), l);
            u.pos = a, u.end != null && (u.end = s.changes.mapPos(u.end)), o.push(u);
          }
        }
        i = o;
      }
      for (let o of s.effects)
        o.is(n) && (i = o.value), o.is(JJ) && (i = []);
      return i;
    },
    provide: (i) => yb.from(i)
  });
  return {
    active: r,
    extension: [
      r,
      wr.define((i) => new YJ(
        i,
        t,
        r,
        n,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      KJ
    ]
  };
}
function oM(t, e) {
  let n = t.plugin(h6);
  if (!n)
    return null;
  let r = n.manager.tooltips.indexOf(e);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const JJ = /* @__PURE__ */ St.define(), _E = /* @__PURE__ */ ze.define({
  combine(t) {
    let e, n;
    for (let r of t)
      e = e || r.topContainer, n = n || r.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function eg(t, e) {
  let n = t.plugin(lM), r = n ? n.specs.indexOf(e) : -1;
  return r > -1 ? n.panels[r] : null;
}
const lM = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(tg), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
    let e = t.state.facet(_E);
    this.top = new I1(t, !0, e.topContainer), this.bottom = new I1(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(t) {
    let e = t.state.facet(_E);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new I1(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new I1(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = t.state.facet(tg);
    if (n != this.input) {
      let r = n.filter((a) => a), i = [], s = [], o = [], l = [];
      for (let a of r) {
        let u = this.specs.indexOf(a), c;
        u < 0 ? (c = a(t.view), l.push(c)) : (c = this.panels[u], c.update && c.update(t)), i.push(c), (c.top ? s : o).push(c);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => $e.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class I1 {
  constructor(e, n, r) {
    this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = kE(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = kE(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function kE(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const tg = /* @__PURE__ */ ze.define({
  enables: lM
});
class oc extends xf {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
oc.prototype.elementClass = "";
oc.prototype.toDOM = void 0;
oc.prototype.mapMode = Kr.TrackBefore;
oc.prototype.startSide = oc.prototype.endSide = -1;
oc.prototype.point = !0;
const Iy = /* @__PURE__ */ ze.define(), ZJ = /* @__PURE__ */ ze.define(), Ny = /* @__PURE__ */ ze.define(), CE = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e)
});
function eZ(t) {
  return [
    tZ
  ];
}
const tZ = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.view = t, this.domAfter = null, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Ny).map((e) => new AE(t, e)), this.fixed = !t.state.facet(CE);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(r < (n.to - n.from) * 0.8);
    }
    if (t.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(CE) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let n = hn.iter(this.view.state.facet(Iy), this.view.viewport.from), r = [], i = this.gutters.map((s) => new nZ(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == Ii.Text && o) {
            u4(n, r, l.from);
            for (let a of i)
              a.line(this.view, l, r);
            o = !1;
          } else if (l.widget)
            for (let a of i)
              a.widget(this.view, l);
      } else if (s.type == Ii.Text) {
        u4(n, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    t && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(t) {
    let e = t.startState.facet(Ny), n = t.state.facet(Ny), r = t.docChanged || t.heightChanged || t.viewportChanged || !hn.eq(t.startState.facet(Iy), t.state.facet(Iy), t.view.viewport.from, t.view.viewport.to);
    if (e == n)
      for (let i of this.gutters)
        i.update(t) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of n) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new AE(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        s.config.side == "after" ? this.getDOMAfter().appendChild(s.dom) : this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (t) => $e.scrollMargins.of((e) => {
    let n = e.plugin(t);
    if (!n || n.gutters.length == 0 || !n.fixed)
      return null;
    let r = n.dom.offsetWidth * e.scaleX, i = n.domAfter ? n.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == jn.LTR ? { left: r, right: i } : { right: r, left: i };
  })
});
function SE(t) {
  return Array.isArray(t) ? t : [t];
}
function u4(t, e, n) {
  for (; t.value && t.from <= n; )
    t.from == n && e.push(t.value), t.next();
}
class nZ {
  constructor(e, n, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = hn.iter(e.markers, n.from);
  }
  addElement(e, n, r) {
    let { gutter: i } = this, s = (n.top - this.height) / e.scaleY, o = n.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new aM(e, o, s, r);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, o, s, r);
    this.height = n.bottom, this.i++;
  }
  line(e, n, r) {
    let i = [];
    u4(this.cursor, i, n.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, n, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, n, i);
  }
  widget(e, n) {
    let r = this.gutter.config.widgetMarker(e, n.widget, n), i = r ? [r] : null;
    for (let s of e.state.facet(ZJ)) {
      let o = s(e, n.widget, n);
      o && (i || (i = [])).push(o);
    }
    i && this.addElement(e, n, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class AE {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        n.domEventHandlers[r](e, l, i) && i.preventDefault();
      });
    this.markers = SE(n.markers(e)), n.initialSpacer && (this.spacer = new aM(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = SE(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !hn.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class aM {
  constructor(e, n, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, i);
  }
  update(e, n, r, i) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), rZ(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, n) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < n.length ? n[s++] : null, u = !1;
      if (a) {
        let c = a.elementClass;
        c && (r += " " + c);
        for (let f = o; f < this.markers.length; f++)
          if (this.markers[f].compare(a)) {
            l = f, u = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let c = this.markers[o++];
        if (c.toDOM) {
          c.destroy(i);
          let f = i.nextSibling;
          i.remove(), i = f;
        }
      }
      if (!a)
        break;
      a.toDOM && (u ? i = i.nextSibling : this.dom.insertBefore(a.toDOM(e), i)), u && o++;
    }
    this.dom.className = r, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function rZ(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].compare(e[n]))
      return !1;
  return !0;
}
const iZ = /* @__PURE__ */ ze.define(), sZ = /* @__PURE__ */ ze.define(), Th = /* @__PURE__ */ ze.define({
  combine(t) {
    return iu(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let r = Object.assign({}, e);
        for (let i in n) {
          let s = r[i], o = n[i];
          r[i] = s ? (l, a, u) => s(l, a, u) || o(l, a, u) : o;
        }
        return r;
      }
    });
  }
});
class Mw extends oc {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Pw(t, e) {
  return t.state.facet(Th).formatNumber(e, t.state);
}
const oZ = /* @__PURE__ */ Ny.compute([Th], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(iZ);
  },
  lineMarker(e, n, r) {
    return r.some((i) => i.toDOM) ? null : new Mw(Pw(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: (e, n, r) => {
    for (let i of e.state.facet(sZ)) {
      let s = i(e, n, r);
      if (s)
        return s;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Th) != e.state.facet(Th),
  initialSpacer(e) {
    return new Mw(Pw(e, EE(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let r = Pw(n.view, EE(n.view.state.doc.lines));
    return r == e.number ? e : new Mw(r);
  },
  domEventHandlers: t.facet(Th).domEventHandlers,
  side: "before"
}));
function lZ(t = {}) {
  return [
    Th.of(t),
    eZ(),
    oZ
  ];
}
function EE(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const aZ = /* @__PURE__ */ new class extends oc {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), uZ = /* @__PURE__ */ Iy.compute(["selection"], (t) => {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.head).from;
    i > n && (n = i, e.push(aZ.range(i)));
  }
  return hn.of(e);
});
function cZ() {
  return uZ;
}
const uM = 1024;
let fZ = 0;
class Iw {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
class Mt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = fZ++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    }), this.combine = e.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = cs.match(e)), (n) => {
      let r = e(n);
      return r === void 0 ? null : [this, r];
    };
  }
}
Mt.closedBy = new Mt({ deserialize: (t) => t.split(" ") });
Mt.openedBy = new Mt({ deserialize: (t) => t.split(" ") });
Mt.group = new Mt({ deserialize: (t) => t.split(" ") });
Mt.isolate = new Mt({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Mt.contextHash = new Mt({ perNode: !0 });
Mt.lookAhead = new Mt({ perNode: !0 });
Mt.mounted = new Mt({ perNode: !0 });
class bb {
  constructor(e, n, r) {
    this.tree = e, this.overlay = n, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Mt.mounted.id];
  }
}
const hZ = /* @__PURE__ */ Object.create(null);
class cs {
  /**
  @internal
  */
  constructor(e, n, r, i = 0) {
    this.name = e, this.props = n, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : hZ, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new cs(e.name || "", n, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let n = this.prop(Mt.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        n[i] = e[r];
    return (r) => {
      for (let i = r.prop(Mt.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = n[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
}
cs.none = new cs(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class p6 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        if (o) {
          i || (i = Object.assign({}, r.props));
          let l = o[1], a = o[0];
          a.combine && a.id in i && (l = a.combine(i[a.id], l)), i[a.id] = l;
        }
      }
      n.push(i ? new cs(r.name, i, r.id, r.flags) : r);
    }
    return new p6(n);
  }
}
const N1 = /* @__PURE__ */ new WeakMap(), DE = /* @__PURE__ */ new WeakMap();
var Ir;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ir || (Ir = {}));
class xr {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, n, r, i, s) {
    if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = bb.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), n += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new f4(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, n = 0, r = 0) {
    let i = N1.get(this) || this.topNode, s = new f4(i);
    return s.moveTo(e, n), N1.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new bo(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, n = 0) {
    let r = ng(N1.get(this) || this.topNode, e, n, !1);
    return N1.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, n = 0) {
    let r = ng(DE.get(this) || this.topNode, e, n, !0);
    return DE.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, n = 0) {
    return gZ(this, e, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: n, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & Ir.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | Ir.IncludeAnonymous); ; ) {
      let u = !1;
      if (a.from <= s && a.to >= i && (!l && a.type.isAnonymous || n(a) !== !1)) {
        if (a.firstChild())
          continue;
        u = !0;
      }
      for (; u && r && (l || !a.type.isAnonymous) && r(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : y6(cs.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new xr(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new xr(cs.none, n, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return mZ(e);
  }
}
xr.empty = new xr(cs.none, [], [], 0);
class g6 {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new g6(this.buffer, this.index);
  }
}
class lc {
  /**
  Create a tree buffer.
  */
  constructor(e, n, r) {
    this.buffer = e, this.length = n, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return cs.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, n, r, i, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != n && !(cM(s, i, o[a + 1], o[a + 2]) && (l = a, r > 0)); a = o[a + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, n, r) {
    let i = this.buffer, s = new Uint16Array(n - e), o = 0;
    for (let l = e, a = 0; l < n; ) {
      s[a++] = i[l++], s[a++] = i[l++] - r;
      let u = s[a++] = i[l++] - r;
      s[a++] = i[l++] - e, o = Math.max(o, u);
    }
    return new lc(s, o, this.set);
  }
}
function cM(t, e, n, r) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return r >= e && n < e;
    case 0:
      return n < e && r > e;
    case 1:
      return n <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function ng(t, e, n, r) {
  for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let o = !r && t instanceof bo && t.index < 0 ? null : t.parent;
    if (!o)
      return t;
    t = o;
  }
  let s = r ? 0 : Ir.IgnoreOverlays;
  if (r)
    for (let o = t, l = o.parent; l; o = l, l = o.parent)
      o instanceof bo && o.index < 0 && ((i = l.enter(e, n, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = l);
  for (; ; ) {
    let o = t.enter(e, n, s);
    if (!o)
      return t;
    t = o;
  }
}
class fM {
  cursor(e = 0) {
    return new f4(this, e);
  }
  getChild(e, n = null, r = null) {
    let i = OE(this, e, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, n = null, r = null) {
    return OE(this, e, n, r);
  }
  resolve(e, n = 0) {
    return ng(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return ng(this, e, n, !0);
  }
  matchContext(e) {
    return c4(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to)
        break;
      i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class bo extends fM {
  constructor(e, n, r, i) {
    super(), this._tree = e, this.from = n, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, u = n > 0 ? l.length : -1; e != u; e += n) {
        let c = l[e], f = a[e] + o.from;
        if (cM(i, r, f, f + c.length)) {
          if (c instanceof lc) {
            if (s & Ir.ExcludeBuffers)
              continue;
            let d = c.findChild(0, c.buffer.length, n, r - f, i);
            if (d > -1)
              return new Iu(new dZ(o, c, e, f), null, d);
          } else if (s & Ir.IncludeAnonymous || !c.type.isAnonymous || m6(c)) {
            let d;
            if (!(s & Ir.IgnoreMounts) && (d = bb.get(c)) && !d.overlay)
              return new bo(d.tree, f, e, o);
            let p = new bo(c, f, e, o);
            return s & Ir.IncludeAnonymous || !p.type.isAnonymous ? p : p.nextChild(n < 0 ? c.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (s & Ir.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + n : e = n < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    let i;
    if (!(r & Ir.IgnoreOverlays) && (i = bb.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((n > 0 ? o <= s : o < s) && (n < 0 ? l >= s : l > s))
          return new bo(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function OE(t, e, n, r) {
  let i = t.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (n != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(n), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function c4(t, e, n = e.length - 1) {
  for (let r = t; n >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[n] && e[n] != r.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class dZ {
  constructor(e, n, r, i) {
    this.parent = e, this.buffer = n, this.index = r, this.start = i;
  }
}
class Iu extends fM {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, r) {
    super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, n, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
    return s < 0 ? null : new Iu(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    if (r & Ir.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return s < 0 ? null : new Iu(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Iu(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Iu(this.context, this._parent, e.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), n.push(0);
    }
    return new xr(this.type, e, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function hM(t) {
  if (!t.length)
    return null;
  let e = 0, n = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > n.from || o.to < n.to) && (n = o, e = s);
  }
  let r = n instanceof bo && n.index < 0 ? null : n.parent, i = t.slice();
  return r ? i[e] = r : i.splice(e, 1), new pZ(i, n);
}
class pZ {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return hM(this.heads);
  }
}
function gZ(t, e, n) {
  let r = t.resolveInner(e, n), i = null;
  for (let s = r instanceof bo ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, n)), s = o;
    } else {
      let o = bb.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new bo(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(ng(l, e, n, !1));
      }
    }
  return i ? hM(i) : r;
}
class f4 {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof bo)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof bo ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, n, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, n, r = this.mode) {
    return this.buffer ? r & Ir.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ir.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Ir.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(n.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: n, parent: r } = i);
    } else
      ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let s = n + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let l = r._tree.children[s];
          if (this.mode & Ir.IncludeAnonymous || l instanceof lc || !l.type.isAnonymous || m6(l))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index)
              return o;
            n = o, r = s + 1;
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = r; i < this.stack.length; i++)
      n = new Iu(this.buffer, n, this.stack[i]);
    return this.bufferNode = new Iu(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, n) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && n && n(this), i = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contextâ€”a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return c4(this.node.parent, e);
    let { buffer: n } = this.buffer, { types: r } = n.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return c4(this._tree, e, i);
      let o = r[n.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function m6(t) {
  return t.children.some((e) => e instanceof lc || !e.type.isAnonymous || m6(e));
}
function mZ(t) {
  var e;
  let { buffer: n, nodeSet: r, maxBufferLength: i = uM, reused: s = [], minRepeatType: o = r.types.length } = t, l = Array.isArray(n) ? new g6(n, n.length) : n, a = r.types, u = 0, c = 0;
  function f(C, E, A, O, T, $) {
    let { id: P, start: B, end: M, size: L } = l, N = c, j = u;
    if (L < 0)
      if (l.next(), L == -1) {
        let se = s[P];
        A.push(se), O.push(B - C);
        return;
      } else if (L == -3) {
        u = P;
        return;
      } else if (L == -4) {
        c = P;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${L}`);
    let U = a[P], H, G, re = B - C;
    if (M - B <= i && (G = b(l.pos - E, T))) {
      let se = new Uint16Array(G.size - G.skip), oe = l.pos - G.size, ne = se.length;
      for (; l.pos > oe; )
        ne = v(G.start, se, ne);
      H = new lc(se, M - G.start, r), re = G.start - C;
    } else {
      let se = l.pos - L;
      l.next();
      let oe = [], ne = [], ce = P >= o ? P : -1, we = 0, Me = M;
      for (; l.pos > se; )
        ce >= 0 && l.id == ce && l.size >= 0 ? (l.end <= Me - i && (m(oe, ne, B, we, l.end, Me, ce, N, j), we = oe.length, Me = l.end), l.next()) : $ > 2500 ? d(B, se, oe, ne) : f(B, se, oe, ne, ce, $ + 1);
      if (ce >= 0 && we > 0 && we < oe.length && m(oe, ne, B, we, B, Me, ce, N, j), oe.reverse(), ne.reverse(), ce > -1 && we > 0) {
        let Pe = p(U, j);
        H = y6(U, oe, ne, 0, oe.length, 0, M - B, Pe, Pe);
      } else
        H = y(U, oe, ne, M - B, N - M, j);
    }
    A.push(H), O.push(re);
  }
  function d(C, E, A, O) {
    let T = [], $ = 0, P = -1;
    for (; l.pos > E; ) {
      let { id: B, start: M, end: L, size: N } = l;
      if (N > 4)
        l.next();
      else {
        if (P > -1 && M < P)
          break;
        P < 0 && (P = L - i), T.push(B, M, L), $++, l.next();
      }
    }
    if ($) {
      let B = new Uint16Array($ * 4), M = T[T.length - 2];
      for (let L = T.length - 3, N = 0; L >= 0; L -= 3)
        B[N++] = T[L], B[N++] = T[L + 1] - M, B[N++] = T[L + 2] - M, B[N++] = N;
      A.push(new lc(B, T[2] - M, r)), O.push(M - C);
    }
  }
  function p(C, E) {
    return (A, O, T) => {
      let $ = 0, P = A.length - 1, B, M;
      if (P >= 0 && (B = A[P]) instanceof xr) {
        if (!P && B.type == C && B.length == T)
          return B;
        (M = B.prop(Mt.lookAhead)) && ($ = O[P] + B.length + M);
      }
      return y(C, A, O, T, $, E);
    };
  }
  function m(C, E, A, O, T, $, P, B, M) {
    let L = [], N = [];
    for (; C.length > O; )
      L.push(C.pop()), N.push(E.pop() + A - T);
    C.push(y(r.types[P], L, N, $ - T, B - $, M)), E.push(T - A);
  }
  function y(C, E, A, O, T, $, P) {
    if ($) {
      let B = [Mt.contextHash, $];
      P = P ? [B].concat(P) : [B];
    }
    if (T > 25) {
      let B = [Mt.lookAhead, T];
      P = P ? [B].concat(P) : [B];
    }
    return new xr(C, E, A, O, P);
  }
  function b(C, E) {
    let A = l.fork(), O = 0, T = 0, $ = 0, P = A.end - i, B = { size: 0, start: 0, skip: 0 };
    e: for (let M = A.pos - C; A.pos > M; ) {
      let L = A.size;
      if (A.id == E && L >= 0) {
        B.size = O, B.start = T, B.skip = $, $ += 4, O += 4, A.next();
        continue;
      }
      let N = A.pos - L;
      if (L < 0 || N < M || A.start < P)
        break;
      let j = A.id >= o ? 4 : 0, U = A.start;
      for (A.next(); A.pos > N; ) {
        if (A.size < 0)
          if (A.size == -3)
            j += 4;
          else
            break e;
        else A.id >= o && (j += 4);
        A.next();
      }
      T = U, O += L, $ += j;
    }
    return (E < 0 || O == C) && (B.size = O, B.start = T, B.skip = $), B.size > 4 ? B : void 0;
  }
  function v(C, E, A) {
    let { id: O, start: T, end: $, size: P } = l;
    if (l.next(), P >= 0 && O < o) {
      let B = A;
      if (P > 4) {
        let M = l.pos - (P - 4);
        for (; l.pos > M; )
          A = v(C, E, A);
      }
      E[--A] = B, E[--A] = $ - C, E[--A] = T - C, E[--A] = O;
    } else P == -3 ? u = O : P == -4 && (c = O);
    return A;
  }
  let _ = [], k = [];
  for (; l.pos > 0; )
    f(t.start || 0, t.bufferStart || 0, _, k, -1, 0);
  let S = (e = t.length) !== null && e !== void 0 ? e : _.length ? k[0] + _[0].length : 0;
  return new xr(a[t.topID], _.reverse(), k.reverse(), S);
}
const FE = /* @__PURE__ */ new WeakMap();
function By(t, e) {
  if (!t.isAnonymous || e instanceof lc || e.type != t)
    return 1;
  let n = FE.get(e);
  if (n == null) {
    n = 1;
    for (let r of e.children) {
      if (r.type != t || !(r instanceof xr)) {
        n = 1;
        break;
      }
      n += By(t, r);
    }
    FE.set(e, n);
  }
  return n;
}
function y6(t, e, n, r, i, s, o, l, a) {
  let u = 0;
  for (let m = r; m < i; m++)
    u += By(t, e[m]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), f = [], d = [];
  function p(m, y, b, v, _) {
    for (let k = b; k < v; ) {
      let S = k, C = y[k], E = By(t, m[k]);
      for (k++; k < v; k++) {
        let A = By(t, m[k]);
        if (E + A >= c)
          break;
        E += A;
      }
      if (k == S + 1) {
        if (E > c) {
          let A = m[S];
          p(A.children, A.positions, 0, A.children.length, y[S] + _);
          continue;
        }
        f.push(m[S]);
      } else {
        let A = y[k - 1] + m[k - 1].length - C;
        f.push(y6(t, m, y, S, k, C, A, null, a));
      }
      d.push(C + _ - s);
    }
  }
  return p(e, n, r, i, 0), (l || a)(f, d, o);
}
class sf {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, n, r, i, s = !1, o = !1) {
    this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, n = [], r = !1) {
    let i = [new sf(0, e.length, e, 0, !1, r)];
    for (let s of n)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, n, r = 128) {
    if (!n.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, u = 0; ; l++) {
      let c = l < n.length ? n[l] : null, f = c ? c.fromA : 1e9;
      if (f - a >= r)
        for (; o && o.from < f; ) {
          let d = o;
          if (a >= d.from || f <= d.to || u) {
            let p = Math.max(d.from, a) - u, m = Math.min(d.to, f) - u;
            d = p >= m ? null : new sf(p, m, d.tree, d.offset + u, l > 0, !!c);
          }
          if (d && i.push(d), o.to > f)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!c)
        break;
      a = c.toA, u = c.toA - c.toB;
    }
    return i;
  }
}
let dM = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, n, r) {
    return typeof e == "string" && (e = new yZ(e)), r = r ? r.length ? r.map((i) => new Iw(i.from, i.to)) : [new Iw(0, 0)] : [new Iw(0, e.length)], this.createParse(e, n || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, n, r) {
    let i = this.startParse(e, n, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
};
class yZ {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
new Mt({ perNode: !0 });
let bZ = 0;
class fo {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.set = n, this.base = r, this.modified = i, this.id = bZ++;
  }
  toString() {
    let { name: e } = this;
    for (let n of this.modified)
      n.name && (e = `${n.name}(${e})`);
    return e;
  }
  static define(e, n) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof fo && (n = e), n?.base)
      throw new Error("Can not derive from a modified tag");
    let i = new fo(r, [], null, []);
    if (i.set.push(i), n)
      for (let s of n.set)
        i.set.push(s);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let n = new vb(e);
    return (r) => r.modified.indexOf(n) > -1 ? r : vb.get(r.base || r, r.modified.concat(n).sort((i, s) => i.id - s.id));
  }
}
let vZ = 0;
class vb {
  constructor(e) {
    this.name = e, this.instances = [], this.id = vZ++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let r = n[0].instances.find((l) => l.base == e && xZ(n, l.modified));
    if (r)
      return r;
    let i = [], s = new fo(e.name, i, e, n);
    for (let l of n)
      l.instances.push(s);
    let o = wZ(n);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          i.push(vb.get(l, a));
    return s;
  }
}
function xZ(t, e) {
  return t.length == e.length && t.every((n, r) => n == e[r]);
}
function wZ(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(t[n]));
  return e.sort((n, r) => r.length - n.length);
}
function b6(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let s = [], o = 2, l = i;
        for (let f = 0; ; ) {
          if (l == "..." && f > 0 && f + 3 == i.length) {
            o = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!d)
            throw new RangeError("Invalid path: " + i);
          if (s.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), f += d[0].length, f == i.length)
            break;
          let p = i[f++];
          if (f == i.length && p == "!") {
            o = 0;
            break;
          }
          if (p != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(f);
        }
        let a = s.length - 1, u = s[a];
        if (!u)
          throw new RangeError("Invalid path: " + i);
        let c = new rg(r, o, a > 0 ? s.slice(0, a) : null);
        e[u] = c.sort(e[u]);
      }
  }
  return pM.add(e);
}
const pM = new Mt({
  combine(t, e) {
    let n, r, i;
    for (; t || e; ) {
      if (!t || e && t.depth >= e.depth ? (i = e, e = e.next) : (i = t, t = t.next), n && n.mode == i.mode && !i.context && !n.context)
        continue;
      let s = new rg(i.tags, i.mode, i.context);
      n ? n.next = s : r = s, n = s;
    }
    return r;
  }
});
let rg = class {
  constructor(e, n, r, i) {
    this.tags = e, this.mode = n, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
rg.empty = new rg([], 2, null);
function gM(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      n[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        n[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let a of l.set) {
          let u = n[a.id];
          if (u) {
            o = o ? o + " " + u : u;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function _Z(t, e) {
  let n = null;
  for (let r of t) {
    let i = r.style(e);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function kZ(t, e, n, r = 0, i = t.length) {
  let s = new CZ(r, Array.isArray(e) ? e : [e], n);
  s.highlightRange(t.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class CZ {
  constructor(e, n, r) {
    this.at = e, this.highlighters = n, this.span = r, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, r, i, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= r || a <= n)
      return;
    o.isTop && (s = this.highlighters.filter((p) => !p.scope || p.scope(o)));
    let u = i, c = SZ(e) || rg.empty, f = _Z(s, c.tags);
    if (f && (u && (u += " "), u += f, c.mode == 1 && (i += (i ? " " : "") + f)), this.startSpan(Math.max(n, l), u), c.opaque)
      return;
    let d = e.tree && e.tree.prop(Mt.mounted);
    if (d && d.overlay) {
      let p = e.node.enter(d.overlay[0].from + l, 1), m = this.highlighters.filter((b) => !b.scope || b.scope(d.tree.type)), y = e.firstChild();
      for (let b = 0, v = l; ; b++) {
        let _ = b < d.overlay.length ? d.overlay[b] : null, k = _ ? _.from + l : a, S = Math.max(n, v), C = Math.min(r, k);
        if (S < C && y)
          for (; e.from < C && (this.highlightRange(e, S, C, i, s), this.startSpan(Math.min(C, e.to), u), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!_ || k > r)
          break;
        v = _.to + l, v > n && (this.highlightRange(p.cursor(), Math.max(n, _.from + l), Math.min(r, v), "", m), this.startSpan(Math.min(r, v), u));
      }
      y && e.parent();
    } else if (e.firstChild()) {
      d && (i = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, n, r, i, s), this.startSpan(Math.min(r, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function SZ(t) {
  let e = t.type.prop(pM);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const Ie = fo.define, B1 = Ie(), Su = Ie(), TE = Ie(Su), RE = Ie(Su), Au = Ie(), L1 = Ie(Au), Nw = Ie(Au), ml = Ie(), Fc = Ie(ml), pl = Ie(), gl = Ie(), h4 = Ie(), K0 = Ie(h4), $1 = Ie(), ie = {
  /**
  A comment.
  */
  comment: B1,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Ie(B1),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Ie(B1),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Ie(B1),
  /**
  Any kind of identifier.
  */
  name: Su,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Ie(Su),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: TE,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Ie(TE),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: RE,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Ie(RE),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Ie(Su),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Ie(Su),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Ie(Su),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Ie(Su),
  /**
  A literal value.
  */
  literal: Au,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: L1,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Ie(L1),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Ie(L1),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Ie(L1),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Nw,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Ie(Nw),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Ie(Nw),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Ie(Au),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Ie(Au),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Ie(Au),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Ie(Au),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Ie(Au),
  /**
  A language keyword.
  */
  keyword: pl,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Ie(pl),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Ie(pl),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Ie(pl),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Ie(pl),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Ie(pl),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Ie(pl),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Ie(pl),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Ie(pl),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Ie(pl),
  /**
  An operator.
  */
  operator: gl,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Ie(gl),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Ie(gl),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Ie(gl),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Ie(gl),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Ie(gl),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Ie(gl),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Ie(gl),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Ie(gl),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Ie(gl),
  /**
  Program or markup punctuation.
  */
  punctuation: h4,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Ie(h4),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: K0,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Ie(K0),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Ie(K0),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Ie(K0),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Ie(K0),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: ml,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Fc,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Ie(Fc),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Ie(Fc),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Ie(Fc),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Ie(Fc),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Ie(Fc),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Ie(Fc),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: Ie(ml),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Ie(ml),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Ie(ml),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Ie(ml),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Ie(ml),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Ie(ml),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Ie(ml),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Ie(ml),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Ie(),
  /**
  Deleted text.
  */
  deleted: Ie(),
  /**
  Changed text.
  */
  changed: Ie(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Ie(),
  /**
  Metadata or meta-instruction.
  */
  meta: $1,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Ie($1),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Ie($1),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Ie($1),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: fo.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: fo.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: fo.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: fo.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: fo.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: fo.defineModifier("special")
};
for (let t in ie) {
  let e = ie[t];
  e instanceof fo && (e.name = t);
}
gM([
  { tag: ie.link, class: "tok-link" },
  { tag: ie.heading, class: "tok-heading" },
  { tag: ie.emphasis, class: "tok-emphasis" },
  { tag: ie.strong, class: "tok-strong" },
  { tag: ie.keyword, class: "tok-keyword" },
  { tag: ie.atom, class: "tok-atom" },
  { tag: ie.bool, class: "tok-bool" },
  { tag: ie.url, class: "tok-url" },
  { tag: ie.labelName, class: "tok-labelName" },
  { tag: ie.inserted, class: "tok-inserted" },
  { tag: ie.deleted, class: "tok-deleted" },
  { tag: ie.literal, class: "tok-literal" },
  { tag: ie.string, class: "tok-string" },
  { tag: ie.number, class: "tok-number" },
  { tag: [ie.regexp, ie.escape, ie.special(ie.string)], class: "tok-string2" },
  { tag: ie.variableName, class: "tok-variableName" },
  { tag: ie.local(ie.variableName), class: "tok-variableName tok-local" },
  { tag: ie.definition(ie.variableName), class: "tok-variableName tok-definition" },
  { tag: ie.special(ie.variableName), class: "tok-variableName2" },
  { tag: ie.definition(ie.propertyName), class: "tok-propertyName tok-definition" },
  { tag: ie.typeName, class: "tok-typeName" },
  { tag: ie.namespace, class: "tok-namespace" },
  { tag: ie.className, class: "tok-className" },
  { tag: ie.macroName, class: "tok-macroName" },
  { tag: ie.propertyName, class: "tok-propertyName" },
  { tag: ie.operator, class: "tok-operator" },
  { tag: ie.comment, class: "tok-comment" },
  { tag: ie.meta, class: "tok-meta" },
  { tag: ie.invalid, class: "tok-invalid" },
  { tag: ie.punctuation, class: "tok-punctuation" }
]);
var Bw;
const Rh = /* @__PURE__ */ new Mt();
function AZ(t) {
  return ze.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const EZ = /* @__PURE__ */ new Mt();
class Ho {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, n, r = [], i = "") {
    this.data = e, this.name = i, nn.prototype.hasOwnProperty("tree") || Object.defineProperty(nn.prototype, "tree", { get() {
      return Dr(this);
    } }), this.parser = n, this.extension = [
      Cd.of(this),
      nn.languageData.of((s, o, l) => {
        let a = ME(s, o, l), u = a.type.prop(Rh);
        if (!u)
          return [];
        let c = s.facet(u), f = a.type.prop(EZ);
        if (f) {
          let d = a.resolve(o - a.from, l);
          for (let p of f)
            if (p.test(d, s)) {
              let m = s.facet(p.facet);
              return p.type == "replace" ? m : m.concat(c);
            }
        }
        return c;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, n, r = -1) {
    return ME(e, n, r).type.prop(Rh) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let n = e.facet(Cd);
    if (n?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(Rh) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(Mt.mounted);
      if (l) {
        if (l.tree.prop(Rh) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              r.push({ from: a.from + o, to: a.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = r.length;
          if (i(l.tree, l.overlay[0].from + o), r.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let u = s.children[a];
        u instanceof xr && i(u, s.positions[a] + o);
      }
    };
    return i(Dr(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Ho.setState = /* @__PURE__ */ St.define();
function ME(t, e, n) {
  let r = t.facet(Cd), i = Dr(t).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, n, Ir.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class ig extends Ho {
  constructor(e, n, r) {
    super(e, n, [], r), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let n = AZ(e.languageData);
    return new ig(n, e.parser.configure({
      props: [Rh.add((r) => r.isTop ? n : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, n) {
    return new ig(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Dr(t) {
  let e = t.field(Ho.state, !1);
  return e ? e.tree : xr.empty;
}
class DZ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let r = this.cursorPos - this.string.length;
    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
  }
}
let Y0 = null;
class xb {
  constructor(e, n, r = [], i, s, o, l, a) {
    this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new xb(e, n, [], xr.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new DZ(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != xr.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(sf.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(sf.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let n = Y0;
    Y0 = this;
    try {
      return e();
    } finally {
      Y0 = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = PE(e, n.from, n.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, n) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((u, c, f, d) => a.push({ fromA: u, toA: c, fromB: f, toB: d })), r = sf.applyChanges(r, a), i = xr.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let u of this.skipped) {
          let c = e.mapPos(u.from, 1), f = e.mapPos(u.to, -1);
          c < f && l.push({ from: c, to: f });
        }
      }
    }
    return new xb(this.parser, n, r, i, s, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && (this.fragments = PE(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends dM {
      createParse(n, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = Y0;
            if (a) {
              for (let u of i)
                a.tempSkipped.push(u);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new xr(cs.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Y0;
  }
}
function PE(t, e, n) {
  return sf.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class kd {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new kd(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), r = xb.create(e.facet(Cd).parser, e, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new kd(r);
  }
}
Ho.state = /* @__PURE__ */ jr.define({
  create: kd.init,
  update(t, e) {
    for (let n of e.effects)
      if (n.is(Ho.setState))
        return n.value;
    return e.startState.facet(Cd) != e.state.facet(Cd) ? kd.init(e.state) : t.apply(e);
  }
});
let mM = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (mM = (t) => {
  let e = -1, n = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
const Lw = typeof navigator < "u" && (!((Bw = navigator.scheduling) === null || Bw === void 0) && Bw.isInputPending) ? () => navigator.scheduling.isInputPending() : null, OZ = /* @__PURE__ */ wr.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(Ho.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(Ho.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = mM(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field(Ho.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Lw ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < i && r.doc.length > i + 1e3, a = s.context.work(() => Lw && Lw() || Date.now() > o, i + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: Ho.setState.of(new kd(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Mi(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Cd = /* @__PURE__ */ ze.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    Ho.state,
    OZ,
    $e.contentAttributes.compute([t], (e) => {
      let n = e.facet(t);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class yM {
  /**
  Create a language support object.
  */
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
}
const FZ = /* @__PURE__ */ ze.define(), Vv = /* @__PURE__ */ ze.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function wb(t) {
  let e = t.facet(Vv);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function sg(t, e) {
  let n = "", r = t.tabSize, i = t.facet(Vv)[0];
  if (i == "	") {
    for (; e >= r; )
      n += "	", e -= r;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    n += i;
  return n;
}
function v6(t, e) {
  t instanceof nn && (t = new Wv(t));
  for (let r of t.state.facet(FZ)) {
    let i = r(t, e);
    if (i !== void 0)
      return i;
  }
  let n = Dr(t.state);
  return n.length >= e ? TZ(t, n, e) : null;
}
class Wv {
  /**
  Create an indent context.
  */
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = wb(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, n = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: "", from: e } : (n < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, n);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, n = e.length) {
    return Xd(e, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const x6 = /* @__PURE__ */ new Mt();
function TZ(t, e, n) {
  let r = e.resolveStack(n), i = e.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
  if (i != r.node) {
    let s = [];
    for (let o = i; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return bM(r, t, n);
}
function bM(t, e, n) {
  for (let r = t; r; r = r.next) {
    let i = MZ(r.node);
    if (i)
      return i(w6.create(e, n, r));
  }
  return 0;
}
function RZ(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function MZ(t) {
  let e = t.type.prop(x6);
  if (e)
    return e;
  let n = t.firstChild, r;
  if (n && (r = n.type.prop(Mt.closedBy))) {
    let i = t.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => BZ(o, !0, 1, void 0, s && !RZ(o) ? i.from : void 0);
  }
  return t.parent == null ? PZ : null;
}
function PZ() {
  return 0;
}
class w6 extends Wv {
  constructor(e, n, r) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new w6(e, n, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (IZ(r, e))
        break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return bM(this.context.next, this.base, this.pos);
  }
}
function IZ(t, e) {
  for (let n = e; n; n = n.parent)
    if (t == n)
      return !0;
  return !1;
}
function NZ(t) {
  let e = t.node, n = e.childAfter(e.from), r = e.lastChild;
  if (!n)
    return null;
  let i = t.options.simulateBreak, s = t.state.doc.lineAt(n.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = n.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == r)
      return null;
    if (!a.type.isSkipped) {
      if (a.from >= o)
        return null;
      let u = /^ */.exec(s.text.slice(n.to - s.from))[0].length;
      return { from: n.from, to: n.to + u };
    }
    l = a.to;
  }
}
function BZ(t, e, n, r, i) {
  let s = t.textAfter, o = s.match(/^\s*/)[0].length, l = r && s.slice(o, o + r.length) == r || i == t.pos + o, a = NZ(t);
  return a ? l ? t.column(a.from) : t.column(a.to) : t.baseIndent + (l ? 0 : t.unit * n);
}
function d4({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let r = t && t.test(n.textAfter);
    return n.baseIndent + (r ? 0 : e * n.unit);
  };
}
const LZ = 200;
function $Z() {
  return nn.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let n = t.newDoc, { head: r } = t.newSelection.main, i = n.lineAt(r);
    if (r > i.from + LZ)
      return t;
    let s = n.sliceString(i.from, r);
    if (!e.some((u) => u.test(s)))
      return t;
    let { state: o } = t, l = -1, a = [];
    for (let { head: u } of o.selection.ranges) {
      let c = o.doc.lineAt(u);
      if (c.from == l)
        continue;
      l = c.from;
      let f = v6(o, c.from);
      if (f == null)
        continue;
      let d = /^\s*/.exec(c.text)[0], p = sg(o, f);
      d != p && a.push({ from: c.from, to: c.from + d.length, insert: p });
    }
    return a.length ? [t, { changes: a, sequential: !0 }] : t;
  });
}
const vM = /* @__PURE__ */ new Mt();
function zZ(t) {
  let e = t.firstChild, n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
class Zg {
  constructor(e, n) {
    this.specs = e;
    let r;
    function i(l) {
      let a = rc.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, o = n.scope;
    this.scope = o instanceof Ho ? (l) => l.prop(Rh) == o.data : o ? (l) => l == o : void 0, this.style = gM(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new rc(r) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, n) {
    return new Zg(e, n || {});
  }
}
const p4 = /* @__PURE__ */ ze.define(), xM = /* @__PURE__ */ ze.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function $w(t) {
  let e = t.facet(p4);
  return e.length ? e : t.facet(xM);
}
function wM(t, e) {
  let n = [qZ], r;
  return t instanceof Zg && (t.module && n.push($e.styleModule.of(t.module)), r = t.themeType), e?.fallback ? n.push(xM.of(t)) : r ? n.push(p4.computeN([$e.darkTheme], (i) => i.facet($e.darkTheme) == (r == "dark") ? [t] : [])) : n.push(p4.of(t)), n;
}
class jZ {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Dr(e.state), this.decorations = this.buildDeco(e, $w(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let n = Dr(e.state), r = $w(e.state), i = r != $w(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    n.length < s.to && !i && n.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = s.to);
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return at.none;
    let r = new nc();
    for (let { from: i, to: s } of e.visibleRanges)
      kZ(this.tree, n, (o, l, a) => {
        r.add(o, l, this.markCache[a] || (this.markCache[a] = at.mark({ class: a })));
      }, i, s);
    return r.finish();
  }
}
const qZ = /* @__PURE__ */ pc.high(/* @__PURE__ */ wr.fromClass(jZ, {
  decorations: (t) => t.decorations
})), UZ = /* @__PURE__ */ Zg.define([
  {
    tag: ie.meta,
    color: "#404740"
  },
  {
    tag: ie.link,
    textDecoration: "underline"
  },
  {
    tag: ie.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: ie.emphasis,
    fontStyle: "italic"
  },
  {
    tag: ie.strong,
    fontWeight: "bold"
  },
  {
    tag: ie.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: ie.keyword,
    color: "#708"
  },
  {
    tag: [ie.atom, ie.bool, ie.url, ie.contentSeparator, ie.labelName],
    color: "#219"
  },
  {
    tag: [ie.literal, ie.inserted],
    color: "#164"
  },
  {
    tag: [ie.string, ie.deleted],
    color: "#a11"
  },
  {
    tag: [ie.regexp, ie.escape, /* @__PURE__ */ ie.special(ie.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ ie.definition(ie.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ ie.local(ie.variableName),
    color: "#30a"
  },
  {
    tag: [ie.typeName, ie.namespace],
    color: "#085"
  },
  {
    tag: ie.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ ie.special(ie.variableName), ie.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ ie.definition(ie.propertyName),
    color: "#00c"
  },
  {
    tag: ie.comment,
    color: "#940"
  },
  {
    tag: ie.invalid,
    color: "#f00"
  }
]), HZ = /* @__PURE__ */ $e.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), _M = 1e4, kM = "()[]{}", CM = /* @__PURE__ */ ze.define({
  combine(t) {
    return iu(t, {
      afterCursor: !0,
      brackets: kM,
      maxScanDistance: _M,
      renderMatch: GZ
    });
  }
}), VZ = /* @__PURE__ */ at.mark({ class: "cm-matchingBracket" }), WZ = /* @__PURE__ */ at.mark({ class: "cm-nonmatchingBracket" });
function GZ(t) {
  let e = [], n = t.matched ? VZ : WZ;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const KZ = /* @__PURE__ */ jr.define({
  create() {
    return at.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let n = [], r = e.state.facet(CM);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = Ml(e.state, i.head, -1, r) || i.head > 0 && Ml(e.state, i.head - 1, 1, r) || r.afterCursor && (Ml(e.state, i.head, 1, r) || i.head < e.state.doc.length && Ml(e.state, i.head + 1, -1, r));
      s && (n = n.concat(r.renderMatch(s, e.state)));
    }
    return at.set(n, !0);
  },
  provide: (t) => $e.decorations.from(t)
}), YZ = [
  KZ,
  HZ
];
function XZ(t = {}) {
  return [CM.of(t), YZ];
}
const QZ = /* @__PURE__ */ new Mt();
function g4(t, e, n) {
  let r = t.prop(e < 0 ? Mt.openedBy : Mt.closedBy);
  if (r)
    return r;
  if (t.name.length == 1) {
    let i = n.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [n[i + e]];
  }
  return null;
}
function m4(t) {
  let e = t.type.prop(QZ);
  return e ? e(t.node) : t;
}
function Ml(t, e, n, r = {}) {
  let i = r.maxScanDistance || _M, s = r.brackets || kM, o = Dr(t), l = o.resolveInner(e, n);
  for (let a = l; a; a = a.parent) {
    let u = g4(a.type, n, s);
    if (u && a.from < a.to) {
      let c = m4(a);
      if (c && (n > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return JZ(t, e, n, a, c, u, s);
    }
  }
  return ZZ(t, e, n, o, l.type, i, s);
}
function JZ(t, e, n, r, i, s, o) {
  let l = r.parent, a = { from: i.from, to: i.to }, u = 0, c = l?.cursor();
  if (c && (n < 0 ? c.childBefore(r.from) : c.childAfter(r.to)))
    do
      if (n < 0 ? c.to <= r.from : c.from >= r.to) {
        if (u == 0 && s.indexOf(c.type.name) > -1 && c.from < c.to) {
          let f = m4(c);
          return { start: a, end: f ? { from: f.from, to: f.to } : void 0, matched: !0 };
        } else if (g4(c.type, n, o))
          u++;
        else if (g4(c.type, -n, o)) {
          if (u == 0) {
            let f = m4(c);
            return {
              start: a,
              end: f && f.from < f.to ? { from: f.from, to: f.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (n < 0 ? c.prevSibling() : c.nextSibling());
  return { start: a, matched: !1 };
}
function ZZ(t, e, n, r, i, s, o) {
  let l = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != n > 0)
    return null;
  let u = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, c = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), f = 0;
  for (let d = 0; !c.next().done && d <= s; ) {
    let p = c.value;
    n < 0 && (d += p.length);
    let m = e + d * n;
    for (let y = n > 0 ? 0 : p.length - 1, b = n > 0 ? p.length : -1; y != b; y += n) {
      let v = o.indexOf(p[y]);
      if (!(v < 0 || r.resolveInner(m + y, 1).type != i))
        if (v % 2 == 0 == n > 0)
          f++;
        else {
          if (f == 1)
            return { start: u, end: { from: m + y, to: m + y + 1 }, matched: v >> 1 == a >> 1 };
          f--;
        }
    }
    n > 0 && (d += p.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const eee = /* @__PURE__ */ Object.create(null), IE = [cs.none], NE = [], BE = /* @__PURE__ */ Object.create(null), tee = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  tee[t] = /* @__PURE__ */ nee(eee, e);
function zw(t, e) {
  NE.indexOf(t) > -1 || (NE.push(t), console.warn(e));
}
function nee(t, e) {
  let n = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let u of l.split(".")) {
      let c = t[u] || ie[u];
      c ? typeof c == "function" ? a.length ? a = a.map(c) : zw(u, `Modifier ${u} used at start of tag`) : a.length ? zw(u, `Tag ${u} used as modifier`) : a = Array.isArray(c) ? c : [c] : zw(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of a)
      n.push(u);
  }
  if (!n.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + n.map((l) => l.id), s = BE[i];
  if (s)
    return s.id;
  let o = BE[i] = cs.define({
    id: IE.length,
    name: r,
    props: [b6({ [r]: n })]
  });
  return IE.push(o), o.id;
}
jn.RTL, jn.LTR;
class SM {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesâ€”in the editor, the extension will create
  these for you.)
  */
  constructor(e, n, r, i) {
    this.state = e, this.pos = n, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let n = Dr(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), s = i.search(EM(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, n, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(n), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function LE(t) {
  let e = Object.keys(t).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function ree(t) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      n[i[s]] = !0;
  }
  let r = LE(e) + LE(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function AM(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : ree(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: n } : null;
  };
}
function iee(t, e) {
  return (n) => {
    for (let r = Dr(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
      if (t.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(n);
  };
}
class $E {
  constructor(e, n, r, i) {
    this.completion = e, this.source = n, this.match = r, this.score = i;
  }
}
function of(t) {
  return t.selection.main.from;
}
function EM(t, e) {
  var n;
  let { source: r } = t, i = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? t : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const _6 = /* @__PURE__ */ ru.define();
function see(t, e, n, r) {
  let { main: i } = t.selection, s = n - i.from, o = r - i.from;
  return {
    ...t.changeByRange((l) => {
      if (l != i && n != r && t.sliceDoc(l.from + s, l.from + o) != t.sliceDoc(n, r))
        return { range: l };
      let a = t.toText(e);
      return {
        changes: { from: l.from + s, to: r == i.from ? l.to : l.from + o, insert: a },
        range: de.cursor(l.from + s + a.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const zE = /* @__PURE__ */ new WeakMap();
function oee(t) {
  if (!Array.isArray(t))
    return t;
  let e = zE.get(t);
  return e || zE.set(t, e = AM(t)), e;
}
const _b = /* @__PURE__ */ St.define(), og = /* @__PURE__ */ St.define();
class lee {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let r = Ji(e, n), i = Al(r);
      this.chars.push(r);
      let s = e.slice(n, n + i), o = s.toUpperCase();
      this.folded.push(Ji(o == s ? s.toLowerCase() : o, 0)), n += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: n, folded: r, any: i, precise: s, byWord: o } = this;
    if (n.length == 1) {
      let _ = Ji(e, 0), k = Al(_), S = k == e.length ? 0 : -100;
      if (_ != n[0]) if (_ == r[0])
        S += -200;
      else
        return null;
      return this.ret(S, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = n.length, u = 0;
    if (l < 0) {
      for (let _ = 0, k = Math.min(e.length, 200); _ < k && u < a; ) {
        let S = Ji(e, _);
        (S == n[u] || S == r[u]) && (i[u++] = _), _ += Al(S);
      }
      if (u < a)
        return null;
    }
    let c = 0, f = 0, d = !1, p = 0, m = -1, y = -1, b = /[a-z]/.test(e), v = !0;
    for (let _ = 0, k = Math.min(e.length, 200), S = 0; _ < k && f < a; ) {
      let C = Ji(e, _);
      l < 0 && (c < a && C == n[c] && (s[c++] = _), p < a && (C == n[p] || C == r[p] ? (p == 0 && (m = _), y = _ + 1, p++) : p = 0));
      let E, A = C < 255 ? C >= 48 && C <= 57 || C >= 97 && C <= 122 ? 2 : C >= 65 && C <= 90 ? 1 : 0 : (E = Zk(C)) != E.toLowerCase() ? 1 : E != E.toUpperCase() ? 2 : 0;
      (!_ || A == 1 && b || S == 0 && A != 0) && (n[f] == C || r[f] == C && (d = !0) ? o[f++] = _ : o.length && (v = !1)), S = A, _ += Al(C);
    }
    return f == a && o[0] == 0 && v ? this.result(-100 + (d ? -200 : 0), o, e) : p == a && m == 0 ? this.ret(-200 - e.length + (y == e.length ? 0 : -100), [0, y]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : p == a ? this.ret(-900 - e.length, [m, y]) : f == a ? this.result(-100 + (d ? -200 : 0) + -700 + (v ? 0 : -1100), o, e) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, n, r) {
    let i = [], s = 0;
    for (let o of n) {
      let l = o + (this.astral ? Al(Ji(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = l : (i[s++] = o, i[s++] = l);
    }
    return this.ret(e - r.length, i);
  }
}
class aee {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let n = e.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, n.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Br = /* @__PURE__ */ ze.define({
  combine(t) {
    return iu(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: uee,
      filterStrict: !1,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (r) => jE(e(r), n(r)),
      optionClass: (e, n) => (r) => jE(e(r), n(r)),
      addToOptions: (e, n) => e.concat(n),
      filterStrict: (e, n) => e || n
    });
  }
});
function jE(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function uee(t, e, n, r, i, s) {
  let o = t.textDirection == jn.RTL, l = o, a = !1, u = "top", c, f, d = e.left - i.left, p = i.right - e.right, m = r.right - r.left, y = r.bottom - r.top;
  if (l && d < Math.min(m, p) ? l = !1 : !l && p < Math.min(m, d) && (l = !0), m <= (l ? d : p))
    c = Math.max(i.top, Math.min(n.top, i.bottom - y)) - e.top, f = Math.min(400, l ? d : p);
  else {
    a = !0, f = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let _ = i.bottom - e.bottom;
    _ >= y || _ > e.top ? c = n.bottom - e.top : (u = "bottom", c = e.bottom - n.top);
  }
  let b = (e.bottom - e.top) / s.offsetHeight, v = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${u}: ${c / b}px; max-width: ${f / v}px`,
    class: "cm-completionInfo-" + (a ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function cee(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(n) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(n, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = n.displayLabel || n.label, a = 0;
      for (let u = 0; u < s.length; ) {
        let c = s[u++], f = s[u++];
        c > a && o.appendChild(document.createTextNode(l.slice(a, c)));
        let d = o.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(l.slice(c, f))), d.className = "cm-completionMatchedText", a = f;
      }
      return a < l.length && o.appendChild(document.createTextNode(l.slice(a))), o;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = n.detail, r;
    },
    position: 80
  }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
}
function jw(t, e, n) {
  if (t <= n)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((t - e) / n);
  return { from: t - (r + 1) * n, to: t - r * n };
}
class fee {
  constructor(e, n, r) {
    this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(n), { options: s, selected: o } = i.open, l = e.state.facet(Br);
    this.optionContent = cee(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = jw(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      let { options: u } = e.state.field(n).open;
      for (let c = a.target, f; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (f = /-(\d+)$/.exec(c.id)) && +f[1] < u.length) {
          this.applyCompletion(e, u[+f[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(Br).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: og.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: s, selected: o, disabled: l } = r.open;
      (!i.open || i.open.options != s) && (this.range = jw(s.length, o, e.state.facet(Br).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), l != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of n.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    (n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = jw(n.options.length, n.selected, this.view.state.facet(Br).maxRenderedOptions), this.showOptions(n.options, e.id));
    let r = this.updateSelectedOption(n.selected);
    if (r) {
      this.destroyInfo();
      let { completion: i } = n.options[n.selected], { info: s } = i;
      if (!s)
        return;
      let o = typeof s == "string" ? document.createTextNode(s) : s(i);
      if (!o)
        return;
      "then" in o ? o.then((l) => {
        l && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(l, i);
      }).catch((l) => Mi(this.view.state, l, "completion info")) : (this.addInfoPane(o, i), r.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", r.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && (r.removeAttribute("aria-selected"), r.removeAttribute("aria-describedby"));
    return n && dee(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return i.top > Math.min(s.bottom, n.bottom) - 10 || i.bottom < Math.max(s.top, n.top) + 10 ? null : this.view.state.facet(Br).positionInfo(this.view, n, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, r) {
    const i = document.createElement("ul");
    i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (o) => {
      o.target == i && o.preventDefault();
    });
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: l, match: a } = e[o], { section: u } = l;
      if (u) {
        let d = typeof u == "string" ? u : u.name;
        if (d != s && (o > r.from || r.from == 0))
          if (s = d, typeof u != "string" && u.header)
            i.appendChild(u.header(u));
          else {
            let p = i.appendChild(document.createElement("completion-section"));
            p.textContent = d;
          }
      }
      const c = i.appendChild(document.createElement("li"));
      c.id = n + "-" + o, c.setAttribute("role", "option");
      let f = this.optionClass(l);
      f && (c.className = f);
      for (let d of this.optionContent) {
        let p = d(l, this.view.state, this.view, a);
        p && c.appendChild(p);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function hee(t, e) {
  return (n) => new fee(n, t, e);
}
function dee(t, e) {
  let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t.offsetHeight;
  r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
}
function qE(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function pee(t, e) {
  let n = [], r = null, i = null, s = (c) => {
    n.push(c);
    let { section: f } = c.completion;
    if (f) {
      r || (r = []);
      let d = typeof f == "string" ? f : f.name;
      r.some((p) => p.name == d) || r.push(typeof f == "string" ? { name: d } : f);
    }
  }, o = e.facet(Br);
  for (let c of t)
    if (c.hasResult()) {
      let f = c.result.getMatch;
      if (c.result.filter === !1)
        for (let d of c.result.options)
          s(new $E(d, c.source, f ? f(d) : [], 1e9 - n.length));
      else {
        let d = e.sliceDoc(c.from, c.to), p, m = o.filterStrict ? new aee(d) : new lee(d);
        for (let y of c.result.options)
          if (p = m.match(y.label)) {
            let b = y.displayLabel ? f ? f(y, p.matched) : [] : p.matched, v = p.score + (y.boost || 0);
            if (s(new $E(y, c.source, b, v)), typeof y.section == "object" && y.section.rank === "dynamic") {
              let { name: _ } = y.section;
              i || (i = /* @__PURE__ */ Object.create(null)), i[_] = Math.max(v, i[_] || -1e9);
            }
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), f = 0, d = (p, m) => (p.rank === "dynamic" && m.rank === "dynamic" ? i[m.name] - i[p.name] : 0) || (typeof p.rank == "number" ? p.rank : 1e9) - (typeof m.rank == "number" ? m.rank : 1e9) || (p.name < m.name ? -1 : 1);
    for (let p of r.sort(d))
      f -= 1e5, c[p.name] = f;
    for (let p of n) {
      let { section: m } = p.completion;
      m && (p.score += c[typeof m == "string" ? m : m.name]);
    }
  }
  let l = [], a = null, u = o.compareCompletions;
  for (let c of n.sort((f, d) => d.score - f.score || u(f.completion, d.completion))) {
    let f = c.completion;
    !a || a.label != f.label || a.detail != f.detail || a.type != null && f.type != null && a.type != f.type || a.apply != f.apply || a.boost != f.boost ? l.push(c) : qE(c.completion) > qE(a) && (l[l.length - 1] = c), a = c.completion;
  }
  return l;
}
class Mh {
  constructor(e, n, r, i, s, o) {
    this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new Mh(this.options, UE(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, r, i, s, o) {
    if (i && !o && e.some((u) => u.isPending))
      return i.setDisabled();
    let l = pee(e, n);
    if (!l.length)
      return i && e.some((u) => u.isPending) ? i.setDisabled() : null;
    let a = n.facet(Br).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let u = i.options[i.selected].completion;
      for (let c = 0; c < l.length; c++)
        if (l[c].completion == u) {
          a = c;
          break;
        }
    }
    return new Mh(l, UE(r, a), {
      pos: e.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: xee,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new Mh(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Mh(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class kb {
  constructor(e, n, r) {
    this.active = e, this.id = n, this.open = r;
  }
  static start() {
    return new kb(bee, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, r = n.facet(Br), s = (r.override || n.languageDataAt("autocomplete", of(n)).map(oee)).map((a) => (this.active.find((c) => c.source == a) || new po(
      a,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    s.length == this.active.length && s.every((a, u) => a == this.active[u]) && (s = this.active);
    let o = this.open, l = e.effects.some((a) => a.is(k6));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !gee(s, this.active) || l ? o = Mh.build(s, n, this.id, o, r, l) : o && o.disabled && !s.some((a) => a.isPending) && (o = null), !o && s.every((a) => !a.isPending) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new po(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(OM) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new kb(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? mee : yee;
  }
}
function gee(t, e) {
  if (t == e)
    return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < t.length && !t[n].hasResult(); )
      n++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let i = n == t.length, s = r == e.length;
    if (i || s)
      return i == s;
    if (t[n++].result != e[r++].result)
      return !1;
  }
}
const mee = {
  "aria-autocomplete": "list"
}, yee = {};
function UE(t, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const bee = [];
function DM(t, e) {
  if (t.isUserEvent("input.complete")) {
    let r = t.annotation(_6);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let n = t.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class po {
  constructor(e, n, r = !1) {
    this.source = e, this.state = n, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, n) {
    let r = DM(e, n), i = this;
    (r & 8 || r & 16 && this.touches(e)) && (i = new po(
      i.source,
      0
      /* State.Inactive */
    )), r & 4 && i.state == 0 && (i = new po(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, r);
    for (let s of e.effects)
      if (s.is(_b))
        i = new po(i.source, 1, s.value);
      else if (s.is(og))
        i = new po(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(k6))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(of(e.state));
  }
}
class Wh extends po {
  constructor(e, n, r, i, s, o) {
    super(e, 3, n), this.limit = r, this.result = i, this.from = s, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var r;
    if (!(n & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = of(e.state);
    if (l > o || !i || n & 2 && (of(e.startState) == this.from || l < this.limit))
      return new po(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let a = e.changes.mapPos(this.limit);
    return vee(i.validFor, e.state, s, o) ? new Wh(this.source, this.explicit, a, i, s, o) : i.update && (i = i.update(i, s, o, new SM(e.state, l, !1))) ? new Wh(this.source, this.explicit, a, i, i.from, (r = i.to) !== null && r !== void 0 ? r : of(e.state)) : new po(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Wh(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new po(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function vee(t, e, n, r) {
  if (!t)
    return !1;
  let i = e.sliceDoc(n, r);
  return typeof t == "function" ? t(i, n, r, e) : EM(t, !0).test(i);
}
const k6 = /* @__PURE__ */ St.define({
  map(t, e) {
    return t.map((n) => n.map(e));
  }
}), OM = /* @__PURE__ */ St.define(), Zi = /* @__PURE__ */ jr.define({
  create() {
    return kb.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    d6.from(t, (e) => e.tooltip),
    $e.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function C6(t, e) {
  const n = e.completion.apply || e.completion.label;
  let r = t.state.field(Zi).active.find((i) => i.source == e.source);
  return r instanceof Wh ? (typeof n == "string" ? t.dispatch({
    ...see(t.state, n, r.from, r.to),
    annotations: _6.of(e.completion)
  }) : n(t, e.completion, r.from, r.to), !0) : !1;
}
const xee = /* @__PURE__ */ hee(Zi, C6);
function z1(t, e = "option") {
  return (n) => {
    let r = n.state.field(Zi, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Br).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = oM(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, l = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), n.dispatch({ effects: OM.of(l) }), !0;
  };
}
const wee = (t) => {
  let e = t.state.field(Zi, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Br).interactionDelay ? !1 : C6(t, e.open.options[e.open.selected]);
}, qw = (t) => t.state.field(Zi, !1) ? (t.dispatch({ effects: _b.of(!0) }), !0) : !1, _ee = (t) => {
  let e = t.state.field(Zi, !1);
  return !e || !e.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: og.of(null) }), !0);
};
class kee {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Cee = 50, See = 1e3, Aee = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(Zi).active)
      e.isPending && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(Zi), n = t.state.facet(Br);
    if (!t.selectionSet && !t.docChanged && t.startState.field(Zi) == e)
      return;
    let r = t.transactions.some((s) => {
      let o = DM(s, n);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (r || o.context.abortOnDocChange && t.docChanged || o.updates.length + t.transactions.length > Cee && Date.now() - o.time > See) {
        for (let l of o.context.abortListeners)
          try {
            l();
          } catch (a) {
            Mi(this.view.state, a);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((s) => s.effects.some((o) => o.is(_b))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.isPending && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let s of t.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(Zi);
    for (let n of e.active)
      n.isPending && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Br).updateSyncTime));
  }
  startQuery(t) {
    let { state: e } = this.view, n = of(e), r = new SM(e, n, t.explicit, this.view), i = new kee(t, r);
    this.running.push(i), Promise.resolve(t.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: og.of(null) }), Mi(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Br).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(Br), r = this.view.state.field(Zi);
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (s.done === void 0)
        continue;
      if (this.running.splice(i--, 1), s.done) {
        let l = of(s.updates.length ? s.updates[0].startState : this.view.state), a = Math.min(l, s.done.from + (s.active.explicit ? 0 : 1)), u = new Wh(s.active.source, s.active.explicit, a, s.done, s.done.from, (t = s.done.to) !== null && t !== void 0 ? t : l);
        for (let c of s.updates)
          u = u.update(c, n);
        if (u.hasResult()) {
          e.push(u);
          continue;
        }
      }
      let o = r.active.find((l) => l.source == s.active.source);
      if (o && o.isPending)
        if (s.done == null) {
          let l = new po(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let a of s.updates)
            l = l.update(a, n);
          l.isPending || e.push(l);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: k6.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(Zi, !1);
      if (e && e.tooltip && this.view.state.facet(Br).closeOnBlur) {
        let n = e.open && oM(this.view, e.open.tooltip);
        (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: og.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: _b.of(!1) }), 20), this.composing = 0;
    }
  }
}), Eee = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Dee = /* @__PURE__ */ pc.highest(/* @__PURE__ */ $e.domEventHandlers({
  keydown(t, e) {
    let n = e.state.field(Zi, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(Eee && t.altKey) || t.metaKey)
      return !1;
    let r = n.open.options[n.open.selected], i = n.active.find((o) => o.source == r.source), s = r.completion.commitCharacters || i.result.commitCharacters;
    return s && s.indexOf(t.key) > -1 && C6(e, r), !1;
  }
})), FM = /* @__PURE__ */ $e.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"Â·Â·Â·"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'Æ’'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'â—‹'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'â—Œ'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'ð‘¥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'ð¶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'ð‘¡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'âˆª'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'â–¡'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'ðŸ”‘ï¸Ž'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'â–¢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Oee {
  constructor(e, n, r, i) {
    this.field = e, this.line = n, this.from = r, this.to = i;
  }
}
class S6 {
  constructor(e, n, r) {
    this.field = e, this.from = n, this.to = r;
  }
  map(e) {
    let n = e.mapPos(this.from, -1, Kr.TrackDel), r = e.mapPos(this.to, 1, Kr.TrackDel);
    return n == null || r == null ? null : new S6(this.field, n, r);
  }
}
class A6 {
  constructor(e, n) {
    this.lines = e, this.fieldPositions = n;
  }
  instantiate(e, n) {
    let r = [], i = [n], s = e.doc.lineAt(n), o = /^\s*/.exec(s.text)[0];
    for (let a of this.lines) {
      if (r.length) {
        let u = o, c = /^\t*/.exec(a)[0].length;
        for (let f = 0; f < c; f++)
          u += e.facet(Vv);
        i.push(n + u.length - c), a = u + a.slice(c);
      }
      r.push(a), n += a.length + 1;
    }
    let l = this.fieldPositions.map((a) => new S6(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: r, ranges: l };
  }
  static parse(e) {
    let n = [], r = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(o); ) {
        let l = s[1] ? +s[1] : null, a = s[2] || s[3] || "", u = -1, c = a.replace(/\\[{}]/g, (f) => f[1]);
        for (let f = 0; f < n.length; f++)
          (l != null ? n[f].seq == l : c && n[f].name == c) && (u = f);
        if (u < 0) {
          let f = 0;
          for (; f < n.length && (l == null || n[f].seq != null && n[f].seq < l); )
            f++;
          n.splice(f, 0, { seq: l, name: c }), u = f;
          for (let d of i)
            d.field >= u && d.field++;
        }
        for (let f of i)
          if (f.line == r.length && f.from > s.index) {
            let d = s[2] ? 3 + (s[1] || "").length : 2;
            f.from -= d, f.to -= d;
          }
        i.push(new Oee(u, r.length, s.index, s.index + c.length)), o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (l, a, u) => {
        for (let c of i)
          c.line == r.length && c.from > u && (c.from--, c.to--);
        return a;
      }), r.push(o);
    }
    return new A6(r, i);
  }
}
let Fee = /* @__PURE__ */ at.widget({ widget: /* @__PURE__ */ new class extends $f {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Tee = /* @__PURE__ */ at.mark({ class: "cm-snippetField" });
class Qd {
  constructor(e, n) {
    this.ranges = e, this.active = n, this.deco = at.set(e.map((r) => (r.from == r.to ? Fee : Tee).range(r.from, r.to)), !0);
  }
  map(e) {
    let n = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      n.push(i);
    }
    return new Qd(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));
  }
}
const em = /* @__PURE__ */ St.define({
  map(t, e) {
    return t && t.map(e);
  }
}), Ree = /* @__PURE__ */ St.define(), lg = /* @__PURE__ */ jr.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let n of e.effects) {
      if (n.is(em))
        return n.value;
      if (n.is(Ree) && t)
        return new Qd(t.ranges, n.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => $e.decorations.from(t, (e) => e ? e.deco : at.none)
});
function E6(t, e) {
  return de.create(t.filter((n) => n.field == e).map((n) => de.range(n.from, n.to)));
}
function Mee(t) {
  let e = A6.parse(t);
  return (n, r, i, s) => {
    let { text: o, ranges: l } = e.instantiate(n.state, i), { main: a } = n.state.selection, u = {
      changes: { from: i, to: s == a.from ? a.to : s, insert: rn.of(o) },
      scrollIntoView: !0,
      annotations: r ? [_6.of(r), vr.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (u.selection = E6(l, 0)), l.some((c) => c.field > 0)) {
      let c = new Qd(l, 0), f = u.effects = [em.of(c)];
      n.state.field(lg, !1) === void 0 && f.push(St.appendConfig.of([lg, Lee, zee, FM]));
    }
    n.dispatch(n.state.update(u));
  };
}
function TM(t) {
  return ({ state: e, dispatch: n }) => {
    let r = e.field(lg, !1);
    if (!r || t < 0 && r.active == 0)
      return !1;
    let i = r.active + t, s = t > 0 && !r.ranges.some((o) => o.field == i + t);
    return n(e.update({
      selection: E6(r.ranges, i),
      effects: em.of(s ? null : new Qd(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const Pee = ({ state: t, dispatch: e }) => t.field(lg, !1) ? (e(t.update({ effects: em.of(null) })), !0) : !1, Iee = /* @__PURE__ */ TM(1), Nee = /* @__PURE__ */ TM(-1), Bee = [
  { key: "Tab", run: Iee, shift: Nee },
  { key: "Escape", run: Pee }
], HE = /* @__PURE__ */ ze.define({
  combine(t) {
    return t.length ? t[0] : Bee;
  }
}), Lee = /* @__PURE__ */ pc.highest(/* @__PURE__ */ Uv.compute([HE], (t) => t.facet(HE)));
function $ee(t, e) {
  return { ...e, apply: Mee(t) };
}
const zee = /* @__PURE__ */ $e.domEventHandlers({
  mousedown(t, e) {
    let n = e.state.field(lg, !1), r;
    if (!n || (r = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let i = n.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == n.active ? !1 : (e.dispatch({
      selection: E6(n.ranges, i.field),
      effects: em.of(n.ranges.some((s) => s.field > i.field) ? new Qd(n.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), ag = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Uc = /* @__PURE__ */ St.define({
  map(t, e) {
    let n = e.mapPos(t, -1, Kr.TrackAfter);
    return n ?? void 0;
  }
}), D6 = /* @__PURE__ */ new class extends xf {
}();
D6.startSide = 1;
D6.endSide = -1;
const RM = /* @__PURE__ */ jr.define({
  create() {
    return hn.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of e.effects)
      n.is(Uc) && (t = t.update({ add: [D6.range(n.value, n.value + 1)] }));
    return t;
  }
});
function jee() {
  return [Uee, RM];
}
const Uw = "()[]{}<>Â«Â»Â»Â«ï¼»ï¼½ï½›ï½";
function MM(t) {
  for (let e = 0; e < Uw.length; e += 2)
    if (Uw.charCodeAt(e) == t)
      return Uw.charAt(e + 1);
  return Zk(t < 128 ? t : t + 1);
}
function PM(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || ag;
}
const qee = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Uee = /* @__PURE__ */ $e.inputHandler.of((t, e, n, r) => {
  if ((qee ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (r.length > 2 || r.length == 2 && Al(Ji(r, 0)) == 1 || e != i.from || n != i.to)
    return !1;
  let s = Wee(t.state, r);
  return s ? (t.dispatch(s), !0) : !1;
}), Hee = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = PM(t, t.selection.main.head).brackets || ag.brackets, i = null, s = t.changeByRange((o) => {
    if (o.empty) {
      let l = Gee(t.doc, o.head);
      for (let a of r)
        if (a == l && Gv(t.doc, o.head) == MM(Ji(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: de.cursor(o.head - a.length)
          };
    }
    return { range: i = o };
  });
  return i || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, Vee = [
  { key: "Backspace", run: Hee }
];
function Wee(t, e) {
  let n = PM(t, t.selection.main.head), r = n.brackets || ag.brackets;
  for (let i of r) {
    let s = MM(Ji(i, 0));
    if (e == i)
      return s == i ? Xee(t, i, r.indexOf(i + i + i) > -1, n) : Kee(t, i, s, n.before || ag.before);
    if (e == s && IM(t, t.selection.main.from))
      return Yee(t, i, s);
  }
  return null;
}
function IM(t, e) {
  let n = !1;
  return t.field(RM).between(0, t.doc.length, (r) => {
    r == e && (n = !0);
  }), n;
}
function Gv(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, Al(Ji(n, 0)));
}
function Gee(t, e) {
  let n = t.sliceString(e - 2, e);
  return Al(Ji(n, 0)) == n.length ? n : n.slice(1);
}
function Kee(t, e, n, r) {
  let i = null, s = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: n, from: o.to }],
        effects: Uc.of(o.to + e.length),
        range: de.range(o.anchor + e.length, o.head + e.length)
      };
    let l = Gv(t.doc, o.head);
    return !l || /\s/.test(l) || r.indexOf(l) > -1 ? {
      changes: { insert: e + n, from: o.head },
      effects: Uc.of(o.head + e.length),
      range: de.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Yee(t, e, n) {
  let r = null, i = t.changeByRange((s) => s.empty && Gv(t.doc, s.head) == n ? {
    changes: { from: s.head, to: s.head + n.length, insert: n },
    range: de.cursor(s.head + n.length)
  } : r = { range: s });
  return r ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Xee(t, e, n, r) {
  let i = r.stringPrefixes || ag.stringPrefixes, s = null, o = t.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: Uc.of(l.to + e.length),
        range: de.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, u = Gv(t.doc, a), c;
    if (u == e) {
      if (VE(t, a))
        return {
          changes: { insert: e + e, from: a },
          effects: Uc.of(a + e.length),
          range: de.cursor(a + e.length)
        };
      if (IM(t, a)) {
        let d = n && t.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + d.length, insert: d },
          range: de.cursor(a + d.length)
        };
      }
    } else {
      if (n && t.sliceDoc(a - 2 * e.length, a) == e + e && (c = WE(t, a - 2 * e.length, i)) > -1 && VE(t, c))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: Uc.of(a + e.length),
          range: de.cursor(a + e.length)
        };
      if (t.charCategorizer(a)(u) != Wn.Word && WE(t, a, i) > -1 && !Qee(t, a, e, i))
        return {
          changes: { insert: e + e, from: a },
          effects: Uc.of(a + e.length),
          range: de.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function VE(t, e) {
  let n = Dr(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function Qee(t, e, n, r) {
  let i = Dr(t).resolveInner(e, -1), s = r.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + s)), a = l.indexOf(n);
    if (!a || a > -1 && r.indexOf(l.slice(0, a)) > -1) {
      let c = i.firstChild;
      for (; c && c.from == i.from && c.to - c.from > n.length + a; ) {
        if (t.sliceDoc(c.to - n.length, c.to) == n)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = i.to == e && i.parent;
    if (!u)
      break;
    i = u;
  }
  return !1;
}
function WE(t, e, n) {
  let r = t.charCategorizer(e);
  if (r(t.sliceDoc(e - 1, e)) != Wn.Word)
    return e;
  for (let i of n) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && r(t.sliceDoc(s - 1, s)) != Wn.Word)
      return s;
  }
  return -1;
}
function Jee(t = {}) {
  return [
    Dee,
    Zi,
    Br.of(t),
    Aee,
    Zee,
    FM
  ];
}
const NM = [
  { key: "Ctrl-Space", run: qw },
  { mac: "Alt-`", run: qw },
  { mac: "Alt-i", run: qw },
  { key: "Escape", run: _ee },
  { key: "ArrowDown", run: /* @__PURE__ */ z1(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ z1(!1) },
  { key: "PageDown", run: /* @__PURE__ */ z1(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ z1(!1, "page") },
  { key: "Enter", run: wee }
], Zee = /* @__PURE__ */ pc.highest(/* @__PURE__ */ Uv.computeN([Br], (t) => t.facet(Br).defaultKeymap ? [NM] : [])), ete = (t) => {
  let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), r = F6(t.state, n.from);
  return r.line ? tte(t) : r.block ? rte(t) : !1;
};
function O6(t, e) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly)
      return !1;
    let i = t(e, n);
    return i ? (r(n.update(i)), !0) : !1;
  };
}
const tte = /* @__PURE__ */ O6(
  ote,
  0
  /* CommentOption.Toggle */
), nte = /* @__PURE__ */ O6(
  BM,
  0
  /* CommentOption.Toggle */
), rte = /* @__PURE__ */ O6(
  (t, e) => BM(t, e, ste(e)),
  0
  /* CommentOption.Toggle */
);
function F6(t, e) {
  let n = t.languageDataAt("commentTokens", e, 1);
  return n.length ? n[0] : {};
}
const X0 = 50;
function ite(t, { open: e, close: n }, r, i) {
  let s = t.sliceDoc(r - X0, r), o = t.sliceDoc(i, i + X0), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, u = s.length - l;
  if (s.slice(u - e.length, u) == e && o.slice(a, a + n.length) == n)
    return {
      open: { pos: r - l, margin: l && 1 },
      close: { pos: i + a, margin: a && 1 }
    };
  let c, f;
  i - r <= 2 * X0 ? c = f = t.sliceDoc(r, i) : (c = t.sliceDoc(r, r + X0), f = t.sliceDoc(i - X0, i));
  let d = /^\s*/.exec(c)[0].length, p = /\s*$/.exec(f)[0].length, m = f.length - p - n.length;
  return c.slice(d, d + e.length) == e && f.slice(m, m + n.length) == n ? {
    open: {
      pos: r + d + e.length,
      margin: /\s/.test(c.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: i - p - n.length,
      margin: /\s/.test(f.charAt(m - 1)) ? 1 : 0
    }
  } : null;
}
function ste(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let r = t.doc.lineAt(n.from), i = n.to <= r.to ? r : t.doc.lineAt(n.to);
    i.from > r.from && i.from == n.to && (i = n.to == r.to + 1 ? r : t.doc.lineAt(n.to - 1));
    let s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function BM(t, e, n = e.selection.ranges) {
  let r = n.map((s) => F6(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = n.map((s, o) => ite(e, r[o], s.from, s.to));
  if (t != 2 && !i.every((s) => s))
    return { changes: e.changes(n.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (t != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if (l = i[o]) {
        let a = r[o], { open: u, close: c } = l;
        s.push({ from: u.pos - a.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function ote(t, e, n = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of n) {
    let l = r.length, a = 1e9, u = F6(e, s).line;
    if (u) {
      for (let c = s; c <= o; ) {
        let f = e.doc.lineAt(c);
        if (f.from > i && (s == o || o > f.from)) {
          i = f.from;
          let d = /^\s*/.exec(f.text)[0].length, p = d == f.length, m = f.text.slice(d, d + u.length) == u ? d : -1;
          d < f.text.length && d < a && (a = d), r.push({ line: f, comment: m, token: u, indent: d, empty: p, single: !1 });
        }
        c = f.to + 1;
      }
      if (a < 1e9)
        for (let c = l; c < r.length; c++)
          r[c].indent < r[c].line.text.length && (r[c].indent = a);
      r.length == l + 1 && (r[l].single = !0);
    }
  }
  if (t != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: u, empty: c, single: f } of r)
      (f || !c) && s.push({ from: l.from + u, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of r)
      if (l >= 0) {
        let u = o.from + l, c = u + a.length;
        o.text[c - o.from] == " " && c++, s.push({ from: u, to: c });
      }
    return { changes: s };
  }
  return null;
}
const y4 = /* @__PURE__ */ ru.define(), lte = /* @__PURE__ */ ru.define(), ate = /* @__PURE__ */ ze.define(), LM = /* @__PURE__ */ ze.define({
  combine(t) {
    return iu(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
    });
  }
}), $M = /* @__PURE__ */ jr.define({
  create() {
    return Pl.empty;
  },
  update(t, e) {
    let n = e.state.facet(LM), r = e.annotation(y4);
    if (r) {
      let a = ns.fromTransaction(e, r.selection), u = r.side, c = u == 0 ? t.undone : t.done;
      return a ? c = Cb(c, c.length, n.minDepth, a) : c = qM(c, e.startState.selection), new Pl(u == 0 ? r.rest : c, u == 0 ? c : r.rest);
    }
    let i = e.annotation(lte);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(vr.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = ns.fromTransaction(e), o = e.annotation(vr.time), l = e.annotation(vr.userEvent);
    return s ? t = t.addChanges(s, o, l, n, e) : e.selection && (t = t.addSelection(e.startState.selection, o, l, n.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Pl(t.done.map(ns.fromJSON), t.undone.map(ns.fromJSON));
  }
});
function ute(t = {}) {
  return [
    $M,
    LM.of(t),
    $e.domEventHandlers({
      beforeinput(e, n) {
        let r = e.inputType == "historyUndo" ? zM : e.inputType == "historyRedo" ? b4 : null;
        return r ? (e.preventDefault(), r(n)) : !1;
      }
    })
  ];
}
function Kv(t, e) {
  return function({ state: n, dispatch: r }) {
    if (!e && n.readOnly)
      return !1;
    let i = n.field($M, !1);
    if (!i)
      return !1;
    let s = i.pop(t, n, e);
    return s ? (r(s), !0) : !1;
  };
}
const zM = /* @__PURE__ */ Kv(0, !1), b4 = /* @__PURE__ */ Kv(1, !1), cte = /* @__PURE__ */ Kv(0, !0), fte = /* @__PURE__ */ Kv(1, !0);
class ns {
  constructor(e, n, r, i, s) {
    this.changes = e, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new ns(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new ns(e.changes && Er.fromJSON(e.changes), [], e.mapped && ql.fromJSON(e.mapped), e.startSelection && de.fromJSON(e.startSelection), e.selectionsAfter.map(de.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, n) {
    let r = go;
    for (let i of e.startState.facet(ate)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new ns(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, go);
  }
  static selection(e) {
    return new ns(void 0, go, void 0, void 0, e);
  }
}
function Cb(t, e, n, r) {
  let i = e + 1 > n + 20 ? e - n - 1 : 0, s = t.slice(i, e);
  return s.push(r), s;
}
function hte(t, e) {
  let n = [], r = !1;
  return t.iterChangedRanges((i, s) => n.push(i, s)), e.iterChangedRanges((i, s, o, l) => {
    for (let a = 0; a < n.length; ) {
      let u = n[a++], c = n[a++];
      l >= u && o <= c && (r = !0);
    }
  }), r;
}
function dte(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
}
function jM(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const go = [], pte = 200;
function qM(t, e) {
  if (t.length) {
    let n = t[t.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - pte));
    return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), Cb(t, t.length - 1, 1e9, n.setSelAfter(r)));
  } else
    return [ns.selection([e])];
}
function gte(t) {
  let e = t[t.length - 1], n = t.slice();
  return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function Hw(t, e) {
  if (!t.length)
    return t;
  let n = t.length, r = go;
  for (; n; ) {
    let i = mte(t[n - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = t.slice(0, n);
      return s[n - 1] = i, s;
    } else
      e = i.mapped, n--, r = i.selectionsAfter;
  }
  return r.length ? [ns.selection(r)] : go;
}
function mte(t, e, n) {
  let r = jM(t.selectionsAfter.length ? t.selectionsAfter.map((l) => l.map(e)) : go, n);
  if (!t.changes)
    return ns.selection(r);
  let i = t.changes.map(e), s = e.mapDesc(t.changes, !0), o = t.mapped ? t.mapped.composeDesc(s) : s;
  return new ns(i, St.mapEffects(t.effects, e), o, t.startSelection.map(s), r);
}
const yte = /^(input\.type|delete)($|\.)/;
class Pl {
  constructor(e, n, r = 0, i = void 0) {
    this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new Pl(this.done, this.undone) : this;
  }
  addChanges(e, n, r, i, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!r || yte.test(r)) && (!l.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(s, hte(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = Cb(o, o.length - 1, i.minDepth, new ns(e.changes.compose(l.changes), jM(St.mapEffects(e.effects, l.changes), l.effects), l.mapped, l.startSelection, go)) : o = Cb(o, o.length, i.minDepth, e), new Pl(o, go, n, r);
  }
  addSelection(e, n, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : go;
    return s.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && dte(s[s.length - 1], e) ? this : new Pl(qM(this.done, e), this.undone, n, r);
  }
  addMapping(e) {
    return new Pl(Hw(this.done, e), Hw(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || n.selection;
    if (r && s.selectionsAfter.length)
      return n.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: y4.of({ side: e, rest: gte(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = i.length == 1 ? go : i.slice(0, i.length - 1);
      return s.mapped && (l = Hw(l, s.mapped)), n.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: y4.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Pl.empty = /* @__PURE__ */ new Pl(go, go);
const bte = [
  { key: "Mod-z", run: zM, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: b4, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: b4, preventDefault: !0 },
  { key: "Mod-u", run: cte, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: fte, preventDefault: !0 }
];
function Jd(t, e) {
  return de.create(t.ranges.map(e), t.mainIndex);
}
function il(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function sl({ state: t, dispatch: e }, n) {
  let r = Jd(t.selection, n);
  return r.eq(t.selection, !0) ? !1 : (e(il(t, r)), !0);
}
function Yv(t, e) {
  return de.cursor(e ? t.to : t.from);
}
function UM(t, e) {
  return sl(t, (n) => n.empty ? t.moveByChar(n, e) : Yv(n, e));
}
function vi(t) {
  return t.textDirectionAt(t.state.selection.main.head) == jn.LTR;
}
const HM = (t) => UM(t, !vi(t)), VM = (t) => UM(t, vi(t));
function WM(t, e) {
  return sl(t, (n) => n.empty ? t.moveByGroup(n, e) : Yv(n, e));
}
const vte = (t) => WM(t, !vi(t)), xte = (t) => WM(t, vi(t));
function wte(t, e, n) {
  if (e.type.prop(n))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Xv(t, e, n) {
  let r = Dr(t).resolveInner(e.head), i = n ? Mt.closedBy : Mt.openedBy;
  for (let a = e.head; ; ) {
    let u = n ? r.childAfter(a) : r.childBefore(a);
    if (!u)
      break;
    wte(t, u, i) ? r = u : a = n ? u.to : u.from;
  }
  let s = r.type.prop(i), o, l;
  return s && (o = n ? Ml(t, r.from, 1) : Ml(t, r.to, -1)) && o.matched ? l = n ? o.end.to : o.end.from : l = n ? r.to : r.from, de.cursor(l, n ? -1 : 1);
}
const _te = (t) => sl(t, (e) => Xv(t.state, e, !vi(t))), kte = (t) => sl(t, (e) => Xv(t.state, e, vi(t)));
function GM(t, e) {
  return sl(t, (n) => {
    if (!n.empty)
      return Yv(n, e);
    let r = t.moveVertically(n, e);
    return r.head != n.head ? r : t.moveToLineBoundary(n, e);
  });
}
const KM = (t) => GM(t, !1), YM = (t) => GM(t, !0);
function XM(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
  if (e) {
    for (let s of t.state.facet($e.scrollMargins)) {
      let o = s(t);
      o?.top && (n = Math.max(o?.top, n)), o?.bottom && (r = Math.max(o?.bottom, r));
    }
    i = t.scrollDOM.clientHeight - n - r;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function QM(t, e) {
  let n = XM(t), { state: r } = t, i = Jd(r.selection, (o) => o.empty ? t.moveVertically(o, e, n.height) : Yv(o, e));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (n.selfScroll) {
    let o = t.coordsAtPos(r.selection.main.head), l = t.scrollDOM.getBoundingClientRect(), a = l.top + n.marginTop, u = l.bottom - n.marginBottom;
    o && o.top > a && o.bottom < u && (s = $e.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - a }));
  }
  return t.dispatch(il(r, i), { effects: s }), !0;
}
const GE = (t) => QM(t, !1), v4 = (t) => QM(t, !0);
function gc(t, e, n) {
  let r = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, n);
  if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, !1)), !n && i.head == r.from && r.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = de.cursor(r.from + s));
  }
  return i;
}
const Cte = (t) => sl(t, (e) => gc(t, e, !0)), Ste = (t) => sl(t, (e) => gc(t, e, !1)), Ate = (t) => sl(t, (e) => gc(t, e, !vi(t))), Ete = (t) => sl(t, (e) => gc(t, e, vi(t))), Dte = (t) => sl(t, (e) => de.cursor(t.lineBlockAt(e.head).from, 1)), Ote = (t) => sl(t, (e) => de.cursor(t.lineBlockAt(e.head).to, -1));
function Fte(t, e, n) {
  let r = !1, i = Jd(t.selection, (s) => {
    let o = Ml(t, s.head, -1) || Ml(t, s.head, 1) || s.head > 0 && Ml(t, s.head - 1, 1) || s.head < t.doc.length && Ml(t, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return de.cursor(l);
  });
  return r ? (e(il(t, i)), !0) : !1;
}
const Tte = ({ state: t, dispatch: e }) => Fte(t, e);
function ko(t, e) {
  let n = Jd(t.state.selection, (r) => {
    let i = e(r);
    return de.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(il(t.state, n)), !0);
}
function JM(t, e) {
  return ko(t, (n) => t.moveByChar(n, e));
}
const ZM = (t) => JM(t, !vi(t)), eP = (t) => JM(t, vi(t));
function tP(t, e) {
  return ko(t, (n) => t.moveByGroup(n, e));
}
const Rte = (t) => tP(t, !vi(t)), Mte = (t) => tP(t, vi(t)), Pte = (t) => ko(t, (e) => Xv(t.state, e, !vi(t))), Ite = (t) => ko(t, (e) => Xv(t.state, e, vi(t)));
function nP(t, e) {
  return ko(t, (n) => t.moveVertically(n, e));
}
const rP = (t) => nP(t, !1), iP = (t) => nP(t, !0);
function sP(t, e) {
  return ko(t, (n) => t.moveVertically(n, e, XM(t).height));
}
const KE = (t) => sP(t, !1), YE = (t) => sP(t, !0), Nte = (t) => ko(t, (e) => gc(t, e, !0)), Bte = (t) => ko(t, (e) => gc(t, e, !1)), Lte = (t) => ko(t, (e) => gc(t, e, !vi(t))), $te = (t) => ko(t, (e) => gc(t, e, vi(t))), zte = (t) => ko(t, (e) => de.cursor(t.lineBlockAt(e.head).from)), jte = (t) => ko(t, (e) => de.cursor(t.lineBlockAt(e.head).to)), XE = ({ state: t, dispatch: e }) => (e(il(t, { anchor: 0 })), !0), QE = ({ state: t, dispatch: e }) => (e(il(t, { anchor: t.doc.length })), !0), JE = ({ state: t, dispatch: e }) => (e(il(t, { anchor: t.selection.main.anchor, head: 0 })), !0), ZE = ({ state: t, dispatch: e }) => (e(il(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), qte = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), Ute = ({ state: t, dispatch: e }) => {
  let n = Qv(t).map(({ from: r, to: i }) => de.range(r, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: de.create(n), userEvent: "select" })), !0;
}, Hte = ({ state: t, dispatch: e }) => {
  let n = Jd(t.selection, (r) => {
    let i = Dr(t), s = i.resolveStack(r.from, 1);
    if (r.empty) {
      let o = i.resolveStack(r.from, -1);
      o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
    }
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < r.from && l.to >= r.to || l.to > r.to && l.from <= r.from) && o.next)
        return de.range(l.to, l.from);
    }
    return r;
  });
  return n.eq(t.selection) ? !1 : (e(il(t, n)), !0);
};
function oP(t, e) {
  let { state: n } = t, r = n.selection, i = n.selection.ranges.slice();
  for (let s of n.selection.ranges) {
    let o = n.doc.lineAt(s.head);
    if (e ? o.to < t.state.doc.length : o.from > 0)
      for (let l = s; ; ) {
        let a = t.moveVertically(l, e);
        if (a.head < o.from || a.head > o.to) {
          i.some((u) => u.head == a.head) || i.push(a);
          break;
        } else {
          if (a.head == l.head)
            break;
          l = a;
        }
      }
  }
  return i.length == r.ranges.length ? !1 : (t.dispatch(il(n, de.create(i, i.length - 1))), !0);
}
const Vte = (t) => oP(t, !1), Wte = (t) => oP(t, !0), Gte = ({ state: t, dispatch: e }) => {
  let n = t.selection, r = null;
  return n.ranges.length > 1 ? r = de.create([n.main]) : n.main.empty || (r = de.create([de.cursor(n.main.head)])), r ? (e(il(t, r)), !0) : !1;
};
function tm(t, e) {
  if (t.state.readOnly)
    return !1;
  let n = "delete.selection", { state: r } = t, i = r.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(s);
      a < o ? (n = "delete.backward", a = j1(t, a, !1)) : a > o && (n = "delete.forward", a = j1(t, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = j1(t, o, !1), l = j1(t, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: de.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? $e.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function j1(t, e, n) {
  if (t instanceof $e)
    for (let r of t.state.facet($e.atomicRanges).map((i) => i(t)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = n ? s : i);
      });
  return e;
}
const lP = (t, e, n) => tm(t, (r) => {
  let i = r.from, { state: s } = t, o = s.doc.lineAt(i), l, a;
  if (n && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test(l = o.text.slice(0, i - o.from))) {
    if (l[l.length - 1] == "	")
      return i - 1;
    let u = Xd(l, s.tabSize), c = u % wb(s) || wb(s);
    for (let f = 0; f < c && l[l.length - 1 - f] == " "; f++)
      i--;
    a = i;
  } else
    a = Yr(o.text, i - o.from, e, e) + o.from, a == i && o.number != (e ? s.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(a - o.from, i - o.from)) && (a = Yr(o.text, a - o.from, !1, !1) + o.from);
  return a;
}), x4 = (t) => lP(t, !1, !0), aP = (t) => lP(t, !0, !1), uP = (t, e) => tm(t, (n) => {
  let r = n.head, { state: i } = t, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let l = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == n.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let a = Yr(s.text, r - s.from, e) + s.from, u = s.text.slice(Math.min(r, a) - s.from, Math.max(r, a) - s.from), c = o(u);
    if (l != null && c != l)
      break;
    (u != " " || r != n.head) && (l = c), r = a;
  }
  return r;
}), cP = (t) => uP(t, !1), Kte = (t) => uP(t, !0), Yte = (t) => tm(t, (e) => {
  let n = t.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), Xte = (t) => tm(t, (e) => {
  let n = t.moveToLineBoundary(e, !1).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
}), Qte = (t) => tm(t, (e) => {
  let n = t.moveToLineBoundary(e, !0).head;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), Jte = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: rn.of(["", ""]) },
    range: de.cursor(r.from)
  }));
  return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Zte = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == t.doc.length)
      return { range: r };
    let i = r.from, s = t.doc.lineAt(i), o = i == s.from ? i - 1 : Yr(s.text, i - s.from, !1) + s.from, l = i == s.to ? i + 1 : Yr(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: t.doc.slice(i, l).append(t.doc.slice(o, i)) },
      range: de.cursor(l)
    };
  });
  return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Qv(t) {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.from), s = t.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = t.doc.lineAt(r.to - 1)), n >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      e.push({ from: i.from, to: s.to, ranges: [r] });
    n = s.number + 1;
  }
  return e;
}
function fP(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of Qv(t)) {
    if (n ? s.to == t.doc.length : s.from == 0)
      continue;
    let o = t.doc.lineAt(n ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (n) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + t.lineBreak });
      for (let a of s.ranges)
        i.push(de.range(Math.min(t.doc.length, a.anchor + l), Math.min(t.doc.length, a.head + l)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: t.lineBreak + o.text });
      for (let a of s.ranges)
        i.push(de.range(a.anchor - l, a.head - l));
    }
  }
  return r.length ? (e(t.update({
    changes: r,
    scrollIntoView: !0,
    selection: de.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const ene = ({ state: t, dispatch: e }) => fP(t, e, !1), tne = ({ state: t, dispatch: e }) => fP(t, e, !0);
function hP(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [];
  for (let i of Qv(t))
    n ? r.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : r.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const nne = ({ state: t, dispatch: e }) => hP(t, e, !1), rne = ({ state: t, dispatch: e }) => hP(t, e, !0), ine = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, n = e.changes(Qv(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), r = Jd(e.selection, (i) => {
    let s;
    if (t.lineWrapping) {
      let o = t.lineBlockAt(i.head), l = t.coordsAtPos(i.head, i.assoc || 1);
      l && (s = o.bottom + t.documentTop - l.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(i, !0, s);
  }).map(n);
  return t.dispatch({ changes: n, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function sne(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = Dr(t).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), s;
  return r && i && r.to <= e && i.from >= e && (s = r.type.prop(Mt.closedBy)) && s.indexOf(i.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const eD = /* @__PURE__ */ dP(!1), one = /* @__PURE__ */ dP(!0);
function dP(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i, l = e.doc.lineAt(s), a = !t && s == o && sne(e, s);
      t && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let u = new Wv(e, { simulateBreak: s, simulateDoubleBreak: !!a }), c = v6(u, s);
      for (c == null && (c = Xd(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let f = ["", sg(e, c)];
      return a && f.push(sg(e, u.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: rn.of(f) },
        range: de.cursor(s + 1 + f[1].length)
      };
    });
    return n(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function T6(t, e) {
  let n = -1;
  return t.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let l = t.doc.lineAt(o);
      l.number > n && (r.empty || r.to > l.from) && (e(l, i, r), n = l.number), o = l.to + 1;
    }
    let s = t.changes(i);
    return {
      changes: i,
      range: de.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const lne = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), r = new Wv(t, { overrideIndentation: (s) => {
    let o = n[s];
    return o ?? -1;
  } }), i = T6(t, (s, o, l) => {
    let a = v6(r, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let u = /^\s*/.exec(s.text)[0], c = sg(t, a);
    (u != c || l.from < s.from + u.length) && (n[s.from] = a, o.push({ from: s.from, to: s.from + u.length, insert: c }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, pP = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(T6(t, (n, r) => {
  r.push({ from: n.from, insert: t.facet(Vv) });
}), { userEvent: "input.indent" })), !0), gP = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(T6(t, (n, r) => {
  let i = /^\s*/.exec(n.text)[0];
  if (!i)
    return;
  let s = Xd(i, t.tabSize), o = 0, l = sg(t, Math.max(0, s - wb(t)));
  for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  r.push({ from: n.from + o, to: n.from + i.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), ane = (t) => (t.setTabFocusMode(), !0), une = ({ state: t, dispatch: e }) => t.selection.ranges.some((n) => !n.empty) ? pP({ state: t, dispatch: e }) : (e(t.update(t.replaceSelection("	"), { scrollIntoView: !0, userEvent: "input" })), !0), cne = [
  { key: "Ctrl-b", run: HM, shift: ZM, preventDefault: !0 },
  { key: "Ctrl-f", run: VM, shift: eP },
  { key: "Ctrl-p", run: KM, shift: rP },
  { key: "Ctrl-n", run: YM, shift: iP },
  { key: "Ctrl-a", run: Dte, shift: zte },
  { key: "Ctrl-e", run: Ote, shift: jte },
  { key: "Ctrl-d", run: aP },
  { key: "Ctrl-h", run: x4 },
  { key: "Ctrl-k", run: Yte },
  { key: "Ctrl-Alt-h", run: cP },
  { key: "Ctrl-o", run: Jte },
  { key: "Ctrl-t", run: Zte },
  { key: "Ctrl-v", run: v4 }
], fne = /* @__PURE__ */ [
  { key: "ArrowLeft", run: HM, shift: ZM, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: vte, shift: Rte, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: Ate, shift: Lte, preventDefault: !0 },
  { key: "ArrowRight", run: VM, shift: eP, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: xte, shift: Mte, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: Ete, shift: $te, preventDefault: !0 },
  { key: "ArrowUp", run: KM, shift: rP, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: XE, shift: JE },
  { mac: "Ctrl-ArrowUp", run: GE, shift: KE },
  { key: "ArrowDown", run: YM, shift: iP, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: QE, shift: ZE },
  { mac: "Ctrl-ArrowDown", run: v4, shift: YE },
  { key: "PageUp", run: GE, shift: KE },
  { key: "PageDown", run: v4, shift: YE },
  { key: "Home", run: Ste, shift: Bte, preventDefault: !0 },
  { key: "Mod-Home", run: XE, shift: JE },
  { key: "End", run: Cte, shift: Nte, preventDefault: !0 },
  { key: "Mod-End", run: QE, shift: ZE },
  { key: "Enter", run: eD, shift: eD },
  { key: "Mod-a", run: qte },
  { key: "Backspace", run: x4, shift: x4, preventDefault: !0 },
  { key: "Delete", run: aP, preventDefault: !0 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: cP, preventDefault: !0 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Kte, preventDefault: !0 },
  { mac: "Mod-Backspace", run: Xte, preventDefault: !0 },
  { mac: "Mod-Delete", run: Qte, preventDefault: !0 }
].concat(/* @__PURE__ */ cne.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), hne = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: _te, shift: Pte },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: kte, shift: Ite },
  { key: "Alt-ArrowUp", run: ene },
  { key: "Shift-Alt-ArrowUp", run: nne },
  { key: "Alt-ArrowDown", run: tne },
  { key: "Shift-Alt-ArrowDown", run: rne },
  { key: "Mod-Alt-ArrowUp", run: Vte },
  { key: "Mod-Alt-ArrowDown", run: Wte },
  { key: "Escape", run: Gte },
  { key: "Mod-Enter", run: one },
  { key: "Alt-l", mac: "Ctrl-l", run: Ute },
  { key: "Mod-i", run: Hte, preventDefault: !0 },
  { key: "Mod-[", run: gP },
  { key: "Mod-]", run: pP },
  { key: "Mod-Alt-\\", run: lne },
  { key: "Shift-Mod-k", run: ine },
  { key: "Shift-Mod-\\", run: Tte },
  { key: "Mod-/", run: ete },
  { key: "Alt-A", run: nte },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: ane }
].concat(fne);
class Sb {
  /**
  @internal
  */
  constructor(e, n, r, i, s, o, l, a, u, c = 0, f) {
    this.p = e, this.stack = n, this.state = r, this.reducePos = i, this.pos = s, this.score = o, this.buffer = l, this.bufferBase = a, this.curContext = u, this.lookAhead = c, this.parent = f;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, n, r = 0) {
    let i = e.parser.context;
    return new Sb(e, [], n, r, r, 0, [], 0, i ? new tD(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var n;
    let r = e >> 19, i = e & 65535, { parser: s } = this.p, o = this.reducePos < this.pos - 25;
    o && this.setLookAhead(this.pos);
    let l = s.dynamicPrecedence(i);
    if (l && (this.score += l), r == 0) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos), i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, o ? 8 : 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let a = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), u = a ? this.stack[a - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let f = a ? this.stack[a - 1] : 0, d = this.bufferBase + this.buffer.length - f;
    if (i < s.minRepeatTerm || e & 131072) {
      let p = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, u, p, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[a];
    else {
      let p = this.stack[a - 3];
      this.state = s.getGoto(p, i, !0);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(i, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, n, r, i = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, l = this.buffer.length;
      if (l == 0 && o.parent && (l = o.bufferBase - o.parent.bufferBase, o = o.parent), l > 0 && o.buffer[l - 4] == 0 && o.buffer[l - 1] > -1) {
        if (n == r)
          return;
        if (o.buffer[l - 2] >= n) {
          o.buffer[l - 2] = r;
          return;
        }
      }
    }
    if (!s || this.pos == r)
      this.buffer.push(e, n, r, i);
    else {
      let o = this.buffer.length;
      if (o > 0 && (this.buffer[o - 4] != 0 || this.buffer[o - 1] < 0)) {
        let l = !1;
        for (let a = o; a > 0 && this.buffer[a - 2] > r; a -= 4)
          if (this.buffer[a - 1] >= 0) {
            l = !0;
            break;
          }
        if (l)
          for (; o > 0 && this.buffer[o - 2] > r; )
            this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, i > 4 && (i -= 4);
      }
      this.buffer[o] = e, this.buffer[o + 1] = n, this.buffer[o + 2] = r, this.buffer[o + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, n, r, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let s = e, { parser: o } = this.p;
      (i > this.pos || n <= o.maxNode) && (this.pos = i, o.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(s, r), this.shiftContext(n, r), n <= o.maxNode && this.buffer.push(n, r, i, 4);
    } else
      this.pos = i, this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, n, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, r, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(n, i), this.buffer.push(
      r,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )
      n -= 4;
    let r = e.buffer.slice(n), i = e.bufferBase + n;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new Sb(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, n) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let n = new dne(this); ; ) {
      let r = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, e);
      if (r == 0)
        return !1;
      if ((r & 65536) == 0)
        return !0;
      n.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let s = 0, o; s < n.length; s += 2)
        (o = n[s + 1]) != this.state && this.p.parser.hasAction(o, e) && i.push(n[s], o);
      if (this.stack.length < 120)
        for (let s = 0; i.length < 8 && s < n.length; s += 2) {
          let o = n[s + 1];
          i.some((l, a) => a & 1 && l == o) || i.push(n[s], o);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let s = n[i + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(n[i], this.pos), o.reducePos = this.pos, o.score -= 200, r.push(o);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, n = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((n & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, n)) {
      let r = n >> 19, i = n & 65535, s = this.stack.length - r * 3;
      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        n = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, n = [], r = (i, s) => {
      if (!n.includes(i))
        return n.push(i), e.allActions(i, (o) => {
          if (!(o & 393216)) if (o & 65536) {
            let l = (o >> 19) - s;
            if (l > 1) {
              let a = o & 65535, u = this.stack.length - l * 3;
              if (u >= 0 && e.getGoto(this.stack[u], a, !1) >= 0)
                return l << 19 | 65536 | a;
            }
          } else {
            let l = r(o, s + 1);
            if (l != null)
              return l;
          }
        });
    };
    return r(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != e.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new tD(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class tD {
  constructor(e, n) {
    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;
  }
}
class dne {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let n = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class Ab {
  constructor(e, n, r) {
    this.stack = e, this.pos = n, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new Ab(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Ab(this.stack, this.pos, this.index);
  }
}
function q1(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let n = null;
  for (let r = 0, i = 0; r < t.length; ) {
    let s = 0;
    for (; ; ) {
      let o = t.charCodeAt(r++), l = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let a = o - 32;
      if (a >= 46 && (a -= 46, l = !0), s += a, l)
        break;
      s *= 46;
    }
    n ? n[i++] = s : n = new e(s);
  }
  return n;
}
class Ly {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const nD = new Ly();
class pne {
  /**
  @internal
  */
  constructor(e, n) {
    this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = nD, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, n) {
    let r = this.range, i = this.rangeIndex, s = this.pos + e;
    for (; s < r.from; ) {
      if (!i)
        return null;
      let o = this.ranges[--i];
      s -= r.from - o.to, r = o;
    }
    for (; n < 0 ? s > r.to : s >= r.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let o = this.ranges[++i];
      s += o.from - r.to, r = o;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let n of this.ranges)
      if (n.to > e)
        return Math.max(e, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingâ€”when looking forwardâ€”or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let n = this.chunkOff + e, r, i;
    if (n >= 0 && n < this.chunk.length)
      r = this.pos + e, i = this.chunk.charCodeAt(n);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (r = s, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let o = this.rangeIndex, l = this.range;
        for (; l.to <= r; )
          l = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - r)), i = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, n) {
    this.token.value = e, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), n = this.pos + e.length;
      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, n) {
    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = nD, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to)
      return this.input.read(e, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n)
        break;
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, n)));
    }
    return r;
  }
}
class Gh {
  constructor(e, n) {
    this.data = e, this.id = n;
  }
  token(e, n) {
    let { parser: r } = n.p;
    mne(this.data, e, n, this.id, r.data, r.tokenPrecTable);
  }
}
Gh.prototype.contextual = Gh.prototype.fallback = Gh.prototype.extend = !1;
Gh.prototype.fallback = Gh.prototype.extend = !1;
class gne {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, n = {}) {
    this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function mne(t, e, n, r, i, s) {
  let o = 0, l = 1 << r, { dialect: a } = n.p.parser;
  e: for (; (l & t[o]) != 0; ) {
    let u = t[o + 1];
    for (let p = o + 3; p < u; p += 2)
      if ((t[p + 1] & l) > 0) {
        let m = t[p];
        if (a.allows(m) && (e.token.value == -1 || e.token.value == m || yne(m, e.token.value, i, s))) {
          e.acceptToken(m);
          break;
        }
      }
    let c = e.next, f = 0, d = t[o + 2];
    if (e.next < 0 && d > f && t[u + d * 3 - 3] == 65535) {
      o = t[u + d * 3 - 1];
      continue e;
    }
    for (; f < d; ) {
      let p = f + d >> 1, m = u + p + (p << 1), y = t[m], b = t[m + 1] || 65536;
      if (c < y)
        d = p;
      else if (c >= b)
        f = p + 1;
      else {
        o = t[m + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function rD(t, e, n) {
  for (let r = e, i; (i = t[r]) != 65535; r++)
    if (i == n)
      return r - e;
  return -1;
}
function yne(t, e, n, r) {
  let i = rD(n, r, e);
  return i < 0 || rD(n, r, t) < i;
}
const Ss = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Vw = null;
function iD(t, e, n) {
  let r = t.cursor(Ir.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(n < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((n < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            r.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            r.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (n < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return n < 0 ? 0 : t.length;
      }
}
class bne {
  constructor(e, n) {
    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? iD(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? iD(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let r = this.trees[n], i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = r.children[i], o = this.start[n] + r.positions[i];
      if (o > e)
        return this.nextStart = o, null;
      if (s instanceof xr) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let l = o + s.length;
          if (l <= this.safeTo) {
            let a = s.prop(Mt.lookAhead);
            if (!a || l + a < this.fragment.to)
              return s;
          }
        }
        this.index[n]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = o + s.length;
    }
  }
}
class vne {
  constructor(e, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new Ly());
  }
  getActions(e) {
    let n = 0, r = null, { parser: i } = e.p, { tokenizers: s } = i, o = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), l = e.curContext ? e.curContext.hash : 0, a = 0;
    for (let u = 0; u < s.length; u++) {
      if ((1 << u & o) == 0)
        continue;
      let c = s[u], f = this.tokens[u];
      if (!(r && !c.fallback) && ((c.contextual || f.start != e.pos || f.mask != o || f.context != l) && (this.updateCachedToken(f, c, e), f.mask = o, f.context = l), f.lookAhead > f.end + 25 && (a = Math.max(f.lookAhead, a)), f.value != 0)) {
        let d = n;
        if (f.extended > -1 && (n = this.addActions(e, f.extended, f.end, n)), n = this.addActions(e, f.value, f.end, n), !c.extend && (r = f, n > d))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return a && e.setLookAhead(a), !r && e.pos == this.stream.end && (r = new Ly(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, n = this.addActions(e, r.value, r.end, n)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let n = new Ly(), { pos: r, p: i } = e;
    return n.start = r, n.end = Math.min(r + 1, i.stream.end), n.value = r == i.stream.end ? i.parser.eofTerm : 0, n;
  }
  updateCachedToken(e, n, r) {
    let i = this.stream.clipPos(r.pos);
    if (n.token(this.stream.reset(i, e), r), e.value > -1) {
      let { parser: s } = r.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let l = s.specializers[o](this.stream.read(e.start, e.end), r);
          if (l >= 0 && r.p.parser.dialect.allows(l >> 1)) {
            (l & 1) == 0 ? e.value = l >> 1 : e.extended = l >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, n, r, i) {
    for (let s = 0; s < i; s += 3)
      if (this.actions[s] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = n, this.actions[i++] = r, i;
  }
  addActions(e, n, r, i) {
    let { state: s } = e, { parser: o } = e.p, { data: l } = o;
    for (let a = 0; a < 2; a++)
      for (let u = o.stateSlot(
        s,
        a ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (l[u] == 65535)
          if (l[u + 1] == 1)
            u = Ra(l, u + 2);
          else {
            i == 0 && l[u + 1] == 2 && (i = this.putAction(Ra(l, u + 2), n, r, i));
            break;
          }
        l[u] == n && (i = this.putAction(Ra(l, u + 1), n, r, i));
      }
    return i;
  }
}
class xne {
  constructor(e, n, r, i) {
    this.parser = e, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new pne(n, i), this.tokens = new vne(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = i[0];
    this.stacks = [Sb.start(this, e.top[0], s)], this.fragments = r.length && this.stream.end - s > e.bufferLength * 4 ? new bne(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, n = this.minStackPos, r = this.stacks = [], i, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, l.pos > n)
          r.push(l);
        else {
          if (this.advanceStack(l, r, e))
            continue;
          {
            i || (i = [], s = []), i.push(l);
            let a = this.tokens.getMainToken(l);
            s.push(a.value, a.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let o = i && _ne(i);
      if (o)
        return Ss && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw Ss && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let o = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, r);
      if (o)
        return Ss && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > o)
        for (r.sort((l, a) => a.score - l.score); r.length > o; )
          r.pop();
      r.some((l) => l.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      e: for (let o = 0; o < r.length - 1; o++) {
        let l = r[o];
        for (let a = o + 1; a < r.length; a++) {
          let u = r[a];
          if (l.sameState(u) || l.buffer.length > 500 && u.buffer.length > 500)
            if ((l.score - u.score || l.buffer.length - u.buffer.length) > 0)
              r.splice(a--, 1);
            else {
              r.splice(o--, 1);
              continue e;
            }
        }
      }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let o = 1; o < r.length; o++)
      r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, n, r) {
    let i = e.pos, { parser: s } = this, o = Ss ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, c = u ? e.curContext.hash : 0;
      for (let f = this.fragments.nodeAt(i); f; ) {
        let d = this.parser.nodeSet.types[f.type.id] == f.type ? s.getGoto(e.state, f.type.id) : -1;
        if (d > -1 && f.length && (!u || (f.prop(Mt.contextHash) || 0) == c))
          return e.useNode(f, d), Ss && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(f.type.id)})`), !0;
        if (!(f instanceof xr) || f.children.length == 0 || f.positions[0] > 0)
          break;
        let p = f.children[0];
        if (p instanceof xr && f.positions[0] == 0)
          f = p;
        else
          break;
      }
    }
    let l = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (l > 0)
      return e.reduce(l), Ss && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(
        l & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let a = this.tokens.getActions(e);
    for (let u = 0; u < a.length; ) {
      let c = a[u++], f = a[u++], d = a[u++], p = u == a.length || !r, m = p ? e : e.split(), y = this.tokens.mainToken;
      if (m.apply(c, f, y ? y.start : m.pos, d), Ss && console.log(o + this.stackID(m) + ` (via ${(c & 65536) == 0 ? "shift" : `reduce of ${s.getName(
        c & 65535
        /* Action.ValueMask */
      )}`} for ${s.getName(f)} @ ${i}${m == e ? "" : ", split"})`), p)
        return !0;
      m.pos > i ? n.push(m) : r.push(m);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, n) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > r)
        return sD(e, n), !0;
    }
  }
  runRecovery(e, n, r) {
    let i = null, s = !1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = n[o << 1], u = n[(o << 1) + 1], c = Ss ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (s || (s = !0, l.restart(), Ss && console.log(c + this.stackID(l) + " (restarted)"), this.advanceFully(l, r))))
        continue;
      let f = l.split(), d = c;
      for (let p = 0; p < 10 && f.forceReduce() && (Ss && console.log(d + this.stackID(f) + " (via force-reduce)"), !this.advanceFully(f, r)); p++)
        Ss && (d = this.stackID(f) + " -> ");
      for (let p of l.recoverByInsert(a))
        Ss && console.log(c + this.stackID(p) + " (via recover-insert)"), this.advanceFully(p, r);
      this.stream.end > l.pos ? (u == l.pos && (u++, a = 0), l.recoverByDelete(a, u), Ss && console.log(c + this.stackID(l) + ` (via recover-delete ${this.parser.getName(a)})`), sD(l, r)) : (!i || i.score < l.score) && (i = l);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), xr.build({
      buffer: Ab.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let n = (Vw || (Vw = /* @__PURE__ */ new WeakMap())).get(e);
    return n || Vw.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;
  }
}
function sD(t, e) {
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    if (r.pos == t.pos && r.sameState(t)) {
      e[n].score < t.score && (e[n] = t);
      return;
    }
  }
  e.push(t);
}
class wne {
  constructor(e, n, r) {
    this.source = e, this.flags = n, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
class ug extends dM {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let l = 0; l < e.repeatNodeCount; l++)
      n.push("");
    let r = Object.keys(e.topRules).map((l) => e.topRules[l][1]), i = [];
    for (let l = 0; l < n.length; l++)
      i.push([]);
    function s(l, a, u) {
      i[l].push([a, a.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let a = l[0];
        typeof a == "string" && (a = Mt[a]);
        for (let u = 1; u < l.length; ) {
          let c = l[u++];
          if (c >= 0)
            s(c, a, l[u++]);
          else {
            let f = l[u + -c];
            for (let d = -c; d > 0; d--)
              s(l[u++], a, f);
            u++;
          }
        }
      }
    this.nodeSet = new p6(n.map((l, a) => cs.define({
      name: a >= this.minRepeatTerm ? void 0 : l,
      id: a,
      props: i[a],
      top: r.indexOf(a) > -1,
      error: a == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = uM;
    let o = q1(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let l = 0; l < this.specializerSpecs.length; l++)
      this.specialized[l] = this.specializerSpecs[l].term;
    this.specializers = this.specializerSpecs.map(oD), this.states = q1(e.states, Uint32Array), this.data = q1(e.stateData), this.goto = q1(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((l) => typeof l == "number" ? new Gh(o, l) : l), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, n, r) {
    let i = new xne(this, e, n, r);
    for (let s of this.wrappers)
      i = s(i, e, n, r);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, n, r = !1) {
    let i = this.goto;
    if (n >= i[0])
      return -1;
    for (let s = i[n + 1]; ; ) {
      let o = i[s++], l = o & 1, a = i[s++];
      if (l && r)
        return a;
      for (let u = s + (o >> 1); s < u; s++)
        if (i[s] == e)
          return a;
      if (l)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), o; ; s += 3) {
        if ((o = r[s]) == 65535)
          if (r[s + 1] == 1)
            o = r[s = Ra(r, s + 2)];
          else {
            if (r[s + 1] == 2)
              return Ra(r, s + 2);
            break;
          }
        if (o == n || o == 0)
          return Ra(r, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(e, n) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(e, n) {
    return !!this.allActions(e, (r) => r == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, n) {
    let r = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = r ? n(r) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = Ra(this.data, s + 2);
        else
          break;
      i = n(Ra(this.data, s + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let n = [];
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Ra(this.data, r + 2);
        else
          break;
      if ((this.data[r + 2] & 1) == 0) {
        let i = this.data[r + 1];
        n.some((s, o) => o & 1 && s == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let n = Object.assign(Object.create(ug.prototype), this);
    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = r;
    }
    return e.tokenizers && (n.tokenizers = this.tokenizers.map((r) => {
      let i = e.tokenizers.find((s) => s.from == r);
      return i ? i.to : r;
    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((r, i) => {
      let s = e.specializers.find((l) => l.from == r.external);
      if (!s)
        return r;
      let o = Object.assign(Object.assign({}, r), { external: s.to });
      return n.specializers[i] = oD(o), o;
    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let n = Object.keys(this.dialects), r = n.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = n.indexOf(s);
        o >= 0 && (r[o] = !0);
      }
    let i = null;
    for (let s = 0; s < n.length; s++)
      if (!r[s])
        for (let o = this.dialects[n[s]], l; (l = this.data[o++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new wne(e, r, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new ug(e);
  }
}
function Ra(t, e) {
  return t[e] | t[e + 1] << 16;
}
function _ne(t) {
  let e = null;
  for (let n of t) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || r != null && n.pos > r) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function oD(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (n, r) => t.external(n, r) << 1 | e;
  }
  return t.get;
}
const kne = 36, lD = 1, Cne = 2, yh = 3, Ww = 4, Sne = 5, Ane = 6, Ene = 7, Dne = 8, One = 9, Fne = 10, Tne = 11, Rne = 12, Mne = 13, Pne = 14, Ine = 15, Nne = 16, Bne = 17, aD = 18, Lne = 19, mP = 20, yP = 21, uD = 22, $ne = 23, zne = 24;
function w4(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57;
}
function jne(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function Ic(t, e, n) {
  for (let r = !1; ; ) {
    if (t.next < 0)
      return;
    if (t.next == e && !r) {
      t.advance();
      return;
    }
    r = n && !r && t.next == 92, t.advance();
  }
}
function qne(t, e) {
  e: for (; ; ) {
    if (t.next < 0)
      return;
    if (t.next == 36) {
      t.advance();
      for (let n = 0; n < e.length; n++) {
        if (t.next != e.charCodeAt(n))
          continue e;
        t.advance();
      }
      if (t.next == 36) {
        t.advance();
        return;
      }
    } else
      t.advance();
  }
}
function Une(t, e) {
  let n = "[{<(".indexOf(String.fromCharCode(e)), r = n < 0 ? e : "]}>)".charCodeAt(n);
  for (; ; ) {
    if (t.next < 0)
      return;
    if (t.next == r && t.peek(1) == 39) {
      t.advance(2);
      return;
    }
    t.advance();
  }
}
function _4(t, e) {
  for (; !(t.next != 95 && !w4(t.next)); )
    e != null && (e += String.fromCharCode(t.next)), t.advance();
  return e;
}
function Hne(t) {
  if (t.next == 39 || t.next == 34 || t.next == 96) {
    let e = t.next;
    t.advance(), Ic(t, e, !1);
  } else
    _4(t);
}
function cD(t, e) {
  for (; t.next == 48 || t.next == 49; )
    t.advance();
  e && t.next == e && t.advance();
}
function fD(t, e) {
  for (; ; ) {
    if (t.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (t.next < 48 || t.next > 57)
      break;
    t.advance();
  }
  if (t.next == 69 || t.next == 101)
    for (t.advance(), (t.next == 43 || t.next == 45) && t.advance(); t.next >= 48 && t.next <= 57; )
      t.advance();
}
function hD(t) {
  for (; !(t.next < 0 || t.next == 10); )
    t.advance();
}
function Tc(t, e) {
  for (let n = 0; n < e.length; n++)
    if (e.charCodeAt(n) == t)
      return !0;
  return !1;
}
const Gw = ` 	\r
`;
function bP(t, e, n) {
  let r = /* @__PURE__ */ Object.create(null);
  r.true = r.false = Sne, r.null = r.unknown = Ane;
  for (let i of t.split(" "))
    i && (r[i] = mP);
  for (let i of e.split(" "))
    i && (r[i] = yP);
  for (let i of (n || "").split(" "))
    i && (r[i] = zne);
  return r;
}
const vP = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", xP = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", k4 = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: !1,
  words: /* @__PURE__ */ bP(xP, vP)
};
function Vne(t, e, n, r) {
  let i = {};
  for (let s in k4)
    i[s] = (t.hasOwnProperty(s) ? t : k4)[s];
  return e && (i.words = bP(e, n || "", r)), i;
}
function wP(t) {
  return new gne((e) => {
    var n;
    let { next: r } = e;
    if (e.advance(), Tc(r, Gw)) {
      for (; Tc(e.next, Gw); )
        e.advance();
      e.acceptToken(kne);
    } else if (r == 36 && t.doubleDollarQuotedStrings) {
      let i = _4(e, "");
      e.next == 36 && (e.advance(), qne(e, i), e.acceptToken(yh));
    } else if (r == 39 || r == 34 && t.doubleQuotedStrings)
      Ic(e, r, t.backslashEscapes), e.acceptToken(yh);
    else if (r == 35 && t.hashComments || r == 47 && e.next == 47 && t.slashComments)
      hD(e), e.acceptToken(lD);
    else if (r == 45 && e.next == 45 && (!t.spaceAfterDashes || e.peek(1) == 32))
      hD(e), e.acceptToken(lD);
    else if (r == 47 && e.next == 42) {
      e.advance();
      for (let i = 1; ; ) {
        let s = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), s == 42 && e.next == 47) {
          if (i--, e.advance(), !i)
            break;
        } else s == 47 && e.next == 42 && (i++, e.advance());
      }
      e.acceptToken(Cne);
    } else if ((r == 101 || r == 69) && e.next == 39)
      e.advance(), Ic(e, 39, !0), e.acceptToken(yh);
    else if ((r == 110 || r == 78) && e.next == 39 && t.charSetCasts)
      e.advance(), Ic(e, 39, t.backslashEscapes), e.acceptToken(yh);
    else if (r == 95 && t.charSetCasts)
      for (let i = 0; ; i++) {
        if (e.next == 39 && i > 1) {
          e.advance(), Ic(e, 39, t.backslashEscapes), e.acceptToken(yh);
          break;
        }
        if (!w4(e.next))
          break;
        e.advance();
      }
    else if (t.plsqlQuotingMechanism && (r == 113 || r == 81) && e.next == 39 && e.peek(1) > 0 && !Tc(e.peek(1), Gw)) {
      let i = e.peek(1);
      e.advance(2), Une(e, i), e.acceptToken(yh);
    } else if (Tc(r, t.identifierQuotes)) {
      const i = r == 91 ? 93 : r;
      Ic(e, i, !1), e.acceptToken(Lne);
    } else if (r == 40)
      e.acceptToken(Ene);
    else if (r == 41)
      e.acceptToken(Dne);
    else if (r == 123)
      e.acceptToken(One);
    else if (r == 125)
      e.acceptToken(Fne);
    else if (r == 91)
      e.acceptToken(Tne);
    else if (r == 93)
      e.acceptToken(Rne);
    else if (r == 59)
      e.acceptToken(Mne);
    else if (t.unquotedBitLiterals && r == 48 && e.next == 98)
      e.advance(), cD(e), e.acceptToken(uD);
    else if ((r == 98 || r == 66) && (e.next == 39 || e.next == 34)) {
      const i = e.next;
      e.advance(), t.treatBitsAsBytes ? (Ic(e, i, t.backslashEscapes), e.acceptToken($ne)) : (cD(e, i), e.acceptToken(uD));
    } else if (r == 48 && (e.next == 120 || e.next == 88) || (r == 120 || r == 88) && e.next == 39) {
      let i = e.next == 39;
      for (e.advance(); jne(e.next); )
        e.advance();
      i && e.next == 39 && e.advance(), e.acceptToken(Ww);
    } else if (r == 46 && e.next >= 48 && e.next <= 57)
      fD(e, !0), e.acceptToken(Ww);
    else if (r == 46)
      e.acceptToken(Pne);
    else if (r >= 48 && r <= 57)
      fD(e, !1), e.acceptToken(Ww);
    else if (Tc(r, t.operatorChars)) {
      for (; Tc(e.next, t.operatorChars); )
        e.advance();
      e.acceptToken(Ine);
    } else if (Tc(r, t.specialVar))
      e.next == r && e.advance(), Hne(e), e.acceptToken(Bne);
    else if (r == 58 || r == 44)
      e.acceptToken(Nne);
    else if (w4(r)) {
      let i = _4(e, String.fromCharCode(r));
      e.acceptToken(e.next == 46 || e.peek(-i.length - 1) == 46 ? aD : (n = t.words[i.toLowerCase()]) !== null && n !== void 0 ? n : aD);
    }
  });
}
const _P = /* @__PURE__ */ wP(k4), Wne = /* @__PURE__ */ ug.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "âš  LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, _P],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function C4(t) {
  let e = t.cursor().moveTo(t.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function cg(t, e) {
  let n = t.sliceString(e.from, e.to), r = /^([`'"\[])(.*)([`'"\]])$/.exec(n);
  return r ? r[2] : n;
}
function Eb(t) {
  return t && (t.name == "Identifier" || t.name == "QuotedIdentifier");
}
function Gne(t, e) {
  if (e.name == "CompositeIdentifier") {
    let n = [];
    for (let r = e.firstChild; r; r = r.nextSibling)
      Eb(r) && n.push(cg(t, r));
    return n;
  }
  return [cg(t, e)];
}
function dD(t, e) {
  for (let n = []; ; ) {
    if (!e || e.name != ".")
      return n;
    let r = C4(e);
    if (!Eb(r))
      return n;
    n.unshift(cg(t, r)), e = C4(r);
  }
}
function Kne(t, e) {
  let n = Dr(t).resolveInner(e, -1), r = Xne(t.doc, n);
  return n.name == "Identifier" || n.name == "QuotedIdentifier" || n.name == "Keyword" ? {
    from: n.from,
    quoted: n.name == "QuotedIdentifier" ? t.doc.sliceString(n.from, n.from + 1) : null,
    parents: dD(t.doc, C4(n)),
    aliases: r
  } : n.name == "." ? { from: e, quoted: null, parents: dD(t.doc, n), aliases: r } : { from: e, quoted: null, parents: [], empty: !0, aliases: r };
}
const Yne = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function Xne(t, e) {
  let n;
  for (let i = e; !n; i = i.parent) {
    if (!i)
      return null;
    i.name == "Statement" && (n = i);
  }
  let r = null;
  for (let i = n.firstChild, s = !1, o = null; i; i = i.nextSibling) {
    let l = i.name == "Keyword" ? t.sliceString(i.from, i.to).toLowerCase() : null, a = null;
    if (!s)
      s = l == "from";
    else if (l == "as" && o && Eb(i.nextSibling))
      a = cg(t, i.nextSibling);
    else {
      if (l && Yne.has(l))
        break;
      o && Eb(i) && (a = cg(t, i));
    }
    a && (r || (r = /* @__PURE__ */ Object.create(null)), r[a] = Gne(t, o)), o = /Identifier$/.test(i.name) ? i : null;
  }
  return r;
}
function Qne(t, e, n) {
  return n.map((r) => ({ ...r, label: r.label[0] == t ? r.label : t + r.label + e, apply: void 0 }));
}
const Jne = /^\w*$/, Zne = /^[`'"\[]?\w*[`'"\]]?$/;
function pD(t) {
  return t.self && typeof t.self.label == "string";
}
class R6 {
  constructor(e, n) {
    this.idQuote = e, this.idCaseInsensitive = n, this.list = [], this.children = void 0;
  }
  child(e) {
    let n = this.children || (this.children = /* @__PURE__ */ Object.create(null)), r = n[e];
    return r || (e && !this.list.some((i) => i.label == e) && this.list.push(gD(e, "type", this.idQuote, this.idCaseInsensitive)), n[e] = new R6(this.idQuote, this.idCaseInsensitive));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let n = this.list.findIndex((r) => r.label == e.label);
    n > -1 ? this.list[n] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let n of e)
      this.addCompletion(typeof n == "string" ? gD(n, "property", this.idQuote, this.idCaseInsensitive) : n);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : pD(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let n of Object.keys(e)) {
      let r = e[n], i = null, s = n.replace(/\\?\./g, (l) => l == "." ? "\0" : l).split("\0"), o = this;
      pD(r) && (i = r.self, r = r.children);
      for (let l = 0; l < s.length; l++)
        i && l == s.length - 1 && o.addCompletion(i), o = o.child(s[l].replace(/\\\./g, "."));
      o.addNamespace(r);
    }
  }
}
function gD(t, e, n, r) {
  return new RegExp("^[a-z_][a-z_\\d]*$", r ? "i" : "").test(t) ? { label: t, type: e } : { label: t, type: e, apply: n + t + kP(n) };
}
function kP(t) {
  return t === "[" ? "]" : t;
}
function ere(t, e, n, r, i, s) {
  var o;
  let l = ((o = s?.spec.identifierQuotes) === null || o === void 0 ? void 0 : o[0]) || '"', a = new R6(l, !!s?.spec.caseInsensitiveIdentifiers), u = i ? a.child(i) : null;
  return a.addNamespace(t), e && (u || a).addCompletions(e), n && a.addCompletions(n), u && a.addCompletions(u.list), r && a.addCompletions((u || a).child(r).list), (c) => {
    let { parents: f, from: d, quoted: p, empty: m, aliases: y } = Kne(c.state, c.pos);
    if (m && !c.explicit)
      return null;
    y && f.length == 1 && (f = y[f[0]] || f);
    let b = a;
    for (let _ of f) {
      for (; !b.children || !b.children[_]; )
        if (b == a && u)
          b = u;
        else if (b == u && r)
          b = b.child(r);
        else
          return null;
      let k = b.maybeChild(_);
      if (!k)
        return null;
      b = k;
    }
    let v = b.list;
    if (b == a && y && (v = v.concat(Object.keys(y).map((_) => ({ label: _, type: "constant" })))), p) {
      let _ = p[0], k = kP(_), S = c.state.sliceDoc(c.pos, c.pos + 1) == k;
      return {
        from: d,
        to: S ? c.pos + 1 : void 0,
        options: Qne(_, k, v),
        validFor: Zne
      };
    } else
      return {
        from: d,
        options: v,
        validFor: Jne
      };
  };
}
function tre(t) {
  return t == yP ? "type" : t == mP ? "keyword" : "variable";
}
function nre(t, e, n) {
  let r = Object.keys(t).map((i) => n(e ? i.toUpperCase() : i, tre(t[i])));
  return iee(["QuotedIdentifier", "String", "LineComment", "BlockComment", "."], AM(r));
}
let rre = /* @__PURE__ */ Wne.configure({
  props: [
    /* @__PURE__ */ x6.add({
      Statement: /* @__PURE__ */ d4()
    }),
    /* @__PURE__ */ vM.add({
      Statement(t, e) {
        return { from: Math.min(t.from + 100, e.doc.lineAt(t.from).to), to: t.to };
      },
      BlockComment(t) {
        return { from: t.from + 2, to: t.to - 2 };
      }
    }),
    /* @__PURE__ */ b6({
      Keyword: ie.keyword,
      Type: ie.typeName,
      Builtin: /* @__PURE__ */ ie.standard(ie.name),
      Bits: ie.number,
      Bytes: ie.string,
      Bool: ie.bool,
      Null: ie.null,
      Number: ie.number,
      String: ie.string,
      Identifier: ie.name,
      QuotedIdentifier: /* @__PURE__ */ ie.special(ie.string),
      SpecialVar: /* @__PURE__ */ ie.special(ie.name),
      LineComment: ie.lineComment,
      BlockComment: ie.blockComment,
      Operator: ie.operator,
      "Semi Punctuation": ie.punctuation,
      "( )": ie.paren,
      "{ }": ie.brace,
      "[ ]": ie.squareBracket
    })
  ]
});
class fg {
  constructor(e, n, r) {
    this.dialect = e, this.language = n, this.spec = r;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Reconfigure the parser used by this dialect. Returns a new
  dialect object.
  */
  configureLanguage(e, n) {
    return new fg(this.dialect, this.language.configure(e, n), this.spec);
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let n = Vne(e, e.keywords, e.types, e.builtin), r = ig.define({
      name: "sql",
      parser: rre.configure({
        tokenizers: [{ from: _P, to: wP(n) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new fg(n, r, e);
  }
}
function ire(t, e) {
  return { label: t, type: e, boost: -1 };
}
function sre(t, e = !1, n) {
  return nre(t.dialect.words, e, n || ire);
}
function ore(t) {
  return t.schema ? ere(t.schema, t.tables, t.schemas, t.defaultTable, t.defaultSchema, t.dialect || M6) : () => null;
}
function lre(t) {
  return t.schema ? (t.dialect || M6).language.data.of({
    autocomplete: ore(t)
  }) : [];
}
function are(t = {}) {
  let e = t.dialect || M6;
  return new yM(e.language, [
    lre(t),
    e.language.data.of({
      autocomplete: sre(e, t.upperCaseKeywords, t.keywordCompletion)
    })
  ]);
}
const M6 = /* @__PURE__ */ fg.define({}), ure = /* @__PURE__ */ fg.define({
  charSetCasts: !0,
  doubleDollarQuotedStrings: !0,
  operatorChars: "+-*/<>=~!@#%^&|`?",
  specialVar: "",
  keywords: xP + "abort abs absent access according ada admin aggregate alias also always analyse analyze array_agg array_max_cardinality asensitive assert assignment asymmetric atomic attach attribute attributes avg backward base64 begin_frame begin_partition bernoulli bit_length blocked bom cache called cardinality catalog_name ceil ceiling chain char_length character_length character_set_catalog character_set_name character_set_schema characteristics characters checkpoint class class_origin cluster coalesce cobol collation_catalog collation_name collation_schema collect column_name columns command_function command_function_code comment comments committed concurrently condition_number configuration conflict connection_name constant constraint_catalog constraint_name constraint_schema contains content control conversion convert copy corr cost covar_pop covar_samp csv cume_dist current_catalog current_row current_schema cursor_name database datalink datatype datetime_interval_code datetime_interval_precision db debug defaults defined definer degree delimiter delimiters dense_rank depends derived detach detail dictionary disable discard dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue document dump dynamic_function dynamic_function_code element elsif empty enable encoding encrypted end_frame end_partition endexec enforced enum errcode error event every exclude excluding exclusive exp explain expression extension extract family file filter final first_value flag floor following force foreach fortran forward frame_row freeze fs functions fusion generated granted greatest groups handler header hex hierarchy hint id ignore ilike immediately immutable implementation implicit import include including increment indent index indexes info inherit inherits inline insensitive instance instantiable instead integrity intersection invoker isnull key_member key_type label lag last_value lead leakproof least length library like_regex link listen ln load location lock locked log logged lower mapping matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text min minvalue mod mode more move multiset mumps name namespace nfc nfd nfkc nfkd nil normalize normalized nothing notice notify notnull nowait nth_value ntile nullable nullif nulls number occurrences_regex octet_length octets off offset oids operator options ordering others over overlay overriding owned owner parallel parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partition pascal passing passthrough password percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding prepared print_strict_params procedural procedures program publication query quote raise range rank reassign recheck recovery refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex rename repeatable replace replica requiring reset respect restart restore result_oid returned_cardinality returned_length returned_octet_length returned_sqlstate returning reverse routine_catalog routine_name routine_schema routines row_count row_number rowtype rule scale schema_name schemas scope scope_catalog scope_name scope_schema security selective self sensitive sequence sequences serializable server server_name setof share show simple skip slice snapshot source specific_name sqlcode sqlerror sqrt stable stacked standalone statement statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time table_name tables tablesample tablespace temp template ties token top_level_count transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex trigger_catalog trigger_name trigger_schema trim trim_array truncate trusted type types uescape unbounded uncommitted unencrypted unlink unlisten unlogged unnamed untyped upper uri use_column use_variable user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema vacuum valid validate validator value_of var_pop var_samp varbinary variable_conflict variadic verbose version versioning views volatile warning whitespace width_bucket window within wrapper xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate yes",
  types: vP + "bigint int8 bigserial serial8 varbit bool box bytea cidr circle precision float8 inet int4 json jsonb line lseg macaddr macaddr8 money numeric pg_lsn point polygon float4 int2 smallserial serial2 serial serial4 text timetz timestamptz tsquery tsvector txid_snapshot uuid xml"
});
class mD {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.diagnostic = r;
  }
}
class $c {
  constructor(e, n, r) {
    this.diagnostics = e, this.panel = n, this.selected = r;
  }
  static init(e, n, r) {
    let i = r.facet(Il).markerFilter;
    i && (e = i(e, r));
    let s = e.slice().sort((p, m) => p.from - m.from || p.to - m.to), o = new nc(), l = [], a = 0, u = r.doc.iter(), c = 0, f = r.doc.length;
    for (let p = 0; ; ) {
      let m = p == s.length ? null : s[p];
      if (!m && !l.length)
        break;
      let y, b;
      if (l.length)
        y = a, b = l.reduce((k, S) => Math.min(k, S.to), m && m.from > y ? m.from : 1e8);
      else {
        if (y = m.from, y > f)
          break;
        b = m.to, l.push(m), p++;
      }
      for (; p < s.length; ) {
        let k = s[p];
        if (k.from == y && (k.to > k.from || k.to == y))
          l.push(k), p++, b = Math.min(k.to, b);
        else {
          b = Math.min(k.from, b);
          break;
        }
      }
      b = Math.min(b, f);
      let v = !1;
      if (l.some((k) => k.from == y && (k.to == b || b == f)) && (v = y == b, !v && b - y < 10)) {
        let k = y - (c + u.value.length);
        k > 0 && (u.next(k), c = y);
        for (let S = y; ; ) {
          if (S >= b) {
            v = !0;
            break;
          }
          if (!u.lineBreak && c + u.value.length > S)
            break;
          S = c + u.value.length, c += u.value.length, u.next();
        }
      }
      let _ = Cre(l);
      if (v)
        o.add(y, y, at.widget({
          widget: new xre(_),
          diagnostics: l.slice()
        }));
      else {
        let k = l.reduce((S, C) => C.markClass ? S + " " + C.markClass : S, "");
        o.add(y, b, at.mark({
          class: "cm-lintRange cm-lintRange-" + _ + k,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((S) => S.to > b)
        }));
      }
      if (a = b, a == f)
        break;
      for (let k = 0; k < l.length; k++)
        l[k].to <= a && l.splice(k--, 1);
    }
    let d = o.finish();
    return new $c(d, n, Sd(d));
  }
}
function Sd(t, e = null, n = 0) {
  let r = null;
  return t.between(n, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new mD(i, s, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new mD(r.from, s, r.diagnostic);
      }
  }), r;
}
function cre(t, e) {
  let n = e.pos, r = e.end || n, i = t.state.facet(Il).hideOn(t, n, r);
  if (i != null)
    return i;
  let s = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((o) => o.is(P6)) || t.changes.touchesRange(s.from, Math.max(s.to, r)));
}
function CP(t, e) {
  return t.field(zs, !1) ? e : e.concat(St.appendConfig.of(DP));
}
function fre(t, e) {
  return {
    effects: CP(t, [P6.of(e)])
  };
}
const P6 = /* @__PURE__ */ St.define(), I6 = /* @__PURE__ */ St.define(), SP = /* @__PURE__ */ St.define(), zs = /* @__PURE__ */ jr.define({
  create() {
    return new $c(at.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let n = t.diagnostics.map(e.changes), r = null, i = t.panel;
      if (t.selected) {
        let s = e.changes.mapPos(t.selected.from, 1);
        r = Sd(n, t.selected.diagnostic, s) || Sd(n, null, s);
      }
      !n.size && i && e.state.facet(Il).autoPanel && (i = null), t = new $c(n, i, r);
    }
    for (let n of e.effects)
      if (n.is(P6)) {
        let r = e.state.facet(Il).autoPanel ? n.value.length ? hg.open : null : t.panel;
        t = $c.init(n.value, r, e.state);
      } else n.is(I6) ? t = new $c(t.diagnostics, n.value ? hg.open : null, t.selected) : n.is(SP) && (t = new $c(t.diagnostics, t.panel, n.value));
    return t;
  },
  provide: (t) => [
    tg.from(t, (e) => e.panel),
    $e.decorations.from(t, (e) => e.diagnostics)
  ]
}), hre = /* @__PURE__ */ at.mark({ class: "cm-lintRange cm-lintRange-active" });
function dre(t, e, n) {
  let { diagnostics: r } = t.state.field(zs), i, s = -1, o = -1;
  r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (a, u, { spec: c }) => {
    if (e >= a && e <= u && (a == u || (e > a || n > 0) && (e < u || n < 0)))
      return i = c.diagnostics, s = a, o = u, !1;
  });
  let l = t.state.facet(Il).tooltipFilter;
  return i && l && (i = l(i, t.state)), i ? {
    pos: s,
    end: o,
    above: t.state.doc.lineAt(s).to < o,
    create() {
      return { dom: pre(t, i) };
    }
  } : null;
}
function pre(t, e) {
  return Dn("ul", { class: "cm-tooltip-lint" }, e.map((n) => EP(t, n, !1)));
}
const gre = (t) => {
  let e = t.state.field(zs, !1);
  (!e || !e.panel) && t.dispatch({ effects: CP(t.state, [I6.of(!0)]) });
  let n = eg(t, hg.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, yD = (t) => {
  let e = t.state.field(zs, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: I6.of(!1) }), !0);
}, mre = (t) => {
  let e = t.state.field(zs, !1);
  if (!e)
    return !1;
  let n = t.state.selection.main, r = e.diagnostics.iter(n.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == n.from && r.to == n.to) ? !1 : (t.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, yre = [
  { key: "Mod-Shift-m", run: gre, preventDefault: !0 },
  { key: "F8", run: mre }
], bre = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.view = t, this.timeout = -1, this.set = !0;
    let { delay: e } = t.state.facet(Il);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    clearTimeout(this.timeout);
    let t = Date.now();
    if (t < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - t);
    else {
      this.set = !1;
      let { state: e } = this.view, { sources: n } = e.facet(Il);
      n.length && vre(n.map((r) => Promise.resolve(r(this.view))), (r) => {
        this.view.state.doc == e.doc && this.view.dispatch(fre(this.view.state, r.reduce((i, s) => i.concat(s))));
      }, (r) => {
        Mi(this.view.state, r);
      });
    }
  }
  update(t) {
    let e = t.state.facet(Il);
    (t.docChanged || e != t.startState.facet(Il) || e.needsRefresh && e.needsRefresh(t)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function vre(t, e, n) {
  let r = [], i = -1;
  for (let s of t)
    s.then((o) => {
      r.push(o), clearTimeout(i), r.length == t.length ? e(r) : i = setTimeout(() => e(r), 200);
    }, n);
}
const Il = /* @__PURE__ */ ze.define({
  combine(t) {
    return {
      sources: t.map((e) => e.source).filter((e) => e != null),
      ...iu(t.map((e) => e.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        delay: Math.max,
        markerFilter: bD,
        tooltipFilter: bD,
        needsRefresh: (e, n) => e ? n ? (r) => e(r) || n(r) : e : n,
        hideOn: (e, n) => e ? n ? (r, i, s) => e(r, i, s) || n(r, i, s) : e : n,
        autoPanel: (e, n) => e || n
      })
    };
  }
});
function bD(t, e) {
  return t ? e ? (n, r) => e(t(n, r), r) : t : e;
}
function vD(t, e = {}) {
  return [
    Il.of({ source: t, config: e }),
    bre,
    DP
  ];
}
function AP(t) {
  let e = [];
  if (t)
    e: for (let { name: n } of t) {
      for (let r = 0; r < n.length; r++) {
        let i = n[r];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function EP(t, e, n) {
  var r;
  let i = n ? AP(e.actions) : [];
  return Dn("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Dn("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let l = !1, a = (p) => {
      if (p.preventDefault(), l)
        return;
      l = !0;
      let m = Sd(t.state.field(zs).diagnostics, e);
      m && s.apply(t, m.from, m.to);
    }, { name: u } = s, c = i[o] ? u.indexOf(i[o]) : -1, f = c < 0 ? u : [
      u.slice(0, c),
      Dn("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ], d = s.markClass ? " " + s.markClass : "";
    return Dn("button", {
      type: "button",
      class: "cm-diagnosticAction" + d,
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, f);
  }), e.source && Dn("div", { class: "cm-diagnosticSource" }, e.source));
}
class xre extends $f {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Dn("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class xD {
  constructor(e, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = EP(e, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class hg {
  constructor(e) {
    this.view = e, this.items = [];
    let n = (i) => {
      if (i.keyCode == 27)
        yD(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = AP(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let a = Sd(this.view.state.field(zs).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = Dn("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: r
    }), this.dom = Dn("div", { class: "cm-panel-lint" }, this.list, Dn("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => yD(this.view)
    }, "Ã—")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(zs).selected;
    if (!e)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == e.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(zs), r = 0, i = !1, s = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (l, a, { spec: u }) => {
      for (let c of u.diagnostics) {
        if (o.has(c))
          continue;
        o.add(c);
        let f = -1, d;
        for (let p = r; p < this.items.length; p++)
          if (this.items[p].diagnostic == c) {
            f = p;
            break;
          }
        f < 0 ? (d = new xD(this.view, c), this.items.splice(r, 0, d), i = !0) : (d = this.items[f], f > r && (this.items.splice(r, f - r), i = !0)), n && d.diagnostic == n.diagnostic ? d.dom.hasAttribute("aria-selected") || (d.dom.setAttribute("aria-selected", "true"), s = d) : d.dom.hasAttribute("aria-selected") && d.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new xD(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: l, panel: a }) => {
        let u = a.height / this.list.offsetHeight;
        l.top < a.top ? this.list.scrollTop -= (a.top - l.top) / u : l.bottom > a.bottom && (this.list.scrollTop += (l.bottom - a.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          n();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(zs), r = Sd(n.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: SP.of(r)
    });
  }
  static open(e) {
    return new hg(e);
  }
}
function wre(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function U1(t) {
  return wre(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const _re = /* @__PURE__ */ $e.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ U1("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ U1("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ U1("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ U1("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function kre(t) {
  return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
}
function Cre(t) {
  let e = "hint", n = 1;
  for (let r of t) {
    let i = kre(r.severity);
    i > n && (n = i, e = r.severity);
  }
  return e;
}
const DP = [
  zs,
  /* @__PURE__ */ $e.decorations.compute([zs], (t) => {
    let { selected: e, panel: n } = t.field(zs);
    return !e || !n || e.from == e.to ? at.none : at.set([
      hre.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ sM(dre, { hideOn: cre }),
  _re
], wD = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class Ad {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, n, r = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (l) => s(wD(l)) : wD, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Ji(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let n = Zk(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += Al(e);
      let i = this.normalize(n);
      if (i.length)
        for (let s = 0, o = r; ; s++) {
          let l = i.charCodeAt(s), a = this.match(l, o, this.bufferPos + this.bufferStart);
          if (s == i.length - 1) {
            if (a)
              return this.value = a, this;
            break;
          }
          o == r && s < n.length && n.charCodeAt(s) == l && o++;
        }
    }
  }
  match(e, n, r) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], l = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: r } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: n, to: r } : this.matches.push(1, n)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Ad.prototype[Symbol.iterator] = function() {
  return this;
});
const OP = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, N6 = "gm" + (/x/.unicode == null ? "" : "u");
class FP {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, n, r, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = OP, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new TP(e, n, r, i, s);
    this.re = new RegExp(n, N6 + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = Db(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index, i = r + n[0].length;
        if (this.matchPos = Db(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Kw = /* @__PURE__ */ new WeakMap();
class Kh {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, r) {
    let i = Kw.get(e);
    if (!i || i.from >= r || i.to <= n) {
      let l = new Kh(n, e.sliceString(n, r));
      return Kw.set(e, l), l;
    }
    if (i.from == n && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > n && (s = e.sliceString(n, o) + s, o = n), i.to < r && (s += e.sliceString(i.to, r)), Kw.set(e, new Kh(o, s)), new Kh(n, s.slice(n - o, r - o));
  }
}
class TP {
  constructor(e, n, r, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = OP, this.matchPos = Db(e, i), this.re = new RegExp(n, N6 + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = Kh.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let r = this.flat.from + n.index, i = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this.matchPos = Db(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Kh.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (FP.prototype[Symbol.iterator] = TP.prototype[Symbol.iterator] = function() {
  return this;
});
function Sre(t) {
  try {
    return new RegExp(t, N6), !0;
  } catch {
    return !1;
  }
}
function Db(t, e) {
  if (e >= t.length)
    return e;
  let n = t.lineAt(e), r;
  for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function S4(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = Dn("input", { class: "cm-textfield", name: "line", value: e }), r = Dn("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: Fp.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, Dn("label", t.state.phrase("Go to line"), ": ", n), " ", Dn("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")), Dn("button", {
    name: "close",
    onclick: () => {
      t.dispatch({ effects: Fp.of(!1) }), t.focus();
    },
    "aria-label": t.state.phrase("close"),
    type: "button"
  }, ["Ã—"]));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!s)
      return;
    let { state: o } = t, l = o.doc.lineAt(o.selection.main.head), [, a, u, c, f] = s, d = c ? +c.slice(1) : 0, p = u ? +u : l.number;
    if (u && f) {
      let b = p / 100;
      a && (b = b * (a == "-" ? -1 : 1) + l.number / o.doc.lines), p = Math.round(o.doc.lines * b);
    } else u && a && (p = p * (a == "-" ? -1 : 1) + l.number);
    let m = o.doc.line(Math.max(1, Math.min(o.doc.lines, p))), y = de.cursor(m.from + Math.max(0, Math.min(d, m.length)));
    t.dispatch({
      effects: [Fp.of(!1), $e.scrollIntoView(y.from, { y: "center" })],
      selection: y
    }), t.focus();
  }
  return { dom: r };
}
const Fp = /* @__PURE__ */ St.define(), _D = /* @__PURE__ */ jr.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(Fp) && (t = n.value);
    return t;
  },
  provide: (t) => tg.from(t, (e) => e ? S4 : null)
}), Are = (t) => {
  let e = eg(t, S4);
  if (!e) {
    let n = [Fp.of(!0)];
    t.state.field(_D, !1) == null && n.push(St.appendConfig.of([_D, Ere])), t.dispatch({ effects: n }), e = eg(t, S4);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Ere = /* @__PURE__ */ $e.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), Dre = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Ore = /* @__PURE__ */ ze.define({
  combine(t) {
    return iu(t, Dre, {
      highlightWordAroundCursor: (e, n) => e || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Fre(t) {
  return [Ire, Pre];
}
const Tre = /* @__PURE__ */ at.mark({ class: "cm-selectionMatch" }), Rre = /* @__PURE__ */ at.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function kD(t, e, n, r) {
  return (n == 0 || t(e.sliceDoc(n - 1, n)) != Wn.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != Wn.Word);
}
function Mre(t, e, n, r) {
  return t(e.sliceDoc(n, n + 1)) == Wn.Word && t(e.sliceDoc(r - 1, r)) == Wn.Word;
}
const Pre = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(Ore), { state: n } = t, r = n.selection;
    if (r.ranges.length > 1)
      return at.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return at.none;
      let a = n.wordAt(i.head);
      if (!a)
        return at.none;
      o = n.charCategorizer(i.head), s = n.sliceDoc(a.from, a.to);
    } else {
      let a = i.to - i.from;
      if (a < e.minSelectionLength || a > 200)
        return at.none;
      if (e.wholeWords) {
        if (s = n.sliceDoc(i.from, i.to), o = n.charCategorizer(i.head), !(kD(o, n, i.from, i.to) && Mre(o, n, i.from, i.to)))
          return at.none;
      } else if (s = n.sliceDoc(i.from, i.to), !s)
        return at.none;
    }
    let l = [];
    for (let a of t.visibleRanges) {
      let u = new Ad(n.doc, s, a.from, a.to);
      for (; !u.next().done; ) {
        let { from: c, to: f } = u.value;
        if ((!o || kD(o, n, c, f)) && (i.empty && c <= i.from && f >= i.to ? l.push(Rre.range(c, f)) : (c >= i.to || f <= i.from) && l.push(Tre.range(c, f)), l.length > e.maxMatches))
          return at.none;
      }
    }
    return at.set(l);
  }
}, {
  decorations: (t) => t.decorations
}), Ire = /* @__PURE__ */ $e.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Nre = ({ state: t, dispatch: e }) => {
  let { selection: n } = t, r = de.create(n.ranges.map((i) => t.wordAt(i.head) || de.cursor(i.head)), n.mainIndex);
  return r.eq(n) ? !1 : (e(t.update({ selection: r })), !0);
};
function Bre(t, e) {
  let { main: n, ranges: r } = t.selection, i = t.wordAt(n.head), s = i && i.from == n.from && i.to == n.to;
  for (let o = !1, l = new Ad(t.doc, e, r[r.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new Ad(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = t.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const Lre = ({ state: t, dispatch: e }) => {
  let { ranges: n } = t.selection;
  if (n.some((s) => s.from === s.to))
    return Nre({ state: t, dispatch: e });
  let r = t.sliceDoc(n[0].from, n[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = Bre(t, r);
  return i ? (e(t.update({
    selection: t.selection.addRange(de.range(i.from, i.to), !1),
    effects: $e.scrollIntoView(i.to)
  })), !0) : !1;
}, Zd = /* @__PURE__ */ ze.define({
  combine(t) {
    return iu(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Xre(e),
      scrollToMatch: (e) => $e.scrollIntoView(e)
    });
  }
});
class RP {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Sre(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new qre(this) : new zre(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, n = 0, r) {
    let i = e.doc ? e : nn.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? Ah(this, i, n, r) : Sh(this, i, n, r);
  }
}
class MP {
  constructor(e) {
    this.spec = e;
  }
}
function Sh(t, e, n, r) {
  return new Ad(e.doc, t.unquoted, n, r, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? $re(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function $re(t, e) {
  return (n, r, i, s) => ((s > n || s + i.length < r) && (s = Math.max(0, n - 2), i = t.sliceString(s, Math.min(t.length, r + 2))), (e(Ob(i, n - s)) != Wn.Word || e(Fb(i, n - s)) != Wn.Word) && (e(Fb(i, r - s)) != Wn.Word || e(Ob(i, r - s)) != Wn.Word));
}
class zre extends MP {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, r) {
    let i = Sh(this.spec, e, r, e.doc.length).nextOverlapping();
    if (i.done) {
      let s = Math.min(e.doc.length, n + this.spec.unquoted.length);
      i = Sh(this.spec, e, 0, s).nextOverlapping();
    }
    return i.done || i.value.from == n && i.value.to == r ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, n, r) {
    for (let i = r; ; ) {
      let s = Math.max(n, i - 1e4 - this.spec.unquoted.length), o = Sh(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == n)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, n, r) {
    let i = this.prevMatchInRange(e, 0, n);
    return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != n || i.to != r) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let r = Sh(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let s = Sh(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function Ah(t, e, n, r) {
  return new FP(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? jre(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, r);
}
function Ob(t, e) {
  return t.slice(Yr(t, e, !1), e);
}
function Fb(t, e) {
  return t.slice(e, Yr(t, e));
}
function jre(t) {
  return (e, n, r) => !r[0].length || (t(Ob(r.input, r.index)) != Wn.Word || t(Fb(r.input, r.index)) != Wn.Word) && (t(Fb(r.input, r.index + r[0].length)) != Wn.Word || t(Ob(r.input, r.index + r[0].length)) != Wn.Word);
}
class qre extends MP {
  nextMatch(e, n, r) {
    let i = Ah(this.spec, e, r, e.doc.length).next();
    return i.done && (i = Ah(this.spec, e, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        n,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = Ah(this.spec, e, s, r), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == n || l.from > s + 10))
        return l;
      if (s == n)
        return null;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (n, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let i = r.length; i > 0; i--) {
        let s = +r.slice(0, i);
        if (s > 0 && s < e.match.length)
          return e.match[s] + r.slice(i);
      }
      return n;
    });
  }
  matchAll(e, n) {
    let r = Ah(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let s = Ah(this.spec, e, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const dg = /* @__PURE__ */ St.define(), B6 = /* @__PURE__ */ St.define(), Hu = /* @__PURE__ */ jr.define({
  create(t) {
    return new Yw(A4(t).create(), null);
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(dg) ? t = new Yw(n.value.create(), t.panel) : n.is(B6) && (t = new Yw(t.query, n.value ? L6 : null));
    return t;
  },
  provide: (t) => tg.from(t, (e) => e.panel)
});
class Yw {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
}
const Ure = /* @__PURE__ */ at.mark({ class: "cm-searchMatch" }), Hre = /* @__PURE__ */ at.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Vre = /* @__PURE__ */ wr.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Hu));
  }
  update(t) {
    let e = t.state.field(Hu);
    (e != t.startState.field(Hu) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return at.none;
    let { view: n } = this, r = new nc();
    for (let i = 0, s = n.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: a } = s[i];
      for (; i < o - 1 && a > s[i + 1].from - 500; )
        a = s[++i].to;
      t.highlight(n.state, l, a, (u, c) => {
        let f = n.state.selection.ranges.some((d) => d.from == u && d.to == c);
        r.add(u, c, f ? Hre : Ure);
      });
    }
    return r.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function nm(t) {
  return (e) => {
    let n = e.state.field(Hu, !1);
    return n && n.query.spec.valid ? t(e, n) : NP(e);
  };
}
const Tb = /* @__PURE__ */ nm((t, { query: e }) => {
  let { to: n } = t.state.selection.main, r = e.nextMatch(t.state, n, n);
  if (!r)
    return !1;
  let i = de.single(r.from, r.to), s = t.state.facet(Zd);
  return t.dispatch({
    selection: i,
    effects: [$6(t, r), s.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), IP(t), !0;
}), Rb = /* @__PURE__ */ nm((t, { query: e }) => {
  let { state: n } = t, { from: r } = n.selection.main, i = e.prevMatch(n, r, r);
  if (!i)
    return !1;
  let s = de.single(i.from, i.to), o = t.state.facet(Zd);
  return t.dispatch({
    selection: s,
    effects: [$6(t, i), o.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), IP(t), !0;
}), Wre = /* @__PURE__ */ nm((t, { query: e }) => {
  let n = e.matchAll(t.state, 1e3);
  return !n || !n.length ? !1 : (t.dispatch({
    selection: de.create(n.map((r) => de.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Gre = ({ state: t, dispatch: e }) => {
  let n = t.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: r, to: i } = n.main, s = [], o = 0;
  for (let l = new Ad(t.doc, t.sliceDoc(r, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == r && (o = s.length), s.push(de.range(l.value.from, l.value.to));
  }
  return e(t.update({
    selection: de.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, CD = /* @__PURE__ */ nm((t, { query: e }) => {
  let { state: n } = t, { from: r, to: i } = n.selection.main;
  if (n.readOnly)
    return !1;
  let s = e.nextMatch(n, r, r);
  if (!s)
    return !1;
  let o = s, l = [], a, u, c = [];
  o.from == r && o.to == i && (u = n.toText(e.getReplacement(o)), l.push({ from: o.from, to: o.to, insert: u }), o = e.nextMatch(n, o.from, o.to), c.push($e.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + ".")));
  let f = t.state.changes(l);
  return o && (a = de.single(o.from, o.to).map(f), c.push($6(t, o)), c.push(n.facet(Zd).scrollToMatch(a.main, t))), t.dispatch({
    changes: f,
    selection: a,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), Kre = /* @__PURE__ */ nm((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let n = e.matchAll(t.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!n.length)
    return !1;
  let r = t.state.phrase("replaced $ matches", n.length) + ".";
  return t.dispatch({
    changes: n,
    effects: $e.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function L6(t) {
  return t.state.facet(Zd).createPanel(t);
}
function A4(t, e) {
  var n, r, i, s, o;
  let l = t.selection.main, a = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let u = t.facet(Zd);
  return new RP({
    search: ((n = e?.literal) !== null && n !== void 0 ? n : u.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : u.caseSensitive,
    literal: (i = e?.literal) !== null && i !== void 0 ? i : u.literal,
    regexp: (s = e?.regexp) !== null && s !== void 0 ? s : u.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : u.wholeWord
  });
}
function PP(t) {
  let e = eg(t, L6);
  return e && e.dom.querySelector("[main-field]");
}
function IP(t) {
  let e = PP(t);
  e && e == t.root.activeElement && e.select();
}
const NP = (t) => {
  let e = t.state.field(Hu, !1);
  if (e && e.panel) {
    let n = PP(t);
    if (n && n != t.root.activeElement) {
      let r = A4(t.state, e.query.spec);
      r.valid && t.dispatch({ effects: dg.of(r) }), n.focus(), n.select();
    }
  } else
    t.dispatch({ effects: [
      B6.of(!0),
      e ? dg.of(A4(t.state, e.query.spec)) : St.appendConfig.of(Jre)
    ] });
  return !0;
}, BP = (t) => {
  let e = t.state.field(Hu, !1);
  if (!e || !e.panel)
    return !1;
  let n = eg(t, L6);
  return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: B6.of(!1) }), !0;
}, Yre = [
  { key: "Mod-f", run: NP, scope: "editor search-panel" },
  { key: "F3", run: Tb, shift: Rb, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Tb, shift: Rb, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: BP, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Gre },
  { key: "Mod-Alt-g", run: Are },
  { key: "Mod-d", run: Lre, preventDefault: !0 }
];
class Xre {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(Hu).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Dn("input", {
      value: n.search,
      placeholder: As(e, "Find"),
      "aria-label": As(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Dn("input", {
      value: n.replace,
      placeholder: As(e, "Replace"),
      "aria-label": As(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Dn("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = Dn("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = Dn("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return Dn("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = Dn("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Tb(e), [As(e, "next")]),
      r("prev", () => Rb(e), [As(e, "previous")]),
      r("select", () => Wre(e), [As(e, "all")]),
      Dn("label", null, [this.caseField, As(e, "match case")]),
      Dn("label", null, [this.reField, As(e, "regexp")]),
      Dn("label", null, [this.wordField, As(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Dn("br"),
        this.replaceField,
        r("replace", () => CD(e), [As(e, "replace")]),
        r("replaceAll", () => Kre(e), [As(e, "replace all")])
      ],
      Dn("button", {
        name: "close",
        onclick: () => BP(e),
        "aria-label": As(e, "close"),
        type: "button"
      }, ["Ã—"])
    ]);
  }
  commit() {
    let e = new RP({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: dg.of(e) }));
  }
  keydown(e) {
    fJ(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Rb : Tb)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), CD(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(dg) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Zd).top;
  }
}
function As(t, e) {
  return t.state.phrase(e);
}
const H1 = 30, V1 = /[\s\.,:;?!]/;
function $6(t, { from: e, to: n }) {
  let r = t.state.doc.lineAt(e), i = t.state.doc.lineAt(n).to, s = Math.max(r.from, e - H1), o = Math.min(i, n + H1), l = t.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let a = 0; a < H1; a++)
      if (!V1.test(l[a + 1]) && V1.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != i) {
    for (let a = l.length - 1; a > l.length - H1; a--)
      if (!V1.test(l[a - 1]) && V1.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return $e.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${r.number}.`);
}
const Qre = /* @__PURE__ */ $e.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), Jre = [
  Hu,
  /* @__PURE__ */ pc.low(Vre),
  Qre
], Zre = "#e5c07b", SD = "#e06c75", eie = "#56b6c2", tie = "#ffffff", $y = "#abb2bf", E4 = "#7d8799", nie = "#61afef", rie = "#98c379", AD = "#d19a66", iie = "#c678dd", sie = "#21252b", ED = "#2c313a", DD = "#282c34", Xw = "#353a42", oie = "#3E4451", OD = "#528bff", lie = /* @__PURE__ */ $e.theme({
  "&": {
    color: $y,
    backgroundColor: DD
  },
  ".cm-content": {
    caretColor: OD
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: OD },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: oie },
  ".cm-panels": { backgroundColor: sie, color: $y },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: DD,
    color: E4,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: ED
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Xw
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Xw,
    borderBottomColor: Xw
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: ED,
      color: $y
    }
  }
}, { dark: !0 }), aie = /* @__PURE__ */ Zg.define([
  {
    tag: ie.keyword,
    color: iie
  },
  {
    tag: [ie.name, ie.deleted, ie.character, ie.propertyName, ie.macroName],
    color: SD
  },
  {
    tag: [/* @__PURE__ */ ie.function(ie.variableName), ie.labelName],
    color: nie
  },
  {
    tag: [ie.color, /* @__PURE__ */ ie.constant(ie.name), /* @__PURE__ */ ie.standard(ie.name)],
    color: AD
  },
  {
    tag: [/* @__PURE__ */ ie.definition(ie.name), ie.separator],
    color: $y
  },
  {
    tag: [ie.typeName, ie.className, ie.number, ie.changed, ie.annotation, ie.modifier, ie.self, ie.namespace],
    color: Zre
  },
  {
    tag: [ie.operator, ie.operatorKeyword, ie.url, ie.escape, ie.regexp, ie.link, /* @__PURE__ */ ie.special(ie.string)],
    color: eie
  },
  {
    tag: [ie.meta, ie.comment],
    color: E4
  },
  {
    tag: ie.strong,
    fontWeight: "bold"
  },
  {
    tag: ie.emphasis,
    fontStyle: "italic"
  },
  {
    tag: ie.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: ie.link,
    color: E4,
    textDecoration: "underline"
  },
  {
    tag: ie.heading,
    fontWeight: "bold",
    color: SD
  },
  {
    tag: [ie.atom, ie.bool, /* @__PURE__ */ ie.special(ie.variableName)],
    color: AD
  },
  {
    tag: [ie.processingInstruction, ie.string, ie.inserted],
    color: rie
  },
  {
    tag: ie.invalid,
    color: tie
  }
]), uie = [lie, /* @__PURE__ */ wM(aie)];
function zf(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var zy = { exports: {} }, cie = zy.exports, FD;
function fie() {
  return FD || (FD = 1, (function(t) {
    (function(e, n) {
      t.exports ? t.exports = n() : e.log = n();
    })(cie, function() {
      var e = function() {
      }, n = "undefined", r = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), i = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], s = {}, o = null;
      function l(y, b) {
        var v = y[b];
        if (typeof v.bind == "function")
          return v.bind(y);
        try {
          return Function.prototype.bind.call(v, y);
        } catch {
          return function() {
            return Function.prototype.apply.apply(v, [y, arguments]);
          };
        }
      }
      function a() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function u(y) {
        return y === "debug" && (y = "log"), typeof console === n ? !1 : y === "trace" && r ? a : console[y] !== void 0 ? l(console, y) : console.log !== void 0 ? l(console, "log") : e;
      }
      function c() {
        for (var y = this.getLevel(), b = 0; b < i.length; b++) {
          var v = i[b];
          this[v] = b < y ? e : this.methodFactory(v, y, this.name);
        }
        if (this.log = this.debug, typeof console === n && y < this.levels.SILENT)
          return "No console available for logging";
      }
      function f(y) {
        return function() {
          typeof console !== n && (c.call(this), this[y].apply(this, arguments));
        };
      }
      function d(y, b, v) {
        return u(y) || f.apply(this, arguments);
      }
      function p(y, b) {
        var v = this, _, k, S, C = "loglevel";
        typeof y == "string" ? C += ":" + y : typeof y == "symbol" && (C = void 0);
        function E(P) {
          var B = (i[P] || "silent").toUpperCase();
          if (!(typeof window === n || !C)) {
            try {
              window.localStorage[C] = B;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(C) + "=" + B + ";";
            } catch {
            }
          }
        }
        function A() {
          var P;
          if (!(typeof window === n || !C)) {
            try {
              P = window.localStorage[C];
            } catch {
            }
            if (typeof P === n)
              try {
                var B = window.document.cookie, M = encodeURIComponent(C), L = B.indexOf(M + "=");
                L !== -1 && (P = /^([^;]+)/.exec(
                  B.slice(L + M.length + 1)
                )[1]);
              } catch {
              }
            return v.levels[P] === void 0 && (P = void 0), P;
          }
        }
        function O() {
          if (!(typeof window === n || !C)) {
            try {
              window.localStorage.removeItem(C);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(C) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function T(P) {
          var B = P;
          if (typeof B == "string" && v.levels[B.toUpperCase()] !== void 0 && (B = v.levels[B.toUpperCase()]), typeof B == "number" && B >= 0 && B <= v.levels.SILENT)
            return B;
          throw new TypeError("log.setLevel() called with invalid level: " + P);
        }
        v.name = y, v.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, v.methodFactory = b || d, v.getLevel = function() {
          return S ?? k ?? _;
        }, v.setLevel = function(P, B) {
          return S = T(P), B !== !1 && E(S), c.call(v);
        }, v.setDefaultLevel = function(P) {
          k = T(P), A() || v.setLevel(P, !1);
        }, v.resetLevel = function() {
          S = null, O(), c.call(v);
        }, v.enableAll = function(P) {
          v.setLevel(v.levels.TRACE, P);
        }, v.disableAll = function(P) {
          v.setLevel(v.levels.SILENT, P);
        }, v.rebuild = function() {
          if (o !== v && (_ = T(o.getLevel())), c.call(v), o === v)
            for (var P in s)
              s[P].rebuild();
        }, _ = T(
          o ? o.getLevel() : "WARN"
        );
        var $ = A();
        $ != null && (S = T($)), c.call(v);
      }
      o = new p(), o.getLogger = function(b) {
        if (typeof b != "symbol" && typeof b != "string" || b === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var v = s[b];
        return v || (v = s[b] = new p(
          b,
          o.methodFactory
        )), v;
      };
      var m = typeof window !== n ? window.log : void 0;
      return o.noConflict = function() {
        return typeof window !== n && window.log === o && (window.log = m), o;
      }, o.getLoggers = function() {
        return s;
      }, o.default = o, o;
    });
  })(zy)), zy.exports;
}
var hie = fie();
const LP = /* @__PURE__ */ zf(hie);
LP.setLevel("silent");
const Yn = LP, _t = {
  STRING: "String",
  NUMBER: "Number",
  TRUE: "True",
  FALSE: "False",
  NULL: "Null",
  OBJECT: "Object",
  ARRAY: "Array",
  PROPERTY: "Property",
  PROPERTY_NAME: "PropertyName",
  PROPERTY_COLON: "PropertyColon",
  // used in json5 grammar
  ITEM: "Item",
  // used in yaml grammar
  JSON_TEXT: "JsonText",
  INVALID: "âš "
}, die = {
  Pair: _t.PROPERTY,
  Key: _t.PROPERTY_NAME,
  BlockSequence: _t.ARRAY,
  BlockMapping: _t.OBJECT,
  FlowSequence: _t.ARRAY,
  FlowMapping: _t.OBJECT,
  QuotedLiteral: _t.STRING,
  Literal: _t.STRING,
  // best guess
  Stream: _t.JSON_TEXT,
  Document: _t.OBJECT
}, pie = {
  File: _t.JSON_TEXT
}, z6 = [
  _t.STRING,
  _t.NUMBER,
  _t.TRUE,
  _t.FALSE,
  _t.NULL
], $P = [_t.OBJECT, _t.ARRAY, _t.ITEM], Hn = {
  JSON5: "json5",
  JSON: "json4",
  YAML: "yaml"
}, dr = (t, e) => {
  var n, r;
  switch (e) {
    case Hn.YAML:
      return (n = die[t]) !== null && n !== void 0 ? n : t;
    case Hn.JSON5:
      return (r = pie[t]) !== null && r !== void 0 ? r : t;
    default:
      return t;
  }
};
function zP(t, e, n) {
  const r = [];
  for (let i = e; i?.parent; i = i.parent)
    switch (dr(i.parent.name, n)) {
      case _t.PROPERTY: {
        const s = D4(i.parent, _t.PROPERTY_NAME, n);
        if (s) {
          let o = Eh(t, s).replace(/[/~]/g, (l) => l === "~" ? "~0" : "~1");
          r.unshift(o);
        }
        break;
      }
      case _t.ARRAY: {
        if (mie(i, n)) {
          const s = UP(i.parent, i, n);
          r.unshift(`${s}`);
        }
        break;
      }
    }
  return r.length === 0 ? "" : "/" + r.join("/");
}
const jP = (t, e, n = -1, r) => zP(t.doc, Dr(t).resolve(e, n), r), j6 = (t, e) => {
  const n = Dr(t), r = /* @__PURE__ */ new Map();
  return n.iterate({
    enter: (i) => {
      var s, o, l, a, u, c, f, d;
      if ([_t.PROPERTY_NAME, _t.OBJECT].includes(dr(i.name, e))) {
        const p = zP(t.doc, i.node, e), { from: m, to: y } = i.node;
        if (!(!((o = (s = i.node) === null || s === void 0 ? void 0 : s.nextSibling) === null || o === void 0) && o.node))
          return r.set(p, { keyFrom: m, keyTo: y }), !0;
        const b = e === Hn.JSON ? (a = (l = i.node) === null || l === void 0 ? void 0 : l.nextSibling) === null || a === void 0 ? void 0 : a.node : (d = (f = (c = (u = i.node) === null || u === void 0 ? void 0 : u.nextSibling) === null || c === void 0 ? void 0 : c.node) === null || f === void 0 ? void 0 : f.nextSibling) === null || d === void 0 ? void 0 : d.node;
        if (!b)
          return r.set(p, { keyFrom: m, keyTo: y }), !0;
        const { from: v, to: _ } = b;
        return r.set(p, { keyFrom: m, keyTo: y, valueFrom: v, valueTo: _ }), !0;
      }
    }
  }), r;
}, Qw = (t, e, n = -1) => Dr(t).resolveInner(e, n), jy = (t) => t.replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1"), gie = (t) => t.replace(/^"(.*)"$/, "'$1'"), Eh = (t, e, n = !0, r = !0) => {
  const i = e ? t.sliceString(e.from, e.to) : "";
  return n ? r ? jy(i) : i.replace(/(^["'])|(["']$)/g, "") : i;
}, qP = (t, e) => {
  var n, r, i, s;
  return dr(t.name, e) === _t.INVALID && (dr((r = (n = t.prevSibling) === null || n === void 0 ? void 0 : n.name) !== null && r !== void 0 ? r : "", e) === _t.PROPERTY_NAME || dr((s = (i = t.prevSibling) === null || i === void 0 ? void 0 : i.name) !== null && s !== void 0 ? s : "", e) === _t.PROPERTY_COLON);
}, qy = (t, e) => z6.includes(dr(t.name, e)) || qP(t, e), mie = (t, e) => [...z6, ...$P].includes(dr(t.name, e)) || qP(t, e), W1 = (t, e) => {
  var n, r, i, s, o, l;
  return dr(t.name, e) === _t.PROPERTY_NAME || dr(t.name, e) === _t.INVALID && (dr((r = (n = t.prevSibling) === null || n === void 0 ? void 0 : n.name) !== null && r !== void 0 ? r : "", e) === _t.PROPERTY || dr((s = (i = t.prevSibling) === null || i === void 0 ? void 0 : i.name) !== null && s !== void 0 ? s : "", e) === "{") || // TODO: Can we make this work without checking for the mode?
  e === Hn.YAML && dr((l = (o = t.parent) === null || o === void 0 ? void 0 : o.name) !== null && l !== void 0 ? l : "", e) === _t.OBJECT;
}, rm = (t) => {
  const e = [];
  let n = t.firstChild;
  for (; n; )
    n && e.push(n), n = n?.nextSibling;
  return e;
}, yie = (t, e, n) => rm(t).filter((r) => dr(r.name, n) === e), D4 = (t, e, n) => {
  var r;
  return (r = rm(t).find((i) => dr(i.name, n) === e)) !== null && r !== void 0 ? r : null;
}, TD = (t, e) => rm(t).find((n) => qy(n, e)), bie = (t, e) => rm(t).filter((n) => z6.includes(dr(n.name, e)) || $P.includes(dr(n.name, e))), UP = (t, e, n) => bie(t, n).findIndex((r) => r.from === e.from && r.to === e.to), RD = (t, e, n, r = 1 / 0) => {
  let i = t;
  for (; i && r > 0; ) {
    if (dr(i.name, n) === e)
      return i;
    i = i.parent, r--;
  }
  return null;
}, vie = St.define(), Mb = jr.define({
  create() {
  },
  update(t, e) {
    for (const n of e.effects)
      if (n.is(vie))
        return n.value;
    return t;
  }
}), q6 = (t) => t.field(Mb), xie = (t) => [
  Mb.init(() => t)
], wie = {
  // validation errors
  AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",
  AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",
  AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",
  AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",
  ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",
  containsAnyError: "The array at `{{pointer}}` must contain at least one item",
  ContainsArrayError: "The property at `{{pointer}}` must not be an array",
  ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",
  EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",
  ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",
  FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",
  FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",
  FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",
  FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",
  FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",
  FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",
  FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",
  FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",
  FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",
  FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",
  FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",
  FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",
  FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",
  InvalidDataError: "No value may be specified in `{{pointer}}`",
  InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",
  MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",
  MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",
  MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",
  MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`",
  MinItemsOneError: "At least one item is required in `{{pointer}}`",
  MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",
  MinLengthOneError: "A value is required in `{{pointer}}`",
  MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`",
  MissingDependencyError: "The required propery '{{missingProperty}}' in `{{pointer}}` is missing",
  MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",
  MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",
  MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",
  NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",
  NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",
  OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",
  OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",
  PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",
  PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",
  RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",
  SchemaWarning: "Failed retrieving a schema from '{{pointer}}' to key '{{key}}'",
  TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",
  UndefinedValueError: "Value must not be undefined in `{{pointer}}`",
  UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",
  UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",
  ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"
}, _ie = Object.prototype.toString;
function Zt(t) {
  const e = _ie.call(t).match(/\s([^\]]+)\]/).pop().toLowerCase();
  return e === "file" ? "object" : e;
}
const kie = "object", Cie = "array";
function Sie(t, e = {}) {
  return t.replace(/\{\{\w+\}\}/g, (n) => {
    const r = n.replace(/[{}]/g, ""), i = e[r], s = Zt(i);
    return s === kie || s === Cie ? JSON.stringify(i) : i;
  });
}
function Aie(t, e, n = t) {
  var r;
  const i = (r = wie[t]) !== null && r !== void 0 ? r : n;
  return Sie(i, e);
}
function Eie(t) {
  return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function Die(t, e) {
  return {
    type: "error",
    name: t,
    code: Eie(t),
    message: Aie(t, e),
    data: e
  };
}
function Qe(t) {
  return Die.bind(null, t);
}
function pg(t, e = []) {
  for (let n = 0; n < t.length; n += 1) {
    const r = t[n];
    Array.isArray(r) ? pg(r, e) : e.push(r);
  }
  return e;
}
const e0 = {
  DECLARATOR_ONEOF: "oneOfProperty",
  GET_TEMPLATE_RECURSION_LIMIT: 1,
  propertyBlacklist: ["_id"],
  templateDefaultOptions: {
    addOptionalProps: !1,
    removeInvalidData: !1,
    extendDefaults: !0
  }
};
function Tp(t, e, n) {
  const r = { ...e };
  return Object.defineProperty(r, "getOneOfOrigin", {
    enumerable: !1,
    value: () => ({
      index: n,
      schema: t
    })
  }), r;
}
function mi(t) {
  return t?.type === "error";
}
function Oie(t) {
  return t instanceof Promise;
}
function Pb(t) {
  return mi(t) || Oie(t);
}
const { DECLARATOR_ONEOF: Yh } = e0;
function HP(t, e, n = t.rootSchema, r = "#") {
  if (e != null && n[Yh]) {
    const o = [], l = n[Yh], a = e[n[Yh]];
    if (a === void 0)
      return t.errors.missingOneOfPropertyError({
        property: l,
        pointer: r,
        schema: n,
        value: e
      });
    for (let u = 0; u < n.oneOf.length; u += 1) {
      const c = t.resolveRef(n.oneOf[u]), f = t.step(l, c, e, r);
      if (mi(f))
        return f;
      let d = pg(t.validate(a, f, r));
      if (d = d.filter(Pb), d.length > 0)
        o.push(...d);
      else
        return Tp(n, c, u);
    }
    return t.errors.oneOfPropertyError({
      property: l,
      value: a,
      pointer: r,
      schema: n,
      errors: o
    });
  }
  const i = [], s = [];
  for (let o = 0; o < n.oneOf.length; o += 1) {
    const l = t.resolveRef(n.oneOf[o]);
    let a = pg(t.validate(e, l, r));
    a = a.filter(Pb), a.length > 0 ? s.push(...a) : i.push({ index: o, schema: l });
  }
  return i.length === 1 ? Tp(n, i[0].schema, i[0].index) : i.length > 1 ? t.errors.multipleOneOfError({
    value: e,
    pointer: r,
    schema: n,
    matches: i
  }) : t.errors.oneOfError({
    value: JSON.stringify(e),
    pointer: r,
    schema: n,
    oneOf: n.oneOf,
    errors: s
  });
}
function Fie(t, e, n, r) {
  if (n == null || e.properties == null)
    return -1;
  let i = 0;
  const s = Object.keys(e.properties);
  for (let o = 0; o < s.length; o += 1) {
    const l = s[o];
    n[l] != null && t.isValid(n[l], e.properties[l], r) && (i += 1);
  }
  return i;
}
function U6(t, e, n = t.rootSchema, r = "#") {
  if (e != null && n[Yh]) {
    const s = [], o = n[Yh], l = e[n[Yh]];
    if (l === void 0)
      return t.errors.missingOneOfPropertyError({
        property: o,
        pointer: r,
        schema: n,
        value: e
      });
    for (let a = 0; a < n.oneOf.length; a += 1) {
      const u = t.resolveRef(n.oneOf[a]), c = t.step(o, u, e, r);
      if (mi(c))
        return c;
      let f = pg(t.validate(l, c, r));
      if (f = f.filter(Pb), f.length > 0)
        s.push(...f);
      else
        return Tp(n, u, a);
    }
    return t.errors.oneOfPropertyError({
      property: o,
      value: l,
      pointer: r,
      schema: n,
      errors: s
    });
  }
  const i = [];
  for (let s = 0; s < n.oneOf.length; s += 1) {
    const o = t.resolveRef(n.oneOf[s]);
    t.isValid(e, o, r) && i.push({ schema: o, index: s });
  }
  if (i.length === 1)
    return Tp(n, i[0].schema, i[0].index);
  if (Zt(e) === "object") {
    let s, o = -1, l = 0;
    for (let a = 0; a < n.oneOf.length; a += 1) {
      const u = t.resolveRef(n.oneOf[a]), c = Fie(t, u, e);
      l < c && (l = c, s = n.oneOf[a], o = a);
    }
    return s === void 0 ? t.errors.oneOfError({
      value: JSON.stringify(e),
      pointer: r,
      schema: n,
      oneOf: n.oneOf
    }) : Tp(n, s, o);
  }
  return i.length > 1 ? t.errors.multipleOneOfError({ matches: i, pointer: r, schema: n, value: e }) : t.errors.oneOfError({
    value: JSON.stringify(e),
    pointer: r,
    schema: n,
    oneOf: n.oneOf
  });
}
const Tie = (t, e, n, r) => {
  if (Array.isArray(e.oneOf)) {
    const i = t.resolveOneOf(n, e, r);
    if (mi(i))
      return i;
  }
};
var Jw, MD;
function Rie() {
  if (MD) return Jw;
  MD = 1;
  var t = function(_) {
    return e(_) && !n(_);
  };
  function e(v) {
    return !!v && typeof v == "object";
  }
  function n(v) {
    var _ = Object.prototype.toString.call(v);
    return _ === "[object RegExp]" || _ === "[object Date]" || s(v);
  }
  var r = typeof Symbol == "function" && Symbol.for, i = r ? Symbol.for("react.element") : 60103;
  function s(v) {
    return v.$$typeof === i;
  }
  function o(v) {
    return Array.isArray(v) ? [] : {};
  }
  function l(v, _) {
    return _.clone !== !1 && _.isMergeableObject(v) ? y(o(v), v, _) : v;
  }
  function a(v, _, k) {
    return v.concat(_).map(function(S) {
      return l(S, k);
    });
  }
  function u(v, _) {
    if (!_.customMerge)
      return y;
    var k = _.customMerge(v);
    return typeof k == "function" ? k : y;
  }
  function c(v) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(v).filter(function(_) {
      return Object.propertyIsEnumerable.call(v, _);
    }) : [];
  }
  function f(v) {
    return Object.keys(v).concat(c(v));
  }
  function d(v, _) {
    try {
      return _ in v;
    } catch {
      return !1;
    }
  }
  function p(v, _) {
    return d(v, _) && !(Object.hasOwnProperty.call(v, _) && Object.propertyIsEnumerable.call(v, _));
  }
  function m(v, _, k) {
    var S = {};
    return k.isMergeableObject(v) && f(v).forEach(function(C) {
      S[C] = l(v[C], k);
    }), f(_).forEach(function(C) {
      p(v, C) || (d(v, C) && k.isMergeableObject(_[C]) ? S[C] = u(C, k)(v[C], _[C], k) : S[C] = l(_[C], k));
    }), S;
  }
  function y(v, _, k) {
    k = k || {}, k.arrayMerge = k.arrayMerge || a, k.isMergeableObject = k.isMergeableObject || t, k.cloneUnlessOtherwiseSpecified = l;
    var S = Array.isArray(_), C = Array.isArray(v), E = S === C;
    return E ? S ? k.arrayMerge(v, _, k) : m(v, _, k) : l(_, k);
  }
  y.all = function(_, k) {
    if (!Array.isArray(_))
      throw new Error("first argument should be an array");
    return _.reduce(function(S, C) {
      return y(S, C, k);
    }, {});
  };
  var b = y;
  return Jw = b, Jw;
}
var Mie = Rie();
const VP = /* @__PURE__ */ zf(Mie), Pie = (t, e) => e, H6 = (t, e) => VP(t, e, { arrayMerge: Pie }), Iie = (t, e) => {
  const n = t.concat(e);
  return n.filter((r, i) => n.indexOf(r) === i);
}, Nie = (t, e) => VP(t, e, { arrayMerge: Iie });
function Fi(t, e) {
  const n = Zt(t), r = Zt(e);
  if (n !== r)
    return t;
  const i = Nie(t, e);
  return t.getOneOfOrigin ? Object.defineProperty(i, "getOneOfOrigin", {
    enumerable: !1,
    value: t.getOneOfOrigin
  }) : e.getOneOfOrigin && Object.defineProperty(i, "getOneOfOrigin", {
    enumerable: !1,
    value: e.getOneOfOrigin
  }), i;
}
function gg(t, ...e) {
  const n = {};
  return Object.keys(t).forEach((r) => {
    e.includes(r) || (n[r] = t[r]);
  }), t.getOneOfOrigin && Object.defineProperty(n, "getOneOfOrigin", {
    enumerable: !1,
    value: t.getOneOfOrigin
  }), n;
}
var Bie = Function.prototype.toString, Zw = Object.create, Lie = Object.prototype.toString, $ie = (
  /** @class */
  (function() {
    function t() {
      this._keys = [], this._values = [];
    }
    return t.prototype.has = function(e) {
      return !!~this._keys.indexOf(e);
    }, t.prototype.get = function(e) {
      return this._values[this._keys.indexOf(e)];
    }, t.prototype.set = function(e, n) {
      this._keys.push(e), this._values.push(n);
    }, t;
  })()
);
function zie() {
  return new $ie();
}
function jie() {
  return /* @__PURE__ */ new WeakMap();
}
var qie = typeof WeakMap < "u" ? jie : zie;
function V6(t) {
  if (!t)
    return Zw(null);
  var e = t.constructor;
  if (e === Object)
    return t === Object.prototype ? {} : Zw(t);
  if (e && ~Bie.call(e).indexOf("[native code]"))
    try {
      return new e();
    } catch {
    }
  return Zw(t);
}
function Uie(t) {
  var e = "";
  return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.unicode && (e += "u"), t.sticky && (e += "y"), e;
}
function Hie(t) {
  return t.flags;
}
var Vie = /test/g.flags === "g" ? Hie : Uie;
function WP(t) {
  var e = Lie.call(t);
  return e.substring(8, e.length - 1);
}
function Wie(t) {
  return t[Symbol.toStringTag] || WP(t);
}
var Gie = typeof Symbol < "u" ? Wie : WP, Kie = Object.defineProperty, Yie = Object.getOwnPropertyDescriptor, GP = Object.getOwnPropertyNames, W6 = Object.getOwnPropertySymbols, KP = Object.prototype, YP = KP.hasOwnProperty, Xie = KP.propertyIsEnumerable, XP = typeof W6 == "function";
function Qie(t) {
  return GP(t).concat(W6(t));
}
var Jie = XP ? Qie : GP;
function Jv(t, e, n) {
  for (var r = Jie(t), i = 0, s = r.length, o = void 0, l = void 0; i < s; ++i)
    if (o = r[i], !(o === "callee" || o === "caller")) {
      if (l = Yie(t, o), !l) {
        e[o] = n.copier(t[o], n);
        continue;
      }
      !l.get && !l.set && (l.value = n.copier(l.value, n));
      try {
        Kie(e, o, l);
      } catch {
        e[o] = l.value;
      }
    }
  return e;
}
function Zie(t, e) {
  var n = new e.Constructor();
  e.cache.set(t, n);
  for (var r = 0, i = t.length; r < i; ++r)
    n[r] = e.copier(t[r], e);
  return n;
}
function ese(t, e) {
  var n = new e.Constructor();
  return e.cache.set(t, n), Jv(t, n, e);
}
function QP(t, e) {
  return t.slice(0);
}
function tse(t, e) {
  return t.slice(0, t.size, t.type);
}
function nse(t, e) {
  return new e.Constructor(QP(t.buffer));
}
function rse(t, e) {
  return new e.Constructor(t.getTime());
}
function JP(t, e) {
  var n = new e.Constructor();
  return e.cache.set(t, n), t.forEach(function(r, i) {
    n.set(i, e.copier(r, e));
  }), n;
}
function ise(t, e) {
  return Jv(t, JP(t, e), e);
}
function sse(t, e) {
  var n = V6(e.prototype);
  e.cache.set(t, n);
  for (var r in t)
    YP.call(t, r) && (n[r] = e.copier(t[r], e));
  return n;
}
function ose(t, e) {
  var n = V6(e.prototype);
  e.cache.set(t, n);
  for (var r in t)
    YP.call(t, r) && (n[r] = e.copier(t[r], e));
  for (var i = W6(t), s = 0, o = i.length, l = void 0; s < o; ++s)
    l = i[s], Xie.call(t, l) && (n[l] = e.copier(t[l], e));
  return n;
}
var lse = XP ? ose : sse;
function ase(t, e) {
  var n = V6(e.prototype);
  return e.cache.set(t, n), Jv(t, n, e);
}
function e3(t, e) {
  return new e.Constructor(t.valueOf());
}
function use(t, e) {
  var n = new e.Constructor(t.source, Vie(t));
  return n.lastIndex = t.lastIndex, n;
}
function Uy(t, e) {
  return t;
}
function ZP(t, e) {
  var n = new e.Constructor();
  return e.cache.set(t, n), t.forEach(function(r) {
    n.add(e.copier(r, e));
  }), n;
}
function cse(t, e) {
  return Jv(t, ZP(t, e), e);
}
var fse = Array.isArray, G6 = Object.assign, hse = Object.getPrototypeOf || (function(t) {
  return t.__proto__;
}), eI = {
  array: Zie,
  arrayBuffer: QP,
  blob: tse,
  dataView: nse,
  date: rse,
  error: Uy,
  map: JP,
  object: lse,
  regExp: use,
  set: ZP
}, dse = G6({}, eI, {
  array: ese,
  map: ise,
  object: ase,
  set: cse
});
function pse(t) {
  return {
    Arguments: t.object,
    Array: t.array,
    ArrayBuffer: t.arrayBuffer,
    Blob: t.blob,
    Boolean: e3,
    DataView: t.dataView,
    Date: t.date,
    Error: t.error,
    Float32Array: t.arrayBuffer,
    Float64Array: t.arrayBuffer,
    Int8Array: t.arrayBuffer,
    Int16Array: t.arrayBuffer,
    Int32Array: t.arrayBuffer,
    Map: t.map,
    Number: e3,
    Object: t.object,
    Promise: Uy,
    RegExp: t.regExp,
    Set: t.set,
    String: e3,
    WeakMap: Uy,
    WeakSet: Uy,
    Uint8Array: t.arrayBuffer,
    Uint8ClampedArray: t.arrayBuffer,
    Uint16Array: t.arrayBuffer,
    Uint32Array: t.arrayBuffer,
    Uint64Array: t.arrayBuffer
  };
}
function tI(t) {
  var e = G6({}, eI, t), n = pse(e), r = n.Array, i = n.Object;
  function s(o, l) {
    if (l.prototype = l.Constructor = void 0, !o || typeof o != "object")
      return o;
    if (l.cache.has(o))
      return l.cache.get(o);
    if (l.prototype = hse(o), l.Constructor = l.prototype && l.prototype.constructor, !l.Constructor || l.Constructor === Object)
      return i(o, l);
    if (fse(o))
      return r(o, l);
    var a = n[Gie(o)];
    return a ? a(o, l) : typeof o.then == "function" ? o : i(o, l);
  }
  return function(l) {
    return s(l, {
      Constructor: void 0,
      cache: qie(),
      copier: s,
      prototype: void 0
    });
  };
}
function gse(t) {
  return tI(G6({}, dse, t));
}
gse({});
var Ib = tI({});
function Zv(t, e, n) {
  if (e.if != null) {
    if (e.if === !1)
      return e.else;
    if (e.if && (e.then || e.else)) {
      const r = t.validate(n, t.resolveRef(e.if));
      if (r.length === 0 && e.then)
        return t.resolveRef(e.then);
      if (r.length !== 0 && e.else)
        return t.resolveRef(e.else);
    }
  }
}
const mse = (t, e, n, r) => {
  const i = Zv(t, e, n);
  if (i)
    return t.validate(n, i, r);
};
function nI(t, e, n) {
  var r;
  const i = { ...(r = t.resolveRef(e)) !== null && r !== void 0 ? r : {} }, s = Zv(t, i, n);
  return s || gg(i, "if", "then", "else");
}
function rI(t, e, n = t.rootSchema) {
  let r = Ib(n);
  for (let i = 0; i < n.allOf.length; i += 1) {
    const s = nI(t, n.allOf[i], e);
    r = Fi(r, s);
  }
  return delete r.allOf, r;
}
function iI(t, e) {
  const { allOf: n } = e;
  if (!Array.isArray(n) || n.length === 0)
    return;
  let r = {};
  return n.forEach((i) => {
    r = Fi(r, t.resolveRef(i));
  }), r;
}
const yse = (t, e, n, r) => {
  const { allOf: i } = e;
  if (!Array.isArray(i) || i.length === 0)
    return;
  const s = [];
  return e.allOf.forEach((o) => {
    s.push(...t.validate(n, o, r));
  }), s;
};
function sI(t, e) {
  return t == null || t.$ref == null ? t : t.getRoot ? t.getRoot().getRef(t) : e.getRef(t);
}
function bse(t) {
  return t.filter((e, n) => t.indexOf(e) === n);
}
function Vu(t) {
  return Zt(t) === "object";
}
function oI(t, e, n) {
  const { dependencies: r } = e;
  if (!Vu(r) || !Vu(n))
    return;
  let i = !1, s = { required: [] };
  if (Object.keys(r).forEach((o) => {
    var l, a;
    if (n[o] == null && !(!((l = e.required) === null || l === void 0) && l.includes(o) || !((a = s.required) === null || a === void 0) && a.includes(o)))
      return;
    const u = r[o];
    if (Array.isArray(u)) {
      i = !0, s.required.push(...u);
      return;
    }
    if (Vu(u)) {
      i = !0, s = Fi(s, t.resolveRef(u));
      return;
    }
  }), i)
    return s.required = bse(s.required), s;
}
const vse = (t, e, n, r) => {
  if (Zt(e.dependencies) !== "object")
    return;
  const i = [];
  return Object.keys(n).forEach((s) => {
    if (e.dependencies[s] === void 0 || e.dependencies[s] === !0)
      return;
    if (e.dependencies[s] === !1) {
      i.push(t.errors.missingDependencyError({ pointer: r, schema: e, value: n }));
      return;
    }
    let o;
    const l = Zt(e.dependencies[s]);
    if (l === "array")
      o = e.dependencies[s].filter((a) => n[a] === void 0).map((a) => t.errors.missingDependencyError({ missingProperty: a, pointer: r, schema: e, value: n }));
    else if (l === "object")
      o = t.validate(n, e.dependencies[s], r);
    else
      throw new Error(`Invalid dependency definition for ${r}/${s}. Must be string[] or schema`);
    i.push(...o);
  }), i.length > 0 ? i : void 0;
};
function lI(t, e, n) {
  if (!Array.isArray(e.anyOf) || e.anyOf.length === 0)
    return;
  let r;
  return e.anyOf.forEach((i) => {
    i = t.resolveRef(i), t.isValid(n, i) && (r = r ? Fi(r, i) : i);
  }), r;
}
function aI(t, e, n = t.rootSchema, r = "#") {
  const { anyOf: i } = n;
  if (!Array.isArray(i) || i.length === 0)
    return n;
  const s = lI(t, n, e);
  if (s == null)
    return t.errors.anyOfError({ pointer: r, schema: n, value: e, anyOf: JSON.stringify(i) });
  const o = Fi(n, s);
  return gg(o, "anyOf");
}
const xse = (t, e, n, r) => {
  if (!(!Array.isArray(e.anyOf) || e.anyOf.length === 0)) {
    for (let i = 0; i < e.anyOf.length; i += 1)
      if (t.isValid(n, e.anyOf[i]))
        return;
    return t.errors.anyOfError({ pointer: r, schema: e, value: n, anyOf: e.anyOf });
  }
}, PD = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"], wse = ["allOf", "anyOf", "oneOf", "dependencies", "if"];
function _se(t) {
  const e = Object.keys(t);
  return wse.findIndex((n) => e.includes(n)) !== -1;
}
function O4(t, e, n, r) {
  let i, s;
  if (e = t.resolveRef(e), e.oneOf) {
    const c = U6(t, n, e, r);
    mi(c) ? s = c : c && (i = Fi(i ?? {}, c));
  }
  if (Array.isArray(e.allOf)) {
    const c = e.allOf.map((f) => {
      if (_se(f)) {
        let d = O4(t, f, n, r);
        return d ? (d = Fi(f, d), gg(d, ...PD)) : void 0;
      }
      return f;
    });
    if (c.length > 0) {
      const f = iI(t, { allOf: c });
      i = Fi(i ?? {}, f);
    }
  }
  const o = lI(t, e, n);
  o && (i = Fi(i ?? {}, o));
  const l = oI(t, e, n);
  l && (i = Fi(i ?? {}, l));
  const a = Zv(t, e, n);
  if (a && (i = Fi(i ?? {}, a)), i == null)
    return s;
  const u = O4(t, i, n, r);
  return u && (i = Fi(i, u)), gg(i, ...PD);
}
const kse = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
function ID(t, e, n, r) {
  let i = O4(t, e, n, r);
  return i ? (i = Fi(e, i), gg(i, ...kse)) : e;
}
class uI {
  constructor(e, n) {
    this.remotes = {}, this.errors = {}, this.typeKeywords = {}, this.validateKeyword = {}, this.validateType = {}, this.validateFormat = {}, this.config = e, this.typeKeywords = Ib(e.typeKeywords), this.validateKeyword = Object.assign({}, e.validateKeyword), this.validateType = Object.assign({}, e.validateType), this.validateFormat = Object.assign({}, e.validateFormat), this.errors = Object.assign({}, e.errors), this.setSchema(n);
  }
  get rootSchema() {
    return this.__rootSchema;
  }
  set rootSchema(e) {
    e != null && (this.__rootSchema = this.config.compileSchema(this, e));
  }
  /**
   * register a json-schema to be referenced from another json-schema
   * @param url - base-url of json-schema (aka id)
   * @param schema - json-schema root
   */
  addRemoteSchema(e, n) {
    this.config.addRemoteSchema(this, e, n);
  }
  compileSchema(e) {
    var n;
    return this.config.compileSchema(this, e, (n = this.rootSchema) !== null && n !== void 0 ? n : e);
  }
  createSchemaOf(e) {
    return this.config.createSchemaOf(e);
  }
  /**
   * Iterates over data, retrieving its schema
   *
   * @param data - the data to iterate
   * @param callback - will be called with (schema, data, pointer) on each item
   * @param [schema] - the schema matching the data. Defaults to rootSchema
   * @param [pointer] - pointer to current data. Default to rootPointer
   */
  each(e, n, r, i) {
    return this.config.each(this, e, n, r, i);
  }
  eachSchema(e, n = this.rootSchema) {
    return this.config.eachSchema(n, e);
  }
  getChildSchemaSelection(e, n) {
    return this.config.getChildSchemaSelection(this, e, n);
  }
  /**
   * Returns the json-schema of a data-json-pointer.
   *
   * To resolve dynamic schema where the type of json-schema is evaluated by
   * its value, a data object has to be passed in options.
   *
   * Per default this function will return `undefined` for valid properties that
   * do not have a defined schema. Use the option `withSchemaWarning: true` to
   * receive an error with `code: schema-warning` containing the location of its
   * last evaluated json-schema.
   *
   * Notes
   *      - uses draft.step to walk through data and schema
   *
   * @param draft
   * @param pointer - json pointer in data to get the json schema for
   * @param [options.data] - the data object, which includes the json pointers value. This is optional, as
   *    long as no oneOf, anyOf, etc statement is part of the pointers schema
   * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema
   * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition
   * @return resolved json-schema object of requested json-pointer location
   */
  getSchema(e) {
    return this.config.getSchema(this, e);
  }
  /**
   * Create data object matching the given schema
   *
   * @param [data] - optional template data
   * @param [schema] - json schema, defaults to rootSchema
   * @return created template data
   */
  getTemplate(e, n, r = this.config.templateDefaultOptions) {
    return this.config.getTemplate(this, e, n, r);
  }
  isValid(e, n, r) {
    return this.config.isValid(this, e, n, r);
  }
  resolveAnyOf(e, n, r) {
    return this.config.resolveAnyOf(this, e, n, r);
  }
  resolveAllOf(e, n) {
    return this.config.resolveAllOf(this, e, n);
  }
  resolveRef(e) {
    return this.config.resolveRef(e, this.rootSchema);
  }
  resolveOneOf(e, n, r) {
    return this.config.resolveOneOf(this, e, n, r);
  }
  setSchema(e) {
    this.rootSchema = e;
  }
  /**
   * Returns the json-schema of the given object property or array item.
   * e.g. it steps by one key into the data
   *
   *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and
   *  returns the correct schema.
   *
   * @param  key       - property-name or array-index
   * @param  schema    - json schema of current data
   * @param  data      - parent of key
   * @param  [pointer] - pointer to schema and data (parent of key)
   * @return Schema or Error if failed resolving key
   */
  step(e, n, r, i) {
    return this.config.step(this, e, n, r, i);
  }
  /**
   * Validate data by a json schema
   *
   * @param value - value to validate
   * @param [schema] - json schema, defaults to rootSchema
   * @param [pointer] - json pointer pointing to value (used for error-messages only)
   * @return list of errors or empty
   */
  validate(e, n, r) {
    return this.config.validate(this, e, n, r);
  }
}
function cI(t, e, n) {
  n.id = n.id || e, t.remotes[e] = t.compileSchema(n);
}
var Hy = { exports: {} }, Cse = Hy.exports, ND;
function Sse() {
  return ND || (ND = 1, (function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(typeof self < "u" ? self : Cse, (() => (() => {
      var n = { d: (M, L) => {
        for (var N in L) n.o(L, N) && !n.o(M, N) && Object.defineProperty(M, N, { enumerable: !0, get: L[N] });
      }, o: (M, L) => Object.prototype.hasOwnProperty.call(M, L), r: (M) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(M, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(M, "__esModule", { value: !0 });
      } }, r = {};
      function i(M) {
        return M === "#" || M === "" || Array.isArray(M) && M.length === 0 || !1;
      }
      n.r(r), n.d(r, { default: () => B, get: () => d, isRoot: () => i, join: () => $, remove: () => C, removeUndefinedItems: () => S, set: () => v, split: () => f, splitLast: () => P });
      const s = /~1/g, o = /~0/g, l = /\/+/g, a = /(^[#/]*|\/+$)/g;
      function u(M) {
        return M.replace(s, "/").replace(o, "~");
      }
      function c(M) {
        return u(decodeURIComponent(M));
      }
      function f(M) {
        if (M == null || typeof M != "string" || i(M)) return Array.isArray(M) ? M : [];
        const L = M.indexOf("#") >= 0 ? c : u, N = (M = (M = M.replace(l, "/")).replace(a, "")).split("/");
        for (let j = 0, U = N.length; j < U; j += 1) N[j] = L(N[j]);
        return N;
      }
      function d(M, L, N = void 0) {
        if (L == null || M == null) return N;
        if (i(L)) return M;
        const j = p(M, f(L));
        return j === void 0 ? N : j;
      }
      function p(M, L) {
        const N = L.shift();
        if (M !== void 0) return N !== void 0 ? p(M[N], L) : M;
      }
      const m = /^\[.*\]$/, y = /^\[(.+)\]$/;
      function b(M, L) {
        return M === "__proto__" || M == "constructor" && L.length > 0 && L[0] == "prototype";
      }
      function v(M, L, N) {
        if (L == null) return M;
        const j = f(L);
        if (j.length === 0) return M;
        M == null && (M = m.test(j[0]) ? [] : {});
        let U, H, G = M;
        for (; j.length > 1; ) U = j.shift(), H = m.test(j[0]), b(U, j) || (G = k(G, U, H));
        return U = j.pop(), _(G, U, N), M;
      }
      function _(M, L, N) {
        let j;
        const U = L.match(y);
        L === "[]" && Array.isArray(M) ? M.push(N) : U ? (j = U.pop(), M[j] = N) : M[L] = N;
      }
      function k(M, L, N) {
        if (M[L] != null) return M[L];
        const j = N ? [] : {};
        return _(M, L, j), j;
      }
      function S(M) {
        let L = 0, N = 0;
        for (; L + N < M.length; ) M[L + N] === void 0 && (N += 1), M[L] = M[L + N], L += 1;
        return M.length = M.length - N, M;
      }
      function C(M, L, N) {
        const j = f(L), U = j.pop(), H = d(M, j);
        return H && delete H[U], Array.isArray(H) && N !== !0 && S(H), M;
      }
      const E = /\/+/g, A = /~/g, O = /\//g;
      function T(M, L) {
        if (M.length === 0) return L ? "#" : "";
        for (let N = 0, j = M.length; N < j; N += 1) M[N] = M[N].replace(A, "~0").replace(O, "~1"), L && (M[N] = encodeURIComponent(M[N]));
        return ((L ? "#/" : "/") + M.join("/")).replace(E, "/");
      }
      function $(M, ...L) {
        const N = [];
        if (Array.isArray(M)) return T(M, arguments[1] === !0);
        const j = arguments[arguments.length - 1], U = typeof j == "boolean" ? j : M && M[0] === "#";
        for (let G = 0, re = arguments.length; G < re; G += 1) N.push.apply(N, f(arguments[G]));
        const H = [];
        for (let G = 0, re = N.length; G < re; G += 1) if (N[G] === "..") {
          if (H.length === 0) return U ? "#" : "";
          H.pop();
        } else H.push(N[G]);
        return T(H, U);
      }
      function P(M) {
        const L = f(M);
        if (L.length === 0) return typeof M == "string" && M[0] === "#" ? ["#", L[0]] : ["", void 0];
        if (L.length === 1) return M[0] === "#" ? ["#", L[0]] : ["", L[0]];
        const N = L.pop();
        return [$(L, M[0] === "#"), N];
      }
      const B = { get: d, set: v, remove: C, join: $, split: f, splitLast: P, isRoot: i, removeUndefinedItems: S };
      return r;
    })()));
  })(Hy)), Hy.exports;
}
var Hc = Sse();
const mg = /* @__PURE__ */ zf(Hc);
var G1 = {}, Hi = {}, Q0 = {}, BD;
function Ase() {
  if (BD) return Q0;
  BD = 1, Object.defineProperty(Q0, "__esModule", { value: !0 }), Q0.TokenError = void 0;
  let t = class extends Error {
    constructor(n, r) {
      if (super(n), this.message = n, this.token = r, r && r.errors)
        r.errors.push(this);
      else
        throw this;
    }
    inspect() {
      return "SyntaxError: " + this.message;
    }
  };
  return Q0.TokenError = t, Q0;
}
var LD;
function Ese() {
  if (LD) return Hi;
  LD = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.Parser = Hi.findRuleByName = Hi.parseRuleName = Hi.escapeRegExp = Hi.readToken = void 0;
  const t = /^[A-Z0-9_]+$/, e = /(\?|\+|\*)$/, n = /^(@|&|!)/, r = "WS", i = Ase();
  function s(y, b) {
    let v = b.exec(y);
    return v && v.index == 0 ? v[0].length == 0 && b.source.length > 0 ? null : {
      type: null,
      text: v[0],
      rest: y.substr(v[0].length),
      start: 0,
      end: v[0].length - 1,
      fullText: v[0],
      errors: [],
      children: [],
      parent: null
    } : null;
  }
  Hi.readToken = s;
  function o(y) {
    return y.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  Hi.escapeRegExp = o;
  function l(y) {
    y.rest = "", y.children && y.children.forEach((b) => l(b));
  }
  function a(y, b) {
    y.start += b, y.end += b, y.children && y.children.forEach((v) => a(v, y.start));
  }
  function u(y, b) {
    b.errors && b.errors.length && b.errors.forEach((v) => y.push(v)), b.children && b.children.forEach((v) => u(y, v));
  }
  function c(y) {
    let b = e.exec(y), v = n.exec(y), _ = b && b[0] || "", k = v && v[0] || "", S = {
      raw: y,
      name: y.replace(e, "").replace(n, ""),
      isOptional: _ == "?" || _ == "*",
      allowRepetition: _ == "+" || _ == "*",
      atLeastOne: _ == "+",
      lookupPositive: k == "&",
      lookupNegative: k == "!",
      pinned: k == "@",
      lookup: !1,
      isLiteral: !1
    };
    return S.isLiteral = S.name[0] == "'" || S.name[0] == '"', S.lookup = S.lookupNegative || S.lookupPositive, S;
  }
  Hi.parseRuleName = c;
  function f(y, b) {
    let v = c(y);
    return b.cachedRules[v.name] || null;
  }
  Hi.findRuleByName = f;
  function d(y, b) {
    if (y.children) {
      let v = y.children.filter((_) => _.type && b.test(_.type));
      for (let _ = 0; _ < v.length; _++) {
        let k = y.children.indexOf(v[_]);
        k != -1 && y.children.splice(k, 1);
      }
      y.children.forEach((_) => d(_, b));
    }
  }
  const p = ["EOF"];
  class m {
    constructor(b, v) {
      this.grammarRules = b, this.options = v, this.cachedRules = {}, this.debug = v ? v.debug === !0 : !1;
      let _ = [], k = [];
      if (b.forEach((S) => {
        let C = c(S.name);
        if (C.name in this.cachedRules) {
          _.push("Duplicated rule " + C.name);
          return;
        } else
          this.cachedRules[C.name] = S;
        if (!S.bnf || !S.bnf.length) {
          let E = "Missing rule content, rule: " + S.name;
          _.indexOf(E) == -1 && _.push(E);
        } else
          S.bnf.forEach((E) => {
            if (typeof E[0] == "string" && c(E[0]).name == S.name) {
              let O = "Left recursion is not allowed, rule: " + S.name;
              _.indexOf(O) == -1 && _.push(O);
            }
            E.forEach((A) => {
              if (typeof A == "string") {
                let O = c(A);
                !O.isLiteral && k.indexOf(O.name) == -1 && p.indexOf(O.name) == -1 && k.push(O.name);
              }
            });
          });
        r == S.name && (S.implicitWs = !1), S.implicitWs && k.indexOf(r) == -1 && k.push(r), S.recover && k.indexOf(S.recover) == -1 && k.push(S.recover);
      }), k.forEach((S) => {
        S in this.cachedRules || _.push("Missing rule " + S);
      }), _.length)
        throw new Error(_.join(`
`));
    }
    getAST(b, v) {
      v || (v = this.grammarRules.filter((k) => !k.fragment && k.name.indexOf("%") != 0)[0].name);
      let _ = this.parse(b, v);
      if (_) {
        u(_.errors, _), a(_, 0), d(_, /^%/), (!this.options || !this.options.keepUpperRules) && d(_, t);
        let k = _.rest;
        k && new i.TokenError(`Unexpected end of input: 
` + k, _), l(_), _.rest = k;
      }
      return _;
    }
    emitSource() {
      return "CANNOT EMIT SOURCE FROM BASE Parser";
    }
    parse(b, v, _ = 0) {
      let k = null, S = c(v), C, E = this.debug && /*!isLiteral &*/
      !t.test(S.name);
      E && console.log(new Array(_).join("â”‚  ") + "Trying to get " + v + " from " + JSON.stringify(b.split(`
`)[0]));
      let A = S.name, O = f(S.name, this);
      if (S.name == "EOF") {
        if (b.length)
          return null;
        if (b.length == 0)
          return {
            type: "EOF",
            text: "",
            rest: "",
            start: 0,
            end: 0,
            fullText: "",
            errors: [],
            children: [],
            parent: null
          };
      }
      try {
        if (!O && S.isLiteral) {
          let T = S.name.trim();
          if (T.startsWith('"') ? T = JSON.parse(T) : T.startsWith("'") && (T = T.replace(/^'(.+)'$/, "$1").replace(/\\'/g, "'")), T === "")
            return {
              type: "%%EMPTY%%",
              text: "",
              rest: b,
              start: 0,
              end: 0,
              fullText: "",
              errors: [],
              children: [],
              parent: null
            };
          C = new RegExp(o(T)), A = null;
        }
      } catch (T) {
        return T instanceof ReferenceError && console.error(T), null;
      }
      if (C) {
        let T = s(b, C);
        if (T)
          return T.type = A, T;
      } else {
        let T = O.bnf;
        T instanceof Array && T.forEach(($) => {
          if (k)
            return;
          let P = null, B = {
            type: S.name,
            text: "",
            children: [],
            end: 0,
            errors: [],
            fullText: "",
            parent: null,
            start: 0,
            rest: b
          };
          O.fragment && (B.fragment = !0);
          let M = b, L = 0, N = $.length > 0, j = !1;
          for (let U = 0; U < $.length; U++)
            if (typeof $[U] == "string") {
              let H = c($[U]);
              N = N && H.isOptional;
              let G, re = !1;
              do {
                if (G = null, O.implicitWs && (G = this.parse(M, H.name, _ + 1), !G)) {
                  let se;
                  do
                    if (se = this.parse(M, r, _ + 1), se)
                      B.text = B.text + se.text, B.end = B.text.length, se.parent = B, B.children.push(se), M = M.substr(se.text.length), L += se.text.length;
                    else
                      break;
                  while (se && se.text.length);
                }
                if (G = G || this.parse(M, H.name, _ + 1), H.lookupNegative) {
                  if (G)
                    return;
                  break;
                }
                if (H.lookupPositive && !G)
                  return;
                if (!G && (H.isOptional || H.atLeastOne && re))
                  break;
                if (G && O.pinned == U + 1 && (P = G, E && console.log(new Array(_ + 1).join("â”‚  ") + "â””â”€ " + G.type + " PINNED")), G || (G = this.parseRecovery(O, M, _ + 1)), !G)
                  if (P)
                    k = B, G = {
                      type: "SyntaxError",
                      text: M,
                      children: [],
                      end: M.length,
                      errors: [],
                      fullText: "",
                      parent: null,
                      start: 0,
                      rest: ""
                    }, M.length ? new i.TokenError(`Unexpected end of input. Expecting ${H.name} Got: ${M}`, G) : new i.TokenError(`Unexpected end of input. Missing ${H.name}`, G), E && console.log(new Array(_ + 1).join("â”‚  ") + "â””â”€ " + G.type + " " + JSON.stringify(G.text));
                  else
                    return;
                if (re = !0, j = !0, G.type == "%%EMPTY%%")
                  break;
                G.start += L, G.end += L, !H.lookupPositive && G.type && (G.fragment ? G.children && G.children.forEach((se) => {
                  se.start += L, se.end += L, se.parent = B, B.children.push(se);
                }) : (G.parent = B, B.children.push(G))), H.lookup && (G.lookup = !0), E && console.log(new Array(_ + 1).join("â”‚  ") + "â””â”€ " + G.type + " " + JSON.stringify(G.text)), !H.lookup && !G.lookup && (B.text = B.text + G.text, B.end = B.text.length, M = M.substr(G.text.length), L += G.text.length), B.rest = M;
              } while (G && H.allowRepetition && M.length && !G.lookup);
            } else {
              let H = s(M, $[U]);
              if (!H)
                return;
              E && console.log(new Array(_ + 1).join("â”‚  ") + "â””> " + JSON.stringify(H.text) + $[U].source), j = !0, H.start += L, H.end += L, B.text = B.text + H.text, B.end = B.text.length, M = M.substr(H.text.length), L += H.text.length, B.rest = M;
            }
          j && (k = B, E && console.log(new Array(_).join("â”‚  ") + "â”œ<â”€â”´< PUSHING " + k.type + " " + JSON.stringify(k.text)));
        }), k && O.simplifyWhenOneChildren && k.children.length == 1 && (k = k.children[0]);
      }
      return k || E && console.log(v + " NOT RESOLVED FROM " + b), k;
    }
    parseRecovery(b, v, _) {
      if (b.recover && v.length) {
        let k = this.debug;
        k && console.log(new Array(_ + 1).join("â”‚  ") + "Trying to recover until token " + b.recover + " from " + JSON.stringify(v.split(`
`)[0] + v.split(`
`)[1]));
        let S = {
          type: "SyntaxError",
          text: "",
          children: [],
          end: 0,
          errors: [],
          fullText: "",
          parent: null,
          start: 0,
          rest: ""
        }, C;
        do
          if (C = this.parse(v, b.recover, _ + 1), C) {
            new i.TokenError('Unexpected input: "' + S.text + `" Expecting: ${b.name}`, S);
            break;
          } else
            S.text = S.text + v[0], S.end = S.text.length, v = v.substr(1);
        while (!C && v.length > 0);
        if (S.text.length > 0 && C)
          return k && console.log(new Array(_ + 1).join("â”‚  ") + "Recovered text: " + JSON.stringify(S.text)), S;
      }
      return null;
    }
  }
  return Hi.Parser = m, Hi.default = m, Hi;
}
var $D;
function Dse() {
  if ($D) return G1;
  $D = 1, Object.defineProperty(G1, "__esModule", { value: !0 });
  const t = Ese();
  var e;
  return (function(n) {
    n.RULES = [
      {
        name: "Grammar",
        bnf: [["RULE_S*", "%Atomic*", "EOF"]]
      },
      {
        name: "%Atomic",
        bnf: [["Production", "RULE_S*"]],
        fragment: !0
      },
      {
        name: "Production",
        bnf: [["NCName", "RULE_S*", '"::="', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", "RULE_EOL+", "RULE_S*"]]
      },
      {
        name: "NCName",
        bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]
      },
      {
        name: "Choice",
        bnf: [["SequenceOrDifference", "%_Choice_1*"]],
        fragment: !0
      },
      {
        name: "%_Choice_1",
        bnf: [["RULE_WHITESPACE*", '"|"', "RULE_WHITESPACE*", "SequenceOrDifference"]],
        fragment: !0
      },
      {
        name: "SequenceOrDifference",
        bnf: [["Item", "RULE_WHITESPACE*", "%_Item_1?"]]
      },
      {
        name: "%_Item_1",
        bnf: [["Minus", "Item"], ["Item*"]],
        fragment: !0
      },
      {
        name: "Minus",
        bnf: [['"-"']]
      },
      {
        name: "Item",
        bnf: [["RULE_WHITESPACE*", "%Primary", "PrimaryDecoration?"]],
        fragment: !0
      },
      {
        name: "PrimaryDecoration",
        bnf: [['"?"'], ['"*"'], ['"+"']]
      },
      {
        name: "DecorationName",
        bnf: [['"ebnf://"', /[^\x5D#]+/]]
      },
      {
        name: "%Primary",
        bnf: [["NCName"], ["StringLiteral"], ["CharCode"], ["CharClass"], ["SubItem"]],
        fragment: !0
      },
      {
        name: "SubItem",
        bnf: [['"("', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", '")"']]
      },
      {
        name: "StringLiteral",
        bnf: [[`'"'`, /[^"]*/, `'"'`], [`"'"`, /[^']*/, `"'"`]],
        pinned: 1
      },
      {
        name: "CharCode",
        bnf: [['"#x"', /[0-9a-zA-Z]+/]]
      },
      {
        name: "CharClass",
        bnf: [["'['", "'^'?", "%RULE_CharClass_1+", '"]"']]
      },
      {
        name: "%RULE_CharClass_1",
        bnf: [["CharCodeRange"], ["CharRange"], ["CharCode"], ["RULE_Char"]],
        fragment: !0
      },
      {
        name: "RULE_Char",
        bnf: [[/\x09/], [/\x0A/], [/\x0D/], [/[\x20-\x5c]/], [/[\x5e-\uD7FF]/], [/[\uE000-\uFFFD]/]]
      },
      {
        name: "CharRange",
        bnf: [["RULE_Char", '"-"', "RULE_Char"]]
      },
      {
        name: "CharCodeRange",
        bnf: [["CharCode", '"-"', "CharCode"]]
      },
      {
        name: "RULE_WHITESPACE",
        bnf: [["%RULE_WHITESPACE_CHAR*"], ["Comment", "RULE_WHITESPACE*"]]
      },
      {
        name: "RULE_S",
        bnf: [["RULE_WHITESPACE", "RULE_S*"], ["RULE_EOL", "RULE_S*"]]
      },
      {
        name: "%RULE_WHITESPACE_CHAR",
        bnf: [[/\x09/], [/\x20/]],
        fragment: !0
      },
      {
        name: "Comment",
        bnf: [['"/*"', "%RULE_Comment_Body*", '"*/"']]
      },
      {
        name: "%RULE_Comment_Body",
        bnf: [['!"*/"', /[^*]/]],
        fragment: !0
      },
      {
        name: "RULE_EOL",
        bnf: [[/\x0D/, /\x0A/], [/\x0A/], [/\x0D/]]
      },
      {
        name: "Link",
        bnf: [["'['", "Url", "']'"]]
      },
      {
        name: "Url",
        bnf: [[/[^\x5D:/?#]/, '"://"', /[^\x5D#]+/, "%Url1?"]]
      },
      {
        name: "%Url1",
        bnf: [['"#"', "NCName"]],
        fragment: !0
      }
    ], n.defaultParser = new t.Parser(n.RULES, { debug: !1 });
    const r = /^(!|&)/, i = /(\?|\+|\*)$/, s = /^%/;
    function o(k, S) {
      if (typeof k == "string") {
        if (r.test(k))
          return "";
        if (s.test(k)) {
          let E = i.exec(k), A = E ? E[0] + " " : "";
          return l(k, S) ? u(k, S) + A : "(" + u(k, S) + ")" + A;
        }
        return k;
      } else
        return k.source.replace(/\\(?:x|u)([a-zA-Z0-9]+)/g, "#x$1").replace(/\[\\(?:x|u)([a-zA-Z0-9]+)-\\(?:x|u)([a-zA-Z0-9]+)\]/g, "[#x$1-#x$2]");
    }
    function l(k, S) {
      let C = t.findRuleByName(k, S);
      return C && C.bnf.length == 1 && C.bnf[0].length == 1 && (C.bnf[0][0] instanceof RegExp || C.bnf[0][0][0] == '"' || C.bnf[0][0][0] == "'");
    }
    function a(k, S) {
      return k.map((C) => o(C, S)).join(" ");
    }
    function u(k, S) {
      let C = t.findRuleByName(k, S);
      return C ? C.bnf.map((E) => a(E, S)).join(" | ") : "RULE_NOT_FOUND {" + k + "}";
    }
    function c(k) {
      let S = [];
      return k.grammarRules.forEach((C) => {
        if (!/^%/.test(C.name)) {
          let E = C.recover ? " /* { recoverUntil=" + C.recover + " } */" : "";
          S.push(C.name + " ::= " + u(C.name, k) + E);
        }
      }), S.join(`
`);
    }
    n.emit = c;
    let f = 0;
    function d(k, S) {
      throw console.log("reberia restar " + S + " a " + k), new Error("Difference not supported yet");
    }
    function p(k) {
      return new RegExp(k.replace(/#x([a-zA-Z0-9]{4})/g, "\\u$1").replace(/#x([a-zA-Z0-9]{3})/g, "\\u0$1").replace(/#x([a-zA-Z0-9]{2})/g, "\\x$1").replace(/#x([a-zA-Z0-9]{1})/g, "\\x0$1"));
    }
    function m(k, S, C) {
      let E = null, A = [];
      return S.children.forEach((O, T) => {
        O.type == "Minus" && d(E, O);
        let $ = S.children[T + 1];
        $ = $ && $.type == "PrimaryDecoration" && $.text || "";
        let P = "";
        switch (O.type) {
          case "SubItem":
            let B = "%" + (C + f++);
            y(k, O, B), A.push(P + B + $);
            break;
          case "NCName":
          case "StringLiteral":
            A.push(P + O.text + $);
            break;
          case "CharCode":
          case "CharClass":
            if ($ || P) {
              let M = {
                name: "%" + (C + f++),
                bnf: [[p(O.text)]]
              };
              k.push(M), A.push(P + M.name + $);
            } else
              A.push(p(O.text));
            break;
          case "PrimaryDecoration":
            break;
          default:
            throw new Error(" HOW SHOULD I PARSE THIS? " + O.type + " -> " + JSON.stringify(O.text));
        }
        E = O;
      }), A;
    }
    function y(k, S, C) {
      let E = S.children.filter((T) => T.type == "SequenceOrDifference").map((T) => m(k, T, C)), A = {
        name: C,
        bnf: E
      }, O = null;
      E.forEach((T) => {
        O = O || T.recover, delete T.recover;
      }), C.indexOf("%") == 0 && (A.fragment = !0), O && (A.recover = O), k.push(A);
    }
    function b(k, S = n.defaultParser) {
      let C = S.getAST(k);
      if (!C)
        throw new Error("Could not parse " + k);
      if (C.errors && C.errors.length)
        throw C.errors[0];
      let E = [];
      return C.children.filter((A) => A.type == "Production").map((A) => {
        let O = A.children.filter((T) => T.type == "NCName")[0].text;
        y(E, A, O);
      }), E;
    }
    n.getRules = b;
    function v(k, S = n.defaultParser) {
      return b(k.join(""), S);
    }
    n.Transform = v;
    class _ extends t.Parser {
      constructor(S, C) {
        const E = C && C.debugRulesParser === !0 ? new t.Parser(n.RULES, { debug: !0 }) : n.defaultParser;
        super(b(S, E), C);
      }
      emitSource() {
        return c(this);
      }
    }
    n.Parser = _;
  })(e || (e = {})), G1.default = e, G1;
}
var Ose = Dse();
const Fse = /* @__PURE__ */ zf(Ose), Tse = "[^?/{}*,()#]+", Rse = `
root ::= ("#" recursion | recursion | (query | pattern) recursion* | "#" SEP? | SEP)
recursion ::= (SEP query | pattern)*

query ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?
property ::= ${Tse}
regex ::= "{" [^}]+ "}"
SEP ::= "/"
all ::= "**"
any ::= "*"

typecheck ::= "?:" ("value" | "boolean" | "string" | "number" | "object" | "array")
lookahead ::= "?" expression ((andExpr | orExpr) expression)*
andExpr ::= S? "&&" S?
orExpr ::= S? "||" S?

expression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*
exprProperty ::= [a-zA-Z0-9-_ $]+
escaped ::= [^"]+
is ::= ":"
isnot ::= ":!"
ESC ::= '"'

pattern ::= S? "(" (SEP query | pattern (orPattern? pattern)*)* ")" quantifier? S? lookahead?
quantifier ::= "+" | "*" | [0-9]+
orPattern ::= S? "," S?

S ::= [ ]*
`, Mse = new Fse.Parser(Rse), Pse = (t) => Mse.getAST(t), Yi = 0, Ed = 3, Nb = (t, e) => `${t}/${e}`, fI = Object.prototype.toString, Ise = /Object|Array/, F4 = (t) => Ise.test(fI.call(t)), Nse = (t) => fI.call(t).match(/\s([^\]]+)\]/).pop().toLowerCase();
function hI(t) {
  return new RegExp(t.text.replace(/(^{|}$)/g, ""));
}
function Bse(t, e) {
  Array.isArray(t) ? t.forEach(e) : Object.prototype.toString.call(t) === "[object Object]" && Object.keys(t).forEach(function(n) {
    e(t[n], n, t);
  });
}
function zD(t) {
  return Array.isArray(t) ? t.map(function(e, n) {
    return `${n}`;
  }) : Object.prototype.toString.call(t) === "[object Object]" ? Object.keys(t) : [];
}
const Wu = {
  mem: [],
  get(t, e) {
    const n = t[Yi][e];
    if (!Wu.mem.includes(n))
      return F4(n) && Wu.mem.push(n), [n, e, t[Yi], Nb(t[Ed], e)];
  },
  reset() {
    Wu.mem.length = 0;
  }
}, T4 = {
  any(t, e) {
    const n = e[Yi];
    return zD(n).map((r) => [
      n[r],
      r,
      n,
      Nb(e[Ed], r)
    ]);
  },
  all(t, e) {
    const n = [e];
    return Bse(e[Yi], (r, i) => {
      const s = Wu.get(e, i);
      s && n.push(...T4.all(t, s));
    }), n;
  },
  regex(t, e) {
    const n = hI(t), r = e[Yi];
    return zD(r).filter((i) => n.test(i)).map((i) => [
      r[i],
      i,
      r,
      Nb(e[Ed], i)
    ]);
  }
}, Bb = {
  // alias to property (but escaped)
  escaped: (t, e) => Bb.property(t, e),
  property: (t, e) => {
    const n = t.text;
    if (e[Yi] && e[Yi][n] !== void 0)
      return [
        e[Yi][n],
        n,
        e[Yi],
        Nb(e[Ed], n)
      ];
  },
  typecheck: (t, e) => {
    const n = t.text.replace(/^\?:/, "");
    if (n === "value")
      return F4(e[Yi]) ? void 0 : e;
    if (Nse(e[Yi]) === n)
      return e;
  },
  lookahead: (t, e) => {
    let n = !0, r = !1;
    return t.children.forEach((i) => {
      if (i.type === "expression") {
        const s = Bb.expression(i, e) !== void 0;
        n = r === !0 ? n || s : n && s;
      } else
        r = i.type === "orExpr";
    }), n ? e : void 0;
  },
  expression: (t, e) => {
    const n = t.children[0].text, r = t.children[1], i = t.children[2], s = e[Yi];
    if (F4(s) !== !1)
      return Lse(s[n], r, i) ? e : void 0;
  }
};
function Lse(t, e, n) {
  if (e === void 0)
    return t !== void 0;
  let r;
  const i = `${t}`;
  return n.type === "regex" ? r = hI(n).test(i) : r = i === n.text, e.type === "isnot" && (r = r === !1 && t !== void 0), r;
}
function $se(t, e, n, r) {
  const i = [];
  for (let s = 0, o = e.length; s < o; s += 1)
    i.push(...t(n, e[s], n, r));
  return i;
}
function zse(t, e, n, r) {
  const i = [];
  for (let s = 0, o = e.length; s < o; s += 1) {
    const l = t(n, e[s], r);
    l && i.push(l);
  }
  return i;
}
function jse(t, e, n) {
  let r = t;
  return e.children.forEach((i) => {
    if (T4[i.type])
      r = $se(T4[i.type], r, i, n);
    else if (Bb[i.type])
      r = zse(Bb[i.type], r, i, n);
    else
      throw new Error(`Unknown filter ${i.type}`);
  }), r;
}
function qse(t, e, n) {
  const r = [];
  let i = t;
  return e.children.forEach((s) => {
    if (s.type === "orPattern") {
      r.push(...i), i = t;
      return;
    }
    i = K6(i, s, n);
  }), r.push(...i), r;
}
function Use(t) {
  if (t == null)
    return 1;
  if (t === "*" || t === "+")
    return 1 / 0;
  const e = parseInt(t);
  return isNaN(e) ? 1 : e;
}
function Hse(t, e, n) {
  const r = [], i = e.children.find((a) => a.type === "quantifier"), s = Use(i && i.text);
  let o = t;
  i && i.text === "*" && r.push(...o);
  let l = 0;
  for (; o.length > 0 && l < s; )
    o = qse(o, e, n), r.push(...o), l += 1;
  return r;
}
function Vse(t, e, n) {
  let r = t;
  return e.children.forEach((i) => r = K6(r, i, n)), r;
}
function K6(t, e, n) {
  let r;
  return e.type === "query" ? r = jse(t, e, n) : e.type === "pattern" ? r = Hse(t, e, n) : r = Vse(t, e, n), Wu.reset(), Wu.mem.push(t), r;
}
function Wse(t, e) {
  return Wu.reset(), Wu.mem.push(t), K6([[t, null, null, "#"]], e);
}
const jD = {
  value: (t) => t.map((e) => e[Yi]),
  pointer: (t) => t.map((e) => e[Ed]),
  all: (t) => t,
  map: (t) => {
    const e = {};
    return t.forEach((n) => e[n[Ed]] = n[Yi]), e;
  }
};
var Cf;
(function(t) {
  t.POINTER = "pointer", t.VALUE = "value", t.ALL = "all", t.MAP = "map";
})(Cf || (Cf = {}));
im.POINTER = Cf.POINTER;
im.VALUE = Cf.VALUE;
im.ALL = Cf.ALL;
im.MAP = Cf.MAP;
function im(t, e, n = Cf.VALUE) {
  if (e == null)
    return [];
  e = e.replace(/(\/$)/g, ""), e === "" && (e = "#");
  const r = Pse(e);
  if (r == null)
    throw new Error(`empty ast for '${e}'`);
  if (r.rest !== "")
    throw new Error(`Failed parsing queryString from: '${r.rest}'`);
  const i = Wse(t, r);
  return typeof n == "function" ? i.map((s) => n(...s)) : jD[n] ? jD[n](i) : i;
}
var Lb;
(function(t) {
  t.REPLACE_ITEMS = "replace", t.INSERT_ITEMS = "insert";
})(Lb || (Lb = {}));
Lb.REPLACE_ITEMS;
Lb.INSERT_ITEMS;
const Ia = {
  $ref: {
    type: !1
  },
  allOf: {
    type: !1,
    definitions: ["allOf/*"]
  },
  anyOf: {
    type: !1,
    definitions: ["anyOf/*"]
  },
  array: {
    type: !0,
    // ignore additionalItems:TypeDef, when items:TypeDef
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "items",
      "items/*",
      "additionalItems"
    ],
    validationKeywords: ["minItems", "maxItems", "uniqueItems"],
    keywords: ["items", "additionalItems", "minItems", "maxItems", "uniqueItems"]
  },
  boolean: {
    type: !0
  },
  enum: {
    type: !1
  },
  integer: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  not: {
    type: !1,
    definitions: ["not"]
  },
  number: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  null: {
    type: !0
  },
  object: {
    type: !0,
    // patternProperties also validate properties
    // dependencies:(string, TypeDef) extend current TypeDef
    // additional Properties validate only remaining properties (after properties & pattern)
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "properties/*",
      "additionalProperties",
      "patternProperties/*",
      "dependencies/*"
    ],
    validationKeywords: ["minProperties", "maxProperties", "required"],
    keywords: [
      "properties",
      "additionalProperties",
      "patternProperties",
      "dependencies",
      "minProperties",
      "maxProperties",
      "required"
    ]
  },
  oneOf: {
    type: !1,
    definitions: ["oneOf/*"]
  },
  string: {
    type: !0,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minLength", "maxLength", "pattern"]
  }
}, Gse = Object.keys(Ia).filter((t) => Ia[t].type === !1), qD = Object.prototype.hasOwnProperty;
function UD(t) {
  if (Vu(t) === !1)
    return;
  if (t.enum)
    return "enum";
  const e = t.type;
  if (Array.isArray(e) || Ia[e])
    return e;
  const n = Gse.filter((r) => t[r]);
  if (n.length === 1)
    return n[0];
  if (n.length === 0) {
    for (let r = 0, i = Ia.object.keywords.length; r < i; r += 1) {
      const s = Ia.object.keywords[r];
      if (qD.call(t, s))
        return "object";
    }
    for (let r = 0, i = Ia.array.keywords.length; r < i; r += 1) {
      const s = Ia.array.keywords[r];
      if (qD.call(t, s))
        return "array";
    }
    return;
  }
  throw new Error(`Mutiple typeIds [${n.join(", ")}] matched in ${JSON.stringify(t)}`);
}
function Kse(t) {
  const e = [], n = UD(t);
  if (n == null)
    return e;
  let r;
  if (Array.isArray(n)) {
    r = {};
    for (let i = 0, s = n.length; i < s; i += 1)
      Object.assign(r, Ia[n[i]]);
  } else
    r = Ia[n];
  return r.definitions == null || r.definitions.forEach((i) => {
    im(t, i, (s, o, l, a) => {
      Vu(s) && UD(s) && e.push({ pointer: mg.join(mg.split(a), !1), def: s });
    });
  }), e;
}
function Yse(t, e) {
  if (this.callback(t, e) === !0)
    return;
  Kse(t).forEach((r) => this.nextTypeDefs(r.def, mg.join(e, r.pointer, !1)));
}
function K1(t, e, n, r = "definitions") {
  const i = e[r];
  Object.keys(i).forEach((s) => {
    if (i[s] === !1 || Vu(i[s])) {
      t.nextTypeDefs(i[s], mg.join(n, r, s, !1));
      return;
    }
  });
}
function e2(t, e, n = "#") {
  const r = { callback: e, nextTypeDefs: Yse };
  r.nextTypeDefs(t, n), t.definitions != null && (r.callback = (i, s) => {
    e(i, s), i.definitions != null && K1(r, i, s);
  }, K1(r, t, n)), t.$defs != null && (r.callback = (i, s) => {
    e(i, s), i.definitions != null && K1(r, i, s);
  }, K1(r, t, n, "$defs"));
}
const Xse = /(#|\/)+$/, Y1 = /#$/, Qse = /^[^:]+:\/\/[^/]+\//, Jse = /\/[^/]*$/, Zse = /#.*$/;
function $b(t, e) {
  return t == null && e == null ? "#" : e == null ? t.replace(Y1, "") : t == null ? e.replace(Y1, "") : e[0] === "#" ? `${t.replace(Zse, "")}${e.replace(Xse, "")}` : Qse.test(e) ? e.replace(Y1, "") : `${t.replace(Jse, "")}/${e.replace(Y1, "")}`;
}
const J0 = /(#|\/)+$/g, eoe = ["", null, "#"];
function toe(t) {
  if (eoe.includes(t))
    return [];
  if (t = t.replace(J0, ""), t.indexOf("#") === -1)
    return [t.replace(J0, "")];
  if (t.indexOf("#") === 0)
    return [t.replace(J0, "")];
  const e = t.split("#");
  return e[0] = e[0].replace(J0, ""), e[1] = `#${e[1].replace(J0, "")}`, e;
}
const noe = /(#|\/)+$/g, roe = (t) => Zt(t) === "object";
function Oa(t, e, n) {
  if (roe(n) && (n = n.__ref || n.$ref), n == null)
    return e;
  let r;
  const i = n.replace(noe, "");
  if (t.remotes[i])
    return r = t.remotes[i], r && r.$ref ? Oa(t, e, r.$ref) : r;
  if (t.ids[n])
    return r = Hc.get(e, t.ids[n]), r && r.$ref ? Oa(t, e, r.$ref) : r;
  const s = toe(n);
  if (s.length === 0)
    return e;
  if (s.length === 1) {
    if (n = s[0], t.remotes[n])
      return r = t.remotes[n], Oa(t, e, r.$ref);
    if (t.ids[n])
      return r = Hc.get(e, t.ids[n]), r && r.$ref ? Oa(t, e, r.$ref) : r;
  }
  if (s.length === 2) {
    const o = s[0];
    if (n = s[1], t.remotes[o])
      return t.remotes[o].getRef ? t.remotes[o].getRef(n) : Oa(t, t.remotes[o], n);
    if (t.ids[o])
      return Oa(t, Hc.get(e, t.ids[o]), n);
  }
  return r = Hc.get(e, t.ids[n] || n), r && r.$ref ? Oa(t, e, r.$ref) : r;
}
const HD = "__compiled", VD = "__ref", ioe = "getRef", soe = "getRoot", ooe = /(#|\/)+$/g;
function loe(t, e, n = e, r = !1) {
  if (!e || e[HD] !== void 0)
    return e;
  const i = { ids: {}, remotes: t.remotes }, s = JSON.stringify(e), o = JSON.parse(s);
  if (Object.defineProperty(o, HD, { enumerable: !1, value: !0 }), Object.defineProperty(o, ioe, {
    enumerable: !1,
    value: Oa.bind(null, i, o)
  }), r === !1 && s.includes("$ref") === !1)
    return o;
  e !== n && Object.defineProperty(o, "definitions", {
    enumerable: !1,
    value: Object.assign({}, n.definitions, n.$defs, e.definitions, e.$defs)
  });
  const l = {}, a = () => o;
  return e2(o, (u, c) => {
    var f;
    if (u.id) {
      if (u.id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(c)) {
        const b = c.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, ""), v = Hc.get(o, b);
        u.id = (f = v.id) !== null && f !== void 0 ? f : u.id;
      }
      i.ids[u.id.replace(ooe, "")] = c;
    }
    c = `#${c}`.replace(/##+/, "#");
    const d = c.replace(/\/[^/]+$/, ""), p = c.replace(/\/[^/]+\/[^/]+$/, ""), m = l[d] || l[p], y = $b(m, u.id);
    l[c] = y, i.ids[y] == null && (i.ids[y] = c), u.$ref && !u[VD] && (Object.defineProperty(u, VD, {
      enumerable: !1,
      value: $b(y, u.$ref)
    }), Object.defineProperty(u, soe, { enumerable: !1, value: a }));
  }), o;
}
function dI(t, e, n, r = t.rootSchema, i = "#") {
  r = t.resolveRef(r), n(r, e, i);
  const s = Zt(e);
  s === "object" ? Object.keys(e).forEach((o) => {
    const l = t.step(o, r, e, i), a = e[o];
    t.each(a, n, l, `${i}/${o}`);
  }) : s === "array" && e.forEach((o, l) => {
    const a = t.step(l, r, e, i);
    t.each(o, n, a, `${i}/${l}`);
  });
}
const pI = {
  additionalItemsError: Qe("AdditionalItemsError"),
  additionalPropertiesError: Qe("AdditionalPropertiesError"),
  anyOfError: Qe("AnyOfError"),
  allOfError: Qe("AllOfError"),
  constError: Qe("ConstError"),
  containsError: Qe("ContainsError"),
  containsArrayError: Qe("ContainsArrayError"),
  containsAnyError: Qe("ContainsAnyError"),
  enumError: Qe("EnumError"),
  forbiddenPropertyError: Qe("ForbiddenPropertyError"),
  formatURLError: Qe("FormatURLError"),
  formatURIError: Qe("FormatURIError"),
  formatURIReferenceError: Qe("FormatURIReferenceError"),
  formatURITemplateError: Qe("FormatURITemplateError"),
  formatDateError: Qe("FormatDateError"),
  formatDateTimeError: Qe("FormatDateTimeError"),
  formatEmailError: Qe("FormatEmailError"),
  formatHostnameError: Qe("FormatHostnameError"),
  formatIPV4Error: Qe("FormatIPV4Error"),
  formatIPV4LeadingZeroError: Qe("FormatIPV4LeadingZeroError"),
  formatIPV6Error: Qe("FormatIPV6Error"),
  formatIPV6LeadingZeroError: Qe("FormatIPV6LeadingZeroError"),
  formatJsonPointerError: Qe("FormatJsonPointerError"),
  formatRegExError: Qe("FormatRegExError"),
  formatTimeError: Qe("FormatTimeError"),
  invalidSchemaError: Qe("InvalidSchemaError"),
  invalidDataError: Qe("InvalidDataError"),
  invalidTypeError: Qe("InvalidTypeError"),
  invalidPropertyNameError: Qe("InvalidPropertyNameError"),
  maximumError: Qe("MaximumError"),
  maxItemsError: Qe("MaxItemsError"),
  maxLengthError: Qe("MaxLengthError"),
  maxPropertiesError: Qe("MaxPropertiesError"),
  minimumError: Qe("MinimumError"),
  minItemsError: Qe("MinItemsError"),
  minItemsOneError: Qe("MinItemsOneError"),
  minLengthError: Qe("MinLengthError"),
  minLengthOneError: Qe("MinLengthOneError"),
  minPropertiesError: Qe("MinPropertiesError"),
  missingDependencyError: Qe("MissingDependencyError"),
  missingOneOfPropertyError: Qe("MissingOneOfPropertyError"),
  multipleOfError: Qe("MultipleOfError"),
  multipleOneOfError: Qe("MultipleOneOfError"),
  noAdditionalPropertiesError: Qe("NoAdditionalPropertiesError"),
  notError: Qe("NotError"),
  oneOfError: Qe("OneOfError"),
  oneOfPropertyError: Qe("OneOfPropertyError"),
  patternError: Qe("PatternError"),
  patternPropertiesError: Qe("PatternPropertiesError"),
  requiredPropertyError: Qe("RequiredPropertyError"),
  schemaWarning: Qe("SchemaWarning"),
  typeError: Qe("TypeError"),
  undefinedValueError: Qe("UndefinedValueError"),
  uniqueItemsError: Qe("UniqueItemsError"),
  unknownPropertyError: Qe("UnknownPropertyError"),
  valueNotEmptyError: Qe("ValueNotEmptyError")
};
var t3 = { exports: {} }, WD;
function aoe() {
  return WD || (WD = 1, (function(t) {
    (function(e) {
      e.exports.is_uri = r, e.exports.is_http_uri = i, e.exports.is_https_uri = s, e.exports.is_web_uri = o, e.exports.isUri = r, e.exports.isHttpUri = i, e.exports.isHttpsUri = s, e.exports.isWebUri = o;
      var n = function(l) {
        var a = l.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return a;
      };
      function r(l) {
        if (l && !/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(l) && !/%[^0-9a-f]/i.test(l) && !/%[0-9a-f](:?[^0-9a-f]|$)/i.test(l)) {
          var a = [], u = "", c = "", f = "", d = "", p = "", m = "";
          if (a = n(l), u = a[1], c = a[2], f = a[3], d = a[4], p = a[5], !!(u && u.length && f.length >= 0)) {
            if (c && c.length) {
              if (!(f.length === 0 || /^\//.test(f))) return;
            } else if (/^\/\//.test(f)) return;
            if (/^[a-z][a-z0-9\+\-\.]*$/.test(u.toLowerCase()))
              return m += u + ":", c && c.length && (m += "//" + c), m += f, d && d.length && (m += "?" + d), p && p.length && (m += "#" + p), m;
          }
        }
      }
      function i(l, a) {
        if (r(l)) {
          var u = [], c = "", f = "", d = "", p = "", m = "", y = "", b = "";
          if (u = n(l), c = u[1], f = u[2], d = u[3], m = u[4], y = u[5], !!c) {
            if (a) {
              if (c.toLowerCase() != "https") return;
            } else if (c.toLowerCase() != "http") return;
            if (f)
              return /:(\d+)$/.test(f) && (p = f.match(/:(\d+)$/)[0], f = f.replace(/:\d+$/, "")), b += c + ":", b += "//" + f, p && (b += p), b += d, m && m.length && (b += "?" + m), y && y.length && (b += "#" + y), b;
          }
        }
      }
      function s(l) {
        return i(l, !0);
      }
      function o(l) {
        return i(l) || s(l);
      }
    })(t);
  })(t3)), t3.exports;
}
var uoe = aoe();
const GD = /* @__PURE__ */ zf(uoe);
var Ci = {}, Vy = { exports: {} }, coe = Vy.exports, KD;
function foe() {
  return KD || (KD = 1, (function(t) {
    (function(e, n) {
      t.exports ? t.exports = n() : e.nearley = n();
    })(coe, function() {
      function e(u, c, f) {
        return this.id = ++e.highestId, this.name = u, this.symbols = c, this.postprocess = f, this;
      }
      e.highestId = 0, e.prototype.toString = function(u) {
        var c = typeof u > "u" ? this.symbols.map(a).join(" ") : this.symbols.slice(0, u).map(a).join(" ") + " â— " + this.symbols.slice(u).map(a).join(" ");
        return this.name + " â†’ " + c;
      };
      function n(u, c, f, d) {
        this.rule = u, this.dot = c, this.reference = f, this.data = [], this.wantedBy = d, this.isComplete = this.dot === u.symbols.length;
      }
      n.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      }, n.prototype.nextState = function(u) {
        var c = new n(this.rule, this.dot + 1, this.reference, this.wantedBy);
        return c.left = this, c.right = u, c.isComplete && (c.data = c.build(), c.right = void 0), c;
      }, n.prototype.build = function() {
        var u = [], c = this;
        do
          u.push(c.right.data), c = c.left;
        while (c.left);
        return u.reverse(), u;
      }, n.prototype.finish = function() {
        this.rule.postprocess && (this.data = this.rule.postprocess(this.data, this.reference, o.fail));
      };
      function r(u, c) {
        this.grammar = u, this.index = c, this.states = [], this.wants = {}, this.scannable = [], this.completed = {};
      }
      r.prototype.process = function(u) {
        for (var c = this.states, f = this.wants, d = this.completed, p = 0; p < c.length; p++) {
          var m = c[p];
          if (m.isComplete) {
            if (m.finish(), m.data !== o.fail) {
              for (var y = m.wantedBy, b = y.length; b--; ) {
                var v = y[b];
                this.complete(v, m);
              }
              if (m.reference === this.index) {
                var _ = m.rule.name;
                (this.completed[_] = this.completed[_] || []).push(m);
              }
            }
          } else {
            var _ = m.rule.symbols[m.dot];
            if (typeof _ != "string") {
              this.scannable.push(m);
              continue;
            }
            if (f[_]) {
              if (f[_].push(m), d.hasOwnProperty(_))
                for (var k = d[_], b = 0; b < k.length; b++) {
                  var S = k[b];
                  this.complete(m, S);
                }
            } else
              f[_] = [m], this.predict(_);
          }
        }
      }, r.prototype.predict = function(u) {
        for (var c = this.grammar.byName[u] || [], f = 0; f < c.length; f++) {
          var d = c[f], p = this.wants[u], m = new n(d, 0, this.index, p);
          this.states.push(m);
        }
      }, r.prototype.complete = function(u, c) {
        var f = u.nextState(c);
        this.states.push(f);
      };
      function i(u, c) {
        this.rules = u, this.start = c || this.rules[0].name;
        var f = this.byName = {};
        this.rules.forEach(function(d) {
          f.hasOwnProperty(d.name) || (f[d.name] = []), f[d.name].push(d);
        });
      }
      i.fromCompiled = function(d, c) {
        var f = d.Lexer;
        d.ParserStart && (c = d.ParserStart, d = d.ParserRules);
        var d = d.map(function(m) {
          return new e(m.name, m.symbols, m.postprocess);
        }), p = new i(d, c);
        return p.lexer = f, p;
      };
      function s() {
        this.reset("");
      }
      s.prototype.reset = function(u, c) {
        this.buffer = u, this.index = 0, this.line = c ? c.line : 1, this.lastLineBreak = c ? -c.col : 0;
      }, s.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var u = this.buffer[this.index++];
          return u === `
` && (this.line += 1, this.lastLineBreak = this.index), { value: u };
        }
      }, s.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      }, s.prototype.formatError = function(u, c) {
        var f = this.buffer;
        if (typeof f == "string") {
          var d = f.split(`
`).slice(
            Math.max(0, this.line - 5),
            this.line
          ), p = f.indexOf(`
`, this.index);
          p === -1 && (p = f.length);
          var m = this.index - this.lastLineBreak, y = String(this.line).length;
          return c += " at line " + this.line + " col " + m + `:

`, c += d.map(function(v, _) {
            return b(this.line - d.length + _ + 1, y) + " " + v;
          }, this).join(`
`), c += `
` + b("", y + m) + `^
`, c;
        } else
          return c + " at index " + (this.index - 1);
        function b(v, _) {
          var k = String(v);
          return Array(_ - k.length + 1).join(" ") + k;
        }
      };
      function o(u, c, f) {
        if (u instanceof i)
          var d = u, f = c;
        else
          var d = i.fromCompiled(u, c);
        this.grammar = d, this.options = {
          keepHistory: !1,
          lexer: d.lexer || new s()
        };
        for (var p in f || {})
          this.options[p] = f[p];
        this.lexer = this.options.lexer, this.lexerState = void 0;
        var m = new r(d, 0);
        this.table = [m], m.wants[d.start] = [], m.predict(d.start), m.process(), this.current = 0;
      }
      o.fail = {}, o.prototype.feed = function(u) {
        var c = this.lexer;
        c.reset(u, this.lexerState);
        for (var f; ; ) {
          try {
            if (f = c.next(), !f)
              break;
          } catch (A) {
            var y = new r(this.grammar, this.current + 1);
            this.table.push(y);
            var d = new Error(this.reportLexerError(A));
            throw d.offset = this.current, d.token = A.token, d;
          }
          var p = this.table[this.current];
          this.options.keepHistory || delete this.table[this.current - 1];
          var m = this.current + 1, y = new r(this.grammar, m);
          this.table.push(y);
          for (var b = f.text !== void 0 ? f.text : f.value, v = c.constructor === s ? f.value : f, _ = p.scannable, k = _.length; k--; ) {
            var S = _[k], C = S.rule.symbols[S.dot];
            if (C.test ? C.test(v) : C.type ? C.type === f.type : C.literal === b) {
              var E = S.nextState({ data: v, token: f, isToken: !0, reference: m - 1 });
              y.states.push(E);
            }
          }
          if (y.process(), y.states.length === 0) {
            var d = new Error(this.reportError(f));
            throw d.offset = this.current, d.token = f, d;
          }
          this.options.keepHistory && (p.lexerState = c.save()), this.current++;
        }
        return p && (this.lexerState = c.save()), this.results = this.finish(), this;
      }, o.prototype.reportLexerError = function(u) {
        var c, f, d = u.token;
        return d ? (c = "input " + JSON.stringify(d.text[0]) + " (lexer error)", f = this.lexer.formatError(d, "Syntax error")) : (c = "input (lexer error)", f = u.message), this.reportErrorCommon(f, c);
      }, o.prototype.reportError = function(u) {
        var c = (u.type ? u.type + " token: " : "") + JSON.stringify(u.value !== void 0 ? u.value : u), f = this.lexer.formatError(u, "Syntax error");
        return this.reportErrorCommon(f, c);
      }, o.prototype.reportErrorCommon = function(u, c) {
        var f = [];
        f.push(u);
        var d = this.table.length - 2, p = this.table[d], m = p.states.filter(function(b) {
          var v = b.rule.symbols[b.dot];
          return v && typeof v != "string";
        });
        if (m.length === 0)
          f.push("Unexpected " + c + `. I did not expect any more input. Here is the state of my parse table:
`), this.displayStateStack(p.states, f);
        else {
          f.push("Unexpected " + c + `. Instead, I was expecting to see one of the following:
`);
          var y = m.map(function(b) {
            return this.buildFirstStateStack(b, []) || [b];
          }, this);
          y.forEach(function(b) {
            var v = b[0], _ = v.rule.symbols[v.dot], k = this.getSymbolDisplay(_);
            f.push("A " + k + " based on:"), this.displayStateStack(b, f);
          }, this);
        }
        return f.push(""), f.join(`
`);
      }, o.prototype.displayStateStack = function(u, c) {
        for (var f, d = 0, p = 0; p < u.length; p++) {
          var m = u[p], y = m.rule.toString(m.dot);
          y === f ? d++ : (d > 0 && c.push("    ^ " + d + " more lines identical to this"), d = 0, c.push("    " + y)), f = y;
        }
      }, o.prototype.getSymbolDisplay = function(u) {
        return l(u);
      }, o.prototype.buildFirstStateStack = function(u, c) {
        if (c.indexOf(u) !== -1)
          return null;
        if (u.wantedBy.length === 0)
          return [u];
        var f = u.wantedBy[0], d = [u].concat(c), p = this.buildFirstStateStack(f, d);
        return p === null ? null : [u].concat(p);
      }, o.prototype.save = function() {
        var u = this.table[this.current];
        return u.lexerState = this.lexerState, u;
      }, o.prototype.restore = function(u) {
        var c = u.index;
        this.current = c, this.table[c] = u, this.table.splice(c + 1), this.lexerState = u.lexerState, this.results = this.finish();
      }, o.prototype.rewind = function(u) {
        if (!this.options.keepHistory)
          throw new Error("set option `keepHistory` to enable rewinding");
        this.restore(this.table[u]);
      }, o.prototype.finish = function() {
        var u = [], c = this.grammar.start, f = this.table[this.table.length - 1];
        return f.states.forEach(function(d) {
          d.rule.name === c && d.dot === d.rule.symbols.length && d.reference === 0 && d.data !== o.fail && u.push(d);
        }), u.map(function(d) {
          return d.data;
        });
      };
      function l(u) {
        var c = typeof u;
        if (c === "string")
          return u;
        if (c === "object") {
          if (u.literal)
            return JSON.stringify(u.literal);
          if (u instanceof RegExp)
            return "character matching " + u;
          if (u.type)
            return u.type + " token";
          if (u.test)
            return "token matching " + String(u.test);
          throw new Error("Unknown symbol type: " + u);
        }
      }
      function a(u) {
        var c = typeof u;
        if (c === "string")
          return u;
        if (c === "object") {
          if (u.literal)
            return JSON.stringify(u.literal);
          if (u instanceof RegExp)
            return u.toString();
          if (u.type)
            return "%" + u.type;
          if (u.test)
            return "<" + String(u.test) + ">";
          throw new Error("Unknown symbol type: " + u);
        }
      }
      return {
        Parser: o,
        Grammar: i,
        Rule: e
      };
    });
  })(Vy)), Vy.exports;
}
var X1 = {}, YD;
function hoe() {
  if (YD) return X1;
  YD = 1, Object.defineProperty(X1, "__esModule", { value: !0 });
  function t(i) {
    return i[0];
  }
  const e = (i) => [].concat(...i.map((s) => Array.isArray(s) ? e(s) : s));
  function n(i) {
    return i ? Array.isArray(i) ? e(i).join("") : i : "";
  }
  const r = {
    Lexer: void 0,
    ParserRules: [
      { name: "Reverse_path", symbols: ["Path"] },
      { name: "Reverse_path$string$1", symbols: [{ literal: "<" }, { literal: ">" }], postprocess: (i) => i.join("") },
      { name: "Reverse_path", symbols: ["Reverse_path$string$1"] },
      { name: "Forward_path$subexpression$1$subexpression$1", symbols: [{ literal: "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { literal: "@" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "Forward_path$subexpression$1", symbols: ["Forward_path$subexpression$1$subexpression$1", "Domain", { literal: ">" }] },
      { name: "Forward_path", symbols: ["Forward_path$subexpression$1"] },
      { name: "Forward_path$subexpression$2", symbols: [{ literal: "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { literal: ">" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "Forward_path", symbols: ["Forward_path$subexpression$2"] },
      { name: "Forward_path", symbols: ["Path"] },
      { name: "Path$ebnf$1$subexpression$1", symbols: ["A_d_l", { literal: ":" }] },
      { name: "Path$ebnf$1", symbols: ["Path$ebnf$1$subexpression$1"], postprocess: t },
      { name: "Path$ebnf$1", symbols: [], postprocess: () => null },
      { name: "Path", symbols: [{ literal: "<" }, "Path$ebnf$1", "Mailbox", { literal: ">" }] },
      { name: "A_d_l$ebnf$1", symbols: [] },
      { name: "A_d_l$ebnf$1$subexpression$1", symbols: [{ literal: "," }, "At_domain"] },
      { name: "A_d_l$ebnf$1", symbols: ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "A_d_l", symbols: ["At_domain", "A_d_l$ebnf$1"] },
      { name: "At_domain", symbols: [{ literal: "@" }, "Domain"] },
      { name: "Domain$ebnf$1", symbols: [] },
      { name: "Domain$ebnf$1$subexpression$1", symbols: [{ literal: "." }, "sub_domain"] },
      { name: "Domain$ebnf$1", symbols: ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Domain", symbols: ["sub_domain", "Domain$ebnf$1"] },
      { name: "sub_domain", symbols: ["U_label"] },
      { name: "Let_dig", symbols: ["ALPHA_DIGIT"], postprocess: t },
      { name: "Ldh_str$ebnf$1", symbols: [] },
      { name: "Ldh_str$ebnf$1", symbols: ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Ldh_str", symbols: ["Ldh_str$ebnf$1", "Let_dig"] },
      { name: "U_Let_dig", symbols: ["ALPHA_DIGIT_U"], postprocess: t },
      { name: "U_Ldh_str$ebnf$1", symbols: [] },
      { name: "U_Ldh_str$ebnf$1", symbols: ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "U_Ldh_str", symbols: ["U_Ldh_str$ebnf$1", "U_Let_dig"] },
      { name: "U_label$ebnf$1$subexpression$1", symbols: ["U_Ldh_str"] },
      { name: "U_label$ebnf$1", symbols: ["U_label$ebnf$1$subexpression$1"], postprocess: t },
      { name: "U_label$ebnf$1", symbols: [], postprocess: () => null },
      { name: "U_label", symbols: ["U_Let_dig", "U_label$ebnf$1"] },
      { name: "address_literal$subexpression$1", symbols: ["IPv4_address_literal"] },
      { name: "address_literal$subexpression$1", symbols: ["IPv6_address_literal"] },
      { name: "address_literal$subexpression$1", symbols: ["General_address_literal"] },
      { name: "address_literal", symbols: [{ literal: "[" }, "address_literal$subexpression$1", { literal: "]" }] },
      {
        name: "non_local_part",
        symbols: ["Domain"],
        postprocess: function(i) {
          return { DomainName: n(i[0]) };
        }
      },
      {
        name: "non_local_part",
        symbols: ["address_literal"],
        postprocess: function(i) {
          return { AddressLiteral: n(i[0]) };
        }
      },
      {
        name: "Mailbox",
        symbols: ["Local_part", { literal: "@" }, "non_local_part"],
        postprocess: function(i) {
          return { localPart: n(i[0]), domainPart: n(i[2]) };
        }
      },
      {
        name: "Local_part",
        symbols: ["Dot_string"],
        postprocess: function(i) {
          return { DotString: n(i[0]) };
        }
      },
      {
        name: "Local_part",
        symbols: ["Quoted_string"],
        postprocess: function(i) {
          return { QuotedString: n(i[0]) };
        }
      },
      { name: "Dot_string$ebnf$1", symbols: [] },
      { name: "Dot_string$ebnf$1$subexpression$1", symbols: [{ literal: "." }, "Atom"] },
      { name: "Dot_string$ebnf$1", symbols: ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Dot_string", symbols: ["Atom", "Dot_string$ebnf$1"] },
      { name: "Atom$ebnf$1", symbols: [/[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/] },
      { name: "Atom$ebnf$1", symbols: ["Atom$ebnf$1", /[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Atom", symbols: ["Atom$ebnf$1"] },
      { name: "Quoted_string$ebnf$1", symbols: [] },
      { name: "Quoted_string$ebnf$1", symbols: ["Quoted_string$ebnf$1", "QcontentSMTP"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "Quoted_string", symbols: ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },
      { name: "QcontentSMTP", symbols: ["qtextSMTP"] },
      { name: "QcontentSMTP", symbols: ["quoted_pairSMTP"] },
      { name: "quoted_pairSMTP", symbols: [{ literal: "\\" }, /[\x20-\x7e]/] },
      { name: "qtextSMTP", symbols: [/[\x20-\x21\x23-\x5b\x5d-\x7e\u0080-\uFFFF]/], postprocess: t },
      { name: "IPv4_address_literal$macrocall$2", symbols: [{ literal: "." }, "Snum"] },
      { name: "IPv4_address_literal$macrocall$1", symbols: ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },
      { name: "IPv4_address_literal", symbols: ["Snum", "IPv4_address_literal$macrocall$1"] },
      { name: "IPv6_address_literal$subexpression$1", symbols: [/[iI]/, /[pP]/, /[vV]/, { literal: "6" }, { literal: ":" }], postprocess: function(i) {
        return i.join("");
      } },
      { name: "IPv6_address_literal", symbols: ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },
      { name: "General_address_literal$ebnf$1", symbols: ["dcontent"] },
      { name: "General_address_literal$ebnf$1", symbols: ["General_address_literal$ebnf$1", "dcontent"], postprocess: (i) => i[0].concat([i[1]]) },
      { name: "General_address_literal", symbols: ["Standardized_tag", { literal: ":" }, "General_address_literal$ebnf$1"] },
      { name: "Standardized_tag", symbols: ["Ldh_str"] },
      { name: "dcontent", symbols: [/[\x21-\x5a\x5e-\x7e]/], postprocess: t },
      { name: "Snum", symbols: ["DIGIT"] },
      { name: "Snum$subexpression$1", symbols: [/[1-9]/, "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$1"] },
      { name: "Snum$subexpression$2", symbols: [{ literal: "1" }, "DIGIT", "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$2"] },
      { name: "Snum$subexpression$3", symbols: [{ literal: "2" }, /[0-4]/, "DIGIT"] },
      { name: "Snum", symbols: ["Snum$subexpression$3"] },
      { name: "Snum$subexpression$4", symbols: [{ literal: "2" }, { literal: "5" }, /[0-5]/] },
      { name: "Snum", symbols: ["Snum$subexpression$4"] },
      { name: "IPv6_addr", symbols: ["IPv6_full"] },
      { name: "IPv6_addr", symbols: ["IPv6_comp"] },
      { name: "IPv6_addr", symbols: ["IPv6v4_full"] },
      { name: "IPv6_addr", symbols: ["IPv6v4_comp"] },
      { name: "IPv6_hex", symbols: ["HEXDIG"] },
      { name: "IPv6_hex$subexpression$1", symbols: ["HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$1"] },
      { name: "IPv6_hex$subexpression$2", symbols: ["HEXDIG", "HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$2"] },
      { name: "IPv6_hex$subexpression$3", symbols: ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },
      { name: "IPv6_hex", symbols: ["IPv6_hex$subexpression$3"] },
      { name: "IPv6_full$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_full$macrocall$1", symbols: ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },
      { name: "IPv6_full", symbols: ["IPv6_hex", "IPv6_full$macrocall$1"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", symbols: ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },
      { name: "IPv6_comp$ebnf$1$subexpression$1", symbols: ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },
      { name: "IPv6_comp$ebnf$1", symbols: ["IPv6_comp$ebnf$1$subexpression$1"], postprocess: t },
      { name: "IPv6_comp$ebnf$1", symbols: [], postprocess: () => null },
      { name: "IPv6_comp$string$1", symbols: [{ literal: ":" }, { literal: ":" }], postprocess: (i) => i.join("") },
      { name: "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", symbols: ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },
      { name: "IPv6_comp$ebnf$2$subexpression$1", symbols: ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },
      { name: "IPv6_comp$ebnf$2", symbols: ["IPv6_comp$ebnf$2$subexpression$1"], postprocess: t },
      { name: "IPv6_comp$ebnf$2", symbols: [], postprocess: () => null },
      { name: "IPv6_comp", symbols: ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },
      { name: "IPv6v4_full$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_full$macrocall$1", symbols: ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },
      { name: "IPv6v4_full", symbols: ["IPv6_hex", "IPv6v4_full$macrocall$1", { literal: ":" }, "IPv4_address_literal"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", symbols: ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },
      { name: "IPv6v4_comp$ebnf$1$subexpression$1", symbols: ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },
      { name: "IPv6v4_comp$ebnf$1", symbols: ["IPv6v4_comp$ebnf$1$subexpression$1"], postprocess: t },
      { name: "IPv6v4_comp$ebnf$1", symbols: [], postprocess: () => null },
      { name: "IPv6v4_comp$string$1", symbols: [{ literal: ":" }, { literal: ":" }], postprocess: (i) => i.join("") },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", symbols: [{ literal: ":" }, "IPv6_hex"] },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", symbols: ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },
      { name: "IPv6v4_comp$ebnf$2$subexpression$1", symbols: ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { literal: ":" }] },
      { name: "IPv6v4_comp$ebnf$2", symbols: ["IPv6v4_comp$ebnf$2$subexpression$1"], postprocess: t },
      { name: "IPv6v4_comp$ebnf$2", symbols: [], postprocess: () => null },
      { name: "IPv6v4_comp", symbols: ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },
      { name: "DIGIT", symbols: [/[0-9]/], postprocess: t },
      { name: "ALPHA_DIGIT_U", symbols: [/[0-9A-Za-z\u0080-\uFFFF]/], postprocess: t },
      { name: "ALPHA_DIGIT", symbols: [/[0-9A-Za-z]/], postprocess: t },
      { name: "ALPHA_DIG_DASH", symbols: [/[-0-9A-Za-z]/], postprocess: t },
      { name: "ALPHA_DIG_DASH_U", symbols: [/[-0-9A-Za-z\u0080-\uFFFF]/], postprocess: t },
      { name: "HEXDIG", symbols: [/[0-9A-Fa-f]/], postprocess: t },
      { name: "DQUOTE", symbols: [{ literal: '"' }], postprocess: t }
    ],
    ParserStart: "Reverse_path"
  };
  return X1.default = r, X1;
}
var XD;
function doe() {
  if (XD) return Ci;
  XD = 1;
  var t = Ci && Ci.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  };
  Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.canonicalize = Ci.canonicalize_quoted_string = Ci.normalize = Ci.normalize_dot_string = Ci.parse = void 0;
  const e = foe(), n = t(hoe());
  n.default.ParserStart = "Mailbox";
  const r = e.Grammar.fromCompiled(n.default);
  function i(u) {
    const c = new e.Parser(r);
    if (c.feed(u), c.results.length !== 1)
      throw new Error("address parsing failed: ambiguous grammar");
    return c.results[0];
  }
  Ci.parse = i;
  function s(u) {
    return (function() {
      const d = u.indexOf("+");
      return d === -1 ? u : u.substr(0, d);
    })().replace(/\./g, "").toLowerCase();
  }
  Ci.normalize_dot_string = s;
  function o(u) {
    var c, f;
    const d = i(u), p = (c = d.domainPart.AddressLiteral) !== null && c !== void 0 ? c : d.domainPart.DomainName.toLowerCase();
    return `${(f = d.localPart.QuotedString) !== null && f !== void 0 ? f : s(d.localPart.DotString)}@${p}`;
  }
  Ci.normalize = o;
  function l(u) {
    return `"${u.substr(1).substr(0, u.length - 2).replace(/(?:\\(.))/g, "$1").replace(/(?:(["\\]))/g, "\\$1")}"`;
  }
  Ci.canonicalize_quoted_string = l;
  function a(u) {
    var c;
    const f = i(u), d = (c = f.domainPart.AddressLiteral) !== null && c !== void 0 ? c : f.domainPart.DomainName.toLowerCase();
    return `${f.localPart.QuotedString ? l(f.localPart.QuotedString) : f.localPart.DotString}@${d}`;
  }
  return Ci.canonicalize = a, Ci;
}
var poe = doe();
const goe = new RegExp("^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$"), moe = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, yoe = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, boe = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/, voe = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, xoe = /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, woe = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], _oe = /^(?:\/(?:[^~/]|~0|~1)*)*$/, koe = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, Coe = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, Soe = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, gI = {
  date: (t, e, n, r) => {
    if (typeof n != "string" || n === "")
      return;
    const i = n.match(voe);
    if (!i)
      return t.errors.formatDateTimeError({ value: n, pointer: r, schema: e });
    const s = +i[1], o = +i[2], l = +i[3], a = s % 4 === 0 && (s % 100 !== 0 || s % 400 === 0);
    if (!(o >= 1 && o <= 12 && l >= 1 && l <= (o == 2 && a ? 29 : woe[o])))
      return t.errors.formatDateError({ value: n, pointer: r, schema: e });
  },
  "date-time": (t, e, n, r) => {
    if (!(typeof n != "string" || n === ""))
      return n === "" || goe.test(n) ? new Date(n).toString() === "Invalid Date" ? t.errors.formatDateTimeError({ value: n, pointer: r, schema: e }) : void 0 : t.errors.formatDateTimeError({ value: n, pointer: r, schema: e });
  },
  email: (t, e, n, r) => {
    if (typeof n != "string" || n === "")
      return;
    if (n[0] === '"')
      return t.errors.formatEmailError({ value: n, pointer: r, schema: e });
    const [i, s, ...o] = n.split("@");
    if (!i || !s || o.length !== 0 || i.length > 64 || s.length > 253)
      return t.errors.formatEmailError({ value: n, pointer: r, schema: e });
    if (i[0] === "." || i.endsWith(".") || i.includes(".."))
      return t.errors.formatEmailError({ value: n, pointer: r, schema: e });
    if (!/^[a-z0-9.-]+$/i.test(s) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(i))
      return t.errors.formatEmailError({ value: n, pointer: r, schema: e });
    if (!s.split(".").every((l) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(l)))
      return t.errors.formatEmailError({ value: n, pointer: r, schema: e });
  },
  /**
   * @draft 7
   * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531
   */
  "idn-email": (t, e, n, r) => {
    if (!(typeof n != "string" || n === ""))
      try {
        poe.parse(n);
        return;
      } catch {
        return t.errors.formatEmailError({ value: n, pointer: r, schema: e });
      }
  },
  hostname: (t, e, n, r) => {
    if (typeof n == "string" && !(n === "" || boe.test(n)))
      return t.errors.formatHostnameError({ value: n, pointer: r, schema: e });
  },
  ipv4: (t, e, n, r) => {
    if (!(typeof n != "string" || n === "")) {
      if (n && n[0] === "0")
        return t.errors.formatIPV4LeadingZeroError({ value: n, pointer: r, schema: e });
      if (!(n.length <= 15 && moe.test(n)))
        return t.errors.formatIPV4Error({ value: n, pointer: r, schema: e });
    }
  },
  ipv6: (t, e, n, r) => {
    if (!(typeof n != "string" || n === "")) {
      if (n && n[0] === "0")
        return t.errors.formatIPV6LeadingZeroError({ value: n, pointer: r, schema: e });
      if (!(n.length <= 45 && yoe.test(n)))
        return t.errors.formatIPV6Error({ value: n, pointer: r, schema: e });
    }
  },
  "json-pointer": (t, e, n, r) => {
    if (!(typeof n != "string" || n === "") && !_oe.test(n))
      return t.errors.formatJsonPointerError({ value: n, pointer: r, schema: e });
  },
  "relative-json-pointer": (t, e, n, r) => {
    if (!(typeof n != "string" || n === "") && !koe.test(n))
      return t.errors.formatJsonPointerError({ value: n, pointer: r, schema: e });
  },
  regex: (t, e, n, r) => {
    if (typeof n == "string" && /\\Z$/.test(n) === !1) {
      try {
        new RegExp(n);
        return;
      } catch {
      }
      return t.errors.formatRegExError({ value: n, pointer: r, schema: e });
    }
    if (!(typeof n == "object" || typeof n == "number" || Array.isArray(n)))
      return t.errors.formatRegExError({ value: n, pointer: r, schema: e });
  },
  // hh:mm:ss.sTZD
  // https://opis.io/json-schema/2.x/formats.html
  // regex https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html
  time: (t, e, n, r) => typeof n != "string" || n === "" || n.match(xoe) ? void 0 : t.errors.formatDateTimeError({ value: n, pointer: r, schema: e }),
  uri: (t, e, n, r) => {
    if (!(typeof n != "string" || n === "") && !GD.isUri(n))
      return t.errors.formatURIError({ value: n, pointer: r, schema: e });
  },
  "uri-reference": (t, e, n, r) => {
    if (!(typeof n != "string" || n === "") && !Coe.test(n))
      return t.errors.formatURIReferenceError({ value: n, pointer: r, schema: e });
  },
  "uri-template": (t, e, n, r) => {
    if (!(typeof n != "string" || n === "") && !Soe.test(n))
      return t.errors.formatURITemplateError({ value: n, pointer: r, schema: e });
  },
  url: (t, e, n, r) => {
    if (!(n === "" || GD.isWebUri(n)))
      return t.errors.formatURLError({ value: n, pointer: r, schema: e });
  }
}, mI = {};
function yI(t, e = mI) {
  const { pointer: n = "#", data: r, schema: i = t.rootSchema, withSchemaWarning: s = !1 } = e, o = mg.split(n), l = bI(t, t.resolveRef(i), o, "#", r);
  if (!(!s && l?.code === "schema-warning"))
    return l;
}
function bI(t, e, n, r, i = mI) {
  if (n.length === 0)
    return t.resolveRef(e);
  const s = n.shift();
  return e = t.step(s, e, i, r), mi(e) ? e : (i = i[s], bI(t, e, n, `${r}/${s}`, i));
}
function Aoe(t) {
  switch (Zt(t)) {
    case "string":
    case "array":
      return t?.length === 0;
    case "null":
    case "undefined":
      return !0;
    case "object":
      return Object.keys(t).length === 0;
    default:
      return !1;
  }
}
const QD = e0.templateDefaultOptions;
let Na;
function n3(t, e) {
  const { $ref: n } = t;
  return n == null ? !0 : (Na[e] == null || Na[e][n] == null ? 0 : Na[e][n]) < e0.GET_TEMPLATE_RECURSION_LIMIT;
}
function JD(t, e, n) {
  const { $ref: r } = e;
  return r == null ? e : (Na[n] = Na[n] || {}, Na[n][r] = Na[n][r] || 0, Na[n][r] += 1, t.resolveRef(e));
}
function Eoe(t, e) {
  if (t === "string")
    return JSON.stringify(e);
  if (typeof e != "string")
    return null;
  try {
    if (e = JSON.parse(e), typeof e === t)
      return e;
  } catch {
  }
  return null;
}
function vI(t, e, n, r, i) {
  if (Zt(e) !== "object")
    return Object.assign({ pointer: r }, e);
  if (n3(e, r) === !1 && n == null)
    return !1;
  let s = Ib(JD(t, e, r));
  if (Array.isArray(e.anyOf) && e.anyOf.length > 0) {
    if (n3(e.anyOf[0], `${r}/anyOf/0`)) {
      const o = JD(t, e.anyOf[0], `${r}/anyOf/0`);
      s = H6(s, o), s.pointer = e.anyOf[0].$ref || s.pointer;
    }
    delete s.anyOf;
  }
  if (Array.isArray(e.allOf) && e.allOf.map((l, a) => n3(l, `${r}/allOf/${a}`)).reduceRight((l, a) => l && a, !0)) {
    const l = [];
    let a = Ib(n);
    for (let c = 0; c < e.allOf.length; c += 1)
      l.push(nI(t, e.allOf[c], a)), a = Io(t, a, { type: e.type, ...l[c] }, `${r}/allOf/${c}`, i);
    const u = iI(t, { allOf: l });
    u && (s = Fi(s, u));
  }
  return s.pointer = s.pointer || e.$ref || r, s;
}
const ZD = (t) => t && typeof t == "object";
function Io(t, e, n, r, i) {
  var s;
  if (n == null)
    throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(e)}`);
  if (r == null)
    throw new Error("Missing pointer");
  let o = vI(t, n, e, r, i);
  if (!ZD(o))
    return;
  if (r = o.pointer, o?.const)
    return o.const;
  if (Array.isArray(o.oneOf))
    if (Aoe(e)) {
      const c = o.oneOf[0].type || o.type || o.const && typeof o.const || Zt(e);
      o = { ...o.oneOf[0], type: c };
    } else {
      const c = U6(t, e, o);
      if (mi(c)) {
        if (e != null && i.removeInvalidData !== !0)
          return e;
        o = o.oneOf[0], e = void 0;
      } else
        c.type = (s = c.type) !== null && s !== void 0 ? s : o.type, o = c;
    }
  if (!ZD(o) || o.type == null)
    return;
  if (e instanceof File)
    return e;
  const l = Array.isArray(o.type) ? Doe(o.type, e, o.default) : o.type, a = Zt(e);
  return e != null && a !== l && !(a === "number" && l === "integer") && (e = Eoe(l, e)), e7[l] == null ? i.removeInvalidData ? void 0 : e : e7[l](t, o, e, r, i);
}
function Doe(t, e, n) {
  if (e == null) {
    if (n != null) {
      const i = Zt(n);
      if (t.includes(i))
        return i;
    }
    return t[0];
  }
  const r = Zt(e);
  return t.includes(r) ? r : t[0];
}
const e7 = {
  null: (t, e, n) => Z0(e, n, null),
  string: (t, e, n) => Z0(e, n, ""),
  number: (t, e, n) => Z0(e, n, 0),
  integer: (t, e, n) => Z0(e, n, 0),
  boolean: (t, e, n) => Z0(e, n, !1),
  object: (t, e, n, r, i) => {
    var s;
    const o = e.default === void 0 ? {} : e.default, l = {}, a = i.extendDefaults === !1 && e.default !== void 0 ? [] : (s = e.required) !== null && s !== void 0 ? s : [];
    e.properties && Object.keys(e.properties).forEach((f) => {
      const d = n == null || n[f] == null ? o[f] : n[f], p = a.includes(f);
      (d != null || p || i.addOptionalProps) && (l[f] = Io(t, d, e.properties[f], `${r}/properties/${f}`, i));
    });
    let u = oI(t, e, l);
    if (u) {
      u = Fi(e, u), delete u.dependencies;
      const f = Io(t, n, u, `${r}/dependencies`, i);
      Object.assign(l, f);
    }
    n && (i.removeInvalidData === !0 && (e.additionalProperties === !1 || Zt(e.additionalProperties) === "object") ? Zt(e.additionalProperties) === "object" && Object.keys(n).forEach((f) => {
      l[f] == null && t.isValid(n[f], e.additionalProperties) && (l[f] = n[f]);
    }) : Object.keys(n).forEach((f) => l[f] == null && (l[f] = n[f])));
    const c = Zv(t, e, l);
    if (c) {
      const f = Io(t, l, { type: "object", ...c }, r, i);
      Object.assign(l, f);
    }
    return l;
  },
  // build array type of items, ignores additionalItems
  array: (t, e, n, r, i) => {
    var s, o;
    if (e.items == null)
      return n || [];
    const l = e.default === void 0 ? [] : e.default, a = n || l, u = i.extendDefaults === !1 && e.default !== void 0 ? 0 : e.minItems || 0;
    if (Array.isArray(e.items)) {
      for (let f = 0, d = Math.max(u ?? 0, (o = (s = e.items) === null || s === void 0 ? void 0 : s.length) !== null && o !== void 0 ? o : 0); f < d; f += 1)
        a[f] = Io(t, a[f] == null ? l[f] : a[f], e.items[f], `${r}/items/${f}`, i);
      return a;
    }
    if (Zt(e.items) !== "object")
      return a;
    const c = vI(t, e.items, n, r, i);
    if (c === !1)
      return a;
    if (r = c.pointer || r, c.oneOf && a.length === 0) {
      const f = c.oneOf[0];
      for (let d = 0; d < u; d += 1)
        a[d] = Io(t, a[d] == null ? l[d] : a[d], f, `${r}/oneOf/0`, i);
      return a;
    }
    if (c.oneOf && a.length > 0) {
      const f = Math.max(u, a.length);
      for (let d = 0; d < f; d += 1) {
        let p = a[d] == null ? l[d] : a[d], m = U6(t, p, c);
        m == null || mi(m) ? p != null && i.removeInvalidData !== !0 ? a[d] = p : (p = void 0, m = c.oneOf[0], a[d] = Io(t, p, m, `${r}/oneOf/${d}`, i)) : a[d] = Io(t, p, m, `${r}/oneOf/${d}`, i);
      }
      return a;
    }
    if (c.type) {
      for (let f = 0, d = Math.max(u, a.length); f < d; f += 1)
        a[f] = Io(t, a[f] == null ? l[f] : a[f], c, `${r}/items`, i);
      return a;
    }
    return a;
  }
};
function Z0(t, e, n) {
  return e ?? (t.const ? t.const : t.default === void 0 && Array.isArray(t.enum) ? t.enum[0] : t.default === void 0 ? n : t.default);
}
const xI = (t, e, n = t.rootSchema, r) => (Na = {}, r ? Io(t, e, n, "#", { ...QD, ...r }) : Io(t, e, n, "#", QD));
function wI(t, e, n = t.rootSchema, r = "#") {
  return t.validate(e, n, r).length === 0;
}
function t7(t) {
  const e = [];
  let n = 0;
  const r = t.length;
  for (; n < r; ) {
    const i = t.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const s = t.charCodeAt(n++);
      (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), n--);
    } else
      e.push(i);
  }
  return e;
}
function n7(t) {
  const e = `${t}`, n = e.indexOf(".");
  return n === -1 ? 0 : e.length - (n + 1);
}
var r3, r7;
function Ooe() {
  return r7 || (r7 = 1, r3 = function t(e, n) {
    if (e === n) return !0;
    if (e && n && typeof e == "object" && typeof n == "object") {
      if (e.constructor !== n.constructor) return !1;
      var r, i, s;
      if (Array.isArray(e)) {
        if (r = e.length, r != n.length) return !1;
        for (i = r; i-- !== 0; )
          if (!t(e[i], n[i])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
      if (s = Object.keys(e), r = s.length, r !== Object.keys(n).length) return !1;
      for (i = r; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, s[i])) return !1;
      for (i = r; i-- !== 0; ) {
        var o = s[i];
        if (!t(e[o], n[o])) return !1;
      }
      return !0;
    }
    return e !== e && n !== n;
  }), r3;
}
var Foe = Ooe();
const _I = /* @__PURE__ */ zf(Foe), Toe = Object.prototype.hasOwnProperty, i7 = (t, e) => !(t[e] === void 0 || !Toe.call(t, e)), kI = {
  additionalProperties: (t, e, n, r) => {
    if (e.additionalProperties === !0 || e.additionalProperties == null || Zt(e.patternProperties) === "object" && e.additionalProperties === !1)
      return;
    const i = [];
    let s = Object.keys(n).filter((l) => e0.propertyBlacklist.includes(l) === !1);
    const o = Object.keys(e.properties || {});
    if (Zt(e.patternProperties) === "object") {
      const l = Object.keys(e.patternProperties).map((a) => new RegExp(a));
      s = s.filter((a) => {
        for (let u = 0; u < l.length; u += 1)
          if (l[u].test(a))
            return !1;
        return !0;
      });
    }
    for (let l = 0, a = s.length; l < a; l += 1) {
      const u = s[l];
      if (o.indexOf(u) === -1) {
        const c = Vu(e.additionalProperties);
        if (c && Array.isArray(e.additionalProperties.oneOf)) {
          const f = t.resolveOneOf(n[u], e.additionalProperties, `${r}/${u}`);
          mi(f) ? i.push(t.errors.additionalPropertiesError({
            pointer: r,
            schema: e.additionalProperties,
            value: n,
            property: s[l],
            properties: o,
            // pass all validation errors
            errors: f.data.errors
          })) : i.push(...t.validate(n[u], f, r));
        } else c ? i.push(...t.validate(n[u], e.additionalProperties, `${r}/${u}`)) : i.push(t.errors.noAdditionalPropertiesError({
          pointer: r,
          schema: e,
          value: n,
          property: s[l],
          properties: o
        }));
      }
    }
    return i;
  },
  allOf: yse,
  anyOf: xse,
  dependencies: vse,
  enum: (t, e, n, r) => {
    const i = Zt(n);
    if (i === "object" || i === "array") {
      const s = JSON.stringify(n);
      for (let o = 0; o < e.enum.length; o += 1)
        if (JSON.stringify(e.enum[o]) === s)
          return;
    } else if (e.enum.includes(n))
      return;
    return t.errors.enumError({ pointer: r, schema: e, value: n, values: e.enum });
  },
  format: (t, e, n, r) => {
    if (t.validateFormat[e.format])
      return t.validateFormat[e.format](t, e, n, r);
  },
  items: (t, e, n, r) => {
    if (e.items === !1)
      return Array.isArray(n) && n.length === 0 ? void 0 : t.errors.invalidDataError({ pointer: r, value: n, schema: e });
    const i = [];
    for (let s = 0; s < n.length; s += 1) {
      const o = n[s], l = t.step(s, e, n, r);
      if (mi(l))
        return [l];
      const a = t.validate(o, l, `${r}/${s}`);
      i.push(...a);
    }
    return i;
  },
  maximum: (t, e, n, r) => {
    if (!isNaN(e.maximum)) {
      if (e.maximum && e.maximum < n)
        return t.errors.maximumError({
          maximum: e.maximum,
          length: n,
          value: n,
          pointer: r,
          schema: e
        });
      if (e.maximum && e.exclusiveMaximum === !0 && e.maximum === n)
        return t.errors.maximumError({
          maximum: e.maximum,
          length: n,
          pointer: r,
          schema: e,
          value: n
        });
    }
  },
  maxItems: (t, e, n, r) => {
    if (!isNaN(e.maxItems) && e.maxItems < n.length)
      return t.errors.maxItemsError({
        maximum: e.maxItems,
        length: n.length,
        schema: e,
        value: n,
        pointer: r
      });
  },
  maxLength: (t, e, n, r) => {
    if (isNaN(e.maxLength))
      return;
    const i = t7(n).length;
    if (e.maxLength < i)
      return t.errors.maxLengthError({
        maxLength: e.maxLength,
        length: i,
        pointer: r,
        schema: e,
        value: n
      });
  },
  maxProperties: (t, e, n, r) => {
    const i = Object.keys(n).length;
    if (isNaN(e.maxProperties) === !1 && e.maxProperties < i)
      return t.errors.maxPropertiesError({
        maxProperties: e.maxProperties,
        length: i,
        pointer: r,
        schema: e,
        value: n
      });
  },
  minLength: (t, e, n, r) => {
    if (isNaN(e.minLength))
      return;
    const i = t7(n).length;
    if (e.minLength > i)
      return e.minLength === 1 ? t.errors.minLengthOneError({
        minLength: e.minLength,
        length: i,
        pointer: r,
        schema: e,
        value: n
      }) : t.errors.minLengthError({
        minLength: e.minLength,
        length: i,
        pointer: r,
        schema: e,
        value: n
      });
  },
  minimum: (t, e, n, r) => {
    if (!isNaN(e.minimum)) {
      if (e.minimum > n)
        return t.errors.minimumError({
          minimum: e.minimum,
          length: n,
          pointer: r,
          schema: e,
          value: n
        });
      if (e.exclusiveMinimum === !0 && e.minimum === n)
        return t.errors.minimumError({
          minimum: e.minimum,
          length: n,
          pointer: r,
          schema: e,
          value: n
        });
    }
  },
  minItems: (t, e, n, r) => {
    if (!isNaN(e.minItems) && e.minItems > n.length)
      return e.minItems === 1 ? t.errors.minItemsOneError({
        minItems: e.minItems,
        length: n.length,
        pointer: r,
        schema: e,
        value: n
      }) : t.errors.minItemsError({
        minItems: e.minItems,
        length: n.length,
        pointer: r,
        schema: e,
        value: n
      });
  },
  minProperties: (t, e, n, r) => {
    if (isNaN(e.minProperties))
      return;
    const i = Object.keys(n).length;
    if (e.minProperties > i)
      return t.errors.minPropertiesError({
        minProperties: e.minProperties,
        length: i,
        pointer: r,
        schema: e,
        value: n
      });
  },
  multipleOf: (t, e, n, r) => {
    if (isNaN(e.multipleOf) || typeof n != "number")
      return;
    const i = n7(n), s = n7(e.multipleOf);
    if (i > s)
      return t.errors.multipleOfError({
        multipleOf: e.multipleOf,
        value: n,
        pointer: r,
        schema: e
      });
    const o = Math.pow(10, s), l = Math.round(n * o), a = Math.round(e.multipleOf * o);
    if (l % a / o !== 0)
      return t.errors.multipleOfError({
        multipleOf: e.multipleOf,
        value: n,
        pointer: r,
        schema: e
      });
  },
  not: (t, e, n, r) => {
    const i = [];
    return t.validate(n, e.not, r).length === 0 && i.push(t.errors.notError({ value: n, not: e.not, pointer: r, schema: e })), i;
  },
  oneOf: Tie,
  pattern: (t, e, n, r) => {
    if (new RegExp(e.pattern, "u").test(n) === !1)
      return t.errors.patternError({
        pattern: e.pattern,
        description: e.patternExample || e.pattern,
        received: n,
        schema: e,
        value: n,
        pointer: r
      });
  },
  patternProperties: (t, e, n, r) => {
    const i = e.properties || {}, s = e.patternProperties;
    if (Zt(s) !== "object")
      return;
    const o = [], l = Object.keys(n), a = Object.keys(s).map((u) => ({
      regex: new RegExp(u),
      patternSchema: s[u]
    }));
    return l.forEach((u) => {
      let c = !1;
      for (let f = 0, d = a.length; f < d; f += 1)
        if (a[f].regex.test(u)) {
          c = !0;
          const p = t.validate(n[u], a[f].patternSchema, `${r}/${u}`);
          p && p.length > 0 && o.push(...p);
        }
      i[u] || c === !1 && e.additionalProperties === !1 && o.push(t.errors.patternPropertiesError({
        key: u,
        pointer: r,
        schema: e,
        value: n,
        patterns: Object.keys(s).join(",")
      }));
    }), o;
  },
  properties: (t, e, n, r) => {
    const i = [], s = Object.keys(e.properties || {});
    for (let o = 0; o < s.length; o += 1) {
      const l = s[o];
      if (i7(n, l)) {
        const a = t.step(l, e, n, r), u = t.validate(n[l], a, `${r}/${l}`);
        i.push(...u);
      }
    }
    return i;
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword
  propertiesRequired: (t, e, n, r) => {
    const i = [], s = Object.keys(e.properties || {});
    for (let o = 0; o < s.length; o += 1) {
      const l = s[o];
      if (n[l] === void 0)
        i.push(t.errors.requiredPropertyError({ key: l, pointer: r, schema: e, value: n }));
      else {
        const a = t.step(l, e, n, r), u = t.validate(n[l], a, `${r}/${l}`);
        i.push(...u);
      }
    }
    return i;
  },
  required: (t, e, n, r) => {
    if (Array.isArray(e.required) !== !1)
      return e.required.map((i) => {
        if (!i7(n, i))
          return t.errors.requiredPropertyError({
            key: i,
            pointer: r,
            schema: e,
            value: n
          });
      });
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword
  requiredNotEmpty: (t, e, n, r) => {
    if (Array.isArray(e.required) !== !1)
      return e.required.map((i) => {
        if (n[i] == null || n[i] === "")
          return t.errors.valueNotEmptyError({
            property: i,
            pointer: `${r}/${i}`,
            schema: e,
            value: n
          });
      });
  },
  uniqueItems: (t, e, n, r) => {
    if ((Array.isArray(n) && e.uniqueItems) === !1)
      return;
    const i = [], s = [];
    return n.forEach((o, l) => {
      for (let a = l + 1; a < n.length; a += 1)
        _I(o, n[a]) && !i.includes(a) && (s.push(t.errors.uniqueItemsError({
          pointer: `${r}/${a}`,
          duplicatePointer: `${r}/${l}`,
          arrayPointer: r,
          value: JSON.stringify(o),
          schema: e
        })), i.push(a));
    }), s;
  }
};
function Dl(t) {
  if (t === void 0)
    return;
  const e = {
    type: Zt(t)
  };
  return e.type === "object" && Vu(t) && (e.properties = {}, Object.keys(t).forEach((n) => e.properties[n] = Dl(t[n]))), e.type === "array" && Array.isArray(t) && (t.length === 1 ? e.items = Dl(t[0]) : e.items = t.map(Dl)), e;
}
const Roe = {
  array: (t, e, n, r, i) => {
    const s = r?.[e], o = Zt(n.items);
    if (o === "object")
      return ID(t, n.items, s, `${i}/${e}`) || t.resolveRef(n.items);
    if (o === "array") {
      if (n.items[e] === !0)
        return Dl(s);
      if (n.items[e] === !1)
        return t.errors.invalidDataError({
          key: e,
          value: s,
          pointer: i,
          schema: n
        });
      if (n.items[e])
        return t.resolveRef(n.items[e]);
      if (n.additionalItems === !1)
        return t.errors.additionalItemsError({
          key: e,
          value: s,
          pointer: i,
          schema: n
        });
      if (n.additionalItems === !0 || n.additionalItems === void 0)
        return Dl(s);
      if (Zt(n.additionalItems) === "object")
        return n.additionalItems;
      throw new Error(`Invalid schema ${JSON.stringify(n, null, 2)} for ${JSON.stringify(r, null, 2)}`);
    }
    return n.additionalItems !== !1 && s ? Dl(s) : new Error(`Invalid array schema for ${e} at ${i}`);
  },
  object: (t, e, n, r, i) => {
    var s;
    n = ID(t, n, r, i);
    const o = (s = n?.properties) === null || s === void 0 ? void 0 : s[e];
    if (o !== void 0) {
      if (o === !1)
        return t.errors.forbiddenPropertyError({
          property: e,
          value: r,
          pointer: i,
          schema: n
        });
      if (o === !0)
        return Dl(r?.[e]);
      const u = t.resolveRef(o);
      if (mi(u))
        return u;
      if (u && Array.isArray(u.oneOf)) {
        const c = t.resolveOneOf(r[e], u, `${i}/${e}`);
        for (const f in u)
          f !== "oneOf" && c[f] === void 0 && (c[f] = u[f]);
        return c;
      }
      if (u)
        return u;
    }
    const { patternProperties: l } = n;
    if (Zt(l) === "object") {
      let u;
      const c = Object.keys(l);
      for (let f = 0, d = c.length; f < d; f += 1)
        if (u = new RegExp(c[f]), u.test(e))
          return l[c[f]];
    }
    const { additionalProperties: a } = n;
    return Zt(a) === "object" ? n.additionalProperties : r && (a === void 0 || a === !0) ? Dl(r[e]) : t.errors.unknownPropertyError({
      property: e,
      value: r,
      pointer: `${i}`,
      schema: n
    });
  }
};
function CI(t, e, n, r, i = "#") {
  var s;
  const o = Zt(r);
  let l = (s = n.type) !== null && s !== void 0 ? s : o;
  if (Array.isArray(l)) {
    if (!l.includes(o))
      return t.errors.typeError({
        value: r,
        pointer: i,
        expected: n.type,
        received: o,
        schema: n
      });
    l = o;
  }
  const a = Roe[l];
  if (a) {
    const u = a(t, `${e}`, n, r, i);
    return u === void 0 ? t.errors.schemaWarning({
      pointer: i,
      value: r,
      schema: n,
      key: e
    }) : u;
  }
  return new Error(`Unsupported schema type ${n.type} for key ${e}`);
}
function SI(t, e, n = t.rootSchema) {
  var r;
  if (n.oneOf)
    return n.oneOf.map((s) => t.resolveRef(s));
  if (!((r = n.items) === null || r === void 0) && r.oneOf)
    return n.items.oneOf.map((s) => t.resolveRef(s));
  const i = t.step(e, n, {}, "#");
  return mi(i) ? i : [i];
}
const Moe = {
  array: (t, e, n, r) => t.typeKeywords.array.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  object: (t, e, n, r) => t.typeKeywords.object.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  string: (t, e, n, r) => t.typeKeywords.string.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  integer: (t, e, n, r) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  number: (t, e, n, r) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  boolean: (t, e, n, r) => t.typeKeywords.boolean.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  null: (t, e, n, r) => t.typeKeywords.null.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r))
};
function Poe(t, e) {
  const n = Zt(t);
  return n === "number" && (e === "integer" || Array.isArray(e) && e.includes("integer")) ? Number.isInteger(t) || isNaN(t) ? "integer" : "number" : n;
}
function AI(t, e, n = t.rootSchema, r = "#") {
  if (n = t.resolveRef(n), Zt(n) === "boolean")
    return n ? [] : [t.errors.invalidDataError({ pointer: r, schema: n, value: e })];
  if (mi(n))
    return [n];
  if (n.const !== void 0)
    return _I(n.const, e) ? [] : [t.errors.constError({ pointer: r, schema: n, value: e, expected: n.const })];
  const i = Poe(e, n.type), s = n.type || i;
  return i !== s && (!Array.isArray(s) || !s.includes(i)) ? [
    t.errors.typeError({
      pointer: r,
      schema: n,
      value: e,
      received: i,
      expected: s
    })
  ] : t.validateType[i] == null ? [t.errors.invalidTypeError({ pointer: r, schema: n, value: e, receivedType: i })] : pg(t.validateType[i](t, n, e, r)).filter(Pb);
}
const Ioe = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "enum",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],
    object: [
      "additionalProperties",
      "dependencies",
      "enum",
      "format",
      "minProperties",
      "maxProperties",
      "patternProperties",
      "properties",
      "required",
      "not",
      "oneOf",
      "allOf",
      "anyOf"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: kI,
  validateType: Moe,
  validateFormat: gI,
  errors: pI,
  addRemoteSchema: cI,
  compileSchema: loe,
  createSchemaOf: Dl,
  each: dI,
  eachSchema: e2,
  getChildSchemaSelection: SI,
  getSchema: yI,
  getTemplate: xI,
  isValid: wI,
  resolveAllOf: rI,
  resolveAnyOf: aI,
  resolveOneOf: HP,
  resolveRef: sI,
  step: CI,
  validate: AI,
  templateDefaultOptions: e0.templateDefaultOptions
};
class EI extends uI {
  constructor(e, n = {}) {
    super(H6(Ioe, n), e);
  }
}
const s7 = "__compiled", o7 = "__ref", Noe = "getRef", Boe = "getRoot", Loe = /(#|\/)+$/g;
function $oe(t, e, n = e, r = !1) {
  if (e === !0 || e === !1 || e === void 0 || e[s7] !== void 0)
    return e;
  const i = { ids: {}, remotes: t.remotes }, s = JSON.stringify(e), o = JSON.parse(s);
  if (Object.defineProperty(o, s7, { enumerable: !1, value: !0 }), Object.defineProperty(o, Noe, {
    enumerable: !1,
    value: Oa.bind(null, i, o)
  }), r === !1 && s.includes("$ref") === !1)
    return o;
  o !== n && Object.defineProperty(o, "$defs", {
    enumerable: !0,
    value: Object.assign({}, n.definitions, n.$defs, o.definitions, o.$defs)
  });
  const l = {}, a = () => o;
  return e2(o, (u, c) => {
    var f;
    if (u.$id) {
      if (u.$id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(c)) {
        const b = c.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, ""), v = Hc.get(o, b);
        u.$id = (f = v.$id) !== null && f !== void 0 ? f : u.$id;
      }
      i.ids[u.$id.replace(Loe, "")] = c;
    }
    c = `#${c}`.replace(/##+/, "#");
    const d = c.replace(/\/[^/]+$/, ""), p = c.replace(/\/[^/]+\/[^/]+$/, ""), m = l[d] || l[p], y = $b(m, u.$id);
    l[c] = y, i.ids[y] == null && (i.ids[y] = c), u.$ref && !u[o7] && (Object.defineProperty(u, o7, {
      enumerable: !1,
      value: $b(y, u.$ref)
    }), Object.defineProperty(u, Boe, { enumerable: !1, value: a }));
  }), o;
}
const zoe = {
  ...kI,
  // @draft >= 6
  contains: (t, e, n, r) => {
    if (e.contains === !1)
      return t.errors.containsArrayError({ pointer: r, value: n, schema: e });
    if (e.contains === !0)
      return Array.isArray(n) && n.length === 0 ? t.errors.containsAnyError({ pointer: r, value: n, schema: e }) : void 0;
    if (Zt(e.contains) === "object") {
      for (let i = 0; i < n.length; i += 1)
        if (t.isValid(n[i], e.contains))
          return;
      return t.errors.containsError({ pointer: r, schema: e, value: n });
    }
  },
  exclusiveMaximum: (t, e, n, r) => {
    if (!isNaN(e.exclusiveMaximum) && e.exclusiveMaximum <= n)
      return t.errors.maximumError({
        maximum: e.exclusiveMaximum,
        length: n,
        pointer: r,
        schema: e,
        value: n
      });
  },
  exclusiveMinimum: (t, e, n, r) => {
    if (!isNaN(e.exclusiveMinimum) && e.exclusiveMinimum >= n)
      return t.errors.minimumError({
        minimum: e.exclusiveMinimum,
        length: n,
        pointer: r,
        schema: e,
        value: n
      });
  },
  // @feature if-then-else
  if: mse,
  maximum: (t, e, n, r) => {
    if (!isNaN(e.maximum) && e.maximum && e.maximum < n)
      return t.errors.maximumError({
        maximum: e.maximum,
        length: n,
        pointer: r,
        schema: e,
        value: n
      });
  },
  minimum: (t, e, n, r) => {
    if (!isNaN(e.minimum) && e.minimum > n)
      return t.errors.minimumError({
        minimum: e.minimum,
        length: n,
        pointer: r,
        schema: e,
        value: n
      });
  },
  patternProperties: (t, e, n, r) => {
    const i = e.properties || {}, s = e.patternProperties;
    if (Zt(s) !== "object")
      return;
    const o = [], l = Object.keys(n), a = Object.keys(s).map((u) => ({
      regex: new RegExp(u),
      patternSchema: s[u]
    }));
    return l.forEach((u) => {
      let c = !1;
      for (let f = 0, d = a.length; f < d; f += 1)
        if (a[f].regex.test(u)) {
          if (c = !0, a[f].patternSchema === !1) {
            o.push(t.errors.patternPropertiesError({
              key: u,
              pointer: r,
              patterns: Object.keys(s).join(","),
              schema: e,
              value: n
            }));
            return;
          }
          const p = t.validate(n[u], a[f].patternSchema, `${r}/${u}`);
          p && p.length > 0 && o.push(...p);
        }
      i[u] || c === !1 && e.additionalProperties === !1 && o.push(t.errors.patternPropertiesError({
        key: u,
        pointer: r,
        patterns: Object.keys(s).join(","),
        schema: e,
        value: n
      }));
    }), o;
  },
  // @draft >= 6
  propertyNames: (t, e, n, r) => {
    if (e.propertyNames === !1)
      return Object.keys(n).length === 0 ? void 0 : t.errors.invalidPropertyNameError({
        property: Object.keys(n),
        pointer: r,
        value: n,
        schema: e
      });
    if (e.propertyNames === !0 || Zt(e.propertyNames) !== "object")
      return;
    const i = [], s = Object.keys(n), o = { ...e.propertyNames, type: "string" };
    return s.forEach((l) => {
      const a = t.validate(l, o, `${r}/${l}`);
      a.length > 0 && i.push(t.errors.invalidPropertyNameError({
        property: l,
        pointer: r,
        validationError: a[0],
        value: n[l],
        schema: e
      }));
    }), i;
  }
}, joe = {
  array: (t, e, n, r) => t.typeKeywords.array.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  object: (t, e, n, r) => t.typeKeywords.object.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  string: (t, e, n, r) => t.typeKeywords.string.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  integer: (t, e, n, r) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  number: (t, e, n, r) => t.typeKeywords.number.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  boolean: (t, e, n, r) => t.typeKeywords.boolean.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r)),
  null: (t, e, n, r) => t.typeKeywords.null.filter((i) => e && e[i] != null).map((i) => t.validateKeyword[i](t, e, n, r))
}, DI = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: zoe,
  validateType: joe,
  validateFormat: gI,
  errors: pI,
  addRemoteSchema: cI,
  compileSchema: $oe,
  createSchemaOf: Dl,
  each: dI,
  eachSchema: e2,
  getChildSchemaSelection: SI,
  getSchema: yI,
  getTemplate: xI,
  isValid: wI,
  resolveAllOf: rI,
  resolveAnyOf: aI,
  resolveOneOf: HP,
  resolveRef: sI,
  step: CI,
  validate: AI,
  templateDefaultOptions: e0.templateDefaultOptions
};
class OI extends uI {
  constructor(e, n = {}) {
    super(H6(DI, n), e);
  }
}
({
  ...DI
});
function kl(t, e, n = []) {
  const r = document.createElement(t);
  return Object.entries(e).forEach(([i, s]) => {
    if (i === "text") {
      r.innerText = s;
      return;
    }
    if (i === "inner") {
      r.innerHTML = s;
      return;
    }
    r.setAttribute(i, s);
  }), n.forEach((i) => r.appendChild(i)), r;
}
const l7 = {};
function qoe(t) {
  let e = l7[t];
  if (e)
    return e;
  e = l7[t] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    e.push(r);
  }
  for (let n = 0; n < t.length; n++) {
    const r = t.charCodeAt(n);
    e[r] = "%" + ("0" + r.toString(16).toUpperCase()).slice(-2);
  }
  return e;
}
function Dd(t, e) {
  typeof e != "string" && (e = Dd.defaultChars);
  const n = qoe(e);
  return t.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    let i = "";
    for (let s = 0, o = r.length; s < o; s += 3) {
      const l = parseInt(r.slice(s + 1, s + 3), 16);
      if (l < 128) {
        i += n[l];
        continue;
      }
      if ((l & 224) === 192 && s + 3 < o) {
        const a = parseInt(r.slice(s + 4, s + 6), 16);
        if ((a & 192) === 128) {
          const u = l << 6 & 1984 | a & 63;
          u < 128 ? i += "ï¿½ï¿½" : i += String.fromCharCode(u), s += 3;
          continue;
        }
      }
      if ((l & 240) === 224 && s + 6 < o) {
        const a = parseInt(r.slice(s + 4, s + 6), 16), u = parseInt(r.slice(s + 7, s + 9), 16);
        if ((a & 192) === 128 && (u & 192) === 128) {
          const c = l << 12 & 61440 | a << 6 & 4032 | u & 63;
          c < 2048 || c >= 55296 && c <= 57343 ? i += "ï¿½ï¿½ï¿½" : i += String.fromCharCode(c), s += 6;
          continue;
        }
      }
      if ((l & 248) === 240 && s + 9 < o) {
        const a = parseInt(r.slice(s + 4, s + 6), 16), u = parseInt(r.slice(s + 7, s + 9), 16), c = parseInt(r.slice(s + 10, s + 12), 16);
        if ((a & 192) === 128 && (u & 192) === 128 && (c & 192) === 128) {
          let f = l << 18 & 1835008 | a << 12 & 258048 | u << 6 & 4032 | c & 63;
          f < 65536 || f > 1114111 ? i += "ï¿½ï¿½ï¿½ï¿½" : (f -= 65536, i += String.fromCharCode(55296 + (f >> 10), 56320 + (f & 1023))), s += 9;
          continue;
        }
      }
      i += "ï¿½";
    }
    return i;
  });
}
Dd.defaultChars = ";/?:@&=+$,#";
Dd.componentChars = "";
const a7 = {};
function Uoe(t) {
  let e = a7[t];
  if (e)
    return e;
  e = a7[t] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    /^[0-9a-z]$/i.test(r) ? e.push(r) : e.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
  }
  for (let n = 0; n < t.length; n++)
    e[t.charCodeAt(n)] = t[n];
  return e;
}
function sm(t, e, n) {
  typeof e != "string" && (n = e, e = sm.defaultChars), typeof n > "u" && (n = !0);
  const r = Uoe(e);
  let i = "";
  for (let s = 0, o = t.length; s < o; s++) {
    const l = t.charCodeAt(s);
    if (n && l === 37 && s + 2 < o && /^[0-9a-f]{2}$/i.test(t.slice(s + 1, s + 3))) {
      i += t.slice(s, s + 3), s += 2;
      continue;
    }
    if (l < 128) {
      i += r[l];
      continue;
    }
    if (l >= 55296 && l <= 57343) {
      if (l >= 55296 && l <= 56319 && s + 1 < o) {
        const a = t.charCodeAt(s + 1);
        if (a >= 56320 && a <= 57343) {
          i += encodeURIComponent(t[s] + t[s + 1]), s++;
          continue;
        }
      }
      i += "%EF%BF%BD";
      continue;
    }
    i += encodeURIComponent(t[s]);
  }
  return i;
}
sm.defaultChars = ";/?:@&=+$,-_.!~*'()#";
sm.componentChars = "-_.!~*'()";
function Y6(t) {
  let e = "";
  return e += t.protocol || "", e += t.slashes ? "//" : "", e += t.auth ? t.auth + "@" : "", t.hostname && t.hostname.indexOf(":") !== -1 ? e += "[" + t.hostname + "]" : e += t.hostname || "", e += t.port ? ":" + t.port : "", e += t.pathname || "", e += t.search || "", e += t.hash || "", e;
}
function zb() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const Hoe = /^([a-z0-9.+-]+:)/i, Voe = /:[0-9]*$/, Woe = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Goe = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Koe = ["{", "}", "|", "\\", "^", "`"].concat(Goe), Yoe = ["'"].concat(Koe), u7 = ["%", "/", "?", ";", "#"].concat(Yoe), c7 = ["/", "?", "#"], Xoe = 255, f7 = /^[+a-z0-9A-Z_-]{0,63}$/, Qoe = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, h7 = {
  javascript: !0,
  "javascript:": !0
}, d7 = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function X6(t, e) {
  if (t && t instanceof zb) return t;
  const n = new zb();
  return n.parse(t, e), n;
}
zb.prototype.parse = function(t, e) {
  let n, r, i, s = t;
  if (s = s.trim(), !e && t.split("#").length === 1) {
    const u = Woe.exec(s);
    if (u)
      return this.pathname = u[1], u[2] && (this.search = u[2]), this;
  }
  let o = Hoe.exec(s);
  if (o && (o = o[0], n = o.toLowerCase(), this.protocol = o, s = s.substr(o.length)), (e || o || s.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = s.substr(0, 2) === "//", i && !(o && h7[o]) && (s = s.substr(2), this.slashes = !0)), !h7[o] && (i || o && !d7[o])) {
    let u = -1;
    for (let m = 0; m < c7.length; m++)
      r = s.indexOf(c7[m]), r !== -1 && (u === -1 || r < u) && (u = r);
    let c, f;
    u === -1 ? f = s.lastIndexOf("@") : f = s.lastIndexOf("@", u), f !== -1 && (c = s.slice(0, f), s = s.slice(f + 1), this.auth = c), u = -1;
    for (let m = 0; m < u7.length; m++)
      r = s.indexOf(u7[m]), r !== -1 && (u === -1 || r < u) && (u = r);
    u === -1 && (u = s.length), s[u - 1] === ":" && u--;
    const d = s.slice(0, u);
    s = s.slice(u), this.parseHost(d), this.hostname = this.hostname || "";
    const p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      const m = this.hostname.split(/\./);
      for (let y = 0, b = m.length; y < b; y++) {
        const v = m[y];
        if (v && !v.match(f7)) {
          let _ = "";
          for (let k = 0, S = v.length; k < S; k++)
            v.charCodeAt(k) > 127 ? _ += "x" : _ += v[k];
          if (!_.match(f7)) {
            const k = m.slice(0, y), S = m.slice(y + 1), C = v.match(Qoe);
            C && (k.push(C[1]), S.unshift(C[2])), S.length && (s = S.join(".") + s), this.hostname = k.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > Xoe && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const l = s.indexOf("#");
  l !== -1 && (this.hash = s.substr(l), s = s.slice(0, l));
  const a = s.indexOf("?");
  return a !== -1 && (this.search = s.substr(a), s = s.slice(0, a)), s && (this.pathname = s), d7[n] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
zb.prototype.parseHost = function(t) {
  let e = Voe.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
const Joe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Dd,
  encode: sm,
  format: Y6,
  parse: X6
}, Symbol.toStringTag, { value: "Module" })), FI = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, TI = /[\0-\x1F\x7F-\x9F]/, Zoe = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, Q6 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, RI = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, MI = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, ele = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any: FI,
  Cc: TI,
  Cf: Zoe,
  P: Q6,
  S: RI,
  Z: MI
}, Symbol.toStringTag, { value: "Module" })), tle = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛžÞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿Žã€–ãŠºã˜¹ãž¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ð”„raveè€»Ã€äƒ€pha;äŽ‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ð”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ð’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ð€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;äŽ’r;ì€€ð”…pf;ì€€ð”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰ŽÜ€HOacdefhilorsuÅÅ‘Å–Æ€ÆžÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆŽÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;äŽ§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈžÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉŽ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ð’žpÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„Ž;ä”lÄ€;tËËžæˆ‡a;äŽ”r;ì€€ð”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ð…f;ì€€ð”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïžrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaÐ’ÐªÐ°ÑžÑ¿Í¼rrowÆ€;BUÐÐžÐ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ðº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥žectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ð’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓžÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ð”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ð”¼silon;äŽ•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;äŽ—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ð”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ð”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸äŽ“;äœreve;ä„žÆ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ð”Š;æ‹™pf;ì€€ð”¾eaterÌ€EFGLSTØµÙ„ÙŽÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ð’¢;æ‰«Ð€AacfiosuÚ…Ú‹Ú–Ú›ÚžÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äžirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜŽÜšÜžÜ¡Ü¨Ý„Ý¸Þ‹ÞÞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»ÃŽäƒŽ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´Ý‰\0Ý¢Ä€;eÝÝŽæˆ¬Ä€grÝ“Ý˜ral;æˆ«section;æ‹‚isibleÄ€CTÝ¬Ý²omma;æ£imes;æ¢Æ€gptÝ¿ÞƒÞˆon;ä„®f;ì€€ð•€a;äŽ™cr;æ„ilde;ä„¨Ç«Þš\0Þžcy;ä†lè€»ÃäƒÊ€cfosuÞ¬Þ·Þ¼ß‚ßÄ€iyÞ±Þµrc;ä„´;ä™r;ì€€ð”pf;ì€€ð•Ç£ß‡\0ßŒr;ì€€ð’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äŽšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ð”Žpf;ì€€ð•‚cr;ì€€ð’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;äŽ›g;æŸªlacetrf;æ„’r;æ†žÆ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢žæ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥ŽÄ€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ð”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§žà§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ð•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªÐ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªŽp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ð”nusPlus;æˆ“pf;ì€€ð•„cÃ²à©¶;äŽœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶žcy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ŽativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ð”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±žà²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰ŽÌ¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµŽsetÄ€;Eà´›à´žì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ð’©ildeè€»Ã‘äƒ‘;äŽÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·Žà·“rcè€»Ã”äƒ”;äžblac;ä…r;ì€€ð”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;äŽ©cron;äŽŸpf;ì€€ð•†enCurlyÄ€DQà¸Žà¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ð’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æžet;æŽ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ð”“i;äŽ¦;äŽ usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ð’«;äŽ¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ð””pf;æ„šcr;ì€€ð’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½Žà½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾Žement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;äŽ¡ghtÐ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€žæ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚žf;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„žá…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„Žá„“á„—æª¼ron;ä… dil;ä…žrc;ä…œ;ä¡r;ì€€ð”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ÐžeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;äŽ£allCircle;æˆ˜pf;ì€€ð•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†žsetÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ð’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡Žæ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰žá‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃžäƒžADE;æ„¢Ä€Hcá‰Žá‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;äŽ¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ð”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;äŽ˜Ä€cnáŠŽáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ð•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ð’¯rok;ä…¦à«¡á‹·áŒŽáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·áŽ…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äŽve;ä…¬Ä€iyáŒžáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ð”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æŽµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠŽÄ€gpá»á¿on;ä…²f;ì€€ð•ŒÐ€ADETadpsáŽ•áŽ®áŽ¸á„Ï¨á’á—á³rrowÆ€;BDá…áŽ áŽ¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRážá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;äŽ¥ing;ä…®cr;ì€€ð’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ð”™pf;ì€€ð•cr;ì€€ð’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ð”špf;ì€€ð•Žcr;ì€€ð’²È€fiosá“‹á“á“’á“˜r;ì€€ð”›;äŽžpf;ì€€ð•cr;ì€€ð’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ð”œpf;ì€€ð•cr;ì€€ð’´ml;ä…¸Ð€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;äŽ–r;æ„¨pf;æ„¤cr;ì€€ð’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ð”žraveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;äŽ±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜žá˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ð•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ð’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœžkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æŽ¶Ä€oyáœá;ä±quo;æ€žÊ€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;äŽ²;æ„¶een;æ‰¬r;ì€€ð”ŸgÎ€costuvwážážáž³áŸáŸ•áŸ›áŸžÆ€aiuáž”áž–ážšÃ°Ý rc;æ—¯pÂ»á±Æ€dptáž¤áž¨áž­ot;æ¨€lus;æ¨imes;æ¨‚É±áž¹\0\0áž¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡žá¡§á¡¬f;ì€€ð•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢Žá¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠžimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•ž;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ð’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ð” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«Žä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«žá«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ð•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ð’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹žc;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®žp;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯žá¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯Ž\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹Žedge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²žá²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;äŽ´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ð”¡arÄ€lrá²³á²µÂ»à£œÂ»á€žÊ€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒžop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ð••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶Žrn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ð’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ð©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½Žá½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸Žá¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ð”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ð•–Æ€alsá»„á»Žá»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäŽµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;äŽ·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾ž\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ð”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ð•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0âŽ;æ…š;æ…8;æ…žl;æ„wn;æŒ¢cr;ì€€ð’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†žÄ€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šäŽ³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ð”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„Žâ„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ð•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…Žâ…;æªŽ;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†ŽproÃ¸â‚žr;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆŽâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ð”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰žâ‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ð•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ð’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹Ž\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0âŽ†âŽªâŽ´cuteè€»Ã­äƒ­Æ€;iyÝ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ð”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ÞŽarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆžie;æ§doÃ´âŒ™Ê€;celpÝ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ð•ša;äŽ¹uestè€»Â¿ä‚¿Ä€ciâŽŠâŽr;ì€€ð’¾nÊ€;EdsvÓ´âŽ›âŽâŽ¡Ó³;æ‹¹ot;æ‹µÄ€;vâŽ¦âŽ§æ‹´;æ‹³Ä€;iÝ·âŽ®lde;ä„©Ç«âŽ¸\0âŽ¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ð”§ath;äˆ·pf;ì€€ð•›Ç£â¬\0â±r;ì€€ð’¿rcy;ä‘˜kcy;ä‘”Ð€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äŽº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ð”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ð•œcr;ì€€ð“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”Žâ”½â•šâ–€â™Žâ™žâ™¥â™¹â™½âššâš²â›˜ââ¨âž‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤ŽÄ€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;äŽ»gÆ€;dlà¢Žâ“â“ƒ;æ¦‘Ã¥à¢Ž;æª…uoè€»Â«ä‚«rÐ€;bfhlpstà¢™â“žâ“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—žrrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ð”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æŽ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›Žâ›æª‡Ä€;qâ›Žâš»im;æ‹¦Ð€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ð•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áŽÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼âž…âž‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âžƒ;æ¥­;æ€Žri;æŠ¿Ì€achiqtâž˜âžà©€âž¢âž®âž»quo;æ€¹r;ì€€ð“mÆ€;egà¦²âžªâž¬;æª;æªÄ€buâ”ªâž³oÄ€;rà¸Ÿâž¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â žÜ€Dacdefhilnopsuâ¡€â¡…â¢‚â¢Žâ¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡Žâ¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡žâ¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ð”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£žâ£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ð•žÄ€ctâ£¸â£½r;ì€€ð“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤äŽ¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡Ž;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦Žâ¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëžute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©Žar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ð”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«Žâ«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ð•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ð“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­äŽ½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²žâ²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§žÆ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·Ž\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªžâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ð”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;äŽ¿;æ¦¶pf;ì€€ð• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹ž\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astÐƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ÐƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ð”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜ŽÆ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„ŽÃ¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼Žä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ð•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»Žâ½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»ŽÆ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ð“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ð”®pf;ì€€ð•¢rime;æ—cr;ì€€ð“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„Žã„«ã…‡ã…¢ã…²ã†Žãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤žÃ«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼žÆ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦Ž;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈŽÈh;æ†³Æ€acgã…Žã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ð”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆžãˆŸæŽ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰Žr;æ¦†;ì€€ð•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ð“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§Žluhar;æ¥¨;æ„žàµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºãŽ¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âžºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãžã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ð”°È€acoyãŽ‚ãŽ†ãŽ‘ãŽ rp;æ™¯Ä€hyãŽ‹ãŽcy;ä‘‰;ä‘ˆrtÉ­ãŽ™\0\0ãŽœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmãŽ¨ãŽ´maÆ€;fvãŽ±ãŽ²ãŽ²äƒ;ä‚Ð€;deglnpráŠ«ã…ã‰ãŽã–ãžã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æªž;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ð•¤aÄ€drã‘Ð‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ð“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“Žã“•rÄ€;fã“”áž¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•žáˆ‰ã–‹ã–ŽÒ€;Edemnprsã”Žã”ã”‘ã”•ã”žã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”Žã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹Žã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ãž‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ð”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›äŽ¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠžÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ð•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãžÄ€ryã·ã»;ì€€ð“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioãž‹ãžŽxÃ´á·headÄ€lrãž—ãž eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã Žã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘žve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²áŽ­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ð”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ð•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡áŽ³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒŽng;ä…¯ri;æ—¹cr;ì€€ð“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Þ€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;háŽ·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ãŽ³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ð”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ð•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ð“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨žÂ»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ð”´pf;ì€€ð•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ð“Œà«£ážŽãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«Ž\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ð”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;äŽ¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptáž¤ãªµãª¾Ä€flãªºáž©;ì€€ð•©imÃ¥áž²Ä€Aaã«‡ã«ŠrÃ²ÏŽrÃ²à¨Ä€cqã«’áž¸r;ì€€ð“Ä€ptáŸ–ã«œrÃ©áŸ”Ð€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ð”¶cy;ä‘—pf;ì€€ð•ªcr;ì€€ð“ŽÄ€cmã¬¦ã¬©y;ä‘Žlè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;äŽ¶r;ì€€ð”·cy;ä¶grarr;æ‡pf;ì€€ð•«cr;ì€€ð“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((t) => t.charCodeAt(0))
), nle = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((t) => t.charCodeAt(0))
);
var i3;
const rle = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), ile = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (i3 = String.fromCodePoint) !== null && i3 !== void 0 ? i3 : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function sle(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = rle.get(t)) !== null && e !== void 0 ? e : t;
}
var Lr;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(Lr || (Lr = {}));
const ole = 32;
var Nu;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Nu || (Nu = {}));
function R4(t) {
  return t >= Lr.ZERO && t <= Lr.NINE;
}
function lle(t) {
  return t >= Lr.UPPER_A && t <= Lr.UPPER_F || t >= Lr.LOWER_A && t <= Lr.LOWER_F;
}
function ale(t) {
  return t >= Lr.UPPER_A && t <= Lr.UPPER_Z || t >= Lr.LOWER_A && t <= Lr.LOWER_Z || R4(t);
}
function ule(t) {
  return t === Lr.EQUALS || ale(t);
}
var Rr;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(Rr || (Rr = {}));
var Fu;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(Fu || (Fu = {}));
class cle {
  constructor(e, n, r) {
    this.decodeTree = e, this.emitCodePoint = n, this.errors = r, this.state = Rr.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Fu.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = Rr.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, n) {
    switch (this.state) {
      case Rr.EntityStart:
        return e.charCodeAt(n) === Lr.NUM ? (this.state = Rr.NumericStart, this.consumed += 1, this.stateNumericStart(e, n + 1)) : (this.state = Rr.NamedEntity, this.stateNamedEntity(e, n));
      case Rr.NumericStart:
        return this.stateNumericStart(e, n);
      case Rr.NumericDecimal:
        return this.stateNumericDecimal(e, n);
      case Rr.NumericHex:
        return this.stateNumericHex(e, n);
      case Rr.NamedEntity:
        return this.stateNamedEntity(e, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, n) {
    return n >= e.length ? -1 : (e.charCodeAt(n) | ole) === Lr.LOWER_X ? (this.state = Rr.NumericHex, this.consumed += 1, this.stateNumericHex(e, n + 1)) : (this.state = Rr.NumericDecimal, this.stateNumericDecimal(e, n));
  }
  addToNumericResult(e, n, r, i) {
    if (n !== r) {
      const s = r - n;
      this.result = this.result * Math.pow(i, s) + parseInt(e.substr(n, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (R4(i) || lle(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (R4(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === Lr.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Fu.Strict)
      return 0;
    return this.emitCodePoint(sle(this.result), this.consumed), this.errors && (e !== Lr.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], s = (i & Nu.VALUE_LENGTH) >> 14;
    for (; n < e.length; n++, this.excess++) {
      const o = e.charCodeAt(n);
      if (this.treeIndex = fle(r, i, this.treeIndex + Math.max(1, s), o), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Fu.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        ule(o)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], s = (i & Nu.VALUE_LENGTH) >> 14, s !== 0) {
        if (o === Lr.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== Fu.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: n, decodeTree: r } = this, i = (r[n] & Nu.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[e] & ~Nu.VALUE_LENGTH : i[e + 1], r), n === 3 && this.emitCodePoint(i[e + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case Rr.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Fu.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case Rr.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Rr.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Rr.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Rr.EntityStart:
        return 0;
    }
  }
}
function PI(t) {
  let e = "";
  const n = new cle(t, (r) => e += ile(r));
  return function(i, s) {
    let o = 0, l = 0;
    for (; (l = i.indexOf("&", l)) >= 0; ) {
      e += i.slice(o, l), n.startEntity(s);
      const u = n.write(
        i,
        // Skip the "&"
        l + 1
      );
      if (u < 0) {
        o = l + n.end();
        break;
      }
      o = l + u, l = u === 0 ? o + 1 : o;
    }
    const a = e + i.slice(o);
    return e = "", a;
  };
}
function fle(t, e, n, r) {
  const i = (e & Nu.BRANCH_LENGTH) >> 7, s = e & Nu.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && r === s ? n : -1;
  if (s) {
    const a = r - s;
    return a < 0 || a >= i ? -1 : t[n + a] - 1;
  }
  let o = n, l = o + i - 1;
  for (; o <= l; ) {
    const a = o + l >>> 1, u = t[a];
    if (u < r)
      o = a + 1;
    else if (u > r)
      l = a - 1;
    else
      return t[a + i];
  }
  return -1;
}
const hle = PI(tle);
PI(nle);
function II(t, e = Fu.Legacy) {
  return hle(t, e);
}
function dle(t) {
  return Object.prototype.toString.call(t);
}
function J6(t) {
  return dle(t) === "[object String]";
}
const ple = Object.prototype.hasOwnProperty;
function gle(t, e) {
  return ple.call(t, e);
}
function t2(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be object");
      Object.keys(n).forEach(function(r) {
        t[r] = n[r];
      });
    }
  }), t;
}
function NI(t, e, n) {
  return [].concat(t.slice(0, e), n, t.slice(e + 1));
}
function Z6(t) {
  return !(t >= 55296 && t <= 57343 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534 || t >= 0 && t <= 8 || t === 11 || t >= 14 && t <= 31 || t >= 127 && t <= 159 || t > 1114111);
}
function jb(t) {
  if (t > 65535) {
    t -= 65536;
    const e = 55296 + (t >> 10), n = 56320 + (t & 1023);
    return String.fromCharCode(e, n);
  }
  return String.fromCharCode(t);
}
const BI = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, mle = /&([a-z#][a-z0-9]{1,31});/gi, yle = new RegExp(BI.source + "|" + mle.source, "gi"), ble = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function vle(t, e) {
  if (e.charCodeAt(0) === 35 && ble.test(e)) {
    const r = e[1].toLowerCase() === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10);
    return Z6(r) ? jb(r) : t;
  }
  const n = II(t);
  return n !== t ? n : t;
}
function xle(t) {
  return t.indexOf("\\") < 0 ? t : t.replace(BI, "$1");
}
function Od(t) {
  return t.indexOf("\\") < 0 && t.indexOf("&") < 0 ? t : t.replace(yle, function(e, n, r) {
    return n || vle(e, r);
  });
}
const wle = /[&<>"]/, _le = /[&<>"]/g, kle = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function Cle(t) {
  return kle[t];
}
function ac(t) {
  return wle.test(t) ? t.replace(_le, Cle) : t;
}
const Sle = /[.?*+^$[\]\\(){}|-]/g;
function Ale(t) {
  return t.replace(Sle, "\\$&");
}
function In(t) {
  switch (t) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function yg(t) {
  if (t >= 8192 && t <= 8202)
    return !0;
  switch (t) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function bg(t) {
  return Q6.test(t) || RI.test(t);
}
function vg(t) {
  switch (t) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function n2(t) {
  return t = t.trim().replace(/\s+/g, " "), "áºž".toLowerCase() === "á¹¾" && (t = t.replace(/áºž/g, "ÃŸ")), t.toLowerCase().toUpperCase();
}
const Ele = { mdurl: Joe, ucmicro: ele }, Dle = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: NI,
  assign: t2,
  escapeHtml: ac,
  escapeRE: Ale,
  fromCodePoint: jb,
  has: gle,
  isMdAsciiPunct: vg,
  isPunctChar: bg,
  isSpace: In,
  isString: J6,
  isValidEntityCode: Z6,
  isWhiteSpace: yg,
  lib: Ele,
  normalizeReference: n2,
  unescapeAll: Od,
  unescapeMd: xle
}, Symbol.toStringTag, { value: "Module" }));
function Ole(t, e, n) {
  let r, i, s, o;
  const l = t.posMax, a = t.pos;
  for (t.pos = e + 1, r = 1; t.pos < l; ) {
    if (s = t.src.charCodeAt(t.pos), s === 93 && (r--, r === 0)) {
      i = !0;
      break;
    }
    if (o = t.pos, t.md.inline.skipToken(t), s === 91) {
      if (o === t.pos - 1)
        r++;
      else if (n)
        return t.pos = a, -1;
    }
  }
  let u = -1;
  return i && (u = t.pos), t.pos = a, u;
}
function Fle(t, e, n) {
  let r, i = e;
  const s = {
    ok: !1,
    pos: 0,
    str: ""
  };
  if (t.charCodeAt(i) === 60) {
    for (i++; i < n; ) {
      if (r = t.charCodeAt(i), r === 10 || r === 60)
        return s;
      if (r === 62)
        return s.pos = i + 1, s.str = Od(t.slice(e + 1, i)), s.ok = !0, s;
      if (r === 92 && i + 1 < n) {
        i += 2;
        continue;
      }
      i++;
    }
    return s;
  }
  let o = 0;
  for (; i < n && (r = t.charCodeAt(i), !(r === 32 || r < 32 || r === 127)); ) {
    if (r === 92 && i + 1 < n) {
      if (t.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (r === 40 && (o++, o > 32))
      return s;
    if (r === 41) {
      if (o === 0)
        break;
      o--;
    }
    i++;
  }
  return e === i || o !== 0 || (s.str = Od(t.slice(e, i)), s.pos = i, s.ok = !0), s;
}
function Tle(t, e, n, r) {
  let i, s = e;
  const o = {
    // if `true`, this is a valid link title
    ok: !1,
    // if `true`, this link can be continued on the next line
    can_continue: !1,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (r)
    o.str = r.str, o.marker = r.marker;
  else {
    if (s >= n)
      return o;
    let l = t.charCodeAt(s);
    if (l !== 34 && l !== 39 && l !== 40)
      return o;
    e++, s++, l === 40 && (l = 41), o.marker = l;
  }
  for (; s < n; ) {
    if (i = t.charCodeAt(s), i === o.marker)
      return o.pos = s + 1, o.str += Od(t.slice(e, s)), o.ok = !0, o;
    if (i === 40 && o.marker === 41)
      return o;
    i === 92 && s + 1 < n && s++, s++;
  }
  return o.can_continue = !0, o.str += Od(t.slice(e, s)), o;
}
const Rle = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination: Fle,
  parseLinkLabel: Ole,
  parseLinkTitle: Tle
}, Symbol.toStringTag, { value: "Module" })), la = {};
la.code_inline = function(t, e, n, r, i) {
  const s = t[e];
  return "<code" + i.renderAttrs(s) + ">" + ac(s.content) + "</code>";
};
la.code_block = function(t, e, n, r, i) {
  const s = t[e];
  return "<pre" + i.renderAttrs(s) + "><code>" + ac(t[e].content) + `</code></pre>
`;
};
la.fence = function(t, e, n, r, i) {
  const s = t[e], o = s.info ? Od(s.info).trim() : "";
  let l = "", a = "";
  if (o) {
    const c = o.split(/(\s+)/g);
    l = c[0], a = c.slice(2).join("");
  }
  let u;
  if (n.highlight ? u = n.highlight(s.content, l, a) || ac(s.content) : u = ac(s.content), u.indexOf("<pre") === 0)
    return u + `
`;
  if (o) {
    const c = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [];
    c < 0 ? f.push(["class", n.langPrefix + l]) : (f[c] = f[c].slice(), f[c][1] += " " + n.langPrefix + l);
    const d = {
      attrs: f
    };
    return `<pre><code${i.renderAttrs(d)}>${u}</code></pre>
`;
  }
  return `<pre><code${i.renderAttrs(s)}>${u}</code></pre>
`;
};
la.image = function(t, e, n, r, i) {
  const s = t[e];
  return s.attrs[s.attrIndex("alt")][1] = i.renderInlineAsText(s.children, n, r), i.renderToken(t, e, n);
};
la.hardbreak = function(t, e, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
la.softbreak = function(t, e, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
la.text = function(t, e) {
  return ac(t[e].content);
};
la.html_block = function(t, e) {
  return t[e].content;
};
la.html_inline = function(t, e) {
  return t[e].content;
};
function t0() {
  this.rules = t2({}, la);
}
t0.prototype.renderAttrs = function(e) {
  let n, r, i;
  if (!e.attrs)
    return "";
  for (i = "", n = 0, r = e.attrs.length; n < r; n++)
    i += " " + ac(e.attrs[n][0]) + '="' + ac(e.attrs[n][1]) + '"';
  return i;
};
t0.prototype.renderToken = function(e, n, r) {
  const i = e[n];
  let s = "";
  if (i.hidden)
    return "";
  i.block && i.nesting !== -1 && n && e[n - 1].hidden && (s += `
`), s += (i.nesting === -1 ? "</" : "<") + i.tag, s += this.renderAttrs(i), i.nesting === 0 && r.xhtmlOut && (s += " /");
  let o = !1;
  if (i.block && (o = !0, i.nesting === 1 && n + 1 < e.length)) {
    const l = e[n + 1];
    (l.type === "inline" || l.hidden || l.nesting === -1 && l.tag === i.tag) && (o = !1);
  }
  return s += o ? `>
` : ">", s;
};
t0.prototype.renderInline = function(t, e, n) {
  let r = "";
  const i = this.rules;
  for (let s = 0, o = t.length; s < o; s++) {
    const l = t[s].type;
    typeof i[l] < "u" ? r += i[l](t, s, e, n, this) : r += this.renderToken(t, s, e);
  }
  return r;
};
t0.prototype.renderInlineAsText = function(t, e, n) {
  let r = "";
  for (let i = 0, s = t.length; i < s; i++)
    switch (t[i].type) {
      case "text":
        r += t[i].content;
        break;
      case "image":
        r += this.renderInlineAsText(t[i].children, e, n);
        break;
      case "html_inline":
      case "html_block":
        r += t[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        r += `
`;
        break;
    }
  return r;
};
t0.prototype.render = function(t, e, n) {
  let r = "";
  const i = this.rules;
  for (let s = 0, o = t.length; s < o; s++) {
    const l = t[s].type;
    l === "inline" ? r += this.renderInline(t[s].children, e, n) : typeof i[l] < "u" ? r += i[l](t, s, e, n, this) : r += this.renderToken(t, s, e, n);
  }
  return r;
};
function fs() {
  this.__rules__ = [], this.__cache__ = null;
}
fs.prototype.__find__ = function(t) {
  for (let e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t)
      return e;
  return -1;
};
fs.prototype.__compile__ = function() {
  const t = this, e = [""];
  t.__rules__.forEach(function(n) {
    n.enabled && n.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), t.__cache__ = {}, e.forEach(function(n) {
    t.__cache__[n] = [], t.__rules__.forEach(function(r) {
      r.enabled && (n && r.alt.indexOf(n) < 0 || t.__cache__[n].push(r.fn));
    });
  });
};
fs.prototype.at = function(t, e, n) {
  const r = this.__find__(t), i = n || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__[r].fn = e, this.__rules__[r].alt = i.alt || [], this.__cache__ = null;
};
fs.prototype.before = function(t, e, n, r) {
  const i = this.__find__(t), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
fs.prototype.after = function(t, e, n, r) {
  const i = this.__find__(t), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i + 1, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
fs.prototype.push = function(t, e, n) {
  const r = n || {};
  this.__rules__.push({
    name: t,
    enabled: !0,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
fs.prototype.enable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const n = [];
  return t.forEach(function(r) {
    const i = this.__find__(r);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !0, n.push(r);
  }, this), this.__cache__ = null, n;
};
fs.prototype.enableOnly = function(t, e) {
  Array.isArray(t) || (t = [t]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(t, e);
};
fs.prototype.disable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const n = [];
  return t.forEach(function(r) {
    const i = this.__find__(r);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !1, n.push(r);
  }, this), this.__cache__ = null, n;
};
fs.prototype.getRules = function(t) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [];
};
function ol(t, e, n) {
  this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
ol.prototype.attrIndex = function(e) {
  if (!this.attrs)
    return -1;
  const n = this.attrs;
  for (let r = 0, i = n.length; r < i; r++)
    if (n[r][0] === e)
      return r;
  return -1;
};
ol.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
ol.prototype.attrSet = function(e, n) {
  const r = this.attrIndex(e), i = [e, n];
  r < 0 ? this.attrPush(i) : this.attrs[r] = i;
};
ol.prototype.attrGet = function(e) {
  const n = this.attrIndex(e);
  let r = null;
  return n >= 0 && (r = this.attrs[n][1]), r;
};
ol.prototype.attrJoin = function(e, n) {
  const r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, n]) : this.attrs[r][1] = this.attrs[r][1] + " " + n;
};
function LI(t, e, n) {
  this.src = t, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = e;
}
LI.prototype.Token = ol;
const Mle = /\r\n?|\n/g, Ple = /\0/g;
function Ile(t) {
  let e;
  e = t.src.replace(Mle, `
`), e = e.replace(Ple, "ï¿½"), t.src = e;
}
function Nle(t) {
  let e;
  t.inlineMode ? (e = new t.Token("inline", "", 0), e.content = t.src, e.map = [0, 1], e.children = [], t.tokens.push(e)) : t.md.block.parse(t.src, t.md, t.env, t.tokens);
}
function Ble(t) {
  const e = t.tokens;
  for (let n = 0, r = e.length; n < r; n++) {
    const i = e[n];
    i.type === "inline" && t.md.inline.parse(i.content, t.md, t.env, i.children);
  }
}
function Lle(t) {
  return /^<a[>\s]/i.test(t);
}
function $le(t) {
  return /^<\/a\s*>/i.test(t);
}
function zle(t) {
  const e = t.tokens;
  if (t.md.options.linkify)
    for (let n = 0, r = e.length; n < r; n++) {
      if (e[n].type !== "inline" || !t.md.linkify.pretest(e[n].content))
        continue;
      let i = e[n].children, s = 0;
      for (let o = i.length - 1; o >= 0; o--) {
        const l = i[o];
        if (l.type === "link_close") {
          for (o--; i[o].level !== l.level && i[o].type !== "link_open"; )
            o--;
          continue;
        }
        if (l.type === "html_inline" && (Lle(l.content) && s > 0 && s--, $le(l.content) && s++), !(s > 0) && l.type === "text" && t.md.linkify.test(l.content)) {
          const a = l.content;
          let u = t.md.linkify.match(a);
          const c = [];
          let f = l.level, d = 0;
          u.length > 0 && u[0].index === 0 && o > 0 && i[o - 1].type === "text_special" && (u = u.slice(1));
          for (let p = 0; p < u.length; p++) {
            const m = u[p].url, y = t.md.normalizeLink(m);
            if (!t.md.validateLink(y))
              continue;
            let b = u[p].text;
            u[p].schema ? u[p].schema === "mailto:" && !/^mailto:/i.test(b) ? b = t.md.normalizeLinkText("mailto:" + b).replace(/^mailto:/, "") : b = t.md.normalizeLinkText(b) : b = t.md.normalizeLinkText("http://" + b).replace(/^http:\/\//, "");
            const v = u[p].index;
            if (v > d) {
              const C = new t.Token("text", "", 0);
              C.content = a.slice(d, v), C.level = f, c.push(C);
            }
            const _ = new t.Token("link_open", "a", 1);
            _.attrs = [["href", y]], _.level = f++, _.markup = "linkify", _.info = "auto", c.push(_);
            const k = new t.Token("text", "", 0);
            k.content = b, k.level = f, c.push(k);
            const S = new t.Token("link_close", "a", -1);
            S.level = --f, S.markup = "linkify", S.info = "auto", c.push(S), d = u[p].lastIndex;
          }
          if (d < a.length) {
            const p = new t.Token("text", "", 0);
            p.content = a.slice(d), p.level = f, c.push(p);
          }
          e[n].children = i = NI(i, o, c);
        }
      }
    }
}
const $I = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, jle = /\((c|tm|r)\)/i, qle = /\((c|tm|r)\)/ig, Ule = {
  c: "Â©",
  r: "Â®",
  tm: "â„¢"
};
function Hle(t, e) {
  return Ule[e.toLowerCase()];
}
function Vle(t) {
  let e = 0;
  for (let n = t.length - 1; n >= 0; n--) {
    const r = t[n];
    r.type === "text" && !e && (r.content = r.content.replace(qle, Hle)), r.type === "link_open" && r.info === "auto" && e--, r.type === "link_close" && r.info === "auto" && e++;
  }
}
function Wle(t) {
  let e = 0;
  for (let n = t.length - 1; n >= 0; n--) {
    const r = t[n];
    r.type === "text" && !e && $I.test(r.content) && (r.content = r.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“")), r.type === "link_open" && r.info === "auto" && e--, r.type === "link_close" && r.info === "auto" && e++;
  }
}
function Gle(t) {
  let e;
  if (t.md.options.typographer)
    for (e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type === "inline" && (jle.test(t.tokens[e].content) && Vle(t.tokens[e].children), $I.test(t.tokens[e].content) && Wle(t.tokens[e].children));
}
const Kle = /['"]/, p7 = /['"]/g, g7 = "â€™";
function Q1(t, e, n) {
  return t.slice(0, e) + n + t.slice(e + 1);
}
function Yle(t, e) {
  let n;
  const r = [];
  for (let i = 0; i < t.length; i++) {
    const s = t[i], o = t[i].level;
    for (n = r.length - 1; n >= 0 && !(r[n].level <= o); n--)
      ;
    if (r.length = n + 1, s.type !== "text")
      continue;
    let l = s.content, a = 0, u = l.length;
    e:
      for (; a < u; ) {
        p7.lastIndex = a;
        const c = p7.exec(l);
        if (!c)
          break;
        let f = !0, d = !0;
        a = c.index + 1;
        const p = c[0] === "'";
        let m = 32;
        if (c.index - 1 >= 0)
          m = l.charCodeAt(c.index - 1);
        else
          for (n = i - 1; n >= 0 && !(t[n].type === "softbreak" || t[n].type === "hardbreak"); n--)
            if (t[n].content) {
              m = t[n].content.charCodeAt(t[n].content.length - 1);
              break;
            }
        let y = 32;
        if (a < u)
          y = l.charCodeAt(a);
        else
          for (n = i + 1; n < t.length && !(t[n].type === "softbreak" || t[n].type === "hardbreak"); n++)
            if (t[n].content) {
              y = t[n].content.charCodeAt(0);
              break;
            }
        const b = vg(m) || bg(String.fromCharCode(m)), v = vg(y) || bg(String.fromCharCode(y)), _ = yg(m), k = yg(y);
        if (k ? f = !1 : v && (_ || b || (f = !1)), _ ? d = !1 : b && (k || v || (d = !1)), y === 34 && c[0] === '"' && m >= 48 && m <= 57 && (d = f = !1), f && d && (f = b, d = v), !f && !d) {
          p && (s.content = Q1(s.content, c.index, g7));
          continue;
        }
        if (d)
          for (n = r.length - 1; n >= 0; n--) {
            let S = r[n];
            if (r[n].level < o)
              break;
            if (S.single === p && r[n].level === o) {
              S = r[n];
              let C, E;
              p ? (C = e.md.options.quotes[2], E = e.md.options.quotes[3]) : (C = e.md.options.quotes[0], E = e.md.options.quotes[1]), s.content = Q1(s.content, c.index, E), t[S.token].content = Q1(
                t[S.token].content,
                S.pos,
                C
              ), a += E.length - 1, S.token === i && (a += C.length - 1), l = s.content, u = l.length, r.length = n;
              continue e;
            }
          }
        f ? r.push({
          token: i,
          pos: c.index,
          single: p,
          level: o
        }) : d && p && (s.content = Q1(s.content, c.index, g7));
      }
  }
}
function Xle(t) {
  if (t.md.options.typographer)
    for (let e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type !== "inline" || !Kle.test(t.tokens[e].content) || Yle(t.tokens[e].children, t);
}
function Qle(t) {
  let e, n;
  const r = t.tokens, i = r.length;
  for (let s = 0; s < i; s++) {
    if (r[s].type !== "inline") continue;
    const o = r[s].children, l = o.length;
    for (e = 0; e < l; e++)
      o[e].type === "text_special" && (o[e].type = "text");
    for (e = n = 0; e < l; e++)
      o[e].type === "text" && e + 1 < l && o[e + 1].type === "text" ? o[e + 1].content = o[e].content + o[e + 1].content : (e !== n && (o[n] = o[e]), n++);
    e !== n && (o.length = n);
  }
}
const s3 = [
  ["normalize", Ile],
  ["block", Nle],
  ["inline", Ble],
  ["linkify", zle],
  ["replacements", Gle],
  ["smartquotes", Xle],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", Qle]
];
function e5() {
  this.ruler = new fs();
  for (let t = 0; t < s3.length; t++)
    this.ruler.push(s3[t][0], s3[t][1]);
}
e5.prototype.process = function(t) {
  const e = this.ruler.getRules("");
  for (let n = 0, r = e.length; n < r; n++)
    e[n](t);
};
e5.prototype.State = LI;
function aa(t, e, n, r) {
  this.src = t, this.md = e, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const i = this.src;
  for (let s = 0, o = 0, l = 0, a = 0, u = i.length, c = !1; o < u; o++) {
    const f = i.charCodeAt(o);
    if (!c)
      if (In(f)) {
        l++, f === 9 ? a += 4 - a % 4 : a++;
        continue;
      } else
        c = !0;
    (f === 10 || o === u - 1) && (f !== 10 && o++, this.bMarks.push(s), this.eMarks.push(o), this.tShift.push(l), this.sCount.push(a), this.bsCount.push(0), c = !1, l = 0, a = 0, s = o + 1);
  }
  this.bMarks.push(i.length), this.eMarks.push(i.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
aa.prototype.push = function(t, e, n) {
  const r = new ol(t, e, n);
  return r.block = !0, n < 0 && this.level--, r.level = this.level, n > 0 && this.level++, this.tokens.push(r), r;
};
aa.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
aa.prototype.skipEmptyLines = function(e) {
  for (let n = this.lineMax; e < n && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
aa.prototype.skipSpaces = function(e) {
  for (let n = this.src.length; e < n; e++) {
    const r = this.src.charCodeAt(e);
    if (!In(r))
      break;
  }
  return e;
};
aa.prototype.skipSpacesBack = function(e, n) {
  if (e <= n)
    return e;
  for (; e > n; )
    if (!In(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
aa.prototype.skipChars = function(e, n) {
  for (let r = this.src.length; e < r && this.src.charCodeAt(e) === n; e++)
    ;
  return e;
};
aa.prototype.skipCharsBack = function(e, n, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (n !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
aa.prototype.getLines = function(e, n, r, i) {
  if (e >= n)
    return "";
  const s = new Array(n - e);
  for (let o = 0, l = e; l < n; l++, o++) {
    let a = 0;
    const u = this.bMarks[l];
    let c = u, f;
    for (l + 1 < n || i ? f = this.eMarks[l] + 1 : f = this.eMarks[l]; c < f && a < r; ) {
      const d = this.src.charCodeAt(c);
      if (In(d))
        d === 9 ? a += 4 - (a + this.bsCount[l]) % 4 : a++;
      else if (c - u < this.tShift[l])
        a++;
      else
        break;
      c++;
    }
    a > r ? s[o] = new Array(a - r + 1).join(" ") + this.src.slice(c, f) : s[o] = this.src.slice(c, f);
  }
  return s.join("");
};
aa.prototype.Token = ol;
const Jle = 65536;
function o3(t, e) {
  const n = t.bMarks[e] + t.tShift[e], r = t.eMarks[e];
  return t.src.slice(n, r);
}
function m7(t) {
  const e = [], n = t.length;
  let r = 0, i = t.charCodeAt(r), s = !1, o = 0, l = "";
  for (; r < n; )
    i === 124 && (s ? (l += t.substring(o, r - 1), o = r) : (e.push(l + t.substring(o, r)), l = "", o = r + 1)), s = i === 92, r++, i = t.charCodeAt(r);
  return e.push(l + t.substring(o)), e;
}
function Zle(t, e, n, r) {
  if (e + 2 > n)
    return !1;
  let i = e + 1;
  if (t.sCount[i] < t.blkIndent || t.sCount[i] - t.blkIndent >= 4)
    return !1;
  let s = t.bMarks[i] + t.tShift[i];
  if (s >= t.eMarks[i])
    return !1;
  const o = t.src.charCodeAt(s++);
  if (o !== 124 && o !== 45 && o !== 58 || s >= t.eMarks[i])
    return !1;
  const l = t.src.charCodeAt(s++);
  if (l !== 124 && l !== 45 && l !== 58 && !In(l) || o === 45 && In(l))
    return !1;
  for (; s < t.eMarks[i]; ) {
    const S = t.src.charCodeAt(s);
    if (S !== 124 && S !== 45 && S !== 58 && !In(S))
      return !1;
    s++;
  }
  let a = o3(t, e + 1), u = a.split("|");
  const c = [];
  for (let S = 0; S < u.length; S++) {
    const C = u[S].trim();
    if (!C) {
      if (S === 0 || S === u.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(C))
      return !1;
    C.charCodeAt(C.length - 1) === 58 ? c.push(C.charCodeAt(0) === 58 ? "center" : "right") : C.charCodeAt(0) === 58 ? c.push("left") : c.push("");
  }
  if (a = o3(t, e).trim(), a.indexOf("|") === -1 || t.sCount[e] - t.blkIndent >= 4)
    return !1;
  u = m7(a), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop();
  const f = u.length;
  if (f === 0 || f !== c.length)
    return !1;
  if (r)
    return !0;
  const d = t.parentType;
  t.parentType = "table";
  const p = t.md.block.ruler.getRules("blockquote"), m = t.push("table_open", "table", 1), y = [e, 0];
  m.map = y;
  const b = t.push("thead_open", "thead", 1);
  b.map = [e, e + 1];
  const v = t.push("tr_open", "tr", 1);
  v.map = [e, e + 1];
  for (let S = 0; S < u.length; S++) {
    const C = t.push("th_open", "th", 1);
    c[S] && (C.attrs = [["style", "text-align:" + c[S]]]);
    const E = t.push("inline", "", 0);
    E.content = u[S].trim(), E.children = [], t.push("th_close", "th", -1);
  }
  t.push("tr_close", "tr", -1), t.push("thead_close", "thead", -1);
  let _, k = 0;
  for (i = e + 2; i < n && !(t.sCount[i] < t.blkIndent); i++) {
    let S = !1;
    for (let E = 0, A = p.length; E < A; E++)
      if (p[E](t, i, n, !0)) {
        S = !0;
        break;
      }
    if (S || (a = o3(t, i).trim(), !a) || t.sCount[i] - t.blkIndent >= 4 || (u = m7(a), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), k += f - u.length, k > Jle))
      break;
    if (i === e + 2) {
      const E = t.push("tbody_open", "tbody", 1);
      E.map = _ = [e + 2, 0];
    }
    const C = t.push("tr_open", "tr", 1);
    C.map = [i, i + 1];
    for (let E = 0; E < f; E++) {
      const A = t.push("td_open", "td", 1);
      c[E] && (A.attrs = [["style", "text-align:" + c[E]]]);
      const O = t.push("inline", "", 0);
      O.content = u[E] ? u[E].trim() : "", O.children = [], t.push("td_close", "td", -1);
    }
    t.push("tr_close", "tr", -1);
  }
  return _ && (t.push("tbody_close", "tbody", -1), _[1] = i), t.push("table_close", "table", -1), y[1] = i, t.parentType = d, t.line = i, !0;
}
function eae(t, e, n) {
  if (t.sCount[e] - t.blkIndent < 4)
    return !1;
  let r = e + 1, i = r;
  for (; r < n; ) {
    if (t.isEmpty(r)) {
      r++;
      continue;
    }
    if (t.sCount[r] - t.blkIndent >= 4) {
      r++, i = r;
      continue;
    }
    break;
  }
  t.line = i;
  const s = t.push("code_block", "code", 0);
  return s.content = t.getLines(e, i, 4 + t.blkIndent, !1) + `
`, s.map = [e, t.line], !0;
}
function tae(t, e, n, r) {
  let i = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || i + 3 > s)
    return !1;
  const o = t.src.charCodeAt(i);
  if (o !== 126 && o !== 96)
    return !1;
  let l = i;
  i = t.skipChars(i, o);
  let a = i - l;
  if (a < 3)
    return !1;
  const u = t.src.slice(l, i), c = t.src.slice(i, s);
  if (o === 96 && c.indexOf(String.fromCharCode(o)) >= 0)
    return !1;
  if (r)
    return !0;
  let f = e, d = !1;
  for (; f++, !(f >= n || (i = l = t.bMarks[f] + t.tShift[f], s = t.eMarks[f], i < s && t.sCount[f] < t.blkIndent)); )
    if (t.src.charCodeAt(i) === o && !(t.sCount[f] - t.blkIndent >= 4) && (i = t.skipChars(i, o), !(i - l < a) && (i = t.skipSpaces(i), !(i < s)))) {
      d = !0;
      break;
    }
  a = t.sCount[e], t.line = f + (d ? 1 : 0);
  const p = t.push("fence", "code", 0);
  return p.info = c, p.content = t.getLines(e + 1, f, a, !0), p.markup = u, p.map = [e, t.line], !0;
}
function nae(t, e, n, r) {
  let i = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  const o = t.lineMax;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 62)
    return !1;
  if (r)
    return !0;
  const l = [], a = [], u = [], c = [], f = t.md.block.ruler.getRules("blockquote"), d = t.parentType;
  t.parentType = "blockquote";
  let p = !1, m;
  for (m = e; m < n; m++) {
    const k = t.sCount[m] < t.blkIndent;
    if (i = t.bMarks[m] + t.tShift[m], s = t.eMarks[m], i >= s)
      break;
    if (t.src.charCodeAt(i++) === 62 && !k) {
      let C = t.sCount[m] + 1, E, A;
      t.src.charCodeAt(i) === 32 ? (i++, C++, A = !1, E = !0) : t.src.charCodeAt(i) === 9 ? (E = !0, (t.bsCount[m] + C) % 4 === 3 ? (i++, C++, A = !1) : A = !0) : E = !1;
      let O = C;
      for (l.push(t.bMarks[m]), t.bMarks[m] = i; i < s; ) {
        const T = t.src.charCodeAt(i);
        if (In(T))
          T === 9 ? O += 4 - (O + t.bsCount[m] + (A ? 1 : 0)) % 4 : O++;
        else
          break;
        i++;
      }
      p = i >= s, a.push(t.bsCount[m]), t.bsCount[m] = t.sCount[m] + 1 + (E ? 1 : 0), u.push(t.sCount[m]), t.sCount[m] = O - C, c.push(t.tShift[m]), t.tShift[m] = i - t.bMarks[m];
      continue;
    }
    if (p)
      break;
    let S = !1;
    for (let C = 0, E = f.length; C < E; C++)
      if (f[C](t, m, n, !0)) {
        S = !0;
        break;
      }
    if (S) {
      t.lineMax = m, t.blkIndent !== 0 && (l.push(t.bMarks[m]), a.push(t.bsCount[m]), c.push(t.tShift[m]), u.push(t.sCount[m]), t.sCount[m] -= t.blkIndent);
      break;
    }
    l.push(t.bMarks[m]), a.push(t.bsCount[m]), c.push(t.tShift[m]), u.push(t.sCount[m]), t.sCount[m] = -1;
  }
  const y = t.blkIndent;
  t.blkIndent = 0;
  const b = t.push("blockquote_open", "blockquote", 1);
  b.markup = ">";
  const v = [e, 0];
  b.map = v, t.md.block.tokenize(t, e, m);
  const _ = t.push("blockquote_close", "blockquote", -1);
  _.markup = ">", t.lineMax = o, t.parentType = d, v[1] = t.line;
  for (let k = 0; k < c.length; k++)
    t.bMarks[k + e] = l[k], t.tShift[k + e] = c[k], t.sCount[k + e] = u[k], t.bsCount[k + e] = a[k];
  return t.blkIndent = y, !0;
}
function rae(t, e, n, r) {
  const i = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let s = t.bMarks[e] + t.tShift[e];
  const o = t.src.charCodeAt(s++);
  if (o !== 42 && o !== 45 && o !== 95)
    return !1;
  let l = 1;
  for (; s < i; ) {
    const u = t.src.charCodeAt(s++);
    if (u !== o && !In(u))
      return !1;
    u === o && l++;
  }
  if (l < 3)
    return !1;
  if (r)
    return !0;
  t.line = e + 1;
  const a = t.push("hr", "hr", 0);
  return a.map = [e, t.line], a.markup = Array(l + 1).join(String.fromCharCode(o)), !0;
}
function y7(t, e) {
  const n = t.eMarks[e];
  let r = t.bMarks[e] + t.tShift[e];
  const i = t.src.charCodeAt(r++);
  if (i !== 42 && i !== 45 && i !== 43)
    return -1;
  if (r < n) {
    const s = t.src.charCodeAt(r);
    if (!In(s))
      return -1;
  }
  return r;
}
function b7(t, e) {
  const n = t.bMarks[e] + t.tShift[e], r = t.eMarks[e];
  let i = n;
  if (i + 1 >= r)
    return -1;
  let s = t.src.charCodeAt(i++);
  if (s < 48 || s > 57)
    return -1;
  for (; ; ) {
    if (i >= r)
      return -1;
    if (s = t.src.charCodeAt(i++), s >= 48 && s <= 57) {
      if (i - n >= 10)
        return -1;
      continue;
    }
    if (s === 41 || s === 46)
      break;
    return -1;
  }
  return i < r && (s = t.src.charCodeAt(i), !In(s)) ? -1 : i;
}
function iae(t, e) {
  const n = t.level + 2;
  for (let r = e + 2, i = t.tokens.length - 2; r < i; r++)
    t.tokens[r].level === n && t.tokens[r].type === "paragraph_open" && (t.tokens[r + 2].hidden = !0, t.tokens[r].hidden = !0, r += 2);
}
function sae(t, e, n, r) {
  let i, s, o, l, a = e, u = !0;
  if (t.sCount[a] - t.blkIndent >= 4 || t.listIndent >= 0 && t.sCount[a] - t.listIndent >= 4 && t.sCount[a] < t.blkIndent)
    return !1;
  let c = !1;
  r && t.parentType === "paragraph" && t.sCount[a] >= t.blkIndent && (c = !0);
  let f, d, p;
  if ((p = b7(t, a)) >= 0) {
    if (f = !0, o = t.bMarks[a] + t.tShift[a], d = Number(t.src.slice(o, p - 1)), c && d !== 1) return !1;
  } else if ((p = y7(t, a)) >= 0)
    f = !1;
  else
    return !1;
  if (c && t.skipSpaces(p) >= t.eMarks[a])
    return !1;
  if (r)
    return !0;
  const m = t.src.charCodeAt(p - 1), y = t.tokens.length;
  f ? (l = t.push("ordered_list_open", "ol", 1), d !== 1 && (l.attrs = [["start", d]])) : l = t.push("bullet_list_open", "ul", 1);
  const b = [a, 0];
  l.map = b, l.markup = String.fromCharCode(m);
  let v = !1;
  const _ = t.md.block.ruler.getRules("list"), k = t.parentType;
  for (t.parentType = "list"; a < n; ) {
    s = p, i = t.eMarks[a];
    const S = t.sCount[a] + p - (t.bMarks[a] + t.tShift[a]);
    let C = S;
    for (; s < i; ) {
      const N = t.src.charCodeAt(s);
      if (N === 9)
        C += 4 - (C + t.bsCount[a]) % 4;
      else if (N === 32)
        C++;
      else
        break;
      s++;
    }
    const E = s;
    let A;
    E >= i ? A = 1 : A = C - S, A > 4 && (A = 1);
    const O = S + A;
    l = t.push("list_item_open", "li", 1), l.markup = String.fromCharCode(m);
    const T = [a, 0];
    l.map = T, f && (l.info = t.src.slice(o, p - 1));
    const $ = t.tight, P = t.tShift[a], B = t.sCount[a], M = t.listIndent;
    if (t.listIndent = t.blkIndent, t.blkIndent = O, t.tight = !0, t.tShift[a] = E - t.bMarks[a], t.sCount[a] = C, E >= i && t.isEmpty(a + 1) ? t.line = Math.min(t.line + 2, n) : t.md.block.tokenize(t, a, n, !0), (!t.tight || v) && (u = !1), v = t.line - a > 1 && t.isEmpty(t.line - 1), t.blkIndent = t.listIndent, t.listIndent = M, t.tShift[a] = P, t.sCount[a] = B, t.tight = $, l = t.push("list_item_close", "li", -1), l.markup = String.fromCharCode(m), a = t.line, T[1] = a, a >= n || t.sCount[a] < t.blkIndent || t.sCount[a] - t.blkIndent >= 4)
      break;
    let L = !1;
    for (let N = 0, j = _.length; N < j; N++)
      if (_[N](t, a, n, !0)) {
        L = !0;
        break;
      }
    if (L)
      break;
    if (f) {
      if (p = b7(t, a), p < 0)
        break;
      o = t.bMarks[a] + t.tShift[a];
    } else if (p = y7(t, a), p < 0)
      break;
    if (m !== t.src.charCodeAt(p - 1))
      break;
  }
  return f ? l = t.push("ordered_list_close", "ol", -1) : l = t.push("bullet_list_close", "ul", -1), l.markup = String.fromCharCode(m), b[1] = a, t.line = a, t.parentType = k, u && iae(t, y), !0;
}
function oae(t, e, n, r) {
  let i = t.bMarks[e] + t.tShift[e], s = t.eMarks[e], o = e + 1;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 91)
    return !1;
  function l(_) {
    const k = t.lineMax;
    if (_ >= k || t.isEmpty(_))
      return null;
    let S = !1;
    if (t.sCount[_] - t.blkIndent > 3 && (S = !0), t.sCount[_] < 0 && (S = !0), !S) {
      const A = t.md.block.ruler.getRules("reference"), O = t.parentType;
      t.parentType = "reference";
      let T = !1;
      for (let $ = 0, P = A.length; $ < P; $++)
        if (A[$](t, _, k, !0)) {
          T = !0;
          break;
        }
      if (t.parentType = O, T)
        return null;
    }
    const C = t.bMarks[_] + t.tShift[_], E = t.eMarks[_];
    return t.src.slice(C, E + 1);
  }
  let a = t.src.slice(i, s + 1);
  s = a.length;
  let u = -1;
  for (i = 1; i < s; i++) {
    const _ = a.charCodeAt(i);
    if (_ === 91)
      return !1;
    if (_ === 93) {
      u = i;
      break;
    } else if (_ === 10) {
      const k = l(o);
      k !== null && (a += k, s = a.length, o++);
    } else if (_ === 92 && (i++, i < s && a.charCodeAt(i) === 10)) {
      const k = l(o);
      k !== null && (a += k, s = a.length, o++);
    }
  }
  if (u < 0 || a.charCodeAt(u + 1) !== 58)
    return !1;
  for (i = u + 2; i < s; i++) {
    const _ = a.charCodeAt(i);
    if (_ === 10) {
      const k = l(o);
      k !== null && (a += k, s = a.length, o++);
    } else if (!In(_)) break;
  }
  const c = t.md.helpers.parseLinkDestination(a, i, s);
  if (!c.ok)
    return !1;
  const f = t.md.normalizeLink(c.str);
  if (!t.md.validateLink(f))
    return !1;
  i = c.pos;
  const d = i, p = o, m = i;
  for (; i < s; i++) {
    const _ = a.charCodeAt(i);
    if (_ === 10) {
      const k = l(o);
      k !== null && (a += k, s = a.length, o++);
    } else if (!In(_)) break;
  }
  let y = t.md.helpers.parseLinkTitle(a, i, s);
  for (; y.can_continue; ) {
    const _ = l(o);
    if (_ === null) break;
    a += _, i = s, s = a.length, o++, y = t.md.helpers.parseLinkTitle(a, i, s, y);
  }
  let b;
  for (i < s && m !== i && y.ok ? (b = y.str, i = y.pos) : (b = "", i = d, o = p); i < s; ) {
    const _ = a.charCodeAt(i);
    if (!In(_))
      break;
    i++;
  }
  if (i < s && a.charCodeAt(i) !== 10 && b)
    for (b = "", i = d, o = p; i < s; ) {
      const _ = a.charCodeAt(i);
      if (!In(_))
        break;
      i++;
    }
  if (i < s && a.charCodeAt(i) !== 10)
    return !1;
  const v = n2(a.slice(1, u));
  return v ? (r || (typeof t.env.references > "u" && (t.env.references = {}), typeof t.env.references[v] > "u" && (t.env.references[v] = { title: b, href: f }), t.line = o), !0) : !1;
}
const lae = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], aae = "[a-zA-Z_:][a-zA-Z0-9:._-]*", uae = "[^\"'=<>`\\x00-\\x20]+", cae = "'[^']*'", fae = '"[^"]*"', hae = "(?:" + uae + "|" + cae + "|" + fae + ")", dae = "(?:\\s+" + aae + "(?:\\s*=\\s*" + hae + ")?)", zI = "<[A-Za-z][A-Za-z0-9\\-]*" + dae + "*\\s*\\/?>", jI = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", pae = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", gae = "<[?][\\s\\S]*?[?]>", mae = "<![A-Za-z][^>]*>", yae = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", bae = new RegExp("^(?:" + zI + "|" + jI + "|" + pae + "|" + gae + "|" + mae + "|" + yae + ")"), vae = new RegExp("^(?:" + zI + "|" + jI + ")"), bh = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + lae.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(vae.source + "\\s*$"), /^$/, !1]
];
function xae(t, e, n, r) {
  let i = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || !t.md.options.html || t.src.charCodeAt(i) !== 60)
    return !1;
  let o = t.src.slice(i, s), l = 0;
  for (; l < bh.length && !bh[l][0].test(o); l++)
    ;
  if (l === bh.length)
    return !1;
  if (r)
    return bh[l][2];
  let a = e + 1;
  if (!bh[l][1].test(o)) {
    for (; a < n && !(t.sCount[a] < t.blkIndent); a++)
      if (i = t.bMarks[a] + t.tShift[a], s = t.eMarks[a], o = t.src.slice(i, s), bh[l][1].test(o)) {
        o.length !== 0 && a++;
        break;
      }
  }
  t.line = a;
  const u = t.push("html_block", "", 0);
  return u.map = [e, a], u.content = t.getLines(e, a, t.blkIndent, !0), !0;
}
function wae(t, e, n, r) {
  let i = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let o = t.src.charCodeAt(i);
  if (o !== 35 || i >= s)
    return !1;
  let l = 1;
  for (o = t.src.charCodeAt(++i); o === 35 && i < s && l <= 6; )
    l++, o = t.src.charCodeAt(++i);
  if (l > 6 || i < s && !In(o))
    return !1;
  if (r)
    return !0;
  s = t.skipSpacesBack(s, i);
  const a = t.skipCharsBack(s, 35, i);
  a > i && In(t.src.charCodeAt(a - 1)) && (s = a), t.line = e + 1;
  const u = t.push("heading_open", "h" + String(l), 1);
  u.markup = "########".slice(0, l), u.map = [e, t.line];
  const c = t.push("inline", "", 0);
  c.content = t.src.slice(i, s).trim(), c.map = [e, t.line], c.children = [];
  const f = t.push("heading_close", "h" + String(l), -1);
  return f.markup = "########".slice(0, l), !0;
}
function _ae(t, e, n) {
  const r = t.md.block.ruler.getRules("paragraph");
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  const i = t.parentType;
  t.parentType = "paragraph";
  let s = 0, o, l = e + 1;
  for (; l < n && !t.isEmpty(l); l++) {
    if (t.sCount[l] - t.blkIndent > 3)
      continue;
    if (t.sCount[l] >= t.blkIndent) {
      let p = t.bMarks[l] + t.tShift[l];
      const m = t.eMarks[l];
      if (p < m && (o = t.src.charCodeAt(p), (o === 45 || o === 61) && (p = t.skipChars(p, o), p = t.skipSpaces(p), p >= m))) {
        s = o === 61 ? 1 : 2;
        break;
      }
    }
    if (t.sCount[l] < 0)
      continue;
    let d = !1;
    for (let p = 0, m = r.length; p < m; p++)
      if (r[p](t, l, n, !0)) {
        d = !0;
        break;
      }
    if (d)
      break;
  }
  if (!s)
    return !1;
  const a = t.getLines(e, l, t.blkIndent, !1).trim();
  t.line = l + 1;
  const u = t.push("heading_open", "h" + String(s), 1);
  u.markup = String.fromCharCode(o), u.map = [e, t.line];
  const c = t.push("inline", "", 0);
  c.content = a, c.map = [e, t.line - 1], c.children = [];
  const f = t.push("heading_close", "h" + String(s), -1);
  return f.markup = String.fromCharCode(o), t.parentType = i, !0;
}
function kae(t, e, n) {
  const r = t.md.block.ruler.getRules("paragraph"), i = t.parentType;
  let s = e + 1;
  for (t.parentType = "paragraph"; s < n && !t.isEmpty(s); s++) {
    if (t.sCount[s] - t.blkIndent > 3 || t.sCount[s] < 0)
      continue;
    let u = !1;
    for (let c = 0, f = r.length; c < f; c++)
      if (r[c](t, s, n, !0)) {
        u = !0;
        break;
      }
    if (u)
      break;
  }
  const o = t.getLines(e, s, t.blkIndent, !1).trim();
  t.line = s;
  const l = t.push("paragraph_open", "p", 1);
  l.map = [e, t.line];
  const a = t.push("inline", "", 0);
  return a.content = o, a.map = [e, t.line], a.children = [], t.push("paragraph_close", "p", -1), t.parentType = i, !0;
}
const J1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", Zle, ["paragraph", "reference"]],
  ["code", eae],
  ["fence", tae, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", nae, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", rae, ["paragraph", "reference", "blockquote", "list"]],
  ["list", sae, ["paragraph", "reference", "blockquote"]],
  ["reference", oae],
  ["html_block", xae, ["paragraph", "reference", "blockquote"]],
  ["heading", wae, ["paragraph", "reference", "blockquote"]],
  ["lheading", _ae],
  ["paragraph", kae]
];
function r2() {
  this.ruler = new fs();
  for (let t = 0; t < J1.length; t++)
    this.ruler.push(J1[t][0], J1[t][1], { alt: (J1[t][2] || []).slice() });
}
r2.prototype.tokenize = function(t, e, n) {
  const r = this.ruler.getRules(""), i = r.length, s = t.md.options.maxNesting;
  let o = e, l = !1;
  for (; o < n && (t.line = o = t.skipEmptyLines(o), !(o >= n || t.sCount[o] < t.blkIndent)); ) {
    if (t.level >= s) {
      t.line = n;
      break;
    }
    const a = t.line;
    let u = !1;
    for (let c = 0; c < i; c++)
      if (u = r[c](t, o, n, !1), u) {
        if (a >= t.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!u) throw new Error("none of the block rules matched");
    t.tight = !l, t.isEmpty(t.line - 1) && (l = !0), o = t.line, o < n && t.isEmpty(o) && (l = !0, o++, t.line = o);
  }
};
r2.prototype.parse = function(t, e, n, r) {
  if (!t)
    return;
  const i = new this.State(t, e, n, r);
  this.tokenize(i, i.line, i.lineMax);
};
r2.prototype.State = aa;
function om(t, e, n, r) {
  this.src = t, this.env = n, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
om.prototype.pushPending = function() {
  const t = new ol("text", "", 0);
  return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t;
};
om.prototype.push = function(t, e, n) {
  this.pending && this.pushPending();
  const r = new ol(t, e, n);
  let i = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(i), r;
};
om.prototype.scanDelims = function(t, e) {
  const n = this.posMax, r = this.src.charCodeAt(t), i = t > 0 ? this.src.charCodeAt(t - 1) : 32;
  let s = t;
  for (; s < n && this.src.charCodeAt(s) === r; )
    s++;
  const o = s - t, l = s < n ? this.src.charCodeAt(s) : 32, a = vg(i) || bg(String.fromCharCode(i)), u = vg(l) || bg(String.fromCharCode(l)), c = yg(i), f = yg(l), d = !f && (!u || c || a), p = !c && (!a || f || u);
  return { can_open: d && (e || !p || a), can_close: p && (e || !d || u), length: o };
};
om.prototype.Token = ol;
function Cae(t) {
  switch (t) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function Sae(t, e) {
  let n = t.pos;
  for (; n < t.posMax && !Cae(t.src.charCodeAt(n)); )
    n++;
  return n === t.pos ? !1 : (e || (t.pending += t.src.slice(t.pos, n)), t.pos = n, !0);
}
const Aae = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function Eae(t, e) {
  if (!t.md.options.linkify || t.linkLevel > 0) return !1;
  const n = t.pos, r = t.posMax;
  if (n + 3 > r || t.src.charCodeAt(n) !== 58 || t.src.charCodeAt(n + 1) !== 47 || t.src.charCodeAt(n + 2) !== 47) return !1;
  const i = t.pending.match(Aae);
  if (!i) return !1;
  const s = i[1], o = t.md.linkify.matchAtStart(t.src.slice(n - s.length));
  if (!o) return !1;
  let l = o.url;
  if (l.length <= s.length) return !1;
  l = l.replace(/\*+$/, "");
  const a = t.md.normalizeLink(l);
  if (!t.md.validateLink(a)) return !1;
  if (!e) {
    t.pending = t.pending.slice(0, -s.length);
    const u = t.push("link_open", "a", 1);
    u.attrs = [["href", a]], u.markup = "linkify", u.info = "auto";
    const c = t.push("text", "", 0);
    c.content = t.md.normalizeLinkText(l);
    const f = t.push("link_close", "a", -1);
    f.markup = "linkify", f.info = "auto";
  }
  return t.pos += l.length - s.length, !0;
}
function Dae(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 10)
    return !1;
  const r = t.pending.length - 1, i = t.posMax;
  if (!e)
    if (r >= 0 && t.pending.charCodeAt(r) === 32)
      if (r >= 1 && t.pending.charCodeAt(r - 1) === 32) {
        let s = r - 1;
        for (; s >= 1 && t.pending.charCodeAt(s - 1) === 32; ) s--;
        t.pending = t.pending.slice(0, s), t.push("hardbreak", "br", 0);
      } else
        t.pending = t.pending.slice(0, -1), t.push("softbreak", "br", 0);
    else
      t.push("softbreak", "br", 0);
  for (n++; n < i && In(t.src.charCodeAt(n)); )
    n++;
  return t.pos = n, !0;
}
const t5 = [];
for (let t = 0; t < 256; t++)
  t5.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t) {
  t5[t.charCodeAt(0)] = 1;
});
function Oae(t, e) {
  let n = t.pos;
  const r = t.posMax;
  if (t.src.charCodeAt(n) !== 92 || (n++, n >= r)) return !1;
  let i = t.src.charCodeAt(n);
  if (i === 10) {
    for (e || t.push("hardbreak", "br", 0), n++; n < r && (i = t.src.charCodeAt(n), !!In(i)); )
      n++;
    return t.pos = n, !0;
  }
  let s = t.src[n];
  if (i >= 55296 && i <= 56319 && n + 1 < r) {
    const l = t.src.charCodeAt(n + 1);
    l >= 56320 && l <= 57343 && (s += t.src[n + 1], n++);
  }
  const o = "\\" + s;
  if (!e) {
    const l = t.push("text_special", "", 0);
    i < 256 && t5[i] !== 0 ? l.content = s : l.content = o, l.markup = o, l.info = "escape";
  }
  return t.pos = n + 1, !0;
}
function Fae(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 96)
    return !1;
  const i = n;
  n++;
  const s = t.posMax;
  for (; n < s && t.src.charCodeAt(n) === 96; )
    n++;
  const o = t.src.slice(i, n), l = o.length;
  if (t.backticksScanned && (t.backticks[l] || 0) <= i)
    return e || (t.pending += o), t.pos += l, !0;
  let a = n, u;
  for (; (u = t.src.indexOf("`", a)) !== -1; ) {
    for (a = u + 1; a < s && t.src.charCodeAt(a) === 96; )
      a++;
    const c = a - u;
    if (c === l) {
      if (!e) {
        const f = t.push("code_inline", "code", 0);
        f.markup = o, f.content = t.src.slice(n, u).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return t.pos = a, !0;
    }
    t.backticks[c] = u;
  }
  return t.backticksScanned = !0, e || (t.pending += o), t.pos += l, !0;
}
function Tae(t, e) {
  const n = t.pos, r = t.src.charCodeAt(n);
  if (e || r !== 126)
    return !1;
  const i = t.scanDelims(t.pos, !0);
  let s = i.length;
  const o = String.fromCharCode(r);
  if (s < 2)
    return !1;
  let l;
  s % 2 && (l = t.push("text", "", 0), l.content = o, s--);
  for (let a = 0; a < s; a += 2)
    l = t.push("text", "", 0), l.content = o + o, t.delimiters.push({
      marker: r,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: t.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return t.pos += i.length, !0;
}
function v7(t, e) {
  let n;
  const r = [], i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    if (o.marker !== 126 || o.end === -1)
      continue;
    const l = e[o.end];
    n = t.tokens[o.token], n.type = "s_open", n.tag = "s", n.nesting = 1, n.markup = "~~", n.content = "", n = t.tokens[l.token], n.type = "s_close", n.tag = "s", n.nesting = -1, n.markup = "~~", n.content = "", t.tokens[l.token - 1].type === "text" && t.tokens[l.token - 1].content === "~" && r.push(l.token - 1);
  }
  for (; r.length; ) {
    const s = r.pop();
    let o = s + 1;
    for (; o < t.tokens.length && t.tokens[o].type === "s_close"; )
      o++;
    o--, s !== o && (n = t.tokens[o], t.tokens[o] = t.tokens[s], t.tokens[s] = n);
  }
}
function Rae(t) {
  const e = t.tokens_meta, n = t.tokens_meta.length;
  v7(t, t.delimiters);
  for (let r = 0; r < n; r++)
    e[r] && e[r].delimiters && v7(t, e[r].delimiters);
}
const qI = {
  tokenize: Tae,
  postProcess: Rae
};
function Mae(t, e) {
  const n = t.pos, r = t.src.charCodeAt(n);
  if (e || r !== 95 && r !== 42)
    return !1;
  const i = t.scanDelims(t.pos, r === 42);
  for (let s = 0; s < i.length; s++) {
    const o = t.push("text", "", 0);
    o.content = String.fromCharCode(r), t.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: r,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: t.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  }
  return t.pos += i.length, !0;
}
function x7(t, e) {
  const n = e.length;
  for (let r = n - 1; r >= 0; r--) {
    const i = e[r];
    if (i.marker !== 95 && i.marker !== 42 || i.end === -1)
      continue;
    const s = e[i.end], o = r > 0 && e[r - 1].end === i.end + 1 && // check that first two markers match and adjacent
    e[r - 1].marker === i.marker && e[r - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[i.end + 1].token === s.token + 1, l = String.fromCharCode(i.marker), a = t.tokens[i.token];
    a.type = o ? "strong_open" : "em_open", a.tag = o ? "strong" : "em", a.nesting = 1, a.markup = o ? l + l : l, a.content = "";
    const u = t.tokens[s.token];
    u.type = o ? "strong_close" : "em_close", u.tag = o ? "strong" : "em", u.nesting = -1, u.markup = o ? l + l : l, u.content = "", o && (t.tokens[e[r - 1].token].content = "", t.tokens[e[i.end + 1].token].content = "", r--);
  }
}
function Pae(t) {
  const e = t.tokens_meta, n = t.tokens_meta.length;
  x7(t, t.delimiters);
  for (let r = 0; r < n; r++)
    e[r] && e[r].delimiters && x7(t, e[r].delimiters);
}
const UI = {
  tokenize: Mae,
  postProcess: Pae
};
function Iae(t, e) {
  let n, r, i, s, o = "", l = "", a = t.pos, u = !0;
  if (t.src.charCodeAt(t.pos) !== 91)
    return !1;
  const c = t.pos, f = t.posMax, d = t.pos + 1, p = t.md.helpers.parseLinkLabel(t, t.pos, !0);
  if (p < 0)
    return !1;
  let m = p + 1;
  if (m < f && t.src.charCodeAt(m) === 40) {
    for (u = !1, m++; m < f && (n = t.src.charCodeAt(m), !(!In(n) && n !== 10)); m++)
      ;
    if (m >= f)
      return !1;
    if (a = m, i = t.md.helpers.parseLinkDestination(t.src, m, t.posMax), i.ok) {
      for (o = t.md.normalizeLink(i.str), t.md.validateLink(o) ? m = i.pos : o = "", a = m; m < f && (n = t.src.charCodeAt(m), !(!In(n) && n !== 10)); m++)
        ;
      if (i = t.md.helpers.parseLinkTitle(t.src, m, t.posMax), m < f && a !== m && i.ok)
        for (l = i.str, m = i.pos; m < f && (n = t.src.charCodeAt(m), !(!In(n) && n !== 10)); m++)
          ;
    }
    (m >= f || t.src.charCodeAt(m) !== 41) && (u = !0), m++;
  }
  if (u) {
    if (typeof t.env.references > "u")
      return !1;
    if (m < f && t.src.charCodeAt(m) === 91 ? (a = m + 1, m = t.md.helpers.parseLinkLabel(t, m), m >= 0 ? r = t.src.slice(a, m++) : m = p + 1) : m = p + 1, r || (r = t.src.slice(d, p)), s = t.env.references[n2(r)], !s)
      return t.pos = c, !1;
    o = s.href, l = s.title;
  }
  if (!e) {
    t.pos = d, t.posMax = p;
    const y = t.push("link_open", "a", 1), b = [["href", o]];
    y.attrs = b, l && b.push(["title", l]), t.linkLevel++, t.md.inline.tokenize(t), t.linkLevel--, t.push("link_close", "a", -1);
  }
  return t.pos = m, t.posMax = f, !0;
}
function Nae(t, e) {
  let n, r, i, s, o, l, a, u, c = "";
  const f = t.pos, d = t.posMax;
  if (t.src.charCodeAt(t.pos) !== 33 || t.src.charCodeAt(t.pos + 1) !== 91)
    return !1;
  const p = t.pos + 2, m = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1);
  if (m < 0)
    return !1;
  if (s = m + 1, s < d && t.src.charCodeAt(s) === 40) {
    for (s++; s < d && (n = t.src.charCodeAt(s), !(!In(n) && n !== 10)); s++)
      ;
    if (s >= d)
      return !1;
    for (u = s, l = t.md.helpers.parseLinkDestination(t.src, s, t.posMax), l.ok && (c = t.md.normalizeLink(l.str), t.md.validateLink(c) ? s = l.pos : c = ""), u = s; s < d && (n = t.src.charCodeAt(s), !(!In(n) && n !== 10)); s++)
      ;
    if (l = t.md.helpers.parseLinkTitle(t.src, s, t.posMax), s < d && u !== s && l.ok)
      for (a = l.str, s = l.pos; s < d && (n = t.src.charCodeAt(s), !(!In(n) && n !== 10)); s++)
        ;
    else
      a = "";
    if (s >= d || t.src.charCodeAt(s) !== 41)
      return t.pos = f, !1;
    s++;
  } else {
    if (typeof t.env.references > "u")
      return !1;
    if (s < d && t.src.charCodeAt(s) === 91 ? (u = s + 1, s = t.md.helpers.parseLinkLabel(t, s), s >= 0 ? i = t.src.slice(u, s++) : s = m + 1) : s = m + 1, i || (i = t.src.slice(p, m)), o = t.env.references[n2(i)], !o)
      return t.pos = f, !1;
    c = o.href, a = o.title;
  }
  if (!e) {
    r = t.src.slice(p, m);
    const y = [];
    t.md.inline.parse(
      r,
      t.md,
      t.env,
      y
    );
    const b = t.push("image", "img", 0), v = [["src", c], ["alt", ""]];
    b.attrs = v, b.children = y, b.content = r, a && v.push(["title", a]);
  }
  return t.pos = s, t.posMax = d, !0;
}
const Bae = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, Lae = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function $ae(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 60)
    return !1;
  const r = t.pos, i = t.posMax;
  for (; ; ) {
    if (++n >= i) return !1;
    const o = t.src.charCodeAt(n);
    if (o === 60) return !1;
    if (o === 62) break;
  }
  const s = t.src.slice(r + 1, n);
  if (Lae.test(s)) {
    const o = t.md.normalizeLink(s);
    if (!t.md.validateLink(o))
      return !1;
    if (!e) {
      const l = t.push("link_open", "a", 1);
      l.attrs = [["href", o]], l.markup = "autolink", l.info = "auto";
      const a = t.push("text", "", 0);
      a.content = t.md.normalizeLinkText(s);
      const u = t.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return t.pos += s.length + 2, !0;
  }
  if (Bae.test(s)) {
    const o = t.md.normalizeLink("mailto:" + s);
    if (!t.md.validateLink(o))
      return !1;
    if (!e) {
      const l = t.push("link_open", "a", 1);
      l.attrs = [["href", o]], l.markup = "autolink", l.info = "auto";
      const a = t.push("text", "", 0);
      a.content = t.md.normalizeLinkText(s);
      const u = t.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return t.pos += s.length + 2, !0;
  }
  return !1;
}
function zae(t) {
  return /^<a[>\s]/i.test(t);
}
function jae(t) {
  return /^<\/a\s*>/i.test(t);
}
function qae(t) {
  const e = t | 32;
  return e >= 97 && e <= 122;
}
function Uae(t, e) {
  if (!t.md.options.html)
    return !1;
  const n = t.posMax, r = t.pos;
  if (t.src.charCodeAt(r) !== 60 || r + 2 >= n)
    return !1;
  const i = t.src.charCodeAt(r + 1);
  if (i !== 33 && i !== 63 && i !== 47 && !qae(i))
    return !1;
  const s = t.src.slice(r).match(bae);
  if (!s)
    return !1;
  if (!e) {
    const o = t.push("html_inline", "", 0);
    o.content = s[0], zae(o.content) && t.linkLevel++, jae(o.content) && t.linkLevel--;
  }
  return t.pos += s[0].length, !0;
}
const Hae = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, Vae = /^&([a-z][a-z0-9]{1,31});/i;
function Wae(t, e) {
  const n = t.pos, r = t.posMax;
  if (t.src.charCodeAt(n) !== 38 || n + 1 >= r) return !1;
  if (t.src.charCodeAt(n + 1) === 35) {
    const s = t.src.slice(n).match(Hae);
    if (s) {
      if (!e) {
        const o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), l = t.push("text_special", "", 0);
        l.content = Z6(o) ? jb(o) : jb(65533), l.markup = s[0], l.info = "entity";
      }
      return t.pos += s[0].length, !0;
    }
  } else {
    const s = t.src.slice(n).match(Vae);
    if (s) {
      const o = II(s[0]);
      if (o !== s[0]) {
        if (!e) {
          const l = t.push("text_special", "", 0);
          l.content = o, l.markup = s[0], l.info = "entity";
        }
        return t.pos += s[0].length, !0;
      }
    }
  }
  return !1;
}
function w7(t) {
  const e = {}, n = t.length;
  if (!n) return;
  let r = 0, i = -2;
  const s = [];
  for (let o = 0; o < n; o++) {
    const l = t[o];
    if (s.push(0), (t[r].marker !== l.marker || i !== l.token - 1) && (r = o), i = l.token, l.length = l.length || 0, !l.close) continue;
    e.hasOwnProperty(l.marker) || (e[l.marker] = [-1, -1, -1, -1, -1, -1]);
    const a = e[l.marker][(l.open ? 3 : 0) + l.length % 3];
    let u = r - s[r] - 1, c = u;
    for (; u > a; u -= s[u] + 1) {
      const f = t[u];
      if (f.marker === l.marker && f.open && f.end < 0) {
        let d = !1;
        if ((f.close || l.open) && (f.length + l.length) % 3 === 0 && (f.length % 3 !== 0 || l.length % 3 !== 0) && (d = !0), !d) {
          const p = u > 0 && !t[u - 1].open ? s[u - 1] + 1 : 0;
          s[o] = o - u + p, s[u] = p, l.open = !1, f.end = o, f.close = !1, c = -1, i = -2;
          break;
        }
      }
    }
    c !== -1 && (e[l.marker][(l.open ? 3 : 0) + (l.length || 0) % 3] = c);
  }
}
function Gae(t) {
  const e = t.tokens_meta, n = t.tokens_meta.length;
  w7(t.delimiters);
  for (let r = 0; r < n; r++)
    e[r] && e[r].delimiters && w7(e[r].delimiters);
}
function Kae(t) {
  let e, n, r = 0;
  const i = t.tokens, s = t.tokens.length;
  for (e = n = 0; e < s; e++)
    i[e].nesting < 0 && r--, i[e].level = r, i[e].nesting > 0 && r++, i[e].type === "text" && e + 1 < s && i[e + 1].type === "text" ? i[e + 1].content = i[e].content + i[e + 1].content : (e !== n && (i[n] = i[e]), n++);
  e !== n && (i.length = n);
}
const l3 = [
  ["text", Sae],
  ["linkify", Eae],
  ["newline", Dae],
  ["escape", Oae],
  ["backticks", Fae],
  ["strikethrough", qI.tokenize],
  ["emphasis", UI.tokenize],
  ["link", Iae],
  ["image", Nae],
  ["autolink", $ae],
  ["html_inline", Uae],
  ["entity", Wae]
], a3 = [
  ["balance_pairs", Gae],
  ["strikethrough", qI.postProcess],
  ["emphasis", UI.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", Kae]
];
function lm() {
  this.ruler = new fs();
  for (let t = 0; t < l3.length; t++)
    this.ruler.push(l3[t][0], l3[t][1]);
  this.ruler2 = new fs();
  for (let t = 0; t < a3.length; t++)
    this.ruler2.push(a3[t][0], a3[t][1]);
}
lm.prototype.skipToken = function(t) {
  const e = t.pos, n = this.ruler.getRules(""), r = n.length, i = t.md.options.maxNesting, s = t.cache;
  if (typeof s[e] < "u") {
    t.pos = s[e];
    return;
  }
  let o = !1;
  if (t.level < i) {
    for (let l = 0; l < r; l++)
      if (t.level++, o = n[l](t, !0), t.level--, o) {
        if (e >= t.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    t.pos = t.posMax;
  o || t.pos++, s[e] = t.pos;
};
lm.prototype.tokenize = function(t) {
  const e = this.ruler.getRules(""), n = e.length, r = t.posMax, i = t.md.options.maxNesting;
  for (; t.pos < r; ) {
    const s = t.pos;
    let o = !1;
    if (t.level < i) {
      for (let l = 0; l < n; l++)
        if (o = e[l](t, !1), o) {
          if (s >= t.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (o) {
      if (t.pos >= r)
        break;
      continue;
    }
    t.pending += t.src[t.pos++];
  }
  t.pending && t.pushPending();
};
lm.prototype.parse = function(t, e, n, r) {
  const i = new this.State(t, e, n, r);
  this.tokenize(i);
  const s = this.ruler2.getRules(""), o = s.length;
  for (let l = 0; l < o; l++)
    s[l](i);
};
lm.prototype.State = om;
function Yae(t) {
  const e = {};
  t = t || {}, e.src_Any = FI.source, e.src_Cc = TI.source, e.src_Z = MI.source, e.src_P = Q6.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
  const n = "[><ï½œ]";
  return e.src_pseudo_letter = "(?:(?!" + n + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + n + "|" + e.src_ZPCc + ")(?!" + (t["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + e.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + e.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
}
function M4(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    n && Object.keys(n).forEach(function(r) {
      t[r] = n[r];
    });
  }), t;
}
function i2(t) {
  return Object.prototype.toString.call(t);
}
function Xae(t) {
  return i2(t) === "[object String]";
}
function Qae(t) {
  return i2(t) === "[object Object]";
}
function Jae(t) {
  return i2(t) === "[object RegExp]";
}
function _7(t) {
  return i2(t) === "[object Function]";
}
function Zae(t) {
  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const HI = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function eue(t) {
  return Object.keys(t || {}).reduce(function(e, n) {
    return e || HI.hasOwnProperty(n);
  }, !1);
}
const tue = {
  "http:": {
    validate: function(t, e, n) {
      const r = t.slice(e);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(r) ? r.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t, e, n) {
      const r = t.slice(e);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(r) ? e >= 3 && t[e - 3] === ":" || e >= 3 && t[e - 3] === "/" ? 0 : r.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t, e, n) {
      const r = t.slice(e);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0;
    }
  }
}, nue = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", rue = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
function iue(t) {
  t.__index__ = -1, t.__text_cache__ = "";
}
function sue(t) {
  return function(e, n) {
    const r = e.slice(n);
    return t.test(r) ? r.match(t)[0].length : 0;
  };
}
function k7() {
  return function(t, e) {
    e.normalize(t);
  };
}
function qb(t) {
  const e = t.re = Yae(t.__opts__), n = t.__tlds__.slice();
  t.onCompile(), t.__tlds_replaced__ || n.push(nue), n.push(e.src_xn), e.src_tlds = n.join("|");
  function r(l) {
    return l.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  const i = [];
  t.__compiled__ = {};
  function s(l, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + l + '": ' + a);
  }
  Object.keys(t.__schemas__).forEach(function(l) {
    const a = t.__schemas__[l];
    if (a === null)
      return;
    const u = { validate: null, link: null };
    if (t.__compiled__[l] = u, Qae(a)) {
      Jae(a.validate) ? u.validate = sue(a.validate) : _7(a.validate) ? u.validate = a.validate : s(l, a), _7(a.normalize) ? u.normalize = a.normalize : a.normalize ? s(l, a) : u.normalize = k7();
      return;
    }
    if (Xae(a)) {
      i.push(l);
      return;
    }
    s(l, a);
  }), i.forEach(function(l) {
    t.__compiled__[t.__schemas__[l]] && (t.__compiled__[l].validate = t.__compiled__[t.__schemas__[l]].validate, t.__compiled__[l].normalize = t.__compiled__[t.__schemas__[l]].normalize);
  }), t.__compiled__[""] = { validate: null, normalize: k7() };
  const o = Object.keys(t.__compiled__).filter(function(l) {
    return l.length > 0 && t.__compiled__[l];
  }).map(Zae).join("|");
  t.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + e.src_ZPCc + "))(" + o + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + e.src_ZPCc + "))(" + o + ")", "ig"), t.re.schema_at_start = RegExp("^" + t.re.schema_search.source, "i"), t.re.pretest = RegExp(
    "(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@",
    "i"
  ), iue(t);
}
function oue(t, e) {
  const n = t.__index__, r = t.__last_index__, i = t.__text_cache__.slice(n, r);
  this.schema = t.__schema__.toLowerCase(), this.index = n + e, this.lastIndex = r + e, this.raw = i, this.text = i, this.url = i;
}
function P4(t, e) {
  const n = new oue(t, e);
  return t.__compiled__[n.schema].normalize(n, t), n;
}
function Ks(t, e) {
  if (!(this instanceof Ks))
    return new Ks(t, e);
  e || eue(t) && (e = t, t = {}), this.__opts__ = M4({}, HI, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = M4({}, tue, t), this.__compiled__ = {}, this.__tlds__ = rue, this.__tlds_replaced__ = !1, this.re = {}, qb(this);
}
Ks.prototype.add = function(e, n) {
  return this.__schemas__[e] = n, qb(this), this;
};
Ks.prototype.set = function(e) {
  return this.__opts__ = M4(this.__opts__, e), this;
};
Ks.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  let n, r, i, s, o, l, a, u, c;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (n = a.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, n[2], a.lastIndex), s) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (u = e.search(this.re.host_fuzzy_test), u >= 0 && (this.__index__ < 0 || u < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = r.index + r[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (c = e.indexOf("@"), c >= 0 && (i = e.match(this.re.email_fuzzy)) !== null && (o = i.index + i[1].length, l = i.index + i[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && l > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = l))), this.__index__ >= 0;
};
Ks.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
Ks.prototype.testSchemaAt = function(e, n, r) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(e, r, this) : 0;
};
Ks.prototype.match = function(e) {
  const n = [];
  let r = 0;
  this.__index__ >= 0 && this.__text_cache__ === e && (n.push(P4(this, r)), r = this.__last_index__);
  let i = r ? e.slice(r) : e;
  for (; this.test(i); )
    n.push(P4(this, r)), i = i.slice(this.__last_index__), r += this.__last_index__;
  return n.length ? n : null;
};
Ks.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return null;
  const n = this.re.schema_at_start.exec(e);
  if (!n) return null;
  const r = this.testSchemaAt(e, n[2], n[0].length);
  return r ? (this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + r, P4(this, 0)) : null;
};
Ks.prototype.tlds = function(e, n) {
  return e = Array.isArray(e) ? e : [e], n ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, i, s) {
    return r !== s[i - 1];
  }).reverse(), qb(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, qb(this), this);
};
Ks.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
Ks.prototype.onCompile = function() {
};
const Xh = 2147483647, Nl = 36, n5 = 1, xg = 26, lue = 38, aue = 700, VI = 72, WI = 128, GI = "-", uue = /^xn--/, cue = /[^\0-\x7F]/, fue = /[\x2E\u3002\uFF0E\uFF61]/g, hue = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, u3 = Nl - n5, Bl = Math.floor, c3 = String.fromCharCode;
function Eu(t) {
  throw new RangeError(hue[t]);
}
function due(t, e) {
  const n = [];
  let r = t.length;
  for (; r--; )
    n[r] = e(t[r]);
  return n;
}
function KI(t, e) {
  const n = t.split("@");
  let r = "";
  n.length > 1 && (r = n[0] + "@", t = n[1]), t = t.replace(fue, ".");
  const i = t.split("."), s = due(i, e).join(".");
  return r + s;
}
function YI(t) {
  const e = [];
  let n = 0;
  const r = t.length;
  for (; n < r; ) {
    const i = t.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const s = t.charCodeAt(n++);
      (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), n--);
    } else
      e.push(i);
  }
  return e;
}
const pue = (t) => String.fromCodePoint(...t), gue = function(t) {
  return t >= 48 && t < 58 ? 26 + (t - 48) : t >= 65 && t < 91 ? t - 65 : t >= 97 && t < 123 ? t - 97 : Nl;
}, C7 = function(t, e) {
  return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
}, XI = function(t, e, n) {
  let r = 0;
  for (t = n ? Bl(t / aue) : t >> 1, t += Bl(t / e); t > u3 * xg >> 1; r += Nl)
    t = Bl(t / u3);
  return Bl(r + (u3 + 1) * t / (t + lue));
}, QI = function(t) {
  const e = [], n = t.length;
  let r = 0, i = WI, s = VI, o = t.lastIndexOf(GI);
  o < 0 && (o = 0);
  for (let l = 0; l < o; ++l)
    t.charCodeAt(l) >= 128 && Eu("not-basic"), e.push(t.charCodeAt(l));
  for (let l = o > 0 ? o + 1 : 0; l < n; ) {
    const a = r;
    for (let c = 1, f = Nl; ; f += Nl) {
      l >= n && Eu("invalid-input");
      const d = gue(t.charCodeAt(l++));
      d >= Nl && Eu("invalid-input"), d > Bl((Xh - r) / c) && Eu("overflow"), r += d * c;
      const p = f <= s ? n5 : f >= s + xg ? xg : f - s;
      if (d < p)
        break;
      const m = Nl - p;
      c > Bl(Xh / m) && Eu("overflow"), c *= m;
    }
    const u = e.length + 1;
    s = XI(r - a, u, a == 0), Bl(r / u) > Xh - i && Eu("overflow"), i += Bl(r / u), r %= u, e.splice(r++, 0, i);
  }
  return String.fromCodePoint(...e);
}, JI = function(t) {
  const e = [];
  t = YI(t);
  const n = t.length;
  let r = WI, i = 0, s = VI;
  for (const a of t)
    a < 128 && e.push(c3(a));
  const o = e.length;
  let l = o;
  for (o && e.push(GI); l < n; ) {
    let a = Xh;
    for (const c of t)
      c >= r && c < a && (a = c);
    const u = l + 1;
    a - r > Bl((Xh - i) / u) && Eu("overflow"), i += (a - r) * u, r = a;
    for (const c of t)
      if (c < r && ++i > Xh && Eu("overflow"), c === r) {
        let f = i;
        for (let d = Nl; ; d += Nl) {
          const p = d <= s ? n5 : d >= s + xg ? xg : d - s;
          if (f < p)
            break;
          const m = f - p, y = Nl - p;
          e.push(
            c3(C7(p + m % y, 0))
          ), f = Bl(m / y);
        }
        e.push(c3(C7(f, 0))), s = XI(i, u, l === o), i = 0, ++l;
      }
    ++i, ++r;
  }
  return e.join("");
}, mue = function(t) {
  return KI(t, function(e) {
    return uue.test(e) ? QI(e.slice(4).toLowerCase()) : e;
  });
}, yue = function(t) {
  return KI(t, function(e) {
    return cue.test(e) ? "xn--" + JI(e) : e;
  });
}, ZI = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: YI,
    encode: pue
  },
  decode: QI,
  encode: JI,
  toASCII: yue,
  toUnicode: mue
}, bue = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, vue = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, xue = {
  options: {
    // Enable HTML tags in source
    html: !0,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !0,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€žâ€œ' for Russian, 'â€žâ€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, wue = {
  default: bue,
  zero: vue,
  commonmark: xue
}, _ue = /^(vbscript|javascript|file|data):/, kue = /^data:image\/(gif|png|jpeg|webp);/;
function Cue(t) {
  const e = t.trim().toLowerCase();
  return _ue.test(e) ? kue.test(e) : !0;
}
const eN = ["http:", "https:", "mailto:"];
function Sue(t) {
  const e = X6(t, !0);
  if (e.hostname && (!e.protocol || eN.indexOf(e.protocol) >= 0))
    try {
      e.hostname = ZI.toASCII(e.hostname);
    } catch {
    }
  return sm(Y6(e));
}
function Aue(t) {
  const e = X6(t, !0);
  if (e.hostname && (!e.protocol || eN.indexOf(e.protocol) >= 0))
    try {
      e.hostname = ZI.toUnicode(e.hostname);
    } catch {
    }
  return Dd(Y6(e), Dd.defaultChars + "%");
}
function wo(t, e) {
  if (!(this instanceof wo))
    return new wo(t, e);
  e || J6(t) || (e = t || {}, t = "default"), this.inline = new lm(), this.block = new r2(), this.core = new e5(), this.renderer = new t0(), this.linkify = new Ks(), this.validateLink = Cue, this.normalizeLink = Sue, this.normalizeLinkText = Aue, this.utils = Dle, this.helpers = t2({}, Rle), this.options = {}, this.configure(t), e && this.set(e);
}
wo.prototype.set = function(t) {
  return t2(this.options, t), this;
};
wo.prototype.configure = function(t) {
  const e = this;
  if (J6(t)) {
    const n = t;
    if (t = wue[n], !t)
      throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  }
  if (!t)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t.options && e.set(t.options), t.components && Object.keys(t.components).forEach(function(n) {
    t.components[n].rules && e[n].ruler.enableOnly(t.components[n].rules), t.components[n].rules2 && e[n].ruler2.enableOnly(t.components[n].rules2);
  }), this;
};
wo.prototype.enable = function(t, e) {
  let n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.enable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(t, !0));
  const r = t.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
wo.prototype.disable = function(t, e) {
  let n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.disable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(t, !0));
  const r = t.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
wo.prototype.use = function(t) {
  const e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t.apply(t, e), this;
};
wo.prototype.parse = function(t, e) {
  if (typeof t != "string")
    throw new Error("Input data should be a String");
  const n = new this.core.State(t, this, e);
  return this.core.process(n), n.tokens;
};
wo.prototype.render = function(t, e) {
  return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e);
};
wo.prototype.parseInline = function(t, e) {
  const n = new this.core.State(t, this, e);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
wo.prototype.renderInline = function(t, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e);
};
function Eue(t, e, n) {
  const {
    parseMetaString: r,
    trimEndingNewline: i = !0,
    defaultLanguage: s = "text",
    fallbackLanguage: o
  } = n, l = e.getLoadedLanguages();
  t.options.highlight = (a, u = "text", c) => {
    u === "" && (u = s), o && !l.includes(u) && (u = o);
    const f = r?.(c, a, u) || {}, d = {
      ...n,
      lang: u,
      meta: {
        ...n.meta,
        ...f,
        __raw: c
      }
    }, p = [];
    return p.push({
      name: "@shikijs/markdown-it:block-class",
      code(m) {
        m.properties.class = `language-${u}`;
      }
    }), i && a.endsWith(`
`) && (a = a.slice(0, -1)), e.codeToHtml(
      a,
      {
        ...d,
        transformers: [
          ...p,
          ...d.transformers || []
        ]
      }
    );
  };
}
function Due(t, e) {
  return function(n) {
    Eue(n, t, e);
  };
}
let lf = class extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
}, r5 = class extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
};
function Oue() {
  return 2147483648;
}
function Fue() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const Tue = (t, e) => t + (e - t % e) % e;
async function Rue(t) {
  let e, n;
  const r = {};
  function i(p) {
    n = p, r.HEAPU8 = new Uint8Array(p), r.HEAPU32 = new Uint32Array(p);
  }
  function s(p, m, y) {
    r.HEAPU8.copyWithin(p, m, m + y);
  }
  function o(p) {
    try {
      return e.grow(p - n.byteLength + 65535 >>> 16), i(e.buffer), 1;
    } catch {
    }
  }
  function l(p) {
    const m = r.HEAPU8.length;
    p = p >>> 0;
    const y = Oue();
    if (p > y)
      return !1;
    for (let b = 1; b <= 4; b *= 2) {
      let v = m * (1 + 0.2 / b);
      v = Math.min(v, p + 100663296);
      const _ = Math.min(y, Tue(Math.max(p, v), 65536));
      if (o(_))
        return !0;
    }
    return !1;
  }
  const a = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function u(p, m, y = 1024) {
    const b = m + y;
    let v = m;
    for (; p[v] && !(v >= b); )
      ++v;
    if (v - m > 16 && p.buffer && a)
      return a.decode(p.subarray(m, v));
    let _ = "";
    for (; m < v; ) {
      let k = p[m++];
      if (!(k & 128)) {
        _ += String.fromCharCode(k);
        continue;
      }
      const S = p[m++] & 63;
      if ((k & 224) === 192) {
        _ += String.fromCharCode((k & 31) << 6 | S);
        continue;
      }
      const C = p[m++] & 63;
      if ((k & 240) === 224 ? k = (k & 15) << 12 | S << 6 | C : k = (k & 7) << 18 | S << 12 | C << 6 | p[m++] & 63, k < 65536)
        _ += String.fromCharCode(k);
      else {
        const E = k - 65536;
        _ += String.fromCharCode(55296 | E >> 10, 56320 | E & 1023);
      }
    }
    return _;
  }
  function c(p, m) {
    return p ? u(r.HEAPU8, p, m) : "";
  }
  const f = {
    emscripten_get_now: Fue,
    emscripten_memcpy_big: s,
    emscripten_resize_heap: l,
    fd_write: () => 0
  };
  async function d() {
    const m = await t({
      env: f,
      wasi_snapshot_preview1: f
    });
    e = m.memory, i(e.buffer), Object.assign(r, m), r.UTF8ToString = c;
  }
  return await d(), r;
}
var Mue = Object.defineProperty, Pue = (t, e, n) => e in t ? Mue(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Ar = (t, e, n) => (Pue(t, typeof e != "symbol" ? e + "" : e, n), n);
let Mr = null;
function Iue(t) {
  throw new r5(t.UTF8ToString(t.getLastOnigError()));
}
class s2 {
  constructor(e) {
    Ar(this, "utf16Length"), Ar(this, "utf8Length"), Ar(this, "utf16Value"), Ar(this, "utf8Value"), Ar(this, "utf16OffsetToUtf8"), Ar(this, "utf8OffsetToUtf16");
    const n = e.length, r = s2._utf8ByteLength(e), i = r !== n, s = i ? new Uint32Array(n + 1) : null;
    i && (s[n] = r);
    const o = i ? new Uint32Array(r + 1) : null;
    i && (o[r] = n);
    const l = new Uint8Array(r);
    let a = 0;
    for (let u = 0; u < n; u++) {
      const c = e.charCodeAt(u);
      let f = c, d = !1;
      if (c >= 55296 && c <= 56319 && u + 1 < n) {
        const p = e.charCodeAt(u + 1);
        p >= 56320 && p <= 57343 && (f = (c - 55296 << 10) + 65536 | p - 56320, d = !0);
      }
      i && (s[u] = a, d && (s[u + 1] = a), f <= 127 ? o[a + 0] = u : f <= 2047 ? (o[a + 0] = u, o[a + 1] = u) : f <= 65535 ? (o[a + 0] = u, o[a + 1] = u, o[a + 2] = u) : (o[a + 0] = u, o[a + 1] = u, o[a + 2] = u, o[a + 3] = u)), f <= 127 ? l[a++] = f : f <= 2047 ? (l[a++] = 192 | (f & 1984) >>> 6, l[a++] = 128 | (f & 63) >>> 0) : f <= 65535 ? (l[a++] = 224 | (f & 61440) >>> 12, l[a++] = 128 | (f & 4032) >>> 6, l[a++] = 128 | (f & 63) >>> 0) : (l[a++] = 240 | (f & 1835008) >>> 18, l[a++] = 128 | (f & 258048) >>> 12, l[a++] = 128 | (f & 4032) >>> 6, l[a++] = 128 | (f & 63) >>> 0), d && u++;
    }
    this.utf16Length = n, this.utf8Length = r, this.utf16Value = e, this.utf8Value = l, this.utf16OffsetToUtf8 = s, this.utf8OffsetToUtf16 = o;
  }
  static _utf8ByteLength(e) {
    let n = 0;
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e.charCodeAt(r);
      let o = s, l = !1;
      if (s >= 55296 && s <= 56319 && r + 1 < i) {
        const a = e.charCodeAt(r + 1);
        a >= 56320 && a <= 57343 && (o = (s - 55296 << 10) + 65536 | a - 56320, l = !0);
      }
      o <= 127 ? n += 1 : o <= 2047 ? n += 2 : o <= 65535 ? n += 3 : n += 4, l && r++;
    }
    return n;
  }
  createString(e) {
    const n = e.omalloc(this.utf8Length);
    return e.HEAPU8.set(this.utf8Value, n), n;
  }
}
const yl = class {
  constructor(t) {
    if (Ar(this, "id", ++yl.LAST_ID), Ar(this, "_onigBinding"), Ar(this, "content"), Ar(this, "utf16Length"), Ar(this, "utf8Length"), Ar(this, "utf16OffsetToUtf8"), Ar(this, "utf8OffsetToUtf16"), Ar(this, "ptr"), !Mr)
      throw new r5("Must invoke loadWasm first.");
    this._onigBinding = Mr, this.content = t;
    const e = new s2(t);
    this.utf16Length = e.utf16Length, this.utf8Length = e.utf8Length, this.utf16OffsetToUtf8 = e.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = e.utf8OffsetToUtf16, this.utf8Length < 1e4 && !yl._sharedPtrInUse ? (yl._sharedPtr || (yl._sharedPtr = Mr.omalloc(1e4)), yl._sharedPtrInUse = !0, Mr.HEAPU8.set(e.utf8Value, yl._sharedPtr), this.ptr = yl._sharedPtr) : this.ptr = e.createString(Mr);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === yl._sharedPtr ? yl._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
let am = yl;
Ar(am, "LAST_ID", 0);
Ar(am, "_sharedPtr", 0);
Ar(am, "_sharedPtrInUse", !1);
class Nue {
  constructor(e) {
    if (Ar(this, "_onigBinding"), Ar(this, "_ptr"), !Mr)
      throw new r5("Must invoke loadWasm first.");
    const n = [], r = [];
    for (let l = 0, a = e.length; l < a; l++) {
      const u = new s2(e[l]);
      n[l] = u.createString(Mr), r[l] = u.utf8Length;
    }
    const i = Mr.omalloc(4 * e.length);
    Mr.HEAPU32.set(n, i / 4);
    const s = Mr.omalloc(4 * e.length);
    Mr.HEAPU32.set(r, s / 4);
    const o = Mr.createOnigScanner(i, s, e.length);
    for (let l = 0, a = e.length; l < a; l++)
      Mr.ofree(n[l]);
    Mr.ofree(s), Mr.ofree(i), o === 0 && Iue(Mr), this._onigBinding = Mr, this._ptr = o;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(e, n, r) {
    let i = 0;
    if (typeof r == "number" && (i = r), typeof e == "string") {
      e = new am(e);
      const s = this._findNextMatchSync(e, n, !1, i);
      return e.dispose(), s;
    }
    return this._findNextMatchSync(e, n, !1, i);
  }
  _findNextMatchSync(e, n, r, i) {
    const s = this._onigBinding, o = s.findNextOnigScannerMatch(this._ptr, e.id, e.ptr, e.utf8Length, e.convertUtf16OffsetToUtf8(n), i);
    if (o === 0)
      return null;
    const l = s.HEAPU32;
    let a = o / 4;
    const u = l[a++], c = l[a++], f = [];
    for (let d = 0; d < c; d++) {
      const p = e.convertUtf8OffsetToUtf16(l[a++]), m = e.convertUtf8OffsetToUtf16(l[a++]);
      f[d] = {
        start: p,
        end: m,
        length: m - p
      };
    }
    return {
      index: u,
      captureIndices: f
    };
  }
}
function Bue(t) {
  return typeof t.instantiator == "function";
}
function Lue(t) {
  return typeof t.default == "function";
}
function $ue(t) {
  return typeof t.data < "u";
}
function zue(t) {
  return typeof Response < "u" && t instanceof Response;
}
function jue(t) {
  return typeof ArrayBuffer < "u" && (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) || typeof Buffer < "u" && Buffer.isBuffer?.(t) || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer || typeof Uint32Array < "u" && t instanceof Uint32Array;
}
let Z1;
function que(t) {
  if (Z1)
    return Z1;
  async function e() {
    Mr = await Rue(async (n) => {
      let r = t;
      return r = await r, typeof r == "function" && (r = await r(n)), typeof r == "function" && (r = await r(n)), Bue(r) ? r = await r.instantiator(n) : Lue(r) ? r = await r.default(n) : ($ue(r) && (r = r.data), zue(r) ? typeof WebAssembly.instantiateStreaming == "function" ? r = await Uue(r)(n) : r = await Hue(r)(n) : jue(r) ? r = await f3(r)(n) : r instanceof WebAssembly.Module ? r = await f3(r)(n) : "default" in r && r.default instanceof WebAssembly.Module && (r = await f3(r.default)(n))), "instance" in r && (r = r.instance), "exports" in r && (r = r.exports), r;
    });
  }
  return Z1 = e(), Z1;
}
function f3(t) {
  return (e) => WebAssembly.instantiate(t, e);
}
function Uue(t) {
  return (e) => WebAssembly.instantiateStreaming(t, e);
}
function Hue(t) {
  return async (e) => {
    const n = await t.arrayBuffer();
    return WebAssembly.instantiate(n, e);
  };
}
let Vue;
function Wue() {
  return Vue;
}
async function Gue(t) {
  return t && await que(t), {
    createScanner(e) {
      return new Nue(e.map((n) => typeof n == "string" ? n : n.source));
    },
    createString(e) {
      return new am(e);
    }
  };
}
function Kue(t) {
  return i5(t);
}
function i5(t) {
  return Array.isArray(t) ? Yue(t) : t instanceof RegExp ? t : typeof t == "object" ? Xue(t) : t;
}
function Yue(t) {
  let e = [];
  for (let n = 0, r = t.length; n < r; n++)
    e[n] = i5(t[n]);
  return e;
}
function Xue(t) {
  let e = {};
  for (let n in t)
    e[n] = i5(t[n]);
  return e;
}
function tN(t, ...e) {
  return e.forEach((n) => {
    for (let r in n)
      t[r] = n[r];
  }), t;
}
function nN(t) {
  const e = ~t.lastIndexOf("/") || ~t.lastIndexOf("\\");
  return e === 0 ? t : ~e === t.length - 1 ? nN(t.substring(0, t.length - 1)) : t.substr(~e + 1);
}
var h3 = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, ey = class {
  static hasCaptures(t) {
    return t === null ? !1 : (h3.lastIndex = 0, h3.test(t));
  }
  static replaceCaptures(t, e, n) {
    return t.replace(h3, (r, i, s, o) => {
      let l = n[parseInt(i || s, 10)];
      if (l) {
        let a = e.substring(l.start, l.end);
        for (; a[0] === "."; )
          a = a.substring(1);
        switch (o) {
          case "downcase":
            return a.toLowerCase();
          case "upcase":
            return a.toUpperCase();
          default:
            return a;
        }
      } else
        return r;
    });
  }
};
function rN(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function iN(t, e) {
  if (t === null && e === null)
    return 0;
  if (!t)
    return -1;
  if (!e)
    return 1;
  let n = t.length, r = e.length;
  if (n === r) {
    for (let i = 0; i < n; i++) {
      let s = rN(t[i], e[i]);
      if (s !== 0)
        return s;
    }
    return 0;
  }
  return n - r;
}
function S7(t) {
  return !!(/^#[0-9a-f]{6}$/i.test(t) || /^#[0-9a-f]{8}$/i.test(t) || /^#[0-9a-f]{3}$/i.test(t) || /^#[0-9a-f]{4}$/i.test(t));
}
function sN(t) {
  return t.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var oN = class {
  constructor(t) {
    this.fn = t;
  }
  cache = /* @__PURE__ */ new Map();
  get(t) {
    if (this.cache.has(t))
      return this.cache.get(t);
    const e = this.fn(t);
    return this.cache.set(t, e), e;
  }
}, Ub = class {
  constructor(t, e, n) {
    this._colorMap = t, this._defaults = e, this._root = n;
  }
  static createFromRawTheme(t, e) {
    return this.createFromParsedTheme(Zue(t), e);
  }
  static createFromParsedTheme(t, e) {
    return tce(t, e);
  }
  _cachedMatchRoot = new oN(
    (t) => this._root.match(t)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(t) {
    if (t === null)
      return this._defaults;
    const e = t.scopeName, r = this._cachedMatchRoot.get(e).find(
      (i) => Que(t.parent, i.parentScopes)
    );
    return r ? new lN(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, d3 = class Wy {
  constructor(e, n) {
    this.parent = e, this.scopeName = n;
  }
  static push(e, n) {
    for (const r of n)
      e = new Wy(e, r);
    return e;
  }
  static from(...e) {
    let n = null;
    for (let r = 0; r < e.length; r++)
      n = new Wy(n, e[r]);
    return n;
  }
  push(e) {
    return new Wy(this, e);
  }
  getSegments() {
    let e = this;
    const n = [];
    for (; e; )
      n.push(e.scopeName), e = e.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(e) {
    return this === e ? !0 : this.parent === null ? !1 : this.parent.extends(e);
  }
  getExtensionIfDefined(e) {
    const n = [];
    let r = this;
    for (; r && r !== e; )
      n.push(r.scopeName), r = r.parent;
    return r === e ? n.reverse() : void 0;
  }
};
function Que(t, e) {
  if (e.length === 0)
    return !0;
  for (let n = 0; n < e.length; n++) {
    let r = e[n], i = !1;
    if (r === ">") {
      if (n === e.length - 1)
        return !1;
      r = e[++n], i = !0;
    }
    for (; t && !Jue(t.scopeName, r); ) {
      if (i)
        return !1;
      t = t.parent;
    }
    if (!t)
      return !1;
    t = t.parent;
  }
  return !0;
}
function Jue(t, e) {
  return e === t || t.startsWith(e) && t[e.length] === ".";
}
var lN = class {
  constructor(t, e, n) {
    this.fontStyle = t, this.foregroundId = e, this.backgroundId = n;
  }
};
function Zue(t) {
  if (!t)
    return [];
  if (!t.settings || !Array.isArray(t.settings))
    return [];
  let e = t.settings, n = [], r = 0;
  for (let i = 0, s = e.length; i < s; i++) {
    let o = e[i];
    if (!o.settings)
      continue;
    let l;
    if (typeof o.scope == "string") {
      let f = o.scope;
      f = f.replace(/^[,]+/, ""), f = f.replace(/[,]+$/, ""), l = f.split(",");
    } else Array.isArray(o.scope) ? l = o.scope : l = [""];
    let a = -1;
    if (typeof o.settings.fontStyle == "string") {
      a = 0;
      let f = o.settings.fontStyle.split(" ");
      for (let d = 0, p = f.length; d < p; d++)
        switch (f[d]) {
          case "italic":
            a = a | 1;
            break;
          case "bold":
            a = a | 2;
            break;
          case "underline":
            a = a | 4;
            break;
          case "strikethrough":
            a = a | 8;
            break;
        }
    }
    let u = null;
    typeof o.settings.foreground == "string" && S7(o.settings.foreground) && (u = o.settings.foreground);
    let c = null;
    typeof o.settings.background == "string" && S7(o.settings.background) && (c = o.settings.background);
    for (let f = 0, d = l.length; f < d; f++) {
      let m = l[f].trim().split(" "), y = m[m.length - 1], b = null;
      m.length > 1 && (b = m.slice(0, m.length - 1), b.reverse()), n[r++] = new ece(
        y,
        b,
        i,
        a,
        u,
        c
      );
    }
  }
  return n;
}
var ece = class {
  constructor(t, e, n, r, i, s) {
    this.scope = t, this.parentScopes = e, this.index = n, this.fontStyle = r, this.foreground = i, this.background = s;
  }
}, La = /* @__PURE__ */ ((t) => (t[t.NotSet = -1] = "NotSet", t[t.None = 0] = "None", t[t.Italic = 1] = "Italic", t[t.Bold = 2] = "Bold", t[t.Underline = 4] = "Underline", t[t.Strikethrough = 8] = "Strikethrough", t))(La || {});
function tce(t, e) {
  t.sort((a, u) => {
    let c = rN(a.scope, u.scope);
    return c !== 0 || (c = iN(a.parentScopes, u.parentScopes), c !== 0) ? c : a.index - u.index;
  });
  let n = 0, r = "#000000", i = "#ffffff";
  for (; t.length >= 1 && t[0].scope === ""; ) {
    let a = t.shift();
    a.fontStyle !== -1 && (n = a.fontStyle), a.foreground !== null && (r = a.foreground), a.background !== null && (i = a.background);
  }
  let s = new nce(e), o = new lN(n, s.getId(r), s.getId(i)), l = new ice(new I4(0, null, -1, 0, 0), []);
  for (let a = 0, u = t.length; a < u; a++) {
    let c = t[a];
    l.insert(0, c.scope, c.parentScopes, c.fontStyle, s.getId(c.foreground), s.getId(c.background));
  }
  return new Ub(s, o, l);
}
var nce = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(t) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(t)) {
      this._isFrozen = !0;
      for (let e = 0, n = t.length; e < n; e++)
        this._color2id[t[e]] = e, this._id2color[e] = t[e];
    } else
      this._isFrozen = !1;
  }
  getId(t) {
    if (t === null)
      return 0;
    t = t.toUpperCase();
    let e = this._color2id[t];
    if (e)
      return e;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${t}`);
    return e = ++this._lastColorId, this._color2id[t] = e, this._id2color[e] = t, e;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, rce = Object.freeze([]), I4 = class aN {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(e, n, r, i, s) {
    this.scopeDepth = e, this.parentScopes = n || rce, this.fontStyle = r, this.foreground = i, this.background = s;
  }
  clone() {
    return new aN(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(e) {
    let n = [];
    for (let r = 0, i = e.length; r < i; r++)
      n[r] = e[r].clone();
    return n;
  }
  acceptOverwrite(e, n, r, i) {
    this.scopeDepth > e ? console.log("how did this happen?") : this.scopeDepth = e, n !== -1 && (this.fontStyle = n), r !== 0 && (this.foreground = r), i !== 0 && (this.background = i);
  }
}, ice = class N4 {
  constructor(e, n = [], r = {}) {
    this._mainRule = e, this._children = r, this._rulesWithParentScopes = n;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(e, n) {
    if (e.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - e.scopeDepth;
    let r = 0, i = 0;
    for (; e.parentScopes[r] === ">" && r++, n.parentScopes[i] === ">" && i++, !(r >= e.parentScopes.length || i >= n.parentScopes.length); ) {
      const s = n.parentScopes[i].length - e.parentScopes[r].length;
      if (s !== 0)
        return s;
      r++, i++;
    }
    return n.parentScopes.length - e.parentScopes.length;
  }
  match(e) {
    if (e !== "") {
      let r = e.indexOf("."), i, s;
      if (r === -1 ? (i = e, s = "") : (i = e.substring(0, r), s = e.substring(r + 1)), this._children.hasOwnProperty(i))
        return this._children[i].match(s);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(N4._cmpBySpecificity), n;
  }
  insert(e, n, r, i, s, o) {
    if (n === "") {
      this._doInsertHere(e, r, i, s, o);
      return;
    }
    let l = n.indexOf("."), a, u;
    l === -1 ? (a = n, u = "") : (a = n.substring(0, l), u = n.substring(l + 1));
    let c;
    this._children.hasOwnProperty(a) ? c = this._children[a] : (c = new N4(this._mainRule.clone(), I4.cloneArr(this._rulesWithParentScopes)), this._children[a] = c), c.insert(e + 1, u, r, i, s, o);
  }
  _doInsertHere(e, n, r, i, s) {
    if (n === null) {
      this._mainRule.acceptOverwrite(e, r, i, s);
      return;
    }
    for (let o = 0, l = this._rulesWithParentScopes.length; o < l; o++) {
      let a = this._rulesWithParentScopes[o];
      if (iN(a.parentScopes, n) === 0) {
        a.acceptOverwrite(e, r, i, s);
        return;
      }
    }
    r === -1 && (r = this._mainRule.fontStyle), i === 0 && (i = this._mainRule.foreground), s === 0 && (s = this._mainRule.background), this._rulesWithParentScopes.push(new I4(e, n, r, i, s));
  }
}, Fd = class oo {
  static toBinaryStr(e) {
    return e.toString(2).padStart(32, "0");
  }
  static print(e) {
    const n = oo.getLanguageId(e), r = oo.getTokenType(e), i = oo.getFontStyle(e), s = oo.getForeground(e), o = oo.getBackground(e);
    console.log({
      languageId: n,
      tokenType: r,
      fontStyle: i,
      foreground: s,
      background: o
    });
  }
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(e, n, r, i, s, o, l) {
    let a = oo.getLanguageId(e), u = oo.getTokenType(e), c = oo.containsBalancedBrackets(e) ? 1 : 0, f = oo.getFontStyle(e), d = oo.getForeground(e), p = oo.getBackground(e);
    return n !== 0 && (a = n), r !== 8 && (u = r), i !== null && (c = i ? 1 : 0), s !== -1 && (f = s), o !== 0 && (d = o), l !== 0 && (p = l), (a << 0 | u << 8 | c << 10 | f << 11 | d << 15 | p << 24) >>> 0;
  }
};
function Hb(t, e) {
  const n = [], r = sce(t);
  let i = r.next();
  for (; i !== null; ) {
    let a = 0;
    if (i.length === 2 && i.charAt(1) === ":") {
      switch (i.charAt(0)) {
        case "R":
          a = 1;
          break;
        case "L":
          a = -1;
          break;
        default:
          console.log(`Unknown priority ${i} in scope selector`);
      }
      i = r.next();
    }
    let u = o();
    if (n.push({ matcher: u, priority: a }), i !== ",")
      break;
    i = r.next();
  }
  return n;
  function s() {
    if (i === "-") {
      i = r.next();
      const a = s();
      return (u) => !!a && !a(u);
    }
    if (i === "(") {
      i = r.next();
      const a = l();
      return i === ")" && (i = r.next()), a;
    }
    if (A7(i)) {
      const a = [];
      do
        a.push(i), i = r.next();
      while (A7(i));
      return (u) => e(a, u);
    }
    return null;
  }
  function o() {
    const a = [];
    let u = s();
    for (; u; )
      a.push(u), u = s();
    return (c) => a.every((f) => f(c));
  }
  function l() {
    const a = [];
    let u = o();
    for (; u && (a.push(u), i === "|" || i === ","); ) {
      do
        i = r.next();
      while (i === "|" || i === ",");
      u = o();
    }
    return (c) => a.some((f) => f(c));
  }
}
function A7(t) {
  return !!t && !!t.match(/[\w\.:]+/);
}
function sce(t) {
  let e = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = e.exec(t);
  return {
    next: () => {
      if (!n)
        return null;
      const r = n[0];
      return n = e.exec(t), r;
    }
  };
}
function uN(t) {
  typeof t.dispose == "function" && t.dispose();
}
var wg = class {
  constructor(t) {
    this.scopeName = t;
  }
  toKey() {
    return this.scopeName;
  }
}, oce = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, lce = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(t) {
    const e = t.toKey();
    this._seenReferenceKeys.has(e) || (this._seenReferenceKeys.add(e), this._references.push(t));
  }
}, ace = class {
  constructor(t, e) {
    this.repo = t, this.initialScopeName = e, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new wg(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const t = this.Q;
    this.Q = [];
    const e = new lce();
    for (const n of t)
      uce(n, this.initialScopeName, this.repo, e);
    for (const n of e.references)
      if (n instanceof wg) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function uce(t, e, n, r) {
  const i = n.lookup(t.scopeName);
  if (!i) {
    if (t.scopeName === e)
      throw new Error(`No grammar provided for <${e}>`);
    return;
  }
  const s = n.lookup(e);
  t instanceof wg ? Gy({ baseGrammar: s, selfGrammar: i }, r) : B4(
    t.ruleName,
    { baseGrammar: s, selfGrammar: i, repository: i.repository },
    r
  );
  const o = n.injections(t.scopeName);
  if (o)
    for (const l of o)
      r.add(new wg(l));
}
function B4(t, e, n) {
  if (e.repository && e.repository[t]) {
    const r = e.repository[t];
    Vb([r], e, n);
  }
}
function Gy(t, e) {
  t.selfGrammar.patterns && Array.isArray(t.selfGrammar.patterns) && Vb(
    t.selfGrammar.patterns,
    { ...t, repository: t.selfGrammar.repository },
    e
  ), t.selfGrammar.injections && Vb(
    Object.values(t.selfGrammar.injections),
    { ...t, repository: t.selfGrammar.repository },
    e
  );
}
function Vb(t, e, n) {
  for (const r of t) {
    if (n.visitedRule.has(r))
      continue;
    n.visitedRule.add(r);
    const i = r.repository ? tN({}, e.repository, r.repository) : e.repository;
    Array.isArray(r.patterns) && Vb(r.patterns, { ...e, repository: i }, n);
    const s = r.include;
    if (!s)
      continue;
    const o = cN(s);
    switch (o.kind) {
      case 0:
        Gy({ ...e, selfGrammar: e.baseGrammar }, n);
        break;
      case 1:
        Gy(e, n);
        break;
      case 2:
        B4(o.ruleName, { ...e, repository: i }, n);
        break;
      case 3:
      case 4:
        const l = o.scopeName === e.selfGrammar.scopeName ? e.selfGrammar : o.scopeName === e.baseGrammar.scopeName ? e.baseGrammar : void 0;
        if (l) {
          const a = { baseGrammar: e.baseGrammar, selfGrammar: l, repository: i };
          o.kind === 4 ? B4(o.ruleName, a, n) : Gy(a, n);
        } else
          o.kind === 4 ? n.add(new oce(o.scopeName, o.ruleName)) : n.add(new wg(o.scopeName));
        break;
    }
  }
}
var cce = class {
  kind = 0;
}, fce = class {
  kind = 1;
}, hce = class {
  constructor(t) {
    this.ruleName = t;
  }
  kind = 2;
}, dce = class {
  constructor(t) {
    this.scopeName = t;
  }
  kind = 3;
}, pce = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  kind = 4;
};
function cN(t) {
  if (t === "$base")
    return new cce();
  if (t === "$self")
    return new fce();
  const e = t.indexOf("#");
  if (e === -1)
    return new dce(t);
  if (e === 0)
    return new hce(t.substring(1));
  {
    const n = t.substring(0, e), r = t.substring(e + 1);
    return new pce(n, r);
  }
}
var gce = /\\(\d+)/, E7 = /\\(\d+)/g, mce = -1, fN = -2;
var um = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(t, e, n, r) {
    this.$location = t, this.id = e, this._name = n || null, this._nameIsCapturing = ey.hasCaptures(this._name), this._contentName = r || null, this._contentNameIsCapturing = ey.hasCaptures(this._contentName);
  }
  get debugName() {
    const t = this.$location ? `${nN(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${t}`;
  }
  getName(t, e) {
    return !this._nameIsCapturing || this._name === null || t === null || e === null ? this._name : ey.replaceCaptures(this._name, t, e);
  }
  getContentName(t, e) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : ey.replaceCaptures(this._contentName, t, e);
  }
}, yce = class extends um {
  retokenizeCapturedWithRuleId;
  constructor(t, e, n, r, i) {
    super(t, e, n, r), this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(t, e) {
    throw new Error("Not supported!");
  }
  compile(t, e) {
    throw new Error("Not supported!");
  }
  compileAG(t, e, n, r) {
    throw new Error("Not supported!");
  }
}, bce = class extends um {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, i) {
    super(t, e, n, null), this._match = new _g(r, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(t, e) {
    e.push(this._match);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new kg(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, D7 = class extends um {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, i) {
    super(t, e, n, r), this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(t, e) {
    for (const n of this.patterns)
      t.getRule(n).collectPatterns(t, e);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new kg(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, L4 = class extends um {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, i, s, o, l, a, u) {
    super(t, e, n, r), this._begin = new _g(i, this.id), this.beginCaptures = s, this._end = new _g(o || "ï¿¿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = l, this.applyEndPatternLast = a || !1, this.patterns = u.patterns, this.hasMissingPatterns = u.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(t, e) {
    return this._end.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t, e).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t, e).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t, e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new kg();
      for (const n of this.patterns)
        t.getRule(n).collectPatterns(t, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, e) : this._cachedCompiledPatterns.setSource(0, e)), this._cachedCompiledPatterns;
  }
}, Wb = class extends um {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(t, e, n, r, i, s, o, l, a) {
    super(t, e, n, r), this._begin = new _g(i, this.id), this.beginCaptures = s, this.whileCaptures = l, this._while = new _g(o, fN), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = a.patterns, this.hasMissingPatterns = a.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(t, e) {
    return this._while.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new kg();
      for (const e of this.patterns)
        t.getRule(e).collectPatterns(t, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(t, e) {
    return this._getCachedCompiledWhilePatterns(t, e).compile(t);
  }
  compileWhileAG(t, e, n, r) {
    return this._getCachedCompiledWhilePatterns(t, e).compileAG(t, n, r);
  }
  _getCachedCompiledWhilePatterns(t, e) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new kg(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, e || "ï¿¿"), this._cachedCompiledWhilePatterns;
  }
}, hN = class Jr {
  static createCaptureRule(e, n, r, i, s) {
    return e.registerRule((o) => new yce(n, o, r, i, s));
  }
  static getCompiledRuleId(e, n, r) {
    return e.id || n.registerRule((i) => {
      if (e.id = i, e.match)
        return new bce(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.match,
          Jr._compileCaptures(e.captures, n, r)
        );
      if (typeof e.begin > "u") {
        e.repository && (r = tN({}, r, e.repository));
        let s = e.patterns;
        return typeof s > "u" && e.include && (s = [{ include: e.include }]), new D7(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.contentName,
          Jr._compilePatterns(s, n, r)
        );
      }
      return e.while ? new Wb(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Jr._compileCaptures(e.beginCaptures || e.captures, n, r),
        e.while,
        Jr._compileCaptures(e.whileCaptures || e.captures, n, r),
        Jr._compilePatterns(e.patterns, n, r)
      ) : new L4(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Jr._compileCaptures(e.beginCaptures || e.captures, n, r),
        e.end,
        Jr._compileCaptures(e.endCaptures || e.captures, n, r),
        e.applyEndPatternLast,
        Jr._compilePatterns(e.patterns, n, r)
      );
    }), e.id;
  }
  static _compileCaptures(e, n, r) {
    let i = [];
    if (e) {
      let s = 0;
      for (const o in e) {
        if (o === "$vscodeTextmateLocation")
          continue;
        const l = parseInt(o, 10);
        l > s && (s = l);
      }
      for (let o = 0; o <= s; o++)
        i[o] = null;
      for (const o in e) {
        if (o === "$vscodeTextmateLocation")
          continue;
        const l = parseInt(o, 10);
        let a = 0;
        e[o].patterns && (a = Jr.getCompiledRuleId(e[o], n, r)), i[l] = Jr.createCaptureRule(n, e[o].$vscodeTextmateLocation, e[o].name, e[o].contentName, a);
      }
    }
    return i;
  }
  static _compilePatterns(e, n, r) {
    let i = [];
    if (e)
      for (let s = 0, o = e.length; s < o; s++) {
        const l = e[s];
        let a = -1;
        if (l.include) {
          const u = cN(l.include);
          switch (u.kind) {
            case 0:
            case 1:
              a = Jr.getCompiledRuleId(r[l.include], n, r);
              break;
            case 2:
              let c = r[u.ruleName];
              c && (a = Jr.getCompiledRuleId(c, n, r));
              break;
            case 3:
            case 4:
              const f = u.scopeName, d = u.kind === 4 ? u.ruleName : null, p = n.getExternalGrammar(f, r);
              if (p)
                if (d) {
                  let m = p.repository[d];
                  m && (a = Jr.getCompiledRuleId(m, n, p.repository));
                } else
                  a = Jr.getCompiledRuleId(p.repository.$self, n, p.repository);
              break;
          }
        } else
          a = Jr.getCompiledRuleId(l, n, r);
        if (a !== -1) {
          const u = n.getRule(a);
          let c = !1;
          if ((u instanceof D7 || u instanceof L4 || u instanceof Wb) && u.hasMissingPatterns && u.patterns.length === 0 && (c = !0), c)
            continue;
          i.push(a);
        }
      }
    return {
      patterns: i,
      hasMissingPatterns: (e ? e.length : 0) !== i.length
    };
  }
}, _g = class dN {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(e, n) {
    if (e && typeof e == "string") {
      const r = e.length;
      let i = 0, s = [], o = !1;
      for (let l = 0; l < r; l++)
        if (e.charAt(l) === "\\" && l + 1 < r) {
          const u = e.charAt(l + 1);
          u === "z" ? (s.push(e.substring(i, l)), s.push("$(?!\\n)(?<!\\n)"), i = l + 2) : (u === "A" || u === "G") && (o = !0), l++;
        }
      this.hasAnchor = o, i === 0 ? this.source = e : (s.push(e.substring(i, r)), this.source = s.join(""));
    } else
      this.hasAnchor = !1, this.source = e;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = gce.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new dN(this.source, this.ruleId);
  }
  setSource(e) {
    this.source !== e && (this.source = e, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(e, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let r = n.map((i) => e.substring(i.start, i.end));
    return E7.lastIndex = 0, this.source.replace(E7, (i, s) => sN(r[parseInt(s, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let e = [], n = [], r = [], i = [], s, o, l, a;
    for (s = 0, o = this.source.length; s < o; s++)
      l = this.source.charAt(s), e[s] = l, n[s] = l, r[s] = l, i[s] = l, l === "\\" && s + 1 < o && (a = this.source.charAt(s + 1), a === "A" ? (e[s + 1] = "ï¿¿", n[s + 1] = "ï¿¿", r[s + 1] = "A", i[s + 1] = "A") : a === "G" ? (e[s + 1] = "ï¿¿", n[s + 1] = "G", r[s + 1] = "ï¿¿", i[s + 1] = "G") : (e[s + 1] = a, n[s + 1] = a, r[s + 1] = a, i[s + 1] = a), s++);
    return {
      A0_G0: e.join(""),
      A0_G1: n.join(""),
      A1_G0: r.join(""),
      A1_G1: i.join("")
    };
  }
  resolveAnchors(e, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : e ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, kg = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(t) {
    this._items.push(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  unshift(t) {
    this._items.unshift(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(t, e) {
    this._items[t].source !== e && (this._disposeCaches(), this._items[t].setSource(e));
  }
  compile(t) {
    if (!this._cached) {
      let e = this._items.map((n) => n.source);
      this._cached = new O7(t, e, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(t, e, n) {
    return this._hasAnchors ? e ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(t, e, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(t, e, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(t, e, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(t, e, n)), this._anchorCache.A0_G0) : this.compile(t);
  }
  _resolveAnchors(t, e, n) {
    let r = this._items.map((i) => i.resolveAnchors(e, n));
    return new O7(t, r, this._items.map((i) => i.ruleId));
  }
}, O7 = class {
  constructor(t, e, n) {
    this.regExps = e, this.rules = n, this.scanner = t.createOnigScanner(e);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const t = [];
    for (let e = 0, n = this.rules.length; e < n; e++)
      t.push("   - " + this.rules[e] + ": " + this.regExps[e]);
    return t.join(`
`);
  }
  findNextMatchSync(t, e, n) {
    const r = this.scanner.findNextMatchSync(t, e, n);
    return r ? {
      ruleId: this.rules[r.index],
      captureIndices: r.captureIndices
    } : null;
  }
}, p3 = class {
  constructor(t, e) {
    this.languageId = t, this.tokenType = e;
  }
}, vce = class $4 {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(e, n) {
    this._defaultAttributes = new p3(
      e,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new xce(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(e) {
    return e === null ? $4._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(e);
  }
  static _NULL_SCOPE_METADATA = new p3(0, 0);
  _getBasicScopeAttributes = new oN((e) => {
    const n = this._scopeToLanguage(e), r = this._toStandardTokenType(e);
    return new p3(n, r);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(e) {
    return this._embeddedLanguagesMatcher.match(e) || 0;
  }
  _toStandardTokenType(e) {
    const n = e.match($4.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, xce = class {
  values;
  scopesRegExp;
  constructor(t) {
    if (t.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(t);
      const e = t.map(
        ([n, r]) => sN(n)
      );
      e.sort(), e.reverse(), this.scopesRegExp = new RegExp(
        `^((${e.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(t) {
    if (!this.scopesRegExp)
      return;
    const e = t.match(this.scopesRegExp);
    if (e)
      return this.values.get(e[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var F7 = class {
  constructor(t, e) {
    this.stack = t, this.stoppedEarly = e;
  }
};
function pN(t, e, n, r, i, s, o, l) {
  const a = e.content.length;
  let u = !1, c = -1;
  if (o) {
    const p = wce(
      t,
      e,
      n,
      r,
      i,
      s
    );
    i = p.stack, r = p.linePos, n = p.isFirstLine, c = p.anchorPosition;
  }
  const f = Date.now();
  for (; !u; ) {
    if (l !== 0 && Date.now() - f > l)
      return new F7(i, !0);
    d();
  }
  return new F7(i, !1);
  function d() {
    const p = _ce(
      t,
      e,
      n,
      r,
      i,
      c
    );
    if (!p) {
      s.produce(i, a), u = !0;
      return;
    }
    const m = p.captureIndices, y = p.matchedRuleId, b = m && m.length > 0 ? m[0].end > r : !1;
    if (y === mce) {
      const v = i.getRule(t);
      s.produce(i, m[0].start), i = i.withContentNameScopesList(i.nameScopesList), mp(
        t,
        e,
        n,
        i,
        s,
        v.endCaptures,
        m
      ), s.produce(i, m[0].end);
      const _ = i;
      if (i = i.parent, c = _.getAnchorPos(), !b && _.getEnterPos() === r) {
        i = _, s.produce(i, a), u = !0;
        return;
      }
    } else {
      const v = t.getRule(y);
      s.produce(i, m[0].start);
      const _ = i, k = v.getName(e.content, m), S = i.contentNameScopesList.pushAttributed(
        k,
        t
      );
      if (i = i.push(
        y,
        r,
        c,
        m[0].end === a,
        null,
        S,
        S
      ), v instanceof L4) {
        const C = v;
        mp(
          t,
          e,
          n,
          i,
          s,
          C.beginCaptures,
          m
        ), s.produce(i, m[0].end), c = m[0].end;
        const E = C.getContentName(
          e.content,
          m
        ), A = S.pushAttributed(
          E,
          t
        );
        if (i = i.withContentNameScopesList(A), C.endHasBackReferences && (i = i.withEndRule(
          C.getEndWithResolvedBackReferences(
            e.content,
            m
          )
        )), !b && _.hasSameRuleAs(i)) {
          i = i.pop(), s.produce(i, a), u = !0;
          return;
        }
      } else if (v instanceof Wb) {
        const C = v;
        mp(
          t,
          e,
          n,
          i,
          s,
          C.beginCaptures,
          m
        ), s.produce(i, m[0].end), c = m[0].end;
        const E = C.getContentName(
          e.content,
          m
        ), A = S.pushAttributed(
          E,
          t
        );
        if (i = i.withContentNameScopesList(A), C.whileHasBackReferences && (i = i.withEndRule(
          C.getWhileWithResolvedBackReferences(
            e.content,
            m
          )
        )), !b && _.hasSameRuleAs(i)) {
          i = i.pop(), s.produce(i, a), u = !0;
          return;
        }
      } else if (mp(
        t,
        e,
        n,
        i,
        s,
        v.captures,
        m
      ), s.produce(i, m[0].end), i = i.pop(), !b) {
        i = i.safePop(), s.produce(i, a), u = !0;
        return;
      }
    }
    m[0].end > r && (r = m[0].end, n = !1);
  }
}
function wce(t, e, n, r, i, s) {
  let o = i.beginRuleCapturedEOL ? 0 : -1;
  const l = [];
  for (let a = i; a; a = a.pop()) {
    const u = a.getRule(t);
    u instanceof Wb && l.push({
      rule: u,
      stack: a
    });
  }
  for (let a = l.pop(); a; a = l.pop()) {
    const { ruleScanner: u, findOptions: c } = Sce(a.rule, t, a.stack.endRule, n, r === o), f = u.findNextMatchSync(e, r, c);
    if (f) {
      if (f.ruleId !== fN) {
        i = a.stack.pop();
        break;
      }
      f.captureIndices && f.captureIndices.length && (s.produce(a.stack, f.captureIndices[0].start), mp(t, e, n, a.stack, s, a.rule.whileCaptures, f.captureIndices), s.produce(a.stack, f.captureIndices[0].end), o = f.captureIndices[0].end, f.captureIndices[0].end > r && (r = f.captureIndices[0].end, n = !1));
    } else {
      i = a.stack.pop();
      break;
    }
  }
  return { stack: i, linePos: r, anchorPosition: o, isFirstLine: n };
}
function _ce(t, e, n, r, i, s) {
  const o = kce(t, e, n, r, i, s), l = t.getInjections();
  if (l.length === 0)
    return o;
  const a = Cce(l, t, e, n, r, i, s);
  if (!a)
    return o;
  if (!o)
    return a;
  const u = o.captureIndices[0].start, c = a.captureIndices[0].start;
  return c < u || a.priorityMatch && c === u ? a : o;
}
function kce(t, e, n, r, i, s) {
  const o = i.getRule(t), { ruleScanner: l, findOptions: a } = gN(o, t, i.endRule, n, r === s), u = l.findNextMatchSync(e, r, a);
  return u ? {
    captureIndices: u.captureIndices,
    matchedRuleId: u.ruleId
  } : null;
}
function Cce(t, e, n, r, i, s, o) {
  let l = Number.MAX_VALUE, a = null, u, c = 0;
  const f = s.contentNameScopesList.getScopeNames();
  for (let d = 0, p = t.length; d < p; d++) {
    const m = t[d];
    if (!m.matcher(f))
      continue;
    const y = e.getRule(m.ruleId), { ruleScanner: b, findOptions: v } = gN(y, e, null, r, i === o), _ = b.findNextMatchSync(n, i, v);
    if (!_)
      continue;
    const k = _.captureIndices[0].start;
    if (!(k >= l) && (l = k, a = _.captureIndices, u = _.ruleId, c = m.priority, l === i))
      break;
  }
  return a ? {
    priorityMatch: c === -1,
    captureIndices: a,
    matchedRuleId: u
  } : null;
}
function gN(t, e, n, r, i) {
  return {
    ruleScanner: t.compileAG(e, n, r, i),
    findOptions: 0
    /* None */
  };
}
function Sce(t, e, n, r, i) {
  return {
    ruleScanner: t.compileWhileAG(e, n, r, i),
    findOptions: 0
    /* None */
  };
}
function mp(t, e, n, r, i, s, o) {
  if (s.length === 0)
    return;
  const l = e.content, a = Math.min(s.length, o.length), u = [], c = o[0].end;
  for (let f = 0; f < a; f++) {
    const d = s[f];
    if (d === null)
      continue;
    const p = o[f];
    if (p.length === 0)
      continue;
    if (p.start > c)
      break;
    for (; u.length > 0 && u[u.length - 1].endPos <= p.start; )
      i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
    if (u.length > 0 ? i.produceFromScopes(u[u.length - 1].scopes, p.start) : i.produce(r, p.start), d.retokenizeCapturedWithRuleId) {
      const y = d.getName(l, o), b = r.contentNameScopesList.pushAttributed(y, t), v = d.getContentName(l, o), _ = b.pushAttributed(v, t), k = r.push(d.retokenizeCapturedWithRuleId, p.start, -1, !1, null, b, _), S = t.createOnigString(l.substring(0, p.end));
      pN(
        t,
        S,
        n && p.start === 0,
        p.start,
        k,
        i,
        !1,
        /* no time limit */
        0
      ), uN(S);
      continue;
    }
    const m = d.getName(l, o);
    if (m !== null) {
      const b = (u.length > 0 ? u[u.length - 1].scopes : r.contentNameScopesList).pushAttributed(m, t);
      u.push(new Ace(b, p.end));
    }
  }
  for (; u.length > 0; )
    i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
}
var Ace = class {
  scopes;
  endPos;
  constructor(t, e) {
    this.scopes = t, this.endPos = e;
  }
};
function Ece(t, e, n, r, i, s, o, l) {
  return new Oce(
    t,
    e,
    n,
    r,
    i,
    s,
    o,
    l
  );
}
function T7(t, e, n, r, i) {
  const s = Hb(e, Gb), o = hN.getCompiledRuleId(n, r, i.repository);
  for (const l of s)
    t.push({
      debugSelector: e,
      matcher: l.matcher,
      ruleId: o,
      grammar: i,
      priority: l.priority
    });
}
function Gb(t, e) {
  if (e.length < t.length)
    return !1;
  let n = 0;
  return t.every((r) => {
    for (let i = n; i < e.length; i++)
      if (Dce(e[i], r))
        return n = i + 1, !0;
    return !1;
  });
}
function Dce(t, e) {
  if (!t)
    return !1;
  if (t === e)
    return !0;
  const n = e.length;
  return t.length > n && t.substr(0, n) === e && t[n] === ".";
}
var Oce = class {
  constructor(t, e, n, r, i, s, o, l) {
    if (this._rootScopeName = t, this.balancedBracketSelectors = s, this._onigLib = l, this._basicScopeAttributesProvider = new vce(
      n,
      r
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = o, this._grammar = R7(e, null), this._injections = null, this._tokenTypeMatchers = [], i)
      for (const a of Object.keys(i)) {
        const u = Hb(a, Gb);
        for (const c of u)
          this._tokenTypeMatchers.push({
            matcher: c.matcher,
            type: i[a]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const t of this._ruleId2desc)
      t && t.dispose();
  }
  createOnigScanner(t) {
    return this._onigLib.createOnigScanner(t);
  }
  createOnigString(t) {
    return this._onigLib.createOnigString(t);
  }
  getMetadataForScope(t) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(t);
  }
  _collectInjections() {
    const t = {
      lookup: (i) => i === this._rootScopeName ? this._grammar : this.getExternalGrammar(i),
      injections: (i) => this._grammarRepository.injections(i)
    }, e = [], n = this._rootScopeName, r = t.lookup(n);
    if (r) {
      const i = r.injections;
      if (i)
        for (let o in i)
          T7(
            e,
            o,
            i[o],
            this,
            r
          );
      const s = this._grammarRepository.injections(n);
      s && s.forEach((o) => {
        const l = this.getExternalGrammar(o);
        if (l) {
          const a = l.injectionSelector;
          a && T7(
            e,
            a,
            l,
            this,
            l
          );
        }
      });
    }
    return e.sort((i, s) => i.priority - s.priority), e;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(t) {
    const e = ++this._lastRuleId, n = t(e);
    return this._ruleId2desc[e] = n, n;
  }
  getRule(t) {
    return this._ruleId2desc[t];
  }
  getExternalGrammar(t, e) {
    if (this._includedGrammars[t])
      return this._includedGrammars[t];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(t);
      if (n)
        return this._includedGrammars[t] = R7(
          n,
          e && e.$base
        ), this._includedGrammars[t];
    }
  }
  tokenizeLine(t, e, n = 0) {
    const r = this._tokenize(t, e, !1, n);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(t, e, n = 0) {
    const r = this._tokenize(t, e, !0, n);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(t, e, n, r) {
    this._rootId === -1 && (this._rootId = hN.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let i;
    if (!e || e === z4.NULL) {
      i = !0;
      const u = this._basicScopeAttributesProvider.getDefaultAttributes(), c = this.themeProvider.getDefaults(), f = Fd.set(
        0,
        u.languageId,
        u.tokenType,
        null,
        c.fontStyle,
        c.foregroundId,
        c.backgroundId
      ), d = this.getRule(this._rootId).getName(
        null,
        null
      );
      let p;
      d ? p = Rp.createRootAndLookUpScopeName(
        d,
        f,
        this
      ) : p = Rp.createRoot(
        "unknown",
        f
      ), e = new z4(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        p,
        p
      );
    } else
      i = !1, e.reset();
    t = t + `
`;
    const s = this.createOnigString(t), o = s.content.length, l = new Tce(
      n,
      t,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), a = pN(
      this,
      s,
      i,
      0,
      e,
      l,
      !0,
      r
    );
    return uN(s), {
      lineLength: o,
      lineTokens: l,
      ruleStack: a.stack,
      stoppedEarly: a.stoppedEarly
    };
  }
};
function R7(t, e) {
  return t = Kue(t), t.repository = t.repository || {}, t.repository.$self = {
    $vscodeTextmateLocation: t.$vscodeTextmateLocation,
    patterns: t.patterns,
    name: t.scopeName
  }, t.repository.$base = e || t.repository.$self, t;
}
var Rp = class bl {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, n, r) {
    this.parent = e, this.scopePath = n, this.tokenAttributes = r;
  }
  static fromExtension(e, n) {
    let r = e, i = e?.scopePath ?? null;
    for (const s of n)
      i = d3.push(i, s.scopeNames), r = new bl(r, i, s.encodedTokenAttributes);
    return r;
  }
  static createRoot(e, n) {
    return new bl(null, new d3(null, e), n);
  }
  static createRootAndLookUpScopeName(e, n, r) {
    const i = r.getMetadataForScope(e), s = new d3(null, e), o = r.themeProvider.themeMatch(s), l = bl.mergeAttributes(
      n,
      i,
      o
    );
    return new bl(null, s, l);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(e) {
    return bl.equals(this, e);
  }
  static equals(e, n) {
    do {
      if (e === n || !e && !n)
        return !0;
      if (!e || !n || e.scopeName !== n.scopeName || e.tokenAttributes !== n.tokenAttributes)
        return !1;
      e = e.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(e, n, r) {
    let i = -1, s = 0, o = 0;
    return r !== null && (i = r.fontStyle, s = r.foregroundId, o = r.backgroundId), Fd.set(
      e,
      n.languageId,
      n.tokenType,
      null,
      i,
      s,
      o
    );
  }
  pushAttributed(e, n) {
    if (e === null)
      return this;
    if (e.indexOf(" ") === -1)
      return bl._pushAttributed(this, e, n);
    const r = e.split(/ /g);
    let i = this;
    for (const s of r)
      i = bl._pushAttributed(i, s, n);
    return i;
  }
  static _pushAttributed(e, n, r) {
    const i = r.getMetadataForScope(n), s = e.scopePath.push(n), o = r.themeProvider.themeMatch(s), l = bl.mergeAttributes(
      e.tokenAttributes,
      i,
      o
    );
    return new bl(e, s, l);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(e) {
    const n = [];
    let r = this;
    for (; r && r !== e; )
      n.push({
        encodedTokenAttributes: r.tokenAttributes,
        scopeNames: r.scopePath.getExtensionIfDefined(r.parent?.scopePath ?? null)
      }), r = r.parent;
    return r === e ? n.reverse() : void 0;
  }
}, z4 = class Nc {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, n, r, i, s, o, l, a) {
    this.parent = e, this.ruleId = n, this.beginRuleCapturedEOL = s, this.endRule = o, this.nameScopesList = l, this.contentNameScopesList = a, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = r, this._anchorPos = i;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new Nc(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(e) {
    return e === null ? !1 : Nc._equals(this, e);
  }
  static _equals(e, n) {
    return e === n ? !0 : this._structuralEquals(e, n) ? Rp.equals(e.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(e, n) {
    do {
      if (e === n || !e && !n)
        return !0;
      if (!e || !n || e.depth !== n.depth || e.ruleId !== n.ruleId || e.endRule !== n.endRule)
        return !1;
      e = e.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(e) {
    for (; e; )
      e._enterPos = -1, e._anchorPos = -1, e = e.parent;
  }
  reset() {
    Nc._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(e, n, r, i, s, o, l) {
    return new Nc(
      this,
      e,
      n,
      r,
      i,
      s,
      o,
      l
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(e) {
    return e.getRule(this.ruleId);
  }
  toString() {
    const e = [];
    return this._writeString(e, 0), "[" + e.join(",") + "]";
  }
  _writeString(e, n) {
    return this.parent && (n = this.parent._writeString(e, n)), e[n++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, n;
  }
  withContentNameScopesList(e) {
    return this.contentNameScopesList === e ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      e
    );
  }
  withEndRule(e) {
    return this.endRule === e ? this : new Nc(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      e,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(e) {
    let n = this;
    for (; n && n._enterPos === e._enterPos; ) {
      if (n.ruleId === e.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(e, n) {
    const r = Rp.fromExtension(e?.nameScopesList ?? null, n.nameScopesList);
    return new Nc(
      e,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      r,
      Rp.fromExtension(r, n.contentNameScopesList)
    );
  }
}, Fce = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(t, e) {
    this.balancedBracketScopes = t.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : Hb(n, Gb).map((r) => r.matcher)
    ), this.unbalancedBracketScopes = e.flatMap(
      (n) => Hb(n, Gb).map((r) => r.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(t) {
    for (const e of this.unbalancedBracketScopes)
      if (e(t))
        return !1;
    for (const e of this.balancedBracketScopes)
      if (e(t))
        return !0;
    return this.allowAny;
  }
}, Tce = class {
  constructor(t, e, n, r) {
    this.balancedBracketSelectors = r, this._emitBinaryTokens = t, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(t, e) {
    this.produceFromScopes(t.contentNameScopesList, e);
  }
  produceFromScopes(t, e) {
    if (this._lastTokenEndIndex >= e)
      return;
    if (this._emitBinaryTokens) {
      let r = t?.tokenAttributes ?? 0, i = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const s = t?.getScopeNames() ?? [];
        for (const o of this._tokenTypeOverrides)
          o.matcher(s) && (r = Fd.set(
            r,
            0,
            o.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(s));
      }
      if (i && (r = Fd.set(
        r,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = e;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = e;
      return;
    }
    const n = t?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: e,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = e;
  }
  getResult(t, e) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === e - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(t, e) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === e - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let r = 0, i = this._binaryTokens.length; r < i; r++)
      n[r] = this._binaryTokens[r];
    return n;
  }
}, Rce = class {
  constructor(t, e) {
    this._onigLib = e, this._theme = t;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const t of this._grammars.values())
      t.dispose();
  }
  setTheme(t) {
    this._theme = t;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(t, e) {
    this._rawGrammars.set(t.scopeName, t), e && this._injectionGrammars.set(t.scopeName, e);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(t) {
    return this._rawGrammars.get(t);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(t) {
    return this._injectionGrammars.get(t);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(t) {
    return this._theme.match(t);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(t, e, n, r, i) {
    if (!this._grammars.has(t)) {
      let s = this._rawGrammars.get(t);
      if (!s)
        return null;
      this._grammars.set(t, Ece(
        t,
        s,
        e,
        n,
        r,
        i,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(t);
  }
}, Mce = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(e) {
    this._options = e, this._syncRegistry = new Rce(
      Ub.createFromRawTheme(e.theme, e.colorMap),
      e.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(e, n) {
    this._syncRegistry.setTheme(Ub.createFromRawTheme(e, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(e, n, r) {
    return this.loadGrammarWithConfiguration(e, n, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(e, n, r) {
    return this._loadGrammar(
      e,
      n,
      r.embeddedLanguages,
      r.tokenTypes,
      new Fce(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(e) {
    return this._loadGrammar(e, 0, null, null, null);
  }
  _loadGrammar(e, n, r, i, s) {
    const o = new ace(this._syncRegistry, e);
    for (; o.Q.length > 0; )
      o.Q.map((l) => this._loadSingleGrammar(l.scopeName)), o.processQueue();
    return this._grammarForScopeName(
      e,
      n,
      r,
      i,
      s
    );
  }
  _loadSingleGrammar(e) {
    this._ensureGrammarCache.has(e) || (this._doLoadSingleGrammar(e), this._ensureGrammarCache.set(e, !0));
  }
  _doLoadSingleGrammar(e) {
    const n = this._options.loadGrammar(e);
    if (n) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(e) : void 0;
      this._syncRegistry.addGrammar(n, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(e, n = [], r = 0, i = null) {
    return this._syncRegistry.addGrammar(e, n), this._grammarForScopeName(e.scopeName, r, i);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(e, n = 0, r = null, i = null, s = null) {
    return this._syncRegistry.grammarForScopeName(
      e,
      n,
      r,
      i,
      s
    );
  }
}, j4 = z4.NULL;
const Pce = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
let cm = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
};
cm.prototype.normal = {};
cm.prototype.property = {};
cm.prototype.space = void 0;
function mN(t, e) {
  const n = {}, r = {};
  for (const i of t)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new cm(n, r, e);
}
function q4(t) {
  return t.toLowerCase();
}
class ms {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
}
ms.prototype.attribute = "";
ms.prototype.booleanish = !1;
ms.prototype.boolean = !1;
ms.prototype.commaOrSpaceSeparated = !1;
ms.prototype.commaSeparated = !1;
ms.prototype.defined = !1;
ms.prototype.mustUseProperty = !1;
ms.prototype.number = !1;
ms.prototype.overloadedBoolean = !1;
ms.prototype.property = "";
ms.prototype.spaceSeparated = !1;
ms.prototype.space = void 0;
let Ice = 0;
const Et = jf(), gr = jf(), U4 = jf(), Ae = jf(), Mn = jf(), Qh = jf(), Es = jf();
function jf() {
  return 2 ** ++Ice;
}
const H4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Et,
  booleanish: gr,
  commaOrSpaceSeparated: Es,
  commaSeparated: Qh,
  number: Ae,
  overloadedBoolean: U4,
  spaceSeparated: Mn
}, Symbol.toStringTag, { value: "Module" })), g3 = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(H4)
);
class s5 extends ms {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), M7(this, "space", i), typeof r == "number")
      for (; ++s < g3.length; ) {
        const o = g3[s];
        M7(this, g3[s], (r & H4[o]) === H4[o]);
      }
  }
}
s5.prototype.defined = !0;
function M7(t, e, n) {
  n && (t[e] = n);
}
function n0(t) {
  const e = {}, n = {};
  for (const [r, i] of Object.entries(t.properties)) {
    const s = new s5(
      r,
      t.transform(t.attributes || {}, r),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[q4(r)] = r, n[q4(s.attribute)] = r;
  }
  return new cm(e, n, t.space);
}
const yN = n0({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: gr,
    ariaAutoComplete: null,
    ariaBusy: gr,
    ariaChecked: gr,
    ariaColCount: Ae,
    ariaColIndex: Ae,
    ariaColSpan: Ae,
    ariaControls: Mn,
    ariaCurrent: null,
    ariaDescribedBy: Mn,
    ariaDetails: null,
    ariaDisabled: gr,
    ariaDropEffect: Mn,
    ariaErrorMessage: null,
    ariaExpanded: gr,
    ariaFlowTo: Mn,
    ariaGrabbed: gr,
    ariaHasPopup: null,
    ariaHidden: gr,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Mn,
    ariaLevel: Ae,
    ariaLive: null,
    ariaModal: gr,
    ariaMultiLine: gr,
    ariaMultiSelectable: gr,
    ariaOrientation: null,
    ariaOwns: Mn,
    ariaPlaceholder: null,
    ariaPosInSet: Ae,
    ariaPressed: gr,
    ariaReadOnly: gr,
    ariaRelevant: null,
    ariaRequired: gr,
    ariaRoleDescription: Mn,
    ariaRowCount: Ae,
    ariaRowIndex: Ae,
    ariaRowSpan: Ae,
    ariaSelected: gr,
    ariaSetSize: Ae,
    ariaSort: null,
    ariaValueMax: Ae,
    ariaValueMin: Ae,
    ariaValueNow: Ae,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function bN(t, e) {
  return e in t ? t[e] : e;
}
function vN(t, e) {
  return bN(t, e.toLowerCase());
}
const Nce = n0({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Qh,
    acceptCharset: Mn,
    accessKey: Mn,
    action: null,
    allow: null,
    allowFullScreen: Et,
    allowPaymentRequest: Et,
    allowUserMedia: Et,
    alt: null,
    as: null,
    async: Et,
    autoCapitalize: null,
    autoComplete: Mn,
    autoFocus: Et,
    autoPlay: Et,
    blocking: Mn,
    capture: null,
    charSet: null,
    checked: Et,
    cite: null,
    className: Mn,
    cols: Ae,
    colSpan: null,
    content: null,
    contentEditable: gr,
    controls: Et,
    controlsList: Mn,
    coords: Ae | Qh,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Et,
    defer: Et,
    dir: null,
    dirName: null,
    disabled: Et,
    download: U4,
    draggable: gr,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Et,
    formTarget: null,
    headers: Mn,
    height: Ae,
    hidden: U4,
    high: Ae,
    href: null,
    hrefLang: null,
    htmlFor: Mn,
    httpEquiv: Mn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Et,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Et,
    itemId: null,
    itemProp: Mn,
    itemRef: Mn,
    itemScope: Et,
    itemType: Mn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Et,
    low: Ae,
    manifest: null,
    max: null,
    maxLength: Ae,
    media: null,
    method: null,
    min: null,
    minLength: Ae,
    multiple: Et,
    muted: Et,
    name: null,
    nonce: null,
    noModule: Et,
    noValidate: Et,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Et,
    optimum: Ae,
    pattern: null,
    ping: Mn,
    placeholder: null,
    playsInline: Et,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Et,
    referrerPolicy: null,
    rel: Mn,
    required: Et,
    reversed: Et,
    rows: Ae,
    rowSpan: Ae,
    sandbox: Mn,
    scope: null,
    scoped: Et,
    seamless: Et,
    selected: Et,
    shadowRootClonable: Et,
    shadowRootDelegatesFocus: Et,
    shadowRootMode: null,
    shape: null,
    size: Ae,
    sizes: null,
    slot: null,
    span: Ae,
    spellCheck: gr,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Ae,
    step: null,
    style: null,
    tabIndex: Ae,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Et,
    useMap: null,
    value: gr,
    width: Ae,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Mn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Ae,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Ae,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Et,
    // Lists. Use CSS to reduce space between items instead
    declare: Et,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Ae,
    // `<img>` and `<object>`
    leftMargin: Ae,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Ae,
    // `<body>`
    marginWidth: Ae,
    // `<body>`
    noResize: Et,
    // `<frame>`
    noHref: Et,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Et,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Et,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Ae,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: gr,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Ae,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Ae,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Et,
    disableRemotePlayback: Et,
    prefix: null,
    property: null,
    results: Ae,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: vN
}), Bce = n0({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Es,
    accentHeight: Ae,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Ae,
    amplitude: Ae,
    arabicForm: null,
    ascent: Ae,
    attributeName: null,
    attributeType: null,
    azimuth: Ae,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Ae,
    by: null,
    calcMode: null,
    capHeight: Ae,
    className: Mn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Ae,
    diffuseConstant: Ae,
    direction: null,
    display: null,
    dur: null,
    divisor: Ae,
    dominantBaseline: null,
    download: Et,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Ae,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Ae,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Ae,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Qh,
    g2: Qh,
    glyphName: Qh,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Ae,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Ae,
    horizOriginX: Ae,
    horizOriginY: Ae,
    id: null,
    ideographic: Ae,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Ae,
    k: Ae,
    k1: Ae,
    k2: Ae,
    k3: Ae,
    k4: Ae,
    kernelMatrix: Es,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Ae,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Ae,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Ae,
    overlineThickness: Ae,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Ae,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Mn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Ae,
    pointsAtY: Ae,
    pointsAtZ: Ae,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Es,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Es,
    rev: Es,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Es,
    requiredFeatures: Es,
    requiredFonts: Es,
    requiredFormats: Es,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Ae,
    specularExponent: Ae,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Ae,
    strikethroughThickness: Ae,
    string: null,
    stroke: null,
    strokeDashArray: Es,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Ae,
    strokeOpacity: Ae,
    strokeWidth: null,
    style: null,
    surfaceScale: Ae,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Es,
    tabIndex: Ae,
    tableValues: null,
    target: null,
    targetX: Ae,
    targetY: Ae,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Es,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Ae,
    underlineThickness: Ae,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Ae,
    values: null,
    vAlphabetic: Ae,
    vMathematical: Ae,
    vectorEffect: null,
    vHanging: Ae,
    vIdeographic: Ae,
    version: null,
    vertAdvY: Ae,
    vertOriginX: Ae,
    vertOriginY: Ae,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Ae,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: bN
}), xN = n0({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), wN = n0({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: vN
}), _N = n0({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), Lce = /[A-Z]/g, P7 = /-[a-z]/g, $ce = /^data[-\w.:]+$/i;
function zce(t, e) {
  const n = q4(e);
  let r = e, i = ms;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && $ce.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(P7, qce);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!P7.test(s)) {
        let o = s.replace(Lce, jce);
        o.charAt(0) !== "-" && (o = "-" + o), e = "data" + o;
      }
    }
    i = s5;
  }
  return new i(r, e);
}
function jce(t) {
  return "-" + t.toLowerCase();
}
function qce(t) {
  return t.charAt(1).toUpperCase();
}
const Uce = mN([yN, Nce, xN, wN, _N], "html"), kN = mN([yN, Bce, xN, wN, _N], "svg"), I7 = {}.hasOwnProperty;
function Hce(t, e) {
  const n = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const l = r.handlers;
    if (i && I7.call(i, t)) {
      const a = String(i[t]);
      o = I7.call(l, a) ? l[a] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const Vce = /["&'<>`]/g, Wce = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Gce = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), Kce = /[|\\{}()[\]^$+*?.]/g, N7 = /* @__PURE__ */ new WeakMap();
function Yce(t, e) {
  if (t = t.replace(
    e.subset ? Xce(e.subset) : Vce,
    r
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(Wce, n).replace(Gce, r);
  function n(i, s, o) {
    return e.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      o.charCodeAt(s + 2),
      e
    );
  }
  function r(i, s, o) {
    return e.format(
      i.charCodeAt(0),
      o.charCodeAt(s + 1),
      e
    );
  }
}
function Xce(t) {
  let e = N7.get(t);
  return e || (e = Qce(t), N7.set(t, e)), e;
}
function Qce(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e.push(t[n].replace(Kce, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
const Jce = /[\dA-Fa-f]/;
function Zce(t, e, n) {
  const r = "&#x" + t.toString(16).toUpperCase();
  return n && e && !Jce.test(String.fromCharCode(e)) ? r : r + ";";
}
const efe = /\d/;
function tfe(t, e, n) {
  const r = "&#" + String(t);
  return n && e && !efe.test(String.fromCharCode(e)) ? r : r + ";";
}
const nfe = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], m3 = {
  nbsp: "Â ",
  iexcl: "Â¡",
  cent: "Â¢",
  pound: "Â£",
  curren: "Â¤",
  yen: "Â¥",
  brvbar: "Â¦",
  sect: "Â§",
  uml: "Â¨",
  copy: "Â©",
  ordf: "Âª",
  laquo: "Â«",
  not: "Â¬",
  shy: "Â­",
  reg: "Â®",
  macr: "Â¯",
  deg: "Â°",
  plusmn: "Â±",
  sup2: "Â²",
  sup3: "Â³",
  acute: "Â´",
  micro: "Âµ",
  para: "Â¶",
  middot: "Â·",
  cedil: "Â¸",
  sup1: "Â¹",
  ordm: "Âº",
  raquo: "Â»",
  frac14: "Â¼",
  frac12: "Â½",
  frac34: "Â¾",
  iquest: "Â¿",
  Agrave: "Ã€",
  Aacute: "Ã",
  Acirc: "Ã‚",
  Atilde: "Ãƒ",
  Auml: "Ã„",
  Aring: "Ã…",
  AElig: "Ã†",
  Ccedil: "Ã‡",
  Egrave: "Ãˆ",
  Eacute: "Ã‰",
  Ecirc: "ÃŠ",
  Euml: "Ã‹",
  Igrave: "ÃŒ",
  Iacute: "Ã",
  Icirc: "ÃŽ",
  Iuml: "Ã",
  ETH: "Ã",
  Ntilde: "Ã‘",
  Ograve: "Ã’",
  Oacute: "Ã“",
  Ocirc: "Ã”",
  Otilde: "Ã•",
  Ouml: "Ã–",
  times: "Ã—",
  Oslash: "Ã˜",
  Ugrave: "Ã™",
  Uacute: "Ãš",
  Ucirc: "Ã›",
  Uuml: "Ãœ",
  Yacute: "Ã",
  THORN: "Ãž",
  szlig: "ÃŸ",
  agrave: "Ã ",
  aacute: "Ã¡",
  acirc: "Ã¢",
  atilde: "Ã£",
  auml: "Ã¤",
  aring: "Ã¥",
  aelig: "Ã¦",
  ccedil: "Ã§",
  egrave: "Ã¨",
  eacute: "Ã©",
  ecirc: "Ãª",
  euml: "Ã«",
  igrave: "Ã¬",
  iacute: "Ã­",
  icirc: "Ã®",
  iuml: "Ã¯",
  eth: "Ã°",
  ntilde: "Ã±",
  ograve: "Ã²",
  oacute: "Ã³",
  ocirc: "Ã´",
  otilde: "Ãµ",
  ouml: "Ã¶",
  divide: "Ã·",
  oslash: "Ã¸",
  ugrave: "Ã¹",
  uacute: "Ãº",
  ucirc: "Ã»",
  uuml: "Ã¼",
  yacute: "Ã½",
  thorn: "Ã¾",
  yuml: "Ã¿",
  fnof: "Æ’",
  Alpha: "Î‘",
  Beta: "Î’",
  Gamma: "Î“",
  Delta: "Î”",
  Epsilon: "Î•",
  Zeta: "Î–",
  Eta: "Î—",
  Theta: "Î˜",
  Iota: "Î™",
  Kappa: "Îš",
  Lambda: "Î›",
  Mu: "Îœ",
  Nu: "Î",
  Xi: "Îž",
  Omicron: "ÎŸ",
  Pi: "Î ",
  Rho: "Î¡",
  Sigma: "Î£",
  Tau: "Î¤",
  Upsilon: "Î¥",
  Phi: "Î¦",
  Chi: "Î§",
  Psi: "Î¨",
  Omega: "Î©",
  alpha: "Î±",
  beta: "Î²",
  gamma: "Î³",
  delta: "Î´",
  epsilon: "Îµ",
  zeta: "Î¶",
  eta: "Î·",
  theta: "Î¸",
  iota: "Î¹",
  kappa: "Îº",
  lambda: "Î»",
  mu: "Î¼",
  nu: "Î½",
  xi: "Î¾",
  omicron: "Î¿",
  pi: "Ï€",
  rho: "Ï",
  sigmaf: "Ï‚",
  sigma: "Ïƒ",
  tau: "Ï„",
  upsilon: "Ï…",
  phi: "Ï†",
  chi: "Ï‡",
  psi: "Ïˆ",
  omega: "Ï‰",
  thetasym: "Ï‘",
  upsih: "Ï’",
  piv: "Ï–",
  bull: "â€¢",
  hellip: "â€¦",
  prime: "â€²",
  Prime: "â€³",
  oline: "â€¾",
  frasl: "â„",
  weierp: "â„˜",
  image: "â„‘",
  real: "â„œ",
  trade: "â„¢",
  alefsym: "â„µ",
  larr: "â†",
  uarr: "â†‘",
  rarr: "â†’",
  darr: "â†“",
  harr: "â†”",
  crarr: "â†µ",
  lArr: "â‡",
  uArr: "â‡‘",
  rArr: "â‡’",
  dArr: "â‡“",
  hArr: "â‡”",
  forall: "âˆ€",
  part: "âˆ‚",
  exist: "âˆƒ",
  empty: "âˆ…",
  nabla: "âˆ‡",
  isin: "âˆˆ",
  notin: "âˆ‰",
  ni: "âˆ‹",
  prod: "âˆ",
  sum: "âˆ‘",
  minus: "âˆ’",
  lowast: "âˆ—",
  radic: "âˆš",
  prop: "âˆ",
  infin: "âˆž",
  ang: "âˆ ",
  and: "âˆ§",
  or: "âˆ¨",
  cap: "âˆ©",
  cup: "âˆª",
  int: "âˆ«",
  there4: "âˆ´",
  sim: "âˆ¼",
  cong: "â‰…",
  asymp: "â‰ˆ",
  ne: "â‰ ",
  equiv: "â‰¡",
  le: "â‰¤",
  ge: "â‰¥",
  sub: "âŠ‚",
  sup: "âŠƒ",
  nsub: "âŠ„",
  sube: "âŠ†",
  supe: "âŠ‡",
  oplus: "âŠ•",
  otimes: "âŠ—",
  perp: "âŠ¥",
  sdot: "â‹…",
  lceil: "âŒˆ",
  rceil: "âŒ‰",
  lfloor: "âŒŠ",
  rfloor: "âŒ‹",
  lang: "âŒ©",
  rang: "âŒª",
  loz: "â—Š",
  spades: "â™ ",
  clubs: "â™£",
  hearts: "â™¥",
  diams: "â™¦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Å’",
  oelig: "Å“",
  Scaron: "Å ",
  scaron: "Å¡",
  Yuml: "Å¸",
  circ: "Ë†",
  tilde: "Ëœ",
  ensp: "â€‚",
  emsp: "â€ƒ",
  thinsp: "â€‰",
  zwnj: "â€Œ",
  zwj: "â€",
  lrm: "â€Ž",
  rlm: "â€",
  ndash: "â€“",
  mdash: "â€”",
  lsquo: "â€˜",
  rsquo: "â€™",
  sbquo: "â€š",
  ldquo: "â€œ",
  rdquo: "â€",
  bdquo: "â€ž",
  dagger: "â€ ",
  Dagger: "â€¡",
  permil: "â€°",
  lsaquo: "â€¹",
  rsaquo: "â€º",
  euro: "â‚¬"
}, rfe = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], CN = {}.hasOwnProperty, V4 = {};
let ty;
for (ty in m3)
  CN.call(m3, ty) && (V4[m3[ty]] = ty);
const ife = /[^\dA-Za-z]/;
function sfe(t, e, n, r) {
  const i = String.fromCharCode(t);
  if (CN.call(V4, i)) {
    const s = V4[i], o = "&" + s;
    return n && nfe.includes(s) && !rfe.includes(s) && (!r || e && e !== 61 && ife.test(String.fromCharCode(e))) ? o : o + ";";
  }
  return "";
}
function ofe(t, e, n) {
  let r = Zce(t, e, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = sfe(
    t,
    e,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const s = tfe(t, e, n.omitOptionalSemicolons);
    s.length < r.length && (r = s);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function Jh(t, e) {
  return Yce(t, Object.assign({ format: ofe }, e));
}
const lfe = /^>|^->|<!--|-->|--!>|<!-$/g, afe = [">"], ufe = ["<", ">"];
function cfe(t, e, n, r) {
  return r.settings.bogusComments ? "<?" + Jh(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: afe
    })
  ) + ">" : "<!--" + t.value.replace(lfe, i) + "-->";
  function i(s) {
    return Jh(
      s,
      Object.assign({}, r.settings.characterReferences, {
        subset: ufe
      })
    );
  }
}
function ffe(t, e, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
function B7(t, e) {
  const n = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(e);
  for (; i !== -1; )
    r++, i = n.indexOf(e, i + e.length);
  return r;
}
function hfe(t, e) {
  const n = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
function dfe(t) {
  return t.join(" ").trim();
}
const pfe = /[ \t\n\f\r]/g;
function o5(t) {
  return typeof t == "object" ? t.type === "text" ? L7(t.value) : !1 : L7(t);
}
function L7(t) {
  return t.replace(pfe, "") === "";
}
const Or = AN(1), SN = AN(-1), gfe = [];
function AN(t) {
  return e;
  function e(n, r, i) {
    const s = n ? n.children : gfe;
    let o = (r || 0) + t, l = s[o];
    if (!i)
      for (; l && o5(l); )
        o += t, l = s[o];
    return l;
  }
}
const mfe = {}.hasOwnProperty;
function EN(t) {
  return e;
  function e(n, r, i) {
    return mfe.call(t, n.tagName) && t[n.tagName](n, r, i);
  }
}
const l5 = EN({
  body: bfe,
  caption: y3,
  colgroup: y3,
  dd: _fe,
  dt: wfe,
  head: y3,
  html: yfe,
  li: xfe,
  optgroup: kfe,
  option: Cfe,
  p: vfe,
  rp: $7,
  rt: $7,
  tbody: Afe,
  td: z7,
  tfoot: Efe,
  th: z7,
  thead: Sfe,
  tr: Dfe
});
function y3(t, e, n) {
  const r = Or(n, e, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && o5(r.value.charAt(0)));
}
function yfe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type !== "comment";
}
function bfe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type !== "comment";
}
function vfe(t, e, n) {
  const r = Or(n, e);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function xfe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && r.tagName === "li";
}
function wfe(t, e, n) {
  const r = Or(n, e);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function _fe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function $7(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function kfe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function Cfe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function Sfe(t, e, n) {
  const r = Or(n, e);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function Afe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function Efe(t, e, n) {
  return !Or(n, e);
}
function Dfe(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && r.tagName === "tr";
}
function z7(t, e, n) {
  const r = Or(n, e);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const Ofe = EN({
  body: Rfe,
  colgroup: Mfe,
  head: Tfe,
  html: Ffe,
  tbody: Pfe
});
function Ffe(t) {
  const e = Or(t, -1);
  return !e || e.type !== "comment";
}
function Tfe(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r of t.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (e.has(r.tagName)) return !1;
      e.add(r.tagName);
    }
  const n = t.children[0];
  return !n || n.type === "element";
}
function Rfe(t) {
  const e = Or(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && o5(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function Mfe(t, e, n) {
  const r = SN(n, e), i = Or(t, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && l5(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function Pfe(t, e, n) {
  const r = SN(n, e), i = Or(t, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && l5(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const ny = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Ife(t, e, n, r) {
  const i = r.schema, s = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let o = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
  const l = [];
  let a;
  i.space === "html" && t.tagName === "svg" && (r.schema = kN);
  const u = Nfe(r, t.properties), c = r.all(
    i.space === "html" && t.tagName === "template" ? t.content : t
  );
  return r.schema = i, c && (o = !1), (u || !s || !Ofe(t, e, n)) && (l.push("<", t.tagName, u ? " " + u : ""), o && (i.space === "svg" || r.settings.closeSelfClosing) && (a = u.charAt(u.length - 1), (!r.settings.tightSelfClosing || a === "/" || a && a !== '"' && a !== "'") && l.push(" "), l.push("/")), l.push(">")), l.push(c), !o && (!s || !l5(t, e, n)) && l.push("</" + t.tagName + ">"), l.join("");
}
function Nfe(t, e) {
  const n = [];
  let r = -1, i;
  if (e) {
    for (i in e)
      if (e[i] !== null && e[i] !== void 0) {
        const s = Bfe(t, i, e[i]);
        s && n.push(s);
      }
  }
  for (; ++r < n.length; ) {
    const s = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && s !== '"' && s !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function Bfe(t, e, n) {
  const r = zce(t.schema, e), i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, s = t.settings.allowDangerousCharacters ? 0 : 1;
  let o = t.quote, l;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const a = Jh(
    r.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: ny.name[i][s]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? hfe : dfe)(n, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(n), t.settings.collapseEmptyAttributes && !n) ? a : (t.settings.preferUnquoted && (l = Jh(
    n,
    Object.assign({}, t.settings.characterReferences, {
      attribute: !0,
      subset: ny.unquoted[i][s]
    })
  )), l !== n && (t.settings.quoteSmart && B7(n, o) > B7(n, t.alternative) && (o = t.alternative), l = o + Jh(
    n,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (o === "'" ? ny.single : ny.double)[i][s],
      attribute: !0
    })
  ) + o), a + (l && "=" + l));
}
const Lfe = ["<", "&"];
function DN(t, e, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : Jh(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: Lfe
    })
  );
}
function $fe(t, e, n, r) {
  return r.settings.allowDangerousHtml ? t.value : DN(t, e, n, r);
}
function zfe(t, e, n, r) {
  return r.all(t);
}
const jfe = Hce("type", {
  invalid: qfe,
  unknown: Ufe,
  handlers: { comment: cfe, doctype: ffe, element: Ife, raw: $fe, root: zfe, text: DN }
});
function qfe(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function Ufe(t) {
  const e = (
    /** @type {Nodes} */
    t
  );
  throw new Error("Cannot compile unknown node `" + e.type + "`");
}
const Hfe = {}, Vfe = {}, Wfe = [];
function Gfe(t, e) {
  const n = Hfe, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: Kfe,
    all: Yfe,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || Pce,
      characterReferences: n.characterReferences || Vfe,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? kN : Uce,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function Kfe(t, e, n) {
  return jfe(t, e, n, this);
}
function Yfe(t) {
  const e = [], n = t && t.children || Wfe;
  let r = -1;
  for (; ++r < n.length; )
    e[r] = this.one(n[r], r, t);
  return e.join("");
}
function Xfe(t) {
  return Array.isArray(t) ? t : [t];
}
function o2(t, e = !1) {
  const n = t.split(/(\r?\n)/g);
  let r = 0;
  const i = [];
  for (let s = 0; s < n.length; s += 2) {
    const o = e ? n[s] + (n[s + 1] || "") : n[s];
    i.push([o, r]), r += n[s].length, r += n[s + 1]?.length || 0;
  }
  return i;
}
function a5(t) {
  return !t || ["plaintext", "txt", "text", "plain"].includes(t);
}
function Qfe(t) {
  return t === "ansi" || a5(t);
}
function u5(t) {
  return t === "none";
}
function Jfe(t) {
  return u5(t);
}
function ON(t, e) {
  if (!e)
    return t;
  t.properties ||= {}, t.properties.class ||= [], typeof t.properties.class == "string" && (t.properties.class = t.properties.class.split(/\s+/g)), Array.isArray(t.properties.class) || (t.properties.class = []);
  const n = Array.isArray(e) ? e : e.split(/\s+/g);
  for (const r of n)
    r && !t.properties.class.includes(r) && t.properties.class.push(r);
  return t;
}
function Zfe(t, e) {
  let n = 0;
  const r = [];
  for (const i of e)
    i > n && r.push({
      ...t,
      content: t.content.slice(n, i),
      offset: t.offset + n
    }), n = i;
  return n < t.content.length && r.push({
    ...t,
    content: t.content.slice(n),
    offset: t.offset + n
  }), r;
}
function ehe(t, e) {
  const n = Array.from(e instanceof Set ? e : new Set(e)).sort((r, i) => r - i);
  return n.length ? t.map((r) => r.flatMap((i) => {
    const s = n.filter((o) => i.offset < o && o < i.offset + i.content.length).map((o) => o - i.offset).sort((o, l) => o - l);
    return s.length ? Zfe(i, s) : i;
  })) : t;
}
async function FN(t) {
  return Promise.resolve(typeof t == "function" ? t() : t).then((e) => e.default || e);
}
function Kb(t, e) {
  const n = typeof t == "string" ? {} : { ...t.colorReplacements }, r = typeof t == "string" ? t : t.name;
  for (const [i, s] of Object.entries(e?.colorReplacements || {}))
    typeof s == "string" ? n[i] = s : i === r && Object.assign(n, s);
  return n;
}
function Vc(t, e) {
  return t && (e?.[t?.toLowerCase()] || t);
}
function TN(t) {
  const e = {};
  return t.color && (e.color = t.color), t.bgColor && (e["background-color"] = t.bgColor), t.fontStyle && (t.fontStyle & La.Italic && (e["font-style"] = "italic"), t.fontStyle & La.Bold && (e["font-weight"] = "bold"), t.fontStyle & La.Underline && (e["text-decoration"] = "underline")), e;
}
function the(t) {
  return typeof t == "string" ? t : Object.entries(t).map(([e, n]) => `${e}:${n}`).join(";");
}
function nhe(t) {
  const e = o2(t, !0).map(([i]) => i);
  function n(i) {
    if (i === t.length)
      return {
        line: e.length - 1,
        character: e[e.length - 1].length
      };
    let s = i, o = 0;
    for (const l of e) {
      if (s < l.length)
        break;
      s -= l.length, o++;
    }
    return { line: o, character: s };
  }
  function r(i, s) {
    let o = 0;
    for (let l = 0; l < i; l++)
      o += e[l].length;
    return o += s, o;
  }
  return {
    lines: e,
    indexToPos: n,
    posToIndex: r
  };
}
class Ti extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
}
const RN = /* @__PURE__ */ new WeakMap();
function l2(t, e) {
  RN.set(t, e);
}
function Cg(t) {
  return RN.get(t);
}
class r0 {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(e, n) {
    return new r0(
      Object.fromEntries(Xfe(n).map((r) => [r, j4])),
      e
    );
  }
  constructor(...e) {
    if (e.length === 2) {
      const [n, r] = e;
      this.lang = r, this._stacks = n;
    } else {
      const [n, r, i] = e;
      this.lang = r, this._stacks = { [i]: n };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(e = this.theme) {
    return this._stacks[e];
  }
  /**
   * @deprecated use `getScopes` instead
   */
  get scopes() {
    return j7(this._stacks[this.theme]);
  }
  getScopes(e = this.theme) {
    return j7(this._stacks[e]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.scopes
    };
  }
}
function j7(t) {
  const e = [], n = /* @__PURE__ */ new Set();
  function r(i) {
    if (n.has(i))
      return;
    n.add(i);
    const s = i?.nameScopesList?.scopeName;
    s && e.push(s), i.parent && r(i.parent);
  }
  return r(t), e;
}
function rhe(t, e) {
  if (!(t instanceof r0))
    throw new Ti("Invalid grammar state");
  return t.getInternalStack(e);
}
function ihe() {
  const t = /* @__PURE__ */ new WeakMap();
  function e(n) {
    if (!t.has(n.meta)) {
      let r = function(o) {
        if (typeof o == "number") {
          if (o < 0 || o > n.source.length)
            throw new Ti(`Invalid decoration offset: ${o}. Code length: ${n.source.length}`);
          return {
            ...i.indexToPos(o),
            offset: o
          };
        } else {
          const l = i.lines[o.line];
          if (l === void 0)
            throw new Ti(`Invalid decoration position ${JSON.stringify(o)}. Lines length: ${i.lines.length}`);
          if (o.character < 0 || o.character > l.length)
            throw new Ti(`Invalid decoration position ${JSON.stringify(o)}. Line ${o.line} length: ${l.length}`);
          return {
            ...o,
            offset: i.posToIndex(o.line, o.character)
          };
        }
      };
      const i = nhe(n.source), s = (n.options.decorations || []).map((o) => ({
        ...o,
        start: r(o.start),
        end: r(o.end)
      }));
      she(s), t.set(n.meta, {
        decorations: s,
        converter: i,
        source: n.source
      });
    }
    return t.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      if (!this.options.decorations?.length)
        return;
      const i = e(this).decorations.flatMap((o) => [o.start.offset, o.end.offset]);
      return ehe(n, i);
    },
    code(n) {
      if (!this.options.decorations?.length)
        return;
      const r = e(this), i = Array.from(n.children).filter((c) => c.type === "element" && c.tagName === "span");
      if (i.length !== r.converter.lines.length)
        throw new Ti(`Number of lines in code element (${i.length}) does not match the number of lines in the source (${r.converter.lines.length}). Failed to apply decorations.`);
      function s(c, f, d, p) {
        const m = i[c];
        let y = "", b = -1, v = -1;
        if (f === 0 && (b = 0), d === 0 && (v = 0), d === Number.POSITIVE_INFINITY && (v = m.children.length), b === -1 || v === -1)
          for (let k = 0; k < m.children.length; k++)
            y += MN(m.children[k]), b === -1 && y.length === f && (b = k + 1), v === -1 && y.length === d && (v = k + 1);
        if (b === -1)
          throw new Ti(`Failed to find start index for decoration ${JSON.stringify(p.start)}`);
        if (v === -1)
          throw new Ti(`Failed to find end index for decoration ${JSON.stringify(p.end)}`);
        const _ = m.children.slice(b, v);
        if (!p.alwaysWrap && _.length === m.children.length)
          l(m, p, "line");
        else if (!p.alwaysWrap && _.length === 1 && _[0].type === "element")
          l(_[0], p, "token");
        else {
          const k = {
            type: "element",
            tagName: "span",
            properties: {},
            children: _
          };
          l(k, p, "wrapper"), m.children.splice(b, _.length, k);
        }
      }
      function o(c, f) {
        i[c] = l(i[c], f, "line");
      }
      function l(c, f, d) {
        const p = f.properties || {}, m = f.transform || ((y) => y);
        return c.tagName = f.tagName || "span", c.properties = {
          ...c.properties,
          ...p,
          class: c.properties.class
        }, f.properties?.class && ON(c, f.properties.class), c = m(c, d) || c, c;
      }
      const a = [], u = r.decorations.sort((c, f) => f.start.offset - c.start.offset);
      for (const c of u) {
        const { start: f, end: d } = c;
        if (f.line === d.line)
          s(f.line, f.character, d.character, c);
        else if (f.line < d.line) {
          s(f.line, f.character, Number.POSITIVE_INFINITY, c);
          for (let p = f.line + 1; p < d.line; p++)
            a.unshift(() => o(p, c));
          s(d.line, 0, d.character, c);
        }
      }
      a.forEach((c) => c());
    }
  };
}
function she(t) {
  for (let e = 0; e < t.length; e++) {
    const n = t[e];
    if (n.start.offset > n.end.offset)
      throw new Ti(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let r = e + 1; r < t.length; r++) {
      const i = t[r], s = n.start.offset < i.start.offset && i.start.offset < n.end.offset, o = n.start.offset < i.end.offset && i.end.offset < n.end.offset, l = i.start.offset < n.start.offset && n.start.offset < i.end.offset, a = i.start.offset < n.end.offset && n.end.offset < i.end.offset;
      if (s || o || l || a) {
        if (o && o || l && a)
          continue;
        throw new Ti(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(i.start)} intersect.`);
      }
    }
  }
}
function MN(t) {
  return t.type === "text" ? t.value : t.type === "element" ? t.children.map(MN).join("") : "";
}
const ohe = [
  /* @__PURE__ */ ihe()
];
function Yb(t) {
  return [
    ...t.transformers || [],
    ...ohe
  ];
}
var Wc = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], b3 = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function lhe(t, e) {
  const n = t.indexOf("\x1B[", e);
  if (n !== -1) {
    const r = t.indexOf("m", n);
    return {
      sequence: t.substring(n + 2, r).split(";"),
      startPosition: n,
      position: r + 1
    };
  }
  return {
    position: t.length
  };
}
function q7(t, e) {
  let n = 1;
  const r = t[e + n++];
  let i;
  if (r === "2") {
    const s = [
      t[e + n++],
      t[e + n++],
      t[e + n]
    ].map((o) => Number.parseInt(o));
    s.length === 3 && !s.some((o) => Number.isNaN(o)) && (i = {
      type: "rgb",
      rgb: s
    });
  } else if (r === "5") {
    const s = Number.parseInt(t[e + n]);
    Number.isNaN(s) || (i = { type: "table", index: Number(s) });
  }
  return [n, i];
}
function ahe(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n], i = Number.parseInt(r);
    if (!Number.isNaN(i))
      if (i === 0)
        e.push({ type: "resetAll" });
      else if (i <= 9)
        b3[i] && e.push({
          type: "setDecoration",
          value: b3[i]
        });
      else if (i <= 29) {
        const s = b3[i - 20];
        s && e.push({
          type: "resetDecoration",
          value: s
        });
      } else if (i <= 37)
        e.push({
          type: "setForegroundColor",
          value: { type: "named", name: Wc[i - 30] }
        });
      else if (i === 38) {
        const [s, o] = q7(t, n);
        o && e.push({
          type: "setForegroundColor",
          value: o
        }), n += s;
      } else if (i === 39)
        e.push({
          type: "resetForegroundColor"
        });
      else if (i <= 47)
        e.push({
          type: "setBackgroundColor",
          value: { type: "named", name: Wc[i - 40] }
        });
      else if (i === 48) {
        const [s, o] = q7(t, n);
        o && e.push({
          type: "setBackgroundColor",
          value: o
        }), n += s;
      } else i === 49 ? e.push({
        type: "resetBackgroundColor"
      }) : i >= 90 && i <= 97 ? e.push({
        type: "setForegroundColor",
        value: { type: "named", name: Wc[i - 90 + 8] }
      }) : i >= 100 && i <= 107 && e.push({
        type: "setBackgroundColor",
        value: { type: "named", name: Wc[i - 100 + 8] }
      });
  }
  return e;
}
function uhe() {
  let t = null, e = null, n = /* @__PURE__ */ new Set();
  return {
    parse(r) {
      const i = [];
      let s = 0;
      do {
        const o = lhe(r, s), l = o.sequence ? r.substring(s, o.startPosition) : r.substring(s);
        if (l.length > 0 && i.push({
          value: l,
          foreground: t,
          background: e,
          decorations: new Set(n)
        }), o.sequence) {
          const a = ahe(o.sequence);
          for (const u of a)
            u.type === "resetAll" ? (t = null, e = null, n.clear()) : u.type === "resetForegroundColor" ? t = null : u.type === "resetBackgroundColor" ? e = null : u.type === "resetDecoration" && n.delete(u.value);
          for (const u of a)
            u.type === "setForegroundColor" ? t = u.value : u.type === "setBackgroundColor" ? e = u.value : u.type === "setDecoration" && n.add(u.value);
        }
        s = o.position;
      } while (s < r.length);
      return i;
    }
  };
}
var che = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function fhe(t = che) {
  function e(l) {
    return t[l];
  }
  function n(l) {
    return `#${l.map((a) => Math.max(0, Math.min(a, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let r;
  function i() {
    if (r)
      return r;
    r = [];
    for (let u = 0; u < Wc.length; u++)
      r.push(e(Wc[u]));
    let l = [0, 95, 135, 175, 215, 255];
    for (let u = 0; u < 6; u++)
      for (let c = 0; c < 6; c++)
        for (let f = 0; f < 6; f++)
          r.push(n([l[u], l[c], l[f]]));
    let a = 8;
    for (let u = 0; u < 24; u++, a += 10)
      r.push(n([a, a, a]));
    return r;
  }
  function s(l) {
    return i()[l];
  }
  function o(l) {
    switch (l.type) {
      case "named":
        return e(l.name);
      case "rgb":
        return n(l.rgb);
      case "table":
        return s(l.index);
    }
  }
  return {
    value: o
  };
}
function hhe(t, e, n) {
  const r = Kb(t, n), i = o2(e), s = fhe(
    Object.fromEntries(
      Wc.map((l) => [
        l,
        t.colors?.[`terminal.ansi${l[0].toUpperCase()}${l.substring(1)}`]
      ])
    )
  ), o = uhe();
  return i.map(
    (l) => o.parse(l[0]).map((a) => {
      let u, c;
      a.decorations.has("reverse") ? (u = a.background ? s.value(a.background) : t.bg, c = a.foreground ? s.value(a.foreground) : t.fg) : (u = a.foreground ? s.value(a.foreground) : t.fg, c = a.background ? s.value(a.background) : void 0), u = Vc(u, r), c = Vc(c, r), a.decorations.has("dim") && (u = dhe(u));
      let f = La.None;
      return a.decorations.has("bold") && (f |= La.Bold), a.decorations.has("italic") && (f |= La.Italic), a.decorations.has("underline") && (f |= La.Underline), {
        content: a.value,
        offset: l[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: u,
        bgColor: c,
        fontStyle: f
      };
    })
  );
}
function dhe(t) {
  const e = t.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (e)
    if (e[3]) {
      const r = Math.round(Number.parseInt(e[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${e[1]}${e[2]}${r}`;
    } else return e[2] ? `#${e[1]}${e[2]}80` : `#${Array.from(e[1]).map((r) => `${r}${r}`).join("")}80`;
  const n = t.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : t;
}
function c5(t, e, n = {}) {
  const {
    lang: r = "text",
    theme: i = t.getLoadedThemes()[0]
  } = n;
  if (a5(r) || u5(i))
    return o2(e).map((a) => [{ content: a[0], offset: a[1] }]);
  const { theme: s, colorMap: o } = t.setTheme(i);
  if (r === "ansi")
    return hhe(s, e, n);
  const l = t.getLanguage(r);
  if (n.grammarState) {
    if (n.grammarState.lang !== l.name)
      throw new lf(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${l.name}"`);
    if (!n.grammarState.themes.includes(s.name))
      throw new lf(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${s.name}"`);
  }
  return ghe(e, l, s, o, n);
}
function phe(...t) {
  if (t.length === 2)
    return Cg(t[1]);
  const [e, n, r = {}] = t, {
    lang: i = "text",
    theme: s = e.getLoadedThemes()[0]
  } = r;
  if (a5(i) || u5(s))
    throw new lf("Plain language does not have grammar state");
  if (i === "ansi")
    throw new lf("ANSI language does not have grammar state");
  const { theme: o, colorMap: l } = e.setTheme(s), a = e.getLanguage(i);
  return new r0(
    Xb(n, a, o, l, r).stateStack,
    a.name,
    o.name
  );
}
function ghe(t, e, n, r, i) {
  const s = Xb(t, e, n, r, i), o = new r0(
    Xb(t, e, n, r, i).stateStack,
    e.name,
    n.name
  );
  return l2(s.tokens, o), s.tokens;
}
function Xb(t, e, n, r, i) {
  const s = Kb(n, i), {
    tokenizeMaxLineLength: o = 0,
    tokenizeTimeLimit: l = 500
  } = i, a = o2(t);
  let u = i.grammarState ? rhe(i.grammarState, n.name) ?? j4 : i.grammarContextCode != null ? Xb(
    i.grammarContextCode,
    e,
    n,
    r,
    {
      ...i,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : j4, c = [];
  const f = [];
  for (let d = 0, p = a.length; d < p; d++) {
    const [m, y] = a[d];
    if (m === "") {
      c = [], f.push([]);
      continue;
    }
    if (o > 0 && m.length >= o) {
      c = [], f.push([{
        content: m,
        offset: y,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let b, v, _;
    i.includeExplanation && (b = e.tokenizeLine(m, u), v = b.tokens, _ = 0);
    const k = e.tokenizeLine2(m, u, l), S = k.tokens.length / 2;
    for (let C = 0; C < S; C++) {
      const E = k.tokens[2 * C], A = C + 1 < S ? k.tokens[2 * C + 2] : m.length;
      if (E === A)
        continue;
      const O = k.tokens[2 * C + 1], T = Vc(
        r[Fd.getForeground(O)],
        s
      ), $ = Fd.getFontStyle(O), P = {
        content: m.substring(E, A),
        offset: y + E,
        color: T,
        fontStyle: $
      };
      if (i.includeExplanation) {
        const B = [];
        if (i.includeExplanation !== "scopeName")
          for (const L of n.settings) {
            let N;
            switch (typeof L.scope) {
              case "string":
                N = L.scope.split(/,/).map((j) => j.trim());
                break;
              case "object":
                N = L.scope;
                break;
              default:
                continue;
            }
            B.push({
              settings: L,
              selectors: N.map((j) => j.split(/ /))
            });
          }
        P.explanation = [];
        let M = 0;
        for (; E + M < A; ) {
          const L = v[_], N = m.substring(
            L.startIndex,
            L.endIndex
          );
          M += N.length, P.explanation.push({
            content: N,
            scopes: i.includeExplanation === "scopeName" ? mhe(
              L.scopes
            ) : yhe(
              B,
              L.scopes
            )
          }), _ += 1;
        }
      }
      c.push(P);
    }
    f.push(c), c = [], u = k.ruleStack;
  }
  return {
    tokens: f,
    stateStack: u
  };
}
function mhe(t) {
  return t.map((e) => ({ scopeName: e }));
}
function yhe(t, e) {
  const n = [];
  for (let r = 0, i = e.length; r < i; r++) {
    const s = e[r];
    n[r] = {
      scopeName: s,
      themeMatches: vhe(t, s, e.slice(0, r))
    };
  }
  return n;
}
function U7(t, e) {
  return t === e || e.substring(0, t.length) === t && e[t.length] === ".";
}
function bhe(t, e, n) {
  if (!U7(t[t.length - 1], e))
    return !1;
  let r = t.length - 2, i = n.length - 1;
  for (; r >= 0 && i >= 0; )
    U7(t[r], n[i]) && (r -= 1), i -= 1;
  return r === -1;
}
function vhe(t, e, n) {
  const r = [];
  for (const { selectors: i, settings: s } of t)
    for (const o of i)
      if (bhe(o, e, n)) {
        r.push(s);
        break;
      }
  return r;
}
function PN(t, e, n) {
  const r = Object.entries(n.themes).filter((a) => a[1]).map((a) => ({ color: a[0], theme: a[1] })), i = r.map((a) => {
    const u = c5(t, e, {
      ...n,
      theme: a.theme
    }), c = Cg(u), f = typeof a.theme == "string" ? a.theme : a.theme.name;
    return {
      tokens: u,
      state: c,
      theme: f
    };
  }), s = xhe(
    ...i.map((a) => a.tokens)
  ), o = s[0].map(
    (a, u) => a.map((c, f) => {
      const d = {
        content: c.content,
        variants: {},
        offset: c.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (d.explanation = c.explanation), s.forEach((p, m) => {
        const {
          content: y,
          explanation: b,
          offset: v,
          ..._
        } = p[u][f];
        d.variants[r[m].color] = _;
      }), d;
    })
  ), l = i[0].state ? new r0(
    Object.fromEntries(i.map((a) => [a.theme, a.state?.getInternalStack(a.theme)])),
    i[0].state.lang
  ) : void 0;
  return l && l2(o, l), o;
}
function xhe(...t) {
  const e = t.map(() => []), n = t.length;
  for (let r = 0; r < t[0].length; r++) {
    const i = t.map((a) => a[r]), s = e.map(() => []);
    e.forEach((a, u) => a.push(s[u]));
    const o = i.map(() => 0), l = i.map((a) => a[0]);
    for (; l.every((a) => a); ) {
      const a = Math.min(...l.map((u) => u.content.length));
      for (let u = 0; u < n; u++) {
        const c = l[u];
        c.content.length === a ? (s[u].push(c), o[u] += 1, l[u] = i[u][o[u]]) : (s[u].push({
          ...c,
          content: c.content.slice(0, a)
        }), l[u] = {
          ...c,
          content: c.content.slice(a),
          offset: c.offset + a
        });
      }
    }
  }
  return e;
}
function Qb(t, e, n) {
  let r, i, s, o, l, a;
  if ("themes" in n) {
    const {
      defaultColor: u = "light",
      cssVariablePrefix: c = "--shiki-"
    } = n, f = Object.entries(n.themes).filter((b) => b[1]).map((b) => ({ color: b[0], theme: b[1] })).sort((b, v) => b.color === u ? -1 : v.color === u ? 1 : 0);
    if (f.length === 0)
      throw new lf("`themes` option must not be empty");
    const d = PN(
      t,
      e,
      n
    );
    if (a = Cg(d), u && !f.find((b) => b.color === u))
      throw new lf(`\`themes\` option must contain the defaultColor key \`${u}\``);
    const p = f.map((b) => t.getTheme(b.theme)), m = f.map((b) => b.color);
    s = d.map((b) => b.map((v) => whe(v, m, c, u))), a && l2(s, a);
    const y = f.map((b) => Kb(b.theme, n));
    i = f.map((b, v) => (v === 0 && u ? "" : `${c + b.color}:`) + (Vc(p[v].fg, y[v]) || "inherit")).join(";"), r = f.map((b, v) => (v === 0 && u ? "" : `${c + b.color}-bg:`) + (Vc(p[v].bg, y[v]) || "inherit")).join(";"), o = `shiki-themes ${p.map((b) => b.name).join(" ")}`, l = u ? void 0 : [i, r].join(";");
  } else if ("theme" in n) {
    const u = Kb(n.theme, n);
    s = c5(
      t,
      e,
      n
    );
    const c = t.getTheme(n.theme);
    r = Vc(c.bg, u), i = Vc(c.fg, u), o = c.name, a = Cg(s);
  } else
    throw new lf("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: s,
    fg: i,
    bg: r,
    themeName: o,
    rootStyle: l,
    grammarState: a
  };
}
function whe(t, e, n, r) {
  const i = {
    content: t.content,
    explanation: t.explanation,
    offset: t.offset
  }, s = e.map((a) => TN(t.variants[a])), o = new Set(s.flatMap((a) => Object.keys(a))), l = {};
  return s.forEach((a, u) => {
    for (const c of o) {
      const f = a[c] || "inherit";
      if (u === 0 && r)
        l[c] = f;
      else {
        const d = c === "color" ? "" : c === "background-color" ? "-bg" : `-${c}`, p = n + e[u] + (c === "color" ? "" : d);
        l[p] = f;
      }
    }
  }), i.htmlStyle = l, i;
}
function Jb(t, e, n, r = {
  meta: {},
  options: n,
  codeToHast: (i, s) => Jb(t, i, s),
  codeToTokens: (i, s) => Qb(t, i, s)
}) {
  let i = e;
  for (const p of Yb(n))
    i = p.preprocess?.call(r, i, n) || i;
  let {
    tokens: s,
    fg: o,
    bg: l,
    themeName: a,
    rootStyle: u,
    grammarState: c
  } = Qb(t, i, n);
  const {
    mergeWhitespaces: f = !0
  } = n;
  f === !0 ? s = khe(s) : f === "never" && (s = Che(s));
  const d = {
    ...r,
    get source() {
      return i;
    }
  };
  for (const p of Yb(n))
    s = p.tokens?.call(d, s) || s;
  return _he(
    s,
    {
      ...n,
      fg: o,
      bg: l,
      themeName: a,
      rootStyle: u
    },
    d,
    c
  );
}
function _he(t, e, n, r = Cg(t)) {
  const i = Yb(e), s = [], o = {
    type: "root",
    children: []
  }, {
    structure: l = "classic",
    tabindex: a = "0"
  } = e;
  let u = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${e.themeName || ""}`,
      style: e.rootStyle || `background-color:${e.bg};color:${e.fg}`,
      ...a !== !1 && a != null ? {
        tabindex: a.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(e.meta || {})
        ).filter(([m]) => !m.startsWith("_"))
      )
    },
    children: []
  }, c = {
    type: "element",
    tagName: "code",
    properties: {},
    children: s
  };
  const f = [], d = {
    ...n,
    structure: l,
    addClassToHast: ON,
    get source() {
      return n.source;
    },
    get tokens() {
      return t;
    },
    get options() {
      return e;
    },
    get root() {
      return o;
    },
    get pre() {
      return u;
    },
    get code() {
      return c;
    },
    get lines() {
      return f;
    }
  };
  if (t.forEach((m, y) => {
    y && (l === "inline" ? o.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : l === "classic" && s.push({ type: "text", value: `
` }));
    let b = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, v = 0;
    for (const _ of m) {
      let k = {
        type: "element",
        tagName: "span",
        properties: {
          ..._.htmlAttrs
        },
        children: [{ type: "text", value: _.content }]
      };
      _.htmlStyle;
      const S = the(_.htmlStyle || TN(_));
      S && (k.properties.style = S);
      for (const C of i)
        k = C?.span?.call(d, k, y + 1, v, b, _) || k;
      l === "inline" ? o.children.push(k) : l === "classic" && b.children.push(k), v += _.content.length;
    }
    if (l === "classic") {
      for (const _ of i)
        b = _?.line?.call(d, b, y + 1) || b;
      f.push(b), s.push(b);
    }
  }), l === "classic") {
    for (const m of i)
      c = m?.code?.call(d, c) || c;
    u.children.push(c);
    for (const m of i)
      u = m?.pre?.call(d, u) || u;
    o.children.push(u);
  }
  let p = o;
  for (const m of i)
    p = m?.root?.call(d, p) || p;
  return r && l2(p, r), p;
}
function khe(t) {
  return t.map((e) => {
    const n = [];
    let r = "", i = 0;
    return e.forEach((s, o) => {
      const a = !(s.fontStyle && s.fontStyle & La.Underline);
      a && s.content.match(/^\s+$/) && e[o + 1] ? (i || (i = s.offset), r += s.content) : r ? (a ? n.push({
        ...s,
        offset: i,
        content: r + s.content
      }) : n.push(
        {
          content: r,
          offset: i
        },
        s
      ), i = 0, r = "") : n.push(s);
    }), n;
  });
}
function Che(t) {
  return t.map((e) => e.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const r = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!r)
      return n;
    const [, i, s, o] = r;
    if (!i && !o)
      return n;
    const l = [{
      ...n,
      offset: n.offset + i.length,
      content: s
    }];
    return i && l.unshift({
      content: i,
      offset: n.offset
    }), o && l.push({
      content: o,
      offset: n.offset + i.length + s.length
    }), l;
  }));
}
function She(t, e, n) {
  const r = {
    meta: {},
    options: n,
    codeToHast: (s, o) => Jb(t, s, o),
    codeToTokens: (s, o) => Qb(t, s, o)
  };
  let i = Gfe(Jb(t, e, n, r));
  for (const s of Yb(n))
    i = s.postprocess?.call(r, i, n) || i;
  return i;
}
const H7 = { light: "#333333", dark: "#bbbbbb" }, V7 = { light: "#fffffe", dark: "#1e1e1e" }, W7 = "__shiki_resolved";
function f5(t) {
  if (t?.[W7])
    return t;
  const e = {
    ...t
  };
  e.tokenColors && !e.settings && (e.settings = e.tokenColors, delete e.tokenColors), e.type ||= "dark", e.colorReplacements = { ...e.colorReplacements }, e.settings ||= [];
  let { bg: n, fg: r } = e;
  if (!n || !r) {
    const l = e.settings ? e.settings.find((a) => !a.name && !a.scope) : void 0;
    l?.settings?.foreground && (r = l.settings.foreground), l?.settings?.background && (n = l.settings.background), !r && e?.colors?.["editor.foreground"] && (r = e.colors["editor.foreground"]), !n && e?.colors?.["editor.background"] && (n = e.colors["editor.background"]), r || (r = e.type === "light" ? H7.light : H7.dark), n || (n = e.type === "light" ? V7.light : V7.dark), e.fg = r, e.bg = n;
  }
  e.settings[0] && e.settings[0].settings && !e.settings[0].scope || e.settings.unshift({
    settings: {
      foreground: e.fg,
      background: e.bg
    }
  });
  let i = 0;
  const s = /* @__PURE__ */ new Map();
  function o(l) {
    if (s.has(l))
      return s.get(l);
    i += 1;
    const a = `#${i.toString(16).padStart(8, "0").toLowerCase()}`;
    return e.colorReplacements?.[`#${a}`] ? o(l) : (s.set(l, a), a);
  }
  e.settings = e.settings.map((l) => {
    const a = l.settings?.foreground && !l.settings.foreground.startsWith("#"), u = l.settings?.background && !l.settings.background.startsWith("#");
    if (!a && !u)
      return l;
    const c = {
      ...l,
      settings: {
        ...l.settings
      }
    };
    if (a) {
      const f = o(l.settings.foreground);
      e.colorReplacements[f] = l.settings.foreground, c.settings.foreground = f;
    }
    if (u) {
      const f = o(l.settings.background);
      e.colorReplacements[f] = l.settings.background, c.settings.background = f;
    }
    return c;
  });
  for (const l of Object.keys(e.colors || {}))
    if ((l === "editor.foreground" || l === "editor.background" || l.startsWith("terminal.ansi")) && !e.colors[l]?.startsWith("#")) {
      const a = o(e.colors[l]);
      e.colorReplacements[a] = e.colors[l], e.colors[l] = a;
    }
  return Object.defineProperty(e, W7, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), e;
}
async function IN(t) {
  return Array.from(new Set((await Promise.all(
    t.filter((e) => !Qfe(e)).map(async (e) => await FN(e).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function NN(t) {
  return (await Promise.all(
    t.map(
      async (n) => Jfe(n) ? null : f5(await FN(n))
    )
  )).filter((n) => !!n);
}
class Ahe extends Mce {
  constructor(e, n, r, i = {}) {
    super(e), this._resolver = e, this._themes = n, this._langs = r, this._alias = i, this._themes.map((s) => this.loadTheme(s)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(e) {
    return typeof e == "string" ? this._resolvedThemes.get(e) : this.loadTheme(e);
  }
  loadTheme(e) {
    const n = f5(e);
    return n.name && (this._resolvedThemes.set(n.name, n), this._loadedThemesCache = null), n;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(e) {
    let n = this._textmateThemeCache.get(e);
    n || (n = Ub.createFromRawTheme(e), this._textmateThemeCache.set(e, n)), this._syncRegistry.setTheme(n);
  }
  getGrammar(e) {
    if (this._alias[e]) {
      const n = /* @__PURE__ */ new Set([e]);
      for (; this._alias[e]; ) {
        if (e = this._alias[e], n.has(e))
          throw new Ti(`Circular alias \`${Array.from(n).join(" -> ")} -> ${e}\``);
        n.add(e);
      }
    }
    return this._resolvedGrammars.get(e);
  }
  loadLanguage(e) {
    if (this.getGrammar(e.name))
      return;
    const n = new Set(
      [...this._langMap.values()].filter((s) => s.embeddedLangsLazy?.includes(e.name))
    );
    this._resolver.addLanguage(e);
    const r = {
      balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(e.scopeName, e);
    const i = this.loadGrammarWithConfiguration(e.scopeName, 1, r);
    if (i.name = e.name, this._resolvedGrammars.set(e.name, i), e.aliases && e.aliases.forEach((s) => {
      this._alias[s] = e.name;
    }), this._loadedLanguagesCache = null, n.size)
      for (const s of n)
        this._resolvedGrammars.delete(s.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(s.scopeName), this._syncRegistry?._grammars?.delete(s.scopeName), this.loadLanguage(this._langMap.get(s.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(e) {
    for (const i of e)
      this.resolveEmbeddedLanguages(i);
    const n = Array.from(this._langGraph.entries()), r = n.filter(([i, s]) => !s);
    if (r.length) {
      const i = n.filter(([s, o]) => o && o.embeddedLangs?.some((l) => r.map(([a]) => a).includes(l))).filter((s) => !r.includes(s));
      throw new Ti(`Missing languages ${r.map(([s]) => `\`${s}\``).join(", ")}, required by ${i.map(([s]) => `\`${s}\``).join(", ")}`);
    }
    for (const [i, s] of n)
      this._resolver.addLanguage(s);
    for (const [i, s] of n)
      this.loadLanguage(s);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(e) {
    if (this._langMap.set(e.name, e), this._langGraph.set(e.name, e), e.embeddedLangs)
      for (const n of e.embeddedLangs)
        this._langGraph.set(n, this._langMap.get(n));
  }
}
class Ehe {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(e, n) {
    this._onigLib = {
      createOnigScanner: (r) => e.createScanner(r),
      createOnigString: (r) => e.createString(r)
    }, n.forEach((r) => this.addLanguage(r));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(e) {
    return this._langs.get(e);
  }
  loadGrammar(e) {
    return this._scopeToLang.get(e);
  }
  addLanguage(e) {
    this._langs.set(e.name, e), e.aliases && e.aliases.forEach((n) => {
      this._langs.set(n, e);
    }), this._scopeToLang.set(e.scopeName, e), e.injectTo && e.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(e.scopeName);
    });
  }
  getInjections(e) {
    const n = e.split(".");
    let r = [];
    for (let i = 1; i <= n.length; i++) {
      const s = n.slice(0, i).join(".");
      r = [...r, ...this._injections.get(s) || []];
    }
    return r;
  }
}
let ep = 0;
function Dhe(t) {
  ep += 1, t.warnings !== !1 && ep >= 10 && ep % 10 === 0 && console.warn(`[Shiki] ${ep} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let e = !1;
  if (!t.engine)
    throw new Ti("`engine` option is required for synchronous mode");
  const n = (t.langs || []).flat(1), r = (t.themes || []).flat(1).map(f5), i = new Ehe(t.engine, n), s = new Ahe(i, r, n, t.langAlias);
  let o;
  function l(_) {
    b();
    const k = s.getGrammar(typeof _ == "string" ? _ : _.name);
    if (!k)
      throw new Ti(`Language \`${_}\` not found, you may need to load it first`);
    return k;
  }
  function a(_) {
    if (_ === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    b();
    const k = s.getTheme(_);
    if (!k)
      throw new Ti(`Theme \`${_}\` not found, you may need to load it first`);
    return k;
  }
  function u(_) {
    b();
    const k = a(_);
    o !== _ && (s.setTheme(k), o = _);
    const S = s.getColorMap();
    return {
      theme: k,
      colorMap: S
    };
  }
  function c() {
    return b(), s.getLoadedThemes();
  }
  function f() {
    return b(), s.getLoadedLanguages();
  }
  function d(..._) {
    b(), s.loadLanguages(_.flat(1));
  }
  async function p(..._) {
    return d(await IN(_));
  }
  function m(..._) {
    b();
    for (const k of _.flat(1))
      s.loadTheme(k);
  }
  async function y(..._) {
    return b(), m(await NN(_));
  }
  function b() {
    if (e)
      throw new Ti("Shiki instance has been disposed");
  }
  function v() {
    e || (e = !0, s.dispose(), ep -= 1);
  }
  return {
    setTheme: u,
    getTheme: a,
    getLanguage: l,
    getLoadedThemes: c,
    getLoadedLanguages: f,
    loadLanguage: p,
    loadLanguageSync: d,
    loadTheme: y,
    loadThemeSync: m,
    dispose: v,
    [Symbol.dispose]: v
  };
}
async function Ohe(t = {}) {
  t.loadWasm;
  const [
    e,
    n,
    r
  ] = await Promise.all([
    NN(t.themes || []),
    IN(t.langs || []),
    t.engine || Gue(t.loadWasm || Wue())
  ]);
  return Dhe({
    ...t,
    themes: e,
    langs: n,
    engine: r
  });
}
async function Fhe(t = {}) {
  const e = await Ohe(t);
  return {
    getLastGrammarState: (...n) => phe(e, ...n),
    codeToTokensBase: (n, r) => c5(e, n, r),
    codeToTokensWithThemes: (n, r) => PN(e, n, r),
    codeToTokens: (n, r) => Qb(e, n, r),
    codeToHast: (n, r) => Jb(e, n, r),
    codeToHtml: (n, r) => She(e, n, r),
    ...e,
    getInternalContext: () => e
  };
}
const W4 = wo({
  linkify: !0,
  typographer: !0
});
(async () => {
  const t = await Fhe({
    themes: [
      import("./chunk-CcmG315c.js"),
      import("./chunk-Cym-eLtO.js")
    ],
    langs: [import("./chunk-fa8UlHZE.js")]
  });
  W4.use(Due(t, {
    themes: {
      light: "vitesse-light",
      dark: "vitesse-dark"
    }
  }));
})();
function Zh(t, e = !0) {
  return e ? W4.renderInline(t) : W4.render(t);
}
const The = b6({
  String: ie.string,
  Number: ie.number,
  "True False": ie.bool,
  PropertyName: ie.propertyName,
  Null: ie.null,
  ", :": ie.separator,
  "[ ]": ie.squareBracket,
  "{ }": ie.brace
}), Rhe = ug.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "âš  JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [The],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), Mhe = () => (t) => {
  try {
    JSON.parse(t.state.doc.toString());
  } catch (e) {
    if (!(e instanceof SyntaxError))
      throw e;
    const n = Phe(e, t.state.doc);
    return [{
      from: n,
      message: e.message,
      severity: "error",
      to: n
    }];
  }
  return [];
};
function Phe(t, e) {
  let n;
  return (n = t.message.match(/at position (\d+)/)) ? Math.min(+n[1], e.length) : (n = t.message.match(/at line (\d+) column (\d+)/)) ? Math.min(e.line(+n[1]).from + +n[2] - 1, e.length) : 0;
}
const BN = /* @__PURE__ */ ig.define({
  name: "json",
  parser: /* @__PURE__ */ Rhe.configure({
    props: [
      /* @__PURE__ */ x6.add({
        Object: /* @__PURE__ */ d4({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ d4({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ vM.add({
        "Object Array": zZ
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function Ihe() {
  return new yM(BN);
}
var v3 = {}, G7;
function Nhe() {
  return G7 || (G7 = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.parse = t.enableErrorLogging = t.disableErrorLogging = t.setErrorLogger = void 0;
    let e = console.error;
    function n(A) {
      e = A;
    }
    t.setErrorLogger = n;
    function r() {
      e = () => {
      };
    }
    t.disableErrorLogging = r;
    function i() {
      e = console.error;
    }
    t.enableErrorLogging = i;
    function s(A) {
      if (A !== void 0) {
        if (A === null)
          return null;
        if (A === "")
          return "";
        A = A.replace(/\\+$/, (O) => O.length % 2 === 0 ? O : O.slice(0, -1));
        try {
          return JSON.parse(A);
        } catch (O) {
          const [T, $] = A.trimLeft()[0] === ":" ? o(A, O) : o(A, O, v);
          if (s.lastParseReminding = $, s.onExtraToken && $.length > 0) {
            const P = $.trimRight();
            s.lastParseReminding = P, P.length > 0 && s.onExtraToken(A, T, P);
          }
          return T;
        }
      }
    }
    t.parse = s, (function(A) {
      A.onExtraToken = (O, T, $) => {
        e("parsed json with extra tokens:", {
          text: O,
          data: T,
          reminding: $
        });
      };
    })(s = t.parse || (t.parse = {}));
    function o(A, O, T) {
      const $ = a[A[0]] || T;
      if (!$)
        throw e(`no parser registered for ${JSON.stringify(A[0])}:`, { s: A }), O;
      return $(A, O);
    }
    function l(A, O, T) {
      return A[0] === '"' ? m(A) : A[0] === "'" ? b(A) : v(A, O, T);
    }
    const a = {};
    function u(A) {
      return A.trimLeft();
    }
    a[" "] = c, a["\r"] = c, a[`
`] = c, a["	"] = c;
    function c(A, O) {
      return A = u(A), o(A, O);
    }
    a["["] = f;
    function f(A, O) {
      A = A.substr(1);
      const T = [];
      for (A = u(A); A.length > 0; ) {
        if (A[0] === "]") {
          A = A.substr(1);
          break;
        }
        const $ = o(A, O, (P, B) => v(P, B, [",", "]"]));
        T.push($[0]), A = $[1], A = u(A), A[0] === "," && (A = A.substring(1), A = u(A));
      }
      return [T, A];
    }
    for (const A of "0123456789.-".slice())
      a[A] = d;
    function d(A) {
      for (let O = 0; O < A.length; O++) {
        const T = A[O];
        if (a[T] === d)
          continue;
        const $ = A.substring(0, O);
        return A = A.substring(O), [p($), A];
      }
      return [p(A), ""];
    }
    function p(A) {
      if (A === "-")
        return -0;
      const O = +A;
      return Number.isNaN(O) ? A : O;
    }
    a['"'] = m;
    function m(A) {
      for (let O = 1; O < A.length; O++) {
        const T = A[O];
        if (T === "\\") {
          O++;
          continue;
        }
        if (T === '"') {
          const $ = y(A.substring(0, O + 1));
          return A = A.substring(O + 1), [JSON.parse($), A];
        }
      }
      return [JSON.parse(y(A) + '"'), ""];
    }
    function y(A) {
      return A.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    }
    a["'"] = b;
    function b(A) {
      for (let O = 1; O < A.length; O++) {
        const T = A[O];
        if (T === "\\") {
          O++;
          continue;
        }
        if (T === "'") {
          const $ = y(A.substring(0, O + 1));
          return A = A.substring(O + 1), [JSON.parse('"' + $.slice(1, -1) + '"'), A];
        }
      }
      return [JSON.parse('"' + y(A.slice(1)) + '"'), ""];
    }
    function v(A, O, T = [" "]) {
      const $ = Math.min(...T.map((M) => {
        const L = A.indexOf(M);
        return L === -1 ? A.length : L;
      })), P = A.substring(0, $).trim(), B = A.substring($);
      return [P, B];
    }
    a["{"] = _;
    function _(A, O) {
      A = A.substr(1);
      const T = {};
      for (A = u(A); A.length > 0; ) {
        if (A[0] === "}") {
          A = A.substr(1);
          break;
        }
        const $ = l(A, O, [":", "}"]), P = $[0];
        if (A = $[1], A = u(A), A[0] !== ":") {
          T[P] = void 0;
          break;
        }
        if (A = A.substr(1), A = u(A), A.length === 0) {
          T[P] = void 0;
          break;
        }
        const B = o(A, O);
        T[P] = B[0], A = B[1], A = u(A), A[0] === "," && (A = A.substr(1), A = u(A));
      }
      return [T, A];
    }
    a.t = k;
    function k(A, O) {
      return E(A, "true", !0, O);
    }
    a.f = S;
    function S(A, O) {
      return E(A, "false", !1, O);
    }
    a.n = C;
    function C(A, O) {
      return E(A, "null", null, O);
    }
    function E(A, O, T, $) {
      for (let P = O.length; P >= 1; P--)
        if (A.startsWith(O.slice(0, P)))
          return [T, A.slice(P)];
      {
        const P = JSON.stringify(A.slice(0, O.length));
        throw e(`unknown token starting with ${P}:`, { s: A }), $;
      }
    }
  })(v3)), v3;
}
var LN = Nhe();
function Bhe(t) {
  let e = null;
  try {
    e = JSON.parse(t.doc.toString());
  } catch {
    try {
      e = LN.parse(t.doc.toString());
    } catch {
    }
  }
  const n = j6(t, Hn.JSON);
  return { data: e, pointers: n };
}
var Lhe = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, $he = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, zhe = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, x3 = {
  Space_Separator: Lhe,
  ID_Start: $he,
  ID_Continue: zhe
}, fr = {
  isSpaceSeparator(t) {
    return typeof t == "string" && x3.Space_Separator.test(t);
  },
  isIdStartChar(t) {
    return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t === "$" || t === "_" || x3.ID_Start.test(t));
  },
  isIdContinueChar(t) {
    return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t >= "0" && t <= "9" || t === "$" || t === "_" || t === "â€Œ" || t === "â€" || x3.ID_Continue.test(t));
  },
  isDigit(t) {
    return typeof t == "string" && /[0-9]/.test(t);
  },
  isHexDigit(t) {
    return typeof t == "string" && /[0-9A-Fa-f]/.test(t);
  }
};
let G4, Ri, Ba, Zb, uc, Wo, Pr, h5, Mp;
var jhe = function(e, n) {
  G4 = String(e), Ri = "start", Ba = [], Zb = 0, uc = 1, Wo = 0, Pr = void 0, h5 = void 0, Mp = void 0;
  do
    Pr = qhe(), Vhe[Ri]();
  while (Pr.type !== "eof");
  return typeof n == "function" ? K4({ "": Mp }, "", n) : Mp;
};
function K4(t, e, n) {
  const r = t[e];
  if (r != null && typeof r == "object")
    if (Array.isArray(r))
      for (let i = 0; i < r.length; i++) {
        const s = String(i), o = K4(r, s, n);
        o === void 0 ? delete r[s] : Object.defineProperty(r, s, {
          value: o,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const i in r) {
        const s = K4(r, i, n);
        s === void 0 ? delete r[i] : Object.defineProperty(r, i, {
          value: s,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return n.call(t, e, r);
}
let Ft, wt, yp, Aa, $t;
function qhe() {
  for (Ft = "default", wt = "", yp = !1, Aa = 1; ; ) {
    $t = Va();
    const t = $N[Ft]();
    if (t)
      return t;
  }
}
function Va() {
  if (G4[Zb])
    return String.fromCodePoint(G4.codePointAt(Zb));
}
function ye() {
  const t = Va();
  return t === `
` ? (uc++, Wo = 0) : t ? Wo += t.length : Wo++, t && (Zb += t.length), t;
}
const $N = {
  default() {
    switch ($t) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "Â ":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        ye();
        return;
      case "/":
        ye(), Ft = "comment";
        return;
      case void 0:
        return ye(), Bn("eof");
    }
    if (fr.isSpaceSeparator($t)) {
      ye();
      return;
    }
    return $N[Ri]();
  },
  comment() {
    switch ($t) {
      case "*":
        ye(), Ft = "multiLineComment";
        return;
      case "/":
        ye(), Ft = "singleLineComment";
        return;
    }
    throw Ln(ye());
  },
  multiLineComment() {
    switch ($t) {
      case "*":
        ye(), Ft = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw Ln(ye());
    }
    ye();
  },
  multiLineCommentAsterisk() {
    switch ($t) {
      case "*":
        ye();
        return;
      case "/":
        ye(), Ft = "default";
        return;
      case void 0:
        throw Ln(ye());
    }
    ye(), Ft = "multiLineComment";
  },
  singleLineComment() {
    switch ($t) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        ye(), Ft = "default";
        return;
      case void 0:
        return ye(), Bn("eof");
    }
    ye();
  },
  value() {
    switch ($t) {
      case "{":
      case "[":
        return Bn("punctuator", ye());
      case "n":
        return ye(), Rc("ull"), Bn("null", null);
      case "t":
        return ye(), Rc("rue"), Bn("boolean", !0);
      case "f":
        return ye(), Rc("alse"), Bn("boolean", !1);
      case "-":
      case "+":
        ye() === "-" && (Aa = -1), Ft = "sign";
        return;
      case ".":
        wt = ye(), Ft = "decimalPointLeading";
        return;
      case "0":
        wt = ye(), Ft = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        wt = ye(), Ft = "decimalInteger";
        return;
      case "I":
        return ye(), Rc("nfinity"), Bn("numeric", 1 / 0);
      case "N":
        return ye(), Rc("aN"), Bn("numeric", NaN);
      case '"':
      case "'":
        yp = ye() === '"', wt = "", Ft = "string";
        return;
    }
    throw Ln(ye());
  },
  identifierNameStartEscape() {
    if ($t !== "u")
      throw Ln(ye());
    ye();
    const t = Y4();
    switch (t) {
      case "$":
      case "_":
        break;
      default:
        if (!fr.isIdStartChar(t))
          throw K7();
        break;
    }
    wt += t, Ft = "identifierName";
  },
  identifierName() {
    switch ($t) {
      case "$":
      case "_":
      case "â€Œ":
      case "â€":
        wt += ye();
        return;
      case "\\":
        ye(), Ft = "identifierNameEscape";
        return;
    }
    if (fr.isIdContinueChar($t)) {
      wt += ye();
      return;
    }
    return Bn("identifier", wt);
  },
  identifierNameEscape() {
    if ($t !== "u")
      throw Ln(ye());
    ye();
    const t = Y4();
    switch (t) {
      case "$":
      case "_":
      case "â€Œ":
      case "â€":
        break;
      default:
        if (!fr.isIdContinueChar(t))
          throw K7();
        break;
    }
    wt += t, Ft = "identifierName";
  },
  sign() {
    switch ($t) {
      case ".":
        wt = ye(), Ft = "decimalPointLeading";
        return;
      case "0":
        wt = ye(), Ft = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        wt = ye(), Ft = "decimalInteger";
        return;
      case "I":
        return ye(), Rc("nfinity"), Bn("numeric", Aa * (1 / 0));
      case "N":
        return ye(), Rc("aN"), Bn("numeric", NaN);
    }
    throw Ln(ye());
  },
  zero() {
    switch ($t) {
      case ".":
        wt += ye(), Ft = "decimalPoint";
        return;
      case "e":
      case "E":
        wt += ye(), Ft = "decimalExponent";
        return;
      case "x":
      case "X":
        wt += ye(), Ft = "hexadecimal";
        return;
    }
    return Bn("numeric", Aa * 0);
  },
  decimalInteger() {
    switch ($t) {
      case ".":
        wt += ye(), Ft = "decimalPoint";
        return;
      case "e":
      case "E":
        wt += ye(), Ft = "decimalExponent";
        return;
    }
    if (fr.isDigit($t)) {
      wt += ye();
      return;
    }
    return Bn("numeric", Aa * Number(wt));
  },
  decimalPointLeading() {
    if (fr.isDigit($t)) {
      wt += ye(), Ft = "decimalFraction";
      return;
    }
    throw Ln(ye());
  },
  decimalPoint() {
    switch ($t) {
      case "e":
      case "E":
        wt += ye(), Ft = "decimalExponent";
        return;
    }
    if (fr.isDigit($t)) {
      wt += ye(), Ft = "decimalFraction";
      return;
    }
    return Bn("numeric", Aa * Number(wt));
  },
  decimalFraction() {
    switch ($t) {
      case "e":
      case "E":
        wt += ye(), Ft = "decimalExponent";
        return;
    }
    if (fr.isDigit($t)) {
      wt += ye();
      return;
    }
    return Bn("numeric", Aa * Number(wt));
  },
  decimalExponent() {
    switch ($t) {
      case "+":
      case "-":
        wt += ye(), Ft = "decimalExponentSign";
        return;
    }
    if (fr.isDigit($t)) {
      wt += ye(), Ft = "decimalExponentInteger";
      return;
    }
    throw Ln(ye());
  },
  decimalExponentSign() {
    if (fr.isDigit($t)) {
      wt += ye(), Ft = "decimalExponentInteger";
      return;
    }
    throw Ln(ye());
  },
  decimalExponentInteger() {
    if (fr.isDigit($t)) {
      wt += ye();
      return;
    }
    return Bn("numeric", Aa * Number(wt));
  },
  hexadecimal() {
    if (fr.isHexDigit($t)) {
      wt += ye(), Ft = "hexadecimalInteger";
      return;
    }
    throw Ln(ye());
  },
  hexadecimalInteger() {
    if (fr.isHexDigit($t)) {
      wt += ye();
      return;
    }
    return Bn("numeric", Aa * Number(wt));
  },
  string() {
    switch ($t) {
      case "\\":
        ye(), wt += Uhe();
        return;
      case '"':
        if (yp)
          return ye(), Bn("string", wt);
        wt += ye();
        return;
      case "'":
        if (!yp)
          return ye(), Bn("string", wt);
        wt += ye();
        return;
      case `
`:
      case "\r":
        throw Ln(ye());
      case "\u2028":
      case "\u2029":
        Whe($t);
        break;
      case void 0:
        throw Ln(ye());
    }
    wt += ye();
  },
  start() {
    switch ($t) {
      case "{":
      case "[":
        return Bn("punctuator", ye());
    }
    Ft = "value";
  },
  beforePropertyName() {
    switch ($t) {
      case "$":
      case "_":
        wt = ye(), Ft = "identifierName";
        return;
      case "\\":
        ye(), Ft = "identifierNameStartEscape";
        return;
      case "}":
        return Bn("punctuator", ye());
      case '"':
      case "'":
        yp = ye() === '"', Ft = "string";
        return;
    }
    if (fr.isIdStartChar($t)) {
      wt += ye(), Ft = "identifierName";
      return;
    }
    throw Ln(ye());
  },
  afterPropertyName() {
    if ($t === ":")
      return Bn("punctuator", ye());
    throw Ln(ye());
  },
  beforePropertyValue() {
    Ft = "value";
  },
  afterPropertyValue() {
    switch ($t) {
      case ",":
      case "}":
        return Bn("punctuator", ye());
    }
    throw Ln(ye());
  },
  beforeArrayValue() {
    if ($t === "]")
      return Bn("punctuator", ye());
    Ft = "value";
  },
  afterArrayValue() {
    switch ($t) {
      case ",":
      case "]":
        return Bn("punctuator", ye());
    }
    throw Ln(ye());
  },
  end() {
    throw Ln(ye());
  }
};
function Bn(t, e) {
  return {
    type: t,
    value: e,
    line: uc,
    column: Wo
  };
}
function Rc(t) {
  for (const e of t) {
    if (Va() !== e)
      throw Ln(ye());
    ye();
  }
}
function Uhe() {
  switch (Va()) {
    case "b":
      return ye(), "\b";
    case "f":
      return ye(), "\f";
    case "n":
      return ye(), `
`;
    case "r":
      return ye(), "\r";
    case "t":
      return ye(), "	";
    case "v":
      return ye(), "\v";
    case "0":
      if (ye(), fr.isDigit(Va()))
        throw Ln(ye());
      return "\0";
    case "x":
      return ye(), Hhe();
    case "u":
      return ye(), Y4();
    case `
`:
    case "\u2028":
    case "\u2029":
      return ye(), "";
    case "\r":
      return ye(), Va() === `
` && ye(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw Ln(ye());
    case void 0:
      throw Ln(ye());
  }
  return ye();
}
function Hhe() {
  let t = "", e = Va();
  if (!fr.isHexDigit(e) || (t += ye(), e = Va(), !fr.isHexDigit(e)))
    throw Ln(ye());
  return t += ye(), String.fromCodePoint(parseInt(t, 16));
}
function Y4() {
  let t = "", e = 4;
  for (; e-- > 0; ) {
    const n = Va();
    if (!fr.isHexDigit(n))
      throw Ln(ye());
    t += ye();
  }
  return String.fromCodePoint(parseInt(t, 16));
}
const Vhe = {
  start() {
    if (Pr.type === "eof")
      throw Mc();
    w3();
  },
  beforePropertyName() {
    switch (Pr.type) {
      case "identifier":
      case "string":
        h5 = Pr.value, Ri = "afterPropertyName";
        return;
      case "punctuator":
        ry();
        return;
      case "eof":
        throw Mc();
    }
  },
  afterPropertyName() {
    if (Pr.type === "eof")
      throw Mc();
    Ri = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (Pr.type === "eof")
      throw Mc();
    w3();
  },
  beforeArrayValue() {
    if (Pr.type === "eof")
      throw Mc();
    if (Pr.type === "punctuator" && Pr.value === "]") {
      ry();
      return;
    }
    w3();
  },
  afterPropertyValue() {
    if (Pr.type === "eof")
      throw Mc();
    switch (Pr.value) {
      case ",":
        Ri = "beforePropertyName";
        return;
      case "}":
        ry();
    }
  },
  afterArrayValue() {
    if (Pr.type === "eof")
      throw Mc();
    switch (Pr.value) {
      case ",":
        Ri = "beforeArrayValue";
        return;
      case "]":
        ry();
    }
  },
  end() {
  }
};
function w3() {
  let t;
  switch (Pr.type) {
    case "punctuator":
      switch (Pr.value) {
        case "{":
          t = {};
          break;
        case "[":
          t = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      t = Pr.value;
      break;
  }
  if (Mp === void 0)
    Mp = t;
  else {
    const e = Ba[Ba.length - 1];
    Array.isArray(e) ? e.push(t) : Object.defineProperty(e, h5, {
      value: t,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (t !== null && typeof t == "object")
    Ba.push(t), Array.isArray(t) ? Ri = "beforeArrayValue" : Ri = "beforePropertyName";
  else {
    const e = Ba[Ba.length - 1];
    e == null ? Ri = "end" : Array.isArray(e) ? Ri = "afterArrayValue" : Ri = "afterPropertyValue";
  }
}
function ry() {
  Ba.pop();
  const t = Ba[Ba.length - 1];
  t == null ? Ri = "end" : Array.isArray(t) ? Ri = "afterArrayValue" : Ri = "afterPropertyValue";
}
function Ln(t) {
  return ev(t === void 0 ? `JSON5: invalid end of input at ${uc}:${Wo}` : `JSON5: invalid character '${zN(t)}' at ${uc}:${Wo}`);
}
function Mc() {
  return ev(`JSON5: invalid end of input at ${uc}:${Wo}`);
}
function K7() {
  return Wo -= 5, ev(`JSON5: invalid identifier character at ${uc}:${Wo}`);
}
function Whe(t) {
  console.warn(`JSON5: '${zN(t)}' in strings is not valid ECMAScript; consider escaping`);
}
function zN(t) {
  const e = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (e[t])
    return e[t];
  if (t < " ") {
    const n = t.charCodeAt(0).toString(16);
    return "\\x" + ("00" + n).substring(n.length);
  }
  return t;
}
function ev(t) {
  const e = new SyntaxError(t);
  return e.lineNumber = uc, e.columnNumber = Wo, e;
}
var Ghe = function(e, n, r) {
  const i = [];
  let s = "", o, l, a = "", u;
  if (n != null && typeof n == "object" && !Array.isArray(n) && (r = n.space, u = n.quote, n = n.replacer), typeof n == "function")
    l = n;
  else if (Array.isArray(n)) {
    o = [];
    for (const y of n) {
      let b;
      typeof y == "string" ? b = y : (typeof y == "number" || y instanceof String || y instanceof Number) && (b = String(y)), b !== void 0 && o.indexOf(b) < 0 && o.push(b);
    }
  }
  return r instanceof Number ? r = Number(r) : r instanceof String && (r = String(r)), typeof r == "number" ? r > 0 && (r = Math.min(10, Math.floor(r)), a = "          ".substr(0, r)) : typeof r == "string" && (a = r.substr(0, 10)), c("", { "": e });
  function c(y, b) {
    let v = b[y];
    switch (v != null && (typeof v.toJSON5 == "function" ? v = v.toJSON5(y) : typeof v.toJSON == "function" && (v = v.toJSON(y))), l && (v = l.call(b, y, v)), v instanceof Number ? v = Number(v) : v instanceof String ? v = String(v) : v instanceof Boolean && (v = v.valueOf()), v) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof v == "string")
      return f(v);
    if (typeof v == "number")
      return String(v);
    if (typeof v == "object")
      return Array.isArray(v) ? m(v) : d(v);
  }
  function f(y) {
    const b = {
      "'": 0.1,
      '"': 0.2
    }, v = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let _ = "";
    for (let S = 0; S < y.length; S++) {
      const C = y[S];
      switch (C) {
        case "'":
        case '"':
          b[C]++, _ += C;
          continue;
        case "\0":
          if (fr.isDigit(y[S + 1])) {
            _ += "\\x00";
            continue;
          }
      }
      if (v[C]) {
        _ += v[C];
        continue;
      }
      if (C < " ") {
        let E = C.charCodeAt(0).toString(16);
        _ += "\\x" + ("00" + E).substring(E.length);
        continue;
      }
      _ += C;
    }
    const k = u || Object.keys(b).reduce((S, C) => b[S] < b[C] ? S : C);
    return _ = _.replace(new RegExp(k, "g"), v[k]), k + _ + k;
  }
  function d(y) {
    if (i.indexOf(y) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    i.push(y);
    let b = s;
    s = s + a;
    let v = o || Object.keys(y), _ = [];
    for (const S of v) {
      const C = c(S, y);
      if (C !== void 0) {
        let E = p(S) + ":";
        a !== "" && (E += " "), E += C, _.push(E);
      }
    }
    let k;
    if (_.length === 0)
      k = "{}";
    else {
      let S;
      if (a === "")
        S = _.join(","), k = "{" + S + "}";
      else {
        let C = `,
` + s;
        S = _.join(C), k = `{
` + s + S + `,
` + b + "}";
      }
    }
    return i.pop(), s = b, k;
  }
  function p(y) {
    if (y.length === 0)
      return f(y);
    const b = String.fromCodePoint(y.codePointAt(0));
    if (!fr.isIdStartChar(b))
      return f(y);
    for (let v = b.length; v < y.length; v++)
      if (!fr.isIdContinueChar(String.fromCodePoint(y.codePointAt(v))))
        return f(y);
    return y;
  }
  function m(y) {
    if (i.indexOf(y) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    i.push(y);
    let b = s;
    s = s + a;
    let v = [];
    for (let k = 0; k < y.length; k++) {
      const S = c(String(k), y);
      v.push(S !== void 0 ? S : "null");
    }
    let _;
    if (v.length === 0)
      _ = "[]";
    else if (a === "")
      _ = "[" + v.join(",") + "]";
    else {
      let k = `,
` + s, S = v.join(k);
      _ = `[
` + s + S + `,
` + b + "]";
    }
    return i.pop(), s = b, _;
  }
};
const Khe = {
  parse: jhe,
  stringify: Ghe
};
var Yhe = Khe;
function Xhe(t) {
  const e = t.doc.toString();
  let n = null;
  try {
    n = Yhe.parse(e);
  } catch {
    try {
      n = LN.parse(e);
    } catch {
    }
  }
  const r = j6(t, Hn.JSON5);
  return { data: n, pointers: r };
}
const d5 = Symbol.for("yaml.alias"), X4 = Symbol.for("yaml.document"), Gu = Symbol.for("yaml.map"), jN = Symbol.for("yaml.pair"), Ql = Symbol.for("yaml.scalar"), i0 = Symbol.for("yaml.seq"), _o = Symbol.for("yaml.node.type"), mc = (t) => !!t && typeof t == "object" && t[_o] === d5, qf = (t) => !!t && typeof t == "object" && t[_o] === X4, s0 = (t) => !!t && typeof t == "object" && t[_o] === Gu, Gn = (t) => !!t && typeof t == "object" && t[_o] === jN, Fn = (t) => !!t && typeof t == "object" && t[_o] === Ql, o0 = (t) => !!t && typeof t == "object" && t[_o] === i0;
function Qn(t) {
  if (t && typeof t == "object")
    switch (t[_o]) {
      case Gu:
      case i0:
        return !0;
    }
  return !1;
}
function Jn(t) {
  if (t && typeof t == "object")
    switch (t[_o]) {
      case d5:
      case Gu:
      case Ql:
      case i0:
        return !0;
    }
  return !1;
}
const qN = (t) => (Fn(t) || Qn(t)) && !!t.anchor, es = Symbol("break visit"), UN = Symbol("skip children"), Ul = Symbol("remove node");
function Uf(t, e) {
  const n = HN(e);
  qf(t) ? Ph(null, t.contents, n, Object.freeze([t])) === Ul && (t.contents = null) : Ph(null, t, n, Object.freeze([]));
}
Uf.BREAK = es;
Uf.SKIP = UN;
Uf.REMOVE = Ul;
function Ph(t, e, n, r) {
  const i = VN(t, e, n, r);
  if (Jn(i) || Gn(i))
    return WN(t, r, i), Ph(t, i, n, r);
  if (typeof i != "symbol") {
    if (Qn(e)) {
      r = Object.freeze(r.concat(e));
      for (let s = 0; s < e.items.length; ++s) {
        const o = Ph(s, e.items[s], n, r);
        if (typeof o == "number")
          s = o - 1;
        else {
          if (o === es)
            return es;
          o === Ul && (e.items.splice(s, 1), s -= 1);
        }
      }
    } else if (Gn(e)) {
      r = Object.freeze(r.concat(e));
      const s = Ph("key", e.key, n, r);
      if (s === es)
        return es;
      s === Ul && (e.key = null);
      const o = Ph("value", e.value, n, r);
      if (o === es)
        return es;
      o === Ul && (e.value = null);
    }
  }
  return i;
}
async function a2(t, e) {
  const n = HN(e);
  qf(t) ? await Ih(null, t.contents, n, Object.freeze([t])) === Ul && (t.contents = null) : await Ih(null, t, n, Object.freeze([]));
}
a2.BREAK = es;
a2.SKIP = UN;
a2.REMOVE = Ul;
async function Ih(t, e, n, r) {
  const i = await VN(t, e, n, r);
  if (Jn(i) || Gn(i))
    return WN(t, r, i), Ih(t, i, n, r);
  if (typeof i != "symbol") {
    if (Qn(e)) {
      r = Object.freeze(r.concat(e));
      for (let s = 0; s < e.items.length; ++s) {
        const o = await Ih(s, e.items[s], n, r);
        if (typeof o == "number")
          s = o - 1;
        else {
          if (o === es)
            return es;
          o === Ul && (e.items.splice(s, 1), s -= 1);
        }
      }
    } else if (Gn(e)) {
      r = Object.freeze(r.concat(e));
      const s = await Ih("key", e.key, n, r);
      if (s === es)
        return es;
      s === Ul && (e.key = null);
      const o = await Ih("value", e.value, n, r);
      if (o === es)
        return es;
      o === Ul && (e.value = null);
    }
  }
  return i;
}
function HN(t) {
  return typeof t == "object" && (t.Collection || t.Node || t.Value) ? Object.assign({
    Alias: t.Node,
    Map: t.Node,
    Scalar: t.Node,
    Seq: t.Node
  }, t.Value && {
    Map: t.Value,
    Scalar: t.Value,
    Seq: t.Value
  }, t.Collection && {
    Map: t.Collection,
    Seq: t.Collection
  }, t) : t;
}
function VN(t, e, n, r) {
  if (typeof n == "function")
    return n(t, e, r);
  if (s0(e))
    return n.Map?.(t, e, r);
  if (o0(e))
    return n.Seq?.(t, e, r);
  if (Gn(e))
    return n.Pair?.(t, e, r);
  if (Fn(e))
    return n.Scalar?.(t, e, r);
  if (mc(e))
    return n.Alias?.(t, e, r);
}
function WN(t, e, n) {
  const r = e[e.length - 1];
  if (Qn(r))
    r.items[t] = n;
  else if (Gn(r))
    t === "key" ? r.key = n : r.value = n;
  else if (qf(r))
    r.contents = n;
  else {
    const i = mc(r) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
const Qhe = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, Jhe = (t) => t.replace(/[!,[\]{}]/g, (e) => Qhe[e]);
class Ai {
  constructor(e, n) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Ai.defaultYaml, e), this.tags = Object.assign({}, Ai.defaultTags, n);
  }
  clone() {
    const e = new Ai(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new Ai(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Ai.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Ai.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, n) {
    this.atNextDocument && (this.yaml = { explicit: Ai.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Ai.defaultTags), this.atNextDocument = !1);
    const r = e.trim().split(/[ \t]+/), i = r.shift();
    switch (i) {
      case "%TAG": {
        if (r.length !== 2 && (n(0, "%TAG directive should contain exactly two parts"), r.length < 2))
          return !1;
        const [s, o] = r;
        return this.tags[s] = o, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, r.length !== 1)
          return n(0, "%YAML directive should contain exactly one part"), !1;
        const [s] = r;
        if (s === "1.1" || s === "1.2")
          return this.yaml.version = s, !0;
        {
          const o = /^\d+\.\d+$/.test(s);
          return n(6, `Unsupported YAML version ${s}`, o), !1;
        }
      }
      default:
        return n(0, `Unknown directive ${i}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, n) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return n(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const o = e.slice(2, -1);
      return o === "!" || o === "!!" ? (n(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && n("Verbatim tags must end with a >"), o);
    }
    const [, r, i] = e.match(/^(.*!)([^!]*)$/s);
    i || n(`The ${e} tag has no suffix`);
    const s = this.tags[r];
    if (s)
      try {
        return s + decodeURIComponent(i);
      } catch (o) {
        return n(String(o)), null;
      }
    return r === "!" ? e : (n(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [n, r] of Object.entries(this.tags))
      if (e.startsWith(r))
        return n + Jhe(e.substring(r.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const n = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], r = Object.entries(this.tags);
    let i;
    if (e && r.length > 0 && Jn(e.contents)) {
      const s = {};
      Uf(e.contents, (o, l) => {
        Jn(l) && l.tag && (s[l.tag] = !0);
      }), i = Object.keys(s);
    } else
      i = [];
    for (const [s, o] of r)
      s === "!!" && o === "tag:yaml.org,2002:" || (!e || i.some((l) => l.startsWith(o))) && n.push(`%TAG ${s} ${o}`);
    return n.join(`
`);
  }
}
Ai.defaultYaml = { explicit: !1, version: "1.2" };
Ai.defaultTags = { "!!": "tag:yaml.org,2002:" };
function GN(t) {
  if (/[\x00-\x19\s,[\]{}]/.test(t)) {
    const n = `Anchor must not contain whitespace or control characters: ${JSON.stringify(t)}`;
    throw new Error(n);
  }
  return !0;
}
function KN(t) {
  const e = /* @__PURE__ */ new Set();
  return Uf(t, {
    Value(n, r) {
      r.anchor && e.add(r.anchor);
    }
  }), e;
}
function YN(t, e) {
  for (let n = 1; ; ++n) {
    const r = `${t}${n}`;
    if (!e.has(r))
      return r;
  }
}
function Zhe(t, e) {
  const n = [], r = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (s) => {
      n.push(s), i ?? (i = KN(t));
      const o = YN(e, i);
      return i.add(o), o;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const s of n) {
        const o = r.get(s);
        if (typeof o == "object" && o.anchor && (Fn(o.node) || Qn(o.node)))
          o.node.anchor = o.anchor;
        else {
          const l = new Error("Failed to resolve repeated object (this should not happen)");
          throw l.source = s, l;
        }
      }
    },
    sourceObjects: r
  };
}
function Nh(t, e, n, r) {
  if (r && typeof r == "object")
    if (Array.isArray(r))
      for (let i = 0, s = r.length; i < s; ++i) {
        const o = r[i], l = Nh(t, r, String(i), o);
        l === void 0 ? delete r[i] : l !== o && (r[i] = l);
      }
    else if (r instanceof Map)
      for (const i of Array.from(r.keys())) {
        const s = r.get(i), o = Nh(t, r, i, s);
        o === void 0 ? r.delete(i) : o !== s && r.set(i, o);
      }
    else if (r instanceof Set)
      for (const i of Array.from(r)) {
        const s = Nh(t, r, i, i);
        s === void 0 ? r.delete(i) : s !== i && (r.delete(i), r.add(s));
      }
    else
      for (const [i, s] of Object.entries(r)) {
        const o = Nh(t, r, i, s);
        o === void 0 ? delete r[i] : o !== s && (r[i] = o);
      }
  return t.call(e, n, r);
}
function vo(t, e, n) {
  if (Array.isArray(t))
    return t.map((r, i) => vo(r, String(i), n));
  if (t && typeof t.toJSON == "function") {
    if (!n || !qN(t))
      return t.toJSON(e, n);
    const r = { aliasCount: 0, count: 1, res: void 0 };
    n.anchors.set(t, r), n.onCreate = (s) => {
      r.res = s, delete n.onCreate;
    };
    const i = t.toJSON(e, n);
    return n.onCreate && n.onCreate(i), i;
  }
  return typeof t == "bigint" && !n?.keep ? Number(t) : t;
}
class p5 {
  constructor(e) {
    Object.defineProperty(this, _o, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: n, maxAliasCount: r, onAnchor: i, reviver: s } = {}) {
    if (!qf(e))
      throw new TypeError("A document argument is required");
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: n === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof r == "number" ? r : 100
    }, l = vo(this, "", o);
    if (typeof i == "function")
      for (const { count: a, res: u } of o.anchors.values())
        i(u, a);
    return typeof s == "function" ? Nh(s, { "": l }, "", l) : l;
  }
}
class u2 extends p5 {
  constructor(e) {
    super(d5), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e, n) {
    let r;
    n?.aliasResolveCache ? r = n.aliasResolveCache : (r = [], Uf(e, {
      Node: (s, o) => {
        (mc(o) || qN(o)) && r.push(o);
      }
    }), n && (n.aliasResolveCache = r));
    let i;
    for (const s of r) {
      if (s === this)
        break;
      s.anchor === this.source && (i = s);
    }
    return i;
  }
  toJSON(e, n) {
    if (!n)
      return { source: this.source };
    const { anchors: r, doc: i, maxAliasCount: s } = n, o = this.resolve(i, n);
    if (!o) {
      const a = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(a);
    }
    let l = r.get(o);
    if (l || (vo(o, null, n), l = r.get(o)), !l || l.res === void 0) {
      const a = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(a);
    }
    if (s >= 0 && (l.count += 1, l.aliasCount === 0 && (l.aliasCount = Ky(i, o, r)), l.count * l.aliasCount > s)) {
      const a = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(a);
    }
    return l.res;
  }
  toString(e, n, r) {
    const i = `*${this.source}`;
    if (e) {
      if (GN(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const s = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(s);
      }
      if (e.implicitKey)
        return `${i} `;
    }
    return i;
  }
}
function Ky(t, e, n) {
  if (mc(e)) {
    const r = e.resolve(t), i = n && r && n.get(r);
    return i ? i.count * i.aliasCount : 0;
  } else if (Qn(e)) {
    let r = 0;
    for (const i of e.items) {
      const s = Ky(t, i, n);
      s > r && (r = s);
    }
    return r;
  } else if (Gn(e)) {
    const r = Ky(t, e.key, n), i = Ky(t, e.value, n);
    return Math.max(r, i);
  }
  return 1;
}
const XN = (t) => !t || typeof t != "function" && typeof t != "object";
class vt extends p5 {
  constructor(e) {
    super(Ql), this.value = e;
  }
  toJSON(e, n) {
    return n?.keep ? this.value : vo(this.value, e, n);
  }
  toString() {
    return String(this.value);
  }
}
vt.BLOCK_FOLDED = "BLOCK_FOLDED";
vt.BLOCK_LITERAL = "BLOCK_LITERAL";
vt.PLAIN = "PLAIN";
vt.QUOTE_DOUBLE = "QUOTE_DOUBLE";
vt.QUOTE_SINGLE = "QUOTE_SINGLE";
const ede = "tag:yaml.org,2002:";
function tde(t, e, n) {
  if (e) {
    const r = n.filter((s) => s.tag === e), i = r.find((s) => !s.format) ?? r[0];
    if (!i)
      throw new Error(`Tag ${e} not found`);
    return i;
  }
  return n.find((r) => r.identify?.(t) && !r.format);
}
function Sg(t, e, n) {
  if (qf(t) && (t = t.contents), Jn(t))
    return t;
  if (Gn(t)) {
    const f = n.schema[Gu].createNode?.(n.schema, null, n);
    return f.items.push(t), f;
  }
  (t instanceof String || t instanceof Number || t instanceof Boolean || typeof BigInt < "u" && t instanceof BigInt) && (t = t.valueOf());
  const { aliasDuplicateObjects: r, onAnchor: i, onTagObj: s, schema: o, sourceObjects: l } = n;
  let a;
  if (r && t && typeof t == "object") {
    if (a = l.get(t), a)
      return a.anchor ?? (a.anchor = i(t)), new u2(a.anchor);
    a = { anchor: null, node: null }, l.set(t, a);
  }
  e?.startsWith("!!") && (e = ede + e.slice(2));
  let u = tde(t, e, o.tags);
  if (!u) {
    if (t && typeof t.toJSON == "function" && (t = t.toJSON()), !t || typeof t != "object") {
      const f = new vt(t);
      return a && (a.node = f), f;
    }
    u = t instanceof Map ? o[Gu] : Symbol.iterator in Object(t) ? o[i0] : o[Gu];
  }
  s && (s(u), delete n.onTagObj);
  const c = u?.createNode ? u.createNode(n.schema, t, n) : typeof u?.nodeClass?.from == "function" ? u.nodeClass.from(n.schema, t, n) : new vt(t);
  return e ? c.tag = e : u.default || (c.tag = u.tag), a && (a.node = c), c;
}
function tv(t, e, n) {
  let r = n;
  for (let i = e.length - 1; i >= 0; --i) {
    const s = e[i];
    if (typeof s == "number" && Number.isInteger(s) && s >= 0) {
      const o = [];
      o[s] = r, r = o;
    } else
      r = /* @__PURE__ */ new Map([[s, r]]);
  }
  return Sg(r, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: t,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const bp = (t) => t == null || typeof t == "object" && !!t[Symbol.iterator]().next().done;
class QN extends p5 {
  constructor(e, n) {
    super(e), Object.defineProperty(this, "schema", {
      value: n,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const n = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (n.schema = e), n.items = n.items.map((r) => Jn(r) || Gn(r) ? r.clone(e) : r), this.range && (n.range = this.range.slice()), n;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, n) {
    if (bp(e))
      this.add(n);
    else {
      const [r, ...i] = e, s = this.get(r, !0);
      if (Qn(s))
        s.addIn(i, n);
      else if (s === void 0 && this.schema)
        this.set(r, tv(this.schema, i, n));
      else
        throw new Error(`Expected YAML collection at ${r}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [n, ...r] = e;
    if (r.length === 0)
      return this.delete(n);
    const i = this.get(n, !0);
    if (Qn(i))
      return i.deleteIn(r);
    throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, n) {
    const [r, ...i] = e, s = this.get(r, !0);
    return i.length === 0 ? !n && Fn(s) ? s.value : s : Qn(s) ? s.getIn(i, n) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((n) => {
      if (!Gn(n))
        return !1;
      const r = n.value;
      return r == null || e && Fn(r) && r.value == null && !r.commentBefore && !r.comment && !r.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [n, ...r] = e;
    if (r.length === 0)
      return this.has(n);
    const i = this.get(n, !0);
    return Qn(i) ? i.hasIn(r) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, n) {
    const [r, ...i] = e;
    if (i.length === 0)
      this.set(r, n);
    else {
      const s = this.get(r, !0);
      if (Qn(s))
        s.setIn(i, n);
      else if (s === void 0 && this.schema)
        this.set(r, tv(this.schema, i, n));
      else
        throw new Error(`Expected YAML collection at ${r}. Remaining path: ${i}`);
    }
  }
}
const nde = (t) => t.replace(/^(?!$)(?: $)?/gm, "#");
function $a(t, e) {
  return /^\n+$/.test(t) ? t.substring(1) : e ? t.replace(/^(?! *$)/gm, e) : t;
}
const Gc = (t, e, n) => t.endsWith(`
`) ? $a(n, e) : n.includes(`
`) ? `
` + $a(n, e) : (t.endsWith(" ") ? "" : " ") + n, JN = "flow", Q4 = "block", Yy = "quoted";
function c2(t, e, n = "flow", { indentAtStart: r, lineWidth: i = 80, minContentWidth: s = 20, onFold: o, onOverflow: l } = {}) {
  if (!i || i < 0)
    return t;
  i < s && (s = 0);
  const a = Math.max(1 + s, 1 + i - e.length);
  if (t.length <= a)
    return t;
  const u = [], c = {};
  let f = i - e.length;
  typeof r == "number" && (r > i - Math.max(2, s) ? u.push(0) : f = i - r);
  let d, p, m = !1, y = -1, b = -1, v = -1;
  n === Q4 && (y = Y7(t, y, e.length), y !== -1 && (f = y + a));
  for (let k; k = t[y += 1]; ) {
    if (n === Yy && k === "\\") {
      switch (b = y, t[y + 1]) {
        case "x":
          y += 3;
          break;
        case "u":
          y += 5;
          break;
        case "U":
          y += 9;
          break;
        default:
          y += 1;
      }
      v = y;
    }
    if (k === `
`)
      n === Q4 && (y = Y7(t, y, e.length)), f = y + e.length + a, d = void 0;
    else {
      if (k === " " && p && p !== " " && p !== `
` && p !== "	") {
        const S = t[y + 1];
        S && S !== " " && S !== `
` && S !== "	" && (d = y);
      }
      if (y >= f)
        if (d)
          u.push(d), f = d + a, d = void 0;
        else if (n === Yy) {
          for (; p === " " || p === "	"; )
            p = k, k = t[y += 1], m = !0;
          const S = y > v + 1 ? y - 2 : b - 1;
          if (c[S])
            return t;
          u.push(S), c[S] = !0, f = S + a, d = void 0;
        } else
          m = !0;
    }
    p = k;
  }
  if (m && l && l(), u.length === 0)
    return t;
  o && o();
  let _ = t.slice(0, u[0]);
  for (let k = 0; k < u.length; ++k) {
    const S = u[k], C = u[k + 1] || t.length;
    S === 0 ? _ = `
${e}${t.slice(0, C)}` : (n === Yy && c[S] && (_ += `${t[S]}\\`), _ += `
${e}${t.slice(S + 1, C)}`);
  }
  return _;
}
function Y7(t, e, n) {
  let r = e, i = e + 1, s = t[i];
  for (; s === " " || s === "	"; )
    if (e < i + n)
      s = t[++e];
    else {
      do
        s = t[++e];
      while (s && s !== `
`);
      r = e, i = e + 1, s = t[i];
    }
  return r;
}
const f2 = (t, e) => ({
  indentAtStart: e ? t.indent.length : t.indentAtStart,
  lineWidth: t.options.lineWidth,
  minContentWidth: t.options.minContentWidth
}), h2 = (t) => /^(%|---|\.\.\.)/m.test(t);
function rde(t, e, n) {
  if (!e || e < 0)
    return !1;
  const r = e - n, i = t.length;
  if (i <= r)
    return !1;
  for (let s = 0, o = 0; s < i; ++s)
    if (t[s] === `
`) {
      if (s - o > r)
        return !0;
      if (o = s + 1, i - o <= r)
        return !1;
    }
  return !0;
}
function Pp(t, e) {
  const n = JSON.stringify(t);
  if (e.options.doubleQuotedAsJSON)
    return n;
  const { implicitKey: r } = e, i = e.options.doubleQuotedMinMultiLineLength, s = e.indent || (h2(t) ? "  " : "");
  let o = "", l = 0;
  for (let a = 0, u = n[a]; u; u = n[++a])
    if (u === " " && n[a + 1] === "\\" && n[a + 2] === "n" && (o += n.slice(l, a) + "\\ ", a += 1, l = a, u = "\\"), u === "\\")
      switch (n[a + 1]) {
        case "u":
          {
            o += n.slice(l, a);
            const c = n.substr(a + 2, 4);
            switch (c) {
              case "0000":
                o += "\\0";
                break;
              case "0007":
                o += "\\a";
                break;
              case "000b":
                o += "\\v";
                break;
              case "001b":
                o += "\\e";
                break;
              case "0085":
                o += "\\N";
                break;
              case "00a0":
                o += "\\_";
                break;
              case "2028":
                o += "\\L";
                break;
              case "2029":
                o += "\\P";
                break;
              default:
                c.substr(0, 2) === "00" ? o += "\\x" + c.substr(2) : o += n.substr(a, 6);
            }
            a += 5, l = a + 1;
          }
          break;
        case "n":
          if (r || n[a + 2] === '"' || n.length < i)
            a += 1;
          else {
            for (o += n.slice(l, a) + `

`; n[a + 2] === "\\" && n[a + 3] === "n" && n[a + 4] !== '"'; )
              o += `
`, a += 2;
            o += s, n[a + 2] === " " && (o += "\\"), a += 1, l = a + 1;
          }
          break;
        default:
          a += 1;
      }
  return o = l ? o + n.slice(l) : n, r ? o : c2(o, s, Yy, f2(e, !1));
}
function J4(t, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && t.includes(`
`) || /[ \t]\n|\n[ \t]/.test(t))
    return Pp(t, e);
  const n = e.indent || (h2(t) ? "  " : ""), r = "'" + t.replace(/'/g, "''").replace(/\n+/g, `$&
${n}`) + "'";
  return e.implicitKey ? r : c2(r, n, JN, f2(e, !1));
}
function Bh(t, e) {
  const { singleQuote: n } = e.options;
  let r;
  if (n === !1)
    r = Pp;
  else {
    const i = t.includes('"'), s = t.includes("'");
    i && !s ? r = J4 : s && !i ? r = Pp : r = n ? J4 : Pp;
  }
  return r(t, e);
}
let Z4;
try {
  Z4 = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  Z4 = /\n+(?!\n|$)/g;
}
function Xy({ comment: t, type: e, value: n }, r, i, s) {
  const { blockQuote: o, commentString: l, lineWidth: a } = r.options;
  if (!o || /\n[\t ]+$/.test(n))
    return Bh(n, r);
  const u = r.indent || (r.forceBlockIndent || h2(n) ? "  " : ""), c = o === "literal" ? !0 : o === "folded" || e === vt.BLOCK_FOLDED ? !1 : e === vt.BLOCK_LITERAL ? !0 : !rde(n, a, u.length);
  if (!n)
    return c ? `|
` : `>
`;
  let f, d;
  for (d = n.length; d > 0; --d) {
    const C = n[d - 1];
    if (C !== `
` && C !== "	" && C !== " ")
      break;
  }
  let p = n.substring(d);
  const m = p.indexOf(`
`);
  m === -1 ? f = "-" : n === p || m !== p.length - 1 ? (f = "+", s && s()) : f = "", p && (n = n.slice(0, -p.length), p[p.length - 1] === `
` && (p = p.slice(0, -1)), p = p.replace(Z4, `$&${u}`));
  let y = !1, b, v = -1;
  for (b = 0; b < n.length; ++b) {
    const C = n[b];
    if (C === " ")
      y = !0;
    else if (C === `
`)
      v = b;
    else
      break;
  }
  let _ = n.substring(0, v < b ? v + 1 : b);
  _ && (n = n.substring(_.length), _ = _.replace(/\n+/g, `$&${u}`));
  let S = (y ? u ? "2" : "1" : "") + f;
  if (t && (S += " " + l(t.replace(/ ?[\r\n]+/g, " ")), i && i()), !c) {
    const C = n.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${u}`);
    let E = !1;
    const A = f2(r, !0);
    o !== "folded" && e !== vt.BLOCK_FOLDED && (A.onOverflow = () => {
      E = !0;
    });
    const O = c2(`${_}${C}${p}`, u, Q4, A);
    if (!E)
      return `>${S}
${u}${O}`;
  }
  return n = n.replace(/\n+/g, `$&${u}`), `|${S}
${u}${_}${n}${p}`;
}
function ide(t, e, n, r) {
  const { type: i, value: s } = t, { actualString: o, implicitKey: l, indent: a, indentStep: u, inFlow: c } = e;
  if (l && s.includes(`
`) || c && /[[\]{},]/.test(s))
    return Bh(s, e);
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(s))
    return l || c || !s.includes(`
`) ? Bh(s, e) : Xy(t, e, n, r);
  if (!l && !c && i !== vt.PLAIN && s.includes(`
`))
    return Xy(t, e, n, r);
  if (h2(s)) {
    if (a === "")
      return e.forceBlockIndent = !0, Xy(t, e, n, r);
    if (l && a === u)
      return Bh(s, e);
  }
  const f = s.replace(/\n+/g, `$&
${a}`);
  if (o) {
    const d = (y) => y.default && y.tag !== "tag:yaml.org,2002:str" && y.test?.test(f), { compat: p, tags: m } = e.doc.schema;
    if (m.some(d) || p?.some(d))
      return Bh(s, e);
  }
  return l ? f : c2(f, a, JN, f2(e, !1));
}
function fm(t, e, n, r) {
  const { implicitKey: i, inFlow: s } = e, o = typeof t.value == "string" ? t : Object.assign({}, t, { value: String(t.value) });
  let { type: l } = t;
  l !== vt.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o.value) && (l = vt.QUOTE_DOUBLE);
  const a = (c) => {
    switch (c) {
      case vt.BLOCK_FOLDED:
      case vt.BLOCK_LITERAL:
        return i || s ? Bh(o.value, e) : Xy(o, e, n, r);
      case vt.QUOTE_DOUBLE:
        return Pp(o.value, e);
      case vt.QUOTE_SINGLE:
        return J4(o.value, e);
      case vt.PLAIN:
        return ide(o, e, n, r);
      default:
        return null;
    }
  };
  let u = a(l);
  if (u === null) {
    const { defaultKeyType: c, defaultStringType: f } = e.options, d = i && c || f;
    if (u = a(d), u === null)
      throw new Error(`Unsupported default string type ${d}`);
  }
  return u;
}
function ZN(t, e) {
  const n = Object.assign({
    blockQuote: !0,
    commentString: nde,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, t.schema.toStringOptions, e);
  let r;
  switch (n.collectionStyle) {
    case "block":
      r = !1;
      break;
    case "flow":
      r = !0;
      break;
    default:
      r = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: t,
    flowCollectionPadding: n.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof n.indent == "number" ? " ".repeat(n.indent) : "  ",
    inFlow: r,
    options: n
  };
}
function sde(t, e) {
  if (e.tag) {
    const i = t.filter((s) => s.tag === e.tag);
    if (i.length > 0)
      return i.find((s) => s.format === e.format) ?? i[0];
  }
  let n, r;
  if (Fn(e)) {
    r = e.value;
    let i = t.filter((s) => s.identify?.(r));
    if (i.length > 1) {
      const s = i.filter((o) => o.test);
      s.length > 0 && (i = s);
    }
    n = i.find((s) => s.format === e.format) ?? i.find((s) => !s.format);
  } else
    r = e, n = t.find((i) => i.nodeClass && r instanceof i.nodeClass);
  if (!n) {
    const i = r?.constructor?.name ?? (r === null ? "null" : typeof r);
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return n;
}
function ode(t, e, { anchors: n, doc: r }) {
  if (!r.directives)
    return "";
  const i = [], s = (Fn(t) || Qn(t)) && t.anchor;
  s && GN(s) && (n.add(s), i.push(`&${s}`));
  const o = t.tag ?? (e.default ? null : e.tag);
  return o && i.push(r.directives.tagString(o)), i.join(" ");
}
function Td(t, e, n, r) {
  if (Gn(t))
    return t.toString(e, n, r);
  if (mc(t)) {
    if (e.doc.directives)
      return t.toString(e);
    if (e.resolvedAliases?.has(t))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(t) : e.resolvedAliases = /* @__PURE__ */ new Set([t]), t = t.resolve(e.doc);
  }
  let i;
  const s = Jn(t) ? t : e.doc.createNode(t, { onTagObj: (a) => i = a });
  i ?? (i = sde(e.doc.schema.tags, s));
  const o = ode(s, i, e);
  o.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + o.length + 1);
  const l = typeof i.stringify == "function" ? i.stringify(s, e, n, r) : Fn(s) ? fm(s, e, n, r) : s.toString(e, n, r);
  return o ? Fn(s) || l[0] === "{" || l[0] === "[" ? `${o} ${l}` : `${o}
${e.indent}${l}` : l;
}
function lde({ key: t, value: e }, n, r, i) {
  const { allNullValues: s, doc: o, indent: l, indentStep: a, options: { commentString: u, indentSeq: c, simpleKeys: f } } = n;
  let d = Jn(t) && t.comment || null;
  if (f) {
    if (d)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (Qn(t) || !Jn(t) && typeof t == "object") {
      const A = "With simple keys, collection cannot be used as a key value";
      throw new Error(A);
    }
  }
  let p = !f && (!t || d && e == null && !n.inFlow || Qn(t) || (Fn(t) ? t.type === vt.BLOCK_FOLDED || t.type === vt.BLOCK_LITERAL : typeof t == "object"));
  n = Object.assign({}, n, {
    allNullValues: !1,
    implicitKey: !p && (f || !s),
    indent: l + a
  });
  let m = !1, y = !1, b = Td(t, n, () => m = !0, () => y = !0);
  if (!p && !n.inFlow && b.length > 1024) {
    if (f)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    p = !0;
  }
  if (n.inFlow) {
    if (s || e == null)
      return m && r && r(), b === "" ? "?" : p ? `? ${b}` : b;
  } else if (s && !f || e == null && p)
    return b = `? ${b}`, d && !m ? b += Gc(b, n.indent, u(d)) : y && i && i(), b;
  m && (d = null), p ? (d && (b += Gc(b, n.indent, u(d))), b = `? ${b}
${l}:`) : (b = `${b}:`, d && (b += Gc(b, n.indent, u(d))));
  let v, _, k;
  Jn(e) ? (v = !!e.spaceBefore, _ = e.commentBefore, k = e.comment) : (v = !1, _ = null, k = null, e && typeof e == "object" && (e = o.createNode(e))), n.implicitKey = !1, !p && !d && Fn(e) && (n.indentAtStart = b.length + 1), y = !1, !c && a.length >= 2 && !n.inFlow && !p && o0(e) && !e.flow && !e.tag && !e.anchor && (n.indent = n.indent.substring(2));
  let S = !1;
  const C = Td(e, n, () => S = !0, () => y = !0);
  let E = " ";
  if (d || v || _) {
    if (E = v ? `
` : "", _) {
      const A = u(_);
      E += `
${$a(A, n.indent)}`;
    }
    C === "" && !n.inFlow ? E === `
` && (E = `

`) : E += `
${n.indent}`;
  } else if (!p && Qn(e)) {
    const A = C[0], O = C.indexOf(`
`), T = O !== -1, $ = n.inFlow ?? e.flow ?? e.items.length === 0;
    if (T || !$) {
      let P = !1;
      if (T && (A === "&" || A === "!")) {
        let B = C.indexOf(" ");
        A === "&" && B !== -1 && B < O && C[B + 1] === "!" && (B = C.indexOf(" ", B + 1)), (B === -1 || O < B) && (P = !0);
      }
      P || (E = `
${n.indent}`);
    }
  } else (C === "" || C[0] === `
`) && (E = "");
  return b += E + C, n.inFlow ? S && r && r() : k && !S ? b += Gc(b, n.indent, u(k)) : y && i && i(), b;
}
function eB(t, e) {
  (t === "debug" || t === "warn") && console.warn(e);
}
const iy = "<<", Wa = {
  identify: (t) => t === iy || typeof t == "symbol" && t.description === iy,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new vt(Symbol(iy)), {
    addToJSMap: tB
  }),
  stringify: () => iy
}, ade = (t, e) => (Wa.identify(e) || Fn(e) && (!e.type || e.type === vt.PLAIN) && Wa.identify(e.value)) && t?.doc.schema.tags.some((n) => n.tag === Wa.tag && n.default);
function tB(t, e, n) {
  if (n = t && mc(n) ? n.resolve(t.doc) : n, o0(n))
    for (const r of n.items)
      _3(t, e, r);
  else if (Array.isArray(n))
    for (const r of n)
      _3(t, e, r);
  else
    _3(t, e, n);
}
function _3(t, e, n) {
  const r = t && mc(n) ? n.resolve(t.doc) : n;
  if (!s0(r))
    throw new Error("Merge sources must be maps or map aliases");
  const i = r.toJSON(null, t, Map);
  for (const [s, o] of i)
    e instanceof Map ? e.has(s) || e.set(s, o) : e instanceof Set ? e.add(s) : Object.prototype.hasOwnProperty.call(e, s) || Object.defineProperty(e, s, {
      value: o,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function nB(t, e, { key: n, value: r }) {
  if (Jn(n) && n.addToJSMap)
    n.addToJSMap(t, e, r);
  else if (ade(t, n))
    tB(t, e, r);
  else {
    const i = vo(n, "", t);
    if (e instanceof Map)
      e.set(i, vo(r, i, t));
    else if (e instanceof Set)
      e.add(i);
    else {
      const s = ude(n, i, t), o = vo(r, s, t);
      s in e ? Object.defineProperty(e, s, {
        value: o,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[s] = o;
    }
  }
  return e;
}
function ude(t, e, n) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (Jn(t) && n?.doc) {
    const r = ZN(n.doc, {});
    r.anchors = /* @__PURE__ */ new Set();
    for (const s of n.anchors.keys())
      r.anchors.add(s.anchor);
    r.inFlow = !0, r.inStringifyKey = !0;
    const i = t.toString(r);
    if (!n.mapKeyWarned) {
      let s = JSON.stringify(i);
      s.length > 40 && (s = s.substring(0, 36) + '..."'), eB(n.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${s}. Set mapAsMap: true to use object keys.`), n.mapKeyWarned = !0;
    }
    return i;
  }
  return JSON.stringify(e);
}
function g5(t, e, n) {
  const r = Sg(t, void 0, n), i = Sg(e, void 0, n);
  return new fi(r, i);
}
class fi {
  constructor(e, n = null) {
    Object.defineProperty(this, _o, { value: jN }), this.key = e, this.value = n;
  }
  clone(e) {
    let { key: n, value: r } = this;
    return Jn(n) && (n = n.clone(e)), Jn(r) && (r = r.clone(e)), new fi(n, r);
  }
  toJSON(e, n) {
    const r = n?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return nB(n, r, this);
  }
  toString(e, n, r) {
    return e?.doc ? lde(this, e, n, r) : JSON.stringify(this);
  }
}
function rB(t, e, n) {
  return (e.inFlow ?? t.flow ? fde : cde)(t, e, n);
}
function cde({ comment: t, items: e }, n, { blockItemPrefix: r, flowChars: i, itemIndent: s, onChompKeep: o, onComment: l }) {
  const { indent: a, options: { commentString: u } } = n, c = Object.assign({}, n, { indent: s, type: null });
  let f = !1;
  const d = [];
  for (let m = 0; m < e.length; ++m) {
    const y = e[m];
    let b = null;
    if (Jn(y))
      !f && y.spaceBefore && d.push(""), nv(n, d, y.commentBefore, f), y.comment && (b = y.comment);
    else if (Gn(y)) {
      const _ = Jn(y.key) ? y.key : null;
      _ && (!f && _.spaceBefore && d.push(""), nv(n, d, _.commentBefore, f));
    }
    f = !1;
    let v = Td(y, c, () => b = null, () => f = !0);
    b && (v += Gc(v, s, u(b))), f && b && (f = !1), d.push(r + v);
  }
  let p;
  if (d.length === 0)
    p = i.start + i.end;
  else {
    p = d[0];
    for (let m = 1; m < d.length; ++m) {
      const y = d[m];
      p += y ? `
${a}${y}` : `
`;
    }
  }
  return t ? (p += `
` + $a(u(t), a), l && l()) : f && o && o(), p;
}
function fde({ items: t }, e, { flowChars: n, itemIndent: r }) {
  const { indent: i, indentStep: s, flowCollectionPadding: o, options: { commentString: l } } = e;
  r += s;
  const a = Object.assign({}, e, {
    indent: r,
    inFlow: !0,
    type: null
  });
  let u = !1, c = 0;
  const f = [];
  for (let m = 0; m < t.length; ++m) {
    const y = t[m];
    let b = null;
    if (Jn(y))
      y.spaceBefore && f.push(""), nv(e, f, y.commentBefore, !1), y.comment && (b = y.comment);
    else if (Gn(y)) {
      const _ = Jn(y.key) ? y.key : null;
      _ && (_.spaceBefore && f.push(""), nv(e, f, _.commentBefore, !1), _.comment && (u = !0));
      const k = Jn(y.value) ? y.value : null;
      k ? (k.comment && (b = k.comment), k.commentBefore && (u = !0)) : y.value == null && _?.comment && (b = _.comment);
    }
    b && (u = !0);
    let v = Td(y, a, () => b = null);
    m < t.length - 1 && (v += ","), b && (v += Gc(v, r, l(b))), !u && (f.length > c || v.includes(`
`)) && (u = !0), f.push(v), c = f.length;
  }
  const { start: d, end: p } = n;
  if (f.length === 0)
    return d + p;
  if (!u) {
    const m = f.reduce((y, b) => y + b.length + 2, 2);
    u = e.options.lineWidth > 0 && m > e.options.lineWidth;
  }
  if (u) {
    let m = d;
    for (const y of f)
      m += y ? `
${s}${i}${y}` : `
`;
    return `${m}
${i}${p}`;
  } else
    return `${d}${o}${f.join(" ")}${o}${p}`;
}
function nv({ indent: t, options: { commentString: e } }, n, r, i) {
  if (r && i && (r = r.replace(/^\n+/, "")), r) {
    const s = $a(e(r), t);
    n.push(s.trimStart());
  }
}
function Kc(t, e) {
  const n = Fn(e) ? e.value : e;
  for (const r of t)
    if (Gn(r) && (r.key === e || r.key === n || Fn(r.key) && r.key.value === n))
      return r;
}
class Is extends QN {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(Gu, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, n, r) {
    const { keepUndefined: i, replacer: s } = r, o = new this(e), l = (a, u) => {
      if (typeof s == "function")
        u = s.call(n, a, u);
      else if (Array.isArray(s) && !s.includes(a))
        return;
      (u !== void 0 || i) && o.items.push(g5(a, u, r));
    };
    if (n instanceof Map)
      for (const [a, u] of n)
        l(a, u);
    else if (n && typeof n == "object")
      for (const a of Object.keys(n))
        l(a, n[a]);
    return typeof e.sortMapEntries == "function" && o.items.sort(e.sortMapEntries), o;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, n) {
    let r;
    Gn(e) ? r = e : !e || typeof e != "object" || !("key" in e) ? r = new fi(e, e?.value) : r = new fi(e.key, e.value);
    const i = Kc(this.items, r.key), s = this.schema?.sortMapEntries;
    if (i) {
      if (!n)
        throw new Error(`Key ${r.key} already set`);
      Fn(i.value) && XN(r.value) ? i.value.value = r.value : i.value = r.value;
    } else if (s) {
      const o = this.items.findIndex((l) => s(r, l) < 0);
      o === -1 ? this.items.push(r) : this.items.splice(o, 0, r);
    } else
      this.items.push(r);
  }
  delete(e) {
    const n = Kc(this.items, e);
    return n ? this.items.splice(this.items.indexOf(n), 1).length > 0 : !1;
  }
  get(e, n) {
    const i = Kc(this.items, e)?.value;
    return (!n && Fn(i) ? i.value : i) ?? void 0;
  }
  has(e) {
    return !!Kc(this.items, e);
  }
  set(e, n) {
    this.add(new fi(e, n), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, n, r) {
    const i = r ? new r() : n?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    n?.onCreate && n.onCreate(i);
    for (const s of this.items)
      nB(n, i, s);
    return i;
  }
  toString(e, n, r) {
    if (!e)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!Gn(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), rB(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: r,
      onComment: n
    });
  }
}
const l0 = {
  collection: "map",
  default: !0,
  nodeClass: Is,
  tag: "tag:yaml.org,2002:map",
  resolve(t, e) {
    return s0(t) || e("Expected a mapping for this tag"), t;
  },
  createNode: (t, e, n) => Is.from(t, e, n)
};
class cc extends QN {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(i0, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const n = sy(e);
    return typeof n != "number" ? !1 : this.items.splice(n, 1).length > 0;
  }
  get(e, n) {
    const r = sy(e);
    if (typeof r != "number")
      return;
    const i = this.items[r];
    return !n && Fn(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const n = sy(e);
    return typeof n == "number" && n < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, n) {
    const r = sy(e);
    if (typeof r != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const i = this.items[r];
    Fn(i) && XN(n) ? i.value = n : this.items[r] = n;
  }
  toJSON(e, n) {
    const r = [];
    n?.onCreate && n.onCreate(r);
    let i = 0;
    for (const s of this.items)
      r.push(vo(s, String(i++), n));
    return r;
  }
  toString(e, n, r) {
    return e ? rB(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: r,
      onComment: n
    }) : JSON.stringify(this);
  }
  static from(e, n, r) {
    const { replacer: i } = r, s = new this(e);
    if (n && Symbol.iterator in Object(n)) {
      let o = 0;
      for (let l of n) {
        if (typeof i == "function") {
          const a = n instanceof Set ? l : String(o++);
          l = i.call(n, a, l);
        }
        s.items.push(Sg(l, void 0, r));
      }
    }
    return s;
  }
}
function sy(t) {
  let e = Fn(t) ? t.value : t;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
const a0 = {
  collection: "seq",
  default: !0,
  nodeClass: cc,
  tag: "tag:yaml.org,2002:seq",
  resolve(t, e) {
    return o0(t) || e("Expected a sequence for this tag"), t;
  },
  createNode: (t, e, n) => cc.from(t, e, n)
}, d2 = {
  identify: (t) => typeof t == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (t) => t,
  stringify(t, e, n, r) {
    return e = Object.assign({ actualString: !0 }, e), fm(t, e, n, r);
  }
}, p2 = {
  identify: (t) => t == null,
  createNode: () => new vt(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new vt(null),
  stringify: ({ source: t }, e) => typeof t == "string" && p2.test.test(t) ? t : e.options.nullStr
}, m5 = {
  identify: (t) => typeof t == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (t) => new vt(t[0] === "t" || t[0] === "T"),
  stringify({ source: t, value: e }, n) {
    if (t && m5.test.test(t)) {
      const r = t[0] === "t" || t[0] === "T";
      if (e === r)
        return t;
    }
    return e ? n.options.trueStr : n.options.falseStr;
  }
};
function ll({ format: t, minFractionDigits: e, tag: n, value: r }) {
  if (typeof r == "bigint")
    return String(r);
  const i = typeof r == "number" ? r : Number(r);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let s = JSON.stringify(r);
  if (!t && e && (!n || n === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
    let o = s.indexOf(".");
    o < 0 && (o = s.length, s += ".");
    let l = e - (s.length - o - 1);
    for (; l-- > 0; )
      s += "0";
  }
  return s;
}
const iB = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: ll
}, sB = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : ll(t);
  }
}, oB = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(t) {
    const e = new vt(parseFloat(t)), n = t.indexOf(".");
    return n !== -1 && t[t.length - 1] === "0" && (e.minFractionDigits = t.length - n - 1), e;
  },
  stringify: ll
}, g2 = (t) => typeof t == "bigint" || Number.isInteger(t), y5 = (t, e, n, { intAsBigInt: r }) => r ? BigInt(t) : parseInt(t.substring(e), n);
function lB(t, e, n) {
  const { value: r } = t;
  return g2(r) && r >= 0 ? n + r.toString(e) : ll(t);
}
const aB = {
  identify: (t) => g2(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (t, e, n) => y5(t, 2, 8, n),
  stringify: (t) => lB(t, 8, "0o")
}, uB = {
  identify: g2,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (t, e, n) => y5(t, 0, 10, n),
  stringify: ll
}, cB = {
  identify: (t) => g2(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (t, e, n) => y5(t, 2, 16, n),
  stringify: (t) => lB(t, 16, "0x")
}, hde = [
  l0,
  a0,
  d2,
  p2,
  m5,
  aB,
  uB,
  cB,
  iB,
  sB,
  oB
];
function X7(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}
const oy = ({ value: t }) => JSON.stringify(t), dde = [
  {
    identify: (t) => typeof t == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (t) => t,
    stringify: oy
  },
  {
    identify: (t) => t == null,
    createNode: () => new vt(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: oy
  },
  {
    identify: (t) => typeof t == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (t) => t === "true",
    stringify: oy
  },
  {
    identify: X7,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (t, e, { intAsBigInt: n }) => n ? BigInt(t) : parseInt(t, 10),
    stringify: ({ value: t }) => X7(t) ? t.toString() : JSON.stringify(t)
  },
  {
    identify: (t) => typeof t == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (t) => parseFloat(t),
    stringify: oy
  }
], pde = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(t, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(t)}`), t;
  }
}, gde = [l0, a0].concat(dde, pde), b5 = {
  identify: (t) => t instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(t, e) {
    if (typeof atob == "function") {
      const n = atob(t.replace(/[\n\r]/g, "")), r = new Uint8Array(n.length);
      for (let i = 0; i < n.length; ++i)
        r[i] = n.charCodeAt(i);
      return r;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), t;
  },
  stringify({ comment: t, type: e, value: n }, r, i, s) {
    if (!n)
      return "";
    const o = n;
    let l;
    if (typeof btoa == "function") {
      let a = "";
      for (let u = 0; u < o.length; ++u)
        a += String.fromCharCode(o[u]);
      l = btoa(a);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e ?? (e = vt.BLOCK_LITERAL), e !== vt.QUOTE_DOUBLE) {
      const a = Math.max(r.options.lineWidth - r.indent.length, r.options.minContentWidth), u = Math.ceil(l.length / a), c = new Array(u);
      for (let f = 0, d = 0; f < u; ++f, d += a)
        c[f] = l.substr(d, a);
      l = c.join(e === vt.BLOCK_LITERAL ? `
` : " ");
    }
    return fm({ comment: t, type: e, value: l }, r, i, s);
  }
};
function fB(t, e) {
  if (o0(t))
    for (let n = 0; n < t.items.length; ++n) {
      let r = t.items[n];
      if (!Gn(r)) {
        if (s0(r)) {
          r.items.length > 1 && e("Each pair must have its own sequence indicator");
          const i = r.items[0] || new fi(new vt(null));
          if (r.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${r.commentBefore}
${i.key.commentBefore}` : r.commentBefore), r.comment) {
            const s = i.value ?? i.key;
            s.comment = s.comment ? `${r.comment}
${s.comment}` : r.comment;
          }
          r = i;
        }
        t.items[n] = Gn(r) ? r : new fi(r);
      }
    }
  else
    e("Expected a sequence for this tag");
  return t;
}
function hB(t, e, n) {
  const { replacer: r } = n, i = new cc(t);
  i.tag = "tag:yaml.org,2002:pairs";
  let s = 0;
  if (e && Symbol.iterator in Object(e))
    for (let o of e) {
      typeof r == "function" && (o = r.call(e, String(s++), o));
      let l, a;
      if (Array.isArray(o))
        if (o.length === 2)
          l = o[0], a = o[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${o}`);
      else if (o && o instanceof Object) {
        const u = Object.keys(o);
        if (u.length === 1)
          l = u[0], a = o[l];
        else
          throw new TypeError(`Expected tuple with one key, not ${u.length} keys`);
      } else
        l = o;
      i.items.push(g5(l, a, n));
    }
  return i;
}
const v5 = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: fB,
  createNode: hB
};
class ed extends cc {
  constructor() {
    super(), this.add = Is.prototype.add.bind(this), this.delete = Is.prototype.delete.bind(this), this.get = Is.prototype.get.bind(this), this.has = Is.prototype.has.bind(this), this.set = Is.prototype.set.bind(this), this.tag = ed.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, n) {
    if (!n)
      return super.toJSON(e);
    const r = /* @__PURE__ */ new Map();
    n?.onCreate && n.onCreate(r);
    for (const i of this.items) {
      let s, o;
      if (Gn(i) ? (s = vo(i.key, "", n), o = vo(i.value, s, n)) : s = vo(i, "", n), r.has(s))
        throw new Error("Ordered maps must not include duplicate keys");
      r.set(s, o);
    }
    return r;
  }
  static from(e, n, r) {
    const i = hB(e, n, r), s = new this();
    return s.items = i.items, s;
  }
}
ed.tag = "tag:yaml.org,2002:omap";
const x5 = {
  collection: "seq",
  identify: (t) => t instanceof Map,
  nodeClass: ed,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(t, e) {
    const n = fB(t, e), r = [];
    for (const { key: i } of n.items)
      Fn(i) && (r.includes(i.value) ? e(`Ordered maps must not include duplicate keys: ${i.value}`) : r.push(i.value));
    return Object.assign(new ed(), n);
  },
  createNode: (t, e, n) => ed.from(t, e, n)
};
function dB({ value: t, source: e }, n) {
  return e && (t ? pB : gB).test.test(e) ? e : t ? n.options.trueStr : n.options.falseStr;
}
const pB = {
  identify: (t) => t === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new vt(!0),
  stringify: dB
}, gB = {
  identify: (t) => t === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new vt(!1),
  stringify: dB
}, mde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: ll
}, yde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t.replace(/_/g, "")),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : ll(t);
  }
}, bde = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(t) {
    const e = new vt(parseFloat(t.replace(/_/g, ""))), n = t.indexOf(".");
    if (n !== -1) {
      const r = t.substring(n + 1).replace(/_/g, "");
      r[r.length - 1] === "0" && (e.minFractionDigits = r.length);
    }
    return e;
  },
  stringify: ll
}, hm = (t) => typeof t == "bigint" || Number.isInteger(t);
function m2(t, e, n, { intAsBigInt: r }) {
  const i = t[0];
  if ((i === "-" || i === "+") && (e += 1), t = t.substring(e).replace(/_/g, ""), r) {
    switch (n) {
      case 2:
        t = `0b${t}`;
        break;
      case 8:
        t = `0o${t}`;
        break;
      case 16:
        t = `0x${t}`;
        break;
    }
    const o = BigInt(t);
    return i === "-" ? BigInt(-1) * o : o;
  }
  const s = parseInt(t, n);
  return i === "-" ? -1 * s : s;
}
function w5(t, e, n) {
  const { value: r } = t;
  if (hm(r)) {
    const i = r.toString(e);
    return r < 0 ? "-" + n + i.substr(1) : n + i;
  }
  return ll(t);
}
const vde = {
  identify: hm,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (t, e, n) => m2(t, 2, 2, n),
  stringify: (t) => w5(t, 2, "0b")
}, xde = {
  identify: hm,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (t, e, n) => m2(t, 1, 8, n),
  stringify: (t) => w5(t, 8, "0")
}, wde = {
  identify: hm,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (t, e, n) => m2(t, 0, 10, n),
  stringify: ll
}, _de = {
  identify: hm,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (t, e, n) => m2(t, 2, 16, n),
  stringify: (t) => w5(t, 16, "0x")
};
class td extends Is {
  constructor(e) {
    super(e), this.tag = td.tag;
  }
  add(e) {
    let n;
    Gn(e) ? n = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? n = new fi(e.key, null) : n = new fi(e, null), Kc(this.items, n.key) || this.items.push(n);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, n) {
    const r = Kc(this.items, e);
    return !n && Gn(r) ? Fn(r.key) ? r.key.value : r.key : r;
  }
  set(e, n) {
    if (typeof n != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof n}`);
    const r = Kc(this.items, e);
    r && !n ? this.items.splice(this.items.indexOf(r), 1) : !r && n && this.items.push(new fi(e));
  }
  toJSON(e, n) {
    return super.toJSON(e, n, Set);
  }
  toString(e, n, r) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), n, r);
    throw new Error("Set items must all have null values");
  }
  static from(e, n, r) {
    const { replacer: i } = r, s = new this(e);
    if (n && Symbol.iterator in Object(n))
      for (let o of n)
        typeof i == "function" && (o = i.call(n, o, o)), s.items.push(g5(o, null, r));
    return s;
  }
}
td.tag = "tag:yaml.org,2002:set";
const _5 = {
  collection: "map",
  identify: (t) => t instanceof Set,
  nodeClass: td,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (t, e, n) => td.from(t, e, n),
  resolve(t, e) {
    if (s0(t)) {
      if (t.hasAllNullValues(!0))
        return Object.assign(new td(), t);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return t;
  }
};
function k5(t, e) {
  const n = t[0], r = n === "-" || n === "+" ? t.substring(1) : t, i = (o) => e ? BigInt(o) : Number(o), s = r.replace(/_/g, "").split(":").reduce((o, l) => o * i(60) + i(l), i(0));
  return n === "-" ? i(-1) * s : s;
}
function mB(t) {
  let { value: e } = t, n = (o) => o;
  if (typeof e == "bigint")
    n = (o) => BigInt(o);
  else if (isNaN(e) || !isFinite(e))
    return ll(t);
  let r = "";
  e < 0 && (r = "-", e *= n(-1));
  const i = n(60), s = [e % i];
  return e < 60 ? s.unshift(0) : (e = (e - s[0]) / i, s.unshift(e % i), e >= 60 && (e = (e - s[0]) / i, s.unshift(e))), r + s.map((o) => String(o).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const yB = {
  identify: (t) => typeof t == "bigint" || Number.isInteger(t),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (t, e, { intAsBigInt: n }) => k5(t, n),
  stringify: mB
}, bB = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (t) => k5(t, !1),
  stringify: mB
}, y2 = {
  identify: (t) => t instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(t) {
    const e = t.match(y2.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, n, r, i, s, o, l] = e.map(Number), a = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let u = Date.UTC(n, r - 1, i, s || 0, o || 0, l || 0, a);
    const c = e[8];
    if (c && c !== "Z") {
      let f = k5(c, !1);
      Math.abs(f) < 30 && (f *= 60), u -= 6e4 * f;
    }
    return new Date(u);
  },
  stringify: ({ value: t }) => t?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
}, Q7 = [
  l0,
  a0,
  d2,
  p2,
  pB,
  gB,
  vde,
  xde,
  wde,
  _de,
  mde,
  yde,
  bde,
  b5,
  Wa,
  x5,
  v5,
  _5,
  yB,
  bB,
  y2
], J7 = /* @__PURE__ */ new Map([
  ["core", hde],
  ["failsafe", [l0, a0, d2]],
  ["json", gde],
  ["yaml11", Q7],
  ["yaml-1.1", Q7]
]), Z7 = {
  binary: b5,
  bool: m5,
  float: oB,
  floatExp: sB,
  floatNaN: iB,
  floatTime: bB,
  int: uB,
  intHex: cB,
  intOct: aB,
  intTime: yB,
  map: l0,
  merge: Wa,
  null: p2,
  omap: x5,
  pairs: v5,
  seq: a0,
  set: _5,
  timestamp: y2
}, kde = {
  "tag:yaml.org,2002:binary": b5,
  "tag:yaml.org,2002:merge": Wa,
  "tag:yaml.org,2002:omap": x5,
  "tag:yaml.org,2002:pairs": v5,
  "tag:yaml.org,2002:set": _5,
  "tag:yaml.org,2002:timestamp": y2
};
function k3(t, e, n) {
  const r = J7.get(e);
  if (r && !t)
    return n && !r.includes(Wa) ? r.concat(Wa) : r.slice();
  let i = r;
  if (!i)
    if (Array.isArray(t))
      i = [];
    else {
      const s = Array.from(J7.keys()).filter((o) => o !== "yaml11").map((o) => JSON.stringify(o)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${s} or define customTags array`);
    }
  if (Array.isArray(t))
    for (const s of t)
      i = i.concat(s);
  else typeof t == "function" && (i = t(i.slice()));
  return n && (i = i.concat(Wa)), i.reduce((s, o) => {
    const l = typeof o == "string" ? Z7[o] : o;
    if (!l) {
      const a = JSON.stringify(o), u = Object.keys(Z7).map((c) => JSON.stringify(c)).join(", ");
      throw new Error(`Unknown custom tag ${a}; use one of ${u}`);
    }
    return s.includes(l) || s.push(l), s;
  }, []);
}
const Cde = (t, e) => t.key < e.key ? -1 : t.key > e.key ? 1 : 0;
class b2 {
  constructor({ compat: e, customTags: n, merge: r, resolveKnownTags: i, schema: s, sortMapEntries: o, toStringDefaults: l }) {
    this.compat = Array.isArray(e) ? k3(e, "compat") : e ? k3(null, e) : null, this.name = typeof s == "string" && s || "core", this.knownTags = i ? kde : {}, this.tags = k3(n, this.name, r), this.toStringOptions = l ?? null, Object.defineProperty(this, Gu, { value: l0 }), Object.defineProperty(this, Ql, { value: d2 }), Object.defineProperty(this, i0, { value: a0 }), this.sortMapEntries = typeof o == "function" ? o : o === !0 ? Cde : null;
  }
  clone() {
    const e = Object.create(b2.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
}
function Sde(t, e) {
  const n = [];
  let r = e.directives === !0;
  if (e.directives !== !1 && t.directives) {
    const a = t.directives.toString(t);
    a ? (n.push(a), r = !0) : t.directives.docStart && (r = !0);
  }
  r && n.push("---");
  const i = ZN(t, e), { commentString: s } = i.options;
  if (t.commentBefore) {
    n.length !== 1 && n.unshift("");
    const a = s(t.commentBefore);
    n.unshift($a(a, ""));
  }
  let o = !1, l = null;
  if (t.contents) {
    if (Jn(t.contents)) {
      if (t.contents.spaceBefore && r && n.push(""), t.contents.commentBefore) {
        const c = s(t.contents.commentBefore);
        n.push($a(c, ""));
      }
      i.forceBlockIndent = !!t.comment, l = t.contents.comment;
    }
    const a = l ? void 0 : () => o = !0;
    let u = Td(t.contents, i, () => l = null, a);
    l && (u += Gc(u, "", s(l))), (u[0] === "|" || u[0] === ">") && n[n.length - 1] === "---" ? n[n.length - 1] = `--- ${u}` : n.push(u);
  } else
    n.push(Td(t.contents, i));
  if (t.directives?.docEnd)
    if (t.comment) {
      const a = s(t.comment);
      a.includes(`
`) ? (n.push("..."), n.push($a(a, ""))) : n.push(`... ${a}`);
    } else
      n.push("...");
  else {
    let a = t.comment;
    a && o && (a = a.replace(/^\n+/, "")), a && ((!o || l) && n[n.length - 1] !== "" && n.push(""), n.push($a(s(a), "")));
  }
  return n.join(`
`) + `
`;
}
class u0 {
  constructor(e, n, r) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, _o, { value: X4 });
    let i = null;
    typeof n == "function" || Array.isArray(n) ? i = n : r === void 0 && n && (r = n, n = void 0);
    const s = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      stringKeys: !1,
      uniqueKeys: !0,
      version: "1.2"
    }, r);
    this.options = s;
    let { version: o } = s;
    r?._directives ? (this.directives = r._directives.atDocument(), this.directives.yaml.explicit && (o = this.directives.yaml.version)) : this.directives = new Ai({ version: o }), this.setSchema(o, r), this.contents = e === void 0 ? null : this.createNode(e, i, r);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(u0.prototype, {
      [_o]: { value: X4 }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = Jn(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    vh(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, n) {
    vh(this.contents) && this.contents.addIn(e, n);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, n) {
    if (!e.anchor) {
      const r = KN(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !n || r.has(n) ? YN(n || "a", r) : n;
    }
    return new u2(e.anchor);
  }
  createNode(e, n, r) {
    let i;
    if (typeof n == "function")
      e = n.call({ "": e }, "", e), i = n;
    else if (Array.isArray(n)) {
      const b = (_) => typeof _ == "number" || _ instanceof String || _ instanceof Number, v = n.filter(b).map(String);
      v.length > 0 && (n = n.concat(v)), i = n;
    } else r === void 0 && n && (r = n, n = void 0);
    const { aliasDuplicateObjects: s, anchorPrefix: o, flow: l, keepUndefined: a, onTagObj: u, tag: c } = r ?? {}, { onAnchor: f, setAnchors: d, sourceObjects: p } = Zhe(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      o || "a"
    ), m = {
      aliasDuplicateObjects: s ?? !0,
      keepUndefined: a ?? !1,
      onAnchor: f,
      onTagObj: u,
      replacer: i,
      schema: this.schema,
      sourceObjects: p
    }, y = Sg(e, c, m);
    return l && Qn(y) && (y.flow = !0), d(), y;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, n, r = {}) {
    const i = this.createNode(e, null, r), s = this.createNode(n, null, r);
    return new fi(i, s);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return vh(this.contents) ? this.contents.delete(e) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return bp(e) ? this.contents == null ? !1 : (this.contents = null, !0) : vh(this.contents) ? this.contents.deleteIn(e) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, n) {
    return Qn(this.contents) ? this.contents.get(e, n) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, n) {
    return bp(e) ? !n && Fn(this.contents) ? this.contents.value : this.contents : Qn(this.contents) ? this.contents.getIn(e, n) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return Qn(this.contents) ? this.contents.has(e) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return bp(e) ? this.contents !== void 0 : Qn(this.contents) ? this.contents.hasIn(e) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, n) {
    this.contents == null ? this.contents = tv(this.schema, [e], n) : vh(this.contents) && this.contents.set(e, n);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, n) {
    bp(e) ? this.contents = n : this.contents == null ? this.contents = tv(this.schema, Array.from(e), n) : vh(this.contents) && this.contents.setIn(e, n);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, n = {}) {
    typeof e == "number" && (e = String(e));
    let r;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Ai({ version: "1.1" }), r = { resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Ai({ version: e }), r = { resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, r = null;
        break;
      default: {
        const i = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (n.schema instanceof Object)
      this.schema = n.schema;
    else if (r)
      this.schema = new b2(Object.assign(r, n));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: n, mapAsMap: r, maxAliasCount: i, onAnchor: s, reviver: o } = {}) {
    const l = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: r === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof i == "number" ? i : 100
    }, a = vo(this.contents, n ?? "", l);
    if (typeof s == "function")
      for (const { count: u, res: c } of l.anchors.values())
        s(c, u);
    return typeof o == "function" ? Nh(o, { "": a }, "", a) : a;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, n) {
    return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: n });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const n = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${n}`);
    }
    return Sde(this, e);
  }
}
function vh(t) {
  if (Qn(t))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class C5 extends Error {
  constructor(e, n, r, i) {
    super(), this.name = e, this.code = r, this.message = i, this.pos = n;
  }
}
class Yc extends C5 {
  constructor(e, n, r) {
    super("YAMLParseError", e, n, r);
  }
}
class vB extends C5 {
  constructor(e, n, r) {
    super("YAMLWarning", e, n, r);
  }
}
const rv = (t, e) => (n) => {
  if (n.pos[0] === -1)
    return;
  n.linePos = n.pos.map((l) => e.linePos(l));
  const { line: r, col: i } = n.linePos[0];
  n.message += ` at line ${r}, column ${i}`;
  let s = i - 1, o = t.substring(e.lineStarts[r - 1], e.lineStarts[r]).replace(/[\n\r]+$/, "");
  if (s >= 60 && o.length > 80) {
    const l = Math.min(s - 39, o.length - 79);
    o = "â€¦" + o.substring(l), s -= l - 1;
  }
  if (o.length > 80 && (o = o.substring(0, 79) + "â€¦"), r > 1 && /^ *$/.test(o.substring(0, s))) {
    let l = t.substring(e.lineStarts[r - 2], e.lineStarts[r - 1]);
    l.length > 80 && (l = l.substring(0, 79) + `â€¦
`), o = l + o;
  }
  if (/[^ ]/.test(o)) {
    let l = 1;
    const a = n.linePos[1];
    a && a.line === r && a.col > i && (l = Math.max(1, Math.min(a.col - i, 80 - s)));
    const u = " ".repeat(s) + "^".repeat(l);
    n.message += `:

${o}
${u}
`;
  }
};
function Rd(t, { flow: e, indicator: n, next: r, offset: i, onError: s, parentIndent: o, startOnNewline: l }) {
  let a = !1, u = l, c = l, f = "", d = "", p = !1, m = !1, y = null, b = null, v = null, _ = null, k = null, S = null, C = null;
  for (const O of t)
    switch (m && (O.type !== "space" && O.type !== "newline" && O.type !== "comma" && s(O.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), m = !1), y && (u && O.type !== "comment" && O.type !== "newline" && s(y, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), y = null), O.type) {
      case "space":
        !e && (n !== "doc-start" || r?.type !== "flow-collection") && O.source.includes("	") && (y = O), c = !0;
        break;
      case "comment": {
        c || s(O, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const T = O.source.substring(1) || " ";
        f ? f += d + T : f = T, d = "", u = !1;
        break;
      }
      case "newline":
        u ? f ? f += O.source : (!S || n !== "seq-item-ind") && (a = !0) : d += O.source, u = !0, p = !0, (b || v) && (_ = O), c = !0;
        break;
      case "anchor":
        b && s(O, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), O.source.endsWith(":") && s(O.offset + O.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), b = O, C ?? (C = O.offset), u = !1, c = !1, m = !0;
        break;
      case "tag": {
        v && s(O, "MULTIPLE_TAGS", "A node can have at most one tag"), v = O, C ?? (C = O.offset), u = !1, c = !1, m = !0;
        break;
      }
      case n:
        (b || v) && s(O, "BAD_PROP_ORDER", `Anchors and tags must be after the ${O.source} indicator`), S && s(O, "UNEXPECTED_TOKEN", `Unexpected ${O.source} in ${e ?? "collection"}`), S = O, u = n === "seq-item-ind" || n === "explicit-key-ind", c = !1;
        break;
      case "comma":
        if (e) {
          k && s(O, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), k = O, u = !1, c = !1;
          break;
        }
      // else fallthrough
      default:
        s(O, "UNEXPECTED_TOKEN", `Unexpected ${O.type} token`), u = !1, c = !1;
    }
  const E = t[t.length - 1], A = E ? E.offset + E.source.length : i;
  return m && r && r.type !== "space" && r.type !== "newline" && r.type !== "comma" && (r.type !== "scalar" || r.source !== "") && s(r.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), y && (u && y.indent <= o || r?.type === "block-map" || r?.type === "block-seq") && s(y, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: k,
    found: S,
    spaceBefore: a,
    comment: f,
    hasNewline: p,
    anchor: b,
    tag: v,
    newlineAfterProp: _,
    end: A,
    start: C ?? A
  };
}
function Ag(t) {
  if (!t)
    return null;
  switch (t.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (t.source.includes(`
`))
        return !0;
      if (t.end) {
        for (const e of t.end)
          if (e.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const e of t.items) {
        for (const n of e.start)
          if (n.type === "newline")
            return !0;
        if (e.sep) {
          for (const n of e.sep)
            if (n.type === "newline")
              return !0;
        }
        if (Ag(e.key) || Ag(e.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function ek(t, e, n) {
  if (e?.type === "flow-collection") {
    const r = e.end[0];
    r.indent === t && (r.source === "]" || r.source === "}") && Ag(e) && n(r, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function xB(t, e, n) {
  const { uniqueKeys: r } = t.options;
  if (r === !1)
    return !1;
  const i = typeof r == "function" ? r : (s, o) => s === o || Fn(s) && Fn(o) && s.value === o.value;
  return e.some((s) => i(s.key, n));
}
const e9 = "All mapping items must start at the same column";
function Ade({ composeNode: t, composeEmptyNode: e }, n, r, i, s) {
  const o = s?.nodeClass ?? Is, l = new o(n.schema);
  n.atRoot && (n.atRoot = !1);
  let a = r.offset, u = null;
  for (const c of r.items) {
    const { start: f, key: d, sep: p, value: m } = c, y = Rd(f, {
      indicator: "explicit-key-ind",
      next: d ?? p?.[0],
      offset: a,
      onError: i,
      parentIndent: r.indent,
      startOnNewline: !0
    }), b = !y.found;
    if (b) {
      if (d && (d.type === "block-seq" ? i(a, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in d && d.indent !== r.indent && i(a, "BAD_INDENT", e9)), !y.anchor && !y.tag && !p) {
        u = y.end, y.comment && (l.comment ? l.comment += `
` + y.comment : l.comment = y.comment);
        continue;
      }
      (y.newlineAfterProp || Ag(d)) && i(d ?? f[f.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else y.found?.indent !== r.indent && i(a, "BAD_INDENT", e9);
    n.atKey = !0;
    const v = y.end, _ = d ? t(n, d, y, i) : e(n, v, f, null, y, i);
    n.schema.compat && ek(r.indent, d, i), n.atKey = !1, xB(n, l.items, _) && i(v, "DUPLICATE_KEY", "Map keys must be unique");
    const k = Rd(p ?? [], {
      indicator: "map-value-ind",
      next: m,
      offset: _.range[2],
      onError: i,
      parentIndent: r.indent,
      startOnNewline: !d || d.type === "block-scalar"
    });
    if (a = k.end, k.found) {
      b && (m?.type === "block-map" && !k.hasNewline && i(a, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), n.options.strict && y.start < k.found.offset - 1024 && i(_.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const S = m ? t(n, m, k, i) : e(n, a, p, null, k, i);
      n.schema.compat && ek(r.indent, m, i), a = S.range[2];
      const C = new fi(_, S);
      n.options.keepSourceTokens && (C.srcToken = c), l.items.push(C);
    } else {
      b && i(_.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), k.comment && (_.comment ? _.comment += `
` + k.comment : _.comment = k.comment);
      const S = new fi(_);
      n.options.keepSourceTokens && (S.srcToken = c), l.items.push(S);
    }
  }
  return u && u < a && i(u, "IMPOSSIBLE", "Map comment with trailing content"), l.range = [r.offset, a, u ?? a], l;
}
function Ede({ composeNode: t, composeEmptyNode: e }, n, r, i, s) {
  const o = s?.nodeClass ?? cc, l = new o(n.schema);
  n.atRoot && (n.atRoot = !1), n.atKey && (n.atKey = !1);
  let a = r.offset, u = null;
  for (const { start: c, value: f } of r.items) {
    const d = Rd(c, {
      indicator: "seq-item-ind",
      next: f,
      offset: a,
      onError: i,
      parentIndent: r.indent,
      startOnNewline: !0
    });
    if (!d.found)
      if (d.anchor || d.tag || f)
        f && f.type === "block-seq" ? i(d.end, "BAD_INDENT", "All sequence items must start at the same column") : i(a, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        u = d.end, d.comment && (l.comment = d.comment);
        continue;
      }
    const p = f ? t(n, f, d, i) : e(n, d.end, c, null, d, i);
    n.schema.compat && ek(r.indent, f, i), a = p.range[2], l.items.push(p);
  }
  return l.range = [r.offset, a, u ?? a], l;
}
function dm(t, e, n, r) {
  let i = "";
  if (t) {
    let s = !1, o = "";
    for (const l of t) {
      const { source: a, type: u } = l;
      switch (u) {
        case "space":
          s = !0;
          break;
        case "comment": {
          n && !s && r(l, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const c = a.substring(1) || " ";
          i ? i += o + c : i = c, o = "";
          break;
        }
        case "newline":
          i && (o += a), s = !0;
          break;
        default:
          r(l, "UNEXPECTED_TOKEN", `Unexpected ${u} at node end`);
      }
      e += a.length;
    }
  }
  return { comment: i, offset: e };
}
const C3 = "Block collections are not allowed within flow collections", S3 = (t) => t && (t.type === "block-map" || t.type === "block-seq");
function Dde({ composeNode: t, composeEmptyNode: e }, n, r, i, s) {
  const o = r.start.source === "{", l = o ? "flow map" : "flow sequence", a = s?.nodeClass ?? (o ? Is : cc), u = new a(n.schema);
  u.flow = !0;
  const c = n.atRoot;
  c && (n.atRoot = !1), n.atKey && (n.atKey = !1);
  let f = r.offset + r.start.source.length;
  for (let b = 0; b < r.items.length; ++b) {
    const v = r.items[b], { start: _, key: k, sep: S, value: C } = v, E = Rd(_, {
      flow: l,
      indicator: "explicit-key-ind",
      next: k ?? S?.[0],
      offset: f,
      onError: i,
      parentIndent: r.indent,
      startOnNewline: !1
    });
    if (!E.found) {
      if (!E.anchor && !E.tag && !S && !C) {
        b === 0 && E.comma ? i(E.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${l}`) : b < r.items.length - 1 && i(E.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${l}`), E.comment && (u.comment ? u.comment += `
` + E.comment : u.comment = E.comment), f = E.end;
        continue;
      }
      !o && n.options.strict && Ag(k) && i(
        k,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (b === 0)
      E.comma && i(E.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${l}`);
    else if (E.comma || i(E.start, "MISSING_CHAR", `Missing , between ${l} items`), E.comment) {
      let A = "";
      e: for (const O of _)
        switch (O.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            A = O.source.substring(1);
            break e;
          default:
            break e;
        }
      if (A) {
        let O = u.items[u.items.length - 1];
        Gn(O) && (O = O.value ?? O.key), O.comment ? O.comment += `
` + A : O.comment = A, E.comment = E.comment.substring(A.length + 1);
      }
    }
    if (!o && !S && !E.found) {
      const A = C ? t(n, C, E, i) : e(n, E.end, S, null, E, i);
      u.items.push(A), f = A.range[2], S3(C) && i(A.range, "BLOCK_IN_FLOW", C3);
    } else {
      n.atKey = !0;
      const A = E.end, O = k ? t(n, k, E, i) : e(n, A, _, null, E, i);
      S3(k) && i(O.range, "BLOCK_IN_FLOW", C3), n.atKey = !1;
      const T = Rd(S ?? [], {
        flow: l,
        indicator: "map-value-ind",
        next: C,
        offset: O.range[2],
        onError: i,
        parentIndent: r.indent,
        startOnNewline: !1
      });
      if (T.found) {
        if (!o && !E.found && n.options.strict) {
          if (S)
            for (const B of S) {
              if (B === T.found)
                break;
              if (B.type === "newline") {
                i(B, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          E.start < T.found.offset - 1024 && i(T.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else C && ("source" in C && C.source && C.source[0] === ":" ? i(C, "MISSING_CHAR", `Missing space after : in ${l}`) : i(T.start, "MISSING_CHAR", `Missing , or : between ${l} items`));
      const $ = C ? t(n, C, T, i) : T.found ? e(n, T.end, S, null, T, i) : null;
      $ ? S3(C) && i($.range, "BLOCK_IN_FLOW", C3) : T.comment && (O.comment ? O.comment += `
` + T.comment : O.comment = T.comment);
      const P = new fi(O, $);
      if (n.options.keepSourceTokens && (P.srcToken = v), o) {
        const B = u;
        xB(n, B.items, O) && i(A, "DUPLICATE_KEY", "Map keys must be unique"), B.items.push(P);
      } else {
        const B = new Is(n.schema);
        B.flow = !0, B.items.push(P);
        const M = ($ ?? O).range;
        B.range = [O.range[0], M[1], M[2]], u.items.push(B);
      }
      f = $ ? $.range[2] : T.end;
    }
  }
  const d = o ? "}" : "]", [p, ...m] = r.end;
  let y = f;
  if (p && p.source === d)
    y = p.offset + p.source.length;
  else {
    const b = l[0].toUpperCase() + l.substring(1), v = c ? `${b} must end with a ${d}` : `${b} in block collection must be sufficiently indented and end with a ${d}`;
    i(f, c ? "MISSING_CHAR" : "BAD_INDENT", v), p && p.source.length !== 1 && m.unshift(p);
  }
  if (m.length > 0) {
    const b = dm(m, y, n.options.strict, i);
    b.comment && (u.comment ? u.comment += `
` + b.comment : u.comment = b.comment), u.range = [r.offset, y, b.offset];
  } else
    u.range = [r.offset, y, y];
  return u;
}
function A3(t, e, n, r, i, s) {
  const o = n.type === "block-map" ? Ade(t, e, n, r, s) : n.type === "block-seq" ? Ede(t, e, n, r, s) : Dde(t, e, n, r, s), l = o.constructor;
  return i === "!" || i === l.tagName ? (o.tag = l.tagName, o) : (i && (o.tag = i), o);
}
function Ode(t, e, n, r, i) {
  const s = r.tag, o = s ? e.directives.tagName(s.source, (d) => i(s, "TAG_RESOLVE_FAILED", d)) : null;
  if (n.type === "block-seq") {
    const { anchor: d, newlineAfterProp: p } = r, m = d && s ? d.offset > s.offset ? d : s : d ?? s;
    m && (!p || p.offset < m.offset) && i(m, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const l = n.type === "block-map" ? "map" : n.type === "block-seq" ? "seq" : n.start.source === "{" ? "map" : "seq";
  if (!s || !o || o === "!" || o === Is.tagName && l === "map" || o === cc.tagName && l === "seq")
    return A3(t, e, n, i, o);
  let a = e.schema.tags.find((d) => d.tag === o && d.collection === l);
  if (!a) {
    const d = e.schema.knownTags[o];
    if (d && d.collection === l)
      e.schema.tags.push(Object.assign({}, d, { default: !1 })), a = d;
    else
      return d ? i(s, "BAD_COLLECTION_TYPE", `${d.tag} used for ${l} collection, but expects ${d.collection ?? "scalar"}`, !0) : i(s, "TAG_RESOLVE_FAILED", `Unresolved tag: ${o}`, !0), A3(t, e, n, i, o);
  }
  const u = A3(t, e, n, i, o, a), c = a.resolve?.(u, (d) => i(s, "TAG_RESOLVE_FAILED", d), e.options) ?? u, f = Jn(c) ? c : new vt(c);
  return f.range = u.range, f.tag = o, a?.format && (f.format = a.format), f;
}
function wB(t, e, n) {
  const r = e.offset, i = Fde(e, t.options.strict, n);
  if (!i)
    return { value: "", type: null, comment: "", range: [r, r, r] };
  const s = i.mode === ">" ? vt.BLOCK_FOLDED : vt.BLOCK_LITERAL, o = e.source ? Tde(e.source) : [];
  let l = o.length;
  for (let y = o.length - 1; y >= 0; --y) {
    const b = o[y][1];
    if (b === "" || b === "\r")
      l = y;
    else
      break;
  }
  if (l === 0) {
    const y = i.chomp === "+" && o.length > 0 ? `
`.repeat(Math.max(1, o.length - 1)) : "";
    let b = r + i.length;
    return e.source && (b += e.source.length), { value: y, type: s, comment: i.comment, range: [r, b, b] };
  }
  let a = e.indent + i.indent, u = e.offset + i.length, c = 0;
  for (let y = 0; y < l; ++y) {
    const [b, v] = o[y];
    if (v === "" || v === "\r")
      i.indent === 0 && b.length > a && (a = b.length);
    else {
      b.length < a && n(u + b.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (a = b.length), c = y, a === 0 && !t.atRoot && n(u, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    u += b.length + v.length + 1;
  }
  for (let y = o.length - 1; y >= l; --y)
    o[y][0].length > a && (l = y + 1);
  let f = "", d = "", p = !1;
  for (let y = 0; y < c; ++y)
    f += o[y][0].slice(a) + `
`;
  for (let y = c; y < l; ++y) {
    let [b, v] = o[y];
    u += b.length + v.length + 1;
    const _ = v[v.length - 1] === "\r";
    if (_ && (v = v.slice(0, -1)), v && b.length < a) {
      const S = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      n(u - v.length - (_ ? 2 : 1), "BAD_INDENT", S), b = "";
    }
    s === vt.BLOCK_LITERAL ? (f += d + b.slice(a) + v, d = `
`) : b.length > a || v[0] === "	" ? (d === " " ? d = `
` : !p && d === `
` && (d = `

`), f += d + b.slice(a) + v, d = `
`, p = !0) : v === "" ? d === `
` ? f += `
` : d = `
` : (f += d + v, d = " ", p = !1);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let y = l; y < o.length; ++y)
        f += `
` + o[y][0].slice(a);
      f[f.length - 1] !== `
` && (f += `
`);
      break;
    default:
      f += `
`;
  }
  const m = r + i.length + e.source.length;
  return { value: f, type: s, comment: i.comment, range: [r, m, m] };
}
function Fde({ offset: t, props: e }, n, r) {
  if (e[0].type !== "block-scalar-header")
    return r(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = e[0], s = i[0];
  let o = 0, l = "", a = -1;
  for (let d = 1; d < i.length; ++d) {
    const p = i[d];
    if (!l && (p === "-" || p === "+"))
      l = p;
    else {
      const m = Number(p);
      !o && m ? o = m : a === -1 && (a = t + d);
    }
  }
  a !== -1 && r(a, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let u = !1, c = "", f = i.length;
  for (let d = 1; d < e.length; ++d) {
    const p = e[d];
    switch (p.type) {
      case "space":
        u = !0;
      // fallthrough
      case "newline":
        f += p.source.length;
        break;
      case "comment":
        n && !u && r(p, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), f += p.source.length, c = p.source.substring(1);
        break;
      case "error":
        r(p, "UNEXPECTED_TOKEN", p.message), f += p.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const m = `Unexpected token in block scalar header: ${p.type}`;
        r(p, "UNEXPECTED_TOKEN", m);
        const y = p.source;
        y && typeof y == "string" && (f += y.length);
      }
    }
  }
  return { mode: s, indent: o, chomp: l, comment: c, length: f };
}
function Tde(t) {
  const e = t.split(/\n( *)/), n = e[0], r = n.match(/^( *)/), s = [r?.[1] ? [r[1], n.slice(r[1].length)] : ["", n]];
  for (let o = 1; o < e.length; o += 2)
    s.push([e[o], e[o + 1]]);
  return s;
}
function _B(t, e, n) {
  const { offset: r, type: i, source: s, end: o } = t;
  let l, a;
  const u = (d, p, m) => n(r + d, p, m);
  switch (i) {
    case "scalar":
      l = vt.PLAIN, a = Rde(s, u);
      break;
    case "single-quoted-scalar":
      l = vt.QUOTE_SINGLE, a = Mde(s, u);
      break;
    case "double-quoted-scalar":
      l = vt.QUOTE_DOUBLE, a = Pde(s, u);
      break;
    /* istanbul ignore next should not happen */
    default:
      return n(t, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [r, r + s.length, r + s.length]
      };
  }
  const c = r + s.length, f = dm(o, c, e, n);
  return {
    value: a,
    type: l,
    comment: f.comment,
    range: [r, c, f.offset]
  };
}
function Rde(t, e) {
  let n = "";
  switch (t[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      n = "a tab character";
      break;
    case ",":
      n = "flow indicator character ,";
      break;
    case "%":
      n = "directive indicator character %";
      break;
    case "|":
    case ">": {
      n = `block scalar indicator ${t[0]}`;
      break;
    }
    case "@":
    case "`": {
      n = `reserved character ${t[0]}`;
      break;
    }
  }
  return n && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${n}`), kB(t);
}
function Mde(t, e) {
  return (t[t.length - 1] !== "'" || t.length === 1) && e(t.length, "MISSING_CHAR", "Missing closing 'quote"), kB(t.slice(1, -1)).replace(/''/g, "'");
}
function kB(t) {
  let e, n;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), n = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, n = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let r = e.exec(t);
  if (!r)
    return t;
  let i = r[1], s = " ", o = e.lastIndex;
  for (n.lastIndex = o; r = n.exec(t); )
    r[1] === "" ? s === `
` ? i += s : s = `
` : (i += s + r[1], s = " "), o = n.lastIndex;
  const l = /[ \t]*(.*)/sy;
  return l.lastIndex = o, r = l.exec(t), i + s + (r?.[1] ?? "");
}
function Pde(t, e) {
  let n = "";
  for (let r = 1; r < t.length - 1; ++r) {
    const i = t[r];
    if (!(i === "\r" && t[r + 1] === `
`))
      if (i === `
`) {
        const { fold: s, offset: o } = Ide(t, r);
        n += s, r = o;
      } else if (i === "\\") {
        let s = t[++r];
        const o = Nde[s];
        if (o)
          n += o;
        else if (s === `
`)
          for (s = t[r + 1]; s === " " || s === "	"; )
            s = t[++r + 1];
        else if (s === "\r" && t[r + 1] === `
`)
          for (s = t[++r + 1]; s === " " || s === "	"; )
            s = t[++r + 1];
        else if (s === "x" || s === "u" || s === "U") {
          const l = { x: 2, u: 4, U: 8 }[s];
          n += Bde(t, r + 1, l, e), r += l;
        } else {
          const l = t.substr(r - 1, 2);
          e(r - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${l}`), n += l;
        }
      } else if (i === " " || i === "	") {
        const s = r;
        let o = t[r + 1];
        for (; o === " " || o === "	"; )
          o = t[++r + 1];
        o !== `
` && !(o === "\r" && t[r + 2] === `
`) && (n += r > s ? t.slice(s, r + 1) : i);
      } else
        n += i;
  }
  return (t[t.length - 1] !== '"' || t.length === 1) && e(t.length, "MISSING_CHAR", 'Missing closing "quote'), n;
}
function Ide(t, e) {
  let n = "", r = t[e + 1];
  for (; (r === " " || r === "	" || r === `
` || r === "\r") && !(r === "\r" && t[e + 2] !== `
`); )
    r === `
` && (n += `
`), e += 1, r = t[e + 1];
  return n || (n = " "), { fold: n, offset: e };
}
const Nde = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "Â…",
  // Unicode next line
  _: "Â ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function Bde(t, e, n, r) {
  const i = t.substr(e, n), o = i.length === n && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(o)) {
    const l = t.substr(e - 2, n + 2);
    return r(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${l}`), l;
  }
  return String.fromCodePoint(o);
}
function CB(t, e, n, r) {
  const { value: i, type: s, comment: o, range: l } = e.type === "block-scalar" ? wB(t, e, r) : _B(e, t.options.strict, r), a = n ? t.directives.tagName(n.source, (f) => r(n, "TAG_RESOLVE_FAILED", f)) : null;
  let u;
  t.options.stringKeys && t.atKey ? u = t.schema[Ql] : a ? u = Lde(t.schema, i, a, n, r) : e.type === "scalar" ? u = $de(t, i, e, r) : u = t.schema[Ql];
  let c;
  try {
    const f = u.resolve(i, (d) => r(n ?? e, "TAG_RESOLVE_FAILED", d), t.options);
    c = Fn(f) ? f : new vt(f);
  } catch (f) {
    const d = f instanceof Error ? f.message : String(f);
    r(n ?? e, "TAG_RESOLVE_FAILED", d), c = new vt(i);
  }
  return c.range = l, c.source = i, s && (c.type = s), a && (c.tag = a), u.format && (c.format = u.format), o && (c.comment = o), c;
}
function Lde(t, e, n, r, i) {
  if (n === "!")
    return t[Ql];
  const s = [];
  for (const l of t.tags)
    if (!l.collection && l.tag === n)
      if (l.default && l.test)
        s.push(l);
      else
        return l;
  for (const l of s)
    if (l.test?.test(e))
      return l;
  const o = t.knownTags[n];
  return o && !o.collection ? (t.tags.push(Object.assign({}, o, { default: !1, test: void 0 })), o) : (i(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${n}`, n !== "tag:yaml.org,2002:str"), t[Ql]);
}
function $de({ atKey: t, directives: e, schema: n }, r, i, s) {
  const o = n.tags.find((l) => (l.default === !0 || t && l.default === "key") && l.test?.test(r)) || n[Ql];
  if (n.compat) {
    const l = n.compat.find((a) => a.default && a.test?.test(r)) ?? n[Ql];
    if (o.tag !== l.tag) {
      const a = e.tagString(o.tag), u = e.tagString(l.tag), c = `Value may be parsed as either ${a} or ${u}`;
      s(i, "TAG_RESOLVE_FAILED", c, !0);
    }
  }
  return o;
}
function zde(t, e, n) {
  if (e) {
    n ?? (n = e.length);
    for (let r = n - 1; r >= 0; --r) {
      let i = e[r];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          t -= i.source.length;
          continue;
      }
      for (i = e[++r]; i?.type === "space"; )
        t += i.source.length, i = e[++r];
      break;
    }
  }
  return t;
}
const jde = { composeNode: SB, composeEmptyNode: S5 };
function SB(t, e, n, r) {
  const i = t.atKey, { spaceBefore: s, comment: o, anchor: l, tag: a } = n;
  let u, c = !0;
  switch (e.type) {
    case "alias":
      u = qde(t, e, r), (l || a) && r(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      u = CB(t, e, a, r), l && (u.anchor = l.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      u = Ode(jde, t, e, n, r), l && (u.anchor = l.source.substring(1));
      break;
    default: {
      const f = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      r(e, "UNEXPECTED_TOKEN", f), u = S5(t, e.offset, void 0, null, n, r), c = !1;
    }
  }
  return l && u.anchor === "" && r(l, "BAD_ALIAS", "Anchor cannot be an empty string"), i && t.options.stringKeys && (!Fn(u) || typeof u.value != "string" || u.tag && u.tag !== "tag:yaml.org,2002:str") && r(a ?? e, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), s && (u.spaceBefore = !0), o && (e.type === "scalar" && e.source === "" ? u.comment = o : u.commentBefore = o), t.options.keepSourceTokens && c && (u.srcToken = e), u;
}
function S5(t, e, n, r, { spaceBefore: i, comment: s, anchor: o, tag: l, end: a }, u) {
  const c = {
    type: "scalar",
    offset: zde(e, n, r),
    indent: -1,
    source: ""
  }, f = CB(t, c, l, u);
  return o && (f.anchor = o.source.substring(1), f.anchor === "" && u(o, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (f.spaceBefore = !0), s && (f.comment = s, f.range[2] = a), f;
}
function qde({ options: t }, { offset: e, source: n, end: r }, i) {
  const s = new u2(n.substring(1));
  s.source === "" && i(e, "BAD_ALIAS", "Alias cannot be an empty string"), s.source.endsWith(":") && i(e + n.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const o = e + n.length, l = dm(r, o, t.strict, i);
  return s.range = [e, o, l.offset], l.comment && (s.comment = l.comment), s;
}
function Ude(t, e, { offset: n, start: r, value: i, end: s }, o) {
  const l = Object.assign({ _directives: e }, t), a = new u0(void 0, l), u = {
    atKey: !1,
    atRoot: !0,
    directives: a.directives,
    options: a.options,
    schema: a.schema
  }, c = Rd(r, {
    indicator: "doc-start",
    next: i ?? s?.[0],
    offset: n,
    onError: o,
    parentIndent: 0,
    startOnNewline: !0
  });
  c.found && (a.directives.docStart = !0, i && (i.type === "block-map" || i.type === "block-seq") && !c.hasNewline && o(c.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), a.contents = i ? SB(u, i, c, o) : S5(u, c.end, r, null, c, o);
  const f = a.contents.range[2], d = dm(s, f, !1, o);
  return d.comment && (a.comment = d.comment), a.range = [n, f, d.offset], a;
}
function tp(t) {
  if (typeof t == "number")
    return [t, t + 1];
  if (Array.isArray(t))
    return t.length === 2 ? t : [t[0], t[1]];
  const { offset: e, source: n } = t;
  return [e, e + (typeof n == "string" ? n.length : 1)];
}
function t9(t) {
  let e = "", n = !1, r = !1;
  for (let i = 0; i < t.length; ++i) {
    const s = t[i];
    switch (s[0]) {
      case "#":
        e += (e === "" ? "" : r ? `

` : `
`) + (s.substring(1) || " "), n = !0, r = !1;
        break;
      case "%":
        t[i + 1]?.[0] !== "#" && (i += 1), n = !1;
        break;
      default:
        n || (r = !0), n = !1;
    }
  }
  return { comment: e, afterEmptyLine: r };
}
class A5 {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (n, r, i, s) => {
      const o = tp(n);
      s ? this.warnings.push(new vB(o, r, i)) : this.errors.push(new Yc(o, r, i));
    }, this.directives = new Ai({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, n) {
    const { comment: r, afterEmptyLine: i } = t9(this.prelude);
    if (r) {
      const s = e.contents;
      if (n)
        e.comment = e.comment ? `${e.comment}
${r}` : r;
      else if (i || e.directives.docStart || !s)
        e.commentBefore = r;
      else if (Qn(s) && !s.flow && s.items.length > 0) {
        let o = s.items[0];
        Gn(o) && (o = o.key);
        const l = o.commentBefore;
        o.commentBefore = l ? `${r}
${l}` : r;
      } else {
        const o = s.commentBefore;
        s.commentBefore = o ? `${r}
${o}` : r;
      }
    }
    n ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: t9(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, n = !1, r = -1) {
    for (const i of e)
      yield* this.next(i);
    yield* this.end(n, r);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (n, r, i) => {
          const s = tp(e);
          s[0] += n, this.onError(s, "BAD_DIRECTIVE", r, i);
        }), this.prelude.push(e.source), this.atDirectives = !0;
        break;
      case "document": {
        const n = Ude(this.options, this.directives, e, this.onError);
        this.atDirectives && !n.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(n, !1), this.doc && (yield this.doc), this.doc = n, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const n = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, r = new Yc(tp(e), "UNEXPECTED_TOKEN", n);
        this.atDirectives || !this.doc ? this.errors.push(r) : this.doc.errors.push(r);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const r = "Unexpected doc-end without preceding document";
          this.errors.push(new Yc(tp(e), "UNEXPECTED_TOKEN", r));
          break;
        }
        this.doc.directives.docEnd = !0;
        const n = dm(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), n.comment) {
          const r = this.doc.comment;
          this.doc.comment = r ? `${r}
${n.comment}` : n.comment;
        }
        this.doc.range[2] = n.offset;
        break;
      }
      default:
        this.errors.push(new Yc(tp(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = !1, n = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (e) {
      const r = Object.assign({ _directives: this.directives }, this.options), i = new u0(void 0, r);
      this.atDirectives && this.onError(n, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, n, n], this.decorate(i, !1), yield i;
    }
  }
}
function Hde(t, e = !0, n) {
  if (t) {
    const r = (i, s, o) => {
      const l = typeof i == "number" ? i : Array.isArray(i) ? i[0] : i.offset;
      if (n)
        n(l, s, o);
      else
        throw new Yc([l, l + 1], s, o);
    };
    switch (t.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return _B(t, e, r);
      case "block-scalar":
        return wB({ options: { strict: e } }, t, r);
    }
  }
  return null;
}
function Vde(t, e) {
  const { implicitKey: n = !1, indent: r, inFlow: i = !1, offset: s = -1, type: o = "PLAIN" } = e, l = fm({ type: o, value: t }, {
    implicitKey: n,
    indent: r > 0 ? " ".repeat(r) : "",
    inFlow: i,
    options: { blockQuote: !0, lineWidth: -1 }
  }), a = e.end ?? [
    { type: "newline", offset: -1, indent: r, source: `
` }
  ];
  switch (l[0]) {
    case "|":
    case ">": {
      const u = l.indexOf(`
`), c = l.substring(0, u), f = l.substring(u + 1) + `
`, d = [
        { type: "block-scalar-header", offset: s, indent: r, source: c }
      ];
      return AB(d, a) || d.push({ type: "newline", offset: -1, indent: r, source: `
` }), { type: "block-scalar", offset: s, indent: r, props: d, source: f };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: s, indent: r, source: l, end: a };
    case "'":
      return { type: "single-quoted-scalar", offset: s, indent: r, source: l, end: a };
    default:
      return { type: "scalar", offset: s, indent: r, source: l, end: a };
  }
}
function Wde(t, e, n = {}) {
  let { afterKey: r = !1, implicitKey: i = !1, inFlow: s = !1, type: o } = n, l = "indent" in t ? t.indent : null;
  if (r && typeof l == "number" && (l += 2), !o)
    switch (t.type) {
      case "single-quoted-scalar":
        o = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        o = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const u = t.props[0];
        if (u.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        o = u.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        o = "PLAIN";
    }
  const a = fm({ type: o, value: e }, {
    implicitKey: i || l === null,
    indent: l !== null && l > 0 ? " ".repeat(l) : "",
    inFlow: s,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (a[0]) {
    case "|":
    case ">":
      Gde(t, a);
      break;
    case '"':
      E3(t, a, "double-quoted-scalar");
      break;
    case "'":
      E3(t, a, "single-quoted-scalar");
      break;
    default:
      E3(t, a, "scalar");
  }
}
function Gde(t, e) {
  const n = e.indexOf(`
`), r = e.substring(0, n), i = e.substring(n + 1) + `
`;
  if (t.type === "block-scalar") {
    const s = t.props[0];
    if (s.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    s.source = r, t.source = i;
  } else {
    const { offset: s } = t, o = "indent" in t ? t.indent : -1, l = [
      { type: "block-scalar-header", offset: s, indent: o, source: r }
    ];
    AB(l, "end" in t ? t.end : void 0) || l.push({ type: "newline", offset: -1, indent: o, source: `
` });
    for (const a of Object.keys(t))
      a !== "type" && a !== "offset" && delete t[a];
    Object.assign(t, { type: "block-scalar", indent: o, props: l, source: i });
  }
}
function AB(t, e) {
  if (e)
    for (const n of e)
      switch (n.type) {
        case "space":
        case "comment":
          t.push(n);
          break;
        case "newline":
          return t.push(n), !0;
      }
  return !1;
}
function E3(t, e, n) {
  switch (t.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      t.type = n, t.source = e;
      break;
    case "block-scalar": {
      const r = t.props.slice(1);
      let i = e.length;
      t.props[0].type === "block-scalar-header" && (i -= t.props[0].source.length);
      for (const s of r)
        s.offset += i;
      delete t.props, Object.assign(t, { type: n, source: e, end: r });
      break;
    }
    case "block-map":
    case "block-seq": {
      const i = { type: "newline", offset: t.offset + e.length, indent: t.indent, source: `
` };
      delete t.items, Object.assign(t, { type: n, source: e, end: [i] });
      break;
    }
    default: {
      const r = "indent" in t ? t.indent : -1, i = "end" in t && Array.isArray(t.end) ? t.end.filter((s) => s.type === "space" || s.type === "comment" || s.type === "newline") : [];
      for (const s of Object.keys(t))
        s !== "type" && s !== "offset" && delete t[s];
      Object.assign(t, { type: n, indent: r, source: e, end: i });
    }
  }
}
const Kde = (t) => "type" in t ? iv(t) : Qy(t);
function iv(t) {
  switch (t.type) {
    case "block-scalar": {
      let e = "";
      for (const n of t.props)
        e += iv(n);
      return e + t.source;
    }
    case "block-map":
    case "block-seq": {
      let e = "";
      for (const n of t.items)
        e += Qy(n);
      return e;
    }
    case "flow-collection": {
      let e = t.start.source;
      for (const n of t.items)
        e += Qy(n);
      for (const n of t.end)
        e += n.source;
      return e;
    }
    case "document": {
      let e = Qy(t);
      if (t.end)
        for (const n of t.end)
          e += n.source;
      return e;
    }
    default: {
      let e = t.source;
      if ("end" in t && t.end)
        for (const n of t.end)
          e += n.source;
      return e;
    }
  }
}
function Qy({ start: t, key: e, sep: n, value: r }) {
  let i = "";
  for (const s of t)
    i += s.source;
  if (e && (i += iv(e)), n)
    for (const s of n)
      i += s.source;
  return r && (i += iv(r)), i;
}
const tk = Symbol("break visit"), Yde = Symbol("skip children"), EB = Symbol("remove item");
function Sf(t, e) {
  "type" in t && t.type === "document" && (t = { start: t.start, value: t.value }), DB(Object.freeze([]), t, e);
}
Sf.BREAK = tk;
Sf.SKIP = Yde;
Sf.REMOVE = EB;
Sf.itemAtPath = (t, e) => {
  let n = t;
  for (const [r, i] of e) {
    const s = n?.[r];
    if (s && "items" in s)
      n = s.items[i];
    else
      return;
  }
  return n;
};
Sf.parentCollection = (t, e) => {
  const n = Sf.itemAtPath(t, e.slice(0, -1)), r = e[e.length - 1][0], i = n?.[r];
  if (i && "items" in i)
    return i;
  throw new Error("Parent collection not found");
};
function DB(t, e, n) {
  let r = n(e, t);
  if (typeof r == "symbol")
    return r;
  for (const i of ["key", "value"]) {
    const s = e[i];
    if (s && "items" in s) {
      for (let o = 0; o < s.items.length; ++o) {
        const l = DB(Object.freeze(t.concat([[i, o]])), s.items[o], n);
        if (typeof l == "number")
          o = l - 1;
        else {
          if (l === tk)
            return tk;
          l === EB && (s.items.splice(o, 1), o -= 1);
        }
      }
      typeof r == "function" && i === "key" && (r = r(e, t));
    }
  }
  return typeof r == "function" ? r(e, t) : r;
}
const v2 = "\uFEFF", x2 = "", w2 = "", Eg = "", Xde = (t) => !!t && "items" in t, Qde = (t) => !!t && (t.type === "scalar" || t.type === "single-quoted-scalar" || t.type === "double-quoted-scalar" || t.type === "block-scalar");
function Jde(t) {
  switch (t) {
    case v2:
      return "<BOM>";
    case x2:
      return "<DOC>";
    case w2:
      return "<FLOW_END>";
    case Eg:
      return "<SCALAR>";
    default:
      return JSON.stringify(t);
  }
}
function OB(t) {
  switch (t) {
    case v2:
      return "byte-order-mark";
    case x2:
      return "doc-mode";
    case w2:
      return "flow-error-end";
    case Eg:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (t[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const Zde = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: v2,
  DOCUMENT: x2,
  FLOW_END: w2,
  SCALAR: Eg,
  createScalarToken: Vde,
  isCollection: Xde,
  isScalar: Qde,
  prettyToken: Jde,
  resolveAsScalar: Hde,
  setScalarValue: Wde,
  stringify: Kde,
  tokenType: OB,
  visit: Sf
}, Symbol.toStringTag, { value: "Module" }));
function Mo(t) {
  switch (t) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const n9 = new Set("0123456789ABCDEFabcdef"), e0e = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), ly = new Set(",[]{}"), t0e = new Set(` ,[]{}
\r	`), D3 = (t) => !t || t0e.has(t);
class FB {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, n = !1) {
    if (e) {
      if (typeof e != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null;
    }
    this.atEnd = !n;
    let r = this.next ?? "stream";
    for (; r && (n || this.hasChars(1)); )
      r = yield* this.parseNext(r);
  }
  atLineEnd() {
    let e = this.pos, n = this.buffer[e];
    for (; n === " " || n === "	"; )
      n = this.buffer[++e];
    return !n || n === "#" || n === `
` ? !0 : n === "\r" ? this.buffer[e + 1] === `
` : !1;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let n = this.buffer[e];
    if (this.indentNext > 0) {
      let r = 0;
      for (; n === " "; )
        n = this.buffer[++r + e];
      if (n === "\r") {
        const i = this.buffer[r + e + 1];
        if (i === `
` || !i && !this.atEnd)
          return e + r + 1;
      }
      return n === `
` || r >= this.indentNext || !n && !this.atEnd ? e + r : -1;
    }
    if (n === "-" || n === ".") {
      const r = this.buffer.substr(e, 3);
      if ((r === "---" || r === "...") && Mo(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === v2 && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let n = e.length, r = e.indexOf("#");
      for (; r !== -1; ) {
        const s = e[r - 1];
        if (s === " " || s === "	") {
          n = r - 1;
          break;
        } else
          r = e.indexOf("#", r + 1);
      }
      for (; ; ) {
        const s = e[n - 1];
        if (s === " " || s === "	")
          n -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(n)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(e.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const n = yield* this.pushSpaces(!0);
      return yield* this.pushCount(e.length - n), yield* this.pushNewline(), "stream";
    }
    return yield x2, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const n = this.peek(3);
      if ((n === "---" || n === "...") && Mo(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, n === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !Mo(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, n] = this.peek(2);
    if (!n && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && Mo(n)) {
      const r = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += r, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (e[n]) {
      case "#":
        yield* this.pushCount(e.length - n);
      // fallthrough
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(D3), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return n += yield* this.parseBlockScalarHeader(), n += yield* this.pushSpaces(!0), yield* this.pushCount(e.length - n), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, n, r = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (n = yield* this.pushSpaces(!1), this.indentValue = r = n) : n = 0, n += yield* this.pushSpaces(!0);
    while (e + n > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((r !== -1 && r < this.indentNext && i[0] !== "#" || r === 0 && (i.startsWith("---") || i.startsWith("...")) && Mo(i[3])) && !(r === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield w2, yield* this.parseLineStart();
    let s = 0;
    for (; i[s] === ","; )
      s += yield* this.pushCount(1), s += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (s += yield* this.pushIndicators(), i[s]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - s), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(D3), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const o = this.charAt(1);
        if (this.flowKey || Mo(o) || o === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      // fallthrough
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let n = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; n !== -1 && this.buffer[n + 1] === "'"; )
        n = this.buffer.indexOf("'", n + 2);
    else
      for (; n !== -1; ) {
        let s = 0;
        for (; this.buffer[n - 1 - s] === "\\"; )
          s += 1;
        if (s % 2 === 0)
          break;
        n = this.buffer.indexOf('"', n + 1);
      }
    const r = this.buffer.substring(0, n);
    let i = r.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const s = this.continueScalar(i + 1);
        if (s === -1)
          break;
        i = r.indexOf(`
`, s);
      }
      i !== -1 && (n = i - (r[i - 1] === "\r" ? 2 : 1));
    }
    if (n === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      n = this.buffer.length;
    }
    return yield* this.pushToIndex(n + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let e = this.pos;
    for (; ; ) {
      const n = this.buffer[++e];
      if (n === "+")
        this.blockScalarKeep = !0;
      else if (n > "0" && n <= "9")
        this.blockScalarIndent = Number(n) - 1;
      else if (n !== "-")
        break;
    }
    return yield* this.pushUntil((n) => Mo(n) || n === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, n = 0, r;
    e: for (let s = this.pos; r = this.buffer[s]; ++s)
      switch (r) {
        case " ":
          n += 1;
          break;
        case `
`:
          e = s, n = 0;
          break;
        case "\r": {
          const o = this.buffer[s + 1];
          if (!o && !this.atEnd)
            return this.setNext("block-scalar");
          if (o === `
`)
            break;
        }
        // fallthrough
        default:
          break e;
      }
    if (!r && !this.atEnd)
      return this.setNext("block-scalar");
    if (n >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = n : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const s = this.continueScalar(e + 1);
        if (s === -1)
          break;
        e = this.buffer.indexOf(`
`, s);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    let i = e + 1;
    for (r = this.buffer[i]; r === " "; )
      r = this.buffer[++i];
    if (r === "	") {
      for (; r === "	" || r === " " || r === "\r" || r === `
`; )
        r = this.buffer[++i];
      e = i - 1;
    } else if (!this.blockScalarKeep)
      do {
        let s = e - 1, o = this.buffer[s];
        o === "\r" && (o = this.buffer[--s]);
        const l = s;
        for (; o === " "; )
          o = this.buffer[--s];
        if (o === `
` && s >= this.pos && s + 1 + n > l)
          e = s;
        else
          break;
      } while (!0);
    return yield Eg, yield* this.pushToIndex(e + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let n = this.pos - 1, r = this.pos - 1, i;
    for (; i = this.buffer[++r]; )
      if (i === ":") {
        const s = this.buffer[r + 1];
        if (Mo(s) || e && ly.has(s))
          break;
        n = r;
      } else if (Mo(i)) {
        let s = this.buffer[r + 1];
        if (i === "\r" && (s === `
` ? (r += 1, i = `
`, s = this.buffer[r + 1]) : n = r), s === "#" || e && ly.has(s))
          break;
        if (i === `
`) {
          const o = this.continueScalar(r + 1);
          if (o === -1)
            break;
          r = Math.max(r, o - 2);
        }
      } else {
        if (e && ly.has(i))
          break;
        n = r;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield Eg, yield* this.pushToIndex(n + 1, !0), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, n) {
    const r = this.buffer.slice(this.pos, e);
    return r ? (yield r, this.pos += r.length, r.length) : (n && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(D3)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const e = this.flowLevel > 0, n = this.charAt(1);
        if (Mo(n) || e && ly.has(n))
          return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, n = this.buffer[e];
      for (; !Mo(n) && n !== ">"; )
        n = this.buffer[++e];
      return yield* this.pushToIndex(n === ">" ? e + 1 : e, !1);
    } else {
      let e = this.pos + 1, n = this.buffer[e];
      for (; n; )
        if (e0e.has(n))
          n = this.buffer[++e];
        else if (n === "%" && n9.has(this.buffer[e + 1]) && n9.has(this.buffer[e + 2]))
          n = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, !1);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let n = this.pos - 1, r;
    do
      r = this.buffer[++n];
    while (r === " " || e && r === "	");
    const i = n - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = n), i;
  }
  *pushUntil(e) {
    let n = this.pos, r = this.buffer[n];
    for (; !e(r); )
      r = this.buffer[++n];
    return yield* this.pushToIndex(n, !1);
  }
}
class TB {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let n = 0, r = this.lineStarts.length;
      for (; n < r; ) {
        const s = n + r >> 1;
        this.lineStarts[s] < e ? n = s + 1 : r = s;
      }
      if (this.lineStarts[n] === e)
        return { line: n + 1, col: 1 };
      if (n === 0)
        return { line: 0, col: e };
      const i = this.lineStarts[n - 1];
      return { line: n, col: e - i + 1 };
    };
  }
}
function Du(t, e) {
  for (let n = 0; n < t.length; ++n)
    if (t[n].type === e)
      return !0;
  return !1;
}
function r9(t) {
  for (let e = 0; e < t.length; ++e)
    switch (t[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function RB(t) {
  switch (t?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function ay(t) {
  switch (t.type) {
    case "document":
      return t.start;
    case "block-map": {
      const e = t.items[t.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return t.items[t.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function xh(t) {
  if (t.length === 0)
    return [];
  let e = t.length;
  e: for (; --e >= 0; )
    switch (t[e].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; t[++e]?.type === "space"; )
    ;
  return t.splice(e, t.length);
}
function i9(t) {
  if (t.start.type === "flow-seq-start")
    for (const e of t.items)
      e.sep && !e.value && !Du(e.start, "explicit-key-ind") && !Du(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, RB(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
class E5 {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new FB(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, n = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const r of this.lexer.lex(e, n))
      yield* this.next(r);
    n || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += e.length;
      return;
    }
    const n = OB(e);
    if (n)
      if (n === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = n, yield* this.step(), n) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += e.length;
      }
    else {
      const r = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: r, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const n = e ?? this.stack.pop();
    if (!n)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield n;
    else {
      const r = this.peek(1);
      switch (n.type === "block-scalar" ? n.indent = "indent" in r ? r.indent : 0 : n.type === "flow-collection" && r.type === "document" && (n.indent = 0), n.type === "flow-collection" && i9(n), r.type) {
        case "document":
          r.value = n;
          break;
        case "block-scalar":
          r.props.push(n);
          break;
        case "block-map": {
          const i = r.items[r.items.length - 1];
          if (i.value) {
            r.items.push({ start: [], key: n, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (i.sep)
            i.value = n;
          else {
            Object.assign(i, { key: n, sep: [] }), this.onKeyLine = !i.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const i = r.items[r.items.length - 1];
          i.value ? r.items.push({ start: [], value: n }) : i.value = n;
          break;
        }
        case "flow-collection": {
          const i = r.items[r.items.length - 1];
          !i || i.value ? r.items.push({ start: [], key: n, sep: [] }) : i.sep ? i.value = n : Object.assign(i, { key: n, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop(), yield* this.pop(n);
      }
      if ((r.type === "document" || r.type === "block-map" || r.type === "block-seq") && (n.type === "block-map" || n.type === "block-seq")) {
        const i = n.items[n.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && r9(i.start) === -1 && (n.indent === 0 || i.start.every((s) => s.type !== "comment" || s.indent < n.indent)) && (r.type === "document" ? r.end = i.start : r.items.push({ start: i.start }), n.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        r9(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const n = this.startBlockValue(e);
    n ? this.stack.push(n) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const n = ay(this.peek(2)), r = xh(n);
      let i;
      e.end ? (i = e.end, i.push(this.sourceToken), delete e.end) : i = [this.sourceToken];
      const s = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: r, key: e, sep: i }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = s;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let n = this.source.indexOf(`
`) + 1;
          for (; n !== 0; )
            this.onNewLine(this.offset + n), n = this.source.indexOf(`
`, n) + 1;
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    const n = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, n.value) {
          const r = "end" in n.value ? n.value.end : void 0;
          (Array.isArray(r) ? r[r.length - 1] : void 0)?.type === "comment" ? r?.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (n.value)
          e.items.push({ start: [this.sourceToken] });
        else if (n.sep)
          n.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(n.start, e.indent)) {
            const i = e.items[e.items.length - 2]?.value?.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, n.start), i.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          n.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const r = !this.onKeyLine && this.indent === e.indent, i = r && (n.sep || n.explicitKey) && this.type !== "seq-item-ind";
      let s = [];
      if (i && n.sep && !n.value) {
        const o = [];
        for (let l = 0; l < n.sep.length; ++l) {
          const a = n.sep[l];
          switch (a.type) {
            case "newline":
              o.push(l);
              break;
            case "space":
              break;
            case "comment":
              a.indent > e.indent && (o.length = 0);
              break;
            default:
              o.length = 0;
          }
        }
        o.length >= 2 && (s = n.sep.splice(o[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || n.value ? (s.push(this.sourceToken), e.items.push({ start: s }), this.onKeyLine = !0) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !n.sep && !n.explicitKey ? (n.start.push(this.sourceToken), n.explicitKey = !0) : i || n.value ? (s.push(this.sourceToken), e.items.push({ start: s, explicitKey: !0 })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: !0 }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (n.explicitKey)
            if (n.sep)
              if (n.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Du(n.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: null, sep: [this.sourceToken] }]
                });
              else if (RB(n.key) && !Du(n.sep, "newline")) {
                const o = xh(n.start), l = n.key, a = n.sep;
                a.push(this.sourceToken), delete n.key, delete n.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: l, sep: a }]
                });
              } else s.length > 0 ? n.sep = n.sep.concat(s, this.sourceToken) : n.sep.push(this.sourceToken);
            else if (Du(n.start, "newline"))
              Object.assign(n, { key: null, sep: [this.sourceToken] });
            else {
              const o = xh(n.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: o, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            n.sep ? n.value || i ? e.items.push({ start: s, key: null, sep: [this.sourceToken] }) : Du(n.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : n.sep.push(this.sourceToken) : Object.assign(n, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const o = this.flowScalar(this.type);
          i || n.value ? (e.items.push({ start: s, key: o, sep: [] }), this.onKeyLine = !0) : n.sep ? this.stack.push(o) : (Object.assign(n, { key: o, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const o = this.startBlockValue(e);
          if (o) {
            if (o.type === "block-seq") {
              if (!n.explicitKey && n.sep && !Du(n.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else r && e.items.push({ start: s });
            this.stack.push(o);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    const n = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (n.value) {
          const r = "end" in n.value ? n.value.end : void 0;
          (Array.isArray(r) ? r[r.length - 1] : void 0)?.type === "comment" ? r?.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          n.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (n.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(n.start, e.indent)) {
            const i = e.items[e.items.length - 2]?.value?.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, n.start), i.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          n.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (n.value || this.indent <= e.indent)
          break;
        n.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        n.value || Du(n.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : n.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const r = this.startBlockValue(e);
      if (r) {
        this.stack.push(r);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const n = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let r;
      do
        yield* this.pop(), r = this.peek(1);
      while (r && r.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !n || n.sep ? e.items.push({ start: [this.sourceToken] }) : n.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !n || n.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : n.sep ? n.sep.push(this.sourceToken) : Object.assign(n, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !n || n.value ? e.items.push({ start: [this.sourceToken] }) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !n || n.value ? e.items.push({ start: [], key: i, sep: [] }) : n.sep ? this.stack.push(i) : Object.assign(n, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const r = this.startBlockValue(e);
      r ? this.stack.push(r) : (yield* this.pop(), yield* this.step());
    } else {
      const r = this.peek(2);
      if (r.type === "block-map" && (this.type === "map-value-ind" && r.indent === e.indent || this.type === "newline" && !r.items[r.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && r.type !== "flow-collection") {
        const i = ay(r), s = xh(i);
        i9(e);
        const o = e.end.splice(1, e.end.length);
        o.push(this.sourceToken);
        const l = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: s, key: e, sep: o }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = l;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let n = this.source.indexOf(`
`) + 1;
      for (; n !== 0; )
        this.onNewLine(this.offset + n), n = this.source.indexOf(`
`, n) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const n = ay(e), r = xh(n);
        return r.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: r, explicitKey: !0 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const n = ay(e), r = xh(n);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: r, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, n) {
    return this.type !== "comment" || this.indent <= n ? !1 : e.every((r) => r.type === "newline" || r.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      // fallthrough
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function MB(t) {
  const e = t.prettyErrors !== !1;
  return { lineCounter: t.lineCounter || e && new TB() || null, prettyErrors: e };
}
function n0e(t, e = {}) {
  const { lineCounter: n, prettyErrors: r } = MB(e), i = new E5(n?.addNewLine), s = new A5(e), o = Array.from(s.compose(i.parse(t)));
  if (r && n)
    for (const l of o)
      l.errors.forEach(rv(t, n)), l.warnings.forEach(rv(t, n));
  return o.length > 0 ? o : Object.assign([], { empty: !0 }, s.streamInfo());
}
function PB(t, e = {}) {
  const { lineCounter: n, prettyErrors: r } = MB(e), i = new E5(n?.addNewLine), s = new A5(e);
  let o = null;
  for (const l of s.compose(i.parse(t), !0, t.length))
    if (!o)
      o = l;
    else if (o.options.logLevel !== "silent") {
      o.errors.push(new Yc(l.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return r && n && (o.errors.forEach(rv(t, n)), o.warnings.forEach(rv(t, n))), o;
}
function r0e(t, e, n) {
  let r;
  typeof e == "function" ? r = e : n === void 0 && e && typeof e == "object" && (n = e);
  const i = PB(t, n);
  if (!i)
    return null;
  if (i.warnings.forEach((s) => eB(i.options.logLevel, s)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: r }, n));
}
function i0e(t, e, n) {
  let r = null;
  if (typeof e == "function" || Array.isArray(e) ? r = e : n === void 0 && e && (n = e), typeof n == "string" && (n = n.length), typeof n == "number") {
    const i = Math.round(n);
    n = i < 1 ? void 0 : i > 8 ? { indent: 8 } : { indent: i };
  }
  if (t === void 0) {
    const { keepUndefined: i } = n ?? e ?? {};
    if (!i)
      return;
  }
  return qf(t) && !r ? t.toString(n) : new u0(t, r, n).toString(n);
}
const s0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: u2,
  CST: Zde,
  Composer: A5,
  Document: u0,
  Lexer: FB,
  LineCounter: TB,
  Pair: fi,
  Parser: E5,
  Scalar: vt,
  Schema: b2,
  YAMLError: C5,
  YAMLMap: Is,
  YAMLParseError: Yc,
  YAMLSeq: cc,
  YAMLWarning: vB,
  isAlias: mc,
  isCollection: Qn,
  isDocument: qf,
  isMap: s0,
  isNode: Jn,
  isPair: Gn,
  isScalar: Fn,
  isSeq: o0,
  parse: r0e,
  parseAllDocuments: n0e,
  parseDocument: PB,
  stringify: i0e,
  visit: Uf,
  visitAsync: a2
}, Symbol.toStringTag, { value: "Module" }));
function o0e(t) {
  let e = null;
  try {
    e = s0e.parse(t.doc.toString());
  } catch {
  }
  const n = j6(t, Hn.YAML);
  return { data: e, pointers: n };
}
const IB = (t) => {
  switch (t) {
    case Hn.JSON:
      return Bhe;
    case Hn.JSON5:
      return Xhe;
    case Hn.YAML:
      return o0e;
  }
};
function l0e(t) {
  return Object.entries(t);
}
function vp(t, e) {
  if (typeof t == "string" || typeof t != "object" || t === null)
    return t;
  if (Array.isArray(t))
    return t.map((i) => vp(i, e));
  if (t instanceof Map) {
    const i = /* @__PURE__ */ new Map();
    for (const [s, o] of t) {
      const l = s, a = vp(o, e);
      i.set(l, a);
    }
    return i;
  }
  if (t instanceof Set) {
    const i = /* @__PURE__ */ new Set();
    for (const s of t) {
      const o = vp(s, e);
      i.add(o);
    }
    return i;
  }
  const n = {};
  function r(i, s, o, l) {
    o === i && l === s ? n[o] = vp(s, e) : n[o] = l;
  }
  for (const [i, s] of l0e(t)) {
    const o = e(i, s);
    if (o.length === 2 && typeof o[0] == "string")
      r(i, s, o[0], o[1]);
    else
      for (const [l, a] of o)
        r(i, s, l, a);
  }
  return n;
}
var a0e = function(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
};
class u0e {
  constructor() {
    this.completions = /* @__PURE__ */ new Map(), this.reservedKeys = /* @__PURE__ */ new Set();
  }
  reserve(e) {
    this.reservedKeys.add(e);
  }
  add(e) {
    this.reservedKeys.has(e.label) || this.completions.set(e.label, e);
  }
}
function Ip(t) {
  return !(!t || mi(t) || t.name === "UnknownPropertyError" || t.type === "undefined");
}
class c0e {
  // private lastKnownValidData: object | null = null;
  constructor(e) {
    var n, r, i;
    this.opts = e, this.originalSchema = null, this.schema = null, this.laxSchema = null, this.mode = Hn.JSON, this.mode = (n = e.mode) !== null && n !== void 0 ? n : Hn.JSON, this.parser = (i = (r = this.opts) === null || r === void 0 ? void 0 : r.jsonParser) !== null && i !== void 0 ? i : IB(this.mode);
  }
  doComplete(e) {
    var n;
    const r = q6(e.state);
    if (this.originalSchema !== r && (this.schema = (n = Bc(r, r)) !== null && n !== void 0 ? n : r, this.laxSchema = h0e(this.schema)), !this.schema || !this.laxSchema)
      return [];
    Yn.log("xxx", "trying with original schema");
    const i = this.doCompleteForSchema(e, this.schema);
    return i.options.length !== 0 ? i : (Yn.log("xxx", "no completions with original schema, trying with lax schema"), this.doCompleteForSchema(e, this.laxSchema));
  }
  doCompleteForSchema(e, n) {
    var r, i;
    const s = {
      from: e.pos,
      to: e.pos,
      options: [],
      filter: !1
      // will be handled manually
    }, o = e.state.doc.sliceString(0);
    let l = Qw(e.state, e.pos), a = e.state.sliceDoc(l.from, e.pos).replace(/^(["'])/, "");
    if (Yn.log("xxx", "node", l, "prefix", a, "ctx", e), !(qy(l, this.mode) || W1(l, this.mode)) && !e.explicit)
      return Yn.log("xxx", "no completions for non-word/primitive", l), s;
    const u = Eh(e.state.doc, l), c = Eh(e.state.doc, l, !1);
    if (l && (qy(l, this.mode) || W1(l, this.mode)))
      s.from = l.from, s.to = l.to;
    else {
      const m = e.matchBefore(/[A-Za-z0-9._]*/), y = e.pos - u.length;
      Yn.log("xxx", "overwriteStart after", y, "ctx.pos", e.pos, "word", m, "currentWord", u, "=>", o[y - 1], "..", o[y], "..", o), s.from = l.name === _t.INVALID ? (r = m?.from) !== null && r !== void 0 ? r : e.pos : y, s.to = e.pos;
    }
    const f = new u0e();
    let d = !0;
    const p = RD(l, _t.PROPERTY_NAME, this.mode);
    if (p && (Yn.log("xxx", "closestPropertyNameNode", p, "node", l), l = p), W1(l, this.mode)) {
      Yn.log("xxx", "isPropertyNameNode", l);
      const m = l.parent;
      if (m) {
        const y = TD(m, this.mode);
        d = !y || y.name === _t.INVALID && y.from - y.to === 0 || // TODO: Verify this doesn't break anything else
        (y.parent ? rm(y.parent).length <= 1 : !1), Yn.log("xxx", "addValue", d, TD(m, this.mode), l), l = (i = RD(m, _t.OBJECT, this.mode)) !== null && i !== void 0 ? i : null;
      }
    }
    if (Yn.log("xxx", l, u, e, "node at pos", Qw(e.state, e.pos)), l && [_t.OBJECT, _t.JSON_TEXT].includes(dr(l.name, this.mode)) && (W1(Qw(e.state, e.pos), this.mode) || p)) {
      if (l.from === e.pos)
        return Yn.log("xxx", "no completions for just before opening brace"), s;
      this.getPropertyCompletions(n, e, l, f, d, c);
    } else {
      const m = {}, y = this.getValueCompletions(n, e, m, f);
      Yn.log("xxx", "getValueCompletions res", y);
    }
    return s.options = Array.from(f.completions.values()).filter((m) => jy(m.label).startsWith(a)), Yn.log("xxx", "result", s, "prefix", a, "collector.completions", f.completions, "reservedKeys", f.reservedKeys), s;
  }
  applySnippetCompletion(e) {
    return $ee(typeof e.apply != "string" ? e.label : e.apply, e);
  }
  getPropertyCompletions(e, n, r, i, s, o) {
    const l = yie(r, _t.PROPERTY, this.mode);
    Yn.log("xxx", "getPropertyCompletions", r, n, l), l.forEach((u) => {
      const c = Eh(n.state.doc, D4(u, _t.PROPERTY_NAME, this.mode));
      i.reserve(jy(c));
    });
    const a = this.getSchemas(e, n);
    Yn.log("xxx", "propertyCompletion schemas", a), a.forEach((u) => {
      if (typeof u != "object")
        return;
      const c = u.properties;
      c && Object.entries(c).forEach(([d, p]) => {
        var m, y;
        if (typeof p == "object") {
          const b = (m = p.description) !== null && m !== void 0 ? m : "", v = (y = p.type) !== null && y !== void 0 ? y : "", _ = Array.isArray(v) ? v.toString() : v, k = {
            // label is the unquoted key which will be displayed.
            label: d,
            apply: this.getInsertTextForProperty(d, s, o, e, p),
            type: "property",
            detail: _,
            info: () => kl("div", {
              inner: Zh(b)
            })
          };
          i.add(this.applySnippetCompletion(k));
        }
      });
      const f = u.propertyNames;
      if (typeof f == "object" && (f.enum && f.enum.forEach((d) => {
        const p = d?.toString();
        if (p) {
          const m = {
            label: p,
            apply: this.getInsertTextForProperty(p, s, o, e),
            type: "property"
          };
          i.add(this.applySnippetCompletion(m));
        }
      }), f.const)) {
        const d = f.const.toString(), p = {
          label: d,
          apply: this.getInsertTextForProperty(d, s, o, e),
          type: "property"
        };
        i.add(this.applySnippetCompletion(p));
      }
    });
  }
  // apply is the quoted key which will be applied.
  // Normally the label needs to match the token
  // prefix i.e. if the token begins with `"to`, then the
  // label needs to have the quotes as well for it to match.
  // However we are manually filtering the results so we can
  // just use the unquoted key as the label, which is nicer
  // and gives us more control.
  // If no property value is present, then we add the colon as well.
  // Use snippetCompletion to handle insert value + position cursor e.g. "key": "#{}"
  // doc: https://codemirror.net/docs/ref/#autocomplete.snippetCompletion
  // idea: https://discuss.codemirror.net/t/autocomplete-cursor-position-in-apply-function/4088/3
  getInsertTextForProperty(e, n, r, i, s) {
    s = s && Bc(s, i);
    let o = this.getInsertTextForPropertyName(e, r);
    if (!n)
      return o;
    o += ": ";
    let l, a = 0;
    if (typeof s == "object") {
      if (typeof s.default < "u")
        l || (l = this.getInsertTextForGuessedValue(s.default, "")), a++;
      else if (s.enum && (!l && s.enum.length === 1 && (l = this.getInsertTextForGuessedValue(s.enum[0], "")), a += s.enum.length), typeof s.const < "u" && (l || (l = this.getInsertTextForGuessedValue(s.const, "")), a++), Array.isArray(s.examples) && s.examples.length && (l || (l = this.getInsertTextForGuessedValue(s.examples[0], "")), a += s.examples.length), l === void 0 && a === 0) {
        let u = Array.isArray(s.type) ? s.type[0] : s.type;
        switch (u || (s.properties ? u = "object" : s.items && (u = "array")), u) {
          case "boolean":
            l = "#{}";
            break;
          case "string":
            l = this.getInsertTextForString("");
            break;
          case "object":
            switch (this.mode) {
              case Hn.JSON5:
                l = "{#{}}";
                break;
              case Hn.YAML:
                l = "#{}";
                break;
              default:
                l = "{#{}}";
                break;
            }
            break;
          case "array":
            l = "[#{}]";
            break;
          case "number":
          case "integer":
            l = "#{0}";
            break;
          case "null":
            l = "#{null}";
            break;
          default:
            l = "#{}";
            break;
        }
      }
    }
    return (!l || a > 1) && (Yn.log("xxx", "value", l, "nValueProposals", a, s), l = "#{}"), o + l;
  }
  getInsertTextForPropertyName(e, n) {
    switch (this.mode) {
      case Hn.JSON5:
      case Hn.YAML:
        return n.startsWith('"') ? `"${e}"` : n.startsWith("'") ? `'${e}'` : e;
      default:
        return `"${e}"`;
    }
  }
  getInsertTextForString(e, n = "#") {
    switch (this.mode) {
      case Hn.JSON5:
        return `'${n}{${e}}'`;
      case Hn.YAML:
        return `${n}{${e}}`;
      default:
        return `"${n}{${e}}"`;
    }
  }
  // TODO: Is this actually working?
  getInsertTextForGuessedValue(e, n = "") {
    switch (typeof e) {
      case "object":
        return e === null ? "${null}" + n : this.getInsertTextForValue(e, n);
      case "string": {
        let r = JSON.stringify(e);
        return r = r.substr(1, r.length - 2), r = this.getInsertTextForPlainText(r), this.getInsertTextForString(r, "$") + n;
      }
      case "number":
      case "boolean":
        return "${" + JSON.stringify(e) + "}" + n;
    }
    return this.getInsertTextForValue(e, n);
  }
  getInsertTextForPlainText(e) {
    return e.replace(/[\\$}]/g, "\\$&");
  }
  getInsertTextForValue(e, n) {
    const r = JSON.stringify(e, null, "	");
    return r === "{}" ? "{#{}}" + n : r === "[]" ? "[#{}]" + n : this.getInsertTextForPlainText(r + n);
  }
  getValueCompletions(e, n, r, i) {
    let s = Dr(n.state).resolveInner(n.pos, -1), o = null, l;
    if (Yn.log("xxx", "getValueCompletions", s, n), s && qy(s, this.mode) && (o = s, s = s.parent), !s) {
      this.addSchemaValueCompletions(e, r, i);
      return;
    }
    if (dr(s.name, this.mode) === _t.PROPERTY) {
      const u = D4(s, _t.PROPERTY_NAME, this.mode);
      u && (l = Eh(n.state.doc, u), s = s.parent);
    }
    if (Yn.log("xxx", "node", s, "parentKey", l), s && (l !== void 0 || dr(s.name, this.mode) === _t.ARRAY)) {
      const u = this.getSchemas(e, n);
      for (const c of u) {
        if (typeof c != "object")
          return;
        if (dr(s.name, this.mode) === _t.ARRAY && c.items) {
          let f = i;
          if (c.uniqueItems && (f = Object.assign(Object.assign({}, f), {
            add(d) {
              f.completions.has(d.label) || i.add(d);
            },
            reserve(d) {
              i.reserve(d);
            }
          })), Array.isArray(c.items)) {
            let d = 0;
            if (o) {
              const m = UP(s, o, this.mode);
              m >= 0 && (d = m);
            }
            const p = c.items[d];
            p && this.addSchemaValueCompletions(p, r, f);
          } else
            this.addSchemaValueCompletions(c.items, r, f);
        }
        if ((c.type == null || c.type !== "object") && this.addSchemaValueCompletions(c, r, i), l !== void 0) {
          let f = !1;
          if (c.properties) {
            const d = c.properties[l];
            d && (f = !0, this.addSchemaValueCompletions(d, r, i));
          }
          if (c.patternProperties && !f)
            for (const d of Object.keys(c.patternProperties)) {
              const p = this.extendedRegExp(d);
              if (p?.test(l)) {
                f = !0;
                const m = c.patternProperties[d];
                m && this.addSchemaValueCompletions(m, r, i);
              }
            }
          if (c.additionalProperties && !f) {
            const d = c.additionalProperties;
            this.addSchemaValueCompletions(d, r, i);
          }
        }
        r.boolean && (this.addBooleanValueCompletion(!0, i), this.addBooleanValueCompletion(!1, i)), r.null && this.addNullValueCompletion(i);
      }
    }
    return {
      valuePrefix: o ? Eh(n.state.doc, o, !0, !1) : ""
    };
  }
  addSchemaValueCompletions(e, n, r) {
    typeof e == "object" && (this.addEnumValueCompletions(e, r), this.addDefaultValueCompletions(e, r), this.collectTypes(e, n), Array.isArray(e.allOf) && e.allOf.forEach((i) => this.addSchemaValueCompletions(i, n, r)), Array.isArray(e.anyOf) && e.anyOf.forEach((i) => this.addSchemaValueCompletions(i, n, r)), Array.isArray(e.oneOf) && e.oneOf.forEach((i) => this.addSchemaValueCompletions(i, n, r)));
  }
  addDefaultValueCompletions(e, n, r = 0) {
    let i = !1;
    if (typeof e.default < "u") {
      let s = e.type, o = e.default;
      for (let a = r; a > 0; a--)
        o = [o], s = "array";
      const l = Object.assign(Object.assign({ type: s?.toString() }, this.getAppliedValue(o)), { detail: "Default value" });
      n.add(l), i = !0;
    }
    Array.isArray(e.examples) && e.examples.forEach((s) => {
      let o = e.type, l = s;
      for (let a = r; a > 0; a--)
        l = [l], o = "array";
      n.add(Object.assign({ type: o?.toString() }, this.getAppliedValue(l))), i = !0;
    }), !i && typeof e.items == "object" && !Array.isArray(e.items) && r < 5 && this.addDefaultValueCompletions(e.items, n, r + 1);
  }
  addEnumValueCompletions(e, n) {
    var r, i;
    if (typeof e.const < "u" && n.add(Object.assign(Object.assign({ type: (r = e.type) === null || r === void 0 ? void 0 : r.toString() }, this.getAppliedValue(e.const)), { info: e.description })), Array.isArray(e.enum))
      for (let s = 0, o = e.enum.length; s < o; s++) {
        const l = e.enum[s];
        n.add(Object.assign(Object.assign({ type: (i = e.type) === null || i === void 0 ? void 0 : i.toString() }, this.getAppliedValue(l)), { info: e.description }));
      }
  }
  addBooleanValueCompletion(e, n) {
    n.add({
      type: "boolean",
      label: e ? "true" : "false"
    });
  }
  addNullValueCompletion(e) {
    e.add({
      type: "null",
      label: "null"
    });
  }
  collectTypes(e, n) {
    if (Array.isArray(e.enum) || typeof e.const < "u")
      return;
    const r = e.type;
    Array.isArray(r) ? r.forEach((i) => n[i] = !0) : r && (n[r] = !0);
  }
  getSchemas(e, n) {
    var r, i, s;
    const { data: o } = this.parser(n.state), l = new OI(e);
    let a = jP(n.state, n.pos, -1, this.mode);
    if (a === "" && (a = void 0), a != null && a.endsWith("/")) {
      a = a.substring(0, a.length - 1);
      const m = s9(e, o, a);
      if (m != null)
        return [m];
    }
    let u = a?.replace(/\/[^/]*$/, "");
    u === "" && (u = void 0);
    const c = s9(e, o, u), f = a?.split("/").pop(), d = f == null || f in ((r = c?.properties) !== null && r !== void 0 ? r : {});
    let p = l.getSchema({
      pointer: a,
      data: o ?? void 0
    });
    return !d && p?.type === "null" && this.mode === "yaml" && (p = void 0), Yn.log("xxxx", "draft.getSchema", p, "data", o, "pointer", a, "pointerPointsToKnownProperty", d), mi(p) && (p = (i = p.data) === null || i === void 0 ? void 0 : i.schema), !Ip(p) && c ? [c] : (Ip(p) || (p = l.getSchema({ pointer: u }), a = u), Yn.log("xxx", "pointer..", JSON.stringify(a)), !Ip(p) && (!a || a === "/") && (p = (s = Bc(e, e)) !== null && s !== void 0 ? s : e), Yn.log("xxx", "subSchema..", p), p ? Array.isArray(p.allOf) ? [
      p,
      ...p.allOf.map((m) => Bc(m, e))
    ] : Array.isArray(p.oneOf) ? [
      p,
      ...p.oneOf.map((m) => Bc(m, e))
    ] : Array.isArray(p.anyOf) ? [
      p,
      ...p.anyOf.map((m) => Bc(m, e))
    ] : [p] : []);
  }
  getAppliedValue(e) {
    const n = jy(JSON.stringify(e));
    switch (this.mode) {
      case Hn.JSON5:
        return {
          label: n,
          apply: gie(JSON.stringify(e))
        };
      case Hn.YAML:
        return {
          label: n,
          apply: n
        };
      default:
        return {
          label: n,
          apply: JSON.stringify(e)
        };
    }
  }
  getValueFromLabel(e) {
    return JSON.parse(e);
  }
  extendedRegExp(e) {
    let n = "";
    e.startsWith("(?i)") && (e = e.substring(4), n = "i");
    try {
      return new RegExp(e, n + "u");
    } catch {
      try {
        return new RegExp(e, n);
      } catch {
        return;
      }
    }
  }
}
function f0e(t = {}) {
  const e = new c0e(t);
  return function(r) {
    return e.doComplete(r);
  };
}
function h0e(t) {
  return vp(t, (e, n) => e === "additionalProperties" && n === !1 ? [] : e === "required" && Array.isArray(n) ? [] : e === "unevaluatedProperties" && n === !1 ? [] : e === "unevaluatedItems" && n === !1 ? [] : [e, n]);
}
function s9(t, e, n) {
  const r = new OI(t), i = r.getSchema({
    pointer: n,
    data: e ?? void 0
  });
  if (!Ip(i))
    return;
  const s = NB(r, i), o = {};
  for (let d of s) {
    let p = p0e(n, d);
    const m = r.getSchema({
      // TODO [performance] use subSchema and only check it's sub-properties
      pointer: p,
      data: e ?? void 0
      // pointer: `/${possibleDirectPropertyName}`,
      // schema: subSchema
    });
    Ip(m) && Object.assign(o, {
      [d]: m
    });
  }
  if (s.length === 0 || Object.keys(o).length === 0)
    return;
  const l = i, { allOf: a, anyOf: u, oneOf: c } = l, f = a0e(l, ["allOf", "anyOf", "oneOf"]);
  return Object.assign(Object.assign({}, f), { properties: o });
}
function NB(t, e) {
  if (e = Bc(e, t.rootSchema), typeof e != "object" || e == null)
    return [];
  const n = [];
  function r(i) {
    const s = NB(t, i);
    n.push(...s);
  }
  if (typeof e.properties == "object" && e.properties != null && n.push(...Object.keys(e.properties)), typeof e.then == "object" && e.then != null && r(e.then), Array.isArray(e.allOf))
    for (const i of e.allOf)
      r(i);
  if (Array.isArray(e.anyOf))
    for (const i of e.anyOf)
      r(i);
  if (Array.isArray(e.oneOf))
    for (const i of e.oneOf)
      r(i);
  return n;
}
function Bc(t, e) {
  if (typeof t == "object" && t.$ref) {
    const n = d0e(e, t.$ref);
    if (typeof n == "object") {
      const r = Object.assign(Object.assign({}, t), n);
      return Reflect.deleteProperty(r, "$ref"), r;
    }
  }
  return t;
}
function d0e(t, e) {
  const n = e.split("/");
  let r = t;
  return n.forEach((i) => {
    if (i) {
      if (i === "#") {
        r = t;
        return;
      }
      typeof r == "object" && (r = r[i]);
    }
  }), r;
}
function p0e(t, e) {
  return t === void 0 ? `/${e}` : `${t}/${e}`;
}
const Dg = (t, e) => {
  const n = t.length > 2;
  let r = t.map((i, s) => {
    const o = "`" + (e ? e(i) : i) + "`";
    return s === t.length - 1 ? "or " + o : o;
  });
  return n ? r.join(", ") : r.join(" ");
}, g0e = (t) => {
  var e, n, r;
  return !((e = t?.data) === null || e === void 0) && e.pointer && ((n = t?.data) === null || n === void 0 ? void 0 : n.pointer) !== "#" ? t.data.pointer.slice(1) : !((r = t?.data) === null || r === void 0) && r.property ? `/${t.data.property}` : "";
}, m0e = (t) => t.startState.field(Mb) !== t.state.field(Mb);
function y0e(t) {
  const e = new v0e(t);
  return (n) => e.doValidation(n);
}
const b0e = [
  "NoAdditionalPropertiesError",
  "RequiredPropertyError",
  "InvalidPropertyNameError",
  "ForbiddenPropertyError",
  "UndefinedValueError"
];
class v0e {
  constructor(e) {
    var n, r, i, s;
    this.options = e, this.schema = null, this.mode = Hn.JSON, this.rewriteError = (o) => {
      var l, a, u, c, f;
      const d = o?.data, p = d?.errors;
      return o.code === "one-of-error" && p?.length ? `Expected one of ${Dg(p, (y) => y.data.expected)}` : o.code === "type-error" ? `Expected \`${!((l = o?.data) === null || l === void 0) && l.expected && Array.isArray((a = o?.data) === null || a === void 0 ? void 0 : a.expected) ? Dg((u = o?.data) === null || u === void 0 ? void 0 : u.expected) : (c = o?.data) === null || c === void 0 ? void 0 : c.expected}\` but received \`${(f = o?.data) === null || f === void 0 ? void 0 : f.received}\`` : o.message.replaceAll("in `#` ", "").replaceAll("at `#`", "").replaceAll("/", ".").replaceAll("#.", "");
    }, this.mode = (r = (n = this.options) === null || n === void 0 ? void 0 : n.mode) !== null && r !== void 0 ? r : Hn.JSON, this.parser = (s = (i = this.options) === null || i === void 0 ? void 0 : i.jsonParser) !== null && s !== void 0 ? s : IB(this.mode);
  }
  get schemaTitle() {
    var e, n, r;
    return (r = (n = (e = this.schema) === null || e === void 0 ? void 0 : e.getSchema()) === null || n === void 0 ? void 0 : n.title) !== null && r !== void 0 ? r : "json-schema";
  }
  // validate using view as the linter extension signature requires
  doValidation(e) {
    const n = q6(e.state);
    if (!n)
      return [];
    if (this.schema = new EI(n), !this.schema)
      return [];
    const r = e.state.doc.toString();
    if (!r?.length)
      return [];
    const i = this.parser(e.state);
    if (i.data == null)
      return [];
    let s = [];
    try {
      s = this.schema.validate(i.data);
    } catch {
    }
    return Yn.log("xxx", "validation errors", s, i.data), s.length ? s.reduce((o, l) => {
      const a = () => {
        const f = this.rewriteError(l);
        o.push({
          from: 0,
          to: 0,
          message: f,
          severity: "error",
          source: this.schemaTitle,
          renderMessage: () => {
            const d = kl("div", {});
            return d.innerHTML = Zh(f), d;
          }
        });
      }, u = g0e(l), c = i.pointers.get(u);
      if (l.name === "MaxPropertiesError" || l.name === "MinPropertiesError" || u === "")
        a();
      else if (c) {
        const f = b0e.includes(l.name), d = this.rewriteError(l), p = f ? c.keyFrom : c.valueFrom, m = f ? c.keyTo : c.valueTo;
        m !== void 0 && p !== void 0 && o.push({
          from: p,
          to: m,
          message: d,
          renderMessage: () => {
            const y = kl("div", {});
            return y.innerHTML = Zh(d), y;
          },
          severity: "error",
          source: this.schemaTitle
        });
      } else
        a();
      return o;
    }, []) : [];
  }
}
function x0e(t) {
  const e = new w0e(t);
  return async function(r, i, s) {
    return e.doHover(r, i, s);
  };
}
function o9(t) {
  if (t.type)
    return t.$ref ? `${t.$ref} (${t.type})` : t.type;
  if (t.$ref)
    return `${t.$ref}`;
}
function O3(t, e, n) {
  return `${e}: ${Dg(t[e].map((r) => {
    try {
      const { data: i } = n.resolveRef({ data: r, pointer: r.$ref });
      return o9(i || r);
    } catch {
      return r.type;
    }
  }))}`;
}
class w0e {
  constructor(e) {
    var n, r;
    this.opts = e, this.schema = null, this.mode = Hn.JSON, this.opts = Object.assign({ parser: JSON.parse }, this.opts), this.mode = (r = (n = this.opts) === null || n === void 0 ? void 0 : n.mode) !== null && r !== void 0 ? r : Hn.JSON;
  }
  getDataForCursor(e, n, r) {
    const i = q6(e.state);
    if (!i)
      return null;
    this.schema = new EI(i);
    const s = jP(e.state, n, r, this.mode);
    let o;
    try {
      o = this.opts.parser(e.state.doc.toString());
    } catch {
    }
    if (!s)
      return null;
    let l = this.schema.getSchema({
      pointer: s,
      data: o,
      withSchemaWarning: !0
    });
    return mi(l) && (l?.data.schema.$ref ? l = this.schema.resolveRef(l) : l = l?.data.schema), { schema: l, pointer: s };
  }
  formatMessage(e) {
    const { message: n, typeInfo: r } = e;
    return n ? kl("div", { class: "cm6-json-schema-hover" }, [
      kl("div", {
        class: "cm6-json-schema-hover--description",
        inner: Zh(n, !1)
      }),
      kl("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
        kl("div", {
          class: "cm6-json-schema-hover--code",
          inner: Zh(r, !1)
        })
      ])
    ]) : kl("div", { class: "cm6-json-schema-hover" }, [
      kl("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
        kl("code", {
          class: "cm6-json-schema-hover--code",
          inner: Zh(r, !1)
        })
      ])
    ]);
  }
  getHoverTexts(e, n) {
    let r = "", i = null;
    const { schema: s } = e;
    return s.oneOf && (r = O3(s, "oneOf", n)), s.anyOf && (r = O3(s, "anyOf", n)), s.allOf && (r = O3(s, "allOf", n)), s.type && (r = Array.isArray(s.type) ? Dg(s.type) : s.type), s.$ref && (r = ` Reference: ${s.$ref}`), s.enum && (r = `\`enum\`: ${Dg(s.enum)}`), s.format && (r += `\`format\`: ${s.format}`), s.pattern && (r += `\`pattern\`: ${s.pattern}`), s.description && (i = s.description), { message: i, typeInfo: r };
  }
  // return hover state for the current json schema property
  async doHover(e, n, r) {
    var i, s, o, l;
    const a = n, u = n;
    try {
      const c = this.getDataForCursor(e, n, r);
      if (Yn.log("cursorData", c), !c?.schema)
        return null;
      const d = ((s = (i = this.opts) === null || i === void 0 ? void 0 : i.getHoverTexts) !== null && s !== void 0 ? s : this.getHoverTexts)(c, this.schema), m = ((l = (o = this.opts) === null || o === void 0 ? void 0 : o.formatHover) !== null && l !== void 0 ? l : this.formatMessage)(d);
      return {
        pos: a,
        end: u,
        arrow: !0,
        // to mimic similar modes for other editors
        // otherwise, it gets into a z-index battle with completion/etc
        above: !0,
        create: (y) => ({
          dom: m
        })
      };
    } catch (c) {
      return Yn.log(c), null;
    }
  }
}
function _0e(t) {
  return [
    Ihe(),
    vD(Mhe()),
    vD(y0e(), {
      needsRefresh: m0e
    }),
    BN.data.of({
      autocomplete: f0e()
    }),
    sM(x0e()),
    xie(t)
  ];
}
function k0e() {
  return [
    lZ(),
    cZ(),
    DJ(),
    ute(),
    yJ(),
    _J(),
    nn.allowMultipleSelections.of(!0),
    $Z(),
    wM(UZ, { fallback: !0 }),
    XZ(),
    jee(),
    Jee(),
    zJ(),
    UJ(),
    PJ(),
    Fre(),
    $e.domEventHandlers({
      keydown(t) {
        t.stopPropagation();
      }
    }),
    Uv.of([
      ...Vee,
      ...hne,
      ...Yre,
      ...bte,
      ...NM,
      ...yre,
      { key: "Tab", preventDefault: !0, run: une },
      { key: "Shift-Tab", preventDefault: !0, run: gP }
    ])
  ];
}
function C0e(t, e) {
  const n = $e.theme({
    "&.cm-editor": { height: "100%" },
    ".cm-scroller": { overflow: "auto" },
    "&.cm-focused": { outline: "none" },
    ".cm-tooltip": {
      boxShadow: e.colorScheme == "light" ? "0 2px 5px rgba(0,0,0,0.2)" : "0 2px 5px rgba(0,0,0,1)"
    },
    ".cm6-json-schema-hover": { padding: "6px" }
  }), r = $e.updateListener.of((o) => {
    if (o.docChanged && e.onChange) {
      const l = o.state.doc.toString();
      e.onChange(l);
    }
  }), i = [];
  if (e.language == "json" && i.push(_0e(e.json?.schema ?? {})), e.language == "sql") {
    let o = e.sql?.table, l = e.sql?.columns;
    i.push(are({
      dialect: ure,
      upperCaseKeywords: !0,
      schema: o != null ? {
        [o]: l?.map((a) => ({ label: a.name, detail: a.type, type: "property" })) ?? []
      } : void 0,
      defaultTable: o
    }));
  }
  const s = new $e({
    doc: e.initialText,
    parent: t,
    extensions: [
      // Basic setup
      ...k0e(),
      // Tooltip parent element
      HJ({ parent: t.parentElement }),
      // Langauge
      ...i,
      // Theme and styling
      ...e.colorScheme == "dark" ? [uie] : [],
      n,
      // Change
      r
    ]
  });
  return {
    set: (o) => {
      s.dispatch({
        changes: { from: 0, to: s.state.doc.length, insert: o }
      });
    },
    destroy: () => {
      s.destroy();
    }
  };
}
var S0e = /* @__PURE__ */ ge('<div><div class="rounded-md overflow-hidden border border-slate-200 dark:border-slate-600 w-full h-full"></div></div>');
function D5(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]), r;
  Vo(() => {
    let o = Gs(() => e.value) ?? "", l = C0e(r, {
      language: e.language ?? "plain",
      colorScheme: e.colorScheme ?? "light",
      initialText: Gs(() => e.value) ?? "",
      json: e.json,
      sql: e.sql,
      onChange: (a) => {
        o = a, e.onChange?.(a);
      }
    });
    return pt(() => {
      e.value != null && e.value != o && (o = n.value, l.set(o));
    }), () => {
      l.destroy();
    };
  });
  var i = S0e(), s = J(i);
  Yo(s, (o) => r = o, () => r), Q(i), ke(() => er(i, 1, Lv(e.class ?? ""))), X(t, i), st();
}
var A0e = /* @__PURE__ */ ge('<div class="w-full h-full flex flex-col gap-2"><!> <div class="flex-none flex gap-2 items-center"><button>Confirm</button> <div class="flex-1 w-0 overflow-hidden text-nowrap text-ellipsis"> </div></div></div>');
function E0e(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ Ee(void 0), r = /* @__PURE__ */ K(() => x(n)?.spec !== void 0);
  function i(p) {
    try {
      return { spec: JSON.parse(p) };
    } catch (m) {
      return { message: m.message?.toString() };
    }
  }
  function s() {
    x(n) && x(n).spec != null && e.onSpecChange?.(x(n).spec);
  }
  var o = A0e(), l = J(o);
  {
    let p = /* @__PURE__ */ K(() => JSON.stringify(e.spec, null, 2));
    D5(l, {
      class: "w-full flex-1 min-h-0",
      get colorScheme() {
        return e.colorScheme;
      },
      language: "json",
      get value() {
        return x(p);
      },
      onChange: (m) => {
        ae(n, i(m), !0);
      }
    });
  }
  var a = ue(l, 2), u = J(a);
  let c;
  u.__click = s;
  var f = ue(u, 2), d = J(f, !0);
  Q(f), Q(a), Q(o), ke(() => {
    c = er(u, 1, "flex-none px-2 h-8 w-24 rounded-md text-white text-sm", null, c, {
      "bg-blue-500": x(r),
      "bg-gray-300": !x(r),
      "dark:text-gray-500": !x(r),
      "dark:bg-gray-700": !x(r)
    }), u.disabled = !x(r), te(f, "title", x(n)?.message ?? ""), ut(d, x(n)?.message ?? "");
  }), X(t, o), st();
}
ir(["click"]);
var D0e = /* @__PURE__ */ ge('<span class="mx-1"> </span>'), O0e = /* @__PURE__ */ ge("<button><!> <!></button>");
function uy(t, e) {
  it(e, !0);
  let n = ct(e, "label", 3, null), r = ct(e, "icon", 3, null), i = ct(e, "title", 3, ""), s = ct(e, "order", 3, null);
  var o = O0e();
  o.__click = () => {
    e.onClick?.();
  };
  let l;
  var a = J(o);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(r);
      var m = kn(), y = We(m);
      Yd(y, () => x(p), (b, v) => {
        v(b, { class: "w-4 h-4" });
      }), X(d, m);
    };
    Fe(a, (d) => {
      r() != null && d(u);
    });
  }
  var c = ue(a, 2);
  {
    var f = (d) => {
      var p = D0e(), m = J(p, !0);
      Q(p), ke(() => ut(m, n())), X(d, p);
    };
    Fe(c, (d) => {
      n() != null && n() != "" && d(f);
    });
  }
  Q(o), ke(() => {
    er(o, 1, `rounded-md flex select-none items-center px-1 py-1 text-slate-500 bg-slate-100 dark:text-slate-400 dark:bg-slate-800 focus-visible:outline-2 outline-blue-600 -outline-offset-1 ${e.class ?? "" ?? ""}`), te(o, "title", i()), l = ht(o, "", l, { order: s() });
  }), X(t, o), st();
}
ir(["click"]);
var F0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M3.2 5.74a.75.75 0 0 1 1.06-.04L8 9.227L11.74 5.7a.75.75 0 1 1 1.02 1.1l-4.25 4a.75.75 0 0 1-1.02 0l-4.25-4a.75.75 0 0 1-.04-1.06"></path></svg>');
function l9(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = F0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var T0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M3.2 10.26a.75.75 0 0 0 1.06.04L8 6.773l3.74 3.527a.75.75 0 1 0 1.02-1.1l-4.25-4a.75.75 0 0 0-1.02 0l-4.25 4a.75.75 0 0 0-.04 1.06"></path></svg>');
function a9(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = T0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var R0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M2.75 2a.75.75 0 0 1 .75.75v12.5c0 .69.56 1.25 1.25 1.25h12.5a.75.75 0 0 1 0 1.5H4.75A2.75 2.75 0 0 1 2 15.25V2.75A.75.75 0 0 1 2.75 2M10 7.5a2.5 2.5 0 1 1-5 0a2.5 2.5 0 0 1 5 0m4.5.5a2.5 2.5 0 1 0 0-5a2.5 2.5 0 0 0 0 5m.5 4.5a2.5 2.5 0 1 1-5 0a2.5 2.5 0 0 1 5 0"></path></svg>');
function M0e(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = R0e();
  Ys(r, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var P0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="m2.397 2.554l.073-.084a.75.75 0 0 1 .976-.073l.084.073L8 6.939l4.47-4.47a.75.75 0 1 1 1.06 1.061L9.061 8l4.47 4.47a.75.75 0 0 1 .072.976l-.073.084a.75.75 0 0 1-.976.073l-.084-.073L8 9.061l-4.47 4.47a.75.75 0 0 1-1.06-1.061L6.939 8l-4.47-4.47a.75.75 0 0 1-.072-.976l.073-.084z"></path></svg>');
function _2(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = P0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var I0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M9 1H6a2 2 0 0 0-2 2v2.205a5.5 5.5 0 0 1 4.666 9.791H12a2 2 0 0 0 2-2V6.001h-3.5A1.5 1.5 0 0 1 9 4.5zm4.997 4h-3.498a.5.5 0 0 1-.5-.5V1h.01zM10 10.5a4.5 4.5 0 1 1-9 0a4.5 4.5 0 0 1 9 0m-4.854 2.353l.003.003a.5.5 0 0 0 .348.144h.006a.5.5 0 0 0 .35-.146l2-2a.5.5 0 0 0-.707-.708L6 11.293V8.5a.5.5 0 0 0-1 0v2.793l-1.146-1.147a.5.5 0 0 0-.708.708z"></path></svg>');
function u9(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = I0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var N0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M10.529 1.764a2.621 2.621 0 1 1 3.707 3.707l-.779.779L9.75 2.543zM9.043 3.25L2.657 9.636a2.96 2.96 0 0 0-.772 1.354l-.87 3.386a.5.5 0 0 0 .61.608l3.385-.869a2.95 2.95 0 0 0 1.354-.772l6.386-6.386z"></path></svg>');
function BB(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = N0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var B0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M2 6a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3zm3-2a2 2 0 0 0-2 2v5h14V6a2 2 0 0 0-2-2z"></path></svg>');
function L0e(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = B0e();
  Ys(r, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var $0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M15 3a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3zM5 4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h6.5V4z"></path></svg>');
function z0e(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = $0e();
  Ys(r, () => ({ viewBox: "0 0 20 20", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var j0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M10.823 11.883a5.5 5.5 0 1 1 1.06-1.06l2.897 2.897a.75.75 0 1 1-1.06 1.06zM11.5 7.5a4 4 0 1 0-8 0a4 4 0 0 0 8 0"></path></svg>');
function q0e(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = j0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var U0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M2.267 6.153A6 6 0 0 1 3.53 3.98a.36.36 0 0 1 .382-.095l1.36.484a.71.71 0 0 0 .935-.538l.26-1.416a.35.35 0 0 1 .274-.282a6.1 6.1 0 0 1 2.52 0c.14.03.248.141.274.282l.26 1.416a.708.708 0 0 0 .935.538l1.36-.484a.36.36 0 0 1 .382.095a6 6 0 0 1 1.262 2.173a.35.35 0 0 1-.108.378l-1.102.931a.703.703 0 0 0 0 1.076l1.102.931c.11.093.152.242.108.378a6 6 0 0 1-1.262 2.173a.36.36 0 0 1-.382.095l-1.36-.484a.71.71 0 0 0-.935.538l-.26 1.416a.35.35 0 0 1-.275.282a6.1 6.1 0 0 1-2.519 0a.35.35 0 0 1-.275-.282l-.259-1.416a.708.708 0 0 0-.935-.538l-1.36.484a.36.36 0 0 1-.382-.095a6 6 0 0 1-1.262-2.173a.35.35 0 0 1 .108-.378l1.102-.931a.704.704 0 0 0 0-1.076l-1.102-.931a.35.35 0 0 1-.108-.378M6.25 8a1.75 1.75 0 1 0 3.5 0a1.75 1.75 0 0 0-3.5 0"></path></svg>');
function LB(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = U0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var H0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M7.456 2a6 6 0 1 1-5.406 8.605a.5.5 0 0 1 .36-.71c1.276-.231 3.278-.937 4.078-3.07c.563-1.5.512-3.015.283-4.23a.5.5 0 0 1 .475-.591Q7.35 2 7.456 2"></path></svg>');
function V0e(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = H0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var W0e = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M8 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 8 1m0 10a3 3 0 1 0 0-6a3 3 0 0 0 0 6m6.5-2.5a.5.5 0 0 0 0-1h-1a.5.5 0 0 0 0 1zM8 13a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 8 13M2.5 8.5a.5.5 0 0 0 0-1h-1a.5.5 0 0 0 0 1zm.646-5.354a.5.5 0 0 1 .708 0l1 1a.5.5 0 1 1-.708.708l-1-1a.5.5 0 0 1 0-.708m.708 9.708a.5.5 0 1 1-.708-.707l1-1a.5.5 0 0 1 .708.707zm9-9.708a.5.5 0 0 0-.708 0l-1 1a.5.5 0 0 0 .708.708l1-1a.5.5 0 0 0 0-.708m-.708 9.708a.5.5 0 0 0 .708-.707l-1-1a.5.5 0 0 0-.708.707z"></path></svg>');
function G0e(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = W0e();
  Ys(r, () => ({ viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
var K0e = /* @__PURE__ */ ge('<div class="text-sm pr-0.5"><!></div>'), Y0e = /* @__PURE__ */ ge('<div class="text-sm pr-0.5"><!></div>'), X0e = /* @__PURE__ */ ge('<div class="h-64"><div class="w-full h-64 p-2"><!></div></div>'), Q0e = /* @__PURE__ */ ge('<div class="px-2 pt-2 flex items-center"><button class="font-mono font-medium py-0.5 text-left flex flex-1 mr-2 overflow-hidden items-center"><!> <div class="flex-1 whitespace-nowrap overflow-hidden text-ellipsis"> </div></button> <div class="flex-none flex gap-1 sm:opacity-0 group-hover:opacity-100 pr-0.5"><!> <!> <!> <!></div></div> <div><div class="overflow-hidden"><!> <!></div></div>', 1);
function c9(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ Ee(!1);
  var r = Q0e(), i = We(r), s = J(i);
  s.__click = () => e.onIsVisibleChange?.(!e.isVisible);
  var o = J(s);
  {
    var l = ($) => {
      var P = K0e(), B = J(P);
      a9(B, {}), Q(P), X($, P);
    }, a = ($) => {
      var P = Y0e(), B = J(P);
      l9(B, {}), Q(P), X($, P);
    };
    Fe(o, ($) => {
      e.isVisible ? $(l) : $(a, !1);
    });
  }
  var u = ue(o, 2), c = J(u, !0);
  Q(u), Q(s);
  var f = ue(s, 2), d = J(f);
  {
    var p = ($) => {
      uy($, {
        get icon() {
          return BB;
        },
        title: "Edit spec",
        onClick: () => ae(n, !x(n))
      });
    };
    Fe(d, ($) => {
      e.onSpecChange && $(p);
    });
  }
  var m = ue(d, 2);
  {
    var y = ($) => {
      uy($, {
        get icon() {
          return a9;
        },
        title: "Move up",
        get onClick() {
          return e.onUp;
        }
      });
    };
    Fe(m, ($) => {
      e.onUp && $(y);
    });
  }
  var b = ue(m, 2);
  {
    var v = ($) => {
      uy($, {
        get icon() {
          return l9;
        },
        title: "Move down",
        get onClick() {
          return e.onDown;
        }
      });
    };
    Fe(b, ($) => {
      e.onDown && $(v);
    });
  }
  var _ = ue(b, 2);
  {
    var k = ($) => {
      uy($, {
        get icon() {
          return _2;
        },
        title: "Close",
        onClick: () => e.onRemove()
      });
    };
    Fe(_, ($) => {
      e.onRemove && $(k);
    });
  }
  Q(f), Q(i);
  var S = ue(i, 2);
  let C;
  var E = J(S), A = J(E);
  Xa(A, () => e.chartView, () => ({ id: e.id, width: "container" }));
  var O = ue(A, 2);
  {
    var T = ($) => {
      var P = X0e(), B = J(P), M = J(B);
      E0e(M, {
        get spec() {
          return e.spec;
        },
        get colorScheme() {
          return e.colorScheme;
        },
        onSpecChange: (L) => {
          e.onSpecChange(L), ae(n, !1);
        }
      }), Q(B), Q(P), cp(3, P, () => fp), X($, P);
    };
    Fe(O, ($) => {
      x(n) && e.onSpecChange && $(T);
    });
  }
  Q(E), Q(S), ke(() => {
    ut(c, e.spec.title), C = ht(S, "", C, {
      display: "grid",
      "grid-template-rows": e.isVisible ? "1fr" : "0fr",
      transition: "grid-template-rows 300ms ease-in-out"
    });
  }), X(t, r), st();
}
ir(["click"]);
function J0e(t) {
  switch (t.type) {
    case "embedding":
      return "embedding";
    case "table":
      return "table";
    default:
      return "chart";
  }
}
function $B(t) {
  let e = { embedding: [], table: [], chart: [] };
  for (let n in t) {
    let r = J0e(t[n]);
    r != null && e[r].push(n);
  }
  return e;
}
var Z0e = /* @__PURE__ */ ge('<div class="flex-1 overflow-hidden rounded-md"><!></div>'), epe = /* @__PURE__ */ ge('<div class="flex flex-row gap-2 flex-1 overflow-hidden"></div>'), tpe = /* @__PURE__ */ ge('<div class="flex-1 h-full overflow-hidden rounded-md"><!></div>'), npe = /* @__PURE__ */ ge("<div></div>"), rpe = /* @__PURE__ */ ge('<div class="flex-1 flex flex-col overflow-hidden"><!> <!> <!></div>'), ipe = /* @__PURE__ */ ge('<div class="bg-white dark:bg-black rounded-md flex flex-col gap-2 group"><!></div>'), spe = /* @__PURE__ */ ge('<div class="h-full overflow-x-hidden overflow-y-scroll"><div class="flex flex-row flex-wrap gap-2"><button class="bg-white dark:bg-black rounded-md flex flex-col justify-center items-center gap-2 p-2 w-full text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-slate-100">+ Add</button> <!></div></div>'), ope = /* @__PURE__ */ ge("<!> <!> <!>", 1), lpe = /* @__PURE__ */ ge('<div class="bg-white dark:bg-black rounded-md flex flex-col gap-2 group"><!></div>'), ape = /* @__PURE__ */ ge('<div class="w-full h-full overflow-y-scroll flex flex-col gap-2"></div>'), upe = /* @__PURE__ */ ge('<div class="w-full h-full flex flex-row"><!></div>');
function cpe(t, e) {
  it(e, !0);
  const n = () => gi(s, "$colorScheme", r), [r, i] = Xs();
  let { colorScheme: s } = e.context, o = /* @__PURE__ */ Ee(100), l = /* @__PURE__ */ Ee(100), a = /* @__PURE__ */ Ee(300), u = /* @__PURE__ */ Ee(400), c = /* @__PURE__ */ K(nA(() => $B(e.charts))), f = /* @__PURE__ */ K(() => x(o) < 500), d = /* @__PURE__ */ K(() => x(c).embedding.length > 0 && (e.state.showEmbedding ?? !0)), p = /* @__PURE__ */ K(() => x(c).table.length > 0 && (e.state.showTable ?? !0)), m = /* @__PURE__ */ K(() => e.state.showCharts ?? !0);
  function y(A, O) {
    let $ = Math.round((A + 7) / (O + 7)), P, B;
    for (let M = Math.max(1, $ - 1); M <= Math.max(1, $ + 1); M++) {
      let L = (A - 7 * (M - 1)) / M, N = Math.abs(L - O);
      (P == null || N < P) && (P = N, B = L);
    }
    return Math.floor((B ?? 400) * 2) / 2;
  }
  let b = /* @__PURE__ */ K(nA(() => {
    let A = e.state.chartsOrder ?? [], O = x(c).chart.slice();
    return O.sort((T, $) => {
      let P = A.indexOf(T), B = A.indexOf($);
      return P == -1 && (P = O.length), B == -1 && (B = O.length), P - B;
    }), O;
  }));
  function v(A, O) {
    let T = [...x(b)], $ = T.indexOf(A);
    if ($ == -1)
      return;
    let P = $ + O;
    P < 0 || P >= T.length || ([T[$], T[P]] = [T[P], T[$]], e.onStateChange({ chartsOrder: T }));
  }
  function _(A) {
    e.onChartsChange({ [A]: void 0 }), e.onChartStatesChange({ [A]: void 0 });
  }
  var k = upe(), S = J(k);
  {
    var C = (A) => {
      var O = ope(), T = We(O);
      {
        var $ = (N) => {
          var j = rpe(), U = J(j);
          {
            var H = (ne) => {
              var ce = epe();
              Bt(ce, 20, () => x(c).embedding, (we) => we, (we, Me) => {
                var Pe = Z0e(), Ce = J(Pe);
                Xa(Ce, () => e.chartView, () => ({ id: Me, width: "container", height: "container" })), Q(Pe), X(we, Pe);
              }), Q(ce), X(ne, ce);
            };
            Fe(U, (ne) => {
              x(d) && ne(H);
            });
          }
          var G = ue(U, 2);
          {
            var re = (ne) => {
              {
                let ce = /* @__PURE__ */ K(() => x(l) - 100);
                CA(ne, {
                  class: "h-2 flex-none",
                  axis: "y",
                  min: 100,
                  get max() {
                    return x(ce);
                  },
                  scaler: -1,
                  get value() {
                    return x(a);
                  },
                  onChange: (we) => ae(a, we, !0)
                });
              }
            };
            Fe(G, (ne) => {
              x(d) && x(p) && ne(re);
            });
          }
          var se = ue(G, 2);
          {
            var oe = (ne) => {
              var ce = npe();
              let we;
              Bt(ce, 20, () => x(c).table, (Me) => Me, (Me, Pe) => {
                var Ce = tpe(), fe = J(Ce);
                Xa(fe, () => e.chartView, () => ({ id: Pe, width: "container", height: "container" })), Q(Ce), X(Me, Ce);
              }), Q(ce), ke(() => {
                er(ce, 1, Lv(x(d) ? "flex-none" : "flex-1")), we = ht(ce, "", we, {
                  height: x(d) ? `${x(a)}px` : null
                });
              }), cp(3, ce, () => fp), X(ne, ce);
            };
            Fe(se, (ne) => {
              x(p) && ne(oe);
            });
          }
          Q(j), X(N, j);
        };
        Fe(T, (N) => {
          (x(d) || x(p)) && N($);
        });
      }
      var P = ue(T, 2);
      {
        var B = (N) => {
          {
            let j = /* @__PURE__ */ K(() => x(o) - 100);
            CA(N, {
              class: "w-2 flex-none",
              axis: "x",
              min: 100,
              get max() {
                return x(j);
              },
              scaler: -1,
              get value() {
                return x(u);
              },
              onChange: (U) => ae(u, U, !0)
            });
          }
        };
        Fe(P, (N) => {
          (x(d) || x(p)) && x(m) && N(B);
        });
      }
      var M = ue(P, 2);
      {
        var L = (N) => {
          const j = /* @__PURE__ */ K(() => x(d) || x(p) ? x(u) : x(o));
          var U = spe();
          let H;
          var G = J(U);
          let re;
          var se = J(G);
          se.__click = () => {
            let ne = hX(e.charts);
            e.onChartsChange({ [ne]: { type: "builder", title: "New" } }), e.onStateChange({ chartsOrder: [ne, ...x(b)] });
          };
          var oe = ue(se, 2);
          Bt(oe, 26, () => x(b), (ne) => ne, (ne, ce, we) => {
            const Me = /* @__PURE__ */ K(() => e.charts[ce]), Pe = /* @__PURE__ */ K(() => e.state.chartVisibility?.[ce] ?? !0);
            var Ce = ipe();
            let fe;
            var De = J(Ce);
            {
              let Se = /* @__PURE__ */ K(() => _.bind(null, ce)), Ne = /* @__PURE__ */ K(() => x(we) > 0 ? v.bind(null, ce, -1) : void 0), Ye = /* @__PURE__ */ K(() => x(we) + 1 < x(b).length ? v.bind(null, ce, 1) : void 0);
              c9(De, {
                get id() {
                  return ce;
                },
                get spec() {
                  return x(Me);
                },
                onIsVisibleChange: (Ge) => {
                  e.onStateChange({ chartVisibility: { [ce]: Ge } });
                },
                get isVisible() {
                  return x(Pe);
                },
                get colorScheme() {
                  return n();
                },
                get chartView() {
                  return e.chartView;
                },
                get onRemove() {
                  return x(Se);
                },
                get onUp() {
                  return x(Ne);
                },
                get onDown() {
                  return x(Ye);
                },
                onSpecChange: (Ge) => {
                  e.onChartsChange({ [ce]: void 0 }), e.onChartStatesChange({ [ce]: void 0 }), e.onChartsChange({ [ce]: Ge });
                }
              });
            }
            Q(Ce), ke((Se) => fe = ht(Ce, "", fe, Se), [
              () => ({ width: `${y(x(j), 500) ?? ""}px` })
            ]), xA(Ce, () => kA, () => ({ duration: 300 })), cp(2, Ce, () => fp), X(ne, Ce);
          }), Q(G), Q(U), ke(() => {
            H = ht(U, "", H, { width: `${x(j) ?? ""}px` }), re = ht(G, "", re, { width: `${x(j) ?? ""}px` });
          }), cp(3, U, () => fp, () => ({ axis: "x" })), X(N, U);
        };
        Fe(M, (N) => {
          x(m) && N(L);
        });
      }
      X(A, O);
    }, E = (A) => {
      var O = ape();
      Bt(O, 30, () => x(c).embedding.concat(x(b), x(c).table), (T) => T, (T, $) => {
        const P = /* @__PURE__ */ K(() => e.state.chartVisibility?.[$] ?? !0), B = /* @__PURE__ */ K(() => x(b).indexOf($));
        var M = lpe(), L = J(M);
        {
          let N = /* @__PURE__ */ K(() => _.bind(null, $)), j = /* @__PURE__ */ K(() => x(B) > 0 ? v.bind(null, $, -1) : void 0), U = /* @__PURE__ */ K(() => x(B) != -1 && x(B) + 1 < x(b).length ? v.bind(null, $, 1) : void 0);
          c9(L, {
            get id() {
              return $;
            },
            get spec() {
              return e.charts[$];
            },
            onIsVisibleChange: (H) => {
              e.onStateChange({ chartVisibility: { [$]: H } });
            },
            get isVisible() {
              return x(P);
            },
            get colorScheme() {
              return n();
            },
            get chartView() {
              return e.chartView;
            },
            get onRemove() {
              return x(N);
            },
            get onUp() {
              return x(j);
            },
            get onDown() {
              return x(U);
            }
          });
        }
        Q(M), xA(M, () => kA, () => ({ duration: 300 })), cp(2, M, () => fp), X(T, M);
      }), Q(O), X(A, O);
    };
    Fe(S, (A) => {
      x(f) ? A(E, !1) : A(C);
    });
  }
  Q(k), Ko(k, "clientWidth", (A) => ae(o, A)), Ko(k, "clientHeight", (A) => ae(l, A)), X(t, k), st(), i();
}
ir(["click"]);
var fpe = /* @__PURE__ */ ge('<span class="flex h-5 items-center"> </span>'), hpe = /* @__PURE__ */ ge("<button><!> <!></button>");
function Jy(t, e) {
  it(e, !0);
  let n = ct(e, "title", 3, ""), r = ct(e, "checked", 15), i = ct(e, "label", 3, null), s = ct(e, "icon", 3, null);
  var o = hpe();
  let l;
  o.__click = () => {
    r(!r());
  };
  var a = J(o);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(s);
      var m = kn(), y = We(m);
      Yd(y, () => x(p), (b, v) => {
        v(b, { class: "w-5 h-5" });
      }), X(d, m);
    };
    Fe(a, (d) => {
      s() != null && d(u);
    });
  }
  var c = ue(a, 2);
  {
    var f = (d) => {
      var p = fpe(), m = J(p, !0);
      Q(p), ke(() => ut(m, i())), X(d, p);
    };
    Fe(c, (d) => {
      i() != null && d(f);
    });
  }
  Q(o), ke(() => {
    l = er(o, 1, "rounded-md px-1.5 py-1.5 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 flex select-none items-center focus-visible:outline-2 outline-blue-600 -outline-offset-1", null, l, {
      "text-slate-400": !r(),
      "dark:text-slate-500": !r()
    }), te(o, "title", n());
  }), X(t, o), st();
}
ir(["click"]);
var dpe = /* @__PURE__ */ ge("<!> <!> <!>", 1);
function f9(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ K(() => $B(e.charts));
  var r = dpe(), i = We(r);
  {
    var s = (d) => {
      var p = () => e.state.showEmbedding ?? !0, m = (y) => {
        e.onStateChange({ showEmbedding: y });
      };
      Jy(d, {
        get icon() {
          return M0e;
        },
        title: "Show / hide embedding",
        get checked() {
          return p();
        },
        set checked(y) {
          m(y);
        }
      });
    };
    Fe(i, (d) => {
      x(n).embedding.length > 0 && d(s);
    });
  }
  var o = ue(i, 2), l = () => e.state.showTable ?? !0, a = (d) => {
    e.onStateChange({ showTable: d });
  };
  Jy(o, {
    get icon() {
      return L0e;
    },
    title: "Show / hide table",
    get checked() {
      return l();
    },
    set checked(d) {
      a(d);
    }
  });
  var u = ue(o, 2), c = () => e.state.showCharts ?? !0, f = (d) => {
    e.onStateChange({ showCharts: d });
  };
  Jy(u, {
    get icon() {
      return z0e;
    },
    title: "Show / hide charts",
    get checked() {
      return c();
    },
    set checked(d) {
      f(d);
    }
  }), X(t, r), st();
}
const nd = {
  list: [cpe, f9],
  grid: [aX, f9]
};
function ppe(t) {
  return nd[t] == null ? nd.list[0] : nd[t][0];
}
function gpe(t) {
  return nd[t] == null ? nd.list[1] : nd[t][1];
}
function mpe(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ K(() => gpe(e.layout)), r = /* @__PURE__ */ K(() => e.layoutStates[e.layout] ?? {});
  function i(u, c = "merge") {
    dd(e.charts, u, c, (f) => e.onChartsChange?.(f));
  }
  function s(u, c = "merge") {
    dd(e.chartStates, u, c, (f) => e.onChartStatesChange?.(f));
  }
  function o(u, c, f = "merge") {
    Cy(e.layoutStates, u, c, f, (d) => e.onLayoutStatesChange?.(d));
  }
  var l = kn(), a = We(l);
  {
    let u = /* @__PURE__ */ K(() => o.bind(null, e.layout));
    Yd(a, () => x(n), (c, f) => {
      f(c, {
        get context() {
          return e.context;
        },
        get charts() {
          return e.charts;
        },
        get state() {
          return x(r);
        },
        get onStateChange() {
          return x(u);
        },
        onChartsChange: i,
        onChartStatesChange: s
      });
    });
  }
  X(t, l), st();
}
var ype = /* @__PURE__ */ ge("<div><!></div>");
function yc(t, e) {
  let n = ct(e, "defaultWidth", 3, null), r = ct(e, "defaultHeight", 3, null), i = ct(e, "scrollX", 3, !1), s = ct(e, "scrollY", 3, !1), o = /* @__PURE__ */ K(() => e.width != null ? e.width : i() ? void 0 : n()), l = /* @__PURE__ */ K(() => e.height != null ? e.height : s() ? void 0 : r());
  var a = ype();
  let u;
  var c = J(a);
  Xa(c, () => e.children), Q(a), ke(() => {
    er(a, 1, `p-2 ${e.class ?? "" ?? ""}`), u = ht(a, "", u, {
      width: x(o) != null ? `${x(o)}px` : void 0,
      height: x(l) != null ? `${x(l)}px` : void 0,
      "overflow-x": i() && e.width != null ? "auto" : void 0,
      "overflow-y": s() && e.height != null ? "auto" : void 0
    });
  }), X(t, a);
}
var bpe = /* @__PURE__ */ ge("<div><!></div>");
function pm(t, e) {
  let n = /* @__PURE__ */ Ee(300), r = /* @__PURE__ */ Ee(200), i = ct(e, "flexHeight", 3, !0), s = ct(e, "defaultHeight", 3, 200);
  var o = bpe();
  let l;
  var a = J(o);
  Xa(a, () => e.children ?? zt, () => x(n), () => x(r)), Q(o), ke(() => {
    er(o, 1, Lv(i() ? "flex-1 min-h-0" : void 0)), l = ht(o, "", l, {
      "user-select": "none",
      position: "relative",
      height: i() ? void 0 : `${s()}px`
    });
  }), Ko(o, "clientWidth", (u) => ae(n, u)), Ko(o, "clientHeight", (u) => ae(r, u)), X(t, o);
}
function vpe(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function sv(t, e) {
  if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
  var n, r = t.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +t.slice(n + 1)
  ];
}
function Md(t) {
  return t = sv(Math.abs(t)), t ? t[1] : NaN;
}
function xpe(t, e) {
  return function(n, r) {
    for (var i = n.length, s = [], o = 0, l = t[0], a = 0; i > 0 && l > 0 && (a + l + 1 > r && (l = Math.max(1, r - a)), s.push(n.substring(i -= l, i + l)), !((a += l + 1) > r)); )
      l = t[o = (o + 1) % t.length];
    return s.reverse().join(e);
  };
}
function wpe(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(n) {
      return t[+n];
    });
  };
}
var _pe = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Og(t) {
  if (!(e = _pe.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new O5({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
Og.prototype = O5.prototype;
function O5(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
O5.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function kpe(t) {
  e: for (var e = t.length, n = 1, r = -1, i; n < e; ++n)
    switch (t[n]) {
      case ".":
        r = i = n;
        break;
      case "0":
        r === 0 && (r = n), i = n;
        break;
      default:
        if (!+t[n]) break e;
        r > 0 && (r = 0);
        break;
    }
  return r > 0 ? t.slice(0, r) + t.slice(i + 1) : t;
}
var zB;
function Cpe(t, e) {
  var n = sv(t, e);
  if (!n) return t + "";
  var r = n[0], i = n[1], s = i - (zB = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, o = r.length;
  return s === o ? r : s > o ? r + new Array(s - o + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + sv(t, Math.max(0, e + s - 1))[0];
}
function h9(t, e) {
  var n = sv(t, e);
  if (!n) return t + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const d9 = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: vpe,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => h9(t * 100, e),
  r: h9,
  s: Cpe,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function p9(t) {
  return t;
}
var g9 = Array.prototype.map, m9 = ["y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Spe(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? p9 : xpe(g9.call(t.grouping, Number), t.thousands + ""), n = t.currency === void 0 ? "" : t.currency[0] + "", r = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", s = t.numerals === void 0 ? p9 : wpe(g9.call(t.numerals, String)), o = t.percent === void 0 ? "%" : t.percent + "", l = t.minus === void 0 ? "âˆ’" : t.minus + "", a = t.nan === void 0 ? "NaN" : t.nan + "";
  function u(f) {
    f = Og(f);
    var d = f.fill, p = f.align, m = f.sign, y = f.symbol, b = f.zero, v = f.width, _ = f.comma, k = f.precision, S = f.trim, C = f.type;
    C === "n" ? (_ = !0, C = "g") : d9[C] || (k === void 0 && (k = 12), S = !0, C = "g"), (b || d === "0" && p === "=") && (b = !0, d = "0", p = "=");
    var E = y === "$" ? n : y === "#" && /[boxX]/.test(C) ? "0" + C.toLowerCase() : "", A = y === "$" ? r : /[%p]/.test(C) ? o : "", O = d9[C], T = /[defgprs%]/.test(C);
    k = k === void 0 ? 6 : /[gprs]/.test(C) ? Math.max(1, Math.min(21, k)) : Math.max(0, Math.min(20, k));
    function $(P) {
      var B = E, M = A, L, N, j;
      if (C === "c")
        M = O(P) + M, P = "";
      else {
        P = +P;
        var U = P < 0 || 1 / P < 0;
        if (P = isNaN(P) ? a : O(Math.abs(P), k), S && (P = kpe(P)), U && +P == 0 && m !== "+" && (U = !1), B = (U ? m === "(" ? m : l : m === "-" || m === "(" ? "" : m) + B, M = (C === "s" ? m9[8 + zB / 3] : "") + M + (U && m === "(" ? ")" : ""), T) {
          for (L = -1, N = P.length; ++L < N; )
            if (j = P.charCodeAt(L), 48 > j || j > 57) {
              M = (j === 46 ? i + P.slice(L + 1) : P.slice(L)) + M, P = P.slice(0, L);
              break;
            }
        }
      }
      _ && !b && (P = e(P, 1 / 0));
      var H = B.length + P.length + M.length, G = H < v ? new Array(v - H + 1).join(d) : "";
      switch (_ && b && (P = e(G + P, G.length ? v - M.length : 1 / 0), G = ""), p) {
        case "<":
          P = B + P + M + G;
          break;
        case "=":
          P = B + G + P + M;
          break;
        case "^":
          P = G.slice(0, H = G.length >> 1) + B + P + M + G.slice(H);
          break;
        default:
          P = G + B + P + M;
          break;
      }
      return s(P);
    }
    return $.toString = function() {
      return f + "";
    }, $;
  }
  function c(f, d) {
    var p = u((f = Og(f), f.type = "f", f)), m = Math.max(-8, Math.min(8, Math.floor(Md(d) / 3))) * 3, y = Math.pow(10, -m), b = m9[8 + m / 3];
    return function(v) {
      return p(y * v) + b;
    };
  }
  return {
    format: u,
    formatPrefix: c
  };
}
var cy, su, jB;
Ape({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Ape(t) {
  return cy = Spe(t), su = cy.format, jB = cy.formatPrefix, cy;
}
function Epe(t) {
  return Math.max(0, -Md(Math.abs(t)));
}
function Dpe(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Md(e) / 3))) * 3 - Md(Math.abs(t)));
}
function Ope(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, Md(e) - Md(t)) + 1;
}
function Zy(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Fpe(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function qB(t) {
  let e, n, r;
  t.length !== 2 ? (e = Zy, n = (l, a) => Zy(t(l), a), r = (l, a) => t(l) - a) : (e = t === Zy || t === Fpe ? t : Tpe, n = t, r = t);
  function i(l, a, u = 0, c = l.length) {
    if (u < c) {
      if (e(a, a) !== 0) return c;
      do {
        const f = u + c >>> 1;
        n(l[f], a) < 0 ? u = f + 1 : c = f;
      } while (u < c);
    }
    return u;
  }
  function s(l, a, u = 0, c = l.length) {
    if (u < c) {
      if (e(a, a) !== 0) return c;
      do {
        const f = u + c >>> 1;
        n(l[f], a) <= 0 ? u = f + 1 : c = f;
      } while (u < c);
    }
    return u;
  }
  function o(l, a, u = 0, c = l.length) {
    const f = i(l, a, u, c - 1);
    return f > u && r(l[f - 1], a) > -r(l[f], a) ? f - 1 : f;
  }
  return { left: i, center: o, right: s };
}
function Tpe() {
  return 0;
}
function Rpe(t) {
  return t === null ? NaN : +t;
}
const Mpe = qB(Zy), Ppe = Mpe.right;
qB(Rpe).center;
class y9 extends Map {
  constructor(e, n = Bpe) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), e != null) for (const [r, i] of e) this.set(r, i);
  }
  get(e) {
    return super.get(b9(this, e));
  }
  has(e) {
    return super.has(b9(this, e));
  }
  set(e, n) {
    return super.set(Ipe(this, e), n);
  }
  delete(e) {
    return super.delete(Npe(this, e));
  }
}
function b9({ _intern: t, _key: e }, n) {
  const r = e(n);
  return t.has(r) ? t.get(r) : n;
}
function Ipe({ _intern: t, _key: e }, n) {
  const r = e(n);
  return t.has(r) ? t.get(r) : (t.set(r, n), n);
}
function Npe({ _intern: t, _key: e }, n) {
  const r = e(n);
  return t.has(r) && (n = t.get(r), t.delete(r)), n;
}
function Bpe(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
const Lpe = Math.sqrt(50), $pe = Math.sqrt(10), zpe = Math.sqrt(2);
function ov(t, e, n) {
  const r = (e - t) / Math.max(0, n), i = Math.floor(Math.log10(r)), s = r / Math.pow(10, i), o = s >= Lpe ? 10 : s >= $pe ? 5 : s >= zpe ? 2 : 1;
  let l, a, u;
  return i < 0 ? (u = Math.pow(10, -i) / o, l = Math.round(t * u), a = Math.round(e * u), l / u < t && ++l, a / u > e && --a, u = -u) : (u = Math.pow(10, i) * o, l = Math.round(t / u), a = Math.round(e / u), l * u < t && ++l, a * u > e && --a), a < l && 0.5 <= n && n < 2 ? ov(t, e, n * 2) : [l, a, u];
}
function nk(t, e, n) {
  if (e = +e, t = +t, n = +n, !(n > 0)) return [];
  if (t === e) return [t];
  const r = e < t, [i, s, o] = r ? ov(e, t, n) : ov(t, e, n);
  if (!(s >= i)) return [];
  const l = s - i + 1, a = new Array(l);
  if (r)
    if (o < 0) for (let u = 0; u < l; ++u) a[u] = (s - u) / -o;
    else for (let u = 0; u < l; ++u) a[u] = (s - u) * o;
  else if (o < 0) for (let u = 0; u < l; ++u) a[u] = (i + u) / -o;
  else for (let u = 0; u < l; ++u) a[u] = (i + u) * o;
  return a;
}
function rk(t, e, n) {
  return e = +e, t = +t, n = +n, ov(t, e, n)[2];
}
function jpe(t, e, n) {
  e = +e, t = +t, n = +n;
  const r = e < t, i = r ? rk(e, t, n) : rk(t, e, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function qpe(t, e, n) {
  t = +t, e = +e, n = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((e - t) / n)) | 0, s = new Array(i); ++r < i; )
    s[r] = t + r * n;
  return s;
}
function gm(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
const v9 = Symbol("implicit");
function UB() {
  var t = new y9(), e = [], n = [], r = v9;
  function i(s) {
    let o = t.get(s);
    if (o === void 0) {
      if (r !== v9) return r;
      t.set(s, o = e.push(s) - 1);
    }
    return n[o % n.length];
  }
  return i.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [], t = new y9();
    for (const o of s)
      t.has(o) || t.set(o, e.push(o) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (n = Array.from(s), i) : n.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (r = s, i) : r;
  }, i.copy = function() {
    return UB(e, n).unknown(r);
  }, gm.apply(i, arguments), i;
}
function HB() {
  var t = UB().unknown(void 0), e = t.domain, n = t.range, r = 0, i = 1, s, o, l = !1, a = 0, u = 0, c = 0.5;
  delete t.unknown;
  function f() {
    var d = e().length, p = i < r, m = p ? i : r, y = p ? r : i;
    s = (y - m) / Math.max(1, d - a + u * 2), l && (s = Math.floor(s)), m += (y - m - s * (d - a)) * c, o = s * (1 - a), l && (m = Math.round(m), o = Math.round(o));
    var b = qpe(d).map(function(v) {
      return m + s * v;
    });
    return n(p ? b.reverse() : b);
  }
  return t.domain = function(d) {
    return arguments.length ? (e(d), f()) : e();
  }, t.range = function(d) {
    return arguments.length ? ([r, i] = d, r = +r, i = +i, f()) : [r, i];
  }, t.rangeRound = function(d) {
    return [r, i] = d, r = +r, i = +i, l = !0, f();
  }, t.bandwidth = function() {
    return o;
  }, t.step = function() {
    return s;
  }, t.round = function(d) {
    return arguments.length ? (l = !!d, f()) : l;
  }, t.padding = function(d) {
    return arguments.length ? (a = Math.min(1, u = +d), f()) : a;
  }, t.paddingInner = function(d) {
    return arguments.length ? (a = Math.min(1, d), f()) : a;
  }, t.paddingOuter = function(d) {
    return arguments.length ? (u = +d, f()) : u;
  }, t.align = function(d) {
    return arguments.length ? (c = Math.max(0, Math.min(1, d)), f()) : c;
  }, t.copy = function() {
    return HB(e(), [r, i]).round(l).paddingInner(a).paddingOuter(u).align(c);
  }, gm.apply(f(), arguments);
}
function mm(t, e, n) {
  t.prototype = e.prototype = n, n.constructor = t;
}
function k2(t, e) {
  var n = Object.create(t.prototype);
  for (var r in e) n[r] = e[r];
  return n;
}
function Hf() {
}
var Fg = 0.7, lv = 1 / Fg, rd = "\\s*([+-]?\\d+)\\s*", Tg = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Hl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Upe = /^#([0-9a-f]{3,8})$/, Hpe = new RegExp(`^rgb\\(${rd},${rd},${rd}\\)$`), Vpe = new RegExp(`^rgb\\(${Hl},${Hl},${Hl}\\)$`), Wpe = new RegExp(`^rgba\\(${rd},${rd},${rd},${Tg}\\)$`), Gpe = new RegExp(`^rgba\\(${Hl},${Hl},${Hl},${Tg}\\)$`), Kpe = new RegExp(`^hsl\\(${Tg},${Hl},${Hl}\\)$`), Ype = new RegExp(`^hsla\\(${Tg},${Hl},${Hl},${Tg}\\)$`), x9 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
mm(Hf, Rg, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: w9,
  // Deprecated! Use color.formatHex.
  formatHex: w9,
  formatHex8: Xpe,
  formatHsl: Qpe,
  formatRgb: _9,
  toString: _9
});
function w9() {
  return this.rgb().formatHex();
}
function Xpe() {
  return this.rgb().formatHex8();
}
function Qpe() {
  return WB(this).formatHsl();
}
function _9() {
  return this.rgb().formatRgb();
}
function Rg(t) {
  var e, n;
  return t = (t + "").trim().toLowerCase(), (e = Upe.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? k9(e) : n === 3 ? new si(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? fy(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? fy(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = Hpe.exec(t)) ? new si(e[1], e[2], e[3], 1) : (e = Vpe.exec(t)) ? new si(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Wpe.exec(t)) ? fy(e[1], e[2], e[3], e[4]) : (e = Gpe.exec(t)) ? fy(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = Kpe.exec(t)) ? A9(e[1], e[2] / 100, e[3] / 100, 1) : (e = Ype.exec(t)) ? A9(e[1], e[2] / 100, e[3] / 100, e[4]) : x9.hasOwnProperty(t) ? k9(x9[t]) : t === "transparent" ? new si(NaN, NaN, NaN, 0) : null;
}
function k9(t) {
  return new si(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function fy(t, e, n, r) {
  return r <= 0 && (t = e = n = NaN), new si(t, e, n, r);
}
function VB(t) {
  return t instanceof Hf || (t = Rg(t)), t ? (t = t.rgb(), new si(t.r, t.g, t.b, t.opacity)) : new si();
}
function Mg(t, e, n, r) {
  return arguments.length === 1 ? VB(t) : new si(t, e, n, r ?? 1);
}
function si(t, e, n, r) {
  this.r = +t, this.g = +e, this.b = +n, this.opacity = +r;
}
mm(si, Mg, k2(Hf, {
  brighter(t) {
    return t = t == null ? lv : Math.pow(lv, t), new si(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Fg : Math.pow(Fg, t), new si(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new si(af(this.r), af(this.g), af(this.b), av(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: C9,
  // Deprecated! Use color.formatHex.
  formatHex: C9,
  formatHex8: Jpe,
  formatRgb: S9,
  toString: S9
}));
function C9() {
  return `#${Xc(this.r)}${Xc(this.g)}${Xc(this.b)}`;
}
function Jpe() {
  return `#${Xc(this.r)}${Xc(this.g)}${Xc(this.b)}${Xc((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function S9() {
  const t = av(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${af(this.r)}, ${af(this.g)}, ${af(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function av(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function af(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function Xc(t) {
  return t = af(t), (t < 16 ? "0" : "") + t.toString(16);
}
function A9(t, e, n, r) {
  return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new jo(t, e, n, r);
}
function WB(t) {
  if (t instanceof jo) return new jo(t.h, t.s, t.l, t.opacity);
  if (t instanceof Hf || (t = Rg(t)), !t) return new jo();
  if (t instanceof jo) return t;
  t = t.rgb();
  var e = t.r / 255, n = t.g / 255, r = t.b / 255, i = Math.min(e, n, r), s = Math.max(e, n, r), o = NaN, l = s - i, a = (s + i) / 2;
  return l ? (e === s ? o = (n - r) / l + (n < r) * 6 : n === s ? o = (r - e) / l + 2 : o = (e - n) / l + 4, l /= a < 0.5 ? s + i : 2 - s - i, o *= 60) : l = a > 0 && a < 1 ? 0 : o, new jo(o, l, a, t.opacity);
}
function Zpe(t, e, n, r) {
  return arguments.length === 1 ? WB(t) : new jo(t, e, n, r ?? 1);
}
function jo(t, e, n, r) {
  this.h = +t, this.s = +e, this.l = +n, this.opacity = +r;
}
mm(jo, Zpe, k2(Hf, {
  brighter(t) {
    return t = t == null ? lv : Math.pow(lv, t), new jo(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Fg : Math.pow(Fg, t), new jo(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * e, i = 2 * n - r;
    return new si(
      F3(t >= 240 ? t - 240 : t + 120, i, r),
      F3(t, i, r),
      F3(t < 120 ? t + 240 : t - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new jo(E9(this.h), hy(this.s), hy(this.l), av(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = av(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${E9(this.h)}, ${hy(this.s) * 100}%, ${hy(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function E9(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function hy(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function F3(t, e, n) {
  return (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) * 255;
}
const ege = Math.PI / 180, tge = 180 / Math.PI, uv = 18, GB = 0.96422, KB = 1, YB = 0.82521, XB = 4 / 29, id = 6 / 29, QB = 3 * id * id, nge = id * id * id;
function JB(t) {
  if (t instanceof Vl) return new Vl(t.l, t.a, t.b, t.opacity);
  if (t instanceof za) return eL(t);
  t instanceof si || (t = VB(t));
  var e = P3(t.r), n = P3(t.g), r = P3(t.b), i = T3((0.2225045 * e + 0.7168786 * n + 0.0606169 * r) / KB), s, o;
  return e === n && n === r ? s = o = i : (s = T3((0.4360747 * e + 0.3850649 * n + 0.1430804 * r) / GB), o = T3((0.0139322 * e + 0.0971045 * n + 0.7141733 * r) / YB)), new Vl(116 * i - 16, 500 * (s - i), 200 * (i - o), t.opacity);
}
function ZB(t, e, n, r) {
  return arguments.length === 1 ? JB(t) : new Vl(t, e, n, r ?? 1);
}
function Vl(t, e, n, r) {
  this.l = +t, this.a = +e, this.b = +n, this.opacity = +r;
}
mm(Vl, ZB, k2(Hf, {
  brighter(t) {
    return new Vl(this.l + uv * (t ?? 1), this.a, this.b, this.opacity);
  },
  darker(t) {
    return new Vl(this.l - uv * (t ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var t = (this.l + 16) / 116, e = isNaN(this.a) ? t : t + this.a / 500, n = isNaN(this.b) ? t : t - this.b / 200;
    return e = GB * R3(e), t = KB * R3(t), n = YB * R3(n), new si(
      M3(3.1338561 * e - 1.6168667 * t - 0.4906146 * n),
      M3(-0.9787684 * e + 1.9161415 * t + 0.033454 * n),
      M3(0.0719453 * e - 0.2289914 * t + 1.4052427 * n),
      this.opacity
    );
  }
}));
function T3(t) {
  return t > nge ? Math.pow(t, 1 / 3) : t / QB + XB;
}
function R3(t) {
  return t > id ? t * t * t : QB * (t - XB);
}
function M3(t) {
  return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function P3(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function rge(t) {
  if (t instanceof za) return new za(t.h, t.c, t.l, t.opacity);
  if (t instanceof Vl || (t = JB(t)), t.a === 0 && t.b === 0) return new za(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var e = Math.atan2(t.b, t.a) * tge;
  return new za(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function ige(t, e, n, r) {
  return arguments.length === 1 ? rge(t) : new za(t, e, n, r ?? 1);
}
function za(t, e, n, r) {
  this.h = +t, this.c = +e, this.l = +n, this.opacity = +r;
}
function eL(t) {
  if (isNaN(t.h)) return new Vl(t.l, 0, 0, t.opacity);
  var e = t.h * ege;
  return new Vl(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
}
mm(za, ige, k2(Hf, {
  brighter(t) {
    return new za(this.h, this.c, this.l + uv * (t ?? 1), this.opacity);
  },
  darker(t) {
    return new za(this.h, this.c, this.l - uv * (t ?? 1), this.opacity);
  },
  rgb() {
    return eL(this).rgb();
  }
}));
function sge(t, e, n, r, i) {
  var s = t * t, o = s * t;
  return ((1 - 3 * t + 3 * s - o) * e + (4 - 6 * s + 3 * o) * n + (1 + 3 * t + 3 * s - 3 * o) * r + o * i) / 6;
}
function oge(t) {
  var e = t.length - 1;
  return function(n) {
    var r = n <= 0 ? n = 0 : n >= 1 ? (n = 1, e - 1) : Math.floor(n * e), i = t[r], s = t[r + 1], o = r > 0 ? t[r - 1] : 2 * i - s, l = r < e - 1 ? t[r + 2] : 2 * s - i;
    return sge((n - r / e) * e, o, i, s, l);
  };
}
const F5 = (t) => () => t;
function lge(t, e) {
  return function(n) {
    return t + n * e;
  };
}
function age(t, e, n) {
  return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function(r) {
    return Math.pow(t + r * e, n);
  };
}
function uge(t) {
  return (t = +t) == 1 ? tL : function(e, n) {
    return n - e ? age(e, n, t) : F5(isNaN(e) ? n : e);
  };
}
function tL(t, e) {
  var n = e - t;
  return n ? lge(t, n) : F5(isNaN(t) ? e : t);
}
const D9 = (function t(e) {
  var n = uge(e);
  function r(i, s) {
    var o = n((i = Mg(i)).r, (s = Mg(s)).r), l = n(i.g, s.g), a = n(i.b, s.b), u = tL(i.opacity, s.opacity);
    return function(c) {
      return i.r = o(c), i.g = l(c), i.b = a(c), i.opacity = u(c), i + "";
    };
  }
  return r.gamma = t, r;
})(1);
function cge(t) {
  return function(e) {
    var n = e.length, r = new Array(n), i = new Array(n), s = new Array(n), o, l;
    for (o = 0; o < n; ++o)
      l = Mg(e[o]), r[o] = l.r || 0, i[o] = l.g || 0, s[o] = l.b || 0;
    return r = t(r), i = t(i), s = t(s), l.opacity = 1, function(a) {
      return l.r = r(a), l.g = i(a), l.b = s(a), l + "";
    };
  };
}
var fge = cge(oge);
function hge(t, e) {
  e || (e = []);
  var n = t ? Math.min(e.length, t.length) : 0, r = e.slice(), i;
  return function(s) {
    for (i = 0; i < n; ++i) r[i] = t[i] * (1 - s) + e[i] * s;
    return r;
  };
}
function dge(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function pge(t, e) {
  var n = e ? e.length : 0, r = t ? Math.min(n, t.length) : 0, i = new Array(r), s = new Array(n), o;
  for (o = 0; o < r; ++o) i[o] = T5(t[o], e[o]);
  for (; o < n; ++o) s[o] = e[o];
  return function(l) {
    for (o = 0; o < r; ++o) s[o] = i[o](l);
    return s;
  };
}
function gge(t, e) {
  var n = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(r) {
    return n.setTime(t * (1 - r) + e * r), n;
  };
}
function cv(t, e) {
  return t = +t, e = +e, function(n) {
    return t * (1 - n) + e * n;
  };
}
function mge(t, e) {
  var n = {}, r = {}, i;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (i in e)
    i in t ? n[i] = T5(t[i], e[i]) : r[i] = e[i];
  return function(s) {
    for (i in n) r[i] = n[i](s);
    return r;
  };
}
var ik = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, I3 = new RegExp(ik.source, "g");
function yge(t) {
  return function() {
    return t;
  };
}
function bge(t) {
  return function(e) {
    return t(e) + "";
  };
}
function vge(t, e) {
  var n = ik.lastIndex = I3.lastIndex = 0, r, i, s, o = -1, l = [], a = [];
  for (t = t + "", e = e + ""; (r = ik.exec(t)) && (i = I3.exec(e)); )
    (s = i.index) > n && (s = e.slice(n, s), l[o] ? l[o] += s : l[++o] = s), (r = r[0]) === (i = i[0]) ? l[o] ? l[o] += i : l[++o] = i : (l[++o] = null, a.push({ i: o, x: cv(r, i) })), n = I3.lastIndex;
  return n < e.length && (s = e.slice(n), l[o] ? l[o] += s : l[++o] = s), l.length < 2 ? a[0] ? bge(a[0].x) : yge(e) : (e = a.length, function(u) {
    for (var c = 0, f; c < e; ++c) l[(f = a[c]).i] = f.x(u);
    return l.join("");
  });
}
function T5(t, e) {
  var n = typeof e, r;
  return e == null || n === "boolean" ? F5(e) : (n === "number" ? cv : n === "string" ? (r = Rg(e)) ? (e = r, D9) : vge : e instanceof Rg ? D9 : e instanceof Date ? gge : dge(e) ? hge : Array.isArray(e) ? pge : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? mge : cv)(t, e);
}
function xge(t, e) {
  return t = +t, e = +e, function(n) {
    return Math.round(t * (1 - n) + e * n);
  };
}
function wge(t) {
  return function() {
    return t;
  };
}
function _ge(t) {
  return +t;
}
var O9 = [0, 1];
function Lh(t) {
  return t;
}
function sk(t, e) {
  return (e -= t = +t) ? function(n) {
    return (n - t) / e;
  } : wge(isNaN(e) ? NaN : 0.5);
}
function kge(t, e) {
  var n;
  return t > e && (n = t, t = e, e = n), function(r) {
    return Math.max(t, Math.min(e, r));
  };
}
function Cge(t, e, n) {
  var r = t[0], i = t[1], s = e[0], o = e[1];
  return i < r ? (r = sk(i, r), s = n(o, s)) : (r = sk(r, i), s = n(s, o)), function(l) {
    return s(r(l));
  };
}
function Sge(t, e, n) {
  var r = Math.min(t.length, e.length) - 1, i = new Array(r), s = new Array(r), o = -1;
  for (t[r] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++o < r; )
    i[o] = sk(t[o], t[o + 1]), s[o] = n(e[o], e[o + 1]);
  return function(l) {
    var a = Ppe(t, l, 1, r) - 1;
    return s[a](i[a](l));
  };
}
function R5(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function M5() {
  var t = O9, e = O9, n = T5, r, i, s, o = Lh, l, a, u;
  function c() {
    var d = Math.min(t.length, e.length);
    return o !== Lh && (o = kge(t[0], t[d - 1])), l = d > 2 ? Sge : Cge, a = u = null, f;
  }
  function f(d) {
    return d == null || isNaN(d = +d) ? s : (a || (a = l(t.map(r), e, n)))(r(o(d)));
  }
  return f.invert = function(d) {
    return o(i((u || (u = l(e, t.map(r), cv)))(d)));
  }, f.domain = function(d) {
    return arguments.length ? (t = Array.from(d, _ge), c()) : t.slice();
  }, f.range = function(d) {
    return arguments.length ? (e = Array.from(d), c()) : e.slice();
  }, f.rangeRound = function(d) {
    return e = Array.from(d), n = xge, c();
  }, f.clamp = function(d) {
    return arguments.length ? (o = d ? !0 : Lh, c()) : o !== Lh;
  }, f.interpolate = function(d) {
    return arguments.length ? (n = d, c()) : n;
  }, f.unknown = function(d) {
    return arguments.length ? (s = d, f) : s;
  }, function(d, p) {
    return r = d, i = p, c();
  };
}
function Age() {
  return M5()(Lh, Lh);
}
function Ege(t, e, n, r) {
  var i = jpe(t, e, n), s;
  switch (r = Og(r ?? ",f"), r.type) {
    case "s": {
      var o = Math.max(Math.abs(t), Math.abs(e));
      return r.precision == null && !isNaN(s = Dpe(i, o)) && (r.precision = s), jB(r, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(s = Ope(i, Math.max(Math.abs(t), Math.abs(e)))) && (r.precision = s - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(s = Epe(i)) && (r.precision = s - (r.type === "%") * 2);
      break;
    }
  }
  return su(r);
}
function nL(t) {
  var e = t.domain;
  return t.ticks = function(n) {
    var r = e();
    return nk(r[0], r[r.length - 1], n ?? 10);
  }, t.tickFormat = function(n, r) {
    var i = e();
    return Ege(i[0], i[i.length - 1], n ?? 10, r);
  }, t.nice = function(n) {
    n == null && (n = 10);
    var r = e(), i = 0, s = r.length - 1, o = r[i], l = r[s], a, u, c = 10;
    for (l < o && (u = o, o = l, l = u, u = i, i = s, s = u); c-- > 0; ) {
      if (u = rk(o, l, n), u === a)
        return r[i] = o, r[s] = l, e(r);
      if (u > 0)
        o = Math.floor(o / u) * u, l = Math.ceil(l / u) * u;
      else if (u < 0)
        o = Math.ceil(o * u) / u, l = Math.floor(l * u) / u;
      else
        break;
      a = u;
    }
    return t;
  }, t;
}
function c0() {
  var t = Age();
  return t.copy = function() {
    return R5(t, c0());
  }, gm.apply(t, arguments), nL(t);
}
function Dge(t, e) {
  t = t.slice();
  var n = 0, r = t.length - 1, i = t[n], s = t[r], o;
  return s < i && (o = n, n = r, r = o, o = i, i = s, s = o), t[n] = e.floor(i), t[r] = e.ceil(s), t;
}
function F9(t) {
  return Math.log(t);
}
function T9(t) {
  return Math.exp(t);
}
function Oge(t) {
  return -Math.log(-t);
}
function Fge(t) {
  return -Math.exp(-t);
}
function Tge(t) {
  return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t;
}
function Rge(t) {
  return t === 10 ? Tge : t === Math.E ? Math.exp : (e) => Math.pow(t, e);
}
function Mge(t) {
  return t === Math.E ? Math.log : t === 10 && Math.log10 || t === 2 && Math.log2 || (t = Math.log(t), (e) => Math.log(e) / t);
}
function R9(t) {
  return (e, n) => -t(-e, n);
}
function Pge(t) {
  const e = t(F9, T9), n = e.domain;
  let r = 10, i, s;
  function o() {
    return i = Mge(r), s = Rge(r), n()[0] < 0 ? (i = R9(i), s = R9(s), t(Oge, Fge)) : t(F9, T9), e;
  }
  return e.base = function(l) {
    return arguments.length ? (r = +l, o()) : r;
  }, e.domain = function(l) {
    return arguments.length ? (n(l), o()) : n();
  }, e.ticks = (l) => {
    const a = n();
    let u = a[0], c = a[a.length - 1];
    const f = c < u;
    f && ([u, c] = [c, u]);
    let d = i(u), p = i(c), m, y;
    const b = l == null ? 10 : +l;
    let v = [];
    if (!(r % 1) && p - d < b) {
      if (d = Math.floor(d), p = Math.ceil(p), u > 0) {
        for (; d <= p; ++d)
          for (m = 1; m < r; ++m)
            if (y = d < 0 ? m / s(-d) : m * s(d), !(y < u)) {
              if (y > c) break;
              v.push(y);
            }
      } else for (; d <= p; ++d)
        for (m = r - 1; m >= 1; --m)
          if (y = d > 0 ? m / s(-d) : m * s(d), !(y < u)) {
            if (y > c) break;
            v.push(y);
          }
      v.length * 2 < b && (v = nk(u, c, b));
    } else
      v = nk(d, p, Math.min(p - d, b)).map(s);
    return f ? v.reverse() : v;
  }, e.tickFormat = (l, a) => {
    if (l == null && (l = 10), a == null && (a = r === 10 ? "s" : ","), typeof a != "function" && (!(r % 1) && (a = Og(a)).precision == null && (a.trim = !0), a = su(a)), l === 1 / 0) return a;
    const u = Math.max(1, r * l / e.ticks().length);
    return (c) => {
      let f = c / s(Math.round(i(c)));
      return f * r < r - 0.5 && (f *= r), f <= u ? a(c) : "";
    };
  }, e.nice = () => n(Dge(n(), {
    floor: (l) => s(Math.floor(i(l))),
    ceil: (l) => s(Math.ceil(i(l)))
  })), e;
}
function Pg() {
  const t = Pge(M5()).domain([1, 10]);
  return t.copy = () => R5(t, Pg()).base(t.base()), gm.apply(t, arguments), t;
}
function M9(t) {
  return function(e) {
    return Math.sign(e) * Math.log1p(Math.abs(e / t));
  };
}
function P9(t) {
  return function(e) {
    return Math.sign(e) * Math.expm1(Math.abs(e)) * t;
  };
}
function Ige(t) {
  var e = 1, n = t(M9(e), P9(e));
  return n.constant = function(r) {
    return arguments.length ? t(M9(e = +r), P9(e)) : e;
  }, nL(n);
}
function rL() {
  var t = Ige(M5());
  return t.copy = function() {
    return R5(t, rL()).constant(t.constant());
  }, gm.apply(t, arguments);
}
function f0(t) {
  for (var e = t.length / 6 | 0, n = new Array(e), r = 0; r < e; ) n[r] = "#" + t.slice(r * 6, ++r * 6);
  return n;
}
const iL = (t) => fge(t[t.length - 1]);
var Nge = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(f0);
const Bge = iL(Nge);
var Lge = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(f0);
const $ge = iL(Lge);
function zge(t) {
  return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}
function C2(t) {
  var e = t.length;
  return function(n) {
    return t[Math.max(0, Math.min(e - 1, Math.floor(n * e)))];
  };
}
C2(f0("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
C2(f0("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var sL = C2(f0("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
C2(f0("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
var No = { slate: { 300: "oklch(86.9% 0.022 252.894)", 400: "oklch(70.4% 0.04 256.788)", 500: "oklch(55.4% 0.046 257.417)", 700: "oklch(37.2% 0.044 257.287)" }, gray: { 500: "oklch(55.1% 0.027 264.364)" } };
function oL() {
  return !(navigator.gpu == null || navigator.gpu.requestAdapter == null);
}
function jge(t) {
  return t == 0 && (t = 4), t % 4 != 0 && (t += 4 - t % 4), t;
}
function sd(t, e, n, r) {
  return (t.buffer == null || t.byteSize != n || t.usage != r) && (t.buffer != null && t.buffer.destroy(), t.buffer = e.createBuffer({ size: jge(n), usage: r }), t.byteSize = n, t.destroy = () => {
    t.buffer?.destroy();
  }), t.buffer;
}
function N3(t, e, n, r) {
  if (t.buffer !== n || t.data !== r) {
    if (r != null)
      if (r.byteLength % 4 != 0) {
        let i = r.byteLength - r.byteLength % 4;
        if (e.queue.writeBuffer(n, 0, r, 0, i), r instanceof Uint8Array) {
          let s = new Uint8Array(4);
          for (let o = 0; o < 4; o++)
            i + o < r.length && (s[o] = r[i + o]);
          e.queue.writeBuffer(n, i, s);
        }
      } else
        e.queue.writeBuffer(n, 0, r, 0);
    else
      e.queue.writeBuffer(n, 0, new ArrayBuffer(n.size));
    t.buffer = n, t.data = r;
  }
  return n;
}
function I9(t, e, n, r, i, s) {
  return (t.texture == null || t.width != n || t.height != r || t.format != i || t.usage != s) && (t.texture != null && t.texture.destroy(), t.texture = e.createTexture({ size: [n, r], format: i, usage: s }), t.destroy = () => {
    t.texture?.destroy();
  }), t.texture;
}
const yi = 2, S2 = 4, A2 = 8, ou = 16, lu = 32, Vf = 64, E2 = 128, Jo = 512, oi = 1024, hs = 2048, au = 4096, Us = 8192, Ku = 16384, D2 = 32768, Pd = 65536, N9 = 1 << 17, lL = 1 << 18, h0 = 1 << 19, aL = 1 << 20, Ig = 32768, ok = 1 << 21, P5 = 1 << 22, Yu = 1 << 23, uf = Symbol("$state"), uL = Symbol("legacy props"), qge = Symbol(""), $h = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), I5 = 3, d0 = 8, Uge = !1;
var cL = Array.isArray, Hge = Array.prototype.indexOf, N5 = Array.from, fL = Object.defineProperty, od = Object.getOwnPropertyDescriptor, hL = Object.getOwnPropertyDescriptors, Vge = Object.prototype, Wge = Array.prototype, B5 = Object.getPrototypeOf, B9 = Object.isExtensible;
function Gge(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function dL() {
  var t, e, n = new Promise((r, i) => {
    t = r, e = i;
  });
  return { promise: n, resolve: t, reject: e };
}
function pL(t) {
  return t === this.v;
}
function gL(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function mL(t) {
  return !gL(t, this.v);
}
function yL(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function Kge() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function Yge(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Xge() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function Qge(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function Jge() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Zge() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function eme(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function tme() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function nme() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function rme() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function ime() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let sme = !1;
const L5 = 1, $5 = 2, bL = 4, ome = 8, lme = 16, ame = 1, ume = 4, cme = 8, fme = 16, hme = 1, dme = 2, vL = "[", O2 = "[!", z5 = "]", Id = {}, Zr = Symbol(), pme = "http://www.w3.org/1999/xhtml";
let ds = null;
function Nd(t) {
  ds = t;
}
function Wf(t, e = !1, n) {
  ds = {
    p: ds,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: null
  };
}
function Gf(t) {
  var e = (
    /** @type {ComponentContext} */
    ds
  ), n = e.e;
  if (n !== null) {
    e.e = null;
    for (var r of n)
      GL(r);
  }
  return e.i = !0, ds = e.p, /** @type {T} */
  {};
}
function xL() {
  return !0;
}
let Qc = [];
function wL() {
  var t = Qc;
  Qc = [], Gge(t);
}
function p0(t) {
  if (Qc.length === 0 && !Np) {
    var e = Qc;
    queueMicrotask(() => {
      e === Qc && wL();
    });
  }
  Qc.push(t);
}
function gme() {
  for (; Qc.length > 0; )
    wL();
}
function F2(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function mme() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let sn = !1;
function ja(t) {
  sn = t;
}
let Jt;
function os(t) {
  if (t === null)
    throw F2(), Id;
  return Jt = t;
}
function ym() {
  return os(
    /** @type {TemplateNode} */
    /* @__PURE__ */ ua(Jt)
  );
}
function br(t) {
  if (sn) {
    if (/* @__PURE__ */ ua(Jt) !== null)
      throw F2(), Id;
    Jt = t;
  }
}
function _L(t = 1) {
  if (sn) {
    for (var e = t, n = Jt; e--; )
      n = /** @type {TemplateNode} */
      /* @__PURE__ */ ua(n);
    Jt = n;
  }
}
function fv(t = !0) {
  for (var e = 0, n = Jt; ; ) {
    if (n.nodeType === d0) {
      var r = (
        /** @type {Comment} */
        n.data
      );
      if (r === z5) {
        if (e === 0) return n;
        e -= 1;
      } else (r === vL || r === O2) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ua(n)
    );
    t && n.remove(), n = i;
  }
}
function kL(t) {
  if (!t || t.nodeType !== d0)
    throw F2(), Id;
  return (
    /** @type {Comment} */
    t.data
  );
}
function Jc(t) {
  if (typeof t != "object" || t === null || uf in t)
    return t;
  const e = B5(t);
  if (e !== Vge && e !== Wge)
    return t;
  var n = /* @__PURE__ */ new Map(), r = cL(t), i = /* @__PURE__ */ Pn(0), s = ff, o = (l) => {
    if (ff === s)
      return l();
    var a = Xt, u = ff;
    rs(null), q9(s);
    var c = l();
    return rs(a), q9(u), c;
  };
  return r && n.set("length", /* @__PURE__ */ Pn(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(l, a, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && tme();
        var c = n.get(a);
        return c === void 0 ? c = o(() => {
          var f = /* @__PURE__ */ Pn(u.value);
          return n.set(a, f), f;
        }) : dt(c, u.value, !0), !0;
      },
      deleteProperty(l, a) {
        var u = n.get(a);
        if (u === void 0) {
          if (a in l) {
            const c = o(() => /* @__PURE__ */ Pn(Zr));
            n.set(a, c), Bp(i);
          }
        } else
          dt(u, Zr), Bp(i);
        return !0;
      },
      get(l, a, u) {
        if (a === uf)
          return t;
        var c = n.get(a), f = a in l;
        if (c === void 0 && (!f || od(l, a)?.writable) && (c = o(() => {
          var p = Jc(f ? l[a] : Zr), m = /* @__PURE__ */ Pn(p);
          return m;
        }), n.set(a, c)), c !== void 0) {
          var d = W(c);
          return d === Zr ? void 0 : d;
        }
        return Reflect.get(l, a, u);
      },
      getOwnPropertyDescriptor(l, a) {
        var u = Reflect.getOwnPropertyDescriptor(l, a);
        if (u && "value" in u) {
          var c = n.get(a);
          c && (u.value = W(c));
        } else if (u === void 0) {
          var f = n.get(a), d = f?.v;
          if (f !== void 0 && d !== Zr)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(l, a) {
        if (a === uf)
          return !0;
        var u = n.get(a), c = u !== void 0 && u.v !== Zr || Reflect.has(l, a);
        if (u !== void 0 || on !== null && (!c || od(l, a)?.writable)) {
          u === void 0 && (u = o(() => {
            var d = c ? Jc(l[a]) : Zr, p = /* @__PURE__ */ Pn(d);
            return p;
          }), n.set(a, u));
          var f = W(u);
          if (f === Zr)
            return !1;
        }
        return c;
      },
      set(l, a, u, c) {
        var f = n.get(a), d = a in l;
        if (r && a === "length")
          for (var p = u; p < /** @type {Source<number>} */
          f.v; p += 1) {
            var m = n.get(p + "");
            m !== void 0 ? dt(m, Zr) : p in l && (m = o(() => /* @__PURE__ */ Pn(Zr)), n.set(p + "", m));
          }
        if (f === void 0)
          (!d || od(l, a)?.writable) && (f = o(() => /* @__PURE__ */ Pn(void 0)), dt(f, Jc(u)), n.set(a, f));
        else {
          d = f.v !== Zr;
          var y = o(() => Jc(u));
          dt(f, y);
        }
        var b = Reflect.getOwnPropertyDescriptor(l, a);
        if (b?.set && b.set.call(c, u), !d) {
          if (r && typeof a == "string") {
            var v = (
              /** @type {Source<number>} */
              n.get("length")
            ), _ = Number(a);
            Number.isInteger(_) && _ >= v.v && dt(v, _ + 1);
          }
          Bp(i);
        }
        return !0;
      },
      ownKeys(l) {
        W(i);
        var a = Reflect.ownKeys(l).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== Zr;
        });
        for (var [u, c] of n)
          c.v !== Zr && !(u in l) && a.push(u);
        return a;
      },
      setPrototypeOf() {
        nme();
      }
    }
  );
}
var L9, CL, SL, AL;
function lk() {
  if (L9 === void 0) {
    L9 = window, CL = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, n = Text.prototype;
    SL = od(e, "firstChild").get, AL = od(e, "nextSibling").get, B9(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), B9(n) && (n.__t = void 0);
  }
}
function Jl(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Ja(t) {
  return SL.call(t);
}
// @__NO_SIDE_EFFECTS__
function ua(t) {
  return AL.call(t);
}
function Nr(t, e) {
  if (!sn)
    return /* @__PURE__ */ Ja(t);
  var n = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ Ja(Jt)
  );
  if (n === null)
    n = Jt.appendChild(Jl());
  else if (e && n.nodeType !== I5) {
    var r = Jl();
    return n?.before(r), os(r), r;
  }
  return os(n), n;
}
function Dh(t, e = !1) {
  if (!sn) {
    var n = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Ja(
        /** @type {Node} */
        t
      )
    );
    return n instanceof Comment && n.data === "" ? /* @__PURE__ */ ua(n) : n;
  }
  if (e && Jt?.nodeType !== I5) {
    var r = Jl();
    return Jt?.before(r), os(r), r;
  }
  return Jt;
}
function Vn(t, e = 1, n = !1) {
  let r = sn ? Jt : t;
  for (var i; e--; )
    i = r, r = /** @type {TemplateNode} */
    /* @__PURE__ */ ua(r);
  if (!sn)
    return r;
  if (n && r?.nodeType !== I5) {
    var s = Jl();
    return r === null ? i?.after(s) : r.before(s), os(s), s;
  }
  return os(r), /** @type {TemplateNode} */
  r;
}
function EL(t) {
  t.textContent = "";
}
function yme() {
  return !1;
}
function DL(t) {
  var e = on;
  if (e === null)
    return Xt.f |= Yu, t;
  if ((e.f & D2) === 0) {
    if ((e.f & E2) === 0)
      throw t;
    e.b.error(t);
  } else
    Bd(t, e);
}
function Bd(t, e) {
  for (; e !== null; ) {
    if ((e.f & E2) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (n) {
        t = n;
      }
    e = e.parent;
  }
  throw t;
}
const dy = /* @__PURE__ */ new Set();
let Cr = null, Ns = null, Ol = [], T2 = null, ak = !1, Np = !1, Zc = class uk {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #n = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #r = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #a = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #l = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Ol = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const r of e)
      this.#s(r, n);
    this.is_fork || this.#u(), this.#r > 0 || this.is_fork ? (this.#o(n.effects), this.#o(n.render_effects), this.#o(n.block_effects)) : (Cr = null, $9(n.render_effects), $9(n.effects), this.#a?.resolve()), Ns = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #s(e, n) {
    e.f ^= oi;
    for (var r = e.first; r !== null; ) {
      var i = r.f, s = (i & (lu | Vf)) !== 0, o = s && (i & oi) !== 0, l = o || (i & Us) !== 0 || this.skipped_effects.has(r);
      if ((r.f & E2) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !l && r.fn !== null) {
        s ? r.f ^= oi : (i & S2) !== 0 ? n.effects.push(r) : bm(r) && ((r.f & ou) !== 0 && n.block_effects.push(r), Bg(r));
        var a = r.first;
        if (a !== null) {
          r = a;
          continue;
        }
      }
      var u = r.parent;
      for (r = r.next; r === null && u !== null; )
        u === n.effect && (this.#o(n.effects), this.#o(n.render_effects), this.#o(n.block_effects), n = /** @type {EffectTarget} */
        n.parent), r = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #o(e) {
    for (const n of e)
      ((n.f & hs) !== 0 ? this.#l : this.#i).push(n), hi(n, oi);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, n) {
    this.previous.has(e) || this.previous.set(e, n), (e.f & Yu) === 0 && (this.current.set(e, e.v), Ns?.set(e, e.v));
  }
  activate() {
    Cr = this, this.apply();
  }
  deactivate() {
    Cr = null, Ns = null;
  }
  flush() {
    if (this.activate(), Ol.length > 0) {
      if (OL(), Cr !== null && Cr !== this)
        return;
    } else this.#n === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#r === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#n === 0 && this.#c();
  }
  #c() {
    if (dy.size > 1) {
      this.previous.clear();
      var e = Ns, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of dy) {
        if (i === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [l, a] of this.current) {
          if (i.current.has(l))
            if (n && a !== i.current.get(l))
              i.current.set(l, a);
            else
              continue;
          s.push(l);
        }
        if (s.length === 0)
          continue;
        const o = [...i.current.keys()].filter((l) => !this.current.has(l));
        if (o.length > 0) {
          const l = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Map();
          for (const u of s)
            FL(u, o, l, a);
          if (Ol.length > 0) {
            Cr = i, i.apply();
            for (const u of Ol)
              i.#s(u, r);
            Ol = [], i.deactivate();
          }
        }
      }
      Cr = null, Ns = e;
    }
    this.committed = !0, dy.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#n += 1, e && (this.#r += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#n -= 1, e && (this.#r -= 1), this.revive();
  }
  revive() {
    for (const e of this.#l)
      hi(e, hs), Af(e);
    for (const e of this.#i)
      hi(e, au), Af(e);
    this.#l = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#a ??= dL()).promise;
  }
  static ensure() {
    if (Cr === null) {
      const e = Cr = new uk();
      dy.add(Cr), Np || uk.enqueue(() => {
        Cr === e && e.flush();
      });
    }
    return Cr;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    p0(e);
  }
  apply() {
  }
};
function bme(t) {
  var e = Np;
  Np = !0;
  try {
    for (var n; ; ) {
      if (gme(), Ol.length === 0 && (Cr?.flush(), Ol.length === 0))
        return T2 = null, /** @type {T} */
        n;
      OL();
    }
  } finally {
    Np = e;
  }
}
function OL() {
  var t = cf;
  ak = !0;
  try {
    var e = 0;
    for (z9(!0); Ol.length > 0; ) {
      var n = Zc.ensure();
      if (e++ > 1e3) {
        var r, i;
        vme();
      }
      n.process(Ol), Xu.clear();
    }
  } finally {
    ak = !1, z9(t), T2 = null;
  }
}
function vme() {
  try {
    Jge();
  } catch (t) {
    Bd(t, T2);
  }
}
let Fa = null;
function $9(t) {
  var e = t.length;
  if (e !== 0) {
    for (var n = 0; n < e; ) {
      var r = t[n++];
      if ((r.f & (Ku | Us)) === 0 && bm(r) && (Fa = /* @__PURE__ */ new Set(), Bg(r), r.deps === null && r.first === null && r.nodes_start === null && (r.teardown === null && r.ac === null ? QL(r) : r.fn = null), Fa?.size > 0)) {
        Xu.clear();
        for (const i of Fa) {
          if ((i.f & (Ku | Us)) !== 0) continue;
          const s = [i];
          let o = i.parent;
          for (; o !== null; )
            Fa.has(o) && (Fa.delete(o), s.push(o)), o = o.parent;
          for (let l = s.length - 1; l >= 0; l--) {
            const a = s[l];
            (a.f & (Ku | Us)) === 0 && Bg(a);
          }
        }
        Fa.clear();
      }
    }
    Fa = null;
  }
}
function FL(t, e, n, r) {
  if (!n.has(t) && (n.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const s = i.f;
      (s & yi) !== 0 ? FL(
        /** @type {Derived} */
        i,
        e,
        n,
        r
      ) : (s & (P5 | ou)) !== 0 && (s & hs) === 0 && // we may have scheduled this one already
      TL(i, e, r) && (hi(i, hs), Af(
        /** @type {Effect} */
        i
      ));
    }
}
function TL(t, e, n) {
  const r = n.get(t);
  if (r !== void 0) return r;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & yi) !== 0 && TL(
        /** @type {Derived} */
        i,
        e,
        n
      ))
        return n.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return n.set(t, !1), !1;
}
function Af(t) {
  for (var e = T2 = t; e.parent !== null; ) {
    e = e.parent;
    var n = e.f;
    if (ak && e === on && (n & ou) !== 0 && (n & lL) === 0)
      return;
    if ((n & (Vf | lu)) !== 0) {
      if ((n & oi) === 0) return;
      e.f ^= oi;
    }
  }
  Ol.push(e);
}
function xme(t) {
  let e = 0, n = Ef(0), r;
  return () => {
    M2() && (W(n), U5(() => (e === 0 && (r = Yf(() => t(() => Bp(n)))), e += 1, () => {
      p0(() => {
        e -= 1, e === 0 && (r?.(), r = void 0, Bp(n));
      });
    })));
  };
}
var wme = Pd | h0 | E2;
function _me(t, e, n) {
  new kme(t, e, n);
}
class kme {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #n = sn ? Jt : null;
  /** @type {BoundaryProps} */
  #r;
  /** @type {((anchor: Node) => void)} */
  #a;
  /** @type {Effect} */
  #l;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #f = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #h = null;
  #y = xme(() => (this.#h = Ef(this.#d), () => {
    this.#h = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, n, r) {
    this.#t = e, this.#r = n, this.#a = r, this.parent = /** @type {Effect} */
    on.b, this.#e = !!this.#r.pending, this.#l = P2(() => {
      if (on.b = this, sn) {
        const s = this.#n;
        ym(), /** @type {Comment} */
        s.nodeType === d0 && /** @type {Comment} */
        s.data === O2 ? this.#v() : this.#b();
      } else {
        var i = this.#x();
        try {
          this.#i = Bo(() => r(i));
        } catch (s) {
          this.error(s);
        }
        this.#f > 0 ? this.#m() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, wme), sn && (this.#t = Jt);
  }
  #b() {
    try {
      this.#i = Bo(() => this.#a(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #v() {
    const e = this.#r.pending;
    e && (this.#s = Bo(() => e(this.#t)), Zc.enqueue(() => {
      var n = this.#x();
      this.#i = this.#g(() => (Zc.ensure(), Bo(() => this.#a(n)))), this.#f > 0 ? this.#m() : (ld(
        /** @type {Effect} */
        this.#s,
        () => {
          this.#s = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = Jl(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #g(e) {
    var n = on, r = Xt, i = ds;
    Zl(this.#l), rs(this.#l), Nd(this.#l.ctx);
    try {
      return e();
    } catch (s) {
      return DL(s), null;
    } finally {
      Zl(n), rs(r), Nd(i);
    }
  }
  #m() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#r.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), e$(this.#i, this.#u)), this.#s === null && (this.#s = Bo(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#f += e, this.#f === 0 && (this.#e = !1, this.#s && ld(this.#s, () => {
      this.#s = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#h && Ld(this.#h, this.#d);
  }
  get_effect_pending() {
    return this.#y(), W(
      /** @type {Source<number>} */
      this.#h
    );
  }
  /** @param {unknown} error */
  error(e) {
    var n = this.#r.onerror;
    let r = this.#r.failed;
    if (this.#p || !n && !r)
      throw e;
    this.#i && (Bi(this.#i), this.#i = null), this.#s && (Bi(this.#s), this.#s = null), this.#o && (Bi(this.#o), this.#o = null), sn && (os(
      /** @type {TemplateNode} */
      this.#n
    ), _L(), os(fv()));
    var i = !1, s = !1;
    const o = () => {
      if (i) {
        mme();
        return;
      }
      i = !0, s && ime(), Zc.ensure(), this.#d = 0, this.#o !== null && ld(this.#o, () => {
        this.#o = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#g(() => (this.#p = !1, Bo(() => this.#a(this.#t)))), this.#f > 0 ? this.#m() : this.#e = !1;
    };
    var l = Xt;
    try {
      rs(null), s = !0, n?.(e, o), s = !1;
    } catch (a) {
      Bd(a, this.#l && this.#l.parent);
    } finally {
      rs(l);
    }
    r && p0(() => {
      this.#o = this.#g(() => {
        Zc.ensure(), this.#p = !0;
        try {
          return Bo(() => {
            r(
              this.#t,
              () => e,
              () => o
            );
          });
        } catch (a) {
          return Bd(
            a,
            /** @type {Effect} */
            this.#l.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function Cme(t, e, n, r) {
  const i = R2;
  if (n.length === 0 && t.length === 0) {
    r(e.map(i));
    return;
  }
  var s = Cr, o = (
    /** @type {Effect} */
    on
  ), l = Sme();
  function a() {
    Promise.all(n.map((u) => /* @__PURE__ */ Ame(u))).then((u) => {
      l();
      try {
        r([...e.map(i), ...u]);
      } catch (c) {
        (o.f & Ku) === 0 && Bd(c, o);
      }
      s?.deactivate(), hv();
    }).catch((u) => {
      Bd(u, o);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    l();
    try {
      return a();
    } finally {
      s?.deactivate(), hv();
    }
  }) : a();
}
function Sme() {
  var t = on, e = Xt, n = ds, r = Cr;
  return function(i = !0) {
    Zl(t), rs(e), Nd(n), i && r?.activate();
  };
}
function hv() {
  Zl(null), rs(null), Nd(null);
}
// @__NO_SIDE_EFFECTS__
function R2(t) {
  var e = yi | hs, n = Xt !== null && (Xt.f & yi) !== 0 ? (
    /** @type {Derived} */
    Xt
  ) : null;
  return on !== null && (on.f |= h0), {
    ctx: ds,
    deps: null,
    effects: null,
    equals: pL,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      Zr
    ),
    wv: 0,
    parent: n ?? on,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function Ame(t, e) {
  let n = (
    /** @type {Effect | null} */
    on
  );
  n === null && Kge();
  var r = (
    /** @type {Boundary} */
    n.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), s = Ef(
    /** @type {V} */
    Zr
  ), o = !Xt, l = /* @__PURE__ */ new Map();
  return Ime(() => {
    var a = dL();
    i = a.promise;
    try {
      Promise.resolve(t()).then(a.resolve, a.reject).then(() => {
        u === Cr && u.committed && u.deactivate(), hv();
      });
    } catch (d) {
      a.reject(d), hv();
    }
    var u = (
      /** @type {Batch} */
      Cr
    );
    if (o) {
      var c = !r.is_pending();
      r.update_pending_count(1), u.increment(c), l.get(u)?.reject($h), l.delete(u), l.set(u, a);
    }
    const f = (d, p = void 0) => {
      if (u.activate(), p)
        p !== $h && (s.f |= Yu, Ld(s, p));
      else {
        (s.f & Yu) !== 0 && (s.f ^= Yu), Ld(s, d);
        for (const [m, y] of l) {
          if (l.delete(m), m === u) break;
          y.reject($h);
        }
      }
      o && (r.update_pending_count(-1), u.decrement(c));
    };
    a.promise.then(f, (d) => f(null, d || "unknown"));
  }), WL(() => {
    for (const a of l.values())
      a.reject($h);
  }), new Promise((a) => {
    function u(c) {
      function f() {
        c === i ? a(s) : u(i);
      }
      c.then(f, f);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function yt(t) {
  const e = /* @__PURE__ */ R2(t);
  return LL(e), e;
}
// @__NO_SIDE_EFFECTS__
function RL(t) {
  const e = /* @__PURE__ */ R2(t);
  return e.equals = mL, e;
}
function ML(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var n = 0; n < e.length; n += 1)
      Bi(
        /** @type {Effect} */
        e[n]
      );
  }
}
function Eme(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & yi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function j5(t) {
  var e, n = on;
  Zl(Eme(t));
  try {
    t.f &= ~Ig, ML(t), e = qL(t);
  } finally {
    Zl(n);
  }
  return e;
}
function PL(t) {
  var e = j5(t);
  if (t.equals(e) || (t.v = e, t.wv = zL()), !Kf)
    if (Ns !== null)
      M2() && Ns.set(t, t.v);
    else {
      var n = (t.f & Jo) === 0 ? au : oi;
      hi(t, n);
    }
}
let ck = /* @__PURE__ */ new Set();
const Xu = /* @__PURE__ */ new Map();
let IL = !1;
function Ef(t, e) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: pL,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function Pn(t, e) {
  const n = Ef(t);
  return LL(n), n;
}
// @__NO_SIDE_EFFECTS__
function NL(t, e = !1, n = !0) {
  const r = Ef(t);
  return e || (r.equals = mL), r;
}
function dt(t, e, n = !1) {
  Xt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Ll || (Xt.f & N9) !== 0) && xL() && (Xt.f & (yi | ou | P5 | N9)) !== 0 && !Ga?.includes(t) && rme();
  let r = n ? Jc(e) : e;
  return Ld(t, r);
}
function Ld(t, e) {
  if (!t.equals(e)) {
    var n = t.v;
    Kf ? Xu.set(t, e) : Xu.set(t, n), t.v = e;
    var r = Zc.ensure();
    r.capture(t, n), (t.f & yi) !== 0 && ((t.f & hs) !== 0 && j5(
      /** @type {Derived} */
      t
    ), hi(t, (t.f & Jo) !== 0 ? oi : au)), t.wv = zL(), BL(t, hs), on !== null && (on.f & oi) !== 0 && (on.f & (lu | Vf)) === 0 && (ao === null ? Ome([t]) : ao.push(t)), !r.is_fork && ck.size > 0 && !IL && Dme();
  }
  return e;
}
function Dme() {
  IL = !1;
  const t = Array.from(ck);
  for (const e of t)
    (e.f & oi) !== 0 && hi(e, au), bm(e) && Bg(e);
  ck.clear();
}
function Bp(t) {
  dt(t, t.v + 1);
}
function BL(t, e) {
  var n = t.reactions;
  if (n !== null)
    for (var r = n.length, i = 0; i < r; i++) {
      var s = n[i], o = s.f, l = (o & hs) === 0;
      if (l && hi(s, e), (o & yi) !== 0) {
        var a = (
          /** @type {Derived} */
          s
        );
        Ns?.delete(a), (o & Ig) === 0 && (o & Jo && (s.f |= Ig), BL(a, au));
      } else l && ((o & ou) !== 0 && Fa !== null && Fa.add(
        /** @type {Effect} */
        s
      ), Af(
        /** @type {Effect} */
        s
      ));
    }
}
function q5(t) {
  var e = Xt, n = on;
  rs(null), Zl(null);
  try {
    return t();
  } finally {
    rs(e), Zl(n);
  }
}
let cf = !1;
function z9(t) {
  cf = t;
}
let Kf = !1;
function j9(t) {
  Kf = t;
}
let Xt = null, Ll = !1;
function rs(t) {
  Xt = t;
}
let on = null;
function Zl(t) {
  on = t;
}
let Ga = null;
function LL(t) {
  Xt !== null && (Ga === null ? Ga = [t] : Ga.push(t));
}
let Ei = null, Os = 0, ao = null;
function Ome(t) {
  ao = t;
}
let $L = 1, Ng = 0, ff = Ng;
function q9(t) {
  ff = t;
}
function zL() {
  return ++$L;
}
function bm(t) {
  var e = t.f;
  if ((e & hs) !== 0)
    return !0;
  if (e & yi && (t.f &= ~Ig), (e & au) !== 0) {
    var n = t.deps;
    if (n !== null)
      for (var r = n.length, i = 0; i < r; i++) {
        var s = n[i];
        if (bm(
          /** @type {Derived} */
          s
        ) && PL(
          /** @type {Derived} */
          s
        ), s.wv > t.wv)
          return !0;
      }
    (e & Jo) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Ns === null && hi(t, oi);
  }
  return !1;
}
function jL(t, e, n = !0) {
  var r = t.reactions;
  if (r !== null && !Ga?.includes(t))
    for (var i = 0; i < r.length; i++) {
      var s = r[i];
      (s.f & yi) !== 0 ? jL(
        /** @type {Derived} */
        s,
        e,
        !1
      ) : e === s && (n ? hi(s, hs) : (s.f & oi) !== 0 && hi(s, au), Af(
        /** @type {Effect} */
        s
      ));
    }
}
function qL(t) {
  var e = Ei, n = Os, r = ao, i = Xt, s = Ga, o = ds, l = Ll, a = ff, u = t.f;
  Ei = /** @type {null | Value[]} */
  null, Os = 0, ao = null, Xt = (u & (lu | Vf)) === 0 ? t : null, Ga = null, Nd(t.ctx), Ll = !1, ff = ++Ng, t.ac !== null && (q5(() => {
    t.ac.abort($h);
  }), t.ac = null);
  try {
    t.f |= ok;
    var c = (
      /** @type {Function} */
      t.fn
    ), f = c(), d = t.deps;
    if (Ei !== null) {
      var p;
      if (dv(t, Os), d !== null && Os > 0)
        for (d.length = Os + Ei.length, p = 0; p < Ei.length; p++)
          d[Os + p] = Ei[p];
      else
        t.deps = d = Ei;
      if (cf && M2() && (t.f & Jo) !== 0)
        for (p = Os; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Os < d.length && (dv(t, Os), d.length = Os);
    if (xL() && ao !== null && !Ll && d !== null && (t.f & (yi | au | hs)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      ao.length; p++)
        jL(
          ao[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (Ng++, ao !== null && (r === null ? r = ao : r.push(.../** @type {Source[]} */
    ao))), (t.f & Yu) !== 0 && (t.f ^= Yu), f;
  } catch (m) {
    return DL(m);
  } finally {
    t.f ^= ok, Ei = e, Os = n, ao = r, Xt = i, Ga = s, Nd(o), Ll = l, ff = a;
  }
}
function Fme(t, e) {
  let n = e.reactions;
  if (n !== null) {
    var r = Hge.call(n, t);
    if (r !== -1) {
      var i = n.length - 1;
      i === 0 ? n = e.reactions = null : (n[r] = n[i], n.pop());
    }
  }
  n === null && (e.f & yi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Ei === null || !Ei.includes(e)) && (hi(e, au), (e.f & Jo) !== 0 && (e.f ^= Jo, e.f &= ~Ig), ML(
    /** @type {Derived} **/
    e
  ), dv(
    /** @type {Derived} **/
    e,
    0
  ));
}
function dv(t, e) {
  var n = t.deps;
  if (n !== null)
    for (var r = e; r < n.length; r++)
      Fme(t, n[r]);
}
function Bg(t) {
  var e = t.f;
  if ((e & Ku) === 0) {
    hi(t, oi);
    var n = on, r = cf;
    on = t, cf = !0;
    try {
      (e & ou) !== 0 ? Nme(t) : XL(t), YL(t);
      var i = qL(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = $L;
      var s;
      Uge && sme && (t.f & hs) !== 0 && t.deps;
    } finally {
      cf = r, on = n;
    }
  }
}
function W(t) {
  var e = t.f, n = (e & yi) !== 0;
  if (Xt !== null && !Ll) {
    var r = on !== null && (on.f & Ku) !== 0;
    if (!r && !Ga?.includes(t)) {
      var i = Xt.deps;
      if ((Xt.f & ok) !== 0)
        t.rv < Ng && (t.rv = Ng, Ei === null && i !== null && i[Os] === t ? Os++ : Ei === null ? Ei = [t] : Ei.includes(t) || Ei.push(t));
      else {
        (Xt.deps ??= []).push(t);
        var s = t.reactions;
        s === null ? t.reactions = [Xt] : s.includes(Xt) || s.push(Xt);
      }
    }
  }
  if (Kf) {
    if (Xu.has(t))
      return Xu.get(t);
    if (n) {
      var o = (
        /** @type {Derived} */
        t
      ), l = o.v;
      return ((o.f & oi) === 0 && o.reactions !== null || HL(o)) && (l = j5(o)), Xu.set(o, l), l;
    }
  } else if (n) {
    if (o = /** @type {Derived} */
    t, Ns?.has(o))
      return Ns.get(o);
    bm(o) && PL(o), cf && M2() && (o.f & Jo) === 0 && UL(o);
  } else if (Ns?.has(t))
    return Ns.get(t);
  if ((t.f & Yu) !== 0)
    throw t.v;
  return t.v;
}
function UL(t) {
  if (t.deps !== null) {
    t.f ^= Jo;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & yi) !== 0 && (e.f & Jo) === 0 && UL(
        /** @type {Derived} */
        e
      );
  }
}
function HL(t) {
  if (t.v === Zr) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Xu.has(e) || (e.f & yi) !== 0 && HL(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function Yf(t) {
  var e = Ll;
  try {
    return Ll = !0, t();
  } finally {
    Ll = e;
  }
}
const Tme = -7169;
function hi(t, e) {
  t.f = t.f & Tme | e;
}
function Rme(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (uf in t)
      fk(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const n = t[e];
        typeof n == "object" && n && uf in n && fk(n);
      }
  }
}
function fk(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let r in t)
      try {
        fk(t[r], e);
      } catch {
      }
    const n = B5(t);
    if (n !== Object.prototype && n !== Array.prototype && n !== Map.prototype && n !== Set.prototype && n !== Date.prototype) {
      const r = hL(n);
      for (let i in r) {
        const s = r[i].get;
        if (s)
          try {
            s.call(t);
          } catch {
          }
      }
    }
  }
}
function VL(t) {
  on === null && (Xt === null && Qge(), Xge()), Kf && Yge();
}
function Mme(t, e) {
  var n = e.last;
  n === null ? e.last = e.first = t : (n.next = t, t.prev = n, e.last = t);
}
function ca(t, e, n, r = !0) {
  var i = on;
  i !== null && (i.f & Us) !== 0 && (t |= Us);
  var s = {
    ctx: ds,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | hs | Jo,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (n)
    try {
      Bg(s), s.f |= D2;
    } catch (a) {
      throw Bi(s), a;
    }
  else e !== null && Af(s);
  if (r) {
    var o = s;
    if (n && o.deps === null && o.teardown === null && o.nodes_start === null && o.first === o.last && // either `null`, or a singular child
    (o.f & h0) === 0 && (o = o.first, (t & ou) !== 0 && (t & Pd) !== 0 && o !== null && (o.f |= Pd)), o !== null && (o.parent = i, i !== null && Mme(o, i), Xt !== null && (Xt.f & yi) !== 0 && (t & Vf) === 0)) {
      var l = (
        /** @type {Derived} */
        Xt
      );
      (l.effects ??= []).push(o);
    }
  }
  return s;
}
function M2() {
  return Xt !== null && !Ll;
}
function WL(t) {
  const e = ca(A2, null, !1);
  return hi(e, oi), e.teardown = t, e;
}
function Ea(t) {
  VL();
  var e = (
    /** @type {Effect} */
    on.f
  ), n = !Xt && (e & lu) !== 0 && (e & D2) === 0;
  if (n) {
    var r = (
      /** @type {ComponentContext} */
      ds
    );
    (r.e ??= []).push(t);
  } else
    return GL(t);
}
function GL(t) {
  return ca(S2 | aL, t, !1);
}
function Lp(t) {
  return VL(), ca(A2 | aL, t, !0);
}
function Pme(t) {
  Zc.ensure();
  const e = ca(Vf | h0, t, !0);
  return (n = {}) => new Promise((r) => {
    n.outro ? ld(e, () => {
      Bi(e), r(void 0);
    }) : (Bi(e), r(void 0));
  });
}
function KL(t) {
  return ca(S2, t, !1);
}
function Ime(t) {
  return ca(P5 | h0, t, !0);
}
function U5(t, e = 0) {
  return ca(A2 | e, t, !0);
}
function Bs(t, e = [], n = [], r = [], i = !1) {
  Cme(r, e, n, (s) => {
    ca(i ? S2 : A2, () => t(...s.map(W)), !0);
  });
}
function P2(t, e = 0) {
  var n = ca(ou | e, t, !0);
  return n;
}
function Bo(t, e = !0) {
  return ca(lu | h0, t, !0, e);
}
function YL(t) {
  var e = t.teardown;
  if (e !== null) {
    const n = Kf, r = Xt;
    j9(!0), rs(null);
    try {
      e.call(null);
    } finally {
      j9(n), rs(r);
    }
  }
}
function XL(t, e = !1) {
  var n = t.first;
  for (t.first = t.last = null; n !== null; ) {
    const i = n.ac;
    i !== null && q5(() => {
      i.abort($h);
    });
    var r = n.next;
    (n.f & Vf) !== 0 ? n.parent = null : Bi(n, e), n = r;
  }
}
function Nme(t) {
  for (var e = t.first; e !== null; ) {
    var n = e.next;
    (e.f & lu) === 0 && Bi(e), e = n;
  }
}
function Bi(t, e = !0) {
  var n = !1;
  (e || (t.f & lL) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (Bme(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), n = !0), XL(t, e && !n), dv(t, 0), hi(t, Ku);
  var r = t.transitions;
  if (r !== null)
    for (const s of r)
      s.stop();
  YL(t);
  var i = t.parent;
  i !== null && i.first !== null && QL(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function Bme(t, e) {
  for (; t !== null; ) {
    var n = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ua(t)
    );
    t.remove(), t = n;
  }
}
function QL(t) {
  var e = t.parent, n = t.prev, r = t.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), e !== null && (e.first === t && (e.first = r), e.last === t && (e.last = n));
}
function ld(t, e, n = !0) {
  var r = [];
  H5(t, r, !0), JL(r, () => {
    n && Bi(t), e && e();
  });
}
function JL(t, e) {
  var n = t.length;
  if (n > 0) {
    var r = () => --n || e();
    for (var i of t)
      i.out(r);
  } else
    e();
}
function H5(t, e, n) {
  if ((t.f & Us) === 0) {
    if (t.f ^= Us, t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || n) && e.push(o);
    for (var r = t.first; r !== null; ) {
      var i = r.next, s = (r.f & Pd) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (r.f & lu) !== 0 && (t.f & ou) !== 0;
      H5(r, e, s ? n : !1), r = i;
    }
  }
}
function V5(t) {
  ZL(t, !0);
}
function ZL(t, e) {
  if ((t.f & Us) !== 0) {
    t.f ^= Us, (t.f & oi) === 0 && (hi(t, hs), Af(t));
    for (var n = t.first; n !== null; ) {
      var r = n.next, i = (n.f & Pd) !== 0 || (n.f & lu) !== 0;
      ZL(n, i ? e : !1), n = r;
    }
    if (t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || e) && s.in();
  }
}
function e$(t, e) {
  for (var n = t.nodes_start, r = t.nodes_end; n !== null; ) {
    var i = n === r ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ua(n)
    );
    e.append(n), n = i;
  }
}
const t$ = /* @__PURE__ */ new Set(), hk = /* @__PURE__ */ new Set();
function Lme(t, e, n, r = {}) {
  function i(s) {
    if (r.capture || xp.call(e, s), !s.cancelBubble)
      return q5(() => n?.call(this, s));
  }
  return p0(() => {
    e.addEventListener(t, i, r);
  }), i;
}
function $me(t, e, n, r, i) {
  var s = { capture: r, passive: i }, o = Lme(t, e, n, s);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && WL(() => {
    e.removeEventListener(t, o, s);
  });
}
function zme(t) {
  for (var e = 0; e < t.length; e++)
    t$.add(t[e]);
  for (var n of hk)
    n(t);
}
let U9 = null;
function xp(t) {
  var e = this, n = (
    /** @type {Node} */
    e.ownerDocument
  ), r = t.type, i = t.composedPath?.() || [], s = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  U9 = t;
  var o = 0, l = U9 === t && t.__root;
  if (l) {
    var a = i.indexOf(l);
    if (a !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    a <= u && (o = a);
  }
  if (s = /** @type {Element} */
  i[o] || t.target, s !== e) {
    fL(t, "currentTarget", {
      configurable: !0,
      get() {
        return s || n;
      }
    });
    var c = Xt, f = on;
    rs(null), Zl(null);
    try {
      for (var d, p = []; s !== null; ) {
        var m = s.assignedSlot || s.parentNode || /** @type {any} */
        s.host || null;
        try {
          var y = s["__" + r];
          y != null && (!/** @type {any} */
          s.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === s) && y.call(s, t);
        } catch (b) {
          d ? p.push(b) : d = b;
        }
        if (t.cancelBubble || m === e || m === null)
          break;
        s = m;
      }
      if (d) {
        for (let b of p)
          queueMicrotask(() => {
            throw b;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, rs(c), Zl(f);
    }
  }
}
function n$(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Qu(t, e) {
  var n = (
    /** @type {Effect} */
    on
  );
  n.nodes_start === null && (n.nodes_start = t, n.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function bc(t, e) {
  var n = (e & hme) !== 0, r = (e & dme) !== 0, i, s = !t.startsWith("<!>");
  return () => {
    if (sn)
      return Qu(Jt, null), Jt;
    i === void 0 && (i = n$(s ? t : "<!>" + t), n || (i = /** @type {Node} */
    /* @__PURE__ */ Ja(i)));
    var o = (
      /** @type {TemplateNode} */
      r || CL ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (n) {
      var l = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Ja(o)
      ), a = (
        /** @type {TemplateNode} */
        o.lastChild
      );
      Qu(l, a);
    } else
      Qu(o, o);
    return o;
  };
}
// @__NO_SIDE_EFFECTS__
function jme(t, e, n = "svg") {
  var r = !t.startsWith("<!>"), i = `<${n}>${r ? t : "<!>" + t}</${n}>`, s;
  return () => {
    if (sn)
      return Qu(Jt, null), Jt;
    if (!s) {
      var o = (
        /** @type {DocumentFragment} */
        n$(i)
      ), l = (
        /** @type {Element} */
        /* @__PURE__ */ Ja(o)
      );
      s = /** @type {Element} */
      /* @__PURE__ */ Ja(l);
    }
    var a = (
      /** @type {TemplateNode} */
      s.cloneNode(!0)
    );
    return Qu(a, a), a;
  };
}
// @__NO_SIDE_EFFECTS__
function uu(t, e) {
  return /* @__PURE__ */ jme(t, e, "svg");
}
function np() {
  if (sn)
    return Qu(Jt, null), Jt;
  var t = document.createDocumentFragment(), e = document.createComment(""), n = Jl();
  return t.append(e, n), Qu(e, n), t;
}
function rr(t, e) {
  if (sn) {
    var n = (
      /** @type {Effect} */
      on
    );
    ((n.f & D2) === 0 || n.nodes_end === null) && (n.nodes_end = Jt), ym();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
const qme = ["touchstart", "touchmove"];
function Ume(t) {
  return qme.includes(t);
}
function $p(t, e) {
  var n = e == null ? "" : typeof e == "object" ? e + "" : e;
  n !== (t.__t ??= t.nodeValue) && (t.__t = n, t.nodeValue = n + "");
}
function r$(t, e) {
  return i$(t, e);
}
function Hme(t, e) {
  lk(), e.intro = e.intro ?? !1;
  const n = e.target, r = sn, i = Jt;
  try {
    for (var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Ja(n)
    ); s && (s.nodeType !== d0 || /** @type {Comment} */
    s.data !== vL); )
      s = /** @type {TemplateNode} */
      /* @__PURE__ */ ua(s);
    if (!s)
      throw Id;
    ja(!0), os(
      /** @type {Comment} */
      s
    );
    const o = i$(t, { ...e, anchor: s });
    return ja(!1), /**  @type {Exports} */
    o;
  } catch (o) {
    if (o instanceof Error && o.message.split(`
`).some((l) => l.startsWith("https://svelte.dev/e/")))
      throw o;
    return o !== Id && console.warn("Failed to hydrate: ", o), e.recover === !1 && Zge(), lk(), EL(n), ja(!1), r$(t, e);
  } finally {
    ja(r), os(i);
  }
}
const wh = /* @__PURE__ */ new Map();
function i$(t, { target: e, anchor: n, props: r = {}, events: i, context: s, intro: o = !0 }) {
  lk();
  var l = /* @__PURE__ */ new Set(), a = (f) => {
    for (var d = 0; d < f.length; d++) {
      var p = f[d];
      if (!l.has(p)) {
        l.add(p);
        var m = Ume(p);
        e.addEventListener(p, xp, { passive: m });
        var y = wh.get(p);
        y === void 0 ? (document.addEventListener(p, xp, { passive: m }), wh.set(p, 1)) : wh.set(p, y + 1);
      }
    }
  };
  a(N5(t$)), hk.add(a);
  var u = void 0, c = Pme(() => {
    var f = n ?? e.appendChild(Jl());
    return _me(
      /** @type {TemplateNode} */
      f,
      {
        pending: () => {
        }
      },
      (d) => {
        if (s) {
          Wf({});
          var p = (
            /** @type {ComponentContext} */
            ds
          );
          p.c = s;
        }
        if (i && (r.$$events = i), sn && Qu(
          /** @type {TemplateNode} */
          d,
          null
        ), u = t(d, r) || {}, sn && (on.nodes_end = Jt, Jt === null || Jt.nodeType !== d0 || /** @type {Comment} */
        Jt.data !== z5))
          throw F2(), Id;
        s && Gf();
      }
    ), () => {
      for (var d of l) {
        e.removeEventListener(d, xp);
        var p = (
          /** @type {number} */
          wh.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, xp), wh.delete(d)) : wh.set(d, p);
      }
      hk.delete(a), f !== n && f.parentNode?.removeChild(f);
    };
  });
  return dk.set(u, c), u;
}
let dk = /* @__PURE__ */ new WeakMap();
function Vme(t, e) {
  const n = dk.get(t);
  return n ? (dk.delete(t), n(e)) : Promise.resolve();
}
function Wme(t) {
  return new Gme(t);
}
class Gme {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var n = /* @__PURE__ */ new Map(), r = (s, o) => {
      var l = /* @__PURE__ */ NL(o, !1, !1);
      return n.set(s, l), l;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(s, o) {
          return W(n.get(o) ?? r(o, Reflect.get(s, o)));
        },
        has(s, o) {
          return o === uL ? !0 : (W(n.get(o) ?? r(o, Reflect.get(s, o))), Reflect.has(s, o));
        },
        set(s, o, l) {
          return dt(n.get(o) ?? r(o, l), l), Reflect.set(s, o, l);
        }
      }
    );
    this.#t = (e.hydrate ? Hme : r$)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && bme(), this.#e = i.$$events;
    for (const s of Object.keys(this.#t))
      s === "$set" || s === "$destroy" || s === "$on" || fL(this, s, {
        get() {
          return this.#t[s];
        },
        /** @param {any} value */
        set(o) {
          this.#t[s] = o;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (s) => {
      Object.assign(i, s);
    }, this.#t.$destroy = () => {
      Vme(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, n) {
    this.#e[e] = this.#e[e] || [];
    const r = (...i) => n.call(this, ...i);
    return this.#e[e].push(r), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== r
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const Kme = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(Kme);
class s$ {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #n = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #r = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, n = !0) {
    this.anchor = e, this.#r = n;
  }
  #a = () => {
    var e = (
      /** @type {Batch} */
      Cr
    );
    if (this.#e.has(e)) {
      var n = (
        /** @type {Key} */
        this.#e.get(e)
      ), r = this.#t.get(n);
      if (r)
        V5(r);
      else {
        var i = this.#n.get(n);
        i && (this.#t.set(n, i.effect), this.#n.delete(n), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), r = i.effect);
      }
      for (const [s, o] of this.#e) {
        if (this.#e.delete(s), s === e)
          break;
        const l = this.#n.get(o);
        l && (Bi(l.effect), this.#n.delete(o));
      }
      for (const [s, o] of this.#t) {
        if (s === n) continue;
        const l = () => {
          if (Array.from(this.#e.values()).includes(s)) {
            var a = document.createDocumentFragment();
            e$(o, a), a.append(Jl()), this.#n.set(s, { effect: o, fragment: a });
          } else
            Bi(o);
          this.#t.delete(s);
        };
        this.#r || !r ? ld(o, l, !1) : l();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #l = (e) => {
    this.#e.delete(e);
    const n = Array.from(this.#e.values());
    for (const [r, i] of this.#n)
      n.includes(r) || (Bi(i.effect), this.#n.delete(r));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, n) {
    var r = (
      /** @type {Batch} */
      Cr
    ), i = yme();
    n && !this.#t.has(e) && !this.#n.has(e) && this.#t.set(
      e,
      Bo(() => n(this.anchor))
    ), this.#e.set(r, e), i || (sn && (this.anchor = Jt), this.#a());
  }
}
function W5(t) {
  ds === null && yL(), Ea(() => {
    const e = Yf(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function Yme(t) {
  ds === null && yL(), W5(() => () => Yf(t));
}
function Vi(t, e, n = !1) {
  sn && ym();
  var r = new s$(t), i = n ? Pd : 0;
  function s(o, l) {
    if (sn) {
      const u = kL(t) === O2;
      if (o === u) {
        var a = fv();
        os(a), r.anchor = a, ja(!1), r.ensure(o, l), ja(!0);
        return;
      }
    }
    r.ensure(o, l);
  }
  P2(() => {
    var o = !1;
    e((l, a = !0) => {
      o = !0, s(a, l);
    }), o || s(!1, null);
  }, i);
}
function Xme(t, e, n) {
  sn && ym();
  var r = new s$(t);
  P2(() => {
    var i = e();
    r.ensure(i, n);
  });
}
function B3(t, e) {
  return e;
}
function Qme(t, e, n) {
  for (var r = t.items, i = [], s = e.length, o = 0; o < s; o++)
    H5(e[o].e, i, !0);
  var l = s > 0 && i.length === 0 && n !== null;
  if (l) {
    var a = (
      /** @type {Element} */
      /** @type {Element} */
      n.parentNode
    );
    EL(a), a.append(
      /** @type {Element} */
      n
    ), r.clear(), wl(t, e[0].prev, e[s - 1].next);
  }
  JL(i, () => {
    for (var u = 0; u < s; u++) {
      var c = e[u];
      l || (r.delete(c.k), wl(t, c.prev, c.next)), Bi(c.e, !l);
    }
  });
}
function L3(t, e, n, r, i, s = null) {
  var o = t, l = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, a = (e & bL) !== 0;
  if (a) {
    var u = (
      /** @type {Element} */
      t
    );
    o = sn ? os(
      /** @type {Comment | Text} */
      /* @__PURE__ */ Ja(u)
    ) : u.appendChild(Jl());
  }
  sn && ym();
  var c = null, f = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ RL(() => {
    var v = n();
    return cL(v) ? v : v == null ? [] : N5(v);
  }), m, y;
  function b() {
    Jme(
      y,
      m,
      l,
      d,
      o,
      i,
      e,
      r,
      n
    ), s !== null && (m.length === 0 ? c ? V5(c) : c = Bo(() => s(o)) : c !== null && ld(c, () => {
      c = null;
    }));
  }
  P2(() => {
    y ??= /** @type {Effect} */
    on, m = /** @type {V[]} */
    W(p);
    var v = m.length;
    if (f && v === 0)
      return;
    f = v === 0;
    let _ = !1;
    if (sn) {
      var k = kL(o) === O2;
      k !== (v === 0) && (o = fv(), os(o), ja(!1), _ = !0);
    }
    if (sn) {
      for (var S = null, C, E = 0; E < v; E++) {
        if (Jt.nodeType === d0 && /** @type {Comment} */
        Jt.data === z5) {
          o = /** @type {Comment} */
          Jt, _ = !0, ja(!1);
          break;
        }
        var A = m[E], O = r(A, E);
        C = o$(
          Jt,
          l,
          S,
          null,
          A,
          O,
          E,
          i,
          e,
          n
        ), l.items.set(O, C), S = C;
      }
      v > 0 && os(fv());
    }
    sn ? v === 0 && s && (c = Bo(() => s(o))) : b(), _ && ja(!0), W(p);
  }), sn && (o = Jt);
}
function Jme(t, e, n, r, i, s, o, l, a) {
  var u = (o & ome) !== 0, c = (o & (L5 | $5)) !== 0, f = e.length, d = n.items, p = n.first, m = p, y, b = null, v, _ = [], k = [], S, C, E, A;
  if (u)
    for (A = 0; A < f; A += 1)
      S = e[A], C = l(S, A), E = d.get(C), E !== void 0 && (E.a?.measure(), (v ??= /* @__PURE__ */ new Set()).add(E));
  for (A = 0; A < f; A += 1) {
    if (S = e[A], C = l(S, A), E = d.get(C), E === void 0) {
      var O = r.get(C);
      if (O !== void 0) {
        r.delete(C), d.set(C, O);
        var T = b ? b.next : m;
        wl(n, b, O), wl(n, O, T), $3(O, T, i), b = O;
      } else {
        var $ = m ? (
          /** @type {TemplateNode} */
          m.e.nodes_start
        ) : i;
        b = o$(
          $,
          n,
          b,
          b === null ? n.first : b.next,
          S,
          C,
          A,
          s,
          o,
          a
        );
      }
      d.set(C, b), _ = [], k = [], m = b.next;
      continue;
    }
    if (c && Zme(E, S, A, o), (E.e.f & Us) !== 0 && (V5(E.e), u && (E.a?.unfix(), (v ??= /* @__PURE__ */ new Set()).delete(E))), E !== m) {
      if (y !== void 0 && y.has(E)) {
        if (_.length < k.length) {
          var P = k[0], B;
          b = P.prev;
          var M = _[0], L = _[_.length - 1];
          for (B = 0; B < _.length; B += 1)
            $3(_[B], P, i);
          for (B = 0; B < k.length; B += 1)
            y.delete(k[B]);
          wl(n, M.prev, L.next), wl(n, b, M), wl(n, L, P), m = P, b = L, A -= 1, _ = [], k = [];
        } else
          y.delete(E), $3(E, m, i), wl(n, E.prev, E.next), wl(n, E, b === null ? n.first : b.next), wl(n, b, E), b = E;
        continue;
      }
      for (_ = [], k = []; m !== null && m.k !== C; )
        (m.e.f & Us) === 0 && (y ??= /* @__PURE__ */ new Set()).add(m), k.push(m), m = m.next;
      if (m === null)
        continue;
      E = m;
    }
    _.push(E), b = E, m = E.next;
  }
  if (m !== null || y !== void 0) {
    for (var N = y === void 0 ? [] : N5(y); m !== null; )
      (m.e.f & Us) === 0 && N.push(m), m = m.next;
    var j = N.length;
    if (j > 0) {
      var U = (o & bL) !== 0 && f === 0 ? i : null;
      if (u) {
        for (A = 0; A < j; A += 1)
          N[A].a?.measure();
        for (A = 0; A < j; A += 1)
          N[A].a?.fix();
      }
      Qme(n, N, U);
    }
  }
  u && p0(() => {
    if (v !== void 0)
      for (E of v)
        E.a?.apply();
  }), t.first = n.first && n.first.e, t.last = b && b.e;
  for (var H of r.values())
    Bi(H.e);
  r.clear();
}
function Zme(t, e, n, r) {
  (r & L5) !== 0 && Ld(t.v, e), (r & $5) !== 0 ? Ld(
    /** @type {Value<number>} */
    t.i,
    n
  ) : t.i = n;
}
function o$(t, e, n, r, i, s, o, l, a, u, c) {
  var f = (a & L5) !== 0, d = (a & lme) === 0, p = f ? d ? /* @__PURE__ */ NL(i, !1, !1) : Ef(i) : i, m = (a & $5) === 0 ? o : Ef(o), y = {
    i: m,
    v: p,
    k: s,
    a: null,
    // @ts-expect-error
    e: null,
    prev: n,
    next: r
  };
  try {
    if (t === null) {
      var b = document.createDocumentFragment();
      b.append(t = Jl());
    }
    return y.e = Bo(() => l(
      /** @type {Node} */
      t,
      p,
      m,
      u
    ), sn), y.e.prev = n && n.e, y.e.next = r && r.e, n === null ? c || (e.first = y) : (n.next = y, n.e.next = y.e), r !== null && (r.prev = y, r.e.prev = y.e), y;
  } finally {
  }
}
function $3(t, e, n) {
  for (var r = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : n, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : n, s = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); s !== null && s !== r; ) {
    var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ua(s)
    );
    i.before(s), s = o;
  }
}
function wl(t, e, n) {
  e === null ? t.first = n : (e.next = n, e.e.next = n && n.e), n !== null && (n.prev = e, n.e.prev = e && e.e);
}
function Po(t, e, n) {
  KL(() => {
    var r = Yf(() => e(t, n?.()) || {});
    if (n && r?.update) {
      var i = !1, s = (
        /** @type {any} */
        {}
      );
      U5(() => {
        var o = n();
        Rme(o), i && gL(s, o) && (s = o, r.update(o));
      }), i = !0;
    }
    if (r?.destroy)
      return () => (
        /** @type {Function} */
        r.destroy()
      );
  });
}
function H9(t, e = !1) {
  var n = e ? " !important;" : ";", r = "";
  for (var i in t) {
    var s = t[i];
    s != null && s !== "" && (r += " " + i + ": " + s + n);
  }
  return r;
}
function e1e(t, e) {
  if (e) {
    var n = "", r, i;
    return Array.isArray(e) ? (r = e[0], i = e[1]) : r = e, r && (n += H9(r)), i && (n += H9(i, !0)), n = n.trim(), n === "" ? null : n;
  }
  return String(t);
}
function z3(t, e = {}, n, r) {
  for (var i in n) {
    var s = n[i];
    e[i] !== s && (n[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, s, r));
  }
}
function Kt(t, e, n, r) {
  var i = t.__style;
  if (sn || i !== e) {
    var s = e1e(e, r);
    (!sn || s !== t.getAttribute("style")) && (s == null ? t.removeAttribute("style") : t.style.cssText = s), t.__style = e;
  } else r && (Array.isArray(r) ? (z3(t, n?.[0], r[0]), z3(t, n?.[1], r[1], "important")) : z3(t, n, r));
  return r;
}
const t1e = Symbol("is custom element"), n1e = Symbol("is html");
function Ue(t, e, n, r) {
  var i = r1e(t);
  sn && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = n) && (e === "loading" && (t[qge] = n), n == null ? t.removeAttribute(e) : typeof n != "string" && i1e(t).includes(e) ? t[e] = n : t.setAttribute(e, n));
}
function r1e(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [t1e]: t.nodeName.includes("-"),
      [n1e]: t.namespaceURI === pme
    }
  );
}
var V9 = /* @__PURE__ */ new Map();
function i1e(t) {
  var e = t.getAttribute("is") || t.nodeName, n = V9.get(e);
  if (n) return n;
  V9.set(e, n = []);
  for (var r, i = t, s = Element.prototype; s !== i; ) {
    r = hL(i);
    for (var o in r)
      r[o].set && n.push(o);
    i = B5(i);
  }
  return n;
}
function W9(t, e) {
  return t === e || t?.[uf] === e;
}
function pk(t = {}, e, n, r) {
  return KL(() => {
    var i, s;
    return U5(() => {
      i = s, s = [], Yf(() => {
        t !== n(...s) && (e(t, ...s), i && W9(n(...i), t) && e(null, ...i));
      });
    }), () => {
      p0(() => {
        s && W9(n(...s), t) && e(null, ...s);
      });
    };
  }), t;
}
let py = !1;
function s1e(t) {
  var e = py;
  try {
    return py = !1, [t(), py];
  } finally {
    py = e;
  }
}
function nt(t, e, n, r) {
  var i = (n & cme) !== 0, s = (n & fme) !== 0, o = (
    /** @type {V} */
    r
  ), l = !0, a = () => (l && (l = !1, o = s ? Yf(
    /** @type {() => V} */
    r
  ) : (
    /** @type {V} */
    r
  )), o), u;
  if (i) {
    var c = uf in t || uL in t;
    u = od(t, e)?.set ?? (c && e in t ? (_) => t[e] = _ : void 0);
  }
  var f, d = !1;
  i ? [f, d] = s1e(() => (
    /** @type {V} */
    t[e]
  )) : f = /** @type {V} */
  t[e], f === void 0 && r !== void 0 && (f = a(), u && (eme(), u(f)));
  var p;
  if (p = () => {
    var _ = (
      /** @type {V} */
      t[e]
    );
    return _ === void 0 ? a() : (l = !0, _);
  }, (n & ume) === 0)
    return p;
  if (u) {
    var m = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(_, k) {
        return arguments.length > 0 ? ((!k || m || d) && u(k ? p() : _), _) : p();
      })
    );
  }
  var y = !1, b = ((n & ame) !== 0 ? R2 : RL)(() => (y = !1, p()));
  i && W(b);
  var v = (
    /** @type {Effect} */
    on
  );
  return (
    /** @type {() => V} */
    (function(_, k) {
      if (arguments.length > 0) {
        const S = k ? W(b) : i ? Jc(_) : _;
        return dt(b, S), y = !0, o !== void 0 && (o = S), _;
      }
      return Kf && y || (v.f & Ku) !== 0 ? b.v : W(b);
    })
  );
}
var o1e = /* @__PURE__ */ uu('<g><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect></g>');
function l1e(t, e) {
  Wf(e, !0);
  let n = /* @__PURE__ */ yt(() => e.pointLocation(e.value.xMin, e.value.yMin)), r = /* @__PURE__ */ yt(() => e.pointLocation(e.value.xMax, e.value.yMax));
  const i = 8;
  function s(b) {
    return (v) => {
      e.preventHover(!0);
      let _ = [W(n).x, W(n).y, W(r).x, W(r).y];
      return {
        move: (k) => {
          let S = k.pageX - v.pageX, C = k.pageY - v.pageY, E = [S, C, S, C].map((T, $) => _[$] + T * b[$]), A = e.coordinateAtPoint(E[0], E[1]), O = e.coordinateAtPoint(E[2], E[3]);
          e.onChange({
            xMin: Math.min(A.x, O.x),
            xMax: Math.max(A.x, O.x),
            yMin: Math.min(A.y, O.y),
            yMax: Math.max(A.y, O.y)
          });
        },
        up: () => {
          e.preventHover(!1);
        },
        cancel: () => {
          e.preventHover(!1);
        }
      };
    };
  }
  var o = o1e(), l = Nr(o);
  Kt(l, "", {}, {
    stroke: "#fff",
    fill: "rgba(128,128,128,0.25)",
    cursor: "move"
  }), Po(l, (b, v) => mr?.(b, v), () => ({ drag: s([1, 1, 1, 1]) }));
  var a = Vn(l);
  Ue(a, "width", i), Kt(a, "", {}, {
    cursor: "ew-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(a, (b, v) => mr?.(b, v), () => ({ drag: s([1, 0, 0, 0]) }));
  var u = Vn(a);
  Ue(u, "width", i), Kt(u, "", {}, {
    cursor: "ew-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(u, (b, v) => mr?.(b, v), () => ({ drag: s([0, 0, 1, 0]) }));
  var c = Vn(u);
  Ue(c, "height", i), Kt(c, "", {}, {
    cursor: "ns-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(c, (b, v) => mr?.(b, v), () => ({ drag: s([0, 1, 0, 0]) }));
  var f = Vn(c);
  Ue(f, "height", i), Kt(f, "", {}, {
    cursor: "ns-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(f, (b, v) => mr?.(b, v), () => ({ drag: s([0, 0, 0, 1]) }));
  var d = Vn(f);
  Ue(d, "width", i), Ue(d, "height", i), Kt(d, "", {}, {
    cursor: "nesw-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(d, (b, v) => mr?.(b, v), () => ({ drag: s([1, 1, 0, 0]) }));
  var p = Vn(d);
  Ue(p, "width", i), Ue(p, "height", i), Kt(p, "", {}, {
    cursor: "nwse-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(p, (b, v) => mr?.(b, v), () => ({ drag: s([1, 0, 0, 1]) }));
  var m = Vn(p);
  Ue(m, "width", i), Ue(m, "height", i), Kt(m, "", {}, {
    cursor: "nwse-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(m, (b, v) => mr?.(b, v), () => ({ drag: s([0, 1, 1, 0]) }));
  var y = Vn(m);
  Ue(y, "width", i), Ue(y, "height", i), Kt(y, "", {}, {
    cursor: "nesw-resize",
    stroke: "none",
    fill: "none",
    "pointer-events": "all"
  }), Po(y, (b, v) => mr?.(b, v), () => ({ drag: s([0, 0, 1, 1]) })), br(o), Bs(
    (b, v, _, k, S, C, E, A, O, T, $, P) => {
      Ue(l, "x", b), Ue(l, "width", v), Ue(l, "y", _), Ue(l, "height", k), Ue(a, "x", W(n).x - i / 2), Ue(a, "y", S), Ue(a, "height", C), Ue(u, "x", W(r).x - i / 2), Ue(u, "y", E), Ue(u, "height", A), Ue(c, "x", O), Ue(c, "width", T), Ue(c, "y", W(n).y - i / 2), Ue(f, "x", $), Ue(f, "width", P), Ue(f, "y", W(r).y - i / 2), Ue(d, "x", W(n).x - i / 2), Ue(d, "y", W(n).y - i / 2), Ue(p, "x", W(n).x - i / 2), Ue(p, "y", W(r).y - i / 2), Ue(m, "x", W(r).x - i / 2), Ue(m, "y", W(n).y - i / 2), Ue(y, "x", W(r).x - i / 2), Ue(y, "y", W(r).y - i / 2);
    },
    [
      () => Math.min(W(n).x, W(r).x),
      () => Math.abs(W(n).x - W(r).x),
      () => Math.min(W(n).y, W(r).y),
      () => Math.abs(W(n).y - W(r).y),
      () => Math.min(W(n).y, W(r).y),
      () => Math.abs(W(n).y - W(r).y),
      () => Math.min(W(n).y, W(r).y),
      () => Math.abs(W(n).y - W(r).y),
      () => Math.min(W(n).x, W(r).x),
      () => Math.abs(W(n).x - W(r).x),
      () => Math.min(W(n).x, W(r).x),
      () => Math.abs(W(n).x - W(r).x)
    ]
  ), rr(t, o), Gf();
}
function a1e(t, e) {
  let n = !1, r, i, s, o = 300, l = 300, a = async (c) => {
    n = !0;
    try {
      await t(c);
    } catch (f) {
      console.error(f);
    }
    if (n = !1, r !== void 0) {
      let f = r;
      r = void 0, u(f);
    }
  }, u = async (c) => {
    if (n) {
      r = c;
      return;
    }
    let f = (/* @__PURE__ */ new Date()).getTime();
    e() && (i = f);
    let d = !0;
    (i == null || f - i < l) && (d = !1), d ? (s && clearTimeout(s), s = setTimeout(() => a(c), o)) : a(c);
  };
  return u;
}
function u1e(t, e) {
  let n = t.x - e.x, r = t.y - e.y;
  return Math.sqrt(n * n + r * r);
}
function c1e(t) {
  return "M " + t.map(({ x: e, y: n }) => `${e},${n}`).join(" L ") + " Z";
}
function l$(t) {
  let e = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0;
  for (let { x: s, y: o } of t)
    e = Math.min(e, s), r = Math.min(r, o), n = Math.max(n, s), i = Math.max(i, o);
  return { xMin: e, yMin: r, xMax: n, yMax: i };
}
async function f1e(t) {
  let e = JSON.stringify(t);
  return d1e(e);
}
function Bu(t, e) {
  if (t === e)
    return !0;
  if (t === null || e === null || typeof t != "object" || typeof e != "object" || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (let n in t)
    if (e.hasOwnProperty(n)) {
      if (!Bu(t[n], e[n]))
        return !1;
    } else
      return !1;
  return !0;
}
function h1e(t, e = 0) {
  let n = 3735928559 ^ e, r = 1103547991 ^ e;
  for (let i = 0; i < t.length; i++) {
    let s = t[i];
    n = Math.imul(n ^ s, 2654435761), r = Math.imul(r ^ s, 1597334677);
  }
  return n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(r ^ r >>> 13, 3266489909), r = Math.imul(r ^ r >>> 16, 2246822507), r ^= Math.imul(n ^ n >>> 13, 3266489909), [r >>> 0, n >>> 0];
}
function d1e(t) {
  let e = new TextEncoder().encode(t), n = h1e(e);
  return n[0].toString(16).padStart(8, "0") + n[1].toString(16).padStart(8, "0");
}
var p1e = /* @__PURE__ */ uu("<path></path>");
function g1e(t, e) {
  Wf(e, !0);
  let n = /* @__PURE__ */ yt(() => e.value.map(({ x: i, y: s }) => e.pointLocation(i, s)));
  var r = p1e();
  Kt(r, "", {}, { stroke: "#fff", fill: "rgba(128,128,128,0.25)" }), Bs((i) => Ue(r, "d", i), [() => c1e(W(n))]), rr(t, r), Gf();
}
const m1e = {
  marquee: "M7 5a2 2 0 1 1-4 0a2 2 0 0 1 4 0m1-.25c0 .414.336.75.75.75h6.5a.75.75 0 0 0 0-1.5h-6.5a.75.75 0 0 0-.75.75M4.75 8a.75.75 0 0 0-.75.75v6.5a.75.75 0 0 0 1.5 0v-6.5A.75.75 0 0 0 4.75 8m14.5 0a.75.75 0 0 0-.75.75v6.5a.75.75 0 0 0 1.5 0v-6.5a.75.75 0 0 0-.75-.75M8.75 20a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5zM5 21a2 2 0 1 0 0-4a2 2 0 0 0 0 4M21 5a2 2 0 1 1-4 0a2 2 0 0 1 4 0m-2 16a2 2 0 1 0 0-4a2 2 0 0 0 0 4",
  lasso: "M9.703 2.265A10 10 0 0 1 12 2c.79 0 1.559.092 2.297.265a.75.75 0 1 1-.343 1.46A8.5 8.5 0 0 0 12 3.5a8.6 8.6 0 0 0-1.954.225a.75.75 0 1 1-.343-1.46m-1.93 1.47a.75.75 0 0 1-.242 1.033a8.55 8.55 0 0 0-2.763 2.763a.75.75 0 1 1-1.275-.79a10.05 10.05 0 0 1 3.248-3.248a.75.75 0 0 1 1.032.243m8.454 0a.75.75 0 0 1 1.032-.242a10.05 10.05 0 0 1 3.248 3.248a.75.75 0 1 1-1.275.79a8.55 8.55 0 0 0-2.763-2.763a.75.75 0 0 1-.242-1.032m-13.06 5.41a.75.75 0 0 1 .558.901A8.5 8.5 0 0 0 3.5 12c0 .673.078 1.327.225 1.954a.75.75 0 1 1-1.46.343A10 10 0 0 1 2 12c0-.79.092-1.559.265-2.297a.75.75 0 0 1 .902-.559m17.666 0a.75.75 0 0 1 .902.558a10.1 10.1 0 0 1 0 4.595a.75.75 0 1 1-1.46-.343a8.54 8.54 0 0 0-.001-3.908a.75.75 0 0 1 .559-.902M3.736 16.226a.75.75 0 0 1 1.032.242a8.55 8.55 0 0 0 2.763 2.763a.75.75 0 0 1-.79 1.275a10.05 10.05 0 0 1-3.248-3.248a.75.75 0 0 1 .243-1.032m16.685.858a.75.75 0 1 0-1.342-.67l-.002.004l-.015.029l-.069.123a8 8 0 0 1-.289.466a9.6 9.6 0 0 1-.965 1.219c-1.17-1.073-2.756-2.006-4.74-2.006c-2.347 0-3.99 1.203-3.99 2.875S10.653 22 13 22c1.942 0 3.495-.75 4.658-1.645a11.7 11.7 0 0 1 1.315 2.01q.05.099.073.149l.017.035l.004.009a.75.75 0 0 0 1.368-.615c-.087-.183 0-.001 0-.001v-.002l-.003-.004l-.007-.015l-.024-.052l-.091-.184a13.2 13.2 0 0 0-1.538-2.337a11 11 0 0 0 1.525-2.032l.09-.162l.024-.047l.007-.014l.002-.005zM13 17.75c1.433 0 2.644.652 3.616 1.512c-.95.7-2.155 1.238-3.616 1.238c-1.973 0-2.49-.922-2.49-1.375s.517-1.375 2.49-1.375"
};
var y1e = /* @__PURE__ */ uu('<svg width="24" height="24" viewBox="0 0 24 24"><path></path></svg>'), b1e = /* @__PURE__ */ bc("<button><!></button>");
function G9(t, e) {
  let n = nt(e, "active", 3, !1);
  var r = b1e();
  r.__click = function(...l) {
    e.onClick?.apply(this, l);
  };
  let i;
  var s = Nr(r);
  {
    var o = (l) => {
      var a = y1e();
      Kt(a, "", {}, { width: "14px", height: "14px" });
      var u = Nr(a);
      Kt(u, "", {}, { fill: "currentColor" }), br(a), Bs(() => Ue(u, "d", m1e[e.icon])), rr(l, a);
    };
    Vi(s, (l) => {
      e.icon != null && l(o);
    });
  }
  br(r), Bs(() => {
    Ue(r, "title", e.title), i = Kt(r, "", i, {
      border: "none",
      appearance: "none",
      background: n() ? "color-mix(in srgb, currentColor 20%, transparent)" : "none",
      "border-radius": "2px",
      height: "16px",
      width: "16px",
      padding: "0",
      margin: "0",
      "font-family": "inherit",
      "font-size": "1em",
      color: "currentColor",
      display: "flex",
      "flex-direction": "row",
      "align-items": "center",
      "justify-content": "center"
    });
  }), rr(t, r);
}
zme(["click"]);
var v1e = /* @__PURE__ */ bc('<div><div> </div> <svg height="6px"><line shape-rendering="crispEdges"></line><line shape-rendering="crispEdges"></line><line shape-rendering="crispEdges"></line></svg></div>');
function x1e(t, e) {
  function n(d, p) {
    let m = Math.log10(p * d), y = Math.round(m), b = [0.1, 0.2, 0.5, 1, 2, 5, 10], v = 0, _ = 1e10;
    for (let k of b) {
      let S = Math.abs(Math.log10(k) + y - m);
      S < _ && (v = k, _ = S);
    }
    return v * Math.pow(10, y);
  }
  let r = /* @__PURE__ */ yt(() => n(e.distancePerPoint, 30)), i = /* @__PURE__ */ yt(() => W(r) / e.distancePerPoint);
  var s = v1e();
  Kt(s, "", {}, { display: "flex", "align-items": "center" });
  var o = Nr(s);
  Kt(o, "", {}, { "padding-right": "4px" });
  var l = Nr(o, !0);
  br(o);
  var a = Vn(o, 2), u = Nr(a);
  Ue(u, "x1", 1), Ue(u, "y1", 3), Ue(u, "y2", 3), Kt(u, "", {}, {
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-cap": "butt"
  });
  var c = Vn(u);
  Ue(c, "x1", 1), Ue(c, "x2", 1), Ue(c, "y1", 0), Ue(c, "y2", 6), Kt(c, "", {}, { stroke: "currentColor" });
  var f = Vn(c);
  Ue(f, "y1", 0), Ue(f, "y2", 6), Kt(f, "", {}, { stroke: "currentColor" }), br(a), br(s), Bs(
    (d) => {
      $p(l, d), Ue(a, "width", `${W(i) + 2}px`), Ue(u, "x2", W(i) + 1), Ue(f, "x1", W(i) + 1), Ue(f, "x2", W(i) + 1);
    },
    [() => W(r).toLocaleString()]
  ), rr(t, s);
}
var w1e = /* @__PURE__ */ bc("<div> </div>"), _1e = /* @__PURE__ */ bc('<a target="_blank"> </a> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div>', 1), k1e = /* @__PURE__ */ bc('<div><div><!></div> <div></div> <div><!> <!> <!> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div> <!> <div style="border-right: 1px solid currentColor; margin: 4px 2px; opacity: 0.3; width: 0; height: 10px"></div> <span> </span></div></div>');
function C1e(t, e) {
  Wf(e, !0);
  let n = nt(e, "statusMessage", 3, null);
  var r = k1e();
  let i;
  var s = Nr(r);
  let o;
  var l = Nr(s);
  {
    var a = (k) => {
      var S = w1e();
      Kt(S, "", {}, { display: "inline-block" });
      var C = Nr(S, !0);
      br(S), Bs(() => $p(C, n())), rr(k, S);
    };
    Vi(l, (k) => {
      n() != null && k(a);
    });
  }
  br(s);
  var u = Vn(s, 2);
  Kt(u, "", {}, { flex: "1 1 0%" });
  var c = Vn(u, 2);
  let f;
  var d = Nr(c);
  {
    var p = (k) => {
      var S = _1e(), C = Dh(S);
      Kt(C, "", {}, { color: "currentColor", "text-decoration": "underline" });
      var E = Nr(C, !0);
      br(C), _L(2), Bs(() => {
        Ue(C, "href", e.resolvedTheme.brandingLink.href), $p(E, e.resolvedTheme.brandingLink.text);
      }), rr(k, S);
    };
    Vi(d, (k) => {
      e.resolvedTheme.brandingLink != null && k(p);
    });
  }
  var m = Vn(d, 2);
  {
    let k = /* @__PURE__ */ yt(() => e.selectionMode == "marquee");
    G9(m, {
      icon: "marquee",
      get active() {
        return W(k);
      },
      title: "Toggle rectangle selection mode. In normal mode, use shift + drag for rectangle selection.",
      onClick: () => e.onSelectionMode(e.selectionMode == "marquee" ? "none" : "marquee")
    });
  }
  var y = Vn(m, 2);
  {
    let k = /* @__PURE__ */ yt(() => e.selectionMode == "lasso");
    G9(y, {
      icon: "lasso",
      get active() {
        return W(k);
      },
      title: "Toggle lasso selection mode. In normal mode, use shift + meta + drag for lasso selection.",
      onClick: () => e.onSelectionMode(e.selectionMode == "lasso" ? "none" : "lasso")
    });
  }
  var b = Vn(y, 4);
  x1e(b, {
    get distancePerPoint() {
      return e.distancePerPoint;
    }
  });
  var v = Vn(b, 4), _ = Nr(v);
  br(v), br(c), br(r), Bs(
    (k) => {
      i = Kt(r, "", i, {
        "font-size": "12px",
        "line-height": "20px",
        height: "20px",
        color: e.resolvedTheme.statusBarTextColor,
        position: "absolute",
        bottom: "0px",
        left: "0px",
        right: "0px",
        "user-select": "none",
        "font-family": e.resolvedTheme.fontFamily,
        display: "flex",
        "flex-direction": "row"
      }), o = Kt(s, "", o, {
        flex: "none",
        display: "flex",
        "flex-direction": "row",
        gap: "4px",
        padding: "0px 4px",
        "border-radius": "2px",
        background: e.resolvedTheme.statusBarBackgroundColor
      }), f = Kt(c, "", f, {
        flex: "none",
        display: "flex",
        "flex-direction": "row",
        "align-items": "center",
        gap: "4px",
        padding: "0px 4px",
        "border-radius": "2px",
        background: e.resolvedTheme.statusBarBackgroundColor
      }), $p(_, `${k ?? ""} points`);
    },
    [() => e.pointCount.toLocaleString()]
  ), rr(t, r), Gf();
}
function S1e(t) {
  return (e, n) => {
    let r = new t(e, n);
    return {
      ...r.update ? { update: r.update.bind(r) } : {},
      ...r.destroy ? { destroy: r.destroy.bind(r) } : {}
    };
  };
}
let j3 = /* @__PURE__ */ new WeakMap();
function a$(t) {
  let e = typeof t == "function" ? t : t.class;
  if (j3.has(e))
    return j3.get(e);
  {
    let n = S1e(e);
    return j3.set(e, n), n;
  }
}
function u$(t, e) {
  return typeof t == "function" ? e : { ...t.props ?? {}, ...e };
}
var A1e = /* @__PURE__ */ bc("<div><div></div></div>");
function E1e(t, e) {
  Wf(e, !0);
  let n = nt(e, "margin", 3, 4), r, i, s = /* @__PURE__ */ yt(() => a$(e.customTooltip)), o = /* @__PURE__ */ yt(() => u$(e.customTooltip, { tooltip: e.tooltip }));
  W5(() => {
    Lp(() => {
      let u = W(s), c = null;
      return Lp(() => {
        i.style.left = "0px", i.style.top = "0px", i.style.pointerEvents = e.allowInteraction ? "all" : "none", c == null ? c = u(i, W(o)) : c.update?.(W(o));
        function f(b, v, _, k) {
          let S = e.location.x, C = e.location.y, E = 2, A = b / 2, O = v + (e.targetHeight + n());
          S - A < _ && (A = S - _), S - A > k - b && (A = S - k + b), C - O < E && (O = -(e.targetHeight + n())), i.style.left = S - A + "px", i.style.top = C - O + "px";
        }
        let d = r.getBoundingClientRect(), { width: p, height: m } = i.getBoundingClientRect();
        f(p, m, 2, d.width - 2);
        let y = requestAnimationFrame(() => {
          y = null;
          let b = i.getBoundingClientRect();
          (b.width != p || b.height != m) && f(b.width, b.height, 2, d.width - 2);
        });
        return () => {
          y != null && cancelAnimationFrame(y);
        };
      }), () => {
        c?.destroy?.(), i.replaceChildren();
      };
    });
  });
  var l = A1e();
  Kt(l, "", {}, { position: "absolute", width: "100%" });
  var a = Nr(l);
  Kt(a, "", {}, {
    display: "flex",
    position: "absolute",
    width: "fit-content",
    height: "fit-content",
    "z-index": "100"
  }), pk(a, (u) => i = u, () => i), br(l), pk(l, (u) => r = u, () => r), rr(t, l), Gf();
}
function G5(t, e, n) {
  t.prototype = e.prototype = n, n.constructor = t;
}
function c$(t, e) {
  var n = Object.create(t.prototype);
  for (var r in e) n[r] = e[r];
  return n;
}
function vm() {
}
var Lg = 0.7, pv = 1 / Lg, ad = "\\s*([+-]?\\d+)\\s*", $g = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Wl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", D1e = /^#([0-9a-f]{3,8})$/, O1e = new RegExp(`^rgb\\(${ad},${ad},${ad}\\)$`), F1e = new RegExp(`^rgb\\(${Wl},${Wl},${Wl}\\)$`), T1e = new RegExp(`^rgba\\(${ad},${ad},${ad},${$g}\\)$`), R1e = new RegExp(`^rgba\\(${Wl},${Wl},${Wl},${$g}\\)$`), M1e = new RegExp(`^hsl\\(${$g},${Wl},${Wl}\\)$`), P1e = new RegExp(`^hsla\\(${$g},${Wl},${Wl},${$g}\\)$`), K9 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
G5(vm, K5, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Y9,
  // Deprecated! Use color.formatHex.
  formatHex: Y9,
  formatHex8: I1e,
  formatHsl: N1e,
  formatRgb: X9,
  toString: X9
});
function Y9() {
  return this.rgb().formatHex();
}
function I1e() {
  return this.rgb().formatHex8();
}
function N1e() {
  return h$(this).formatHsl();
}
function X9() {
  return this.rgb().formatRgb();
}
function K5(t) {
  var e, n;
  return t = (t + "").trim().toLowerCase(), (e = D1e.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? Q9(e) : n === 3 ? new is(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? gy(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? gy(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = O1e.exec(t)) ? new is(e[1], e[2], e[3], 1) : (e = F1e.exec(t)) ? new is(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = T1e.exec(t)) ? gy(e[1], e[2], e[3], e[4]) : (e = R1e.exec(t)) ? gy(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = M1e.exec(t)) ? eO(e[1], e[2] / 100, e[3] / 100, 1) : (e = P1e.exec(t)) ? eO(e[1], e[2] / 100, e[3] / 100, e[4]) : K9.hasOwnProperty(t) ? Q9(K9[t]) : t === "transparent" ? new is(NaN, NaN, NaN, 0) : null;
}
function Q9(t) {
  return new is(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function gy(t, e, n, r) {
  return r <= 0 && (t = e = n = NaN), new is(t, e, n, r);
}
function B1e(t) {
  return t instanceof vm || (t = K5(t)), t ? (t = t.rgb(), new is(t.r, t.g, t.b, t.opacity)) : new is();
}
function f$(t, e, n, r) {
  return arguments.length === 1 ? B1e(t) : new is(t, e, n, r ?? 1);
}
function is(t, e, n, r) {
  this.r = +t, this.g = +e, this.b = +n, this.opacity = +r;
}
G5(is, f$, c$(vm, {
  brighter(t) {
    return t = t == null ? pv : Math.pow(pv, t), new is(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Lg : Math.pow(Lg, t), new is(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new is(hf(this.r), hf(this.g), hf(this.b), gv(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: J9,
  // Deprecated! Use color.formatHex.
  formatHex: J9,
  formatHex8: L1e,
  formatRgb: Z9,
  toString: Z9
}));
function J9() {
  return `#${ef(this.r)}${ef(this.g)}${ef(this.b)}`;
}
function L1e() {
  return `#${ef(this.r)}${ef(this.g)}${ef(this.b)}${ef((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Z9() {
  const t = gv(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${hf(this.r)}, ${hf(this.g)}, ${hf(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function gv(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function hf(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function ef(t) {
  return t = hf(t), (t < 16 ? "0" : "") + t.toString(16);
}
function eO(t, e, n, r) {
  return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new qo(t, e, n, r);
}
function h$(t) {
  if (t instanceof qo) return new qo(t.h, t.s, t.l, t.opacity);
  if (t instanceof vm || (t = K5(t)), !t) return new qo();
  if (t instanceof qo) return t;
  t = t.rgb();
  var e = t.r / 255, n = t.g / 255, r = t.b / 255, i = Math.min(e, n, r), s = Math.max(e, n, r), o = NaN, l = s - i, a = (s + i) / 2;
  return l ? (e === s ? o = (n - r) / l + (n < r) * 6 : n === s ? o = (r - e) / l + 2 : o = (e - n) / l + 4, l /= a < 0.5 ? s + i : 2 - s - i, o *= 60) : l = a > 0 && a < 1 ? 0 : o, new qo(o, l, a, t.opacity);
}
function $1e(t, e, n, r) {
  return arguments.length === 1 ? h$(t) : new qo(t, e, n, r ?? 1);
}
function qo(t, e, n, r) {
  this.h = +t, this.s = +e, this.l = +n, this.opacity = +r;
}
G5(qo, $1e, c$(vm, {
  brighter(t) {
    return t = t == null ? pv : Math.pow(pv, t), new qo(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Lg : Math.pow(Lg, t), new qo(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * e, i = 2 * n - r;
    return new is(
      q3(t >= 240 ? t - 240 : t + 120, i, r),
      q3(t, i, r),
      q3(t < 120 ? t + 240 : t - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new qo(tO(this.h), my(this.s), my(this.l), gv(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = gv(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${tO(this.h)}, ${my(this.s) * 100}%, ${my(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function tO(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function my(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function q3(t, e, n) {
  return (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) * 255;
}
const nO = [
  "#1f77b4",
  "#ff7f0e",
  "#2ca02c",
  "#d62728",
  "#9467bd",
  "#8c564b",
  "#e377c2",
  "#7f7f7f",
  "#bcbd22",
  "#17becf"
], yy = [
  "#1f77b4",
  "#aec7e8",
  "#ff7f0e",
  "#ffbb78",
  "#2ca02c",
  "#98df8a",
  "#d62728",
  "#ff9896",
  "#9467bd",
  "#c5b0d5",
  "#8c564b",
  "#c49c94",
  "#e377c2",
  "#f7b6d2",
  "#7f7f7f",
  "#c7c7c7",
  "#bcbd22",
  "#dbdb8d",
  "#17becf",
  "#9edae5"
];
function g0(t) {
  if (t < 1 && (t = 1), t <= nO.length)
    return nO.slice(0, t);
  if (t <= yy.length)
    return yy.slice(0, t);
  {
    let e = [];
    for (let n = 0; n < t; n++)
      e[n] = yy[n % yy.length];
    return e;
  }
}
function Y5(t) {
  let { r: e, g: n, b: r, opacity: i } = f$(t);
  return { r: e / 255, g: n / 255, b: r / 255, a: i };
}
function d$() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}
function X5(t, e) {
  return [
    t[0] * e[0] + t[3] * e[1] + t[6] * e[2],
    t[1] * e[0] + t[4] * e[1] + t[7] * e[2],
    t[2] * e[0] + t[5] * e[1] + t[8] * e[2],
    t[0] * e[3] + t[3] * e[4] + t[6] * e[5],
    t[1] * e[3] + t[4] * e[4] + t[7] * e[5],
    t[2] * e[3] + t[5] * e[4] + t[8] * e[5],
    t[0] * e[6] + t[3] * e[7] + t[6] * e[8],
    t[1] * e[6] + t[4] * e[7] + t[7] * e[8],
    t[2] * e[6] + t[5] * e[7] + t[8] * e[8]
  ];
}
function p$(t, e) {
  return [
    e[0] * t[0] + e[3] * t[1] + e[6] * t[2],
    e[1] * t[0] + e[4] * t[1] + e[7] * t[2],
    e[2] * t[0] + e[5] * t[1] + e[8] * t[2]
  ];
}
function z1e(t) {
  return t[0] * t[4] * t[8] - t[0] * t[5] * t[7] - t[1] * t[3] * t[8] + t[1] * t[5] * t[6] + t[2] * t[3] * t[7] - t[2] * t[4] * t[6];
}
function g$(t) {
  let e = z1e(t);
  return [
    (t[4] * t[8] - t[5] * t[7]) / e,
    (t[2] * t[7] - t[1] * t[8]) / e,
    (t[1] * t[5] - t[2] * t[4]) / e,
    (t[5] * t[6] - t[3] * t[8]) / e,
    (t[0] * t[8] - t[2] * t[6]) / e,
    (t[2] * t[3] - t[0] * t[5]) / e,
    (t[3] * t[7] - t[4] * t[6]) / e,
    (t[1] * t[6] - t[0] * t[7]) / e,
    (t[0] * t[4] - t[1] * t[3]) / e
  ];
}
class I2 {
  viewport;
  width;
  height;
  _matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  _pixel_kx = 0;
  _pixel_bx = 0;
  _pixel_ky = 0;
  _pixel_by = 0;
  constructor(e, n, r) {
    this.viewport = e, this.width = n, this.height = r, this.updateCoefficients();
  }
  update(e, n, r) {
    this.viewport = e, this.width = n, this.height = r, this.updateCoefficients();
  }
  updateCoefficients() {
    let { x: e, y: n, scale: r } = this.viewport, i = r, s = r;
    this.width < this.height ? i *= this.height / this.width : s *= this.width / this.height, this._matrix = [i, 0, 0, 0, s, 0, -e * i, -n * s, 1], this._pixel_kx = this._matrix[0] * this.width / 2, this._pixel_bx = (this._matrix[6] + 1) * this.width / 2, this._pixel_ky = -this._matrix[4] * this.height / 2, this._pixel_by = (-this._matrix[7] + 1) * this.height / 2;
  }
  matrix() {
    return this._matrix;
  }
  pixelLocation(e, n) {
    return { x: e * this._pixel_kx + this._pixel_bx, y: n * this._pixel_ky + this._pixel_by };
  }
  coordinateAtPixel(e, n) {
    return { x: (e - this._pixel_bx) / this._pixel_kx, y: (n - this._pixel_by) / this._pixel_ky };
  }
  pixelLocationFunction() {
    let e = this._pixel_kx, n = this._pixel_ky, r = this._pixel_bx, i = this._pixel_by;
    return (s, o) => ({ x: s * e + r, y: o * n + i });
  }
  coordinateAtPixelFunction() {
    let e = this._pixel_kx, n = this._pixel_ky, r = this._pixel_bx, i = this._pixel_by;
    return (s, o) => ({ x: (s - r) / e, y: (o - i) / n });
  }
}
let gk = class {
  _needsRun = !0;
  _inputs = /* @__PURE__ */ new Set();
  _targets = /* @__PURE__ */ new Set();
  constructor(e = []) {
    this._inputs = new Set(e);
    for (let n of this._inputs)
      n._targets.add(this);
  }
  addInput(e) {
    this._inputs.add(e), e._targets.add(this);
  }
  removeInput(e) {
    e._targets.delete(this), this._inputs.delete(e);
  }
  run() {
    if (this._needsRun) {
      for (let e of this._inputs)
        e.run();
      this.update(), this._needsRun = !1;
    }
  }
  setNeedsRunDownstream() {
    for (let e of this._targets)
      e._needsRun || (e._needsRun = !0, e.setNeedsRunDownstream());
  }
  update() {
  }
  destroy() {
    for (let e of this._inputs)
      e._targets.delete(this);
  }
}, m0 = class extends gk {
  _value = null;
  setValue(e) {
    this._value !== e && (this._value = e, this.setNeedsRunDownstream());
  }
  get value() {
    return this.run(), this._value;
  }
};
class m$ extends m0 {
  constructor(e) {
    super([]), this.setValue(e);
  }
  get value() {
    return super.value;
  }
  set value(e) {
    this.setValue(e);
  }
}
let j1e = class extends m0 {
  fn;
  constructor(e, n) {
    super(n), this.fn = e;
  }
  update() {
    this.setValue(this.fn());
  }
}, q1e = class extends m0 {
  fn;
  state;
  constructor(e, n) {
    super(n), this.fn = e, this.state = {};
  }
  update() {
    this.setValue(this.fn(this.state));
  }
  destroy() {
    super.destroy(), this.state.destroy && this.state.destroy(), this.state = {};
  }
}, U1e = class extends m0 {
  parent;
  condition;
  buildTrue;
  buildFalse;
  context = null;
  currentCondition = null;
  currentNode = null;
  constructor(e, n, r, i) {
    super([n]), this.parent = e, this.condition = n, this.buildTrue = r, this.buildFalse = i;
  }
  update() {
    (this.currentNode == null || this.currentCondition !== this.condition.value) && (this.currentNode && this.removeInput(this.currentNode), this.context?.destroy(), this.context = new Xf(this.parent), this.currentCondition = this.condition.value, this.currentCondition ? this.currentNode = this.buildTrue(this.context) : this.currentNode = this.buildFalse(this.context), this.addInput(this.currentNode)), this.setValue(this.currentNode.value);
  }
  destroy() {
    super.destroy(), this.context?.destroy();
  }
}, H1e = class extends m0 {
  parent;
  input;
  build;
  cache;
  constructor(e, n, r) {
    super([n]), this.parent = e, this.input = n, this.build = r, this.cache = /* @__PURE__ */ new Map();
  }
  update() {
    let e = /* @__PURE__ */ new Set(), n = this.input.value.map((r) => {
      if (e.add(r), this.cache.has(r)) {
        let i = this.cache.get(r);
        return i.input.value = r, i.output.value;
      } else {
        let i = new Xf(this.parent), s = new m$(r), o = this.build(i, s);
        return this.cache.set(r, { context: i, input: s, output: o }), this.addInput(o), o.value;
      }
    });
    for (let [r, i] of this.cache)
      e.has(r) || (this.cache.delete(r), this.removeInput(i.output), i.context.destroy());
    this.setValue(n);
  }
  destroy() {
    super.destroy();
    for (let e of this.cache.values())
      e.context.destroy();
  }
}, V1e = class extends m0 {
  parent;
  input;
  cases;
  currentCase = null;
  currentNode = null;
  currentContext = null;
  constructor(e, n, r) {
    super([n]), this.parent = e, this.input = n, this.cases = r;
  }
  update() {
    (this.currentNode == null || this.input.value !== this.currentCase) && (this.currentNode && this.removeInput(this.currentNode), this.currentContext?.destroy(), this.currentContext = new Xf(this.parent), this.currentCase = this.input.value, this.currentNode = this.cases[this.currentCase](this.currentContext), this.addInput(this.currentNode)), this.setValue(this.currentNode.value);
  }
  destroy() {
    super.destroy(), this.currentContext?.destroy();
  }
};
class Xf {
  _children;
  _nodes;
  /** Creates a new dataflow context. */
  constructor(e = null) {
    this._children = /* @__PURE__ */ new Set(), this._nodes = /* @__PURE__ */ new Set(), e?._children.add(this);
  }
  /** Destroy the dataflow and all associated states. */
  destroy() {
    for (let e of this._children)
      e.destroy();
    for (let e of this._nodes)
      e.destroy();
    this._children.clear(), this._nodes.clear();
  }
  /** Creates a value node. */
  value(e) {
    let n = new m$(e);
    return this._nodes.add(n), n;
  }
  /** Creates a derived value. */
  derive(e, n) {
    let r = e.map((s) => s instanceof gk ? s : this.value(s)), i = new j1e(() => n(...r.map((s) => s.value)), r);
    return this._nodes.add(i), i;
  }
  /** Creates a stateful derived value. */
  statefulDerive(e, n) {
    let r = e.map((s) => s instanceof gk ? s : this.value(s)), i = new q1e((s) => n(s, ...r.map((o) => o.value)), r);
    return this._nodes.add(i), i;
  }
  /** Creates a true or false dataflow depending on the value of the condition. */
  if(e, n, r) {
    let i = new U1e(this, e, n, r);
    return this._nodes.add(i), i;
  }
  switch(e, n) {
    let r = new V1e(this, e, n);
    return this._nodes.add(r), r;
  }
  map(e, n) {
    let r = new H1e(this, e, n);
    return this._nodes.add(r), r;
  }
  assertNotNull(e) {
    return e;
  }
  subgraph() {
    return new Xf(this);
  }
}
function ea(t, e, n, r) {
  if (t.program == null || t.vsSource != n || t.fsSource != r) {
    t.destroy && t.destroy();
    let s = rO(e, e.VERTEX_SHADER, n), o = rO(e, e.FRAGMENT_SHADER, r), l = e.createProgram();
    if (e.attachShader(l, s), e.attachShader(l, o), e.linkProgram(l), !e.getProgramParameter(l, e.LINK_STATUS)) {
      var i = e.getProgramInfoLog(l);
      throw new Error(`failed to link program: ${i}, vertex source: ${n}, fragment source: ${r}`);
    }
    t.program = l, t.vsSource = n, t.fsSource = r, t.destroy = () => {
      e.deleteProgram(l), e.deleteShader(s), e.deleteShader(o);
    }, t.uniforms = {};
    for (let a of (n + r).matchAll(/uniform +[0-9a-zA-Z_]+ +([0-9a-zA-Z_]+) *(;|\[)/g)) {
      let u = a[1];
      t.uniforms[u] = e.getUniformLocation(l, u);
    }
  }
  return { program: t.program, uniforms: t.uniforms ?? {} };
}
function rO(t, e, n) {
  let r = t.createShader(e);
  if (t.shaderSource(r, n), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS)) {
    var i = t.getShaderInfoLog(r);
    throw new Error(`failed to compile shader: ${i}, source: ${n}`);
  }
  return r;
}
function Gl(t, e, n, r) {
  if (t.buffer == null) {
    let i = e.createBuffer();
    t.buffer = i, t.destroy = () => {
      e.deleteBuffer(i);
    };
  }
  if (t.data !== n) {
    if (t.data = n, e.bindBuffer(e.ARRAY_BUFFER, t.buffer), n instanceof Array)
      switch (r ?? "f32") {
        case "f32":
          e.bufferData(e.ARRAY_BUFFER, new Float32Array(n), e.STATIC_DRAW);
          break;
        case "i32":
          e.bufferData(e.ARRAY_BUFFER, new Int32Array(n), e.STATIC_DRAW);
          break;
        case "u32":
          e.bufferData(e.ARRAY_BUFFER, new Uint32Array(n), e.STATIC_DRAW);
          break;
        case "i16":
          e.bufferData(e.ARRAY_BUFFER, new Int16Array(n), e.STATIC_DRAW);
          break;
        case "u16":
          e.bufferData(e.ARRAY_BUFFER, new Uint16Array(n), e.STATIC_DRAW);
          break;
        case "i8":
          e.bufferData(e.ARRAY_BUFFER, new Int8Array(n), e.STATIC_DRAW);
          break;
        case "u8":
          e.bufferData(e.ARRAY_BUFFER, new Uint8Array(n), e.STATIC_DRAW);
          break;
        default:
          throw new Error("invalid type");
      }
    else
      e.bufferData(e.ARRAY_BUFFER, n, e.STATIC_DRAW);
    e.bindBuffer(e.ARRAY_BUFFER, null);
  }
  return t.buffer;
}
function W1e(t, e, n, r, i) {
  const s = {
    u8: {
      1: [t.R8, t.RED, t.UNSIGNED_BYTE],
      2: [t.RG8, t.RG, t.UNSIGNED_BYTE],
      3: [t.RGB8, t.RGB, t.UNSIGNED_BYTE],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_BYTE]
    },
    u16: {
      1: [t.R8, t.RED, t.UNSIGNED_SHORT],
      2: [t.RG8, t.RG, t.UNSIGNED_SHORT],
      3: [t.RGB8, t.RGB, t.UNSIGNED_SHORT],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_SHORT]
    },
    u32: {
      1: [t.R8, t.RED, t.UNSIGNED_INT],
      2: [t.RG8, t.RG, t.UNSIGNED_INT],
      3: [t.RGB8, t.RGB, t.UNSIGNED_INT],
      4: [t.RGBA8, t.RGBA, t.UNSIGNED_INT]
    },
    f32: {
      1: [t.R32F, t.RED, t.FLOAT],
      2: [t.RG32F, t.RG, t.FLOAT],
      3: [t.RGB32F, t.RGB, t.FLOAT],
      4: [t.RGBA32F, t.RGBA, t.FLOAT]
    }
  };
  let [o, l, a] = s[i][r];
  t.texImage2D(t.TEXTURE_2D, 0, o, e, n, 0, l, a, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
}
function Lu(t, e, n, r, i, s) {
  if (t.framebuffer == null || t.texture == null) {
    let l = e.createFramebuffer(), a = e.createTexture();
    e.bindFramebuffer(e.FRAMEBUFFER, l), e.bindTexture(e.TEXTURE_2D, a), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, a, 0), e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), t.framebuffer = l, t.texture = a, t.destroy = () => {
      e.deleteFramebuffer(l), e.deleteTexture(a);
    };
  }
  let o = `${n},${r},${i},${s}`;
  return t.cacheKey != o && (t.cacheKey = o, e.bindTexture(e.TEXTURE_2D, t.texture), W1e(e, n, r, i, s), e.bindTexture(e.TEXTURE_2D, null)), {
    framebuffer: t.framebuffer,
    texture: t.texture,
    width: n,
    height: r
  };
}
function G1e(t) {
  let e = t.squareMaxSize, n = t.samples, r = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, i = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;
    void main() {
      vec4 color = vec4(0.0);
      const int count = ${e};
      int i = -count;
      while(i + 1 <= count) {
        color += texture(image, uv + direction * (float(i) + 0.5) / resolution) * 2.0;
        i += 2;
      }
      if (i <= count) {
        color += texture(image, uv + direction * float(count) / resolution);
      }
      outColor = color;
    }
  `, s = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform sampler2D imageBox;
    uniform vec2 resolution;
    uniform float scaler;
    in vec2 uv;
    out vec4 outColor;

    void main() {
      vec4 color = texture(imageBox, uv);
      if (color != vec4(0.0)) {
        ${n.map(({ x: o, y: l, w: a }) => `color -= texture(image, uv + vec2(${o.toFixed(8)}, ${l.toFixed(8)}) / resolution) * (${a.toFixed(8)})`).join(";")};
      }
      outColor = color * scaler;
    }
  `;
  return { vertex: r, fragment1: i, fragment2: s };
}
function K1e(t, e, n) {
  let r = t.derive([n], Y1e), i = t.derive([r], G1e), s = t.statefulDerive(
    [e, t.derive([i], (a) => a.vertex), t.derive([i], (a) => a.fragment1)],
    ea
  ), o = t.statefulDerive(
    [e, t.derive([i], (a) => a.vertex), t.derive([i], (a) => a.fragment2)],
    ea
  ), l = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Gl);
  return t.derive(
    [e, l, s, o, n, r],
    (a, u, c, f, d, p) => (m, y, b) => {
      let { width: v, height: _ } = y;
      a.disable(a.BLEND), a.enableVertexAttribArray(0), a.bindBuffer(a.ARRAY_BUFFER, u), a.vertexAttribPointer(0, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, null), a.useProgram(c.program), a.uniform2f(c.uniforms.resolution, v, _), a.uniform1i(c.uniforms.image, 0), a.bindFramebuffer(a.FRAMEBUFFER, y.framebuffer), a.bindTexture(a.TEXTURE_2D, m), a.uniform2f(c.uniforms.direction, 0, 1), a.drawArrays(a.TRIANGLE_STRIP, 0, 4), a.bindFramebuffer(a.FRAMEBUFFER, b.framebuffer), a.bindTexture(a.TEXTURE_2D, y.texture), a.uniform2f(c.uniforms.direction, 1, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 4), a.bindFramebuffer(a.FRAMEBUFFER, y.framebuffer), a.activeTexture(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, b.texture), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, m), a.useProgram(f.program), a.uniform2f(f.uniforms.resolution, v, _), a.uniform1i(f.uniforms.image, 0), a.uniform1i(f.uniforms.imageBox, 1);
      let k = 1 / p.totalWeight * d * d * Math.PI;
      a.uniform1f(f.uniforms.scaler, k), a.drawArrays(a.TRIANGLE_STRIP, 0, 4), a.bindFramebuffer(a.FRAMEBUFFER, null), a.useProgram(null), a.activeTexture(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, null), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, null), a.disableVertexAttribArray(0);
    }
  );
}
function iO(t, e, n) {
  let r = Math.sqrt(e * e + n * n);
  if (r < t - Math.sqrt(2) / 2)
    return 1;
  if (r > t + Math.sqrt(2) / 2)
    return 0;
  let i = 2, s = 0;
  for (let o = 0; o < i; o++)
    for (let l = 0; l < i; l++) {
      let a = e + (o + 0.5) / i - 0.5, u = n + (l + 0.5) / i - 0.5;
      Math.sqrt(a * a + u * u) < t && (s += 1);
    }
  return s / i / i;
}
function Y1e(t) {
  let e = Math.floor(t + 0.5), n = e, r = iO(t, 0, 0), i = [];
  for (let l = -e; l <= e; l++)
    for (let a = -e; a <= e; a++) {
      let u = r - iO(t, l, a);
      if (!(u <= 0))
        if (i.length > 0 && l == i[i.length - 1].x && a == i[i.length - 1].y + 1) {
          let c = i[i.length - 1].w, f = u;
          i[i.length - 1].y += 1 - c / (c + f), i[i.length - 1].w = c + f;
        } else
          i.push({ x: l, y: a, w: u });
    }
  i = i.sort((l, a) => l.y != a.y ? l.y - a.y : l.x - a.x);
  let s = [];
  for (let { x: l, y: a, w: u } of i)
    if (s.length > 0 && a == s[s.length - 1].y && l == s[s.length - 1].x + 1) {
      let c = s[s.length - 1].w, f = u;
      s[s.length - 1].x += 1 - c / (c + f), s[s.length - 1].w = c + f;
    } else
      s.push({ x: l, y: a, w: u });
  let o = -s.reduce((l, a) => l + a.w, 0);
  return o += r * (1 + n * 2) * (1 + n * 2), { squareMaxSize: n, squareWeight: r, samples: s, totalWeight: o };
}
function X1e(t) {
  let e;
  return t ? e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      layout(location=0) in float x;
      layout(location=1) in float y;
      layout(location=2) in int category;
      out vec4 color;
      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        if (category == 0) {
          color = vec4(1, 0, 0, 0);
        } else if (category == 1) {
          color = vec4(0, 1, 0, 0);
        } else if (category == 2) {
          color = vec4(0, 0, 1, 0);
        } else if (category == 3) {
          color = vec4(0, 0, 0, 1);
        }
        gl_PointSize = 1.0;
      }
    ` : e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      layout(location=0) in float x;
      layout(location=1) in float y;
      out vec4 color;
      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        color = vec4(1, 0, 0, 0);
        gl_PointSize = 1.0;
      }
    `, { vertex: e, fragment: `#version 300 es
    precision highp float;
    in vec4 color;
    out vec4 outColor;
    void main() {
      outColor = color;
    }
  ` };
}
function mk(t, e, n, r, i, s) {
  let o = i != null, l = X1e(o), a = t.statefulDerive([e, l.vertex, l.fragment], ea);
  return t.derive([e, a, n, r, i, s], (u, c, f, d, p, m) => (y) => {
    u.enable(u.BLEND), u.blendFunc(u.ONE, u.ONE), u.useProgram(c.program), u.enableVertexAttribArray(0), u.bindBuffer(u.ARRAY_BUFFER, f), u.vertexAttribPointer(0, 1, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(1), u.bindBuffer(u.ARRAY_BUFFER, d), u.vertexAttribPointer(1, 1, u.FLOAT, !1, 0, 0), p != null && (u.enableVertexAttribArray(2), u.bindBuffer(u.ARRAY_BUFFER, p), u.vertexAttribIPointer(2, 1, u.BYTE, 0, 0)), u.bindBuffer(u.ARRAY_BUFFER, null), u.uniformMatrix3fv(c.uniforms.matrix, !1, y), u.drawArrays(u.POINTS, 0, m), u.disableVertexAttribArray(0), u.disableVertexAttribArray(1), p != null && u.disableVertexAttribArray(2), u.useProgram(null);
  });
}
function Q1e() {
  return { vertex: `#version 300 es
    precision highp float;
    uniform vec2 xyScaler;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy * xyScaler, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform float gamma;
    in vec2 uv;
    out vec4 outColor;
    void main() {
      vec4 color = texture(source, uv);
      color.rgb = pow(color.rgb, vec3(1.0 / gamma));
      outColor = color;
    }
  ` };
}
function y$(t, e) {
  let { vertex: n, fragment: r } = Q1e(), i = t.statefulDerive([e, n, r], ea), s = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Gl);
  return t.derive([e, i, s], (o, l, a) => (u, c, f, d) => {
    o.disable(o.BLEND), o.enableVertexAttribArray(0), o.bindBuffer(o.ARRAY_BUFFER, a), o.vertexAttribPointer(0, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, null), o.bindTexture(o.TEXTURE_2D, u), o.useProgram(l.program), o.uniform1i(l.uniforms.source, 0), o.uniform2f(l.uniforms.xyScaler, f ?? 1, d ?? 1), o.uniform1f(l.uniforms.gamma, c ?? 2.2), o.drawArrays(o.TRIANGLE_STRIP, 0, 4), o.useProgram(null), o.bindTexture(o.TEXTURE_2D, null), o.disableVertexAttribArray(0);
  });
}
function b$(t) {
  return Math.ceil(t * 3);
}
function J1e(t) {
  let e = b$(t), n = [];
  for (let l = -e; l <= e; l++)
    n.push(Math.exp(-l * l / t / t / 2));
  let r = n.reduce((l, a) => l + a, 0);
  n = n.map((l) => l / r);
  let i = eye(n).map(([l, a]) => [l - e, a]), s = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, o = `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;

    void main() {
      vec4 color = vec4(0.0);
      ${i.map(([l, a]) => `color += texture(image, uv + direction * vec2(${l.toFixed(10)}) / resolution) * ${a.toFixed(10)};`).join(`
`)}
      outColor = color;
    }
  `;
  return { vertex: s, fragment: o };
}
function Z1e(t, e, n) {
  let r = t.derive([n], J1e), i = t.statefulDerive(
    [e, t.derive([r], (o) => o.vertex), t.derive([r], (o) => o.fragment)],
    ea
  ), s = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Gl);
  return t.derive([e, s, i, n], (o, l, a, u) => (c, f, d) => {
    let { width: p, height: m } = f;
    o.disable(o.BLEND), o.enableVertexAttribArray(0), o.bindBuffer(o.ARRAY_BUFFER, l), o.vertexAttribPointer(0, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, null), o.useProgram(a.program), o.uniform2f(a.uniforms.resolution, p, m), o.uniform1i(a.uniforms.image, 0), o.bindFramebuffer(o.FRAMEBUFFER, d.framebuffer), o.bindTexture(o.TEXTURE_2D, c), o.uniform2f(a.uniforms.direction, 0, 1), o.drawArrays(o.TRIANGLE_STRIP, 0, 4), o.bindFramebuffer(o.FRAMEBUFFER, f.framebuffer), o.bindTexture(o.TEXTURE_2D, d.texture), o.uniform2f(a.uniforms.direction, 1, 0), o.drawArrays(o.TRIANGLE_STRIP, 0, 4), o.bindFramebuffer(o.FRAMEBUFFER, null), o.useProgram(null), o.bindTexture(o.TEXTURE_2D, null), o.disableVertexAttribArray(0);
  });
}
function eye(t) {
  let e = [];
  for (let n = 0; n < t.length; n += 2)
    if (n + 1 < t.length) {
      let r = t[n], i = t[n + 1], s = 1 - r / (r + i);
      if (s >= 0 && s <= 1) {
        let o = r + i;
        o != 0 && e.push([n + s, o]);
      } else
        e.push([n, t[n]]), e.push([n + 1, t[n + 1]]);
    } else
      e.push([n, t[n]]);
  return e;
}
function tye(t) {
  return Math.ceil(t * 3);
}
function nye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D image;
    uniform vec2 resolution;
    uniform vec2 direction;
    in vec2 uv;
    out vec4 outColor;

    uniform float weight0;
    uniform vec3 distances;
    uniform vec3 weights;

    void main() {
      vec4 color = texture(image, uv) * weight0;
      if (weights.x != 0.0) {
        color += texture(image, uv + direction * vec2(distances.x) / resolution) * weights.x;
        color += texture(image, uv - direction * vec2(distances.x) / resolution) * weights.x;
      }
      if (weights.y != 0.0) {
        color += texture(image, uv + direction * vec2(distances.y) / resolution) * weights.y;
        color += texture(image, uv - direction * vec2(distances.y) / resolution) * weights.y;
      }
      if (weights.z != 0.0) {
        color += texture(image, uv + direction * vec2(distances.z) / resolution) * weights.z;
        color += texture(image, uv - direction * vec2(distances.z) / resolution) * weights.z;
      }
      outColor = color;
    }
  ` };
}
function rye(t, e, n) {
  let { vertex: r, fragment: i } = nye(), s = t.statefulDerive([e, r, i], ea), o = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Gl);
  return t.derive([e, o, s], (l, a, u) => (c, f, d) => {
    let { width: p, height: m } = f;
    l.disable(l.BLEND), l.enableVertexAttribArray(0), l.bindBuffer(l.ARRAY_BUFFER, a), l.vertexAttribPointer(0, 2, l.FLOAT, !1, 0, 0), l.bindBuffer(l.ARRAY_BUFFER, null), l.useProgram(u.program), l.uniform2f(u.uniforms.resolution, p, m), l.uniform1i(u.uniforms.image, 0);
    let y = c, b = d, v = f;
    for (let _ = 0; _ < 2; _++) {
      l.uniform2f(u.uniforms.direction, _, 1 - _);
      for (let [k, S, C] of iye) {
        l.bindFramebuffer(l.FRAMEBUFFER, b.framebuffer), l.bindTexture(l.TEXTURE_2D, y), l.uniform1fv(u.uniforms.weight0, S), l.uniform3fv(u.uniforms.distances, k), l.uniform3fv(u.uniforms.weights, C), l.drawArrays(l.TRIANGLE_STRIP, 0, 4), y = b.texture;
        let E = b;
        b = v, v = E;
      }
    }
    l.bindFramebuffer(l.FRAMEBUFFER, null), l.useProgram(null), l.bindTexture(l.TEXTURE_2D, null), l.disableVertexAttribArray(0);
  });
}
const iye = [
  [[1, 2, 3], [0.2288468365182578], [0.18230006506971572, 0.1356122230111784, 0.06766429365997693]],
  [[2, 6, 10], [0.09116254014100238], [0.23317759354726447, 0.18385867277788717, 0.03738246360434722]],
  [[3, 10, 20], [0.2950645715317288], [0.010918865853671198, 0.23773695670296047, 0.10381189167750389]],
  [[4, 16, 30], [0.20085957073474772], [0.14463019087130788, 0.17934533765938643, 0.07559468610193185]]
];
function sye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform float densityScaler;
    uniform float quantizationStep;
    uniform vec4 channelMask;
    uniform vec4 color;
    uniform float globalAlpha;

    in vec2 uv;
    out vec4 outColor;

    float sample_density(vec2 uv) {
      float d = dot(texture(source, uv), channelMask) * densityScaler;
      d = min(1.0, max(0.0, d));
      d = floor(d / quantizationStep);
      return d;
    }

    void main() {
      // Run the Sobel operator.
      float v = sample_density(uv);
      float v11 = sample_density(uv + vec2(-1, -1) / resolution);
      float v12 = sample_density(uv + vec2(-1,  0) / resolution);
      float v13 = sample_density(uv + vec2(-1, +1) / resolution);
      float v21 = sample_density(uv + vec2( 0, -1) / resolution);
      float v23 = sample_density(uv + vec2( 0, +1) / resolution);
      float v31 = sample_density(uv + vec2(+1, -1) / resolution);
      float v32 = sample_density(uv + vec2(+1,  0) / resolution);
      float v33 = sample_density(uv + vec2(+1, +1) / resolution);
      float gx = v11 + v12 * 2.0 + v13 - v31 - v32 * 2.0 - v33;
      float gy = v11 + v21 * 2.0 + v31 - v13 - v23 * 2.0 - v33;
      // Derive alpha value from the result.
      float alpha = length(vec2(gx, gy)) * 0.2;
      alpha = min(1.0, max(0.0, alpha));
      outColor = color * alpha * globalAlpha;
    }
  ` };
}
function oye(t, e) {
  let { vertex: n, fragment: r } = sye(), i = t.statefulDerive([e, n, r], ea), s = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Gl);
  return t.derive(
    [e, i, s],
    (o, l, a) => (u, c, f, d, p, m) => {
      o.enable(o.BLEND), o.blendFunc(o.ONE, o.ONE_MINUS_SRC_ALPHA), o.enableVertexAttribArray(0), o.bindBuffer(o.ARRAY_BUFFER, a), o.vertexAttribPointer(0, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, null), o.bindTexture(o.TEXTURE_2D, u.texture), o.useProgram(l.program), o.uniform1i(l.uniforms.source, 0), o.uniform2f(l.uniforms.resolution, u.width, u.height), o.uniform1f(l.uniforms.densityScaler, c), o.uniform1f(l.uniforms.quantizationStep, f), o.uniform1f(l.uniforms.globalAlpha, d), o.uniform4fv(l.uniforms.channelMask, p), o.uniform4fv(l.uniforms.color, m), o.drawArrays(o.TRIANGLE_STRIP, 0, 4), o.useProgram(null), o.bindTexture(o.TEXTURE_2D, null), o.disableVertexAttribArray(0);
    }
  );
}
function lye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
    `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform float densityScaler;
    uniform float quantizationStep;

    uniform mat4 colorMatrix;
    uniform int isDarkMode;
    uniform float globalAlpha;

    in vec2 uv;
    out vec4 outColor;

    /* Combine alphas with symmetric blending equation f(a, b) = a + b - ab. */
    float combine_alphas(vec4 alphas) {
      float r = alphas.x + alphas.y - alphas.x * alphas.y;
      r = r + alphas.z - r * alphas.z;
      r = r + alphas.w - r * alphas.w;
      return r;
    }

    void main() {
      vec4 density = texture(source, uv) * densityScaler;

      if (density.x > 1.0 || density.y > 1.0 || density.z > 1.0 || density.w > 1.0) {
        density = density / max(max(max(density.x, density.y), density.z), density.w);
      } else {
        density = floor(density / quantizationStep) * quantizationStep;
      }

      if (density.x + density.y + density.z + density.w == 0.0) {
        discard;
      }

      float alpha = combine_alphas(density);

      density *= alpha / (density.x + density.y + density.z + density.w);

      vec3 c1 = colorMatrix[0].rgb * density.x;
      vec3 c2 = colorMatrix[1].rgb * density.y;
      vec3 c3 = colorMatrix[2].rgb * density.z;
      vec3 c4 = colorMatrix[3].rgb * density.w;
      vec3 c;

      if (isDarkMode == 0) {
        c = vec3(1.0) - alpha + c1 + c2 + c3 + c4;
      } else {
        c = c1 + c2 + c3 + c4;
      }

      outColor = vec4(c, 1.0) * alpha * globalAlpha;
    }
  ` };
}
function aye(t, e) {
  let { vertex: n, fragment: r } = lye(), i = t.statefulDerive([e, n, r], ea), s = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Gl);
  return t.derive(
    [e, i, s],
    (o, l, a) => (u, c, f, d, p, m) => {
      o.enable(o.BLEND), o.blendFunc(o.ONE, o.ONE_MINUS_SRC_ALPHA), o.enableVertexAttribArray(0), o.bindBuffer(o.ARRAY_BUFFER, a), o.vertexAttribPointer(0, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, null), o.bindTexture(o.TEXTURE_2D, u.texture), o.useProgram(l.program), o.uniform1i(l.uniforms.source, 0), o.uniform2f(l.uniforms.resolution, u.width, u.height), o.uniform1f(l.uniforms.densityScaler, c), o.uniform1f(l.uniforms.quantizationStep, f), o.uniform1f(l.uniforms.globalAlpha, d), o.uniform1i(l.uniforms.isDarkMode, m == "dark" ? 1 : 0), o.uniformMatrix4fv(l.uniforms.colorMatrix, !1, p), o.drawArrays(o.TRIANGLE_STRIP, 0, 4), o.useProgram(null), o.bindTexture(o.TEXTURE_2D, null), o.disableVertexAttribArray(0);
    }
  );
}
function uye(t) {
  let e;
  return t ? e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      uniform float point_size;
      uniform float alpha;
      uniform vec4 colorScheme[64];

      layout(location=0) in float x;
      layout(location=1) in float y;
      layout(location=2) in int category;

      out vec4 color;

      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        if (category < 64) {
          color = colorScheme[category];
        } else {
          color = vec4(0.5, 0.5, 0.5, 1);
        }
        color *= alpha;
        gl_PointSize = point_size;
      }
    ` : e = `#version 300 es
      precision highp float;
      uniform mat3 matrix;
      uniform float point_size;
      uniform vec4 colorScheme;
      uniform float alpha;

      layout(location=0) in float x;
      layout(location=1) in float y;

      out vec4 color;

      void main() {
        gl_Position = vec4(matrix * vec3(x, y, 1), 1);
        color = colorScheme;
        color *= alpha;
        gl_PointSize = point_size;
      }
    `, { vertex: e, fragment: `#version 300 es
    precision highp float;
    uniform float point_size;
    in vec4 color;
    out vec4 outColor;
    void main() {
      float r = length(gl_PointCoord.xy - vec2(0.5, 0.5)) * point_size;
      float a = max(0.0, min(1.0, point_size / 2.0 - r));
      outColor = color * a;
    }
  ` };
}
function sO(t, e, n, r, i, s) {
  let o = i != null, l = uye(o), a = t.statefulDerive([e, l.vertex, l.fragment], ea);
  return t.derive(
    [e, a, n, r, i, s],
    (u, c, f, d, p, m) => (y, b, v, _) => {
      u.enable(u.BLEND), u.blendFunc(u.ONE, u.ONE_MINUS_SRC_ALPHA), u.useProgram(c.program), u.enableVertexAttribArray(0), u.bindBuffer(u.ARRAY_BUFFER, f), u.vertexAttribPointer(0, 1, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(1), u.bindBuffer(u.ARRAY_BUFFER, d), u.vertexAttribPointer(1, 1, u.FLOAT, !1, 0, 0), p != null && (u.enableVertexAttribArray(2), u.bindBuffer(u.ARRAY_BUFFER, p), u.vertexAttribIPointer(2, 1, u.BYTE, 0, 0)), u.bindBuffer(u.ARRAY_BUFFER, null), u.uniformMatrix3fv(c.uniforms.matrix, !1, y), u.uniform1f(c.uniforms.point_size, b * 2), u.uniform1f(c.uniforms.alpha, v), o ? u.uniform4fv(c.uniforms.colorScheme, _) : u.uniform4fv(c.uniforms.colorScheme, _.slice(0, 4)), u.drawArrays(u.POINTS, 0, m), u.disableVertexAttribArray(0), u.disableVertexAttribArray(1), p != null && u.disableVertexAttribArray(2), u.useProgram(null);
    }
  );
}
function cye() {
  return { vertex: `#version 300 es
    precision highp float;
    layout(location=0) in vec2 xy;
    out vec2 uv;
    void main() {
      gl_Position = vec4(xy, 0, 1);
      uv = (xy + 1.0) / 2.0;
    }
  `, fragment: `#version 300 es
    precision highp float;
    uniform sampler2D source;
    uniform vec2 resolution;
    uniform mat4 colorMatrix;
    uniform float pointAlpha;
    uniform float globalAlpha;
    uniform int isDarkMode;
    in vec2 uv;
    out vec4 outColor;

    /* Combine alphas with symmetric blending equation f(a, b) = a + b - ab. */
    float combine_alphas(vec4 alphas) {
      float r = alphas.x + alphas.y - alphas.x * alphas.y;
      r = r + alphas.z - r * alphas.z;
      r = r + alphas.w - r * alphas.w;
      return r;
    }

    void main() {
      vec4 count = texture(source, uv);
      vec4 alphas = pointAlpha >= 0.999
        ? vec4(count.x > 0.0 ? 1.0 : 0.0, count.y > 0.0 ? 1.0 : 0.0, count.z > 0.0 ? 1.0 : 0.0, count.w > 0.0 ? 1.0 : 0.0)
        : vec4(1.0) - pow(vec4(1.0 - pointAlpha), count);
      float a = combine_alphas(alphas);
      if (a <= 0.0) { discard; }
      alphas *= a / (alphas.x + alphas.y + alphas.z + alphas.w);

      vec3 c1 = colorMatrix[0].rgb * alphas.x;
      vec3 c2 = colorMatrix[1].rgb * alphas.y;
      vec3 c3 = colorMatrix[2].rgb * alphas.z;
      vec3 c4 = colorMatrix[3].rgb * alphas.w;
      vec3 c;
      if (isDarkMode == 0) {
        c = vec3(1.0) - a + c1 + c2 + c3 + c4;
      } else {
        c = c1 + c2 + c3 + c4;
      }
      outColor = vec4(c, 1.0) * a * globalAlpha;
    }
  ` };
}
function fye(t, e) {
  let { vertex: n, fragment: r } = cye(), i = t.statefulDerive([e, n, r], ea), s = t.statefulDerive([e, [-1, -1, -1, 1, 1, -1, 1, 1], "f32"], Gl);
  return t.derive(
    [e, i, s],
    (o, l, a) => (u, c, f, d, p) => {
      o.enable(o.BLEND), o.blendFunc(o.ONE, o.ONE_MINUS_SRC_ALPHA), o.enableVertexAttribArray(0), o.bindBuffer(o.ARRAY_BUFFER, a), o.vertexAttribPointer(0, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, null), o.bindTexture(o.TEXTURE_2D, u.texture), o.useProgram(l.program), o.uniform1i(l.uniforms.source, 0), o.uniform2f(l.uniforms.resolution, u.width, u.height), o.uniform1f(l.uniforms.pointAlpha, c), o.uniform1f(l.uniforms.globalAlpha, f), o.uniform1i(l.uniforms.isDarkMode, p == "dark" ? 1 : 0), o.uniformMatrix4fv(l.uniforms.colorMatrix, !1, d), o.drawArrays(o.TRIANGLE_STRIP, 0, 4), o.useProgram(null), o.bindTexture(o.TEXTURE_2D, null), o.disableVertexAttribArray(0);
    }
  );
}
let hye = class {
  props;
  viewport;
  df;
  gl;
  renderInputs;
  dataBuffers;
  renderer;
  constructor(e, n, r) {
    this.props = {
      mode: "points",
      colorScheme: "light",
      x: new Float32Array(),
      y: new Float32Array(),
      category: null,
      categoryCount: 1,
      categoryColors: null,
      viewportX: 0,
      viewportY: 0,
      viewportScale: 1,
      pointSize: 1,
      pointAlpha: 1,
      pointsAlpha: 1,
      densityScaler: 1,
      densityBandwidth: 1,
      densityQuantizationStep: 0.1,
      contoursAlpha: 1,
      densityAlpha: 1,
      gamma: 2.2,
      width: n,
      height: r
    }, this.viewport = new I2({ x: 0, y: 0, scale: 1 }, n, r);
    let i = new Xf(), s = i.value(e);
    this.df = i, this.gl = s, this.renderInputs = {
      mode: i.value(this.props.mode),
      colorScheme: i.value(this.props.colorScheme),
      xData: i.value(this.props.x),
      yData: i.value(this.props.y),
      categoryData: i.value(this.props.category),
      categoryCount: i.value(this.props.categoryCount),
      matrix: i.value(d$()),
      width: i.value(n),
      height: i.value(r),
      pointSize: i.value(this.props.pointSize),
      densityBandwidth: i.value(this.props.densityBandwidth)
    }, this.dataBuffers = dye(i, s, this.renderInputs), this.renderer = pye(i, s, this.renderInputs, this.dataBuffers);
  }
  setProps(e) {
    let n = !1, r;
    for (r in e)
      e[r] !== this.props[r] && (this.props[r] = e[r], n = !0);
    return this.viewport.update(
      { x: this.props.viewportX, y: this.props.viewportY, scale: this.props.viewportScale },
      this.props.width,
      this.props.height
    ), this.renderInputs.mode.value = this.props.mode, this.renderInputs.colorScheme.value = this.props.colorScheme, this.renderInputs.xData.value = this.props.x, this.renderInputs.yData.value = this.props.y, this.renderInputs.categoryData.value = this.props.category, this.props.category != null ? this.renderInputs.categoryCount.value = this.props.categoryCount : this.renderInputs.categoryCount.value = 1, this.renderInputs.matrix.value = this.viewport.matrix(), this.renderInputs.width.value = this.props.width, this.renderInputs.height.value = this.props.height, this.renderInputs.pointSize.value = this.props.pointSize, this.renderInputs.densityBandwidth.value = this.props.densityBandwidth, n;
  }
  render() {
    this.renderer.value(this.props);
  }
  destroy() {
    this.df.destroy();
  }
  async densityMap(e, n, r, i) {
    let s = this.df.subgraph(), o = yye(s, this.gl, this.dataBuffers, s.value(e), s.value(n), s.value(r)), { x: l, y: a, scale: u } = i, c = [u, 0, 0, 0, u, 0, -l * u, -a * u, 1], f = o.value(c), d = g$(c);
    return s.destroy(), {
      data: f,
      width: e,
      height: n,
      coordinateAtPixel: (p, m) => {
        let y = p / e * 2 - 1, b = m / n * 2 - 1, v = p$([y, b, 1], d);
        return { x: v[0], y: v[1] };
      }
    };
  }
};
function dye(t, e, n) {
  const r = t.statefulDerive([e, n.xData, "f32"], Gl), i = t.statefulDerive([e, n.yData, "f32"], Gl), s = t.if(
    t.derive([n.categoryData], (l) => l != null),
    (l) => l.statefulDerive([e, l.assertNotNull(n.categoryData), "u8"], Gl),
    (l) => l.value(null)
  ), o = t.derive([n.xData], (l) => l.length);
  return { x: r, y: i, category: s, count: o };
}
function pye(t, e, n, r) {
  return t.switch(n.mode, {
    points: (i) => gye(i, e, n, r),
    density: (i) => mye(i, e, n, r)
  });
}
function gye(t, e, n, r) {
  const i = t.derive([n.categoryCount], (a) => a > 1), s = t.statefulDerive([e, n.width, n.height, 4, "f32"], Lu);
  let o = t.if(
    i,
    (a) => sO(a, e, r.x, r.y, a.assertNotNull(r.category), r.count),
    (a) => sO(a, e, r.x, r.y, null, r.count)
  ), l = y$(t, e);
  return t.derive(
    [e, s, o, l, n.colorScheme, n.matrix, n.categoryCount],
    (a, u, c, f, d, p, m) => (y) => {
      let b = [], v = y.categoryColors ?? g0(y.categoryCount);
      for (let _ = 0; _ < m; _++)
        if (_ < v.length) {
          let { r: k, g: S, b: C } = Y5(v[_]);
          k = Math.pow(k, y.gamma), S = Math.pow(S, y.gamma), C = Math.pow(C, y.gamma), b = b.concat([k, S, C, 1]);
        } else
          b = b.concat([0.5, 0.5, 0.5, 1]);
      a.bindFramebuffer(a.FRAMEBUFFER, u.framebuffer), a.viewport(0, 0, u.width, u.height), d == "light" ? a.clearColor(1, 1, 1, 1) : a.clearColor(0, 0, 0, 1), a.clear(a.COLOR_BUFFER_BIT), c(p, Math.max(3, y.pointSize), y.pointAlpha * y.pointsAlpha, b), a.bindFramebuffer(a.FRAMEBUFFER, null), a.viewport(0, 0, y.width, y.height), f(u.texture, y.gamma);
    }
  );
}
function mye(t, e, n, r) {
  let i = t.derive([n.densityBandwidth], (k) => tye(k) + 1), s = t.derive([n.width, i], (k, S) => k + S * 2), o = t.derive([n.height, i], (k, S) => k + S * 2);
  const l = t.derive([n.categoryCount], (k) => k > 1), a = t.statefulDerive([e, s, o, 4, "f32"], Lu), u = t.statefulDerive([e, s, o, 4, "f32"], Lu), c = t.statefulDerive([e, s, o, 4, "f32"], Lu), f = t.statefulDerive([e, s, o, 4, "f32"], Lu);
  let d = t.if(
    l,
    (k) => mk(k, e, r.x, r.y, k.assertNotNull(r.category), r.count),
    (k) => mk(k, e, r.x, r.y, null, r.count)
  ), p = K1e(t, e, n.pointSize), m = rye(t, e, n.densityBandwidth), y = fye(t, e), b = aye(t, e), v = oye(t, e), _ = y$(t, e);
  return t.derive(
    [
      e,
      a,
      u,
      c,
      f,
      n.colorScheme,
      n.matrix,
      d,
      p,
      m,
      y,
      b,
      v,
      _
    ],
    (k, S, C, E, A, O, T, $, P, B, M, L, N, j) => (U) => {
      let H = U.categoryColors ?? g0(U.categoryCount), G = [];
      for (let ne = 0; ne < 4; ne++)
        if (ne < H.length) {
          let { r: ce, g: we, b: Me } = Y5(H[ne]);
          ce = Math.pow(ce, U.gamma), we = Math.pow(we, U.gamma), Me = Math.pow(Me, U.gamma), G = G.concat([ce, we, Me, 1]);
        } else
          G = G.concat([0.5, 0.5, 0.5, 1]);
      let re = U.width / C.width, se = U.height / C.height, oe = X5([re, 0, 0, 0, se, 0, 0, 0, 1], T);
      if (k.bindFramebuffer(k.FRAMEBUFFER, S.framebuffer), k.viewport(0, 0, S.width, S.height), k.clearColor(0, 0, 0, 0), k.clear(k.COLOR_BUFFER_BIT), $(oe), k.bindFramebuffer(k.FRAMEBUFFER, C.framebuffer), k.viewport(0, 0, C.width, C.height), O == "light" ? k.clearColor(1, 1, 1, 1) : k.clearColor(0, 0, 0, 1), k.clear(k.COLOR_BUFFER_BIT), U.pointAlpha > 0 && U.pointsAlpha > 0 && (P(S.texture, E, A), k.bindFramebuffer(k.FRAMEBUFFER, C.framebuffer), M(E, U.pointAlpha, U.pointsAlpha, G, O)), U.densityScaler > 0 && (U.densityAlpha > 0 || U.contoursAlpha > 0) && (B(S.texture, E, A), k.bindFramebuffer(k.FRAMEBUFFER, C.framebuffer), U.densityAlpha > 0 && L(
        E,
        U.densityScaler,
        U.densityQuantizationStep,
        U.densityAlpha,
        G,
        O
      ), U.contoursAlpha > 0))
        for (let ne = 0; ne < H.length; ne++) {
          let ce = [0, 0, 0, 0];
          ce[ne] = 1, N(
            E,
            U.densityScaler,
            U.densityQuantizationStep,
            U.contoursAlpha,
            ce,
            G.slice(ne * 4, ne * 4 + 4)
          );
        }
      k.bindFramebuffer(k.FRAMEBUFFER, null), k.viewport(0, 0, U.width, U.height), j(C.texture, U.gamma, 1 / re, 1 / se);
    }
  );
}
function yye(t, e, n, r, i, s) {
  let o = t.derive([s], (m) => b$(m) + 1), l = t.derive([r, o], (m, y) => m + y * 2), a = t.derive([i, o], (m, y) => m + y * 2);
  const u = t.statefulDerive([e, l, a, 1, "f32"], Lu), c = t.statefulDerive([e, l, a, 1, "f32"], Lu), f = t.statefulDerive([e, l, a, 1, "f32"], Lu);
  let d = mk(t, e, n.x, n.y, null, n.count), p = Z1e(t, e, s);
  return t.derive(
    [e, o, r, i, u, c, f, d, p],
    (m, y, b, v, _, k, S, C, E) => (A) => {
      let O = b / _.width, T = v / _.height, $ = X5([O, 0, 0, 0, T, 0, 0, 0, 1], A);
      m.bindFramebuffer(m.FRAMEBUFFER, _.framebuffer), m.viewport(0, 0, _.width, _.height), m.clearColor(0, 0, 0, 0), m.clear(m.COLOR_BUFFER_BIT), C($), E(_.texture, k, S), m.bindFramebuffer(m.FRAMEBUFFER, k.framebuffer);
      let P = new Float32Array(b * v);
      return m.readPixels(y, y, b, v, m.RED, m.FLOAT, P), m.bindFramebuffer(m.FRAMEBUFFER, null), P;
    }
  );
}
let bye = class {
  i32View;
  u32View;
  f32View;
  offset;
  constructor(e) {
    this.i32View = new Int32Array(e), this.u32View = new Uint32Array(e), this.f32View = new Float32Array(e), this.offset = 0;
  }
  align2() {
    this.offset % 2 != 0 && (this.offset += 2 - this.offset % 2);
  }
  align4() {
    this.offset % 4 != 0 && (this.offset += 4 - this.offset % 4);
  }
  f32(e) {
    this.f32View[this.offset++] = e;
  }
  u32(e) {
    this.u32View[this.offset++] = e;
  }
  i32(e) {
    this.i32View[this.offset++] = e;
  }
  vec2f(e, n) {
    this.align2(), this.f32View[this.offset++] = e, this.f32View[this.offset++] = n;
  }
  vec3f(e, n, r) {
    this.align4(), this.f32View[this.offset++] = e, this.f32View[this.offset++] = n, this.f32View[this.offset++] = r;
  }
  vec4f(e, n, r, i) {
    this.align4(), this.f32View[this.offset++] = e, this.f32View[this.offset++] = n, this.f32View[this.offset++] = r, this.f32View[this.offset++] = i;
  }
  mat3x3f(e) {
    this.vec3f(e[0], e[1], e[2]), this.vec3f(e[3], e[4], e[5]), this.vec3f(e[6], e[7], e[8]);
  }
  byteOffset() {
    return this.offset * 4;
  }
};
function vye(t, e) {
  let n = new ArrayBuffer(4288), r = t.statefulDerive(
    [e, 4288, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.VERTEX],
    sd
  );
  return {
    buffer: r,
    update: t.derive([e, r], (i, s) => (o) => {
      let l = new bye(n);
      l.u32(o.count), l.u32(o.category_count), l.i32(o.framebuffer_width), l.i32(o.framebuffer_height), l.i32(o.density_width), l.i32(o.density_height), l.f32(o.gamma), l.f32(o.point_size), l.f32(o.point_alpha), l.f32(o.points_alpha), l.f32(o.density_scaler), l.f32(o.quantization_step), l.f32(o.density_alpha), l.f32(o.contours_alpha), l.mat3x3f(o.matrix), l.vec2f(...o.view_xy_scaler), l.vec4f(...o.kde_causal), l.vec4f(...o.kde_anticausal), l.vec4f(...o.kde_a), l.vec4f(...o.background_color);
      let a = o.gamma;
      for (let u = 0; u < Math.min(o.category_colors.length, 256); u++) {
        let { r: c, g: f, b: d, a: p } = o.category_colors[u];
        c = Math.pow(c, a), f = Math.pow(f, a), d = Math.pow(d, a), l.vec4f(c, f, d, p);
      }
      i.queue.writeBuffer(s, 0, n, 0, l.byteOffset());
    })
  };
}
const U3 = 64, H3 = 64;
function v$(t, e, n, r, i, s) {
  let o = t.derive(
    [e, n, r.layouts],
    (l, a, u) => l.createComputePipeline({
      layout: l.createPipelineLayout({ bindGroupLayouts: [u.group0, u.group1, u.group2A] }),
      compute: { module: a, entryPoint: "accumulate" }
    })
  );
  return t.derive(
    [
      o,
      r.group0,
      r.group1,
      r.group2A,
      s.countBuffer,
      i.count
    ],
    (l, a, u, c, f, d) => (p) => {
      if (p.clearBuffer(f), d == 0)
        return;
      let m = p.beginComputePass();
      m.setPipeline(l), m.setBindGroup(0, a), m.setBindGroup(1, u), m.setBindGroup(2, c), d <= U3 * H3 ? m.dispatchWorkgroups(Math.ceil(d / U3)) : m.dispatchWorkgroups(H3, Math.ceil(d / (U3 * H3))), m.end();
    }
  );
}
function xye(t) {
  const { COMPUTE: e, VERTEX: n, FRAGMENT: r } = GPUShaderStage;
  return {
    // Group 0
    group0: t.createBindGroupLayout({
      entries: [{ binding: 0, visibility: e | n | r, buffer: { type: "uniform" } }]
    }),
    // Group 1
    group1: t.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: e | n, buffer: { type: "read-only-storage" } },
        { binding: 1, visibility: e | n, buffer: { type: "read-only-storage" } },
        { binding: 2, visibility: e | n, buffer: { type: "read-only-storage" } }
      ]
    }),
    // Group 2
    group2A: t.createBindGroupLayout({
      entries: [{ binding: 0, visibility: e | r, buffer: { type: "storage" } }]
    }),
    group2B: t.createBindGroupLayout({
      entries: [
        { binding: 1, visibility: e | r, buffer: { type: "storage" } },
        { binding: 2, visibility: e | r, buffer: { type: "storage" } }
      ]
    }),
    // Group 3
    group3: t.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    })
  };
}
function x$(t, e, n, r, i) {
  let s = t.derive([e], (f) => xye(f)), o = t.derive(
    [e, s, n],
    (f, d, p) => f.createBindGroup({
      layout: d.group0,
      entries: [{ binding: 0, resource: { buffer: p } }]
    })
  ), l = t.derive(
    [e, s, r.x, r.y, r.category],
    (f, d, p, m, y) => f.createBindGroup({
      layout: d.group1,
      entries: [
        { binding: 0, resource: { buffer: p } },
        { binding: 1, resource: { buffer: m } },
        { binding: 2, resource: { buffer: y ?? p } }
      ]
    })
  ), a = t.derive(
    [e, s, i.countBuffer, i.blurBuffer],
    (f, d, p, m) => f.createBindGroup({
      layout: d.group2A,
      entries: [{ binding: 0, resource: { buffer: p } }]
    })
  ), u = t.derive(
    [e, s, i.countBuffer, i.blurBuffer],
    (f, d, p, m) => f.createBindGroup({
      layout: d.group2B,
      entries: [
        { binding: 1, resource: { buffer: p } },
        { binding: 2, resource: { buffer: m } }
      ]
    })
  ), c = t.derive(
    [e, s, i.colorTexture, i.alphaTexture],
    (f, d, p, m) => f.createBindGroup({
      layout: d.group3,
      entries: [
        { binding: 0, resource: f.createSampler({}) },
        { binding: 1, resource: p.createView() },
        { binding: 2, resource: m.createView() }
      ]
    })
  );
  return {
    layouts: s,
    group0: o,
    group1: l,
    group2A: a,
    group2B: u,
    group3: c
  };
}
function wye(t, e, n, r, i) {
  const s = t.derive(
    [e, n, r.layouts],
    (o, l, a) => o.createRenderPipeline({
      layout: o.createPipelineLayout({
        bindGroupLayouts: [a.group0, a.group1, a.group2B]
      }),
      vertex: { entryPoint: "draw_density_map_vs", module: l },
      fragment: {
        entryPoint: "draw_density_map_fs",
        module: l,
        targets: [
          {
            format: i.colorTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          },
          {
            format: i.alphaTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [
      s,
      r.group0,
      r.group1,
      r.group2B,
      i.colorTexture,
      i.alphaTexture
    ],
    (o, l, a, u, c, f) => (d) => {
      let p = d.beginRenderPass({
        colorAttachments: [
          { loadOp: "load", storeOp: "store", view: c.createView() },
          { loadOp: "load", storeOp: "store", view: f.createView() }
        ]
      });
      p.setPipeline(o), p.setBindGroup(0, l), p.setBindGroup(1, a), p.setBindGroup(2, u), p.draw(4), p.end();
    }
  );
}
function _ye(t, e, n, r, i, s) {
  const o = t.derive(
    [e, n, r.layouts],
    (l, a, u) => l.createRenderPipeline({
      layout: l.createPipelineLayout({ bindGroupLayouts: [u.group0, u.group1] }),
      vertex: { entryPoint: "points_vs", module: a },
      fragment: {
        entryPoint: "points_fs",
        module: a,
        targets: [
          {
            format: s.colorTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          },
          {
            format: s.alphaTextureFormat,
            blend: { color: { srcFactor: "one", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [
      o,
      r.group0,
      r.group1,
      i.count,
      s.colorTexture,
      s.alphaTexture
    ],
    (l, a, u, c, f, d) => (p) => {
      let m = p.beginRenderPass({
        colorAttachments: [
          { clearValue: [0, 0, 0, 0], loadOp: "clear", storeOp: "store", view: f.createView() },
          { clearValue: [0, 0, 0, 0], loadOp: "clear", storeOp: "store", view: d.createView() }
        ]
      });
      m.setPipeline(l), m.setBindGroup(0, a), m.setBindGroup(1, u), c > 0 && m.draw(4, c), m.end();
    }
  );
}
function kye(t, e, n, r, i) {
  const s = t.derive(
    [e, n, i.layouts],
    (o, l, a) => o.createRenderPipeline({
      layout: o.createPipelineLayout({
        bindGroupLayouts: [a.group0, a.group1, a.group2B, a.group3]
      }),
      vertex: { entryPoint: "gamma_correction_vs", module: l },
      fragment: { entryPoint: "gamma_correction_fs", module: l, targets: [{ format: r }] },
      primitive: { topology: "triangle-strip" }
    })
  );
  return t.derive(
    [s, i.group0, i.group1, i.group2B, i.group3],
    (o, l, a, u, c) => (f, d) => {
      let p = f.beginRenderPass({
        colorAttachments: [{ clearValue: [1, 1, 1, 1], loadOp: "clear", storeOp: "store", view: d }]
      });
      p.setPipeline(o), p.setBindGroup(0, l), p.setBindGroup(1, a), p.setBindGroup(2, u), p.setBindGroup(3, c), p.draw(4), p.end();
    }
  );
}
const oO = 64;
function w$(t, e, n, r, i, s, o) {
  let l = t.derive(
    [e, n, r.layouts],
    (u, c, f) => u.createComputePipeline({
      layout: u.createPipelineLayout({
        bindGroupLayouts: [f.group0, f.group1, f.group2B, f.group3]
      }),
      compute: { module: c, entryPoint: "gaussian_blur_stage_1" }
    })
  ), a = t.derive(
    [e, n, r.layouts],
    (u, c, f) => u.createComputePipeline({
      layout: u.createPipelineLayout({
        bindGroupLayouts: [f.group0, f.group1, f.group2B, f.group3]
      }),
      compute: { module: c, entryPoint: "gaussian_blur_stage_2" }
    })
  );
  return t.derive(
    [
      l,
      a,
      r.group0,
      r.group1,
      r.group2B,
      r.group3,
      i,
      s,
      o
    ],
    (u, c, f, d, p, m, y, b, v) => (_) => {
      let k = _.beginComputePass();
      k.setBindGroup(0, f), k.setBindGroup(1, d), k.setBindGroup(2, p), k.setBindGroup(3, m), k.setPipeline(u), k.dispatchWorkgroups(Math.ceil(y / oO), v), k.setPipeline(c), k.dispatchWorkgroups(Math.ceil(b / oO), v), k.end();
    }
  );
}
function Cye(t, e = !1) {
  const n = new Float64Array(5), r = new Float64Array(4);
  Sye(n, r, t);
  const i = Float64Array.of(
    0,
    r[1] - n[1] * r[0],
    r[2] - n[2] * r[0],
    r[3] - n[3] * r[0],
    -n[4] * r[0]
  ), s = 1 + n[1] + n[2] + n[3] + n[4], o = (r[0] + r[1] + r[2] + r[3]) / s, l = (i[1] + i[2] + i[3] + i[4]) / s;
  return {
    sigma: t,
    negative: e,
    a: n,
    b_causal: r,
    b_anticausal: i,
    sum_causal: o,
    sum_anticausal: l
  };
}
function Sye(t, e, n) {
  const r = Float64Array.of(
    0.84,
    1.8675,
    0.84,
    -1.8675,
    -0.34015,
    -0.1299,
    -0.34015,
    0.1299
  ), i = Math.exp(-1.783 / n), s = Math.exp(-1.723 / n), o = 0.6318 / n, l = 1.997 / n, a = Float64Array.of(
    -i * Math.cos(o),
    i * Math.sin(o),
    -i * Math.cos(-o),
    i * Math.sin(-o),
    -s * Math.cos(l),
    s * Math.sin(l),
    -s * Math.cos(-l),
    s * Math.sin(-l)
  ), u = n * 2.5066282746310007, c = Float64Array.of(r[0], r[1], 0, 0, 0, 0, 0, 0), f = Float64Array.of(1, 0, a[0], a[1], 0, 0, 0, 0, 0, 0);
  let d, p;
  for (p = 2; p < 8; p += 2) {
    for (c[p] = a[p] * c[p - 2] - a[p + 1] * c[p - 1], c[p + 1] = a[p] * c[p - 1] + a[p + 1] * c[p - 2], d = p - 2; d > 0; d -= 2)
      c[d] += a[p] * c[d - 2] - a[p + 1] * c[d - 1], c[d + 1] += a[p] * c[d - 1] + a[p + 1] * c[d - 2];
    for (d = 0; d <= p; d += 2)
      c[d] += r[p] * f[d] - r[p + 1] * f[d + 1], c[d + 1] += r[p] * f[d + 1] + r[p + 1] * f[d];
    for (f[p + 2] = a[p] * f[p] - a[p + 1] * f[p + 1], f[p + 3] = a[p] * f[p + 1] + a[p + 1] * f[p], d = p; d > 0; d -= 2)
      f[d] += a[p] * f[d - 2] - a[p + 1] * f[d - 1], f[d + 1] += a[p] * f[d - 1] + a[p + 1] * f[d - 2];
  }
  for (p = 0; p < 4; ++p)
    d = p << 1, e[p] = c[d] / u, t[p + 1] = f[d + 2];
}
function _$(t) {
  let e = Cye(t);
  return {
    kde_causal: [e.b_causal[0], e.b_causal[1], e.b_causal[2], e.b_causal[3]],
    kde_anticausal: [e.b_anticausal[1], e.b_anticausal[2], e.b_anticausal[3], e.b_anticausal[4]],
    kde_a: [e.a[1], e.a[2], e.a[3], e.a[4]]
  };
}
const Aye = `// Copyright (c) 2025 Apple Inc. Licensed under MIT License.

enable f16;

struct Uniforms {
  count: u32,
  category_count: u32,
  framebuffer_width: i32,
  framebuffer_height: i32,
  density_width: i32,
  density_height: i32,
  gamma: f32,
  point_size: f32,
  point_alpha: f32,
  points_alpha: f32,
  density_scaler: f32,
  quantization_step: f32,
  density_alpha: f32,
  contours_alpha: f32,
  matrix: mat3x3<f32>,
  view_xy_scaler: vec2<f32>,
  kde_causal: vec4<f32>,
  kde_anticausal: vec4<f32>,
  kde_a: vec4<f32>,
  background_color: vec4<f32>,
  category_colors: array<vec4<f32>, 256>,
}

struct PointData {
  position: vec3<f32>,
  category: u32,
}

struct FragmentOutput {
  @location(0) color: vec4<f32>,
  @location(1) log1malpha: f32, // log(1 - alpha)
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@group(1) @binding(0) var<storage, read> x_buffer: array<f32>;
@group(1) @binding(1) var<storage, read> y_buffer: array<f32>;
@group(1) @binding(2) var<storage, read> category_buffer: array<u32>;

@group(2) @binding(0) var<storage, read_write> count_buffer: array<atomic<u32>>;
@group(2) @binding(1) var<storage, read_write> blur_buffer: array<f16>;
@group(2) @binding(2) var<storage, read_write> blur_swap_buffer: array<f16>;

@group(3) @binding(0) var framebuffer_sampler: sampler;
@group(3) @binding(1) var color_texture: texture_2d<f32>;
@group(3) @binding(2) var log1malpha_texture: texture_2d<f32>;

fn get_point(index: u32) -> PointData {
  var result: PointData;
  result.position = vec3(x_buffer[index], y_buffer[index], 1.0);
  if (uniforms.category_count > 1) {
    result.category = (category_buffer[index >> 2] >> ((index & 3) << 3)) & 0xff;
  } else {
    result.category = 0;
  }
  return result;
}

const ACCUMULATE_UNIT: u32 = 4096;

fn increment_count(x: i32, y: i32, category: u32, value: u32) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  if (x < 0 || x >= width || y < 0 || y >= height || category >= uniforms.category_count || value == 0) {
    return;
  }
  let offset = (y * width + x) + i32(category) * (width * height);
  atomicAdd(&count_buffer[offset], value);
}

@compute @workgroup_size(64, 1)
fn accumulate(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let index = id.y * 4096 + id.x; // 4096 = 64 * 64
  if (index >= uniforms.count) { return; }
  let point = get_point(index);
  let pos = uniforms.matrix * point.position;
  let x = (pos.x + 1.0) / 2.0 * f32(width) - 0.5;
  let y = (pos.y + 1.0) / 2.0 * f32(height) - 0.5;
  let ix = i32(x);
  let iy = i32(y);
  let tx = x - f32(ix);
  let ty = y - f32(iy);
  let w1: u32 = u32((1 - tx) * (1 - ty) * f32(ACCUMULATE_UNIT));
  let w2: u32 = u32(tx * (1 - ty) * f32(ACCUMULATE_UNIT));
  let w3: u32 = u32((1 - tx) * ty * f32(ACCUMULATE_UNIT));
  let w123 = w1 + w2 + w3;
  var w4: u32 = select(0, ACCUMULATE_UNIT - w123, w123 < ACCUMULATE_UNIT);
  increment_count(ix, iy, point.category, w1);
  increment_count(ix + 1, iy, point.category, w2);
  increment_count(ix, iy + 1, point.category, w3);
  increment_count(ix + 1, iy + 1, point.category, w4);
}

// Draw Discrete Points

struct PointsVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) dp: vec3<f32>,
  @location(1) color: vec4<f32>,
}

@vertex
fn points_vs(
  @builtin(instance_index) index: u32,
  @builtin(vertex_index) part: u32,
) -> PointsVertexOutput {
  let framebuffer_size = vec2(f32(uniforms.framebuffer_width), f32(uniforms.framebuffer_height));
  let alpha = uniforms.point_alpha * uniforms.points_alpha;
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  let point = get_point(index);
  let pos = uniforms.matrix * point.position;

  var out: PointsVertexOutput;
  out.position = vec4<f32>(pos.xy + dp * uniforms.point_size / framebuffer_size * 2.0, 0.0, 1.0);
  out.dp = vec3(dp, uniforms.point_size);
  out.color = uniforms.category_colors[point.category] * alpha;
  return out;
}

@fragment
fn points_fs(in: PointsVertexOutput) -> FragmentOutput {
  let r = length(in.dp.xy) * in.dp.z;
  let a = max(0.0, min(1.0, in.dp.z - r));
  var out: FragmentOutput;
  out.color = in.color * a;
  out.log1malpha = log(1 - out.color.a);
  return out;
}

// Draw Density Map

struct DrawDensityMapVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) texture_coord: vec2<f32>,
}

@vertex
fn draw_density_map_vs(
  @builtin(vertex_index) part: u32,
) -> DrawDensityMapVertexOutput {
  let framebuffer_size = vec2(f32(uniforms.framebuffer_width), f32(uniforms.framebuffer_height));
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  var out: DrawDensityMapVertexOutput;
  out.position = vec4(dp, 0.0, 1.0);
  out.texture_coord = (vec2(dp.x, dp.y) + 1.0) / 2.0 * framebuffer_size;
  return out;
}

fn get_density_raw(x: i32, y: i32, category: u32) -> f32 {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let density_scaler = uniforms.density_scaler;
  if (x < 0 || x >= width || y < 0 || y >= height) {
    return 0.0;
  }
  let offset = (y * width + x) + i32(category) * (width * height);
  return max(0.0, f32(blur_buffer[offset]) * density_scaler);
}

fn get_density(x: f32, y: f32, category: u32) -> f32 {
  let px = x / f32(uniforms.framebuffer_width) * f32(uniforms.density_width) - 0.5;
  let py = y / f32(uniforms.framebuffer_height) * f32(uniforms.density_height) - 0.5;
  let ix = i32(px);
  let iy = i32(py);
  let tx = px - f32(ix);
  let ty = py - f32(iy);
  let v00 = get_density_raw(ix, iy, category);
  let v10 = get_density_raw(ix + 1, iy, category);
  let v01 = get_density_raw(ix, iy + 1, category);
  let v11 = get_density_raw(ix + 1, iy + 1, category);
  return mix(mix(v00, v10, tx), mix(v01, v11, tx), ty);
}

fn get_density_quantized(x: f32, y: f32, category: u32) -> f32 {
  let v = get_density(x, y, category);
  return floor(clamp(v, 0, 1) / uniforms.quantization_step);
}

fn get_density_quantized_sobel(x: f32, y: f32, category: u32) -> vec2<f32> {
  let v11 = get_density_quantized(x - 1, y - 1, category);
  let v21 = get_density_quantized(x, y - 1, category);
  let v31 = get_density_quantized(x + 1, y - 1, category);
  let v12 = get_density_quantized(x - 1, y, category);
  let v22 = get_density_quantized(x, y, category);
  let v32 = get_density_quantized(x + 1, y, category);
  let v13 = get_density_quantized(x - 1, y + 1, category);
  let v23 = get_density_quantized(x, y + 1, category);
  let v33 = get_density_quantized(x + 1, y + 1, category);
  let gx = v11 + v12 * 2.0 + v13 - v31 - v32 * 2.0 - v33;
  let gy = v11 + v21 * 2.0 + v31 - v13 - v23 * 2.0 - v33;
  return vec2(gx, gy);
}

@fragment
fn draw_density_map_fs(in: DrawDensityMapVertexOutput) -> FragmentOutput {
  let px = in.texture_coord.x;
  let py = in.texture_coord.y;
  let quantization_step: f32 = uniforms.quantization_step;

  var sum_color: vec4<f32> = vec4(0);
  var sum_log1malpha: f32 = 0.0;

  for (var i: u32 = 0; i < uniforms.category_count; i++) {
    let density = get_density(px, py, i);
    var alpha = min(1.0, floor(density / quantization_step) * quantization_step);
    alpha *= uniforms.density_alpha;
    let color = uniforms.category_colors[i] * alpha;
    sum_color += color;
    sum_log1malpha += log(1 - color.a);
  }

  if (uniforms.contours_alpha > 0.0) {
    for (var i: u32 = 0; i < uniforms.category_count; i++) {
      let sobel = get_density_quantized_sobel(px, py, i);
      let alpha = clamp(length(sobel) * 0.2, 0.0, 1.0) * uniforms.contours_alpha;
      let color = uniforms.category_colors[i] * alpha;
      sum_color += color;
      sum_log1malpha += log(1 - color.a);
    }
  }

  var out: FragmentOutput;
  out.color = sum_color;
  out.log1malpha = sum_log1malpha;
  return out;
}

// Gamma Correction

struct GammaCorrectionVertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) texture_coord: vec2<f32>,
}

@vertex
fn gamma_correction_vs(
  @builtin(vertex_index) part: u32,
) -> GammaCorrectionVertexOutput {
  let dp = vec2<f32>(f32(part % 2), f32(part / 2)) * 2.0 - 1.0;
  var out: GammaCorrectionVertexOutput;
  out.position = vec4(dp * uniforms.view_xy_scaler, 0.0, 1.0);
  out.texture_coord = (vec2(dp.x, -dp.y) + 1.0) / 2.0;
  return out;
}

@fragment
fn gamma_correction_fs(in: GammaCorrectionVertexOutput) -> @location(0) vec4<f32> {
  let sum_color = textureSample(color_texture, framebuffer_sampler, in.texture_coord);
  let sum_log_one_minus_alpha = textureSample(log1malpha_texture, framebuffer_sampler, in.texture_coord).r;
  var color: vec4<f32>;
  if (sum_color.a > 0.0) {
    color = sum_color / sum_color.a * (1.0 - exp(sum_log_one_minus_alpha));
    color = color + uniforms.background_color * (1 - color.a);
  } else {
    color = uniforms.background_color;
  }
  let rgb = pow(color.rgb, vec3(1.0 / uniforms.gamma));
  return vec4(rgb, 1.0);
}

// Gaussian Blur

@compute @workgroup_size(64, 1)
fn gaussian_blur_stage_1(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let x = id.x;
  if (x >= u32(width)) { return; }
  let start = x + id.y * u32(width * height);
  let count = u32(height);
  let stride = u32(width);

  deriche_conv_1d(
    &blur_buffer, &blur_swap_buffer, start, stride, count,
    uniforms.kde_causal, uniforms.kde_anticausal, uniforms.kde_a,
    true
  );
}

@compute @workgroup_size(64, 1)
fn gaussian_blur_stage_2(@builtin(global_invocation_id) id: vec3<u32>) {
  let width = uniforms.density_width;
  let height = uniforms.density_height;
  let y = id.x;
  if (y >= u32(height)) { return; }
  let start = y * u32(width) + id.y * u32(width * height);
  let count = u32(width);
  let stride = u32(1);

  deriche_conv_1d(
    &blur_swap_buffer, &blur_buffer, start, stride, count,
    uniforms.kde_causal, uniforms.kde_anticausal, uniforms.kde_a,
    false
  );
}

fn deriche_conv_1d(
    src: ptr<storage, array<f16>, read_write>,
    dst: ptr<storage, array<f16>, read_write>,
    start: u32, stride: u32, count: u32,
    kde_causal: vec4<f32>, kde_anticausal: vec4<f32>, kde_a: vec4<f32>,
    src_is_u32: bool
) {
  var s: vec4<f32> = vec4(0.0);
  var y0: f32 = 0.0;
  var y1234: vec4<f32> = vec4(0.0);

  var first_nonzero: u32 = count;
  var last_nonzero: u32 = 0;

  for (var i: u32 = 0; i < count; i++) {
    let offset = start + i * stride;
    var input: f32;
    if (src_is_u32) {
      input = f32(bitcast<u32>(vec2((*src)[offset * 2], (*src)[offset * 2 + 1]))) / f32(ACCUMULATE_UNIT);
    } else {
      input = f32((*src)[offset]);
    }
    if (input != 0.0) {
      first_nonzero = min(i, first_nonzero);
      last_nonzero = max(i, last_nonzero);
    }
    s = vec4(input, s.xyz);
    y1234 = vec4(y0, y1234.xyz);
    y0 = dot(kde_causal, s) - dot(kde_a, y1234);
    (*dst)[offset] = f16(y0);
  }

  if (first_nonzero > last_nonzero) {
    return;
  }

  s = vec4(0.0);
  y0 = 0.0;
  y1234 = vec4(0.0);

  for (var i: u32 = count - 1 - last_nonzero; i < count; i++) {
    let p = count - 1 - i;
    let offset = start + p * stride;
    var input: f32 = 0.0;
    if (p >= first_nonzero) {
      if (src_is_u32) {
        input = f32(bitcast<u32>(vec2((*src)[offset * 2], (*src)[offset * 2 + 1]))) / f32(ACCUMULATE_UNIT);
      } else {
        input = f32((*src)[offset]);
      }
    }
    y1234 = vec4(y0, y1234.xyz);
    y0 = dot(kde_anticausal, s) - dot(kde_a, y1234);
    s = vec4(input, s.xyz);
    if (y0 != 0.0) {
      (*dst)[offset] = f16(f32((*dst)[offset]) + y0);
    }
  }
}
`;
class Eye {
  props;
  viewport;
  df;
  device;
  module;
  uniforms;
  context;
  renderInputs;
  dataBuffers;
  renderer;
  constructor(e, n, r, i, s) {
    this.context = e, this.props = {
      mode: "points",
      colorScheme: "light",
      x: new Float32Array(),
      y: new Float32Array(),
      category: null,
      categoryCount: 1,
      categoryColors: null,
      viewportX: 0,
      viewportY: 0,
      viewportScale: 1,
      pointSize: 1,
      pointAlpha: 1,
      pointsAlpha: 1,
      densityScaler: 1,
      densityBandwidth: 1,
      densityQuantizationStep: 0.1,
      contoursAlpha: 1,
      densityAlpha: 1,
      gamma: 2.2,
      width: i,
      height: s
    }, this.viewport = new I2({ x: 0, y: 0, scale: 1 }, i, s), this.df = new Xf();
    let o = this.df;
    this.renderInputs = {
      mode: o.value(this.props.mode),
      colorScheme: o.value(this.props.colorScheme),
      xData: o.value(this.props.x),
      yData: o.value(this.props.y),
      categoryData: o.value(this.props.category),
      categoryCount: o.value(this.props.categoryCount),
      categoryColors: o.value(this.props.categoryColors),
      matrix: o.value(d$()),
      width: o.value(i),
      height: o.value(s),
      pointSize: o.value(this.props.pointSize),
      densityBandwidth: o.value(this.props.densityBandwidth)
    }, this.device = o.value(n), this.dataBuffers = Dye(o, this.device, this.renderInputs), this.module = o.derive([this.device], (l) => l.createShaderModule({ code: Aye })), this.uniforms = vye(o, this.device), this.renderer = Oye(
      o,
      this.device,
      this.module,
      this.uniforms,
      r,
      this.renderInputs,
      this.dataBuffers
    );
  }
  setProps(e) {
    let n = !1, r;
    for (r in e)
      e[r] !== this.props[r] && (this.props[r] = e[r], n = !0);
    return this.viewport.update(
      { x: this.props.viewportX, y: this.props.viewportY, scale: this.props.viewportScale },
      this.props.width,
      this.props.height
    ), this.renderInputs.mode.value = this.props.mode, this.renderInputs.colorScheme.value = this.props.colorScheme, this.renderInputs.xData.value = this.props.x, this.renderInputs.yData.value = this.props.y, this.renderInputs.categoryData.value = this.props.category, this.renderInputs.categoryColors.value = this.props.categoryColors, this.props.category != null ? this.renderInputs.categoryCount.value = this.props.categoryCount : this.renderInputs.categoryCount.value = 1, this.renderInputs.matrix.value = this.viewport.matrix(), this.renderInputs.width.value = this.props.width, this.renderInputs.height.value = this.props.height, this.renderInputs.pointSize.value = this.props.pointSize, this.renderInputs.densityBandwidth.value = this.props.densityBandwidth, n;
  }
  render() {
    this.renderer.value(this.props, this.context.getCurrentTexture().createView());
  }
  destroy() {
    this.df.destroy();
  }
  async densityMap(e, n, r, i) {
    let s = this.df.subgraph(), { x: o, y: l, scale: a } = i, u = [a, 0, 0, 0, a, 0, -o * a, -l * a, 1], c = g$(u), f = await Fye(
      s,
      this.device,
      this.module,
      this.uniforms,
      s.value(e),
      s.value(n),
      s.value(r),
      s.value(u),
      this.dataBuffers
    ).value();
    return s.destroy(), {
      data: f,
      width: e,
      height: n,
      coordinateAtPixel: (d, p) => {
        let m = d / e * 2 - 1, y = p / n * 2 - 1, b = p$([m, y, 1], c);
        return { x: b[0], y: b[1] };
      }
    };
  }
}
function Dye(t, e, n) {
  let r = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
  const i = t.derive([n.xData], (c) => c.length), s = t.derive([i], (c) => c * 4), o = i, l = t.statefulDerive(
    [e, t.statefulDerive([e, s, r], sd), n.xData],
    N3
  ), a = t.statefulDerive(
    [e, t.statefulDerive([e, s, r], sd), n.yData],
    N3
  ), u = t.statefulDerive(
    [e, t.statefulDerive([e, o, r], sd), n.categoryData],
    N3
  );
  return { x: l, y: a, category: u, count: i };
}
function k$(t, e, n, r, i, s, o) {
  let l = "rgba16float", a = "r16float", u = GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, c = t.statefulDerive(
    [e, n, r, l, u],
    I9
  ), f = t.statefulDerive(
    [e, n, r, a, u],
    I9
  ), d = t.derive(
    [i, s, o],
    (b, v, _) => b * v * _ * 4
    // w * h * categoryCount * sizeof(uint32)
  ), p = t.derive(
    [i, s, o],
    (b, v, _) => b * v * _ * 2
    // w * h * categoryCount * sizeof(f16)
  ), m = t.statefulDerive(
    [e, d, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC],
    sd
  ), y = t.statefulDerive([e, p, GPUBufferUsage.STORAGE], sd);
  return {
    colorTexture: c,
    alphaTexture: f,
    colorTextureFormat: l,
    alphaTextureFormat: a,
    countBuffer: m,
    blurBuffer: y
  };
}
function Oye(t, e, n, r, i, s, o) {
  let l = t.derive([s.densityBandwidth], (C) => Math.ceil(C * 3) + 1), a = t.derive([s.width, l], (C, E) => C + E * 2), u = t.derive([s.height, l], (C, E) => C + E * 2), c = t.derive([a], (C) => Math.ceil(C / 4)), f = t.derive([u], (C) => Math.ceil(C / 4)), d = k$(
    t,
    e,
    a,
    u,
    c,
    f,
    s.categoryCount
  ), p = x$(t, e, r.buffer, o, d), m = v$(t, e, n, p, o, d), y = _ye(t, e, n, p, o, d), b = wye(t, e, n, p, d), v = kye(t, e, n, i, p), _ = w$(t, e, n, p, a, u, s.categoryCount), k = t.derive(
    [s.densityBandwidth, a, c],
    (C, E, A) => _$(C / E * A)
  ), S = t.derive(
    [s.categoryColors, s.categoryCount],
    (C, E) => (C == null && (C = g0(E)), C.map((A) => Y5(A)))
  );
  return t.derive(
    [
      e,
      a,
      u,
      c,
      f,
      r.update,
      o.count,
      s.matrix,
      S,
      y,
      v,
      m,
      _,
      b,
      k
    ],
    (C, E, A, O, T, $, P, B, M, L, N, j, U, H, G) => (re, se) => {
      let oe = re.colorScheme == "light" ? [1, 1, 1, 1] : [0, 0, 0, 1], ne = re.width / E, ce = re.height / A, we = X5([ne, 0, 0, 0, ce, 0, 0, 0, 1], B);
      $({
        count: P,
        category_count: re.categoryCount,
        framebuffer_width: E,
        framebuffer_height: A,
        density_width: O,
        density_height: T,
        gamma: re.gamma,
        point_size: Math.max(re.mode == "points" ? 3 : 1, re.pointSize),
        point_alpha: re.pointAlpha,
        points_alpha: re.pointsAlpha,
        density_scaler: re.densityScaler / 16,
        quantization_step: re.densityQuantizationStep,
        density_alpha: re.densityAlpha,
        contours_alpha: re.contoursAlpha,
        matrix: we,
        view_xy_scaler: [1 / ne, 1 / ce],
        kde_causal: G.kde_causal,
        kde_anticausal: G.kde_anticausal,
        kde_a: G.kde_a,
        background_color: oe,
        category_colors: M
      });
      let Me = C.createCommandEncoder();
      L(Me), re.mode == "density" && (re.densityAlpha > 0 || re.contoursAlpha > 0) && (j(Me), U(Me), H(Me)), N(Me, se), C.queue.submit([Me.finish()]);
    }
  );
}
function Fye(t, e, n, r, i, s, o, l, a) {
  let u = k$(t, e, i, s, i, s, t.value(1)), c = x$(t, e, r.buffer, a, u), f = v$(t, e, n, c, a, u), d = w$(t, e, n, c, i, s, t.value(1));
  return t.derive(
    [
      e,
      i,
      s,
      a.count,
      r.update,
      o,
      l,
      f,
      d,
      u.countBuffer
    ],
    (p, m, y, b, v, _, k, S, C, E) => () => {
      let A = p.createCommandEncoder(), O = _$(_);
      v({
        count: b,
        category_count: 1,
        framebuffer_width: m,
        framebuffer_height: y,
        density_width: m,
        density_height: y,
        gamma: 1,
        point_size: 0,
        point_alpha: 0,
        points_alpha: 0,
        density_scaler: 0,
        quantization_step: 0,
        density_alpha: 0,
        contours_alpha: 0,
        matrix: k,
        view_xy_scaler: [1, 1],
        kde_causal: O.kde_causal,
        kde_anticausal: O.kde_anticausal,
        kde_a: O.kde_a,
        background_color: [0, 0, 0, 0],
        category_colors: []
      }), S(A), C(A);
      let T = p.createBuffer({
        size: m * y * 2,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      return A.copyBufferToBuffer(E, 0, T, 0, m * y * 2), p.queue.submit([A.finish()]), T.mapAsync(GPUMapMode.READ, 0, m * y * 2).then(() => Tye(T.getMappedRange()));
    }
  );
}
function Tye(t) {
  let e = new Uint16Array(t), n = new Uint32Array(e.length);
  for (let r = 0; r < e.length; r++) {
    let i = e[r] & 32767, s = e[r] & 32768, o = e[r] & 31744;
    i <<= 13, s <<= 16, i += 939524096, i = o == 0 ? 0 : i, i |= s, n[r] = i;
  }
  return new Float32Array(n.buffer);
}
let rp;
function Rye() {
  return rp == null && (rp = document.createElement("canvas"), rp.width = 1, rp.height = 1), rp.getContext("2d");
}
function Mye(t) {
  let e = Rye();
  e.font = `${t.fontSize ?? 10}px ${t.fontFamily ?? "system-ui"}`;
  let n = t.text.split(`
`).map((i) => e.measureText(i).width), r = (t.fontSize ?? 10) * (t.lineSpacing ?? 1) * n.length;
  return {
    width: n.reduce((i, s) => Math.max(i, s)),
    height: r
  };
}
let V3 = null, yk = /* @__PURE__ */ new Map();
function Pye() {
  return V3 == null && (V3 = new Promise((t, e) => {
    let n = new Worker(new URL("./clustering.worker.js", import.meta.url), { type: "module" });
    n.onmessage = (r) => {
      if (r.data.ready) {
        t(n);
        return;
      }
      if (r.data.id != null) {
        let i = yk.get(r.data.id);
        i != null && (yk.delete(r.data.id), i(r.data));
      }
    };
  })), V3;
}
function y0(t, e, n = []) {
  return new Promise((r, i) => {
    Pye().then((s) => {
      let o = (/* @__PURE__ */ new Date()).getTime().toString() + "-" + Math.random().toString();
      yk.set(o, (l) => {
        r(l.payload);
      }), s.postMessage({ id: o, name: t, payload: e }, n);
    });
  });
}
let Iye = (t, e, n, r) => y0("findClusters", [t, e, n, r], [t.buffer]), Nye = (...t) => y0("dynamicLabelPlacement", t), Bye = (...t) => y0("textSummarizerCreate", t), Lye = (...t) => y0("textSummarizerDestroy", t), $ye = (...t) => y0("textSummarizerAdd", t), zye = (...t) => y0("textSummarizerSummarize", t);
async function lO(t, e, n, r, i) {
  let s = new I2(n, t, e), o = r.reduce((m, y) => Math.min(m, y.level ?? 0), 0), l = r.reduce((m, y) => Math.max(m, y.level ?? 0), 0), a = n.scale, u = n.scale / 2, c = u * 4, f = a / c, d = r.map((m) => {
    let y = s.pixelLocation(m.x, m.y), b = m.level ?? 0, v = b == 0 ? 14 : 12, _ = Mye({
      text: m.text,
      fontSize: v,
      fontFamily: i
    });
    return _.width += 4, _.height += 4, {
      text: m.text,
      fontSize: v,
      bounds: {
        xMin: y.x - _.width / 2,
        xMax: y.x + _.width / 2,
        yMin: y.y - _.height / 2,
        yMax: y.y + _.height / 2
      },
      locationAtZero: y,
      priority: m.priority,
      minScale: m.level == l ? null : f * Math.pow(2, -b) / 1.2,
      maxScale: m.level == o ? null : f * Math.pow(2, -b + 1),
      coordinate: { x: m.x, y: m.y },
      placement: null
    };
  }), p = await Nye(d, { globalMaxScale: a / u });
  for (let m = 0; m < p.length; m++) {
    let y = p[m];
    if (y != null) {
      let b = a / y.minScale, v = a / y.maxScale;
      d[m].placement = { minScale: v, maxScale: b };
    }
  }
  return d;
}
function jye(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var aO = { exports: {} }, uO;
function qye() {
  return uO || (uO = 1, (function(t) {
    (function() {
      function e(l, a) {
        var u = l.x - a.x, c = l.y - a.y;
        return u * u + c * c;
      }
      function n(l, a, u) {
        var c = a.x, f = a.y, d = u.x - c, p = u.y - f;
        if (d !== 0 || p !== 0) {
          var m = ((l.x - c) * d + (l.y - f) * p) / (d * d + p * p);
          m > 1 ? (c = u.x, f = u.y) : m > 0 && (c += d * m, f += p * m);
        }
        return d = l.x - c, p = l.y - f, d * d + p * p;
      }
      function r(l, a) {
        for (var u = l[0], c = [u], f, d = 1, p = l.length; d < p; d++)
          f = l[d], e(f, u) > a && (c.push(f), u = f);
        return u !== f && c.push(f), c;
      }
      function i(l, a, u, c, f) {
        for (var d = c, p, m = a + 1; m < u; m++) {
          var y = n(l[m], l[a], l[u]);
          y > d && (p = m, d = y);
        }
        d > c && (p - a > 1 && i(l, a, p, c, f), f.push(l[p]), u - p > 1 && i(l, p, u, c, f));
      }
      function s(l, a) {
        var u = l.length - 1, c = [l[0]];
        return i(l, 0, u, a, c), c.push(l[u]), c;
      }
      function o(l, a, u) {
        if (l.length <= 2) return l;
        var c = a !== void 0 ? a * a : 1;
        return l = u ? l : r(l, c), l = s(l, c), l;
      }
      t.exports = o, t.exports.default = o;
    })();
  })(aO)), aO.exports;
}
var Uye = qye();
const cO = /* @__PURE__ */ jye(Uye);
function Hye(t, e) {
  let n = t.slice();
  for (let r = 0; r < e; r++) {
    const i = [], s = n.length;
    for (let o = 0; o < s; o++) {
      const l = n[o], a = n[(o + 1) % s], u = {
        x: 0.75 * l.x + 0.25 * a.x,
        y: 0.75 * l.y + 0.25 * a.y
      }, c = {
        x: 0.25 * l.x + 0.75 * a.x,
        y: 0.25 * l.y + 0.75 * a.y
      };
      i.push(u, c);
    }
    n = i;
  }
  return n;
}
function Vye(t, e) {
  const n = Hye(t, 5), r = l$(n);
  let i = Math.max(r.xMax - r.xMin, r.yMax - r.yMin) / 100, s = cO(n, i), o = 0;
  for (; s.length > e && o < 20; )
    i *= 1.1, o += 1, s = cO(n, i);
  return s;
}
const fO = {
  light: {
    fontFamily: "system-ui,sans-serif",
    clusterLabelColor: "#000",
    clusterLabelOutlineColor: "rgba(255,255,255,0.8)",
    clusterLabelOpacity: 0.8,
    statusBar: !0,
    statusBarTextColor: "#525252",
    statusBarBackgroundColor: "rgba(255,255,255,0.9)",
    brandingLink: { text: "Embedding Atlas", href: "https://apple.github.io/embedding-atlas" }
  },
  dark: {
    fontFamily: "system-ui,sans-serif",
    clusterLabelColor: "#ccc",
    clusterLabelOutlineColor: "rgba(0,0,0,0.8)",
    clusterLabelOpacity: 0.8,
    statusBar: !0,
    statusBarTextColor: "#d9d9d9",
    statusBarBackgroundColor: "rgba(0,0,0,0.9)",
    brandingLink: { text: "Embedding Atlas", href: "https://apple.github.io/embedding-atlas" }
  }
};
function Wye(t, e) {
  return t == null ? fO[e] : { ...fO[e], ...t, ...t[e] != null ? t[e] : {} };
}
function Gye(t, e, n, r, i, s, o) {
  let l = Math.max(r, i) / s, a = t / (n * n) / (l * l), u = 1 / (a / (s * s)) * 0.2, c = Math.sqrt(t / e / (l * l)), f = Math.log(c), d = Math.log(n), p = (Math.min(Math.max((d - f) * 2, -1), 1) + 1) / 2, m;
  if (o != null)
    m = o * s;
  else {
    let v = 0.25 / Math.sqrt(a);
    m = Math.max(0.2, Math.min(5, v)) * s;
  }
  let y = 1 - p, b = 0.5 + p * 0.5;
  return {
    densityScaler: u,
    densityAlpha: y,
    contoursAlpha: y,
    pointSize: m,
    pointAlpha: 0.7,
    pointsAlpha: b,
    densityBandwidth: 20
  };
}
var Kye = /* @__PURE__ */ bc("<div></div>"), Yye = /* @__PURE__ */ uu("<circle></circle>"), Xye = /* @__PURE__ */ uu("<circle></circle>"), Qye = /* @__PURE__ */ uu('<text dominant-baseline="middle"> </text>'), Jye = /* @__PURE__ */ uu("<g></g>"), Zye = /* @__PURE__ */ uu("<g><!></g>"), ebe = /* @__PURE__ */ uu("<g></g>"), tbe = /* @__PURE__ */ bc('<div><canvas></canvas> <div><!></div> <svg role="none"><!><!><!><!></svg> <!> <!></div>');
function nbe(t, e) {
  Wf(e, !0);
  let n = nt(e, "data", 19, () => ({ x: new Float32Array(), y: new Float32Array(), category: null })), r = nt(e, "categoryCount", 3, 1), i = nt(e, "categoryColors", 3, null), s = nt(e, "width", 3, 800), o = nt(e, "height", 3, 800), l = nt(e, "pixelRatio", 3, 2), a = nt(e, "theme", 3, null), u = nt(e, "config", 3, null), c = nt(e, "totalCount", 3, null), f = nt(e, "maxDensity", 3, null), d = nt(e, "labels", 3, null), p = nt(e, "queryClusterLabels", 3, null), m = nt(e, "tooltip", 7, null), y = nt(e, "selection", 7, null), b = nt(e, "querySelection", 3, null), v = nt(e, "rangeSelection", 7, null), _ = nt(e, "defaultViewportState", 3, null), k = nt(e, "viewportState", 7, null), S = nt(e, "customTooltip", 3, null), C = nt(e, "customOverlay", 3, null), E = nt(e, "onViewportState", 3, null), A = nt(e, "onTooltip", 3, null), O = nt(e, "onSelection", 3, null), T = nt(e, "onRangeSelection", 3, null), $ = nt(e, "cache", 3, null), P = /* @__PURE__ */ yt(() => u()?.colorScheme ?? "light"), B = /* @__PURE__ */ yt(() => Wye(a(), W(P))), M = /* @__PURE__ */ yt(() => i() ?? g0(r())), L = /* @__PURE__ */ yt(() => k() ?? _() ?? { x: 0, y: 0, scale: 1 }), N = /* @__PURE__ */ yt(() => new I2(W(L), s(), o())), j = /* @__PURE__ */ yt(() => W(N).pixelLocationFunction()), U = /* @__PURE__ */ yt(() => W(N).coordinateAtPixelFunction()), H = /* @__PURE__ */ Pn(!1);
  function G(ve, Re) {
    return ve.x == Re.x && ve.y == Re.y && ve.category == Re.category && ve.text == Re.text;
  }
  let re = /* @__PURE__ */ yt(() => y()?.length == 1 && m() != null && G(y()[0], m()));
  function se(ve) {
    Bu(k(), ve) || (k(ve), E()?.(ve));
  }
  function oe(ve) {
    Bu(m(), ve) || (m(ve), A()?.(ve));
  }
  function ne(ve) {
    Bu(y(), ve) || (y(ve), O()?.(ve));
  }
  function ce(ve) {
    Bu(v(), ve) || (v(ve), T()?.(ve));
  }
  let we = /* @__PURE__ */ Pn(Jc([])), Me = /* @__PURE__ */ Pn(null), Pe = /* @__PURE__ */ Pn("none"), Ce = /* @__PURE__ */ yt(() => s() * l()), fe = /* @__PURE__ */ yt(() => o() * l()), De = /* @__PURE__ */ Pn(null), Se = /* @__PURE__ */ Pn(null), Ne = /* @__PURE__ */ Pn(null), Ye = /* @__PURE__ */ yt(() => u()?.minimumDensity ?? 1 / 16), Ge = /* @__PURE__ */ yt(() => u()?.pointSize ?? null), gt = /* @__PURE__ */ yt(() => u()?.mode ?? "points"), Pt = /* @__PURE__ */ yt(() => u()?.autoLabelEnabled), mt = /* @__PURE__ */ yt(() => Gye(f() ?? (c() ?? n().x.length) / 4, W(Ye), W(L).scale, W(Ce), W(fe), l(), W(Ge))), Wt = /* @__PURE__ */ yt(() => W(mt).pointSize), un = !0;
  Lp(() => {
    W(Se)?.setProps({
      mode: W(gt),
      colorScheme: W(P),
      viewportX: W(L).x,
      viewportY: W(L).y,
      viewportScale: W(L).scale,
      width: W(Ce),
      height: W(fe),
      x: n().x,
      y: n().y,
      category: n().category,
      categoryCount: r(),
      categoryColors: W(M),
      ...W(mt)
    }) && (It(), (W(Pt) !== !1 || d() != null) && un && W(Se) != null && n().x != null && n().x.length > 0 && _() != null && (un = !1, qn(_())));
  });
  function Ke() {
    Ze = null, !(!W(De) || !W(Se)) && (W(De).width = W(Se).props.width, W(De).height = W(Se).props.height, W(De).style.width = `${W(Se).props.width / l()}px`, W(De).style.height = `${W(Se).props.height / l()}px`, W(Se).render());
  }
  let Ze = null;
  function It() {
    Ze == null && (Ze = requestAnimationFrame(Ke));
  }
  function vn(ve) {
    let Re;
    function qe() {
      Re = ve.getContext("webgl2", { antialias: !1 }), Re.getExtension("EXT_color_buffer_float"), Re.getExtension("EXT_float_blend"), Re.getExtension("OES_texture_float_linear"), dt(Se, new hye(Re, W(Ce), W(fe)), !0);
    }
    qe(), ve.addEventListener("webglcontextlost", () => {
      W(Se)?.destroy(), dt(Se, null), Re = null;
    }), ve.addEventListener("webglcontextrestored", () => {
      qe();
    });
  }
  function Te(ve) {
    async function Re() {
      let qe = ve.getContext("webgpu");
      if (qe == null) {
        console.error("Could not get WebGPU canvas context");
        return;
      }
      let Xe = await navigator.gpu.requestAdapter();
      if (!Xe) {
        console.error("Could not request WebGPU adapter");
        return;
      }
      let tt = 512 * 1048576, ft = 512 * 1048576;
      tt = Math.min(tt, Xe.limits.maxBufferSize), ft = Math.min(ft, Xe.limits.maxStorageBufferBindingSize);
      let Ht = {
        requiredLimits: { maxBufferSize: tt, maxStorageBufferBindingSize: ft },
        requiredFeatures: ["shader-f16"]
      }, mn = await Xe.requestDevice(Ht);
      mn.lost.then((ar) => {
        console.info(`WebGPU device was lost: ${ar.message}`), ar.reason != "destroyed" && (W(Se)?.destroy(), dt(Se, null), Re());
      });
      let An = navigator.gpu.getPreferredCanvasFormat();
      qe.configure({ device: mn, format: An, alphaMode: "premultiplied" }), dt(Se, new Eye(qe, mn, An, W(Ce), W(fe)), !0);
    }
    Re();
  }
  function Oe(ve) {
    ve != null && k() == null && se(ve);
  }
  Lp(() => Oe(_())), W5(() => {
    W(De) != null && (oL() ? Te(W(De)) : (vn(W(De)), dt(Ne, "WebGPU is unavailable. If you are using Safari, please enable the WebGPU feature flag.")));
  }), Yme(() => {
    W(Se)?.destroy(), dt(Se, null);
  });
  function et(ve) {
    let Re = W(De)?.getBoundingClientRect() ?? { left: 0, top: 0 };
    return { x: ve.clientX - Re.left, y: ve.clientY - Re.top };
  }
  function kt(ve) {
    ve.preventDefault();
    let { x: Re, y: qe } = et(ve), Xe = Math.exp(-ve.deltaY / 200);
    tn(Xe, { x: Re, y: qe });
  }
  function tn(ve, Re) {
    let { x: qe, y: Xe, scale: tt } = W(L);
    oe(null);
    let ft = Math.min(100, Math.max(0.01, tt * ve)), Ht = W(De).getBoundingClientRect(), mn = Math.max(Ht.width, Ht.height), An = (Re.x - Ht.width / 2) / mn * 2, ar = (Ht.height / 2 - Re.y) / mn * 2, Qs = qe + An / tt - An / ft, Fr = Xe + ar / tt - ar / ft;
    se({ x: Qs, y: Fr, scale: ft });
  }
  function Tn(ve) {
    oe(null);
    let Re = "pan";
    W(Pe) != "none" ? ve.modifiers.shift || (Re = W(Pe)) : ve.modifiers.shift && (Re = ve.modifiers.meta ? "lasso" : "marquee");
    let qe = et(ve);
    switch (Re) {
      case "marquee":
        return {
          move: (Xe) => {
            if (oe(null), W(Se) == null)
              return;
            let tt = et(Xe), ft = W(U)(qe.x, qe.y), Ht = W(U)(tt.x, tt.y);
            ce({
              xMin: Math.min(ft.x, Ht.x),
              yMin: Math.min(ft.y, Ht.y),
              xMax: Math.max(ft.x, Ht.x),
              yMax: Math.max(ft.y, Ht.y)
            });
          }
        };
      case "lasso": {
        let Xe = [W(U)(qe.x, qe.y)];
        return {
          move: (tt) => {
            if (oe(null), W(Se) == null)
              return;
            let ft = et(tt);
            Xe = [...Xe, W(U)(ft.x, ft.y)], Xe.length >= 3 && ce(Vye(Xe, 24));
          }
        };
      }
      case "pan": {
        let Xe = W(U)(0, 0), tt = W(U)(1, 1), ft = Xe.x - tt.x, Ht = Xe.y - tt.y, mn = W(L).x, An = W(L).y;
        return {
          move: (ar) => {
            se({
              x: mn + (ar.clientX - ve.clientX) * ft,
              y: An + (ar.clientY - ve.clientY) * Ht,
              scale: W(L).scale
            });
          }
        };
      }
    }
  }
  async function Gt(ve) {
    if (v() != null)
      ce(null);
    else {
      const Re = await tr(et(ve));
      if (Re == null)
        ne([]), oe(null);
      else if (ve.modifiers.shift || ve.modifiers.ctrl || ve.modifiers.meta) {
        let qe = y()?.findIndex((Xe) => Xe.x == Re.x && Xe.y == Re.y && Xe.category == Re.category);
        y() == null || qe == null || qe < 0 ? (ne([...y() ?? [], Re]), oe(Re)) : (ne([
          ...y().slice(0, qe),
          ...y().slice(qe + 1)
        ]), oe(null));
      } else
        ne([Re]), oe(Re);
    }
  }
  let Je = a1e(
    async (ve) => {
      let Re = ve ? et(ve) : null;
      if (y() != null && y().length == 1) {
        let qe = W(j)(y()[0].x, y()[0].y);
        Re != null && u1e(Re, qe) < 10 && oe(y()[0]);
      } else
        oe(await tr(Re));
    },
    () => m() != null
  );
  function gn(ve) {
    ve != null ? W(H) || Je(ve) : Je(null);
  }
  Lp(() => {
    W(H) && Je(null);
  });
  async function tr(ve) {
    if (W(Se) == null || ve == null || b() == null)
      return null;
    let { x: Re, y: qe } = W(U)(ve.x, ve.y), Xe = Math.abs(W(U)(ve.x + 1, ve.y).x - Re);
    return await b()(Re, qe, Xe);
  }
  async function xi(ve, Re, qe, Xe = 5e-3) {
    let tt = await ve.densityMap(1e3, 1e3, Re, qe), ft = await Iye(tt.data, tt.width, tt.height), Ht = [];
    for (let An = 0; An < ft.length; An++) {
      let ar = ft[An], Qs = tt.coordinateAtPixel(ar.meanX, ar.meanY), Fr = ar.boundaryRectApproximation.map(([bs, Eo, E0, Do]) => {
        let ga = tt.coordinateAtPixel(bs, Eo), ma = tt.coordinateAtPixel(E0, Do);
        return {
          xMin: Math.min(ga.x, ma.x),
          xMax: Math.max(ga.x, ma.x),
          yMin: Math.min(ga.y, ma.y),
          yMax: Math.max(ga.y, ma.y)
        };
      });
      Ht.push({
        x: Qs.x,
        y: Qs.y,
        sumDensity: ar.sumDensity,
        rects: Fr,
        bandwidth: Re
      });
    }
    let mn = Ht.reduce((An, ar) => Math.max(An, ar.sumDensity), 0);
    return Ht.filter((An) => An.sumDensity / mn > Xe);
  }
  async function pa(ve) {
    if (W(Se) == null || p() == null)
      return [];
    let Re = await f1e({
      autoLabel: {
        version: 1,
        viewport: ve,
        stopWords: u()?.autoLabelStopWords,
        densityThreshold: u()?.autoLabelDensityThreshold
      }
    });
    if ($() != null) {
      let tt = await $().get(Re);
      if (tt != null)
        return tt;
    }
    let qe = await xi(W(Se), 10, ve, u()?.autoLabelDensityThreshold ?? 5e-3);
    if (qe = qe.concat(await xi(W(Se), 5, ve)), p()) {
      let tt = await p()(qe.map((ft) => ft.rects));
      for (let ft = 0; ft < qe.length; ft++)
        qe[ft].label = tt[ft];
    }
    let Xe = qe.filter((tt) => tt.label != null && tt.label.length > 0).map((tt) => ({
      x: tt.x,
      y: tt.y,
      text: tt.label,
      priority: tt.sumDensity,
      level: tt.bandwidth == 10 ? 0 : 1
    }));
    return $() != null && await $().set(Re, Xe), Xe;
  }
  async function qn(ve) {
    if (W(Se) != null)
      if (d() != null)
        dt(we, await lO(s(), o(), ve, d(), W(B).fontFamily), !0);
      else {
        dt(Me, "Generating labels...");
        let Re = await pa(ve);
        dt(we, await lO(s(), o(), ve, Re, W(B).fontFamily), !0), dt(Me, null);
      }
  }
  class qr {
    content;
    constructor(Re, qe) {
      let Xe = document.createElement("div");
      this.content = Xe, this.update(qe), Re.appendChild(Xe);
    }
    update(Re) {
      let qe = this.content;
      qe.style.fontFamily = Re.fontFamily, W(P) == "light" ? (qe.style.color = "#000", qe.style.background = "#fff", qe.style.border = "1px solid #000") : (qe.style.color = "#ccc", qe.style.background = "#000", qe.style.border = "1px solid #ccc"), qe.style.borderRadius = "2px", qe.style.padding = "5px", qe.style.fontSize = "12px", qe.style.maxWidth = "300px", qe.innerText = Re.tooltip.text ?? JSON.stringify(Re.tooltip);
    }
  }
  var ys = tbe();
  let al;
  var So = Nr(ys);
  Kt(So, "", {}, { position: "absolute", top: "0", left: "0" }), pk(So, (ve) => dt(De, ve), () => W(De));
  var Ao = Vn(So, 2);
  let xc;
  var tx = Nr(Ao);
  {
    var nx = (ve) => {
      const Re = /* @__PURE__ */ yt(() => a$(C())), qe = /* @__PURE__ */ yt(() => ({
        location: W(j),
        width: s(),
        height: o()
      }));
      var Xe = np(), tt = Dh(Xe);
      Xme(tt, () => W(Re), (ft) => {
        var Ht = Kye();
        Po(Ht, (mn, An) => W(Re)?.(mn, An), () => u$(C(), { proxy: W(qe) })), rr(ft, Ht);
      }), rr(ve, Xe);
    };
    Vi(tx, (ve) => {
      C() && ve(nx);
    });
  }
  br(Ao);
  var ul = Vn(Ao, 2);
  Kt(ul, "", {}, { position: "absolute", left: "0", top: "0" });
  var Dm = Nr(ul);
  {
    var Om = (ve) => {
      const Re = /* @__PURE__ */ yt(() => {
        const { x: Ht, y: mn } = W(j)(m().x, m().y);
        return { x: Ht, y: mn };
      }), qe = /* @__PURE__ */ yt(() => Math.max(3, W(Wt) / l()) + 1);
      var Xe = np(), tt = Dh(Xe);
      {
        var ft = (Ht) => {
          var mn = Yye();
          let An;
          Bs(() => {
            Ue(mn, "cx", W(Re).x), Ue(mn, "cy", W(Re).y), Ue(mn, "r", W(qe)), An = Kt(mn, "", An, {
              stroke: W(P) == "light" ? "#000" : "#fff",
              "stroke-width": 1,
              fill: "none"
            });
          }), rr(Ht, mn);
        };
        Vi(tt, (Ht) => {
          isFinite(W(Re).x) && isFinite(W(Re).y) && isFinite(W(qe)) && Ht(ft);
        });
      }
      rr(ve, Xe);
    };
    Vi(Dm, (ve) => {
      m() != null && W(Se) != null && ve(Om);
    });
  }
  var Fm = Vn(Dm);
  {
    var rx = (ve) => {
      var Re = np(), qe = Dh(Re);
      L3(qe, 17, y, B3, (Xe, tt) => {
        const ft = /* @__PURE__ */ yt(() => {
          const { x: Fr, y: bs } = W(j)(W(tt).x, W(tt).y);
          return { x: Fr, y: bs };
        }), Ht = /* @__PURE__ */ yt(() => W(tt).category != null ? W(M)[W(tt).category] : W(M)[0]), mn = /* @__PURE__ */ yt(() => Math.max(3, W(Wt) / l()) + 1);
        var An = np(), ar = Dh(An);
        {
          var Qs = (Fr) => {
            var bs = Xye();
            let Eo;
            Bs(() => {
              Ue(bs, "cx", W(ft).x), Ue(bs, "cy", W(ft).y), Ue(bs, "r", W(mn)), Eo = Kt(bs, "", Eo, {
                stroke: W(P) == "light" ? "#000" : "#fff",
                "stroke-width": 2,
                fill: W(Ht)
              });
            }), rr(Fr, bs);
          };
          Vi(ar, (Fr) => {
            isFinite(W(ft).x) && isFinite(W(ft).y) && isFinite(W(mn)) && Fr(Qs);
          });
        }
        rr(Xe, An);
      }), rr(ve, Re);
    };
    Vi(Fm, (ve) => {
      y() != null && W(Se) != null && ve(rx);
    });
  }
  var Tm = Vn(Fm);
  {
    var S0 = (ve) => {
      var Re = ebe();
      L3(Re, 21, () => W(we), B3, (qe, Xe) => {
        const tt = /* @__PURE__ */ yt(() => W(Xe).text.split(`
`)), ft = /* @__PURE__ */ yt(() => W(j)(W(Xe).coordinate.x, W(Xe).coordinate.y)), Ht = /* @__PURE__ */ yt(() => W(Xe).placement != null && W(Xe).placement.minScale <= W(L).scale && W(L).scale <= W(Xe).placement.maxScale);
        var mn = Zye(), An = Nr(mn);
        {
          var ar = (Qs) => {
            var Fr = Jye();
            L3(Fr, 21, () => W(tt), B3, (bs, Eo, E0) => {
              var Do = Qye();
              Ue(Do, "x", 0);
              let ga;
              var ma = Nr(Do, !0);
              br(Do), Bs(() => {
                Ue(Do, "y", (E0 - (W(tt).length - 1) / 2) * W(Xe).fontSize), Ue(Do, "font-size", W(Xe).fontSize), ga = Kt(Do, "", ga, {
                  "paint-order": "stroke",
                  "stroke-width": "4",
                  "stroke-linejoin": "round",
                  "stroke-linecap": "round",
                  "text-anchor": "middle",
                  fill: W(B).clusterLabelColor,
                  stroke: W(B).clusterLabelOutlineColor,
                  opacity: W(B).clusterLabelOpacity,
                  "user-select": "none",
                  "-webkit-user-select": "none",
                  "font-family": W(B).fontFamily
                }), $p(ma, W(Eo));
              }), rr(bs, Do);
            }), br(Fr), rr(Qs, Fr);
          };
          Vi(An, (Qs) => {
            W(Ht) && Qs(ar);
          });
        }
        br(mn), Bs(() => Ue(mn, "transform", `translate(${W(ft).x ?? ""},${W(ft).y ?? ""})`)), rr(qe, mn);
      }), br(Re), rr(ve, Re);
    };
    Vi(Tm, (ve) => {
      ve(S0);
    });
  }
  var ix = Vn(Tm);
  {
    var A0 = (ve) => {
      var Re = np(), qe = Dh(Re);
      {
        var Xe = (ft) => {
          g1e(ft, {
            get value() {
              return v();
            },
            get pointLocation() {
              return W(j);
            }
          });
        }, tt = (ft) => {
          l1e(ft, {
            get value() {
              return v();
            },
            onChange: ce,
            get pointLocation() {
              return W(j);
            },
            get coordinateAtPoint() {
              return W(U);
            },
            preventHover: (Ht) => {
              dt(H, Ht, !0);
            }
          });
        };
        Vi(qe, (ft) => {
          v() instanceof Array ? ft(Xe) : ft(tt, !1);
        });
      }
      rr(ve, Re);
    };
    Vi(ix, (ve) => {
      v() != null && W(Se) != null && ve(A0);
    });
  }
  br(ul), Po(ul, (ve, Re) => mr?.(ve, Re), () => ({ click: Gt, drag: Tn, hover: gn }));
  var Rm = Vn(ul, 2);
  {
    var sx = (ve) => {
      const Re = /* @__PURE__ */ yt(() => W(j)(m().x, m().y));
      {
        let qe = /* @__PURE__ */ yt(() => Math.max(3, W(Wt) / l())), Xe = /* @__PURE__ */ yt(() => S() ?? {
          class: qr,
          props: {
            colorScheme: W(P),
            fontFamily: W(B).fontFamily
          }
        });
        E1e(ve, {
          get location() {
            return W(Re);
          },
          get allowInteraction() {
            return W(re);
          },
          get targetHeight() {
            return W(qe);
          },
          get customTooltip() {
            return W(Xe);
          },
          get tooltip() {
            return m();
          }
        });
      }
    };
    Vi(Rm, (ve) => {
      m() != null && W(Se) != null && ve(sx);
    });
  }
  var ox = Vn(Rm, 2);
  {
    var lx = (ve) => {
      {
        let Re = /* @__PURE__ */ yt(() => W(Me) ?? W(Ne)), qe = /* @__PURE__ */ yt(() => 1 / (W(j)(1, 0).x - W(j)(0, 0).x));
        C1e(ve, {
          get resolvedTheme() {
            return W(B);
          },
          get statusMessage() {
            return W(Re);
          },
          get distancePerPoint() {
            return W(qe);
          },
          get pointCount() {
            return n().x.length;
          },
          get selectionMode() {
            return W(Pe);
          },
          onSelectionMode: (Xe) => dt(Pe, Xe, !0)
        });
      }
    };
    Vi(ox, (ve) => {
      W(B).statusBar && ve(lx);
    });
  }
  br(ys), Bs(() => {
    al = Kt(ys, "", al, {
      width: `${s() ?? ""}px`,
      height: `${o() ?? ""}px`,
      position: "relative"
    }), xc = Kt(Ao, "", xc, {
      width: `${s() ?? ""}px`,
      height: `${o() ?? ""}px`,
      position: "absolute",
      top: "0",
      left: "0"
    }), Ue(ul, "width", s()), Ue(ul, "height", o());
  }), $me("wheel", ul, kt), rr(t, ys), Gf();
}
function hO(t, e) {
  if (e.length == 0)
    return R.literal(!1);
  if (t.identifier != null) {
    let n = t.identifier;
    return R.or(...e.map((r) => R.eq(R.column(n), R.literal(r.identifier))));
  } else {
    let n = t.x, r = t.y, i = t.category;
    return i != null ? R.or(
      ...e.map(
        (s) => R.and(
          R.eq(R.cast(R.column(n), "DOUBLE"), R.literal(s.x)),
          R.eq(R.cast(R.column(r), "DOUBLE"), R.literal(s.y)),
          R.eq(R.cast(R.column(i), "INTEGER"), R.literal(s.category))
        )
      )
    ) : R.or(
      ...e.map(
        (s) => R.and(
          R.eq(R.cast(R.column(n), "DOUBLE"), R.literal(s.x)),
          R.eq(R.cast(R.column(r), "DOUBLE"), R.literal(s.y))
        )
      )
    );
  }
}
function rbe(t, e, n) {
  let r = [];
  for (let s = 0; s < n.length; s++) {
    let o = (s + 1) % n.length, { x: l, y: a } = n[s], { x: u, y: c } = n[o], f = a < c ? R.and(R.lte(R.literal(a), e), R.lt(e, R.literal(c))) : R.and(R.lte(R.literal(c), e), R.lt(e, R.literal(a))), d = (a < c ? R.lt : R.gt)(
      R.sub(R.mul(R.literal(u - l), e), R.mul(R.literal(c - a), t)),
      R.literal((u - l) * a - (c - a) * l)
    );
    r.push(R.cast(R.and(f, d), "INT"));
  }
  let i = r.reduce((s, o) => R.add(s, o));
  return R.eq(R.mod(i, R.literal(2)), R.literal(1));
}
function ibe(t, e) {
  if (e instanceof Array) {
    if (e.length < 3)
      return R.literal(!1);
    let n = l$(e);
    return R.and(
      R.isBetween(R.column(t.x), [n.xMin, n.xMax]),
      R.isBetween(R.column(t.y), [n.yMin, n.yMax]),
      rbe(R.column(t.x), R.column(t.y), e)
    );
  } else
    return R.and(
      R.isBetween(R.column(t.x), [e.xMin, e.xMax]),
      R.isBetween(R.column(t.y), [e.yMin, e.yMax])
    );
}
async function sbe(t, e) {
  let { x: n, y: r, table: i } = e, s = await t.query(
    R.Query.from(i).select({
      centerX: R.sql`MEDIAN(${R.column(n)})`,
      centerY: R.sql`MEDIAN(${R.column(r)})`,
      stdX: R.sql`STDDEV(${R.column(n)})`,
      stdY: R.sql`STDDEV(${R.column(r)})`,
      ...e.category != null ? {
        maxCategory: R.sql`MAX(${R.column(e.category)}::UTINYINT)`
      } : {}
    })
  ), { centerX: o, centerY: l, stdX: a, stdY: u, maxCategory: c } = s.get(0), f = 1 / (Math.max(a, u, 1e-3) * 3), d = 0.1 / f, p = R.sql`FLOOR((${R.column(n)} - ${o}) / ${d})`, m = R.sql`FLOOR((${R.column(r)} - ${l}) / ${d})`, y = e.category != null ? R.column(e.category) : null, b = y != null ? [p, m, y] : [p, m], v = R.Query.from(
    R.Query.from(i).select({ count: R.sql`COUNT(*)` }).groupby(...b)
  ).select({
    totalCount: R.sql`SUM(count)::INT`,
    maxCount: R.sql`MAX(count)::INT`
  });
  s = await t.query(v);
  let { maxCount: _, totalCount: k } = s.get(0), S = _ / (d * d);
  return {
    centerX: o,
    centerY: l,
    scaler: f,
    totalCount: k,
    categoryCount: (c ?? 0) + 1,
    maxDensity: S
  };
}
class obe {
  coordinator;
  source;
  lastDistance;
  selectParams;
  constructor(e, n) {
    this.coordinator = e, this.source = n, this.lastDistance = 0;
    let { x: r, y: i, category: s, text: o, identifier: l } = this.source, a = {}, u = n.additionalFields ?? {};
    for (let c in u) {
      let f = u[c];
      typeof f == "string" ? a["field_" + c] = R.column(f) : a["field_" + c] = R.sql`${f.sql}`;
    }
    this.selectParams = {
      x: R.sql`${R.column(r)}::DOUBLE`,
      y: R.sql`${R.column(i)}::DOUBLE`,
      ...s != null ? { category: R.sql`${R.column(s)}::INT` } : {},
      ...o != null ? { text: R.sql`${R.column(o)}` } : {},
      ...l != null ? { identifier: R.sql`${R.column(l)}` } : {},
      ...a
    };
  }
  _convertToDataPoint(e) {
    let n = {};
    for (let r in e)
      r.startsWith("field_") && (n[r.slice(6)] = e[r]);
    return {
      x: e.x,
      y: e.y,
      category: e.category,
      text: e.text,
      identifier: e.identifier,
      fields: n
    };
  }
  async queryClosestPoint(e, n, r, i) {
    let s = i * 12, { x: o, y: l } = this.source;
    for (let a of [this.lastDistance, s]) {
      if (a == 0 || a > s)
        continue;
      let u = R.Query.from(this.source.table).select(this.selectParams);
      u = u.where(R.sql`${R.column(o)} BETWEEN ${n - a} AND ${n + a}`), u = u.where(R.sql`${R.column(l)} BETWEEN ${r - a} AND ${r + a}`), e && (u = u.where(e)), u = u.orderby(R.sql`(x - (${n}))**2 + (y - (${r}))**2`).limit(1);
      let c = (await this.coordinator.query(u)).get(0);
      if (c)
        return this.lastDistance = Math.max(Math.abs(c.x - n), Math.abs(c.y - r)) * 4, this._convertToDataPoint(c);
    }
    return null;
  }
  async queryPoints(e) {
    let { table: n, identifier: r } = this.source;
    if (r == null)
      return [];
    let i = R.Query.from(n).select(this.selectParams);
    return i = i.where(
      R.isIn(
        R.column(r),
        e.map((s) => R.literal(s))
      )
    ), Array.from(await this.coordinator.query(i)).map((s) => this._convertToDataPoint(s));
  }
}
function lbe(t, e) {
  Wf(e, !0);
  let n = nt(e, "coordinator", 19, _F), r = nt(e, "category", 3, null), i = nt(e, "text", 3, null), s = nt(e, "identifier", 3, null), o = nt(e, "filter", 3, null), l = nt(e, "categoryColors", 3, null), a = nt(e, "tooltip", 3, null), u = nt(e, "additionalFields", 3, null), c = nt(e, "selection", 3, null), f = nt(e, "rangeSelection", 3, null), d = nt(e, "rangeSelectionValue", 3, null), p = nt(e, "width", 3, null), m = nt(e, "height", 3, null), y = nt(e, "pixelRatio", 3, null), b = nt(e, "config", 3, null), v = nt(e, "theme", 3, null), _ = nt(e, "viewportState", 3, null), k = nt(e, "labels", 3, null), S = nt(e, "customTooltip", 3, null), C = nt(e, "customOverlay", 3, null), E = nt(e, "onViewportState", 3, null), A = nt(e, "onTooltip", 3, null), O = nt(e, "onSelection", 3, null), T = nt(e, "onRangeSelection", 3, null), $ = nt(e, "cache", 3, null), P = /* @__PURE__ */ Pn(new Float32Array()), B = /* @__PURE__ */ Pn(new Float32Array()), M = /* @__PURE__ */ Pn(null), L = /* @__PURE__ */ Pn(1), N = /* @__PURE__ */ Pn(1), j = /* @__PURE__ */ Pn(1), U = /* @__PURE__ */ Pn(null), H = /* @__PURE__ */ Pn(null), G = /* @__PURE__ */ Pn(null), re = /* @__PURE__ */ Pn(null), se = /* @__PURE__ */ Pn(null);
  Ea(() => {
    let fe = {
      coordinator: n(),
      source: {
        table: e.table,
        x: e.x,
        y: e.y,
        category: r()
      }
    }, De = null, Se = !1;
    async function Ne() {
      let Ye = fe.source, Ge = await sbe(fe.coordinator, Ye);
      if (Se)
        return;
      let gt = Ge.scaler * 0.95;
      dt(U, {
        x: Ge.centerX,
        y: Ge.centerY,
        scale: gt
      }), dt(N, Ge.totalCount), dt(j, Ge.maxDensity), dt(L, Ge.categoryCount), De = ia({
        coordinator: fe.coordinator,
        selection: o() ?? void 0,
        query: (Pt) => R.Query.from(Ye.table).select({
          x: R.sql`${R.column(Ye.x)}::FLOAT`,
          y: R.sql`${R.column(Ye.y)}::FLOAT`,
          ...Ye.category != null ? { c: R.sql`${R.column(Ye.category)}::UTINYINT` } : {}
        }).where(Pt),
        queryResult: (Pt) => {
          let mt = Pt.getChild("x").toArray(), Wt = Pt.getChild("y").toArray(), un = Pt.getChild("c")?.toArray() ?? null;
          mt != null && !(mt instanceof Float32Array) && (mt = new Float32Array(mt)), Wt != null && !(Wt instanceof Float32Array) && (Wt = new Float32Array(Wt)), un != null && !(un instanceof Uint8Array) && (un = new Uint8Array(un)), dt(P, mt), dt(B, Wt), dt(M, un), oe(null), ne(null);
        }
      }), De.reset = () => {
        ce();
      }, dt(se, De);
    }
    return Ne(), () => {
      dt(se, null), Se = !0, De?.destroy();
    };
  }), Ea(() => {
    if (g_(a())) {
      let fe = W(se);
      if (fe == null)
        return;
      let De = a();
      dt(H, De.valueFor(fe) ?? null);
      let Se = () => {
        dt(H, De.valueFor(fe) ?? null);
      };
      return Ea(() => {
        let Ne = W(H), Ye = {
          x: e.x,
          y: e.y,
          category: r(),
          identifier: s()
        };
        De.update({
          source: fe,
          clients: (/* @__PURE__ */ new Set()).add(fe),
          predicate: Ne != null ? hO(Ye, [Ne]) : null,
          value: Ne
        });
      }), De.addEventListener("value", Se), () => {
        De.removeEventListener("value", Se), De.update({
          source: fe,
          clients: (/* @__PURE__ */ new Set()).add(fe),
          value: null,
          predicate: null
        });
      };
    } else if (a() == null || typeof a() == "object")
      dt(H, a());
    else {
      if (W(H)?.identifier == a())
        return;
      let fe = !1;
      return Pe([a()]).then((De) => {
        fe || (De.length > 0 ? dt(H, De[0]) : dt(H, null));
      }), () => {
        fe = !0;
      };
    }
  });
  function oe(fe) {
    Bu(a(), fe) || (dt(H, fe), A()?.(fe));
  }
  Ea(() => {
    if (g_(c())) {
      let fe = W(se);
      if (fe == null)
        return;
      let De = c();
      dt(G, De.valueFor(fe) ?? null);
      let Se = () => {
        dt(G, De.valueFor(fe) ?? null);
      };
      return Ea(() => {
        let Ne = W(G), Ye = {
          x: e.x,
          y: e.y,
          category: r(),
          identifier: s()
        };
        De.update({
          source: fe,
          clients: (/* @__PURE__ */ new Set()).add(fe),
          predicate: Ne != null ? hO(Ye, Ne) : null,
          value: Ne
        });
      }), De.addEventListener("value", Se), () => {
        De.removeEventListener("value", Se), De.update({
          source: fe,
          clients: (/* @__PURE__ */ new Set()).add(fe),
          value: null,
          predicate: null
        });
      };
    } else if (c() == null)
      dt(G, null);
    else if (c().length == 0)
      dt(G, []);
    else if (c().every((fe) => typeof fe == "object"))
      dt(G, c());
    else {
      let fe = !1;
      return Pe(c()).then((De) => {
        fe || dt(G, De);
      }), () => {
        fe = !0;
      };
    }
  });
  function ne(fe) {
    Bu(c(), fe) || (dt(G, fe), O()?.(fe));
  }
  Ea(() => {
    let fe = W(se);
    if (fe == null)
      return;
    let De = f();
    if (De != null)
      return Ea(() => {
        let Se = W(re), Ne = { x: e.x, y: e.y }, Ye = {
          source: fe,
          clients: (/* @__PURE__ */ new Set()).add(fe),
          predicate: Se != null ? ibe(Ne, Se) : null,
          value: Se
        };
        De.update(Ye), De.activate(Ye);
      }), () => {
        De.update({
          source: fe,
          clients: (/* @__PURE__ */ new Set()).add(fe),
          value: null,
          predicate: null
        });
      };
  }), Ea(() => {
    Bu(Yf(() => W(re)), d()) || dt(re, d());
  });
  function ce() {
    ne(null), oe(null), T()?.(null), dt(re, null);
  }
  let we = /* @__PURE__ */ yt(() => new obe(n(), {
    table: e.table,
    x: e.x,
    y: e.y,
    category: r(),
    text: i(),
    identifier: s(),
    additionalFields: u()
  }));
  async function Me(fe, De, Se) {
    return await W(we).queryClosestPoint(o()?.predicate?.(W(se)), fe, De, Se);
  }
  async function Pe(fe) {
    return await W(we).queryPoints(fe);
  }
  async function Ce(fe) {
    if (i() == null)
      return fe.map(() => null);
    let De = await Bye({
      regions: fe,
      stopWords: b()?.autoLabelStopWords ?? null
    }), Se = 0, Ne = 1e4, Ye = null;
    for (; ; ) {
      let gt = await n().query(R.Query.from(e.table).select({
        x: R.column(e.x),
        y: R.column(e.y),
        text: R.column(i())
      }).offset(Se).limit(Ne)), Pt = {
        x: gt.getChild("x").toArray(),
        y: gt.getChild("y").toArray(),
        text: gt.getChild("text").toArray()
      };
      if (Ye != null && await Ye, Ye = $ye(De, Pt), gt.getChild("text").length < Ne)
        break;
      Se += Ne;
    }
    Ye != null && await Ye;
    let Ge = await zye(De);
    return await Lye(De), Ge.map((gt) => gt.length == 0 ? null : gt.length > 2 ? gt.slice(0, 2).join("-") + `-
` + gt.slice(2).join("-") : gt.join("-"));
  }
  {
    let fe = /* @__PURE__ */ yt(() => p() ?? 800), De = /* @__PURE__ */ yt(() => m() ?? 800), Se = /* @__PURE__ */ yt(() => y() ?? 2), Ne = /* @__PURE__ */ yt(() => ({
      x: W(P),
      y: W(B),
      category: W(M)
    }));
    nbe(t, {
      get width() {
        return W(fe);
      },
      get height() {
        return W(De);
      },
      get pixelRatio() {
        return W(Se);
      },
      get theme() {
        return v();
      },
      get config() {
        return b();
      },
      get data() {
        return W(Ne);
      },
      get totalCount() {
        return W(N);
      },
      get maxDensity() {
        return W(j);
      },
      get categoryCount() {
        return W(L);
      },
      get categoryColors() {
        return l();
      },
      get defaultViewportState() {
        return W(U);
      },
      querySelection: Me,
      queryClusterLabels: Ce,
      get labels() {
        return k();
      },
      get customTooltip() {
        return S();
      },
      get customOverlay() {
        return C();
      },
      get tooltip() {
        return W(H);
      },
      onTooltip: oe,
      get selection() {
        return W(G);
      },
      onSelection: ne,
      get viewportState() {
        return _();
      },
      get onViewportState() {
        return E();
      },
      get rangeSelection() {
        return W(re);
      },
      onRangeSelection: (Ye) => {
        dt(re, Ye), T()?.(Ye);
      },
      get cache() {
        return $();
      }
    });
  }
  Gf();
}
class abe {
  component;
  currentProps;
  constructor(e, n) {
    this.currentProps = { ...n }, this.component = Wme({ component: lbe, target: e, props: n });
  }
  update(e) {
    let n = {};
    for (let r in e)
      e[r] !== this.currentProps[r] && (n[r] = e[r], this.currentProps[r] = e[r]);
    this.component.$set(n);
  }
  destroy() {
    this.component.$destroy();
  }
}
function ube() {
  return oL() ? 32 : 4;
}
function by(t, e = 0) {
  let n = ZB(t);
  return n.l += e, n.a = 0, n.b = 0, n.rgb().formatHex8();
}
const vc = {
  light: {
    scheme: "light",
    continuousColorScheme: "YlGnBu",
    continuousColorSchemeAtZero: $ge(0),
    markColor: "#3b82f6",
    markColorFade: "#dbeafe",
    markColorGray: by("#3b82f6", 20),
    markColorGrayFade: by("#dbeafe"),
    gridColor: No.slate[300],
    labelColor: No.slate[400],
    titleColor: No.slate[400],
    brushBorder: No.slate[500],
    brushBorderBack: "#fff",
    brushFill: "rgba(0,0,0,0.1)"
  },
  dark: {
    scheme: "dark",
    continuousColorScheme: "Inferno",
    continuousColorSchemeAtZero: sL(0),
    markColor: "#3b82f6",
    markColorFade: "#3b4d7f",
    markColorGray: by("#3b82f6", -20),
    markColorGrayFade: by("#1f398a"),
    gridColor: No.slate[700],
    labelColor: No.slate[500],
    titleColor: No.slate[500],
    brushBorder: No.slate[400],
    brushBorderBack: "#000",
    brushFill: "rgba(255,255,255,0.1)"
  }
};
function C$(t) {
  let e = [];
  for (let n = 0; n < t; n++)
    e.push(zge((n + 0.5) / t));
  return e;
}
const S$ = "system-ui", bk = 11, cbe = 80;
let ip;
function fbe() {
  return ip == null && (ip = document.createElement("canvas"), ip.width = 1, ip.height = 1), ip.getContext("2d");
}
function vk(t) {
  let e = fbe();
  e.font = `${bk}px ${S$}`;
  let n = e.measureText(t);
  return {
    width: Math.min(cbe, n.width),
    height: bk
  };
}
function A$(t, e, n = 0) {
  let r = 0, i = 0;
  for (let s of t) {
    let { width: o, height: l } = s.size;
    r = Math.max(r, o), i = Math.max(i, l);
  }
  switch (e) {
    case "x":
      return { left: r / 2, right: r / 2, top: 0, bottom: i + n };
    case "y":
      return { left: r + n, right: 0, top: i / 2, bottom: i / 2 };
  }
}
function dO(t, e, n) {
  switch (t.type) {
    case "band":
      return hbe(t, e, n);
    default:
      return dbe(t, e, n);
  }
}
function hbe(t, e, n) {
  let r = [...t.domain, ...t.specialValues ?? []];
  r = Array.from(new Set(r)), n == "y" && (r = r.reverse());
  let i = HB().domain(r).padding(0.1), s = [], o = [], l = { left: 0, right: 0, top: 0, bottom: 0 };
  if (e) {
    let a = e.values ?? i.domain(), u = e.labelPadding ?? 6;
    s = a.map((c) => {
      let { width: f, height: d } = vk(c);
      return n == "y" ? {
        text: c,
        value: c,
        padding: u,
        level: 0,
        size: { width: f, height: d },
        orientation: "horizontal"
      } : {
        text: c,
        value: c,
        padding: u,
        level: 0,
        size: { width: d, height: f },
        orientation: "vertical"
      };
    }), o = a.map((c) => ({ value: c, level: 0 })), l = Q5([l, A$(s, n, u)]);
  }
  return {
    extents: l,
    labels: s,
    gridLines: [],
    ticks: o,
    concrete: (a) => gbe(i, t.domain, t.specialValues ?? [], a)
  };
}
function dbe(t, e, n) {
  let r;
  switch (t.type) {
    case "linear": {
      r = c0().domain(t.domain);
      break;
    }
    case "log": {
      r = Pg().domain(t.domain);
      break;
    }
    case "symlog": {
      let l = t.constant ?? 1;
      r = rL().constant(l).domain(t.domain), r.nice = () => r, r.ticks = (a) => mbe(r.domain(), l, a), r.tickFormat = () => su("~s");
      break;
    }
    default:
      throw new Error("invalid scale type");
  }
  let i = [], s = [], o = { left: 0, right: 0, top: 0, bottom: 0 };
  if (e) {
    let l = [];
    if (e.extendScaleToTicks ?? !0)
      if (e.values) {
        l = e.values;
        let f = r.domain().concat(l);
        r = r.domain([
          f.reduce((d, p) => Math.min(d, p), f[0]),
          f.reduce((d, p) => Math.max(d, p), f[0])
        ]);
      } else {
        let f = e.desiredTickCount ?? 5;
        r.nice && (r = r.nice(f)), l = r.ticks(f);
      }
    else {
      if (e.values)
        l = e.values;
      else {
        let p = e.desiredTickCount ?? 5;
        l = r.ticks(p);
      }
      let [f, d] = r.domain();
      l = l.filter((p) => p >= f && p <= d);
    }
    let a = e.labelPadding ?? 6, u = r.tickFormat(e.values ? e.values.length : e.desiredTickCount ?? 5), c = (f) => t.type == "log" || t.type == "symlog" ? Math.round(Math.log10(Math.abs(f))) == Math.log10(Math.abs(f)) ? 0 : 1 : 0;
    i = l.map((f) => {
      let d = u(f);
      return {
        text: d,
        value: f,
        padding: a,
        level: c(f),
        size: vk(d),
        orientation: "horizontal"
      };
    });
    for (let f of t.specialValues ?? [])
      i.push({
        text: f,
        value: f,
        padding: a,
        level: 0,
        size: vk(f),
        orientation: "horizontal"
      });
    s = l.map((f) => ({ value: f, level: c(f) })), o = Q5([o, A$(i, n, a)]);
  }
  return {
    extents: o,
    labels: i,
    gridLines: s,
    ticks: s,
    concrete: (l) => pbe(r, t.specialValues ?? [], l)
  };
}
function Q5(t) {
  let e = { left: 0, right: 0, top: 0, bottom: 0 };
  for (let n of t)
    e.left = Math.max(e.left, n.left), e.right = Math.max(e.right, n.right), e.top = Math.max(e.top, n.top), e.bottom = Math.max(e.bottom, n.bottom);
  return e;
}
function pO(t, e, n = {}) {
  let r = n.gap ?? 0, i = t.map((l, a) => ({ ...e(l), index: a })).sort((l, a) => l.priority - a.priority), s = t.map((l) => !1), o = (l, a) => Math.abs(l.center - a.center) < r + l.length / 2 + a.length / 2;
  for (let l = 0; l < i.length; l++) {
    let a = !1;
    for (let u = 0; u < l; u++)
      if (s[i[u].index] && o(i[l], i[u])) {
        a = !0;
        break;
      }
    s[i[l].index] = !a;
  }
  return t.filter((l, a) => s[a]);
}
function pbe(t, e, n) {
  e = Array.from(new Set(e));
  let r = n[0], i = n[1], s = /* @__PURE__ */ new Map(), o;
  if (e.length > 0) {
    let a = 22, u = 8, c = 20, f = e.length * c, d = 2, p = r;
    r < i ? (r = r + f + a, o = [p, p + f + a - u]) : (r = r - f - a, p = r + a, o = [p - a + u, p + f]);
    for (let m = 0; m < e.length; m++)
      s.set(e[m], [p + m * c + d, p + m * c + c - d]);
  }
  let l = t.copy().range([r, i]);
  return {
    domain: t.domain(),
    specialValues: e ?? [],
    range: [r, i],
    rangeBands: [[r, i], ...o ? [o] : []],
    apply: (a) => {
      let u = s.get(a);
      return u != null ? (u[0] + u[1]) / 2 : l(a);
    },
    applyBand: (a) => {
      let u = s.get(a);
      if (u != null)
        return u;
      if (typeof a != "number")
        return [l(a[0]), l(a[1])];
      {
        let c = l(a);
        return [c, c];
      }
    },
    invert: (a, u) => {
      if (u != "number") {
        for (let [c, f] of s.entries())
          if (a >= Math.min(...f) && a <= Math.max(...f))
            return c;
      }
      return l.invert(a);
    }
  };
}
function gbe(t, e, n, r) {
  let i = r[0], s = r[1], o = t.copy().range(r), l = o.bandwidth(), a = o.step();
  return {
    domain: e,
    specialValues: n,
    range: [i, s],
    rangeBands: [[i, s]],
    apply: (u) => (o(u) ?? 0) + l / 2,
    applyBand: (u) => {
      let c = o(u) ?? 0;
      return [c, c + l];
    },
    invert: (u) => {
      let c = (u - i) / (s - i), f = Math.floor(c * Math.abs(s - i) / a);
      return t.domain()[f];
    }
  };
}
function mbe(t, e, n) {
  n = n ?? 5;
  let r = t[0], i = t[1];
  if (r > 0 && i > 0 && r / i > 0.5 || r < 0 && i < 0 && i / r > 0.5)
    return c0().domain([r, i]).ticks(n);
  let s = e * 2, o = e * 5;
  return r < -o && i > o && (n = Math.ceil(n / 2)), [
    ...r < -o ? Pg().domain([s, -r]).ticks(n).map((l) => -l) : [],
    0,
    ...i > o ? Pg().domain([s, i]).ticks(n) : []
  ].filter((l) => l >= r && l <= i);
}
function ybe(t, e) {
  let { min: n, max: r, median: i, count: s, minPositive: o } = t, l = {
    type: "linear",
    domain: [n, r]
  };
  return e == null ? s >= 100 && n >= 0 && i < r * 0.05 && (l.type = n > 0 ? "log" : "symlog") : l.type = e, l.type == "log" && (l.domain[0] = o), l;
}
function bbe(t, e = {}) {
  let n = e.fade ?? [], r = e.ordinal ?? !1, i = [], s = (a) => JSON.stringify(a);
  for (let a of t) {
    let u = s(a);
    typeof a == "string" && n.indexOf(a) >= 0 || i.push(u);
  }
  let o = r ? C$(i.length) : g0(i.length), l = new Map(i.map((a, u) => [a, o[u]]));
  return {
    domain: t,
    apply: (a) => {
      let u = s(a);
      return l.get(u) ?? "#888888";
    }
  };
}
var vbe = /* @__PURE__ */ Dt("<g><foreignObject><div> </div></foreignObject></g>");
function gO(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ K(() => e.dimension == "x" ? {
    px: e.proxy.xScale?.apply(e.label.value) ?? 0,
    py: e.proxy.plotHeight + e.label.padding,
    anchorX: 0.5,
    anchorY: 0
  } : {
    px: -e.label.padding,
    py: e.proxy.yScale?.apply(e.label.value) ?? 0,
    anchorX: 1,
    anchorY: 0.5
  }), r = /* @__PURE__ */ K(() => x(n).px), i = /* @__PURE__ */ K(() => x(n).py), s = /* @__PURE__ */ K(() => x(n).anchorX), o = /* @__PURE__ */ K(() => x(n).anchorY), l = /* @__PURE__ */ K(() => e.label.orientation == "vertical" ? {
    rotation: 90,
    shiftX: x(s) * e.label.size.width,
    shiftY: -x(o) * e.label.size.height,
    width: e.label.size.height,
    height: e.label.size.width
  } : {
    rotation: 0,
    shiftX: -x(s) * e.label.size.width,
    shiftY: -x(o) * e.label.size.height,
    width: e.label.size.width,
    height: e.label.size.height
  }), a = /* @__PURE__ */ K(() => x(l).rotation), u = /* @__PURE__ */ K(() => x(l).shiftX), c = /* @__PURE__ */ K(() => x(l).shiftY), f = /* @__PURE__ */ K(() => x(l).width), d = /* @__PURE__ */ K(() => x(l).height), p = 4, m = 4;
  var y = vbe(), b = J(y);
  te(b, "x", -p), te(b, "y", -m);
  var v = J(b);
  let _;
  var k = J(v, !0);
  Q(v), Q(b), Q(y), ke(() => {
    te(y, "transform", `translate(${x(r) + x(u)}, ${x(i) + x(c)}) rotate(${x(a) ?? ""})`), te(b, "width", x(f) + p * 2), te(b, "height", x(d) + m * 2), te(v, "title", e.label.text), _ = ht(v, "", _, {
      width: `${x(f) + 2}px`,
      height: `${x(d) + m * 2}px`,
      "line-height": `${x(d) + m * 2}px`,
      "font-family": S$,
      "font-size": `${bk}px`,
      "margin-left": "4px",
      color: e.color,
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }), ut(k, e.label.text);
  }), X(t, y), st();
}
var xbe = /* @__PURE__ */ Dt('<line stroke-linecap="butt"></line>'), wbe = /* @__PURE__ */ Dt('<line stroke-dasharray="1,3" stroke-linecap="square"></line>'), _be = /* @__PURE__ */ Dt("<g><!><!><!></g>"), kbe = /* @__PURE__ */ Dt('<line stroke-linecap="butt"></line>'), Cbe = /* @__PURE__ */ Dt('<line stroke-linecap="square"></line>'), Sbe = /* @__PURE__ */ Dt("<g><!><!><!></g>"), Abe = /* @__PURE__ */ ge("<div><svg><g><!><!><!><!></g></svg></div>");
function $d(t, e) {
  it(e, !0);
  const n = 4;
  let r = ct(e, "xAxis", 19, () => ({})), i = ct(e, "yAxis", 19, () => ({})), s = /* @__PURE__ */ K(() => e.xScale ? dO(e.xScale, r(), "x") : null), o = /* @__PURE__ */ K(() => e.yScale ? dO(e.yScale, i(), "y") : null), l = /* @__PURE__ */ K(() => Q5([
    x(s)?.extents,
    x(o)?.extents,
    e.extents
  ].filter((T) => T != null))), a = /* @__PURE__ */ K(() => ({
    x: x(l).left,
    y: x(l).top,
    width: e.width - x(l).left - x(l).right,
    height: e.height - x(l).top - x(l).bottom
  })), u = /* @__PURE__ */ K(() => x(s)?.concrete([0, x(a).width])), c = /* @__PURE__ */ K(() => x(o)?.concrete([x(a).height, 0])), f = /* @__PURE__ */ K(() => x(s) && x(u) ? pO(
    x(s).labels,
    (T) => ({
      center: x(u).apply(T.value),
      length: T.size.width,
      priority: T.level
    }),
    { gap: 4 }
  ) : []), d = /* @__PURE__ */ K(() => x(o) && x(c) ? pO(
    x(o).labels,
    (T) => ({
      center: x(c).apply(T.value),
      length: T.size.height,
      priority: T.level
    }),
    { gap: 2 }
  ) : []), p = /* @__PURE__ */ K(() => vc[e.colorScheme ?? "light"]), m = /* @__PURE__ */ K(() => ({
    xScale: x(u),
    yScale: x(c),
    plotWidth: x(a).width,
    plotHeight: x(a).height
  }));
  var y = Abe();
  let b;
  var v = J(y);
  ht(v, "", {}, { position: "absolute", left: "-4px", top: "-4px" });
  var _ = J(v), k = J(_);
  Xa(k, () => e.childrenBelow ?? zt, () => x(m));
  var S = ue(k);
  {
    var C = (T) => {
      var $ = _be(), P = J($);
      Bt(P, 17, () => x(s).ticks, fn, (L, N) => {
        const j = /* @__PURE__ */ K(() => x(u).apply(x(N).value));
        var U = xbe();
        ke(() => {
          te(U, "x1", x(j)), te(U, "y1", x(a).height), te(U, "x2", x(j)), te(U, "y2", x(a).height + (x(N).level == 0 ? 3 : 0)), te(U, "stroke", x(p).gridColor), te(U, "stroke-opacity", x(N).level == 0 ? 1 : 0.4);
        }), X(L, U);
      });
      var B = ue(P);
      Bt(B, 17, () => x(s).gridLines, fn, (L, N) => {
        const j = /* @__PURE__ */ K(() => x(u).apply(x(N).value));
        var U = kn(), H = We(U);
        Bt(H, 17, () => x(c)?.rangeBands ?? [], fn, (G, re) => {
          var se = /* @__PURE__ */ K(() => lA(x(re), 2));
          let oe = () => x(se)[0], ne = () => x(se)[1];
          var ce = wbe();
          ke(
            (we, Me) => {
              te(ce, "x1", x(j)), te(ce, "y1", we), te(ce, "x2", x(j)), te(ce, "y2", Me), te(ce, "stroke", x(p).gridColor), te(ce, "stroke-opacity", x(N).level == 0 ? 1 : 0.4);
            },
            [() => Math.min(oe(), ne()), () => Math.max(oe(), ne())]
          ), X(G, ce);
        }), X(L, U);
      });
      var M = ue(B);
      Bt(M, 17, () => x(f), fn, (L, N) => {
        gO(L, {
          get label() {
            return x(N);
          },
          dimension: "x",
          get proxy() {
            return x(m);
          },
          get color() {
            return x(p).labelColor;
          }
        });
      }), Q($), X(T, $);
    };
    Fe(S, (T) => {
      x(s) && x(u) && r() && T(C);
    });
  }
  var E = ue(S);
  {
    var A = (T) => {
      var $ = Sbe(), P = J($);
      Bt(P, 17, () => x(o).ticks, fn, (L, N) => {
        const j = /* @__PURE__ */ K(() => x(c).apply(x(N).value));
        var U = kbe();
        te(U, "x2", 0), ke(() => {
          te(U, "x1", -(x(N).level == 0 ? 3 : 0)), te(U, "y1", x(j)), te(U, "y2", x(j)), te(U, "stroke", x(p).gridColor), te(U, "stroke-opacity", x(N).level == 0 ? 1 : 0.4);
        }), X(L, U);
      });
      var B = ue(P);
      Bt(B, 17, () => x(o).gridLines, fn, (L, N) => {
        const j = /* @__PURE__ */ K(() => x(c).apply(x(N).value));
        var U = kn(), H = We(U);
        Bt(H, 17, () => x(u)?.rangeBands ?? [], fn, (G, re) => {
          var se = /* @__PURE__ */ K(() => lA(x(re), 2));
          let oe = () => x(se)[0], ne = () => x(se)[1];
          var ce = Cbe();
          ke(() => {
            te(ce, "x1", oe()), te(ce, "y1", x(j)), te(ce, "x2", ne()), te(ce, "y2", x(j)), te(ce, "stroke", x(p).gridColor), te(ce, "stroke-opacity", x(N).level == 0 ? 1 : 0.4);
          }), X(G, ce);
        }), X(L, U);
      });
      var M = ue(B);
      Bt(M, 17, () => x(d), fn, (L, N) => {
        gO(L, {
          get label() {
            return x(N);
          },
          dimension: "y",
          get proxy() {
            return x(m);
          },
          get color() {
            return x(p).labelColor;
          }
        });
      }), Q($), X(T, $);
    };
    Fe(E, (T) => {
      x(o) && x(c) && i() && T(A);
    });
  }
  var O = ue(E);
  Xa(O, () => e.children ?? zt, () => x(m)), Q(_), Q(v), Q(y), ke(() => {
    b = ht(y, "", b, {
      width: `${e.width ?? ""}py`,
      height: `${e.height ?? ""}px`,
      position: "relative",
      "user-select": "none",
      "-webkit-user-select": "none",
      cursor: "default"
    }), te(v, "width", e.width + n * 2), te(v, "height", e.height + n * 2), te(_, "transform", `translate(${n + x(a).x},${n + x(a).y})`);
  }), X(t, y), st();
}
var Ebe = /* @__PURE__ */ Dt('<rect role="none"></rect><rect role="none"></rect>', 1), Dbe = /* @__PURE__ */ Dt('<rect role="none"></rect><rect role="none"></rect>', 1), Obe = /* @__PURE__ */ Dt('<rect role="none"></rect><rect role="none"></rect><rect role="none"></rect><rect role="none"></rect>', 1), Fbe = /* @__PURE__ */ Dt('<rect></rect><rect role="none"></rect><!><!><!>', 1), Tbe = /* @__PURE__ */ Dt('<g><rect stroke="none" fill="none" role="none"></rect><!></g>');
function N2(t, e) {
  it(e, !0);
  const n = 8;
  let r = /* @__PURE__ */ K(() => vc[e.colorScheme ?? "light"]), i, s = /* @__PURE__ */ K(() => e.proxy.xScale != null && e.value?.x != null ? e.proxy.xScale.applyBand(e.value.x) : [0, e.proxy.plotWidth]), o = /* @__PURE__ */ K(() => e.proxy.yScale != null && e.value?.y != null ? e.proxy.yScale.applyBand(e.value.y) : [0, e.proxy.plotHeight]);
  function l(b) {
    return b instanceof Array && b.length == 2 && typeof b[0] == "number" && typeof b[1] == "number";
  }
  function a(b, v, _) {
    let k = b.invert(v, _);
    if (b.domain.length == 2 && typeof b.domain[0] == "number" && typeof k == "number") {
      let [S, C] = b.domain;
      return Math.max(Math.min(S, C), Math.min(Math.max(S, C), k));
    }
    return k;
  }
  function u(b, v) {
    return (v == "x" || v == "xy") && b.x == null ? !1 : !((v == "y" || v == "xy") && b.y == null);
  }
  function c() {
    return (b) => {
      let v = i.getBoundingClientRect().left, _ = i.getBoundingClientRect().top, k = b.clientX - v, S = b.clientY - _, C = e.proxy.xScale ? a(e.proxy.xScale, k) : null, E = e.proxy.yScale ? a(e.proxy.yScale, S) : null;
      if (C == null && (e.mode == "x" || e.mode == "xy") || E == null && (e.mode == "y" || e.mode == "xy"))
        return;
      let A = (T, $) => typeof T == "number" && typeof $ == "number" ? T != $ ? [Math.min(T, $), Math.max(T, $)] : null : $, O = (T) => {
        let $ = T.clientX - v, P = T.clientY - _, B = e.proxy.xScale ? a(e.proxy.xScale, $, typeof C == "number" ? "number" : void 0) : null, M = e.proxy.yScale ? a(e.proxy.yScale, P, typeof E == "number" ? "number" : void 0) : null, L = {};
        return (e.mode == "x" || e.mode == "xy") && (L.x = A(C, B)), (e.mode == "y" || e.mode == "xy") && (L.y = A(E, M)), u(L, e.mode) ? L : null;
      };
      return {
        move: (T) => {
          e.onChange(O(T));
        },
        up: (T) => {
          e.onChange(O(T));
        }
      };
    };
  }
  function f(b) {
    return (v) => {
      if (e.value == null)
        return;
      let _ = { ...e.value }, { xScale: k, yScale: S } = e.proxy, C = l(_.x), E = l(_.y), A = [
        ...k && _.x ? k.applyBand(_.x) : [0, 0],
        ...S && _.y ? S.applyBand(_.y) : [0, 0]
      ];
      if (!C) {
        let T = Math.max(b[0], b[1]);
        b = [T, T, b[2], b[3]];
      }
      if (!E) {
        let T = Math.max(b[2], b[3]);
        b = [b[0], b[1], T, T];
      }
      let O = (T) => {
        let $ = T.pageX - v.pageX, P = T.pageY - v.pageY, B = [$, $, P, P].map((L, N) => A[N] + L * b[N]), M = { ..._ };
        if (k && (e.mode == "x" || e.mode == "xy"))
          if (C) {
            let L = a(k, B[0], "number"), N = a(k, B[1], "number");
            M.x = L == N ? null : L < N ? [L, N] : [N, L];
          } else
            M.x = a(k, (B[0] + B[1]) / 2), typeof M.x != "string" && (M.x = null);
        if (S != null && (e.mode == "y" || e.mode == "xy"))
          if (E) {
            let L = a(S, B[2], "number"), N = a(S, B[3], "number");
            M.y = L == N ? null : L < N ? [L, N] : [N, L];
          } else
            M.y = a(S, (B[2] + B[3]) / 2), typeof M.y != "string" && (M.y = null);
        return u(M, e.mode) || (M = null), M;
      };
      return {
        move: (T) => {
          e.onChange(O(T));
        },
        up: (T) => {
          let $ = O(T);
          $ && !C && !E && $.x == _.x && $.y == _.y && ($ = null), e.onChange($);
        }
      };
    };
  }
  var d = Tbe(), p = J(d);
  te(p, "x", 0), te(p, "y", 0), ht(p, "", {}, {
    "pointer-events": "fill",
    "user-select": "none",
    cursor: "crosshair"
  }), Yo(p, (b) => i = b, () => i), Ts(p, (b, v) => mr?.(b, v), () => ({
    click: () => {
      e.onChange(null);
    },
    drag: c()
  }));
  var m = ue(p);
  {
    var y = (b) => {
      var v = Fbe(), _ = We(v);
      let k;
      var S = ue(_);
      let C;
      Ts(S, (B, M) => mr?.(B, M), () => ({ drag: f([1, 1, 1, 1]) }));
      var E = ue(S);
      {
        var A = (B) => {
          var M = Ebe(), L = We(M);
          te(L, "width", n), ht(L, "", {}, {
            cursor: "ew-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(L, (j, U) => mr?.(j, U), () => ({ drag: f([1, 0, 0, 0]) }));
          var N = ue(L);
          te(N, "width", n), ht(N, "", {}, {
            cursor: "ew-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(N, (j, U) => mr?.(j, U), () => ({ drag: f([0, 1, 0, 0]) })), ke(
            (j, U, H, G) => {
              te(L, "x", x(s)[0] - n / 2), te(L, "y", j), te(L, "height", U), te(N, "x", x(s)[1] - n / 2), te(N, "y", H), te(N, "height", G);
            },
            [
              () => Math.min(x(o)[0], x(o)[1]),
              () => Math.abs(x(o)[0] - x(o)[1]),
              () => Math.min(x(o)[0], x(o)[1]),
              () => Math.abs(x(o)[0] - x(o)[1])
            ]
          ), X(B, M);
        };
        Fe(E, (B) => {
          (e.mode == "x" || e.mode == "xy") && l(e.value.x) && B(A);
        });
      }
      var O = ue(E);
      {
        var T = (B) => {
          var M = Dbe(), L = We(M);
          te(L, "height", n), ht(L, "", {}, {
            cursor: "ns-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(L, (j, U) => mr?.(j, U), () => ({ drag: f([0, 0, 1, 0]) }));
          var N = ue(L);
          te(N, "height", n), ht(N, "", {}, {
            cursor: "ns-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(N, (j, U) => mr?.(j, U), () => ({ drag: f([0, 0, 0, 1]) })), ke(
            (j, U, H, G) => {
              te(L, "x", j), te(L, "width", U), te(L, "y", x(o)[0] - n / 2), te(N, "x", H), te(N, "width", G), te(N, "y", x(o)[1] - n / 2);
            },
            [
              () => Math.min(x(s)[0], x(s)[1]),
              () => Math.abs(x(s)[0] - x(s)[1]),
              () => Math.min(x(s)[0], x(s)[1]),
              () => Math.abs(x(s)[0] - x(s)[1])
            ]
          ), X(B, M);
        };
        Fe(O, (B) => {
          (e.mode == "y" || e.mode == "xy") && l(e.value.y) && B(T);
        });
      }
      var $ = ue(O);
      {
        var P = (B) => {
          var M = Obe(), L = We(M);
          te(L, "width", n), te(L, "height", n), ht(L, "", {}, {
            cursor: "nesw-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(L, (H, G) => mr?.(H, G), () => ({ drag: f([1, 0, 1, 0]) }));
          var N = ue(L);
          te(N, "width", n), te(N, "height", n), ht(N, "", {}, {
            cursor: "nwse-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(N, (H, G) => mr?.(H, G), () => ({ drag: f([1, 0, 0, 1]) }));
          var j = ue(N);
          te(j, "width", n), te(j, "height", n), ht(j, "", {}, {
            cursor: "nwse-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(j, (H, G) => mr?.(H, G), () => ({ drag: f([0, 1, 1, 0]) }));
          var U = ue(j);
          te(U, "width", n), te(U, "height", n), ht(U, "", {}, {
            cursor: "nesw-resize",
            stroke: "none",
            fill: "none",
            "pointer-events": "all"
          }), Ts(U, (H, G) => mr?.(H, G), () => ({ drag: f([0, 1, 0, 1]) })), ke(() => {
            te(L, "x", x(s)[0] - n / 2), te(L, "y", x(o)[0] - n / 2), te(N, "x", x(s)[0] - n / 2), te(N, "y", x(o)[1] - n / 2), te(j, "x", x(s)[1] - n / 2), te(j, "y", x(o)[0] - n / 2), te(U, "x", x(s)[1] - n / 2), te(U, "y", x(o)[1] - n / 2);
          }), X(B, M);
        };
        Fe($, (B) => {
          e.mode == "xy" && l(e.value.x) && l(e.value.y) && B(P);
        });
      }
      ke(
        (B, M, L, N, j, U, H, G) => {
          te(_, "x", B), te(_, "width", M), te(_, "y", L), te(_, "height", N), k = ht(_, "", k, {
            stroke: x(r).brushBorderBack,
            fill: "none",
            "stroke-width": 2
          }), te(S, "x", j), te(S, "width", U), te(S, "y", H), te(S, "height", G), C = ht(S, "", C, {
            stroke: x(r).brushBorder,
            fill: x(r).brushFill,
            cursor: "move"
          });
        },
        [
          () => Math.min(x(s)[0], x(s)[1]),
          () => Math.abs(x(s)[0] - x(s)[1]),
          () => Math.min(x(o)[0], x(o)[1]),
          () => Math.abs(x(o)[0] - x(o)[1]),
          () => Math.min(x(s)[0], x(s)[1]),
          () => Math.abs(x(s)[0] - x(s)[1]),
          () => Math.min(x(o)[0], x(o)[1]),
          () => Math.abs(x(o)[0] - x(o)[1])
        ]
      ), X(b, v);
    };
    Fe(m, (b) => {
      x(s) && x(o) && e.value && b(y);
    });
  }
  Q(d), ke(() => {
    te(p, "width", e.proxy.plotWidth), te(p, "height", e.proxy.plotHeight);
  }), X(t, d), st();
}
const Rbe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let E$ = (t = 21) => {
  let e = "", n = crypto.getRandomValues(new Uint8Array(t |= 0));
  for (; t--; )
    e += Rbe[n[t] & 63];
  return e;
};
var Mbe = /* @__PURE__ */ ge("<option> </option>"), Pbe = /* @__PURE__ */ ge('<select class="form-select text-center pl-[4px] pr-[16px] py-0 my-0 border-0 rounded text-sm! text-slate-500 bg-slate-100 dark:text-slate-400 dark:bg-slate-900"></select>');
function B2(t, e) {
  it(e, !0);
  let n;
  const r = E$(), i = r + "_null", s = r + "_undefined", o = (d) => d === null ? i : d === void 0 ? s : d.toString(), l = (d) => d === i ? null : d === s ? void 0 : d, a = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 20">
    <path d="M 2,8 L 5,12 L 8,8" style="stroke:${No.gray[500]};stroke-opacity:0.7;stroke-width:1.5;fill:none;stroke-linecap:round;stroke-linejoin:round" />
  </svg>`;
  var u = Pbe();
  u.__change = () => {
    e.onChange(l(n.value));
  };
  let c;
  Bt(u, 21, () => e.options, fn, (d, p) => {
    var m = Mbe(), y = J(m, !0);
    Q(m);
    var b = {};
    ke(
      (v) => {
        ut(y, x(p).label), b !== (b = v) && (m.value = (m.__value = v) ?? "");
      },
      [() => o(x(p).value)]
    ), X(d, m);
  }), Q(u), Yo(u, (d) => n = d, () => n);
  var f;
  ab(u), ke(
    (d, p) => {
      c = ht(u, "", c, d), f !== (f = p) && (u.value = (u.__value = p) ?? "", bd(u, p));
    },
    [
      () => ({
        "background-image": `url(data:image/svg+xml;base64,${btoa(a) ?? ""})`,
        "background-position": "right center"
      }),
      () => o(e.value)
    ]
  ), X(t, u), st();
}
ir(["change"]);
var Ibe = /* @__PURE__ */ ge('<span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm"> </span> <!></span>');
function Df(t, e) {
  it(e, !0);
  let n = ct(e, "value", 15);
  const r = ["linear", "log", "symlog"];
  var i = kn(), s = We(i);
  {
    var o = (l) => {
      var a = Ibe(), u = J(a), c = J(u);
      Q(u);
      var f = ue(u, 2);
      {
        let d = /* @__PURE__ */ K(() => r.map((p) => ({ value: p, label: p })));
        B2(f, {
          get options() {
            return x(d);
          },
          get value() {
            return n();
          },
          onChange: (p) => n(p)
        });
      }
      Q(a), ke(() => ut(c, `${e.label ?? ""}:`)), X(l, a);
    };
    Fe(s, (l) => {
      n() != null && n() != "band" && l(o);
    });
  }
  X(t, i), st();
}
function D$(t) {
  return t == null ? null : t instanceof Array ? t.length == 0 ? null : R.and(t).toString().trim() : typeof t == "string" ? t.trim() : typeof t == "boolean" ? R.literal(t).toString() : t.toString().trim();
}
async function O$(t, e) {
  return Array.from(await t.query(`DESCRIBE ${e}`)).map((r) => ({
    name: r.column_name,
    type: r.column_type,
    jsType: J5(r.column_type)
  }));
}
async function F$(t, e, n) {
  return (await t.query(`SELECT COUNT(DISTINCT ${R.column(n)}) AS count FROM ${e}`)).get(0).count;
}
function J5(t) {
  return Nbe.has(t) ? "number" : Bbe.has(t) ? "string" : t.match(/^(VARCHAR|TEXT)\[\d*\]$/) ? "string[]" : null;
}
const Nbe = /* @__PURE__ */ new Set([
  "REAL",
  "FLOAT4",
  "FLOAT8",
  "FLOAT",
  "DOUBLE",
  "INT",
  "TINYINT",
  "INT1",
  "SMALLINT",
  "INT2",
  "SHORT",
  "INTEGER",
  "INT4",
  "INT",
  "SIGNED",
  "INT8",
  "LONG",
  "BIGINT",
  "UTINYINT",
  "USMALLINT",
  "UINTEGER",
  "UBIGINT",
  "UHUGEINT"
]), Bbe = /* @__PURE__ */ new Set(["BOOLEAN", "DATE", "VARCHAR", "CHAR", "BPCHAR", "TEXT", "STRING"]), sp = {
  linear: { type: "linear", expr: (t) => t, forward: (t) => t, reverse: (t) => t },
  log: {
    type: "log",
    expr: (t) => R.cond(R.gt(t, 0), R.log(t), R.literal("nan")),
    forward: (t) => Math.log10(t),
    reverse: (t) => Math.pow(10, t)
  },
  symlog: {
    type: "symlog",
    expr: (t, e) => R.mul(R.sign(t), R.ln(R.add(1, R.abs(R.div(t, e))))),
    forward: (t, e) => Math.sign(t) * Math.log1p(Math.abs(t) / e),
    reverse: (t, e) => Math.sign(t) * Math.expm1(Math.abs(t)) * e
  }
};
function Lbe(t, e) {
  let n = t, r = 1 / 0;
  for (let i of e) {
    let s = Math.abs(t - i);
    s < r && (r = s, n = i);
  }
  return n;
}
function T$(t, e = {}) {
  let { min: n, max: r, median: i, count: s } = t, o = e.scale;
  o == "band" && (o = null), o == null && (o = "linear", s >= 100 && n >= 0 && i < r * 0.05 && (o = n > 0 ? "log" : "symlog")), n <= 0 && o == "log" && (r <= 0 ? (n = 1, r = 10) : n = Math.min(t.minPositive, r / 10));
  let l = e.desiredCount ?? 5;
  switch (o) {
    case "linear": {
      let a = c0().domain([n, r]).nice(l), u = a.ticks(l);
      return {
        scale: { ...sp.linear, domain: a.domain() },
        binStart: a.domain()[0],
        binSize: u[1] - u[0]
      };
    }
    case "log": {
      let a = Pg().domain([n, r]).nice(), u = Math.log10(a.domain()[0]), c = (Math.log10(a.domain()[1]) - u) / l;
      return c = Lbe(c, [0.05, 0.1, 0.2, 0.5, 1, 1.5, 2]), {
        scale: { ...sp.log, domain: a.domain() },
        binStart: u,
        binSize: c
      };
    }
    case "symlog": {
      let a = Math.max(Math.abs(n), Math.abs(r)), u = a >= 100 ? 1 : a > 0 ? a / 1e5 : 1, c = sp.symlog.forward(n, u), f = sp.symlog.forward(r, u);
      return {
        scale: { ...sp.symlog, domain: [n, r], constant: u },
        binStart: c,
        binSize: (f - c) / l
      };
    }
    default:
      throw new Error("invalid scale type");
  }
}
async function Za(t, e, n) {
  let r = (l) => t.query(l), s = (await r(R.Query.describe(R.Query.from(e).select({ field: R.column(n, e) })))).get(0)?.column_type;
  if (s == null)
    return null;
  let o = J5(s);
  if (o == "number") {
    let l = R.cast(R.column(n, e), "DOUBLE"), a = await r(
      R.Query.from(e).select({
        count: R.count(),
        min: R.min(l),
        minPositive: R.min(R.cond(R.gt(l, 0), l, R.literal(null))),
        max: R.max(l),
        mean: R.avg(l),
        median: R.median(l)
      }).where(R.isFinite(l))
    ), u = await r(
      R.Query.from(e).select({
        countNonFinite: R.count()
      }).where(R.or(R.not(R.isFinite(l)), R.isNull(l)))
    );
    return {
      table: e,
      field: n,
      quantitative: { ...a.get(0), ...u.get(0) }
    };
  } else if (o == "string") {
    let l = R.cast(R.column(n, e), "TEXT"), a = Array.from(
      await r(
        R.Query.from(e).select({ value: l, count: R.count() }).where(R.isNotNull(l)).groupby(l).orderby(R.desc(R.count())).limit(1e3)
      )
    ), u = (await r(R.Query.from(e).select({ count: R.count() }).where(R.isNull(l)))).get(0).count, { otherCount: c, numOtherLevels: f } = (await r(
      R.Query.from(e).select({ otherCount: R.count(), numOtherLevels: R.sql`COUNT(DISTINCT(${l}))` }).where(
        R.isNotNull(l),
        R.not(
          R.isIn(
            l,
            a.map((d) => R.literal(d.value))
          )
        )
      )
    )).get(0);
    return {
      table: e,
      field: n,
      nominal: {
        levels: a,
        numOtherLevels: f,
        otherCount: c,
        nullCount: u
      }
    };
  }
  return null;
}
function b0(...t) {
  let e = {}, n = {}, r = {}, i = {}, s = {};
  for (let a of t) {
    if (a.stats.quantitative) {
      let u = T$(a.stats.quantitative, {
        scale: a.scaleType,
        desiredCount: a.binCount ?? 20
      }), c = R.cast(R.column(a.stats.field), "DOUBLE"), f = u.scale.expr(c, u.scale.constant ?? 0);
      e[a.key] = u.scale.type == "log" ? R.cond(
        R.and(R.isFinite(c), R.gt(c, R.literal(0))),
        R.floor(R.mul(R.sub(f, u.binStart), 1 / u.binSize)),
        R.literal(null)
      ) : R.cond(
        R.isFinite(c),
        R.floor(R.mul(R.sub(f, u.binStart), 1 / u.binSize)),
        R.literal(null)
      );
      let d = (k) => Math.floor((u.scale.forward(k, u.scale.constant ?? 0) - u.binStart) / u.binSize), p = (k) => u.scale.reverse(k * u.binSize + u.binStart, u.scale.constant ?? 0);
      r[a.key] = (k) => k == null ? "n/a" : [p(k), p(k + 1)];
      let m = d(
        u.scale.type == "log" ? a.stats.quantitative.minPositive : a.stats.quantitative.min
      ), y = d(a.stats.quantitative.max), b = [p(m), p(y + 1)], v = a.stats.quantitative.countNonFinite > 0;
      u.scale.type == "log" && a.stats.quantitative.min < 0 && (v = !0), n[a.key] = {
        type: u.scale.type,
        constant: u.scale.constant,
        domain: b,
        specialValues: v ? ["n/a"] : []
      };
      let _ = (k) => {
        if (typeof k == "string") {
          if (k == "n/a")
            return R.or(R.not(R.isFinite(c)), R.isNull(c));
        } else if (k instanceof Array)
          if (k.length == 2 && typeof k[0] == "number") {
            let [S, C] = k;
            if (typeof S == "number" && typeof C == "number")
              return R.isBetween(c, [Math.min(S, C), Math.max(S, C)]);
          } else
            return R.or(...k.map(_));
        return R.literal(!1);
      };
      i[a.key] = _, s[a.key] = (k, S) => {
        let C = typeof k == "string" ? [1, 0] : [0, k[0]], E = typeof S == "string" ? [1, 0] : [0, S[0]];
        return C[0] != E[0] ? C[0] - E[0] : C[1] - E[1];
      };
    }
    if (a.stats.nominal) {
      let u = a.binCount ?? 15, { levels: c, nullCount: f, otherCount: d, numOtherLevels: p } = a.stats.nominal;
      c.length > u && (p += c.length - u, d = c.slice(u).reduce((S, C) => S + C.count, 0), c = c.slice(0, u));
      let m = `(${p.toLocaleString()} others)`, y = "(null)", b = R.cast(R.column(a.stats.field), "TEXT");
      e[a.key] = R.cond(
        R.isIn(
          b,
          c.map((S) => R.literal(S.value))
        ),
        b,
        R.cond(R.isNull(b), R.literal(y), R.literal(m))
      );
      let v = [...d > 0 ? [m] : [], ...f > 0 ? [y] : []];
      n[a.key] = {
        type: "band",
        domain: c.map((S) => S.value),
        specialValues: v
      }, r[a.key] = (S) => S;
      let _ = (S) => S == y ? R.isNull(b) : S == m ? R.and(
        R.not(
          R.isIn(
            b,
            c.map((C) => R.literal(C.value))
          )
        ),
        R.isNotNull(b)
      ) : R.isNotDistinct(b, R.literal(S));
      i[a.key] = (S) => S instanceof Array ? R.or(...S.map((C) => _(C))) : typeof S == "string" ? _(S) : null;
      let k = c.map((S) => S.value);
      s[a.key] = (S, C) => {
        if (typeof S == "string" && typeof C == "string") {
          let E = k.indexOf(S);
          E < 0 && (E = k.length + v.indexOf(S));
          let A = k.indexOf(C);
          return A < 0 && (A = k.length + v.indexOf(C)), E - A;
        }
        return 0;
      };
    }
  }
  function o(a) {
    let u = { ...a };
    for (let c of t)
      u[c.key] = r[c.key](u[c.key]);
    return u;
  }
  function l(a) {
    let u = [];
    for (let c of t) {
      let f = a[c.key], d = f != null ? i[c.key](f) : null;
      d && u.push(d);
    }
    return {
      value: { ...a },
      predicate: u.length > 0 ? R.and(...u) : null
    };
  }
  return { select: e, collect: o, scales: n, clause: l, order: s };
}
var $be = /* @__PURE__ */ Dt('<line></line><line></line><line></line><rect></rect><line stroke-linecap="butt"></line>', 1), zbe = /* @__PURE__ */ Dt("<!><!>", 1), jbe = /* @__PURE__ */ ge('<div class="text-slate-400 mb-1 select-none"> </div> <!> <div class="text-slate-400 mb-1 select-none text-right"> </div> <div class="flex flex-col items-end gap-1"><div class="flex flex gap-2 mt-2"><!> <!></div></div>', 1);
function qbe(t, e) {
  it(e, !0);
  const n = () => gi(s, "$colorScheme", r), [r, i] = Xs();
  let { colorScheme: s } = e.context, o = /* @__PURE__ */ K(() => e.state.brush), l = /* @__PURE__ */ K(() => vc[n()]), a = /* @__PURE__ */ Ee(null), u = /* @__PURE__ */ Ee(null), c = /* @__PURE__ */ Ee(null);
  function f(d, p, m, y, b) {
    let v = /* @__PURE__ */ Ee(null);
    Promise.all([
      Za(d, p, m),
      Za(d, p, y)
    ]).then(([C, E]) => {
      ae(v, C != null && E != null ? { x: C, y: E } : null);
    });
    let _ = /* @__PURE__ */ K(() => x(v) ? b0({
      key: "x",
      stats: x(v).x,
      scaleType: e.spec.xScaleType,
      binCount: e.spec.xBinCount
    }) : null), k = /* @__PURE__ */ K(() => x(v)?.y.quantitative ? ybe(x(v).y.quantitative, e.spec.yScaleType) : null);
    pt(() => {
      x(u) == null && x(_)?.scales.x?.type != null && ae(u, x(_)?.scales.x?.type), x(c) == null && x(k)?.type != null && ae(c, x(k)?.type);
    });
    function S(C, E, A) {
      return ia({
        coordinator: d,
        selection: E ?? void 0,
        query: (O) => {
          let T = R.column(y, p);
          return R.Query.from(p).select({
            ...C.select,
            min: R.min(T),
            max: R.max(T),
            p50: R.median(T),
            p25: R.quantile(T, 0.25),
            p75: R.quantile(T, 0.75)
          }).where(O, R.isFinite(T)).groupby(C.select.x);
        },
        queryResult: (O) => {
          A(Array.from(O).map(C.collect));
        }
      });
    }
    pt(() => {
      if (x(_) == null || x(k) == null)
        return;
      let C = x(_), E = /* @__PURE__ */ Ee(ho([])), A = S(C, b, (O) => {
        ae(E, O, !0);
      });
      return A.reset = () => {
        e.onStateChange({ brush: null });
      }, pt(() => {
        ae(a, {
          xScale: C.scales.x,
          yScale: x(k),
          items: x(E)
        });
      }), pt(() => {
        let O = {
          source: A,
          clients: /* @__PURE__ */ new Set([A]),
          ...x(o) != null ? C.clause(x(o)) : { value: null, predicate: null }
        };
        b.update(O), b.activate(O);
      }), () => {
        A.destroy(), b.update({
          source: A,
          clients: /* @__PURE__ */ new Set([A]),
          value: null,
          predicate: null
        });
      };
    });
  }
  pt(() => {
    f(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y, e.context.filter);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col",
    children: (d, p) => {
      var m = jbe(), y = We(m), b = J(y);
      Q(y);
      var v = ue(y, 2);
      {
        const B = (L, N = zt, j = zt) => {
          var U = kn(), H = We(U);
          {
            var G = (re) => {
              $d(re, {
                get width() {
                  return N();
                },
                get height() {
                  return j();
                },
                get xScale() {
                  return x(a).xScale;
                },
                get yScale() {
                  return x(a).yScale;
                },
                get colorScheme() {
                  return n();
                },
                children: (oe, ne = zt) => {
                  const ce = /* @__PURE__ */ K(() => ne().xScale), we = /* @__PURE__ */ K(() => ne().yScale), Me = /* @__PURE__ */ K(() => n() == "dark" ? "#bbbbbb" : "black");
                  var Pe = zbe(), Ce = We(Pe);
                  Bt(Ce, 17, () => x(a)?.items ?? [], fn, (De, Se) => {
                    const Ne = /* @__PURE__ */ K(() => {
                      const [Te, Oe] = x(ce).applyBand(x(Se).x);
                      return { x0: Te, x1: Oe };
                    }), Ye = /* @__PURE__ */ K(() => x(we).apply(x(Se).p50)), Ge = /* @__PURE__ */ K(() => {
                      const [Te, Oe] = x(we).applyBand([x(Se).min, x(Se).max]);
                      return { ey0: Te, ey1: Oe };
                    }), gt = /* @__PURE__ */ K(() => {
                      const [Te, Oe] = x(we).applyBand([x(Se).p25, x(Se).p75]);
                      return { by0: Te, by1: Oe };
                    }), Pt = /* @__PURE__ */ K(() => Math.min(Math.abs(x(Ne).x1 - x(Ne).x0) * 0.1, 1)), mt = /* @__PURE__ */ K(() => Math.abs(x(Ne).x1 - x(Ne).x0) / 3);
                    var Wt = $be(), un = We(Wt), Ke = ue(un), Ze = ue(Ke), It = ue(Ze), vn = ue(It);
                    ke(
                      (Te, Oe, et, kt, tn, Tn) => {
                        te(un, "y1", x(Ge).ey0), te(un, "y2", x(Ge).ey1), te(un, "x1", (x(Ne).x0 + x(Ne).x1) / 2), te(un, "x2", (x(Ne).x0 + x(Ne).x1) / 2), te(un, "stroke", x(Me)), te(Ke, "y1", x(Ge).ey0), te(Ke, "y2", x(Ge).ey0), te(Ke, "x1", (x(Ne).x0 + x(Ne).x1) / 2 - x(mt) / 2), te(Ke, "x2", (x(Ne).x0 + x(Ne).x1) / 2 + x(mt) / 2), te(Ke, "stroke", x(Me)), te(Ze, "y1", x(Ge).ey1), te(Ze, "y2", x(Ge).ey1), te(Ze, "x1", (x(Ne).x0 + x(Ne).x1) / 2 - x(mt) / 2), te(Ze, "x2", (x(Ne).x0 + x(Ne).x1) / 2 + x(mt) / 2), te(Ze, "stroke", x(Me)), te(It, "x", Te), te(It, "height", Oe), te(It, "y", et), te(It, "width", kt), te(It, "fill", x(l).markColor), te(vn, "y1", x(Ye)), te(vn, "y2", x(Ye)), te(vn, "x1", tn), te(vn, "x2", Tn), te(vn, "stroke", x(Me));
                      },
                      [
                        () => Math.min(x(Ne).x0, x(Ne).x1) + x(Pt) / 2,
                        () => Math.abs(x(gt).by0 - x(gt).by1),
                        () => Math.min(x(gt).by0, x(gt).by1),
                        () => Math.abs(x(Ne).x0 - x(Ne).x1) - x(Pt),
                        () => Math.min(x(Ne).x0, x(Ne).x1) + x(Pt) / 2,
                        () => Math.max(x(Ne).x0, x(Ne).x1) - x(Pt) / 2
                      ]
                    ), X(De, Wt);
                  });
                  var fe = ue(Ce);
                  {
                    let De = /* @__PURE__ */ K(() => x(o) ?? null);
                    N2(fe, {
                      get proxy() {
                        return ne();
                      },
                      mode: "x",
                      get value() {
                        return x(De);
                      },
                      get colorScheme() {
                        return n();
                      },
                      onChange: (Se) => {
                        e.onStateChange({ brush: Se != null && Se.x != null ? { x: Se.x } : null });
                      }
                    });
                  }
                  X(oe, Pe);
                },
                $$slots: { default: !0 }
              });
            };
            Fe(H, (re) => {
              x(a) != null && re(G);
            });
          }
          X(L, U);
        };
        let M = /* @__PURE__ */ K(() => e.height != null);
        pm(v, {
          get flexHeight() {
            return x(M);
          },
          children: B,
          $$slots: { default: !0 }
        });
      }
      var _ = ue(v, 2), k = J(_);
      Q(_);
      var S = ue(_, 2), C = J(S), E = J(C), A = () => e.spec.xScaleType ?? x(u) ?? "linear", O = (B) => {
        e.onSpecChange({ xScaleType: B });
      };
      Df(E, {
        label: "X",
        get value() {
          return A();
        },
        set value(B) {
          O(B);
        }
      });
      var T = ue(E, 2), $ = () => e.spec.yScaleType ?? x(c) ?? "linear", P = (B) => {
        e.onSpecChange({ yScaleType: B });
      };
      Df(T, {
        label: "Y",
        get value() {
          return $();
        },
        set value(B) {
          P(B);
        }
      }), Q(C), Q(S), ke(() => {
        ut(b, `â†‘ ${e.spec.data.y ?? ""}`), ut(k, `${e.spec.data.x ?? ""} â†’`);
      }), X(d, m);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
var Ube = /* @__PURE__ */ ge('<hr class="mt-1 mb-1 border-slate-300 dark:border-slate-500 border-dashed"/>'), Hbe = /* @__PURE__ */ ge('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>'), Vbe = /* @__PURE__ */ ge('<!> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), Wbe = /* @__PURE__ */ ge('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>'), Gbe = /* @__PURE__ */ ge('<!> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), Kbe = /* @__PURE__ */ ge('<!> <button class="text-left items-center flex py-0.5"><div class="w-40 flex-none overflow-hidden whitespace-nowrap text-ellipsis pr-1"><span> </span></div> <div class="flex-1 h-4 relative"><!></div> <div class="flex-none"><span><!></span></div></button>', 1), Ybe = /* @__PURE__ */ ge('<button class="py-0.5 text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden"><!></button>'), Xbe = /* @__PURE__ */ ge('<!> <div class="flex"><div class="flex-1 pl-40 mr-2 overflow-hidden"><!></div> <div class="flex"><!></div></div>', 1), Qbe = /* @__PURE__ */ ge('<div class="flex flex-col text-sm w-full select-none"><!></div>');
function Jbe(t, e) {
  it(e, !0);
  const n = () => gi(a, "$colorScheme", r), [r, i] = Xs(), s = 10, o = 100;
  let { coordinator: l, colorScheme: a } = e.context, u = /* @__PURE__ */ K(() => e.state.selection), c = /* @__PURE__ */ K(() => e.spec.expanded), f = /* @__PURE__ */ K(() => e.spec.percentage), d = /* @__PURE__ */ Ee(null), p = /* @__PURE__ */ Ee(400), m = /* @__PURE__ */ K(() => x(d)?.items.reduce((O, T) => Math.max(O, x(f) ? T.selected : T.total), 0) ?? 0), y = /* @__PURE__ */ K(() => c0([0, Math.max(1, x(m))], [0, x(p) - 250])), b = /* @__PURE__ */ K(() => (O) => O != 0 ? Math.max(1, x(y)(O)) : 0), v = /* @__PURE__ */ K(() => vc[n()]);
  function _(O, T, $, P) {
    let B = /* @__PURE__ */ Ee(null);
    Za(O, T, $).then((N) => {
      ae(B, N);
    });
    let M = /* @__PURE__ */ K(() => x(B) ? b0({
      key: "x",
      stats: x(B),
      binCount: x(c) ? o : s
    }) : null);
    function L(N, j, U) {
      return ia({
        coordinator: O,
        selection: j ?? void 0,
        query: (H) => R.Query.from(T).select({ ...N.select, count: R.count() }).where(H).groupby(N.select.x),
        queryResult: (H) => {
          U(Array.from(H).map(N.collect));
        }
      });
    }
    pt(() => {
      if (x(M) == null)
        return;
      let N = x(M), j = /* @__PURE__ */ Ee([]), U = /* @__PURE__ */ Ee([]), H = L(N, null, (se) => {
        ae(j, se);
      }), G = L(N, P, (se) => {
        ae(U, se);
      }), re = {
        reset: () => {
          e.onStateChange({ selection: null });
        }
      };
      return pt(() => {
        if (x(j).length > 0) {
          let se = (ce) => JSON.stringify(ce), oe = new Map(x(j).map(({ x: ce, count: we }) => [se(ce), we])), ne = new Map(x(U).map(({ x: ce, count: we }) => [se(ce), we]));
          if (x(j).every((ce) => typeof ce.x == "string")) {
            let ce = N.scales.x.specialValues ?? [], we = ce.filter((fe) => fe != "(null)").length > 0, Me = [...N.scales.x.domain, ...ce].map((fe) => ({
              x: fe,
              total: oe.get(se(fe)) ?? 0,
              selected: ne.get(se(fe)) ?? 0
            })), Pe = Me.reduce((fe, De) => fe + De.total, 0), Ce = Me.reduce((fe, De) => fe + De.selected, 0);
            ae(d, {
              items: Me,
              sumTotal: Pe,
              sumSelected: Ce,
              firstSpecialIndex: N.scales.x.domain.length,
              hasOther: we
            });
          } else {
            let ce = Array.from(oe.keys()).map((Ce) => JSON.parse(Ce));
            ce = ce.sort((Ce, fe) => {
              let De = typeof Ce == "string" ? 1 / 0 : Ce[0], Se = typeof fe == "string" ? 1 / 0 : fe[0];
              return De - Se;
            });
            let we = ce.map((Ce) => ({
              x: Ce,
              total: oe.get(se(Ce)) ?? 0,
              selected: ne.get(se(Ce)) ?? 0
            })), Me = we.reduce((Ce, fe) => Ce + fe.total, 0), Pe = we.reduce((Ce, fe) => Ce + fe.selected, 0);
            ae(d, {
              items: we,
              sumTotal: Me,
              sumSelected: Pe,
              firstSpecialIndex: ce.findIndex((Ce) => typeof Ce == "string"),
              hasOther: !1
            });
          }
        }
      }), pt(() => {
        let se = {
          source: re,
          clients: /* @__PURE__ */ new Set([G]),
          ...x(u) != null ? N.clause({ x: x(u) }) : { value: null, predicate: null }
        };
        P.update(se), P.activate(se);
      }), () => {
        H.destroy(), G.destroy(), P.update({
          source: re,
          clients: /* @__PURE__ */ new Set([G]),
          value: null,
          predicate: null
        });
      };
    });
  }
  pt(() => {
    _(l, e.context.table, e.spec.data.field, e.context.filter);
  });
  const k = (O, T) => JSON.stringify(O) == JSON.stringify(T);
  function S(O, T) {
    if (x(u) == null || x(u).length == 0)
      e.onStateChange({ selection: [O] });
    else {
      let $ = x(u).findIndex((P) => k(P, O)) >= 0;
      T ? $ ? e.onStateChange({ selection: x(u).filter((P) => !k(P, O)) }) : e.onStateChange({ selection: [...x(u), O] }) : $ ? e.onStateChange({ selection: null }) : e.onStateChange({ selection: [O] });
    }
  }
  const C = su(".6");
  function E(O) {
    return typeof O == "string" ? O : "[" + C(O[0]) + ", " + C(O[1]) + ")";
  }
  function A(O, T) {
    return T == 0 ? "-%" : (O / T * 100).toFixed(1) + "%";
  }
  yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (O, T) => {
      var $ = Qbe(), P = J($);
      {
        var B = (M) => {
          var L = Xbe(), N = We(L);
          Bt(N, 17, () => x(d).items, fn, (oe, ne, ce) => {
            const we = /* @__PURE__ */ K(() => x(u) == null || x(u).length == 0 || x(u).findIndex((Oe) => k(Oe, x(ne).x)) >= 0), Me = /* @__PURE__ */ K(() => !x(d).items.every((Oe) => Oe.total == Oe.selected));
            var Pe = Kbe(), Ce = We(Pe);
            {
              var fe = (Oe) => {
                var et = Ube();
                X(Oe, et);
              };
              Fe(Ce, (Oe) => {
                ce == x(d).firstSpecialIndex && Oe(fe);
              });
            }
            var De = ue(Ce, 2);
            De.__click = (Oe) => S(x(ne).x, Oe.shiftKey);
            var Se = J(De), Ne = J(Se);
            let Ye;
            var Ge = J(Ne, !0);
            Q(Ne), Q(Se);
            var gt = ue(Se, 2), Pt = J(gt);
            {
              var mt = (Oe) => {
                var et = Vbe(), kt = We(et);
                {
                  var tn = (Je) => {
                    var gn = Hbe();
                    let tr;
                    ke((xi) => tr = ht(gn, "", tr, xi), [
                      () => ({
                        background: x(v).markColorFade,
                        width: `${x(b)(x(ne).total) ?? ""}px`
                      })
                    ]), X(Je, gn);
                  };
                  Fe(kt, (Je) => {
                    x(f) || Je(tn);
                  });
                }
                var Tn = ue(kt, 2);
                let Gt;
                ke((Je) => Gt = ht(Tn, "", Gt, Je), [
                  () => ({
                    background: x(v).markColor,
                    width: `${x(b)(x(ne).selected) ?? ""}px`
                  })
                ]), X(Oe, et);
              }, Wt = (Oe) => {
                var et = Gbe(), kt = We(et);
                {
                  var tn = (Je) => {
                    var gn = Wbe();
                    let tr;
                    ke((xi) => tr = ht(gn, "", tr, xi), [
                      () => ({
                        background: x(v).markColorGrayFade,
                        width: `${x(b)(x(ne).total) ?? ""}px`
                      })
                    ]), X(Je, gn);
                  };
                  Fe(kt, (Je) => {
                    x(f) || Je(tn);
                  });
                }
                var Tn = ue(kt, 2);
                let Gt;
                ke((Je) => Gt = ht(Tn, "", Gt, Je), [
                  () => ({
                    background: x(v).markColorGray,
                    width: `${x(b)(x(ne).selected) ?? ""}px`
                  })
                ]), X(Oe, et);
              };
              Fe(Pt, (Oe) => {
                x(we) ? Oe(mt) : Oe(Wt, !1);
              });
            }
            Q(gt);
            var un = ue(gt, 2), Ke = J(un);
            let Ze;
            var It = J(Ke);
            {
              var vn = (Oe) => {
                var et = kn(), kt = We(et);
                {
                  var tn = (Gt) => {
                    var Je = Ms();
                    ke((gn) => ut(Je, gn), [
                      () => A(x(ne).selected, x(d).sumSelected)
                    ]), X(Gt, Je);
                  }, Tn = (Gt) => {
                    var Je = Ms();
                    ke((gn) => ut(Je, gn), [
                      () => x(ne).selected.toLocaleString() + " / " + x(ne).total.toLocaleString()
                    ]), X(Gt, Je);
                  };
                  Fe(kt, (Gt) => {
                    x(f) ? Gt(tn) : Gt(Tn, !1);
                  });
                }
                X(Oe, et);
              }, Te = (Oe) => {
                var et = kn(), kt = We(et);
                {
                  var tn = (Gt) => {
                    var Je = Ms();
                    ke((gn) => ut(Je, gn), [
                      () => A(x(ne).total, x(d).sumTotal)
                    ]), X(Gt, Je);
                  }, Tn = (Gt) => {
                    var Je = Ms();
                    ke((gn) => ut(Je, gn), [() => x(ne).total.toLocaleString()]), X(Gt, Je);
                  };
                  Fe(
                    kt,
                    (Gt) => {
                      x(f) ? Gt(tn) : Gt(Tn, !1);
                    },
                    !0
                  );
                }
                X(Oe, et);
              };
              Fe(It, (Oe) => {
                x(Me) ? Oe(vn) : Oe(Te, !1);
              });
            }
            Q(Ke), Q(un), Q(De), ke(
              (Oe, et) => {
                te(De, "title", x(ne).x), Ye = er(Ne, 1, "", null, Ye, {
                  "text-gray-400": !x(we),
                  "dark:text-gray-400": !x(we)
                }), ut(Ge, Oe), Ze = er(Ke, 1, "text-slate-400 dark:text-slate-500", null, Ze, {
                  "!text-gray-200": !x(we),
                  "dark:!text-gray-600": !x(we)
                }), te(Ke, "title", et);
              },
              [
                () => E(x(ne).x),
                () => x(Me) ? `${x(ne).selected.toLocaleString()} / ${x(ne).total.toLocaleString()} (${A(x(ne).selected, x(ne).total)})
${A(x(ne).selected, x(d).sumSelected)} of selection` : `${x(ne).total.toLocaleString()}
${A(x(ne).total, x(d).sumTotal)} of all rows`
              ]
            ), X(oe, Pe);
          });
          var j = ue(N, 2), U = J(j), H = J(U);
          {
            var G = (oe) => {
              var ne = Ybe();
              ne.__click = () => {
                x(c) == !0 ? (e.onSpecChange({ expanded: !1 }), e.onStateChange({ selection: null })) : e.onSpecChange({ expanded: !0 });
              };
              var ce = J(ne);
              {
                var we = (Pe) => {
                  var Ce = Ms();
                  Ce.nodeValue = "â†‘ Show up to 10 values", X(Pe, Ce);
                }, Me = (Pe) => {
                  var Ce = Ms();
                  Ce.nodeValue = "â†“ Show up to 100 values", X(Pe, Ce);
                };
                Fe(ce, (Pe) => {
                  x(c) ? Pe(we) : Pe(Me, !1);
                });
              }
              Q(ne), X(oe, ne);
            };
            Fe(H, (oe) => {
              (x(c) || x(d).hasOther) && oe(G);
            });
          }
          Q(U);
          var re = ue(U, 2), se = J(re);
          {
            let oe = /* @__PURE__ */ K(() => x(f)?.toString() ?? "false");
            B2(se, {
              options: [
                { value: "true", label: "%" },
                { value: "false", label: "#/#" }
              ],
              get value() {
                return x(oe);
              },
              onChange: (ne) => e.onSpecChange({ percentage: ne == "true" })
            });
          }
          Q(re), Q(j), X(M, L);
        };
        Fe(P, (M) => {
          x(d) && M(B);
        });
      }
      Q($), Ko($, "clientWidth", (M) => ae(p, M)), X(O, $);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
ir(["click"]);
async function Zbe(t, e, n, r) {
  let i = R.column(n, e), s = await t.query(R.Query.from(R.Query.from(e).select({ value: R.sql`UNNEST(${i})` })).select({ value: "value", count: R.count() }).groupby("value").orderby(R.desc("count")).limit(r + 1)), o = Array.from(s);
  return {
    values: o.slice(0, r),
    hasOther: o.length > r
  };
}
function eve(t, e) {
  return R.or(...e.map((n) => R.sql`${R.literal(n)} IN ${R.column(t)}`));
}
var tve = /* @__PURE__ */ ge('<hr class="mt-1 mb-1 border-slate-300 dark:border-slate-500 border-dashed"/>'), nve = /* @__PURE__ */ ge('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), rve = /* @__PURE__ */ ge('<div class="absolute left-0 top-0 bottom-0 rounded-sm"></div> <div class="absolute left-0 top-0 bottom-0 rounded-sm"></div>', 1), ive = /* @__PURE__ */ ge('<!> <button class="text-left items-center flex py-0.5"><div class="w-40 flex-none overflow-hidden whitespace-nowrap text-ellipsis pr-1"><span> </span></div> <div class="flex-1 h-4 relative"><!></div> <div class="flex-none"><span><!></span></div></button>', 1), sve = /* @__PURE__ */ ge('<button class="py-0.5 text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden"><!></button>'), ove = /* @__PURE__ */ ge('<!> <div class="flex"><div class="flex-1 pl-40 mr-2 overflow-hidden"><!></div></div>', 1), lve = /* @__PURE__ */ ge('<div class="flex flex-col text-sm w-full select-none"><!></div>');
function ave(t, e) {
  it(e, !0);
  const n = () => gi(l, "$colorScheme", r), [r, i] = Xs(), s = 10, o = 100;
  let l = e.context.colorScheme, a = /* @__PURE__ */ K(() => e.state.selection), u = /* @__PURE__ */ Ee(null), c = /* @__PURE__ */ Ee(400), f = /* @__PURE__ */ K(() => x(u)?.items.reduce((C, E) => Math.max(C, E.total), 0) ?? 0), d = /* @__PURE__ */ K(() => c0([0, Math.max(1, x(f))], [0, x(c) - 250])), p = /* @__PURE__ */ K(() => (C) => C != 0 ? Math.max(1, x(d)(C)) : 0), m = /* @__PURE__ */ K(() => vc[n()]);
  function y(C, E, A, O, T) {
    let $ = /* @__PURE__ */ Ee(null);
    Zbe(C, E, A, T).then((B) => {
      ae($, B);
    });
    function P(B, M, L) {
      return ia({
        coordinator: C,
        selection: B ?? void 0,
        query: (N) => {
          let j = R.column(A, E);
          return R.Query.from(R.Query.from(E).select({ value: R.sql`UNNEST(${j})` }).where(N)).select({ x: "value", count: R.count() }).where(R.isIn("value", M.map((U) => R.literal(U)))).groupby("value").orderby(R.desc("count"));
        },
        queryResult: (N) => {
          L(Array.from(N));
        }
      });
    }
    pt(() => {
      if (x($) == null)
        return;
      let B = x($).values.map((G) => G.value), M = x($).hasOther, L = /* @__PURE__ */ Ee([]), N = /* @__PURE__ */ Ee([]), j = P(null, B, (G) => {
        ae(L, G);
      }), U = P(O, B, (G) => {
        ae(N, G);
      }), H = {
        reset: () => {
          e.onStateChange({ selection: null });
        }
      };
      return pt(() => {
        if (x(L).length > 0) {
          let G = (ne) => JSON.stringify(ne), re = new Map(x(L).map(({ x: ne, count: ce }) => [G(ne), ce])), se = new Map(x(N).map(({ x: ne, count: ce }) => [G(ne), ce])), oe = B.map((ne) => ({
            x: ne,
            total: re.get(G(ne)) ?? 0,
            selected: se.get(G(ne)) ?? 0
          }));
          ae(u, { items: oe, firstSpecialIndex: B.length, hasOther: M });
        }
      }), pt(() => {
        let G = {
          source: H,
          clients: /* @__PURE__ */ new Set([U]),
          ...x(a) != null ? {
            value: x(a),
            predicate: eve(A, x(a))
          } : { value: null, predicate: null }
        };
        O.update(G), O.activate(G);
      }), () => {
        j.destroy(), U.destroy(), O.update({
          source: H,
          clients: /* @__PURE__ */ new Set([U]),
          value: null,
          predicate: null
        });
      };
    });
  }
  pt(() => {
    y(e.context.coordinator, e.context.table, e.spec.data.field, e.context.filter, e.spec.expanded ? o : s);
  });
  const b = (C, E) => JSON.stringify(C) == JSON.stringify(E);
  function v(C, E) {
    if (x(a) == null || x(a).length == 0)
      e.onStateChange({ selection: [C] });
    else {
      let A = x(a).findIndex((O) => b(O, C)) >= 0;
      E ? A ? e.onStateChange({ selection: x(a).filter((O) => !b(O, C)) }) : e.onStateChange({ selection: [...x(a), C] }) : A ? e.onStateChange({ selection: null }) : e.onStateChange({ selection: [C] });
    }
  }
  const _ = su(".6");
  function k(C) {
    return typeof C == "string" ? C : "[" + _(C[0]) + ", " + _(C[1]) + ")";
  }
  function S(C, E) {
    return E == 0 ? "-%" : (C / E * 100).toFixed(1) + "%";
  }
  yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (C, E) => {
      var A = lve(), O = J(A);
      {
        var T = ($) => {
          var P = ove(), B = We(P);
          Bt(B, 17, () => x(u).items, fn, (U, H, G) => {
            const re = /* @__PURE__ */ K(() => x(a) == null || x(a).length == 0 || x(a).findIndex((Ke) => b(Ke, x(H).x)) >= 0), se = /* @__PURE__ */ K(() => !x(u).items.every((Ke) => Ke.total == Ke.selected));
            var oe = ive(), ne = We(oe);
            {
              var ce = (Ke) => {
                var Ze = tve();
                X(Ke, Ze);
              };
              Fe(ne, (Ke) => {
                G == x(u).firstSpecialIndex && Ke(ce);
              });
            }
            var we = ue(ne, 2);
            we.__click = (Ke) => v(x(H).x, Ke.shiftKey);
            var Me = J(we), Pe = J(Me);
            let Ce;
            var fe = J(Pe, !0);
            Q(Pe), Q(Me);
            var De = ue(Me, 2), Se = J(De);
            {
              var Ne = (Ke) => {
                var Ze = nve(), It = We(Ze);
                let vn;
                var Te = ue(It, 2);
                let Oe;
                ke(
                  (et, kt) => {
                    vn = ht(It, "", vn, et), Oe = ht(Te, "", Oe, kt);
                  },
                  [
                    () => ({
                      background: x(m).markColorFade,
                      width: `${x(p)(x(H).total) ?? ""}px`
                    }),
                    () => ({
                      background: x(m).markColor,
                      width: `${x(p)(x(H).selected) ?? ""}px`
                    })
                  ]
                ), X(Ke, Ze);
              }, Ye = (Ke) => {
                var Ze = rve(), It = We(Ze);
                let vn;
                var Te = ue(It, 2);
                let Oe;
                ke(
                  (et, kt) => {
                    vn = ht(It, "", vn, et), Oe = ht(Te, "", Oe, kt);
                  },
                  [
                    () => ({
                      background: x(m).markColorGrayFade,
                      width: `${x(p)(x(H).total) ?? ""}px`
                    }),
                    () => ({
                      background: x(m).markColorGray,
                      width: `${x(p)(x(H).selected) ?? ""}px`
                    })
                  ]
                ), X(Ke, Ze);
              };
              Fe(Se, (Ke) => {
                x(re) ? Ke(Ne) : Ke(Ye, !1);
              });
            }
            Q(De);
            var Ge = ue(De, 2), gt = J(Ge);
            let Pt;
            var mt = J(gt);
            {
              var Wt = (Ke) => {
                var Ze = Ms();
                ke((It) => ut(Ze, It), [
                  () => x(H).selected.toLocaleString() + " / " + x(H).total.toLocaleString()
                ]), X(Ke, Ze);
              }, un = (Ke) => {
                var Ze = Ms();
                ke((It) => ut(Ze, It), [() => x(H).total.toLocaleString()]), X(Ke, Ze);
              };
              Fe(mt, (Ke) => {
                x(se) ? Ke(Wt) : Ke(un, !1);
              });
            }
            Q(gt), Q(Ge), Q(we), ke(
              (Ke, Ze) => {
                te(we, "title", x(H).x), Ce = er(Pe, 1, "", null, Ce, {
                  "text-gray-400": !x(re),
                  "dark:text-gray-400": !x(re)
                }), ut(fe, Ke), Pt = er(gt, 1, "text-slate-400 dark:text-slate-500", null, Pt, {
                  "!text-gray-200": !x(re),
                  "dark:!text-gray-600": !x(re)
                }), te(gt, "title", Ze);
              },
              [
                () => k(x(H).x),
                () => x(se) ? `${x(H).total.toLocaleString()} rows contain "${x(H).x}"; ${x(H).selected.toLocaleString()} (${S(x(H).selected, x(H).total)}) in selection` : `${x(H).total.toLocaleString()} rows contain "${x(H).x}"`
              ]
            ), X(U, oe);
          });
          var M = ue(B, 2), L = J(M), N = J(L);
          {
            var j = (U) => {
              var H = sve();
              H.__click = () => {
                let oe = !e.spec.expanded;
                e.onSpecChange({ expanded: oe }), oe == !1 && e.onStateChange({ selection: null });
              };
              var G = J(H);
              {
                var re = (oe) => {
                  var ne = Ms();
                  ne.nodeValue = "â†‘ Show up to 10 values", X(oe, ne);
                }, se = (oe) => {
                  var ne = Ms();
                  ne.nodeValue = "â†“ Show up to 100 values", X(oe, ne);
                };
                Fe(G, (oe) => {
                  e.spec.expanded ? oe(re) : oe(se, !1);
                });
              }
              Q(H), X(U, H);
            };
            Fe(N, (U) => {
              (e.spec.expanded || x(u).hasOther) && U(j);
            });
          }
          Q(L), Q(M), X($, P);
        };
        Fe(O, ($) => {
          x(u) && $(T);
        });
      }
      Q(A), Ko(A, "clientWidth", ($) => ae(c, $)), X(C, A);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
ir(["click"]);
var uve = /* @__PURE__ */ Dt("<rect></rect>"), cve = /* @__PURE__ */ Dt("<rect></rect>"), fve = /* @__PURE__ */ Dt("<!><!><!>", 1), hve = /* @__PURE__ */ ge('<div class="flex gap items-center text-sm"><span class="flex-1 text-slate-400 dark:text-slate-500"><!></span> <!></div>'), dve = /* @__PURE__ */ ge("<!> <!>", 1);
function pve(t, e) {
  it(e, !0);
  const n = () => gi(o, "$colorScheme", r), [r, i] = Xs();
  let { coordinator: s, colorScheme: o } = e.context, l = /* @__PURE__ */ K(() => e.state.brush), a = /* @__PURE__ */ K(() => vc[n()]), u = /* @__PURE__ */ Ee(null), c = /* @__PURE__ */ Ee(null);
  function f(d, p, m, y) {
    let b = /* @__PURE__ */ Ee(null);
    Za(d, p, m).then((k) => {
      ae(b, k);
    });
    let v = /* @__PURE__ */ K(() => x(b) ? b0({
      key: "x",
      stats: x(b),
      scaleType: e.spec.xScaleType,
      binCount: e.spec.binCount
    }) : null);
    pt(() => {
      x(c) == null && x(v)?.scales.x?.type != null && ae(c, x(v)?.scales.x?.type, !0);
    });
    function _(k, S, C) {
      return ia({
        coordinator: d,
        selection: S ?? void 0,
        query: (E) => R.Query.from(p).select({ ...k.select, count: R.count() }).where(E).groupby(k.select.x),
        queryResult: (E) => {
          C(Array.from(E).map(k.collect));
        }
      });
    }
    pt(() => {
      if (x(v) == null)
        return;
      let k = x(v), S = /* @__PURE__ */ Ee(ho([])), C = /* @__PURE__ */ Ee(ho([])), E = _(k, null, (T) => {
        ae(S, T, !0);
      }), A = _(k, y, (T) => {
        ae(C, T, !0);
      });
      pt(() => {
        x(S).length > 0 && ae(u, {
          xScale: k.scales.x,
          allItems: x(S),
          filteredItems: x(C)
        });
      });
      let O = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return pt(() => {
        let T = {
          source: O,
          clients: /* @__PURE__ */ new Set([A]),
          ...x(l) != null ? k.clause(x(l)) : { value: null, predicate: null }
        };
        y.update(T), y.activate(T);
      }), () => {
        E.destroy(), A.destroy(), y.update({
          source: O,
          clients: /* @__PURE__ */ new Set([A]),
          value: null,
          predicate: null
        });
      };
    });
  }
  pt(() => {
    f(s, e.context.table, e.spec.data.field, e.context.filter);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (d, p) => {
      var m = dve(), y = We(m);
      {
        const _ = (S, C = zt, E = zt) => {
          var A = kn(), O = We(A);
          {
            var T = ($) => {
              const P = /* @__PURE__ */ K(() => x(u).allItems.reduce((B, M) => Math.max(B, M.count), 1));
              {
                const B = (L, N = zt) => {
                  const j = /* @__PURE__ */ K(() => N().xScale), U = /* @__PURE__ */ K(() => N().yScale);
                  var H = fve(), G = We(H);
                  Bt(G, 17, () => x(u)?.allItems ?? [], fn, (oe, ne) => {
                    const ce = /* @__PURE__ */ K(() => {
                      const [Ce, fe] = x(j).applyBand(x(ne).x);
                      return { x0: Ce, x1: fe };
                    }), we = /* @__PURE__ */ K(() => {
                      const [Ce, fe] = x(U).applyBand([0, x(ne).count]);
                      return { y0: Ce, y1: fe };
                    }), Me = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ce).x1 - x(ce).x0) * 0.1, 1));
                    var Pe = uve();
                    ke(
                      (Ce, fe, De, Se) => {
                        te(Pe, "x", Ce), te(Pe, "y", fe), te(Pe, "width", De), te(Pe, "height", Se), te(Pe, "fill", x(a).markColorFade);
                      },
                      [
                        () => Math.min(x(ce).x0, x(ce).x1) + x(Me) / 2,
                        () => Math.min(x(we).y0, x(we).y1),
                        () => Math.abs(x(ce).x0 - x(ce).x1) - x(Me),
                        () => Math.abs(x(we).y0 - x(we).y1)
                      ]
                    ), X(oe, Pe);
                  });
                  var re = ue(G);
                  Bt(re, 17, () => x(u)?.filteredItems ?? [], fn, (oe, ne) => {
                    const ce = /* @__PURE__ */ K(() => {
                      const [Ce, fe] = x(j).applyBand(x(ne).x);
                      return { x0: Ce, x1: fe };
                    }), we = /* @__PURE__ */ K(() => {
                      const [Ce, fe] = x(U).applyBand([0, x(ne).count]);
                      return { y0: Ce, y1: fe };
                    }), Me = /* @__PURE__ */ K(() => Math.min(Math.abs(x(ce).x1 - x(ce).x0) * 0.1, 1));
                    var Pe = cve();
                    ke(
                      (Ce, fe, De, Se) => {
                        te(Pe, "x", Ce), te(Pe, "height", fe), te(Pe, "y", De), te(Pe, "width", Se), te(Pe, "fill", x(a).markColor);
                      },
                      [
                        () => Math.min(x(ce).x0, x(ce).x1) + x(Me) / 2,
                        () => Math.abs(x(we).y0 - x(we).y1),
                        () => Math.min(x(we).y0, x(we).y1),
                        () => Math.abs(x(ce).x0 - x(ce).x1) - x(Me)
                      ]
                    ), X(oe, Pe);
                  });
                  var se = ue(re);
                  {
                    let oe = /* @__PURE__ */ K(() => x(l) ?? null);
                    N2(se, {
                      get proxy() {
                        return N();
                      },
                      mode: "x",
                      get value() {
                        return x(oe);
                      },
                      get colorScheme() {
                        return n();
                      },
                      onChange: (ne) => {
                        e.onStateChange({ brush: ne != null && ne.x != null ? { x: ne.x } : null });
                      }
                    });
                  }
                  X(L, H);
                };
                let M = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(P)] }));
                $d($, {
                  get width() {
                    return C();
                  },
                  get height() {
                    return E();
                  },
                  get xScale() {
                    return x(u).xScale;
                  },
                  get yScale() {
                    return x(M);
                  },
                  get colorScheme() {
                    return n();
                  },
                  children: B,
                  $$slots: { default: !0 }
                });
              }
            };
            Fe(O, ($) => {
              x(u) != null && $(T);
            });
          }
          X(S, A);
        };
        let k = /* @__PURE__ */ K(() => e.height != null);
        pm(y, {
          get flexHeight() {
            return x(k);
          },
          children: _,
          $$slots: { default: !0 }
        });
      }
      var b = ue(y, 2);
      {
        var v = (_) => {
          var k = hve(), S = J(k), C = J(S);
          {
            var E = ($) => {
              var P = kn(), B = We(P);
              {
                var M = (N) => {
                  var j = Ms();
                  ke(() => ut(j, `[${x(l).x ?? ""}]`)), X(N, j);
                }, L = (N) => {
                  const j = /* @__PURE__ */ K(() => su(".4"));
                  var U = Ms();
                  ke((H, G) => ut(U, `[${H ?? ""}, ${G ?? ""}]`), [
                    () => x(j)(x(l).x[0]),
                    () => x(j)(x(l).x[1])
                  ]), X(N, U);
                };
                Fe(B, (N) => {
                  typeof x(l).x == "string" ? N(M) : N(L, !1);
                });
              }
              X($, P);
            };
            Fe(C, ($) => {
              x(l) && $(E);
            });
          }
          Q(S);
          var A = ue(S, 2), O = () => e.spec.xScaleType ?? x(c) ?? "linear", T = ($) => {
            e.onSpecChange({ xScaleType: $ });
          };
          Df(A, {
            label: "X",
            get value() {
              return O();
            },
            set value($) {
              T($);
            }
          }), Q(k), X(_, k);
        };
        Fe(b, (_) => {
          x(u)?.xScale.type != "band" && _(v);
        });
      }
      X(d, m);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
var gve = /* @__PURE__ */ Dt('<image preserveAspectRatio="none"></image>');
function mve(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ K(() => e.proxy.xScale && e.xDomain ? e.proxy.xScale.apply(e.xDomain[0]) : 0), r = /* @__PURE__ */ K(() => e.proxy.xScale && e.xDomain ? e.proxy.xScale.apply(e.xDomain[1]) : e.proxy.plotWidth), i = /* @__PURE__ */ K(() => e.proxy.yScale && e.yDomain ? e.proxy.yScale.apply(e.yDomain[0]) : 0), s = /* @__PURE__ */ K(() => e.proxy.yScale && e.yDomain ? e.proxy.yScale.apply(e.yDomain[1]) : e.proxy.plotHeight), o = /* @__PURE__ */ Ee(null), l = document.createElement("canvas");
  pt(() => {
    l.width = e.rasterWidth, l.height = e.rasterHeight;
    let u = l.getContext("2d", { colorSpace: "srgb", willReadFrequently: !0 });
    u.clearRect(0, 0, l.width, l.height);
    let c = u.getImageData(0, 0, l.width, l.height), f = 0;
    for (let d = 0; d < l.height; d++)
      for (let p = 0; p < l.width; p++) {
        let m = (p + 0.5) / l.width * (x(r) - x(n)) + x(n), y = (d + 0.5) / l.height * (x(s) - x(i)) + x(i), b = e.proxy.xScale?.invert(m) ?? 0, v = e.proxy.yScale?.invert(y) ?? 0, { r: _, g: k, b: S, opacity: C } = Mg(e.color(b, v));
        c.data[f++] = _, c.data[f++] = k, c.data[f++] = S, c.data[f++] = C * 255;
      }
    u.putImageData(c, 0, 0), ae(o, l.toDataURL("image/png"), !0);
  });
  var a = gve();
  ke(
    (u, c, f, d) => {
      te(a, "x", u), te(a, "y", c), te(a, "width", f), te(a, "height", d), te(a, "href", x(o));
    },
    [
      () => Math.min(x(n), x(r)),
      () => Math.min(x(i), x(s)),
      () => Math.abs(x(n) - x(r)),
      () => Math.abs(x(i) - x(s))
    ]
  ), X(t, a), st();
}
var yve = /* @__PURE__ */ Dt("<rect></rect>"), bve = /* @__PURE__ */ Dt("<rect></rect><!>", 1), vve = /* @__PURE__ */ ge('<div class="text-slate-400 mb-1 select-none"> </div> <!> <div class="text-slate-400 mb-1 select-none text-right"> </div> <div class="flex gap items-center text-sm"><span class="flex-1 text-slate-400 dark:text-slate-500"><!></span> <span class="flex flex-col items-end gap-1"><span class="flex gap-2"><!> <!></span> <span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm">Normalize:</span> <!></span></span></div>', 1);
function xve(t, e) {
  it(e, !0);
  const n = () => gi(s, "$colorScheme", r), [r, i] = Xs();
  let { colorScheme: s } = e.context, o = /* @__PURE__ */ K(() => e.state.brush), l = /* @__PURE__ */ Ee(null), a = /* @__PURE__ */ K(() => x(l)?.items.reduce((y, b) => Math.max(y, b.value), 1) ?? 1);
  const u = 0.07, c = (y) => y > 0 ? u + (1 - u) * y : 0;
  let f = /* @__PURE__ */ K(() => n() == "dark" ? (y) => sL(c(y / x(a))) : (y) => Bge(c(y / x(a)))), d = /* @__PURE__ */ Ee(null), p = /* @__PURE__ */ Ee(null);
  function m(y, b, v, _, k) {
    let S = /* @__PURE__ */ Ee(null);
    Promise.all([
      Za(y, b, v),
      Za(y, b, _)
    ]).then(([A, O]) => {
      ae(S, A != null && O != null ? { x: A, y: O } : null);
    });
    let C = /* @__PURE__ */ K(() => x(S) ? b0(
      {
        key: "x",
        stats: x(S).x,
        scaleType: e.spec.xScaleType,
        binCount: e.spec.xBinCount
      },
      {
        key: "y",
        stats: x(S).y,
        scaleType: e.spec.yScaleType,
        binCount: e.spec.yBinCount
      }
    ) : null);
    pt(() => {
      x(d) == null && x(C)?.scales.x?.type != null && ae(d, x(C)?.scales.x?.type), x(p) == null && x(C)?.scales.y?.type != null && ae(p, x(C)?.scales.y?.type);
    });
    function E(A, O, T) {
      return ia({
        coordinator: y,
        selection: O ?? void 0,
        query: ($) => R.Query.from(R.Query.from(b).select({ ...A.select, count: R.count() }).where($).groupby(A.select.x, A.select.y)).select({
          x: "x",
          y: "y",
          count: "count",
          normalizeByX: R.sql`count / (SUM(count) OVER (PARTITION BY x))`,
          normalizeByY: R.sql`count / (SUM(count) OVER (PARTITION BY y))`
        }),
        queryResult: ($) => {
          T(Array.from($).map(A.collect));
        }
      });
    }
    pt(() => {
      if (x(C) == null)
        return;
      let A = x(C), O = /* @__PURE__ */ Ee(null), T = E(A, k, (P) => {
        ae(O, P);
      }), $ = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return pt(() => {
        x(O) != null && ae(l, {
          xScale: A.scales.x,
          yScale: A.scales.y,
          items: x(O).map((P) => ({
            x: P.x,
            y: P.y,
            value: e.spec.normalization == "x" ? P.normalizeByX : e.spec.normalization == "y" ? P.normalizeByY : P.count
          }))
        });
      }), pt(() => {
        let P = {
          source: $,
          clients: /* @__PURE__ */ new Set([T]),
          ...x(o) != null ? A.clause(x(o)) : { value: null, predicate: null }
        };
        k.update(P), k.activate(P);
      }), () => {
        T.destroy(), k.update({
          source: $,
          clients: /* @__PURE__ */ new Set([T]),
          value: null,
          predicate: null
        });
      };
    });
  }
  pt(() => {
    m(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y, e.context.filter);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col",
    children: (y, b) => {
      var v = vve(), _ = We(v), k = J(_);
      Q(_);
      var S = ue(_, 2);
      {
        const re = (ne, ce = zt, we = zt) => {
          var Me = kn(), Pe = We(Me);
          {
            var Ce = (fe) => {
              $d(fe, {
                get width() {
                  return ce();
                },
                get height() {
                  return we();
                },
                get xScale() {
                  return x(l).xScale;
                },
                get yScale() {
                  return x(l).yScale;
                },
                get colorScheme() {
                  return n();
                },
                childrenBelow: (Ne, Ye = zt) => {
                  const Ge = /* @__PURE__ */ K(() => Ye().xScale), gt = /* @__PURE__ */ K(() => Ye().yScale);
                  var Pt = bve(), mt = We(Pt);
                  te(mt, "x", 0), te(mt, "y", 0);
                  var Wt = ue(mt);
                  Bt(Wt, 17, () => x(l)?.items ?? [], fn, (un, Ke) => {
                    const Ze = /* @__PURE__ */ K(() => {
                      const [Oe, et] = x(Ge).applyBand(x(Ke).x);
                      return { x0: Oe, x1: et };
                    }), It = /* @__PURE__ */ K(() => {
                      const [Oe, et] = x(gt).applyBand(x(Ke).y);
                      return { y0: Oe, y1: et };
                    }), vn = /* @__PURE__ */ K(() => 0);
                    var Te = yve();
                    ke(
                      (Oe, et, kt, tn, Tn) => {
                        te(Te, "x", Oe), te(Te, "y", et), te(Te, "width", kt), te(Te, "height", tn), te(Te, "fill", Tn);
                      },
                      [
                        () => Math.min(x(Ze).x0, x(Ze).x1) + x(vn) / 2,
                        () => Math.min(x(It).y0, x(It).y1) + x(vn) / 2,
                        () => Math.abs(x(Ze).x0 - x(Ze).x1) - x(vn),
                        () => Math.abs(x(It).y0 - x(It).y1) - x(vn),
                        () => x(f)(x(Ke).value)
                      ]
                    ), X(un, Te);
                  }), ke(
                    (un) => {
                      te(mt, "width", Ye().plotWidth), te(mt, "height", Ye().plotHeight), te(mt, "fill", un);
                    },
                    [() => x(f)(0)]
                  ), X(Ne, Pt);
                },
                children: (Ne, Ye = zt) => {
                  N2(Ne, {
                    get proxy() {
                      return Ye();
                    },
                    mode: "xy",
                    get value() {
                      return x(o);
                    },
                    get colorScheme() {
                      return n();
                    },
                    onChange: (Ge) => {
                      e.onStateChange({
                        brush: Ge != null && Ge.x != null && Ge.y != null ? { x: Ge.x, y: Ge.y } : null
                      });
                    }
                  });
                },
                $$slots: { childrenBelow: !0, default: !0 }
              });
            };
            Fe(Pe, (fe) => {
              x(l) != null && fe(Ce);
            });
          }
          X(ne, Me);
        };
        let se = /* @__PURE__ */ K(() => e.height != null), oe = /* @__PURE__ */ K(() => Math.min(300, e.width ?? 300));
        pm(S, {
          get flexHeight() {
            return x(se);
          },
          get defaultHeight() {
            return x(oe);
          },
          children: re,
          $$slots: { default: !0 }
        });
      }
      var C = ue(S, 2), E = J(C);
      Q(C);
      var A = ue(C, 2), O = J(A), T = J(O);
      {
        const re = (oe, ne = zt) => {
          {
            let ce = /* @__PURE__ */ K(() => ne().xScale?.domain);
            mve(oe, {
              get color() {
                return x(f);
              },
              rasterWidth: 100,
              rasterHeight: 1,
              get proxy() {
                return ne();
              },
              get xDomain() {
                return x(ce);
              }
            });
          }
        };
        let se = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x(a)] }));
        $d(T, {
          get xScale() {
            return x(se);
          },
          xAxis: { extendScaleToTicks: !1 },
          width: 230,
          height: 24,
          extents: { left: 30, right: 30, top: 0, bottom: 0 },
          get colorScheme() {
            return n();
          },
          children: re,
          $$slots: { default: !0 }
        });
      }
      Q(O);
      var $ = ue(O, 2), P = J($), B = J(P), M = () => e.spec.xScaleType ?? x(d) ?? "linear", L = (re) => {
        e.onSpecChange({ xScaleType: re });
      };
      Df(B, {
        label: "X",
        get value() {
          return M();
        },
        set value(re) {
          L(re);
        }
      });
      var N = ue(B, 2), j = () => e.spec.yScaleType ?? x(p) ?? "linear", U = (re) => {
        e.onSpecChange({ yScaleType: re });
      };
      Df(N, {
        label: "Y",
        get value() {
          return j();
        },
        set value(re) {
          U(re);
        }
      }), Q(P);
      var H = ue(P, 2), G = ue(J(H), 2);
      {
        let re = /* @__PURE__ */ K(() => e.spec.normalization ?? null);
        B2(G, {
          options: [
            { value: null, label: "off" },
            { value: "x", label: "X" },
            { value: "y", label: "Y" }
          ],
          get value() {
            return x(re);
          },
          onChange: (se) => e.onSpecChange({ normalization: se })
        });
      }
      Q(H), Q($), Q(A), ke(() => {
        ut(k, `â†‘ ${e.spec.data.y ?? ""}`), ut(E, `${e.spec.data.x ?? ""} â†’`);
      }), X(y, v);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
var wve = /* @__PURE__ */ Dt("<rect></rect>"), _ve = /* @__PURE__ */ Dt("<rect></rect>"), kve = /* @__PURE__ */ Dt("<!><!><!>", 1), Cve = /* @__PURE__ */ ge('<div class="flex gap-1 items-center"><div class="w-3 h-3 block rounded-sm"></div> <div class="whitespace-nowrap max-w-32 overflow-hidden text-ellipsis"> </div></div>'), Sve = /* @__PURE__ */ ge('<div class="flex gap-2 flex-wrap items-center select-none"></div>'), Ave = /* @__PURE__ */ ge('<!> <div class="flex-none flex gap-2 items-start text-sm"><div class="flex-1 text-slate-400 dark:text-slate-500"><!></div> <span class="flex flex-col items-end gap-1"><!> <span class="flex gap-1 select-none"><span class="text-slate-400 dark:text-slate-500 text-sm">Normalize:</span> <!></span></span></div>', 1);
function Eve(t, e) {
  it(e, !0);
  const n = () => gi(s, "$colorScheme", r), [r, i] = Xs();
  let { colorScheme: s } = e.context, o = /* @__PURE__ */ K(() => e.state.brush), l = /* @__PURE__ */ K(() => vc[n()]), a = /* @__PURE__ */ Ee(null), u = /* @__PURE__ */ Ee(null);
  function c(p, m, y, b, v) {
    let _ = /* @__PURE__ */ Ee(null);
    Promise.all([
      Za(p, m, y),
      Za(p, m, b)
    ]).then(([C, E]) => {
      ae(_, C != null && E != null ? { x: C, group: E } : null);
    });
    let k = /* @__PURE__ */ K(() => x(_) ? b0(
      {
        key: "x",
        stats: x(_).x,
        scaleType: e.spec.xScaleType,
        binCount: e.spec.xBinCount
      },
      {
        key: "group",
        stats: x(_).group,
        binCount: e.spec.groupBinCount
      }
    ) : null);
    pt(() => {
      x(u) == null && x(k)?.scales.x?.type != null && ae(u, x(k)?.scales.x?.type, !0);
    });
    function S(C, E, A) {
      return ia({
        coordinator: p,
        selection: E ?? void 0,
        query: (O) => R.Query.from(R.Query.from(m).select({ ...C.select, count: R.count() }).where(O).groupby(C.select.x, C.select.group)).select({
          x: "x",
          group: "group",
          count: "count",
          normalizeByX: R.sql`count / (SUM(count) OVER (PARTITION BY x))`
        }),
        queryResult: (O) => {
          A(Array.from(O).map(C.collect));
        }
      });
    }
    pt(() => {
      if (x(k) == null)
        return;
      let C = x(k), E = /* @__PURE__ */ Ee(null), A = /* @__PURE__ */ Ee(null), O = S(C, null, (P) => {
        ae(E, P);
      }), T = S(C, v, (P) => {
        ae(A, P);
      }), $ = {
        reset: () => {
          e.onStateChange({ brush: null });
        }
      };
      return pt(() => {
        if (x(E) != null && x(A) != null) {
          let P = (H) => JSON.stringify(H), B = e.spec.normalization == "x" ? "normalizeByX" : "count", M = Array.from(f(x(E), (H) => P(H.group), (H) => H[0].group).entries()).sort((H, G) => C.order.group(H[1], G[1])), L = f(x(E), (H) => P(H.x), (H) => ({
            x: H[0].x,
            total: H.reduce((G, re) => G + re[B], 0)
          })), N = f(x(A), (H) => P(H.x), (H) => {
            H = H.sort((se, oe) => C.order.group(se.group, oe.group));
            let G = [], re = 0;
            for (let se of H)
              G.push({ group: se.group, y1: re, y2: re + se[B] }), re += se[B];
            return { x: H[0].x, groups: G };
          }), j = L.values().reduce((H, G) => Math.max(H, G.total), 1);
          e.spec.normalization && (j = 1);
          let U = bbe(Array.from(M.map((H) => H[1])), {
            fade: ["n/a", "(null)"],
            ordinal: C.scales.group.type != "band"
          });
          ae(a, {
            xScale: C.scales.x,
            yScale: { type: "linear", domain: [0, j] },
            colorScale: U,
            totals: Array.from(L.values()),
            items: Array.from(N.values())
          });
        }
      }), pt(() => {
        let P = {
          source: $,
          clients: /* @__PURE__ */ new Set([T]),
          ...x(o) != null ? C.clause(x(o)) : { value: null, predicate: null }
        };
        v.update(P), v.activate(P);
      }), () => {
        O.destroy(), T.destroy(), v.update({
          source: $,
          clients: /* @__PURE__ */ new Set([T]),
          value: null,
          predicate: null
        });
      };
    });
  }
  pt(() => {
    c(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.group, e.context.filter);
  });
  function f(p, m, y) {
    let b = /* @__PURE__ */ new Map();
    for (let v of p) {
      let _ = m(v), k = b.get(_);
      k || (k = [], b.set(_, k)), k.push(v);
    }
    return new Map(b.entries().map(([v, _]) => [v, y(_)]));
  }
  function d(p) {
    if (typeof p == "string")
      return p;
    {
      let m = su(".6");
      if (p.length == 2)
        return `[${m(p[0])}, ${m(p[1])})`;
    }
    return "(invalid)";
  }
  yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (p, m) => {
      var y = Ave(), b = We(y);
      {
        const P = (M, L = zt, N = zt) => {
          var j = kn(), U = We(j);
          {
            var H = (G) => {
              $d(G, {
                get width() {
                  return L();
                },
                get height() {
                  return N();
                },
                get xScale() {
                  return x(a).xScale;
                },
                get yScale() {
                  return x(a).yScale;
                },
                get colorScheme() {
                  return n();
                },
                children: (se, oe = zt) => {
                  const ne = /* @__PURE__ */ K(() => oe().xScale), ce = /* @__PURE__ */ K(() => oe().yScale);
                  var we = kve(), Me = We(we);
                  Bt(Me, 17, () => x(a)?.totals ?? [], fn, (fe, De) => {
                    const Se = /* @__PURE__ */ K(() => {
                      const [gt, Pt] = x(ne).applyBand(x(De).x);
                      return { x0: gt, x1: Pt };
                    }), Ne = /* @__PURE__ */ K(() => {
                      const [gt, Pt] = x(ce).applyBand([0, x(De).total]);
                      return { y0: gt, y1: Pt };
                    }), Ye = /* @__PURE__ */ K(() => Math.min(Math.abs(x(Se).x1 - x(Se).x0) * 0.2, Math.abs(x(Ne).y1 - x(Ne).y0) * 0.2, 1));
                    var Ge = wve();
                    ke(
                      (gt, Pt, mt, Wt) => {
                        te(Ge, "x", gt), te(Ge, "y", Pt), te(Ge, "width", mt), te(Ge, "height", Wt), te(Ge, "fill", x(l).markColorFade);
                      },
                      [
                        () => Math.min(x(Se).x0, x(Se).x1) + x(Ye) / 2,
                        () => Math.min(x(Ne).y0, x(Ne).y1),
                        () => Math.abs(x(Se).x0 - x(Se).x1) - x(Ye),
                        () => Math.abs(x(Ne).y0 - x(Ne).y1)
                      ]
                    ), X(fe, Ge);
                  });
                  var Pe = ue(Me);
                  Bt(Pe, 17, () => x(a)?.items ?? [], fn, (fe, De) => {
                    let Se = () => x(De).x, Ne = () => x(De).groups;
                    const Ye = /* @__PURE__ */ K(() => {
                      const [Pt, mt] = x(ne).applyBand(Se());
                      return { x0: Pt, x1: mt };
                    });
                    var Ge = kn(), gt = We(Ge);
                    Bt(gt, 17, Ne, fn, (Pt, mt) => {
                      const Wt = /* @__PURE__ */ K(() => {
                        const [Ze, It] = x(ce).applyBand([x(mt).y1, x(mt).y2]);
                        return { y0: Ze, y1: It };
                      }), un = /* @__PURE__ */ K(() => Math.min(Math.abs(x(Ye).x1 - x(Ye).x0) * 0.2, Math.abs(x(Wt).y1 - x(Wt).y0) * 0.2, 1));
                      var Ke = _ve();
                      ke(
                        (Ze, It, vn, Te, Oe) => {
                          te(Ke, "x", Ze), te(Ke, "y", It), te(Ke, "width", vn), te(Ke, "height", Te), te(Ke, "fill", Oe);
                        },
                        [
                          () => Math.min(x(Ye).x0, x(Ye).x1) + x(un) / 2,
                          () => Math.min(x(Wt).y0, x(Wt).y1),
                          () => Math.abs(x(Ye).x0 - x(Ye).x1) - x(un),
                          () => Math.abs(x(Wt).y0 - x(Wt).y1),
                          () => x(a)?.colorScale.apply(x(mt).group)
                        ]
                      ), X(Pt, Ke);
                    }), X(fe, Ge);
                  });
                  var Ce = ue(Pe);
                  N2(Ce, {
                    get proxy() {
                      return oe();
                    },
                    mode: "x",
                    get value() {
                      return x(o);
                    },
                    get colorScheme() {
                      return n();
                    },
                    onChange: (fe) => {
                      e.onStateChange({ brush: fe != null && fe.x != null ? { x: fe.x } : null });
                    }
                  }), X(se, we);
                },
                $$slots: { default: !0 }
              });
            };
            Fe(U, (G) => {
              x(a) != null && G(H);
            });
          }
          X(M, j);
        };
        let B = /* @__PURE__ */ K(() => e.height != null);
        pm(b, {
          get flexHeight() {
            return x(B);
          },
          children: P,
          $$slots: { default: !0 }
        });
      }
      var v = ue(b, 2), _ = J(v), k = J(_);
      {
        var S = (P) => {
          var B = Sve();
          Bt(B, 21, () => x(a).colorScale.domain, fn, (M, L) => {
            var N = Cve(), j = J(N);
            let U;
            var H = ue(j, 2), G = J(H, !0);
            Q(H), Q(N), ke(
              (re, se, oe) => {
                te(N, "title", re), U = ht(j, "", U, se), ut(G, oe);
              },
              [
                () => JSON.stringify(x(L)),
                () => ({ background: x(a).colorScale.apply(x(L)) }),
                () => d(x(L))
              ]
            ), X(M, N);
          }), Q(B), X(P, B);
        };
        Fe(k, (P) => {
          x(a) && P(S);
        });
      }
      Q(_);
      var C = ue(_, 2), E = J(C), A = () => e.spec.xScaleType ?? x(u) ?? "linear", O = (P) => {
        e.onSpecChange({ xScaleType: P });
      };
      Df(E, {
        label: "X",
        get value() {
          return A();
        },
        set value(P) {
          O(P);
        }
      });
      var T = ue(E, 2), $ = ue(J(T), 2);
      B2($, {
        options: [{ value: null, label: "off" }, { value: "x", label: "X" }],
        get value() {
          return e.spec.normalization;
        },
        onChange: (P) => e.onSpecChange({ normalization: P })
      }), Q(T), Q(C), Q(v), X(p, y);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
var Dve = /* @__PURE__ */ Dt('<circle r="3"></circle>'), Ove = /* @__PURE__ */ Dt('<path fill="none" stroke-width="2"></path><!>', 1), Fve = /* @__PURE__ */ ge('<div class="flex gap items-center text-sm"><span class="flex-1"></span> <!></div>'), Tve = /* @__PURE__ */ ge("<!> <!>", 1);
function Rve(t, e) {
  it(e, !0);
  const n = () => gi(o, "$colorScheme", r), [r, i] = Xs();
  let { coordinator: s, colorScheme: o } = e.context, l = /* @__PURE__ */ K(() => vc[n()]), a = /* @__PURE__ */ Ee(null), u = /* @__PURE__ */ Ee(null);
  function c(f, d, p) {
    let m = /* @__PURE__ */ Ee(null);
    Za(f, d, p).then((v) => {
      ae(m, v);
    });
    let y = /* @__PURE__ */ K(() => x(m) ? b0({
      key: "x",
      stats: x(m),
      scaleType: e.spec.xScaleType,
      binCount: 52
    }) : null);
    pt(() => {
      x(u) == null && x(y)?.scales.x?.type != null && ae(u, x(y)?.scales.x?.type, !0);
    });
    function b(v, _) {
      return ia({
        coordinator: f,
        selection: e.context.filter,
        query: (k) => R.Query.from(d).select({ ...v.select, count: R.count() }).where(k).groupby(v.select.x).orderby(v.select.x),
        queryResult: (k) => {
          _(Array.from(k).map(v.collect));
        }
      });
    }
    pt(() => {
      if (x(y) == null)
        return;
      let v = x(y), _ = /* @__PURE__ */ Ee(ho([])), k = b(v, (S) => {
        ae(_, S, !0);
      });
      return pt(() => {
        x(_).length > 0 && ae(a, { xScale: v.scales.x, points: x(_) });
      }), () => {
        k.destroy();
      };
    });
  }
  pt(() => {
    c(s, e.context.table, e.spec.data.x);
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    class: "flex flex-col gap-2",
    children: (f, d) => {
      var p = Tve(), m = We(p);
      {
        const v = (k, S = zt, C = zt) => {
          var E = kn(), A = We(E);
          {
            var O = (T) => {
              const $ = /* @__PURE__ */ K(() => x(a).points.reduce((P, B) => Math.max(P, B.count), 1));
              {
                const P = (M, L = zt) => {
                  const N = /* @__PURE__ */ K(() => L().xScale), j = /* @__PURE__ */ K(() => L().yScale);
                  var U = kn(), H = We(U);
                  {
                    var G = (re) => {
                      const se = /* @__PURE__ */ K(() => x(a).points.map((we, Me) => {
                        const Pe = x(N).apply(we.x), Ce = x(j).apply(we.count);
                        return `${Me === 0 ? "M" : "L"} ${Pe} ${Ce}`;
                      }).join(" "));
                      var oe = Ove(), ne = We(oe), ce = ue(ne);
                      Bt(ce, 17, () => x(a).points, fn, (we, Me) => {
                        const Pe = /* @__PURE__ */ K(() => x(N).apply(x(Me).x)), Ce = /* @__PURE__ */ K(() => x(j).apply(x(Me).count));
                        var fe = Dve();
                        ke(() => {
                          te(fe, "cx", x(Pe)), te(fe, "cy", x(Ce)), te(fe, "fill", x(l).markColor);
                        }), X(we, fe);
                      }), ke(() => {
                        te(ne, "d", x(se)), te(ne, "stroke", x(l).markColor);
                      }), X(re, oe);
                    };
                    Fe(H, (re) => {
                      x(a).points.length > 1 && re(G);
                    });
                  }
                  X(M, U);
                };
                let B = /* @__PURE__ */ K(() => ({ type: "linear", domain: [0, x($)] }));
                $d(T, {
                  get width() {
                    return S();
                  },
                  get height() {
                    return C();
                  },
                  get xScale() {
                    return x(a).xScale;
                  },
                  get yScale() {
                    return x(B);
                  },
                  get colorScheme() {
                    return n();
                  },
                  children: P,
                  $$slots: { default: !0 }
                });
              }
            };
            Fe(A, (T) => {
              x(a) != null && T(O);
            });
          }
          X(k, E);
        };
        let _ = /* @__PURE__ */ K(() => e.height != null);
        pm(m, {
          get flexHeight() {
            return x(_);
          },
          children: v,
          $$slots: { default: !0 }
        });
      }
      var y = ue(m, 2);
      {
        var b = (v) => {
          var _ = Fve(), k = ue(J(_), 2);
          {
            let S = /* @__PURE__ */ K(() => e.spec.xScaleType ?? x(u) ?? "linear");
            Df(k, {
              label: "X",
              get value() {
                return x(S);
              },
              onChange: (C) => {
                e.onSpecChange({ xScaleType: C });
              }
            });
          }
          Q(_), X(v, _);
        };
        Fe(y, (v) => {
          x(a)?.xScale.type != "band" && v(b);
        });
      }
      X(f, p);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
var Mve = /* @__PURE__ */ ge('<div class="p-2 w-full"></div>');
function Pve(t, e) {
  it(e, !0);
  let { coordinator: n, colorScheme: r } = e.context, i = /* @__PURE__ */ Ee(void 0), s = /* @__PURE__ */ Ee(ho(e.width ?? 800));
  function o(c, f) {
    if (!c) return !1;
    let d = f.mark?.plot?.element;
    return d == null ? !1 : c?.contains(d) ?? !1;
  }
  async function l(c, f, d, p = {}) {
    try {
      const m = SK(f), y = EK({ coordinator: c }), b = await AK(m, { params: new Map(Object.entries(p)), api: y });
      return d.innerHTML = "", b.element && d.appendChild(b.element), () => {
        for (const v in p) {
          const _ = p[v];
          if (g_(_))
            for (const k of _.clauses)
              o(d, k.source) && (k.source?.reset?.(), _.update({ ...k, value: null, predicate: null }));
        }
        b.element?.remove();
      };
    } catch (m) {
      return console.error("[MosaicSpec] Failed to render vgplot spec:", m), d.innerHTML = `<div style="padding: 1rem; color: #ef4444;">
        Failed to render chart: ${m instanceof Error ? m.message : String(m)}
      </div>`, () => {
      };
    }
  }
  Kg(() => {
    pt(() => {
      let c = null;
      async function f() {
        x(i) && e.spec.spec && (c = await l(n, e.spec.spec, x(i), { filter: e.context.filter }));
      }
      return f(), () => {
        c?.();
      };
    });
  }), Vo(() => {
    e.width != null && ae(s, e.width, !0);
  });
  var a = Mve();
  let u;
  Yo(a, (c) => ae(i, c), () => x(i)), ke(() => u = ht(a, "", u, {
    height: e.height != null ? `${e.height}px` : "100%"
  })), Ko(a, "clientWidth", (c) => ae(s, c)), X(t, a), st();
}
var Ive = /* @__PURE__ */ ge('<div class="bg-slate-100 p-2 rounded-md w-full h-full overflow-y-scroll"><pre> </pre></div>');
function W3(t, e) {
  it(e, !0);
  var n = Ive(), r = J(n), i = J(r, !0);
  Q(r), Q(n), ke((s) => ut(i, s), [() => JSON.stringify(e.spec, null, 2)]), X(t, n), st();
}
var Nve = /* @__PURE__ */ ge('<span class="mx-1"> </span>'), Bve = /* @__PURE__ */ ge("<button><!> <!></button>");
function Tu(t, e) {
  it(e, !0);
  let n = ct(e, "label", 3, null), r = ct(e, "icon", 3, null), i = ct(e, "title", 3, ""), s = ct(e, "order", 3, null);
  var o = Bve();
  o.__click = () => {
    e.onClick?.();
  };
  let l;
  var a = J(o);
  {
    var u = (d) => {
      const p = /* @__PURE__ */ K(r);
      var m = kn(), y = We(m);
      Yd(y, () => x(p), (b, v) => {
        v(b, { class: "w-5 h-5" });
      }), X(d, m);
    };
    Fe(a, (d) => {
      r() != null && d(u);
    });
  }
  var c = ue(a, 2);
  {
    var f = (d) => {
      var p = Nve(), m = J(p, !0);
      Q(p), ke(() => ut(m, n())), X(d, p);
    };
    Fe(c, (d) => {
      n() != null && n() != "" && d(f);
    });
  }
  Q(o), ke(() => {
    er(o, 1, `rounded-md flex select-none items-center px-1.5 py-1.5 h-[28px] border bg-white dark:bg-slate-900 border-slate-300 dark:border-slate-600 dark:text-slate-400 focus-visible:outline-2 outline-blue-600 -outline-offset-1 ${e.class ?? "" ?? ""}`), te(o, "title", i()), l = ht(o, "", l, { order: s() });
  }), X(t, o), st();
}
ir(["click"]);
var Lve = /* @__PURE__ */ ge("<input/>");
function R$(t, e) {
  it(e, !0);
  let n = ct(e, "value", 15), r = ct(e, "type", 3, "text"), i = ct(e, "placeholder", 3, ""), s = ct(e, "className", 3, "");
  function o(a) {
    a.key == "Escape" && a.stopPropagation();
  }
  var l = Lve();
  OT(l), l.__keydown = o, ke(() => {
    te(l, "type", r()), te(l, "placeholder", i()), er(l, 1, `form-input rounded-md py-1 bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 ${s() ?? "" ?? ""}`);
  }), QY(l, n), X(t, l), st();
}
ir(["keydown"]);
var $ve = /* @__PURE__ */ ge('<div><button class="flex-1 overflow-hidden text-left"><div class="text-ellipsis overflow-hidden w-full"> </div> <div class="text-ellipsis overflow-hidden w-full"><code class="text-xs whitespace-nowrap"> </code></div></button> <div class="flex-none flex gap-1"><!> <!></div></div>'), zve = /* @__PURE__ */ ge('<div class="mt-4"><!> <div class="text-slate-500 dark:text-slate-400 text-sm mb-1">SQL Predicate</div> <div class="w-full !h-32 mb-2"><!></div> <div class="flex gap-2"><!> <!> <div class="flex-1"></div> <button class="text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200">Current Predicate</button></div></div>'), jve = /* @__PURE__ */ ge('<div class="flex flex-col gap-1"><!> <button class="text-left text-slate-400 dark:text-slate-500 hover:text-slate-800 dark:hover:text-slate-200 whitespace-nowrap text-ellipsis w-full overflow-hidden">+ Add Predicate</button></div> <!>', 1);
function qve(t, e) {
  it(e, !0);
  const n = () => gi(s, "$colorScheme", r), [r, i] = Xs();
  let { colorScheme: s } = e.context, o = /* @__PURE__ */ K(() => e.spec.items ?? []), l = /* @__PURE__ */ K(() => e.state.selectedPredicates ?? []), a = /* @__PURE__ */ Ee(!1), u = /* @__PURE__ */ Ee(null), c = /* @__PURE__ */ Ee(""), f = /* @__PURE__ */ Ee("");
  function d() {
    ae(a, !1), ae(u, null), ae(f, ""), ae(c, "");
  }
  function p(y) {
    e.onSpecChange({ items: y }), e.onStateChange({
      selectedPredicates: (e.state.selectedPredicates ?? []).filter((b) => y.find((v) => v.predicate == b) != null)
    });
  }
  async function m() {
    let y = x(f).trim();
    y == "" && (y = "Predicate");
    let b = x(c).trim();
    if (b == "")
      return null;
    try {
      await e.context.coordinator.query(R.Query.from(e.context.table).select({ count: R.count() }).where(b));
    } catch (v) {
      return alert(v.toString()), null;
    }
    return { name: y, predicate: b };
  }
  pt(() => {
    let y = ia({
      coordinator: e.context.coordinator,
      selection: e.context.filter,
      query: () => R.sql`SELECT 1`
    }), b = {
      reset: () => {
        e.onStateChange({ selectedPredicates: [] });
      }
    };
    return Vo(() => {
      if (x(l).length == 0)
        e.context.filter.update({
          source: b,
          clients: /* @__PURE__ */ new Set([y]),
          predicate: null,
          value: null
        });
      else {
        let v = x(l).map((_) => "(" + _ + ")").join(" OR ");
        e.context.filter.update({
          source: b,
          clients: /* @__PURE__ */ new Set([y]),
          predicate: R.asVerbatim(v),
          value: v
        });
      }
    }), () => {
      y.destroy();
    };
  }), yc(t, {
    get width() {
      return e.width;
    },
    get height() {
      return e.height;
    },
    scrollY: !0,
    children: (y, b) => {
      var v = jve(), _ = We(v), k = J(_);
      Bt(k, 17, () => x(o), fn, (A, O) => {
        const T = /* @__PURE__ */ K(() => x(l).indexOf(x(O).predicate) >= 0);
        var $ = $ve();
        let P;
        var B = J($);
        B.__click = (se) => {
          se.shiftKey ? ae(l, x(T) ? x(l).filter((oe) => oe != x(O).predicate) : [...x(l), x(O).predicate]) : x(T) ? ae(l, []) : ae(l, [x(O).predicate]);
        };
        var M = J(B), L = J(M, !0);
        Q(M);
        var N = ue(M, 2), j = J(N), U = J(j, !0);
        Q(j), Q(N), Q(B);
        var H = ue(B, 2), G = J(H);
        Tu(G, {
          get icon() {
            return BB;
          },
          onClick: () => {
            ae(u, x(O)), ae(c, x(O).predicate, !0), ae(f, x(O).name, !0), ae(a, !0);
          }
        });
        var re = ue(G, 2);
        Tu(re, {
          get icon() {
            return _2;
          },
          onClick: () => {
            p(x(o).filter((se) => se !== x(O)));
          }
        }), Q(H), Q($), ke(() => {
          P = er($, 1, "flex gap-4 w-full bg-white dark:bg-slate-800 p-2 rounded-md border border-slate-200 dark:border-slate-600 select-none", null, P, {
            "!bg-blue-100": x(T),
            "!border-blue-400": x(T),
            "dark:!bg-blue-800": x(T),
            "dark:!border-blue-600": x(T)
          }), ut(L, x(O).name), te(j, "title", x(O).predicate), ut(U, x(O).predicate);
        }), X(A, $);
      });
      var S = ue(k, 2);
      S.__click = () => {
        ae(a, !0), ae(u, null);
      }, Q(_);
      var C = ue(_, 2);
      {
        var E = (A) => {
          var O = zve(), T = J(O);
          R$(T, {
            placeholder: "name",
            className: "w-full mb-2",
            get value() {
              return x(f);
            },
            set value(H) {
              ae(f, H, !0);
            }
          });
          var $ = ue(T, 4), P = J($);
          {
            let H = /* @__PURE__ */ K(() => ({
              table: e.context.table,
              columns: e.context.columns
            }));
            D5(P, {
              language: "sql",
              get sql() {
                return x(H);
              },
              class: "w-full h-full",
              get colorScheme() {
                return n();
              },
              get value() {
                return x(c);
              },
              onChange: (G) => ae(c, G, !0)
            });
          }
          Q($);
          var B = ue($, 2), M = J(B);
          {
            var L = (H) => {
              Tu(H, {
                label: "Update",
                onClick: async () => {
                  let G = await m();
                  G && (p(x(o).map((re) => re === x(u) ? G : re)), d());
                }
              });
            }, N = (H) => {
              Tu(H, {
                label: "Add",
                onClick: async () => {
                  let G = await m();
                  G && (p([...x(o), G]), d());
                }
              });
            };
            Fe(M, (H) => {
              x(u) != null ? H(L) : H(N, !1);
            });
          }
          var j = ue(M, 2);
          Tu(j, {
            label: "Cancel",
            onClick: () => {
              ae(u, null), ae(a, !1);
            }
          });
          var U = ue(j, 4);
          U.__click = () => ae(c, D$(e.context.filter.predicate(null)) ?? "", !0), Q(B), Q(O), X(A, O);
        };
        Fe(C, (A) => {
          x(a) && A(E);
        });
      }
      X(y, v);
    },
    $$slots: { default: !0 }
  }), st(), i();
}
ir(["click"]);
var Uve = /* @__PURE__ */ ge("<option disabled selected> </option>"), Hve = /* @__PURE__ */ ge("<hr/>"), Vve = /* @__PURE__ */ ge("<option> </option>"), Wve = /* @__PURE__ */ ge('<label class="select-none flex items-center gap-2"><span class="text-slate-500 dark:text-slate-400 whitespace-nowrap"> </span> <select><!><!></select></label>'), Gve = /* @__PURE__ */ ge("<option disabled selected> </option>"), Kve = /* @__PURE__ */ ge("<hr/>"), Yve = /* @__PURE__ */ ge("<option> </option>"), Xve = /* @__PURE__ */ ge("<select><!><!></select>");
function Of(t, e) {
  it(e, !0);
  let n = ct(e, "label", 3, void 0), r = ct(e, "disabled", 3, !1), i = ct(e, "placeholder", 3, null), s = ct(e, "options", 19, () => []), o = ct(e, "onChange", 3, void 0), l = /* @__PURE__ */ Ee(void 0);
  const a = E$(), u = a + "_null", c = a + "_undefined", f = (_) => _ === null ? u : _ === void 0 ? c : _.toString(), d = (_) => _ === u ? null : _ === c ? void 0 : _;
  function p(_) {
    !o() || !x(l) || o()(d(x(l).value));
  }
  var m = kn(), y = We(m);
  {
    var b = (_) => {
      var k = Wve(), S = J(k), C = J(S, !0);
      Q(S);
      var E = ue(S, 2);
      E.__change = p;
      var A = J(E);
      {
        var O = (P) => {
          var B = Uve(), M = J(B, !0);
          Q(B), B.value = (B.__value = null) ?? "", ke(() => ut(M, i())), X(P, B);
        };
        Fe(A, (P) => {
          i() != null && P(O);
        });
      }
      var T = ue(A);
      Bt(T, 17, s, fn, (P, B) => {
        var M = kn(), L = We(M);
        {
          var N = (U) => {
            var H = Hve();
            X(U, H);
          }, j = (U) => {
            var H = Vve(), G = J(H, !0);
            Q(H);
            var re = {};
            ke(
              (se) => {
                ut(G, x(B).label), re !== (re = se) && (H.value = (H.__value = se) ?? "");
              },
              [() => f(x(B).value)]
            ), X(U, H);
          };
          Fe(L, (U) => {
            x(B) === "---" ? U(N) : U(j, !1);
          });
        }
        X(P, M);
      }), Q(E), Yo(E, (P) => ae(l, P), () => x(l));
      var $;
      ab(E), Q(k), ke(
        (P) => {
          ut(C, n()), er(E, 1, `form-select rounded-md py-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 dark:text-slate-400 text-ellipsis ${e.class ?? "" ?? ""}`), E.disabled = r(), $ !== ($ = P) && (E.value = (E.__value = P) ?? "", bd(E, P));
        },
        [() => f(e.value)]
      ), X(_, k);
    }, v = (_) => {
      var k = Xve();
      k.__change = p;
      var S = J(k);
      {
        var C = (O) => {
          var T = Gve(), $ = J(T, !0);
          Q(T), T.value = (T.__value = null) ?? "", ke(() => ut($, i())), X(O, T);
        };
        Fe(S, (O) => {
          i() != null && O(C);
        });
      }
      var E = ue(S);
      Bt(E, 17, s, fn, (O, T) => {
        var $ = kn(), P = We($);
        {
          var B = (L) => {
            var N = Kve();
            X(L, N);
          }, M = (L) => {
            var N = Yve(), j = J(N, !0);
            Q(N);
            var U = {};
            ke(
              (H) => {
                ut(j, x(T).label), U !== (U = H) && (N.value = (N.__value = H) ?? "");
              },
              [() => f(x(T).value)]
            ), X(L, N);
          };
          Fe(P, (L) => {
            x(T) === "---" ? L(B) : L(M, !1);
          });
        }
        X(O, $);
      }), Q(k), Yo(k, (O) => ae(l, O), () => x(l));
      var A;
      ab(k), ke(
        (O) => {
          er(k, 1, `form-select rounded-md py-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 dark:text-slate-400 select-none text-ellipsis ${e.class ?? "" ?? ""}`), k.disabled = r(), A !== (A = O) && (k.value = (k.__value = O) ?? "", bd(k, O));
        },
        [() => f(e.value)]
      ), X(_, k);
    };
    Fe(y, (_) => {
      n() != null ? _(b) : _(v, !1);
    });
  }
  X(t, m), st();
}
ir(["change"]);
const Qve = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<line x1="15" y1="54" x2="15" y2="12" stroke="black" stroke-width="2"/>
<line x1="32" y1="53" x2="32" y2="10" stroke="black" stroke-width="2"/>
<line x1="49" y1="45" x2="49" y2="19" stroke="black" stroke-width="2"/>
<rect x="8" y="27" width="14" height="18" rx="3" fill="#007AFF"/>
<rect x="25" y="22" width="14" height="14" rx="3" fill="#007AFF"/>
<rect x="42" y="27" width="14" height="12" rx="3" fill="#007AFF"/>
</svg>
`, Jve = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="32" cy="28" r="2" fill="#007AFF"/>
<circle cx="32" cy="24" r="2" fill="#007AFF"/>
<circle cx="32" cy="20" r="2" fill="#007AFF"/>
<circle cx="36" cy="32" r="2" fill="#007AFF"/>
<circle cx="36" cy="28" r="2" fill="#007AFF"/>
<circle cx="36" cy="24" r="2" fill="#007AFF"/>
<circle cx="28" cy="32" r="2" fill="#007AFF"/>
<circle cx="28" cy="28" r="2" fill="#007AFF"/>
<circle cx="28" cy="24" r="2" fill="#007AFF"/>
<circle cx="28" cy="20" r="2" fill="#007AFF"/>
<circle cx="28" cy="16" r="2" fill="#007AFF"/>
<circle cx="44" cy="24" r="2" fill="#A3CFFF"/>
<circle cx="44" cy="20" r="2" fill="#A3CFFF"/>
<circle cx="44" cy="16" r="2" fill="#A3CFFF"/>
<circle cx="40" cy="20" r="2" fill="#A3CFFF"/>
<circle cx="40" cy="16" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="32" r="2" fill="#007AFF"/>
<circle cx="20" cy="28" r="2" fill="#007AFF"/>
<circle cx="20" cy="24" r="2" fill="#007AFF"/>
<circle cx="20" cy="20" r="2" fill="#3897FF"/>
<circle cx="20" cy="16" r="2" fill="#3897FF"/>
<circle cx="24" cy="32" r="2" fill="#007AFF"/>
<circle cx="24" cy="28" r="2" fill="#007AFF"/>
<circle cx="24" cy="24" r="2" fill="#007AFF"/>
<circle cx="24" cy="20" r="2" fill="#3897FF"/>
<circle cx="24" cy="16" r="2" fill="#3897FF"/>
<circle cx="16" cy="32" r="2" fill="#3897FF"/>
<circle cx="16" cy="28" r="2" fill="#3897FF"/>
<circle cx="16" cy="24" r="2" fill="#3897FF"/>
<circle cx="32" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="32" cy="36" r="2" fill="#007AFF"/>
<circle cx="36" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="36" cy="36" r="2" fill="#007AFF"/>
<circle cx="28" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="28" cy="36" r="2" fill="#007AFF"/>
<circle cx="44" cy="44" r="2" fill="#3897FF"/>
<circle cx="48" cy="44" r="2" fill="#3897FF"/>
<circle cx="48" cy="40" r="2" fill="#3897FF"/>
<circle cx="52" cy="32" r="2" fill="#A3CFFF"/>
<circle cx="52" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="32" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="28" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="52" cy="36" r="2" fill="#A3CFFF"/>
<circle cx="56" cy="36" r="2" fill="#A3CFFF"/>
<circle cx="8" cy="16" r="2" fill="#E0EFFF"/>
<circle cx="12" cy="32" r="2" fill="#3897FF"/>
<circle cx="12" cy="28" r="2" fill="#3897FF"/>
<circle cx="28" cy="8" r="2" fill="#A3CFFF"/>
<circle cx="48" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="48" cy="8" r="2" fill="#E0EFFF"/>
<circle cx="20" cy="12" r="2" fill="#A3CFFF"/>
<circle cx="24" cy="12" r="2" fill="#A3CFFF"/>
<circle cx="24" cy="8" r="2" fill="#A3CFFF"/>
<circle cx="52" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="56" cy="8" r="2" fill="#E0EFFF"/>
<circle cx="8" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="12" cy="12" r="2" fill="#E0EFFF"/>
<circle cx="32" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="32" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="36" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="28" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="28" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="44" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="40" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="20" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="24" cy="56" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="24" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="16" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="12" cy="52" r="2" fill="#007AFF" fill-opacity="0.12"/>
<circle cx="8" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="12" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="12" cy="44" r="2" fill="#3897FF"/>
<circle cx="40" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="20" cy="40" r="2" fill="#007AFF"/>
<circle cx="24" cy="36" r="2" fill="#007AFF"/>
<circle cx="16" cy="48" r="2" fill="#A3CFFF"/>
<circle cx="16" cy="40" r="2" fill="#3897FF"/>
<circle cx="16" cy="36" r="2" fill="#3897FF"/>
</svg>
`, Zve = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="8" y="8" width="48" height="14" rx="3" fill="#007AFF"/>
<rect x="8" y="25" width="36" height="14" rx="3" fill="#007AFF"/>
<rect x="8" y="42" width="24" height="14" rx="3" fill="#007AFF"/>
</svg>
`, e2e = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="48" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="48" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.78"/>
<rect x="48" y="28" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="48" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.5"/>
<rect x="48" y="8" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="38" y="48" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.96"/>
<rect x="38" y="38" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="38" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.63"/>
<rect x="38" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.36"/>
<rect x="38" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.64"/>
<rect x="28" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="28" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.45"/>
<rect x="28" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.28"/>
<rect x="28" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.8"/>
<rect x="28" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.7"/>
<rect x="18" y="48" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.27"/>
<rect x="18" y="38" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.46"/>
<rect x="18" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.74"/>
<rect x="18" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.96"/>
<rect x="18" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.82"/>
<rect x="8" y="48" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="8" y="38" width="8" height="8" rx="2" fill="#007AFF"/>
<rect x="8" y="28" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.33"/>
<rect x="8" y="18" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.12"/>
<rect x="8" y="8" width="8" height="8" rx="2" fill="#007AFF" fill-opacity="0.4"/>
</svg>
`, t2e = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M24.5966 37L26.2869 26.8182H29.7273C30.5227 26.8182 31.1508 26.9607 31.6115 27.2457C32.0755 27.5308 32.3887 27.9169 32.5511 28.4041C32.7169 28.8913 32.75 29.4366 32.6506 30.0398C32.5511 30.6364 32.3374 31.1799 32.0092 31.6705C31.6844 32.161 31.2436 32.5521 30.6868 32.8438C30.1333 33.1354 29.4621 33.2812 28.6733 33.2812H26.2074L26.3864 32.1875H28.8125C29.3561 32.1875 29.8101 32.093 30.1747 31.9041C30.5393 31.7152 30.8243 31.4583 31.0298 31.1335C31.2353 30.8087 31.3712 30.4441 31.4375 30.0398C31.5038 29.6288 31.4872 29.2642 31.3878 28.946C31.2917 28.6245 31.0911 28.3726 30.7862 28.1903C30.4846 28.0047 30.0587 27.9119 29.5085 27.9119H27.3409L25.8295 37H24.5966ZM33.3105 37L34.5833 29.3636H35.7168L35.5179 30.517H35.5975C35.7963 30.1392 36.0996 29.8326 36.5073 29.5973C36.915 29.362 37.3475 29.2443 37.8049 29.2443C37.8944 29.2443 38.0021 29.246 38.128 29.2493C38.254 29.2493 38.3517 29.2543 38.4213 29.2642L38.2225 30.4574C38.1827 30.4474 38.0932 30.4325 37.954 30.4126C37.8148 30.3894 37.6657 30.3778 37.5066 30.3778C37.1354 30.3778 36.7923 30.4557 36.4775 30.6115C36.1626 30.764 35.8991 30.9761 35.687 31.2479C35.4748 31.5163 35.339 31.8229 35.2793 32.1676L34.4838 37H33.3105ZM41.4963 37.1591C40.7638 37.1591 40.1589 36.9967 39.6816 36.6719C39.2044 36.3438 38.8713 35.8864 38.6824 35.2997C38.4934 34.7098 38.4636 34.0237 38.5929 33.2415C38.7221 32.4593 38.979 31.7699 39.3635 31.1733C39.7479 30.5734 40.2269 30.1061 40.8002 29.7713C41.3736 29.4332 42.0034 29.2642 42.6895 29.2642C43.0872 29.2642 43.47 29.3305 43.8379 29.4631C44.2058 29.5956 44.524 29.8111 44.7924 30.1094C45.0609 30.4044 45.2482 30.7955 45.3542 31.2827C45.4603 31.7699 45.4537 32.3698 45.3343 33.0824L45.2548 33.5795H39.3684L39.5275 32.5653H44.2207C44.2969 32.1345 44.277 31.75 44.161 31.4119C44.0484 31.0739 43.8511 30.8071 43.5694 30.6115C43.291 30.416 42.938 30.3182 42.5105 30.3182C42.0697 30.3182 41.6587 30.4375 41.2775 30.6761C40.8964 30.9115 40.5782 31.2098 40.323 31.571C40.0678 31.929 39.9087 32.2936 39.8457 32.6648L39.7065 33.5398C39.6071 34.1728 39.622 34.6766 39.7512 35.0511C39.8838 35.4257 40.1142 35.6958 40.4423 35.8615C40.7704 36.0239 41.1814 36.1051 41.6752 36.1051C41.9901 36.1051 42.2801 36.062 42.5453 35.9759C42.8104 35.8864 43.0474 35.7538 43.2562 35.5781C43.465 35.3991 43.6407 35.1771 43.7832 34.9119L44.8571 35.2301C44.6748 35.6146 44.4179 35.9527 44.0865 36.2443C43.7583 36.5327 43.3739 36.758 42.9331 36.9205C42.4956 37.0795 42.0166 37.1591 41.4963 37.1591ZM49.3638 37.1591C48.7241 37.1591 48.1872 36.9983 47.753 36.6768C47.3188 36.352 47.0123 35.8946 46.8333 35.3047C46.6576 34.7114 46.6361 34.0104 46.7686 33.2017C46.9045 32.3996 47.1581 31.7036 47.5293 31.1136C47.9038 30.5237 48.3629 30.0679 48.9064 29.7464C49.45 29.425 50.0433 29.2642 50.6863 29.2642C51.1834 29.2642 51.5629 29.3471 51.8248 29.5128C52.0899 29.6752 52.2821 29.8608 52.4015 30.0696C52.5208 30.2751 52.6119 30.4441 52.6749 30.5767H52.7743L53.4007 26.8182H54.574L52.8837 37H51.7502L51.949 35.8267H51.8098C51.7005 35.9659 51.548 36.1416 51.3525 36.3537C51.1569 36.5625 50.8984 36.7498 50.5769 36.9155C50.2587 37.0779 49.8543 37.1591 49.3638 37.1591ZM49.6522 36.1051C50.1228 36.1051 50.5437 35.9825 50.915 35.7372C51.2895 35.4886 51.601 35.1456 51.8496 34.7081C52.0982 34.2673 52.2705 33.7585 52.3667 33.1818C52.4628 32.6117 52.4595 32.1129 52.3567 31.6854C52.254 31.2545 52.0568 30.9197 51.7651 30.6811C51.4734 30.4392 51.0873 30.3182 50.6067 30.3182C50.1129 30.3182 49.6837 30.4458 49.3191 30.701C48.9545 30.9529 48.6578 31.2959 48.4292 31.7301C48.2005 32.161 48.0414 32.6449 47.9519 33.1818C47.8624 33.7254 47.8607 34.2192 47.9469 34.6634C48.0331 35.1042 48.2154 35.4555 48.4938 35.7173C48.7755 35.9759 49.1616 36.1051 49.6522 36.1051Z" fill="#007AFF"/>
<path d="M24.5966 20L26.2869 9.81818H29.7273C30.5227 9.81818 31.1508 9.9607 31.6115 10.2457C32.0755 10.5308 32.3887 10.9169 32.5511 11.4041C32.7169 11.8913 32.75 12.4366 32.6506 13.0398C32.5511 13.6364 32.3374 14.1799 32.0092 14.6705C31.6844 15.161 31.2436 15.5521 30.6868 15.8438C30.1333 16.1354 29.4621 16.2812 28.6733 16.2812H26.2074L26.3864 15.1875H28.8125C29.3561 15.1875 29.8101 15.093 30.1747 14.9041C30.5393 14.7152 30.8243 14.4583 31.0298 14.1335C31.2353 13.8087 31.3712 13.4441 31.4375 13.0398C31.5038 12.6288 31.4872 12.2642 31.3878 11.946C31.2917 11.6245 31.0911 11.3726 30.7862 11.1903C30.4846 11.0047 30.0587 10.9119 29.5085 10.9119H27.3409L25.8295 20H24.5966ZM33.3105 20L34.5833 12.3636H35.7168L35.5179 13.517H35.5975C35.7963 13.1392 36.0996 12.8326 36.5073 12.5973C36.915 12.362 37.3475 12.2443 37.8049 12.2443C37.8944 12.2443 38.0021 12.246 38.128 12.2493C38.254 12.2493 38.3517 12.2543 38.4213 12.2642L38.2225 13.4574C38.1827 13.4474 38.0932 13.4325 37.954 13.4126C37.8148 13.3894 37.6657 13.3778 37.5066 13.3778C37.1354 13.3778 36.7923 13.4557 36.4775 13.6115C36.1626 13.764 35.8991 13.9761 35.687 14.2479C35.4748 14.5163 35.339 14.8229 35.2793 15.1676L34.4838 20H33.3105ZM41.4963 20.1591C40.7638 20.1591 40.1589 19.9967 39.6816 19.6719C39.2044 19.3438 38.8713 18.8864 38.6824 18.2997C38.4934 17.7098 38.4636 17.0237 38.5929 16.2415C38.7221 15.4593 38.979 14.7699 39.3635 14.1733C39.7479 13.5734 40.2269 13.1061 40.8002 12.7713C41.3736 12.4332 42.0034 12.2642 42.6895 12.2642C43.0872 12.2642 43.47 12.3305 43.8379 12.4631C44.2058 12.5956 44.524 12.8111 44.7924 13.1094C45.0609 13.4044 45.2482 13.7955 45.3542 14.2827C45.4603 14.7699 45.4537 15.3698 45.3343 16.0824L45.2548 16.5795H39.3684L39.5275 15.5653H44.2207C44.2969 15.1345 44.277 14.75 44.161 14.4119C44.0484 14.0739 43.8511 13.8071 43.5694 13.6115C43.291 13.416 42.938 13.3182 42.5105 13.3182C42.0697 13.3182 41.6587 13.4375 41.2775 13.6761C40.8964 13.9115 40.5782 14.2098 40.323 14.571C40.0678 14.929 39.9087 15.2936 39.8457 15.6648L39.7065 16.5398C39.6071 17.1728 39.622 17.6766 39.7512 18.0511C39.8838 18.4257 40.1142 18.6958 40.4423 18.8615C40.7704 19.0239 41.1814 19.1051 41.6752 19.1051C41.9901 19.1051 42.2801 19.062 42.5453 18.9759C42.8104 18.8864 43.0474 18.7538 43.2562 18.5781C43.465 18.3991 43.6407 18.1771 43.7832 17.9119L44.8571 18.2301C44.6748 18.6146 44.4179 18.9527 44.0865 19.2443C43.7583 19.5327 43.3739 19.758 42.9331 19.9205C42.4956 20.0795 42.0166 20.1591 41.4963 20.1591ZM49.3638 20.1591C48.7241 20.1591 48.1872 19.9983 47.753 19.6768C47.3188 19.352 47.0123 18.8946 46.8333 18.3047C46.6576 17.7114 46.6361 17.0104 46.7686 16.2017C46.9045 15.3996 47.1581 14.7036 47.5293 14.1136C47.9038 13.5237 48.3629 13.0679 48.9064 12.7464C49.45 12.425 50.0433 12.2642 50.6863 12.2642C51.1834 12.2642 51.5629 12.3471 51.8248 12.5128C52.0899 12.6752 52.2821 12.8608 52.4015 13.0696C52.5208 13.2751 52.6119 13.4441 52.6749 13.5767H52.7743L53.4007 9.81818H54.574L52.8837 20H51.7502L51.949 18.8267H51.8098C51.7005 18.9659 51.548 19.1416 51.3525 19.3537C51.1569 19.5625 50.8984 19.7498 50.5769 19.9155C50.2587 20.0779 49.8543 20.1591 49.3638 20.1591ZM49.6522 19.1051C50.1228 19.1051 50.5437 18.9825 50.915 18.7372C51.2895 18.4886 51.601 18.1456 51.8496 17.7081C52.0982 17.2673 52.2705 16.7585 52.3667 16.1818C52.4628 15.6117 52.4595 15.1129 52.3567 14.6854C52.254 14.2545 52.0568 13.9197 51.7651 13.6811C51.4734 13.4392 51.0873 13.3182 50.6067 13.3182C50.1129 13.3182 49.6837 13.4458 49.3191 13.701C48.9545 13.9529 48.6578 14.2959 48.4292 14.7301C48.2005 15.161 48.0414 15.6449 47.9519 16.1818C47.8624 16.7254 47.8607 17.2192 47.9469 17.6634C48.0331 18.1042 48.2154 18.4555 48.4938 18.7173C48.7755 18.9759 49.1616 19.1051 49.6522 19.1051Z" fill="#007AFF" fill-opacity="0.25"/>
<path d="M24.5966 54L26.2869 43.8182H29.7273C30.5227 43.8182 31.1508 43.9607 31.6115 44.2457C32.0755 44.5308 32.3887 44.9169 32.5511 45.4041C32.7169 45.8913 32.75 46.4366 32.6506 47.0398C32.5511 47.6364 32.3374 48.1799 32.0092 48.6705C31.6844 49.161 31.2436 49.5521 30.6868 49.8438C30.1333 50.1354 29.4621 50.2812 28.6733 50.2812H26.2074L26.3864 49.1875H28.8125C29.3561 49.1875 29.8101 49.093 30.1747 48.9041C30.5393 48.7152 30.8243 48.4583 31.0298 48.1335C31.2353 47.8087 31.3712 47.4441 31.4375 47.0398C31.5038 46.6288 31.4872 46.2642 31.3878 45.946C31.2917 45.6245 31.0911 45.3726 30.7862 45.1903C30.4846 45.0047 30.0587 44.9119 29.5085 44.9119H27.3409L25.8295 54H24.5966ZM33.3105 54L34.5833 46.3636H35.7168L35.5179 47.517H35.5975C35.7963 47.1392 36.0996 46.8326 36.5073 46.5973C36.915 46.362 37.3475 46.2443 37.8049 46.2443C37.8944 46.2443 38.0021 46.246 38.128 46.2493C38.254 46.2493 38.3517 46.2543 38.4213 46.2642L38.2225 47.4574C38.1827 47.4474 38.0932 47.4325 37.954 47.4126C37.8148 47.3894 37.6657 47.3778 37.5066 47.3778C37.1354 47.3778 36.7923 47.4557 36.4775 47.6115C36.1626 47.764 35.8991 47.9761 35.687 48.2479C35.4748 48.5163 35.339 48.8229 35.2793 49.1676L34.4838 54H33.3105ZM41.4963 54.1591C40.7638 54.1591 40.1589 53.9967 39.6816 53.6719C39.2044 53.3438 38.8713 52.8864 38.6824 52.2997C38.4934 51.7098 38.4636 51.0237 38.5929 50.2415C38.7221 49.4593 38.979 48.7699 39.3635 48.1733C39.7479 47.5734 40.2269 47.1061 40.8002 46.7713C41.3736 46.4332 42.0034 46.2642 42.6895 46.2642C43.0872 46.2642 43.47 46.3305 43.8379 46.4631C44.2058 46.5956 44.524 46.8111 44.7924 47.1094C45.0609 47.4044 45.2482 47.7955 45.3542 48.2827C45.4603 48.7699 45.4537 49.3698 45.3343 50.0824L45.2548 50.5795H39.3684L39.5275 49.5653H44.2207C44.2969 49.1345 44.277 48.75 44.161 48.4119C44.0484 48.0739 43.8511 47.8071 43.5694 47.6115C43.291 47.416 42.938 47.3182 42.5105 47.3182C42.0697 47.3182 41.6587 47.4375 41.2775 47.6761C40.8964 47.9115 40.5782 48.2098 40.323 48.571C40.0678 48.929 39.9087 49.2936 39.8457 49.6648L39.7065 50.5398C39.6071 51.1728 39.622 51.6766 39.7512 52.0511C39.8838 52.4257 40.1142 52.6958 40.4423 52.8615C40.7704 53.0239 41.1814 53.1051 41.6752 53.1051C41.9901 53.1051 42.2801 53.062 42.5453 52.9759C42.8104 52.8864 43.0474 52.7538 43.2562 52.5781C43.465 52.3991 43.6407 52.1771 43.7832 51.9119L44.8571 52.2301C44.6748 52.6146 44.4179 52.9527 44.0865 53.2443C43.7583 53.5327 43.3739 53.758 42.9331 53.9205C42.4956 54.0795 42.0166 54.1591 41.4963 54.1591ZM49.3638 54.1591C48.7241 54.1591 48.1872 53.9983 47.753 53.6768C47.3188 53.352 47.0123 52.8946 46.8333 52.3047C46.6576 51.7114 46.6361 51.0104 46.7686 50.2017C46.9045 49.3996 47.1581 48.7036 47.5293 48.1136C47.9038 47.5237 48.3629 47.0679 48.9064 46.7464C49.45 46.425 50.0433 46.2642 50.6863 46.2642C51.1834 46.2642 51.5629 46.3471 51.8248 46.5128C52.0899 46.6752 52.2821 46.8608 52.4015 47.0696C52.5208 47.2751 52.6119 47.4441 52.6749 47.5767H52.7743L53.4007 43.8182H54.574L52.8837 54H51.7502L51.949 52.8267H51.8098C51.7005 52.9659 51.548 53.1416 51.3525 53.3537C51.1569 53.5625 50.8984 53.7498 50.5769 53.9155C50.2587 54.0779 49.8543 54.1591 49.3638 54.1591ZM49.6522 53.1051C50.1228 53.1051 50.5437 52.9825 50.915 52.7372C51.2895 52.4886 51.601 52.1456 51.8496 51.7081C52.0982 51.2673 52.2705 50.7585 52.3667 50.1818C52.4628 49.6117 52.4595 49.1129 52.3567 48.6854C52.254 48.2545 52.0568 47.9197 51.7651 47.6811C51.4734 47.4392 51.0873 47.3182 50.6067 47.3182C50.1129 47.3182 49.6837 47.4458 49.3191 47.701C48.9545 47.9529 48.6578 48.2959 48.4292 48.7301C48.2005 49.161 48.0414 49.6449 47.9519 50.1818C47.8624 50.7254 47.8607 51.2192 47.9469 51.6634C48.0331 52.1042 48.2154 52.4555 48.4938 52.7173C48.7755 52.9759 49.1616 53.1051 49.6522 53.1051Z" fill="#007AFF" fill-opacity="0.25"/>
<rect x="9" y="10" width="10" height="10" rx="3" fill="#007AFF" fill-opacity="0.25"/>
<rect x="9" y="27" width="10" height="10" rx="3" fill="#007AFF"/>
<rect x="9" y="44" width="10" height="10" rx="3" fill="#007AFF" fill-opacity="0.25"/>
</svg>
`, n2e = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M28.1666 45.7042C28.9268 45.8901 29.611 45.5001 29.8329 44.7506L36.9814 20.6115C37.1728 19.9366 36.8385 19.2589 36.0783 19.0547C35.3333 18.8689 34.6979 19.1477 34.4425 20.0235L27.3365 44.0276C27.1175 44.7804 27.3579 45.5001 28.1666 45.7042Z" fill="black"/>
<path d="M12 32.3568C12 32.7499 12.1764 33.1396 12.5046 33.4216L22.0655 41.9466C22.6825 42.4776 23.4794 42.4744 23.9719 41.9287C24.4765 41.3647 24.3975 40.5639 23.829 40.0662L15.214 32.3568L23.829 24.6476C24.3975 24.1496 24.4765 23.3488 23.9719 22.7851C23.4794 22.2391 22.6825 22.2362 22.0655 22.7669L12.5046 31.2922C12.1764 31.5742 12 31.9639 12 32.3568ZM52.1638 32.3568C52.1638 31.9639 52.0027 31.5742 51.6742 31.2922L42.1015 22.7669C41.481 22.2362 40.6997 22.2391 40.1948 22.7851C39.6871 23.3488 39.7663 24.1496 40.3378 24.6476L48.968 32.3568L40.3378 40.0662C39.7663 40.5639 39.6871 41.3647 40.1948 41.9287C40.6997 42.4744 41.481 42.4776 42.1015 41.9466L51.6742 33.4216C52.0027 33.1396 52.1638 32.7499 52.1638 32.3568Z" fill="black"/>
</svg>
`, r2e = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 33H22V53C22 54.6569 20.6569 56 19 56H11C9.34315 56 8 54.6569 8 53V33Z" fill="#34C759"/>
<path d="M8 19C8 17.3431 9.34315 16 11 16H19C20.6569 16 22 17.3431 22 19V34H8V19Z" fill="#007AFF"/>
<path d="M25 39H39V53C39 54.6569 37.6569 56 36 56H28C26.3431 56 25 54.6569 25 53V39Z" fill="#34C759"/>
<path d="M42 32H56V53C56 54.6569 54.6569 56 53 56H45C43.3431 56 42 54.6569 42 53V32Z" fill="#34C759"/>
<path d="M25 29C25 27.3431 26.3431 26 28 26H36C37.6569 26 39 27.3431 39 29V40H25V29Z" fill="#3C82F6"/>
<path d="M42 16C42 14.3431 43.3431 13 45 13H53C54.6569 13 56 14.3431 56 16V33H42V16Z" fill="#007AFF"/>
</svg>
`, i2e = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="8" y="32" width="14" height="24" rx="3" fill="#007AFF"/>
<rect x="25" y="12" width="14" height="44" rx="3" fill="#007AFF"/>
<rect x="42" y="24" width="14" height="32" rx="3" fill="#007AFF"/>
</svg>
`, s2e = {
  "chart-boxplot": Qve,
  "chart-h-bar": Zve,
  "chart-heatmap": e2e,
  "chart-embedding": Jve,
  "chart-stacked": r2e,
  "chart-v-histogram": i2e,
  "chart-spec": n2e,
  "chart-predicates": t2e
};
var o2e = /* @__PURE__ */ ge('<div class="w-12 h-12"><!></div>');
function l2e(t, e) {
  it(e, !0);
  function n(s, o) {
    s = s.replace("xmlns", 'style="width:100%;height:100%" xmlns');
    let l = o == "dark" ? { black: No.slate[400] } : { black: No.slate[500] };
    for (let a in l)
      s = s.replaceAll(a, l[a]);
    return s;
  }
  var r = o2e(), i = J(r);
  zY(i, () => n(s2e[e.type] ?? "", e.colorScheme ?? "light")), Q(r), X(t, r), st();
}
var a2e = /* @__PURE__ */ ge("<button><!></button>"), u2e = /* @__PURE__ */ ge('<span class="text-slate-500 dark:text-slate-400"> </span> <!>', 1), c2e = /* @__PURE__ */ ge('<div class="w-full h-64"><!></div>'), f2e = /* @__PURE__ */ ge("<!> <!>", 1), h2e = /* @__PURE__ */ ge('<div class="border-t border-b border-dotted border-slate-400 dark:border-slate-500 py-2 my-1"><div class="-m-2 rounded-md"><!></div></div>'), d2e = /* @__PURE__ */ ge("<div> </div>"), p2e = /* @__PURE__ */ ge('<div class="p-2 flex flex-col gap-2"><div class="flex flex-wrap gap-2"></div> <div> </div> <!> <!> <div><button>Confirm</button></div> <!></div>');
function g2e(t, e) {
  it(e, !0);
  const n = () => gi(o, "$colorScheme", r), [r, i] = Xs();
  let { columns: s, colorScheme: o } = e.context, l = oke(), a = /* @__PURE__ */ Ee(l[0]), u = /* @__PURE__ */ Ee(ho({})), c = /* @__PURE__ */ Ee(!1), f = /* @__PURE__ */ Ee(null), d = /* @__PURE__ */ Ee(null);
  pt(() => {
    x(a);
    let M = Gs(() => x(u)), L = {};
    for (let N of x(a).ui)
      if ("field" in N) {
        let j = b(s, N.field.types), U = M[N.field.key];
        U != null && j.findIndex(({ name: H }) => H == U) >= 0 && (L[N.field.key] = U);
      }
    ae(u, L, !0);
  }), pt(() => {
    try {
      let M = m();
      if (M == null) {
        ae(c, !1), ae(d, null), ae(f, null);
        return;
      }
      let L = x(a).create(M, { table: e.context.table, id: e.context.id });
      ae(c, L != null), ae(d, L), ae(f, null);
    } catch (M) {
      ae(c, M.toString(), !0);
    }
  });
  function p() {
    x(d) != null && (e.onSpecChange(x(d), "replace"), e.onStateChange(x(f) ?? {}, "replace"));
  }
  function m() {
    let M = { ...x(u) };
    for (let L of x(a).ui)
      if ("field" in L) {
        let N = y(M[L.field.key]);
        if (L.field.required && N == null)
          return;
        M[L.field.key] = N;
      }
    return M;
  }
  function y(M) {
    let L = s.find((N) => N.name == M);
    if (L == null || L.jsType == null)
      return null;
    switch (L.jsType) {
      case "number":
        return { name: L.name, type: "continuous" };
      case "string":
        return { name: L.name, type: "discrete" };
      case "string[]":
        return { name: L.name, type: "discrete[]" };
      default:
        return null;
    }
  }
  function b(M, L) {
    return L == null ? M.filter((N) => N.jsType != null) : M.filter((N) => N.jsType != null && L.indexOf(N.jsType) >= 0);
  }
  var v = p2e(), _ = J(v);
  Bt(_, 21, () => l, fn, (M, L) => {
    const N = /* @__PURE__ */ K(() => x(a) == x(L));
    var j = a2e();
    j.__click = () => {
      ae(a, x(L));
    };
    let U;
    var H = J(j);
    l2e(H, {
      get type() {
        return x(L).icon;
      },
      get colorScheme() {
        return n();
      }
    }), Q(j), ke(() => {
      te(j, "title", x(L).description), U = er(j, 1, "rounded-md border border-slate-200 dark:border-slate-700", null, U, {
        "!border-slate-600": x(N),
        "dark:!border-slate-400": x(N),
        "!bg-slate-100": x(N),
        "dark:!bg-slate-700": x(N)
      });
    }), X(M, j);
  }), Q(_);
  var k = ue(_, 2), S = J(k, !0);
  Q(k);
  var C = ue(k, 2);
  Bt(C, 17, () => x(a).ui, fn, (M, L) => {
    var N = f2e(), j = We(N);
    {
      var U = (re) => {
        const se = /* @__PURE__ */ K(() => x(L).field.key);
        var oe = u2e(), ne = We(oe), ce = J(ne, !0);
        Q(ne);
        var we = ue(ne, 2);
        {
          let Me = /* @__PURE__ */ K(() => x(u)[x(se)] ?? null), Pe = /* @__PURE__ */ K(() => b(s, x(L).field.types).map((Ce) => ({ value: Ce.name, label: `${Ce.name} (${Ce.type})` })));
          Of(we, {
            get value() {
              return x(Me);
            },
            onChange: (Ce) => x(u)[x(se)] = Ce,
            placeholder: "(select field)",
            class: "w-full",
            get options() {
              return x(Pe);
            }
          });
        }
        ke(() => ut(ce, x(L).field.label)), X(re, oe);
      };
      Fe(j, (re) => {
        "field" in x(L) && re(U);
      });
    }
    var H = ue(j, 2);
    {
      var G = (re) => {
        const se = /* @__PURE__ */ K(() => x(L).code.key);
        var oe = c2e(), ne = J(oe);
        {
          let ce = /* @__PURE__ */ K(() => x(L).code.language ?? "plain");
          D5(ne, {
            class: "w-full h-full",
            get value() {
              return x(u)[x(se)];
            },
            onChange: (we) => x(u)[x(se)] = we,
            get colorScheme() {
              return n();
            },
            get language() {
              return x(ce);
            }
          });
        }
        Q(oe), X(re, oe);
      };
      Fe(H, (re) => {
        "code" in x(L) && re(G);
      });
    }
    X(M, N);
  });
  var E = ue(C, 2);
  {
    var A = (M) => {
      var L = kn(), N = We(L);
      CT(N, () => x(d), (j) => {
        var U = h2e(), H = J(U), G = J(H);
        {
          let re = /* @__PURE__ */ K(() => x(f) ?? {});
          uj(G, {
            get context() {
              return e.context;
            },
            get spec() {
              return x(d);
            },
            get state() {
              return x(re);
            },
            width: "container",
            onStateChange: (se, oe = "merge") => {
              dd(x(f) ?? {}, se, oe, (ne) => ae(f, ne));
            },
            onSpecChange: (se, oe = "merge") => {
              dd(x(d) ?? {}, se, oe, (ne) => ae(d, ne));
            }
          });
        }
        Q(H), Q(U), X(j, U);
      }), X(M, L);
    };
    Fe(E, (M) => {
      x(d) != null && x(a).preview !== !1 && M(A);
    });
  }
  var O = ue(E, 2), T = J(O);
  let $;
  T.__click = p, Q(O);
  var P = ue(O, 2);
  {
    var B = (M) => {
      var L = d2e(), N = J(L, !0);
      Q(L), ke(() => ut(N, x(c))), X(M, L);
    };
    Fe(P, (M) => {
      typeof x(c) == "string" && x(c).trim() != "" && M(B);
    });
  }
  Q(v), ke(() => {
    ut(S, x(a).description), $ = er(T, 1, "px-2 h-8 w-24 rounded-md text-white text-sm", null, $, {
      "bg-blue-500": x(c) === !0,
      "bg-gray-300": x(c) !== !0,
      "dark:text-gray-500": x(c) !== !0,
      "dark:bg-gray-700": x(c) !== !0
    }), T.disabled = x(c) !== !0;
  }), X(t, v), st(), i();
}
ir(["click"]);
var m2e = /* @__PURE__ */ Dt('<line class="stroke-orange-500"></line>'), y2e = /* @__PURE__ */ Dt('<circle class="fill-orange-500 stroke-orange-700 stroke-2"></circle>'), b2e = /* @__PURE__ */ Dt("<svg><g><!><!></g></svg>");
function v2e(t, e) {
  it(e, !0);
  var n = b2e(), r = J(n), i = J(r);
  {
    var s = (l) => {
      const a = /* @__PURE__ */ K(() => e.proxy.location(e.center.x, e.center.y));
      var u = kn(), c = We(u);
      Bt(c, 17, () => e.points ?? [], fn, (f, d) => {
        const p = /* @__PURE__ */ K(() => e.proxy.location(x(d).x, x(d).y));
        var m = m2e();
        ke(() => {
          te(m, "x1", x(a).x), te(m, "y1", x(a).y), te(m, "x2", x(p).x), te(m, "y2", x(p).y);
        }), X(f, m);
      }), X(l, u);
    };
    Fe(i, (l) => {
      e.center != null && l(s);
    });
  }
  var o = ue(i);
  Bt(o, 17, () => e.points ?? [], fn, (l, a) => {
    const u = /* @__PURE__ */ K(() => e.proxy.location(x(a).x, x(a).y));
    var c = y2e();
    te(c, "r", 4), ke(() => {
      te(c, "cx", x(u).x), te(c, "cy", x(u).y);
    }), X(l, c);
  }), Q(r), Q(n), ke(() => {
    te(n, "width", e.proxy.width), te(n, "height", e.proxy.height);
  }), X(t, n), st();
}
function x2e(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
function w2e(t) {
  const e = atob(t);
  return new Uint8Array([...e].map((n) => n.charCodeAt(0)));
}
function _h(t, e) {
  if (t.length < e.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (t[n] != e[n])
      return !1;
  return !0;
}
function mO(t) {
  return _h(t, [137, 80, 78, 71, 13, 10, 26, 10]) ? "image/png" : _h(t, [255, 216, 255]) ? "image/jpeg" : _h(t, [73, 73, 42, 0]) ? "image/tiff" : _h(t, [66, 77]) ? "image/bmp" : _h(t, [71, 73, 70, 56, 55, 97]) || _h(t, [71, 73, 70, 56, 55, 97]) ? "image/gif" : "application/octet-stream";
}
function M$(t) {
  if (t == null)
    return null;
  if (typeof t == "string")
    return t.startsWith("data:") ? t : `data:${mO(w2e(t))};base64,` + t;
  {
    let e = null;
    if (t.bytes && t.bytes instanceof Uint8Array && (e = t.bytes), t instanceof Uint8Array && (e = t), e != null)
      return `data:${mO(e)};base64,` + x2e(e);
  }
  return null;
}
class _2e {
  element;
  constructor(e, n) {
    this.element = e, this.update(n);
  }
  update(e) {
    if (e.value == null) {
      this.element.innerText = "(null)";
      return;
    }
    let n = M$(e.value);
    if (n != null) {
      let r = e.size ?? 100, i = document.createElement("img");
      i.src = n, i.style.maxHeight = r + "px", i.style.maxWidth = r + "px", this.element.replaceChildren(i);
    } else
      this.element.innerText = "(unknown)";
  }
}
function P$(t, e) {
  try {
    return JSON.stringify(
      t,
      (n, r) => r instanceof Object && ArrayBuffer.isView(r) ? Array.from(r) : r,
      e
    );
  } catch {
    return "(invalid)";
  }
}
class k2e {
  element;
  constructor(e, n) {
    this.element = e, this.update(n);
  }
  update(e) {
    let n = document.createElement("pre");
    n.className = "text-sm", n.style.whiteSpace = "pre-wrap", n.style.wordBreak = "break-all", n.innerText = P$(e.value, 2), this.element.replaceChildren(n);
  }
}
function Z5() {
  return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
}
var Qf = Z5();
function I$(t) {
  Qf = t;
}
var zp = { exec: () => null };
function ln(t, e = "") {
  let n = typeof t == "string" ? t : t.source, r = { replace: (i, s) => {
    let o = typeof s == "string" ? s : s.source;
    return o = o.replace(Pi.caret, "$1"), n = n.replace(i, o), r;
  }, getRegex: () => new RegExp(n, e) };
  return r;
}
var C2e = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return !1;
  }
})(), Pi = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`), htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i") }, S2e = /^(?:[ \t]*(?:\n|$))+/, A2e = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, E2e = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, xm = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, D2e = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, eC = /(?:[*+-]|\d{1,9}[.)])/, N$ = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, B$ = ln(N$).replace(/bull/g, eC).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), O2e = ln(N$).replace(/bull/g, eC).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), tC = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, F2e = /^[^\n]+/, nC = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, T2e = ln(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", nC).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), R2e = ln(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, eC).getRegex(), L2 = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", rC = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, M2e = ln("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", rC).replace("tag", L2).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), L$ = ln(tC).replace("hr", xm).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", L2).getRegex(), P2e = ln(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", L$).getRegex(), iC = { blockquote: P2e, code: A2e, def: T2e, fences: E2e, heading: D2e, hr: xm, html: M2e, lheading: B$, list: R2e, newline: S2e, paragraph: L$, table: zp, text: F2e }, yO = ln("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", xm).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", L2).getRegex(), I2e = { ...iC, lheading: O2e, table: yO, paragraph: ln(tC).replace("hr", xm).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", yO).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", L2).getRegex() }, N2e = { ...iC, html: ln(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", rC).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: zp, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: ln(tC).replace("hr", xm).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", B$).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, B2e = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, L2e = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, $$ = /^( {2,}|\\)\n(?!\s*$)/, $2e = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, $2 = /[\p{P}\p{S}]/u, sC = /[\s\p{P}\p{S}]/u, z$ = /[^\s\p{P}\p{S}]/u, z2e = ln(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, sC).getRegex(), j$ = /(?!~)[\p{P}\p{S}]/u, j2e = /(?!~)[\s\p{P}\p{S}]/u, q2e = /(?:[^\s\p{P}\p{S}]|~)/u, U2e = ln(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", C2e ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), q$ = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, H2e = ln(q$, "u").replace(/punct/g, $2).getRegex(), V2e = ln(q$, "u").replace(/punct/g, j$).getRegex(), U$ = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", W2e = ln(U$, "gu").replace(/notPunctSpace/g, z$).replace(/punctSpace/g, sC).replace(/punct/g, $2).getRegex(), G2e = ln(U$, "gu").replace(/notPunctSpace/g, q2e).replace(/punctSpace/g, j2e).replace(/punct/g, j$).getRegex(), K2e = ln("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, z$).replace(/punctSpace/g, sC).replace(/punct/g, $2).getRegex(), Y2e = ln(/\\(punct)/, "gu").replace(/punct/g, $2).getRegex(), X2e = ln(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Q2e = ln(rC).replace("(?:-->|$)", "-->").getRegex(), J2e = ln("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Q2e).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), mv = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, Z2e = ln(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", mv).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), H$ = ln(/^!?\[(label)\]\[(ref)\]/).replace("label", mv).replace("ref", nC).getRegex(), V$ = ln(/^!?\[(ref)\](?:\[\])?/).replace("ref", nC).getRegex(), exe = ln("reflink|nolink(?!\\()", "g").replace("reflink", H$).replace("nolink", V$).getRegex(), bO = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, oC = { _backpedal: zp, anyPunctuation: Y2e, autolink: X2e, blockSkip: U2e, br: $$, code: L2e, del: zp, emStrongLDelim: H2e, emStrongRDelimAst: W2e, emStrongRDelimUnd: K2e, escape: B2e, link: Z2e, nolink: V$, punctuation: z2e, reflink: H$, reflinkSearch: exe, tag: J2e, text: $2e, url: zp }, txe = { ...oC, link: ln(/^!?\[(label)\]\((.*?)\)/).replace("label", mv).getRegex(), reflink: ln(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", mv).getRegex() }, xk = { ...oC, emStrongRDelimAst: G2e, emStrongLDelim: V2e, url: ln(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", bO).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: ln(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", bO).getRegex() }, nxe = { ...xk, br: ln($$).replace("{2,}", "*").getRegex(), text: ln(xk.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, vy = { normal: iC, gfm: I2e, pedantic: N2e }, op = { normal: oC, gfm: xk, breaks: nxe, pedantic: txe }, rxe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, vO = (t) => rxe[t];
function vl(t, e) {
  if (e) {
    if (Pi.escapeTest.test(t)) return t.replace(Pi.escapeReplace, vO);
  } else if (Pi.escapeTestNoEncode.test(t)) return t.replace(Pi.escapeReplaceNoEncode, vO);
  return t;
}
function xO(t) {
  try {
    t = encodeURI(t).replace(Pi.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function wO(t, e) {
  let n = t.replace(Pi.findPipe, (s, o, l) => {
    let a = !1, u = o;
    for (; --u >= 0 && l[u] === "\\"; ) a = !a;
    return a ? "|" : " |";
  }), r = n.split(Pi.splitPipe), i = 0;
  if (r[0].trim() || r.shift(), r.length > 0 && !r.at(-1)?.trim() && r.pop(), e) if (r.length > e) r.splice(e);
  else for (; r.length < e; ) r.push("");
  for (; i < r.length; i++) r[i] = r[i].trim().replace(Pi.slashPipe, "|");
  return r;
}
function lp(t, e, n) {
  let r = t.length;
  if (r === 0) return "";
  let i = 0;
  for (; i < r && t.charAt(r - i - 1) === e; )
    i++;
  return t.slice(0, r - i);
}
function ixe(t, e) {
  if (t.indexOf(e[1]) === -1) return -1;
  let n = 0;
  for (let r = 0; r < t.length; r++) if (t[r] === "\\") r++;
  else if (t[r] === e[0]) n++;
  else if (t[r] === e[1] && (n--, n < 0)) return r;
  return n > 0 ? -2 : -1;
}
function _O(t, e, n, r, i) {
  let s = e.href, o = e.title || null, l = t[1].replace(i.other.outputLinkReplace, "$1");
  r.state.inLink = !0;
  let a = { type: t[0].charAt(0) === "!" ? "image" : "link", raw: n, href: s, title: o, text: l, tokens: r.inlineTokens(l) };
  return r.state.inLink = !1, a;
}
function sxe(t, e, n) {
  let r = t.match(n.other.indentCodeCompensation);
  if (r === null) return e;
  let i = r[1];
  return e.split(`
`).map((s) => {
    let o = s.match(n.other.beginningSpace);
    if (o === null) return s;
    let [l] = o;
    return l.length >= i.length ? s.slice(i.length) : s;
  }).join(`
`);
}
var yv = class {
  options;
  rules;
  lexer;
  constructor(t) {
    this.options = t || Qf;
  }
  space(t) {
    let e = this.rules.block.newline.exec(t);
    if (e && e[0].length > 0) return { type: "space", raw: e[0] };
  }
  code(t) {
    let e = this.rules.block.code.exec(t);
    if (e) {
      let n = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: e[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : lp(n, `
`) };
    }
  }
  fences(t) {
    let e = this.rules.block.fences.exec(t);
    if (e) {
      let n = e[0], r = sxe(n, e[3] || "", this.rules);
      return { type: "code", raw: n, lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2], text: r };
    }
  }
  heading(t) {
    let e = this.rules.block.heading.exec(t);
    if (e) {
      let n = e[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r = lp(n, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
      }
      return { type: "heading", raw: e[0], depth: e[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(t) {
    let e = this.rules.block.hr.exec(t);
    if (e) return { type: "hr", raw: lp(e[0], `
`) };
  }
  blockquote(t) {
    let e = this.rules.block.blockquote.exec(t);
    if (e) {
      let n = lp(e[0], `
`).split(`
`), r = "", i = "", s = [];
      for (; n.length > 0; ) {
        let o = !1, l = [], a;
        for (a = 0; a < n.length; a++) if (this.rules.other.blockquoteStart.test(n[a])) l.push(n[a]), o = !0;
        else if (!o) l.push(n[a]);
        else break;
        n = n.slice(a);
        let u = l.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${u}` : u, i = i ? `${i}
${c}` : c;
        let f = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(c, s, !0), this.lexer.state.top = f, n.length === 0) break;
        let d = s.at(-1);
        if (d?.type === "code") break;
        if (d?.type === "blockquote") {
          let p = d, m = p.raw + `
` + n.join(`
`), y = this.blockquote(m);
          s[s.length - 1] = y, r = r.substring(0, r.length - p.raw.length) + y.raw, i = i.substring(0, i.length - p.text.length) + y.text;
          break;
        } else if (d?.type === "list") {
          let p = d, m = p.raw + `
` + n.join(`
`), y = this.list(m);
          s[s.length - 1] = y, r = r.substring(0, r.length - d.raw.length) + y.raw, i = i.substring(0, i.length - p.raw.length) + y.raw, n = m.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r, tokens: s, text: i };
    }
  }
  list(t) {
    let e = this.rules.block.list.exec(t);
    if (e) {
      let n = e[1].trim(), r = n.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: !1, items: [] };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = !1;
      for (; t; ) {
        let a = !1, u = "", c = "";
        if (!(e = s.exec(t)) || this.rules.block.hr.test(t)) break;
        u = e[0], t = t.substring(u.length);
        let f = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (v) => " ".repeat(3 * v.length)), d = t.split(`
`, 1)[0], p = !f.trim(), m = 0;
        if (this.options.pedantic ? (m = 2, c = f.trimStart()) : p ? m = e[1].length + 1 : (m = e[2].search(this.rules.other.nonSpaceChar), m = m > 4 ? 1 : m, c = f.slice(m), m += e[1].length), p && this.rules.other.blankLine.test(d) && (u += d + `
`, t = t.substring(d.length + 1), a = !0), !a) {
          let v = this.rules.other.nextBulletRegex(m), _ = this.rules.other.hrRegex(m), k = this.rules.other.fencesBeginRegex(m), S = this.rules.other.headingBeginRegex(m), C = this.rules.other.htmlBeginRegex(m);
          for (; t; ) {
            let E = t.split(`
`, 1)[0], A;
            if (d = E, this.options.pedantic ? (d = d.replace(this.rules.other.listReplaceNesting, "  "), A = d) : A = d.replace(this.rules.other.tabCharGlobal, "    "), k.test(d) || S.test(d) || C.test(d) || v.test(d) || _.test(d)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= m || !d.trim()) c += `
` + A.slice(m);
            else {
              if (p || f.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || k.test(f) || S.test(f) || _.test(f)) break;
              c += `
` + d;
            }
            !p && !d.trim() && (p = !0), u += E + `
`, t = t.substring(E.length + 1), f = A.slice(m);
          }
        }
        i.loose || (o ? i.loose = !0 : this.rules.other.doubleBlankLine.test(u) && (o = !0));
        let y = null, b;
        this.options.gfm && (y = this.rules.other.listIsTask.exec(c), y && (b = y[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: u, task: !!y, checked: b, loose: !1, text: c, tokens: [] }), i.raw += u;
      }
      let l = i.items.at(-1);
      if (l) l.raw = l.raw.trimEnd(), l.text = l.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let a = 0; a < i.items.length; a++) if (this.lexer.state.top = !1, i.items[a].tokens = this.lexer.blockTokens(i.items[a].text, []), !i.loose) {
        let u = i.items[a].tokens.filter((f) => f.type === "space"), c = u.length > 0 && u.some((f) => this.rules.other.anyLine.test(f.raw));
        i.loose = c;
      }
      if (i.loose) for (let a = 0; a < i.items.length; a++) i.items[a].loose = !0;
      return i;
    }
  }
  html(t) {
    let e = this.rules.block.html.exec(t);
    if (e) return { type: "html", block: !0, raw: e[0], pre: e[1] === "pre" || e[1] === "script" || e[1] === "style", text: e[0] };
  }
  def(t) {
    let e = this.rules.block.def.exec(t);
    if (e) {
      let n = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return { type: "def", tag: n, raw: e[0], href: r, title: i };
    }
  }
  table(t) {
    let e = this.rules.block.table.exec(t);
    if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
    let n = wO(e[1]), r = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = e[3]?.trim() ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: e[0], header: [], align: [], rows: [] };
    if (n.length === r.length) {
      for (let o of r) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < n.length; o++) s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: !0, align: s.align[o] });
      for (let o of i) s.rows.push(wO(o, s.header.length).map((l, a) => ({ text: l, tokens: this.lexer.inline(l), header: !1, align: s.align[a] })));
      return s;
    }
  }
  lheading(t) {
    let e = this.rules.block.lheading.exec(t);
    if (e) return { type: "heading", raw: e[0], depth: e[2].charAt(0) === "=" ? 1 : 2, text: e[1], tokens: this.lexer.inline(e[1]) };
  }
  paragraph(t) {
    let e = this.rules.block.paragraph.exec(t);
    if (e) {
      let n = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return { type: "paragraph", raw: e[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(t) {
    let e = this.rules.block.text.exec(t);
    if (e) return { type: "text", raw: e[0], text: e[0], tokens: this.lexer.inline(e[0]) };
  }
  escape(t) {
    let e = this.rules.inline.escape.exec(t);
    if (e) return { type: "escape", raw: e[0], text: e[1] };
  }
  tag(t) {
    let e = this.rules.inline.tag.exec(t);
    if (e) return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: e[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: e[0] };
  }
  link(t) {
    let e = this.rules.inline.link.exec(t);
    if (e) {
      let n = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = lp(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = ixe(e[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let o = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + s;
          e[2] = e[2].substring(0, s), e[0] = e[0].substring(0, o).trim(), e[3] = "";
        }
      }
      let r = e[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r);
        s && (r = s[1], i = s[3]);
      } else i = e[3] ? e[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), _O(e, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, e[0], this.lexer, this.rules);
    }
  }
  reflink(t, e) {
    let n;
    if ((n = this.rules.inline.reflink.exec(t)) || (n = this.rules.inline.nolink.exec(t))) {
      let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = e[r.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return _O(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(t, e, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(t);
    if (!(!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) && (!(r[1] || r[2]) || !n || this.rules.inline.punctuation.exec(n))) {
      let i = [...r[0]].length - 1, s, o, l = i, a = 0, u = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (u.lastIndex = 0, e = e.slice(-1 * t.length + i); (r = u.exec(e)) != null; ) {
        if (s = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !s) continue;
        if (o = [...s].length, r[3] || r[4]) {
          l += o;
          continue;
        } else if ((r[5] || r[6]) && i % 3 && !((i + o) % 3)) {
          a += o;
          continue;
        }
        if (l -= o, l > 0) continue;
        o = Math.min(o, o + l + a);
        let c = [...r[0]][0].length, f = t.slice(0, i + r.index + c + o);
        if (Math.min(i, o) % 2) {
          let p = f.slice(1, -1);
          return { type: "em", raw: f, text: p, tokens: this.lexer.inlineTokens(p) };
        }
        let d = f.slice(2, -2);
        return { type: "strong", raw: f, text: d, tokens: this.lexer.inlineTokens(d) };
      }
    }
  }
  codespan(t) {
    let e = this.rules.inline.code.exec(t);
    if (e) {
      let n = e[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: e[0], text: n };
    }
  }
  br(t) {
    let e = this.rules.inline.br.exec(t);
    if (e) return { type: "br", raw: e[0] };
  }
  del(t) {
    let e = this.rules.inline.del.exec(t);
    if (e) return { type: "del", raw: e[0], text: e[2], tokens: this.lexer.inlineTokens(e[2]) };
  }
  autolink(t) {
    let e = this.rules.inline.autolink.exec(t);
    if (e) {
      let n, r;
      return e[2] === "@" ? (n = e[1], r = "mailto:" + n) : (n = e[1], r = n), { type: "link", raw: e[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(t) {
    let e;
    if (e = this.rules.inline.url.exec(t)) {
      let n, r;
      if (e[2] === "@") n = e[0], r = "mailto:" + n;
      else {
        let i;
        do
          i = e[0], e[0] = this.rules.inline._backpedal.exec(e[0])?.[0] ?? "";
        while (i !== e[0]);
        n = e[0], e[1] === "www." ? r = "http://" + e[0] : r = e[0];
      }
      return { type: "link", raw: e[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(t) {
    let e = this.rules.inline.text.exec(t);
    if (e) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: e[0], text: e[0], escaped: n };
    }
  }
}, $o = class wk {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Qf, this.options.tokenizer = this.options.tokenizer || new yv(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    let n = { other: Pi, block: vy.normal, inline: op.normal };
    this.options.pedantic ? (n.block = vy.pedantic, n.inline = op.pedantic) : this.options.gfm && (n.block = vy.gfm, this.options.breaks ? n.inline = op.breaks : n.inline = op.gfm), this.tokenizer.rules = n;
  }
  static get rules() {
    return { block: vy, inline: op };
  }
  static lex(e, n) {
    return new wk(n).lex(e);
  }
  static lexInline(e, n) {
    return new wk(n).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Pi.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let n = 0; n < this.inlineQueue.length; n++) {
      let r = this.inlineQueue[n];
      this.inlineTokens(r.src, r.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, n = [], r = !1) {
    for (this.options.pedantic && (e = e.replace(Pi.tabCharGlobal, "    ").replace(Pi.spaceLine, "")); e; ) {
      let i;
      if (this.options.extensions?.block?.some((o) => (i = o.call({ lexer: this }, e, n)) ? (e = e.substring(i.raw.length), n.push(i), !0) : !1)) continue;
      if (i = this.tokenizer.space(e)) {
        e = e.substring(i.raw.length);
        let o = n.at(-1);
        i.raw.length === 1 && o !== void 0 ? o.raw += `
` : n.push(i);
        continue;
      }
      if (i = this.tokenizer.code(e)) {
        e = e.substring(i.raw.length);
        let o = n.at(-1);
        o?.type === "paragraph" || o?.type === "text" ? (o.raw += (o.raw.endsWith(`
`) ? "" : `
`) + i.raw, o.text += `
` + i.text, this.inlineQueue.at(-1).src = o.text) : n.push(i);
        continue;
      }
      if (i = this.tokenizer.fences(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      if (i = this.tokenizer.heading(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      if (i = this.tokenizer.hr(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      if (i = this.tokenizer.blockquote(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      if (i = this.tokenizer.list(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      if (i = this.tokenizer.html(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      if (i = this.tokenizer.def(e)) {
        e = e.substring(i.raw.length);
        let o = n.at(-1);
        o?.type === "paragraph" || o?.type === "text" ? (o.raw += (o.raw.endsWith(`
`) ? "" : `
`) + i.raw, o.text += `
` + i.raw, this.inlineQueue.at(-1).src = o.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title }, n.push(i));
        continue;
      }
      if (i = this.tokenizer.table(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      if (i = this.tokenizer.lheading(e)) {
        e = e.substring(i.raw.length), n.push(i);
        continue;
      }
      let s = e;
      if (this.options.extensions?.startBlock) {
        let o = 1 / 0, l = e.slice(1), a;
        this.options.extensions.startBlock.forEach((u) => {
          a = u.call({ lexer: this }, l), typeof a == "number" && a >= 0 && (o = Math.min(o, a));
        }), o < 1 / 0 && o >= 0 && (s = e.substring(0, o + 1));
      }
      if (this.state.top && (i = this.tokenizer.paragraph(s))) {
        let o = n.at(-1);
        r && o?.type === "paragraph" ? (o.raw += (o.raw.endsWith(`
`) ? "" : `
`) + i.raw, o.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : n.push(i), r = s.length !== e.length, e = e.substring(i.raw.length);
        continue;
      }
      if (i = this.tokenizer.text(e)) {
        e = e.substring(i.raw.length);
        let o = n.at(-1);
        o?.type === "text" ? (o.raw += (o.raw.endsWith(`
`) ? "" : `
`) + i.raw, o.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : n.push(i);
        continue;
      }
      if (e) {
        let o = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(o);
          break;
        } else throw new Error(o);
      }
    }
    return this.state.top = !0, n;
  }
  inline(e, n = []) {
    return this.inlineQueue.push({ src: e, tokens: n }), n;
  }
  inlineTokens(e, n = []) {
    let r = e, i = null;
    if (this.tokens.links) {
      let a = Object.keys(this.tokens.links);
      if (a.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null; ) a.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(r)) != null; ) r = r.slice(0, i.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let s;
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(r)) != null; ) s = i[2] ? i[2].length : 0, r = r.slice(0, i.index + s) + "[" + "a".repeat(i[0].length - s - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    r = this.options.hooks?.emStrongMask?.call({ lexer: this }, r) ?? r;
    let o = !1, l = "";
    for (; e; ) {
      o || (l = ""), o = !1;
      let a;
      if (this.options.extensions?.inline?.some((c) => (a = c.call({ lexer: this }, e, n)) ? (e = e.substring(a.raw.length), n.push(a), !0) : !1)) continue;
      if (a = this.tokenizer.escape(e)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (a = this.tokenizer.tag(e)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (a = this.tokenizer.link(e)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (a = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(a.raw.length);
        let c = n.at(-1);
        a.type === "text" && c?.type === "text" ? (c.raw += a.raw, c.text += a.text) : n.push(a);
        continue;
      }
      if (a = this.tokenizer.emStrong(e, r, l)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (a = this.tokenizer.codespan(e)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (a = this.tokenizer.br(e)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (a = this.tokenizer.del(e)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (a = this.tokenizer.autolink(e)) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      if (!this.state.inLink && (a = this.tokenizer.url(e))) {
        e = e.substring(a.raw.length), n.push(a);
        continue;
      }
      let u = e;
      if (this.options.extensions?.startInline) {
        let c = 1 / 0, f = e.slice(1), d;
        this.options.extensions.startInline.forEach((p) => {
          d = p.call({ lexer: this }, f), typeof d == "number" && d >= 0 && (c = Math.min(c, d));
        }), c < 1 / 0 && c >= 0 && (u = e.substring(0, c + 1));
      }
      if (a = this.tokenizer.inlineText(u)) {
        e = e.substring(a.raw.length), a.raw.slice(-1) !== "_" && (l = a.raw.slice(-1)), o = !0;
        let c = n.at(-1);
        c?.type === "text" ? (c.raw += a.raw, c.text += a.text) : n.push(a);
        continue;
      }
      if (e) {
        let c = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(c);
          break;
        } else throw new Error(c);
      }
    }
    return n;
  }
}, bv = class {
  options;
  parser;
  constructor(t) {
    this.options = t || Qf;
  }
  space(t) {
    return "";
  }
  code({ text: t, lang: e, escaped: n }) {
    let r = (e || "").match(Pi.notSpaceStart)?.[0], i = t.replace(Pi.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + vl(r) + '">' + (n ? i : vl(i, !0)) + `</code></pre>
` : "<pre><code>" + (n ? i : vl(i, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: t }) {
    return `<blockquote>
${this.parser.parse(t)}</blockquote>
`;
  }
  html({ text: t }) {
    return t;
  }
  def(t) {
    return "";
  }
  heading({ tokens: t, depth: e }) {
    return `<h${e}>${this.parser.parseInline(t)}</h${e}>
`;
  }
  hr(t) {
    return `<hr>
`;
  }
  list(t) {
    let e = t.ordered, n = t.start, r = "";
    for (let o = 0; o < t.items.length; o++) {
      let l = t.items[o];
      r += this.listitem(l);
    }
    let i = e ? "ol" : "ul", s = e && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r + "</" + i + `>
`;
  }
  listitem(t) {
    let e = "";
    if (t.task) {
      let n = this.checkbox({ checked: !!t.checked });
      t.loose ? t.tokens[0]?.type === "paragraph" ? (t.tokens[0].text = n + " " + t.tokens[0].text, t.tokens[0].tokens && t.tokens[0].tokens.length > 0 && t.tokens[0].tokens[0].type === "text" && (t.tokens[0].tokens[0].text = n + " " + vl(t.tokens[0].tokens[0].text), t.tokens[0].tokens[0].escaped = !0)) : t.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: !0 }) : e += n + " ";
    }
    return e += this.parser.parse(t.tokens, !!t.loose), `<li>${e}</li>
`;
  }
  checkbox({ checked: t }) {
    return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: t }) {
    return `<p>${this.parser.parseInline(t)}</p>
`;
  }
  table(t) {
    let e = "", n = "";
    for (let i = 0; i < t.header.length; i++) n += this.tablecell(t.header[i]);
    e += this.tablerow({ text: n });
    let r = "";
    for (let i = 0; i < t.rows.length; i++) {
      let s = t.rows[i];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: t }) {
    return `<tr>
${t}</tr>
`;
  }
  tablecell(t) {
    let e = this.parser.parseInline(t.tokens), n = t.header ? "th" : "td";
    return (t.align ? `<${n} align="${t.align}">` : `<${n}>`) + e + `</${n}>
`;
  }
  strong({ tokens: t }) {
    return `<strong>${this.parser.parseInline(t)}</strong>`;
  }
  em({ tokens: t }) {
    return `<em>${this.parser.parseInline(t)}</em>`;
  }
  codespan({ text: t }) {
    return `<code>${vl(t, !0)}</code>`;
  }
  br(t) {
    return "<br>";
  }
  del({ tokens: t }) {
    return `<del>${this.parser.parseInline(t)}</del>`;
  }
  link({ href: t, title: e, tokens: n }) {
    let r = this.parser.parseInline(n), i = xO(t);
    if (i === null) return r;
    t = i;
    let s = '<a href="' + t + '"';
    return e && (s += ' title="' + vl(e) + '"'), s += ">" + r + "</a>", s;
  }
  image({ href: t, title: e, text: n, tokens: r }) {
    r && (n = this.parser.parseInline(r, this.parser.textRenderer));
    let i = xO(t);
    if (i === null) return vl(n);
    t = i;
    let s = `<img src="${t}" alt="${n}"`;
    return e && (s += ` title="${vl(e)}"`), s += ">", s;
  }
  text(t) {
    return "tokens" in t && t.tokens ? this.parser.parseInline(t.tokens) : "escaped" in t && t.escaped ? t.text : vl(t.text);
  }
}, lC = class {
  strong({ text: t }) {
    return t;
  }
  em({ text: t }) {
    return t;
  }
  codespan({ text: t }) {
    return t;
  }
  del({ text: t }) {
    return t;
  }
  html({ text: t }) {
    return t;
  }
  text({ text: t }) {
    return t;
  }
  link({ text: t }) {
    return "" + t;
  }
  image({ text: t }) {
    return "" + t;
  }
  br() {
    return "";
  }
}, zo = class _k {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || Qf, this.options.renderer = this.options.renderer || new bv(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new lC();
  }
  static parse(e, n) {
    return new _k(n).parse(e);
  }
  static parseInline(e, n) {
    return new _k(n).parseInline(e);
  }
  parse(e, n = !0) {
    let r = "";
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.options.extensions?.renderers?.[s.type]) {
        let l = s, a = this.options.extensions.renderers[l.type].call({ parser: this }, l);
        if (a !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(l.type)) {
          r += a || "";
          continue;
        }
      }
      let o = s;
      switch (o.type) {
        case "space": {
          r += this.renderer.space(o);
          continue;
        }
        case "hr": {
          r += this.renderer.hr(o);
          continue;
        }
        case "heading": {
          r += this.renderer.heading(o);
          continue;
        }
        case "code": {
          r += this.renderer.code(o);
          continue;
        }
        case "table": {
          r += this.renderer.table(o);
          continue;
        }
        case "blockquote": {
          r += this.renderer.blockquote(o);
          continue;
        }
        case "list": {
          r += this.renderer.list(o);
          continue;
        }
        case "html": {
          r += this.renderer.html(o);
          continue;
        }
        case "def": {
          r += this.renderer.def(o);
          continue;
        }
        case "paragraph": {
          r += this.renderer.paragraph(o);
          continue;
        }
        case "text": {
          let l = o, a = this.renderer.text(l);
          for (; i + 1 < e.length && e[i + 1].type === "text"; ) l = e[++i], a += `
` + this.renderer.text(l);
          n ? r += this.renderer.paragraph({ type: "paragraph", raw: a, text: a, tokens: [{ type: "text", raw: a, text: a, escaped: !0 }] }) : r += a;
          continue;
        }
        default: {
          let l = 'Token with "' + o.type + '" type was not found.';
          if (this.options.silent) return console.error(l), "";
          throw new Error(l);
        }
      }
    }
    return r;
  }
  parseInline(e, n = this.renderer) {
    let r = "";
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.options.extensions?.renderers?.[s.type]) {
        let l = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (l !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) {
          r += l || "";
          continue;
        }
      }
      let o = s;
      switch (o.type) {
        case "escape": {
          r += n.text(o);
          break;
        }
        case "html": {
          r += n.html(o);
          break;
        }
        case "link": {
          r += n.link(o);
          break;
        }
        case "image": {
          r += n.image(o);
          break;
        }
        case "strong": {
          r += n.strong(o);
          break;
        }
        case "em": {
          r += n.em(o);
          break;
        }
        case "codespan": {
          r += n.codespan(o);
          break;
        }
        case "br": {
          r += n.br(o);
          break;
        }
        case "del": {
          r += n.del(o);
          break;
        }
        case "text": {
          r += n.text(o);
          break;
        }
        default: {
          let l = 'Token with "' + o.type + '" type was not found.';
          if (this.options.silent) return console.error(l), "";
          throw new Error(l);
        }
      }
    }
    return r;
  }
}, wp = class {
  options;
  block;
  constructor(t) {
    this.options = t || Qf;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(t) {
    return t;
  }
  postprocess(t) {
    return t;
  }
  processAllTokens(t) {
    return t;
  }
  emStrongMask(t) {
    return t;
  }
  provideLexer() {
    return this.block ? $o.lex : $o.lexInline;
  }
  provideParser() {
    return this.block ? zo.parse : zo.parseInline;
  }
}, oxe = class {
  defaults = Z5();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = zo;
  Renderer = bv;
  TextRenderer = lC;
  Lexer = $o;
  Tokenizer = yv;
  Hooks = wp;
  constructor(...t) {
    this.use(...t);
  }
  walkTokens(t, e) {
    let n = [];
    for (let r of t) switch (n = n.concat(e.call(this, r)), r.type) {
      case "table": {
        let i = r;
        for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, e));
        for (let s of i.rows) for (let o of s) n = n.concat(this.walkTokens(o.tokens, e));
        break;
      }
      case "list": {
        let i = r;
        n = n.concat(this.walkTokens(i.items, e));
        break;
      }
      default: {
        let i = r;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let o = i[s].flat(1 / 0);
          n = n.concat(this.walkTokens(o, e));
        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, e)));
      }
    }
    return n;
  }
  use(...t) {
    let e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t.forEach((n) => {
      let r = { ...n };
      if (r.async = this.defaults.async || r.async || !1, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = e.renderers[i.name];
          s ? e.renderers[i.name] = function(...o) {
            let l = i.renderer.apply(this, o);
            return l === !1 && (l = s.apply(this, o)), l;
          } : e.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = e[i.level];
          s ? s.unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (e.childTokens[i.name] = i.childTokens);
      }), r.extensions = e), n.renderer) {
        let i = this.defaults.renderer || new bv(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, l = n.renderer[o], a = i[o];
          i[o] = (...u) => {
            let c = l.apply(i, u);
            return c === !1 && (c = a.apply(i, u)), c || "";
          };
        }
        r.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new yv(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, l = n.tokenizer[o], a = i[o];
          i[o] = (...u) => {
            let c = l.apply(i, u);
            return c === !1 && (c = a.apply(i, u)), c;
          };
        }
        r.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new wp();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, l = n.hooks[o], a = i[o];
          wp.passThroughHooks.has(s) ? i[o] = (u) => {
            if (this.defaults.async && wp.passThroughHooksRespectAsync.has(s)) return (async () => {
              let f = await l.call(i, u);
              return a.call(i, f);
            })();
            let c = l.call(i, u);
            return a.call(i, c);
          } : i[o] = (...u) => {
            if (this.defaults.async) return (async () => {
              let f = await l.apply(i, u);
              return f === !1 && (f = await a.apply(i, u)), f;
            })();
            let c = l.apply(i, u);
            return c === !1 && (c = a.apply(i, u)), c;
          };
        }
        r.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r.walkTokens = function(o) {
          let l = [];
          return l.push(s.call(this, o)), i && (l = l.concat(i.call(this, o))), l;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(t) {
    return this.defaults = { ...this.defaults, ...t }, this;
  }
  lexer(t, e) {
    return $o.lex(t, e ?? this.defaults);
  }
  parser(t, e) {
    return zo.parse(t, e ?? this.defaults);
  }
  parseMarkdown(t) {
    return (e, n) => {
      let r = { ...n }, i = { ...this.defaults, ...r }, s = this.onError(!!i.silent, !!i.async);
      if (this.defaults.async === !0 && r.async === !1) return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof e > "u" || e === null) return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof e != "string") return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"));
      if (i.hooks && (i.hooks.options = i, i.hooks.block = t), i.async) return (async () => {
        let o = i.hooks ? await i.hooks.preprocess(e) : e, l = await (i.hooks ? await i.hooks.provideLexer() : t ? $o.lex : $o.lexInline)(o, i), a = i.hooks ? await i.hooks.processAllTokens(l) : l;
        i.walkTokens && await Promise.all(this.walkTokens(a, i.walkTokens));
        let u = await (i.hooks ? await i.hooks.provideParser() : t ? zo.parse : zo.parseInline)(a, i);
        return i.hooks ? await i.hooks.postprocess(u) : u;
      })().catch(s);
      try {
        i.hooks && (e = i.hooks.preprocess(e));
        let o = (i.hooks ? i.hooks.provideLexer() : t ? $o.lex : $o.lexInline)(e, i);
        i.hooks && (o = i.hooks.processAllTokens(o)), i.walkTokens && this.walkTokens(o, i.walkTokens);
        let l = (i.hooks ? i.hooks.provideParser() : t ? zo.parse : zo.parseInline)(o, i);
        return i.hooks && (l = i.hooks.postprocess(l)), l;
      } catch (o) {
        return s(o);
      }
    };
  }
  onError(t, e) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, t) {
        let r = "<p>An error occurred:</p><pre>" + vl(n.message + "", !0) + "</pre>";
        return e ? Promise.resolve(r) : r;
      }
      if (e) return Promise.reject(n);
      throw n;
    };
  }
}, Ff = new oxe();
function _n(t, e) {
  return Ff.parse(t, e);
}
_n.options = _n.setOptions = function(t) {
  return Ff.setOptions(t), _n.defaults = Ff.defaults, I$(_n.defaults), _n;
};
_n.getDefaults = Z5;
_n.defaults = Qf;
_n.use = function(...t) {
  return Ff.use(...t), _n.defaults = Ff.defaults, I$(_n.defaults), _n;
};
_n.walkTokens = function(t, e) {
  return Ff.walkTokens(t, e);
};
_n.parseInline = Ff.parseInline;
_n.Parser = zo;
_n.parser = zo.parse;
_n.Renderer = bv;
_n.TextRenderer = lC;
_n.Lexer = $o;
_n.lexer = $o.lex;
_n.Tokenizer = yv;
_n.Hooks = wp;
_n.parse = _n;
_n.options;
_n.setOptions;
_n.use;
_n.walkTokens;
_n.parseInline;
zo.parse;
$o.lex;
class lxe {
  element;
  constructor(e, n) {
    this.element = e, this.update(n);
  }
  update(e) {
    this.element.innerHTML = '<div class="markdown-content">' + _n(e.value?.toString() ?? "(null)", { async: !1, gfm: !0 }) + "</div>";
  }
}
class axe {
  element;
  constructor(e, n) {
    this.element = e, this.update(n);
  }
  update(e) {
    if (e.value != null) {
      let n = document.createElement("a");
      n.href = e.value, n.innerText = e.value, n.className = "underline", n.target = "_blank", this.element.replaceChildren(n);
    } else
      this.element.innerText = "(null)";
  }
}
let W$ = {
  markdown: lxe,
  image: _2e,
  url: axe,
  json: k2e
}, uxe = [
  { renderer: "markdown", label: "Markdown" },
  { renderer: "image", label: "Image" },
  { renderer: "url", label: "Link" },
  { renderer: "json", label: "JSON" }
];
function kO(t) {
  if (t != null)
    return typeof t == "string" ? W$[t] : t;
}
function cxe(t) {
  return typeof t == "string" && (t.startsWith("http://") || t.startsWith("https://"));
}
function fxe(t) {
  return t == null ? !1 : !!(typeof t == "string" && t.startsWith("data:image/") || t.bytes && t.bytes instanceof Uint8Array);
}
function aC(t) {
  if (t == null)
    return "(null)";
  if (typeof t == "string")
    return t.toString();
  if (typeof t == "number")
    return t.toLocaleString();
  if (Array.isArray(t))
    return "[" + t.map((e) => aC(e)).join(", ") + "]";
  try {
    return P$(t);
  } catch {
    return t.toString();
  }
}
var hxe = /* @__PURE__ */ ge('<a class="underline" target="_blank"> </a>'), dxe = /* @__PURE__ */ ge('<img alt="" class="max-w-24 max-h-24"/>'), pxe = /* @__PURE__ */ ge("<div></div>");
function CO(t, e) {
  it(e, !0);
  let n = ct(e, "value", 3, ""), r = ct(e, "rendererOptions", 19, () => ({})), i = /* @__PURE__ */ K(() => e.renderer != null ? W$[e.renderer] ?? null : null);
  function s(c, f) {
    let d = new f.class(c, { value: f.value, ...f.options });
    return {
      update(p) {
        d.update?.({ value: p.value, ...p.options });
      },
      destroy() {
        d.destroy?.();
      }
    };
  }
  var o = kn(), l = We(o);
  {
    var a = (c) => {
      var f = kn(), d = We(f);
      {
        var p = (y) => {
          var b = hxe(), v = J(b, !0);
          Q(b), ke(() => {
            te(b, "href", n()), ut(v, n());
          }), X(y, b);
        }, m = (y) => {
          var b = kn(), v = We(b);
          {
            var _ = (S) => {
              var C = dxe();
              ke((E) => te(C, "src", E), [() => M$(n())]), X(S, C);
            }, k = (S) => {
              var C = Ms();
              ke((E) => ut(C, E), [() => aC(n())]), X(S, C);
            };
            Fe(
              v,
              (S) => {
                fxe(n()) ? S(_) : S(k, !1);
              },
              !0
            );
          }
          X(y, b);
        };
        Fe(d, (y) => {
          cxe(n()) ? y(p) : y(m, !1);
        });
      }
      X(c, f);
    }, u = (c) => {
      var f = kn(), d = We(f);
      CT(d, () => x(i), (p) => {
        var m = pxe();
        Ts(m, (y, b) => s?.(y, b), () => ({
          class: x(i),
          value: n(),
          options: r() ?? {}
        })), X(p, m);
      }), X(c, f);
    };
    Fe(l, (c) => {
      x(i) == null ? c(a) : c(u, !1);
    });
  }
  X(t, o), st();
}
var gxe = /* @__PURE__ */ ge('<div class="flex flex-col"><div class="text-slate-400 dark:text-slate-400 font-medium text-xs"> </div> <div><!></div></div>'), mxe = /* @__PURE__ */ ge('<div class="px-2 flex items-center gap-2 border border-slate-200 dark:border-slate-700 bg-slate-100/25 dark:bg-slate-700/25 text-slate-700 dark:text-slate-300 rounded-md"><div class="text-slate-400 dark:text-slate-400 font-medium text-sm"> </div> <div class="text-ellipsis whitespace-nowrap overflow-hidden max-w-72"><!></div></div>'), yxe = /* @__PURE__ */ ge('<div class="flex flex-col gap-2"><!> <div class="flex-none flex flex-row gap-1 flex-wrap items-start"></div></div>');
function G$(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ K(() => Object.keys(e.columnStyles).filter((l) => e.columnStyles[l].display == "full")), r = /* @__PURE__ */ K(() => Object.keys(e.columnStyles).filter((l) => e.columnStyles[l].display == "badge"));
  var i = yxe(), s = J(i);
  Bt(s, 17, () => x(n), fn, (l, a) => {
    const u = /* @__PURE__ */ K(() => e.values[x(a)]);
    var c = gxe(), f = J(c), d = J(f, !0);
    Q(f);
    var p = ue(f, 2), m = J(p);
    CO(m, {
      get value() {
        return x(u);
      },
      get renderer() {
        return e.columnStyles[x(a)].renderer;
      },
      get rendererOptions() {
        return e.columnStyles[x(a)].rendererOptions;
      }
    }), Q(p), Q(c), ke(() => ut(d, x(a))), X(l, c);
  });
  var o = ue(s, 2);
  Bt(o, 21, () => x(r), fn, (l, a) => {
    const u = /* @__PURE__ */ K(() => e.values[x(a)]);
    var c = mxe(), f = J(c), d = J(f, !0);
    Q(f);
    var p = ue(f, 2), m = J(p);
    CO(m, {
      get value() {
        return x(u);
      }
    }), Q(p), Q(c), ke(
      (y) => {
        ut(d, x(a)), te(p, "title", y);
      },
      [() => aC(x(u))]
    ), X(l, c);
  }), Q(o), Q(i), X(t, i), st();
}
var bxe = /* @__PURE__ */ ge('<div><button class="text-sm flex gap-0.5 items-center text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-300"><!> Nearest Neighbors</button></div>'), vxe = /* @__PURE__ */ ge('<div class="embedding-atlas-root"><div><!> <!></div></div>');
function xxe(t, e) {
  it(e, !0);
  var n = vxe(), r = J(n);
  let i;
  ht(r, "", {}, { "max-width": "400px", "max-height": "300px" });
  var s = J(r);
  {
    let a = /* @__PURE__ */ K(() => e.tooltip.fields ?? {}), u = /* @__PURE__ */ K(() => e.columnStyles ?? {});
    G$(s, {
      get values() {
        return x(a);
      },
      get columnStyles() {
        return x(u);
      }
    });
  }
  var o = ue(s, 2);
  {
    var l = (a) => {
      var u = bxe(), c = J(u);
      c.__click = () => {
        e.onNearestNeighborSearch?.(e.tooltip.identifier);
      };
      var f = J(c);
      q0e(f, {}), Vk(), Q(c), Q(u), X(a, u);
    };
    Fe(o, (a) => {
      e.onNearestNeighborSearch && a(l);
    });
  }
  Q(r), Q(n), ke(() => i = er(r, 1, "p-2 border flex flex-col gap-2 border-slate-300 dark:border-slate-600 shadow-md text-slate-700 dark:text-slate-300 rounded-md text-ellipsis overflow-x-hidden overflow-y-scroll bg-white/75 dark:bg-slate-800/75 backdrop-blur-sm", null, i, { dark: e.colorScheme == "dark" })), X(t, n), st();
}
ir(["click"]);
function K$(t) {
  return class {
    component;
    constructor(e, n) {
      this.component = _T({ component: t, target: e, props: n });
    }
    update(e) {
      this.component.$set(e);
    }
    destroy() {
      this.component.$destroy();
    }
  };
}
var wxe = /* @__PURE__ */ ge("<div></div>");
function _xe(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]), r;
  Kg(() => {
    let s = new abe(r, n);
    Vo(() => {
      s.update(n);
    }), kT(() => {
      s.destroy();
    });
  });
  var i = wxe();
  ht(i, "", {}, { display: "flex" }), Yo(i, (s) => r = s, () => r), X(t, i), st();
}
const vv = Math.min, df = Math.max, xv = Math.round, xy = Math.floor, Kl = (t) => ({
  x: t,
  y: t
});
function SO(t, e, n) {
  return df(t, vv(e, n));
}
function uC(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function z2(t) {
  return t.split("-")[0];
}
function Y$(t) {
  return t.split("-")[1];
}
function X$(t) {
  return t === "x" ? "y" : "x";
}
function kxe(t) {
  return t === "y" ? "height" : "width";
}
const Cxe = /* @__PURE__ */ new Set(["top", "bottom"]);
function j2(t) {
  return Cxe.has(z2(t)) ? "y" : "x";
}
function Sxe(t) {
  return X$(j2(t));
}
function Axe(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Exe(t) {
  return typeof t != "number" ? Axe(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function wv(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: i
  } = t;
  return {
    width: r,
    height: i,
    top: n,
    left: e,
    right: e + r,
    bottom: n + i,
    x: e,
    y: n
  };
}
function AO(t, e, n) {
  let {
    reference: r,
    floating: i
  } = t;
  const s = j2(e), o = Sxe(e), l = kxe(o), a = z2(e), u = s === "y", c = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, d = r[l] / 2 - i[l] / 2;
  let p;
  switch (a) {
    case "top":
      p = {
        x: c,
        y: r.y - i.height
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: r.y + r.height
      };
      break;
    case "right":
      p = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      p = {
        x: r.x - i.width,
        y: f
      };
      break;
    default:
      p = {
        x: r.x,
        y: r.y
      };
  }
  switch (Y$(e)) {
    case "start":
      p[o] -= d * (n && u ? -1 : 1);
      break;
    case "end":
      p[o] += d * (n && u ? -1 : 1);
      break;
  }
  return p;
}
const Dxe = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = n, l = s.filter(Boolean), a = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let u = await o.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: c,
    y: f
  } = AO(u, r, a), d = r, p = {}, m = 0;
  for (let y = 0; y < l.length; y++) {
    const {
      name: b,
      fn: v
    } = l[y], {
      x: _,
      y: k,
      data: S,
      reset: C
    } = await v({
      x: c,
      y: f,
      initialPlacement: r,
      placement: d,
      strategy: i,
      middlewareData: p,
      rects: u,
      platform: o,
      elements: {
        reference: t,
        floating: e
      }
    });
    c = _ ?? c, f = k ?? f, p = {
      ...p,
      [b]: {
        ...p[b],
        ...S
      }
    }, C && m <= 50 && (m++, typeof C == "object" && (C.placement && (d = C.placement), C.rects && (u = C.rects === !0 ? await o.getElementRects({
      reference: t,
      floating: e,
      strategy: i
    }) : C.rects), {
      x: c,
      y: f
    } = AO(u, d, a)), y = -1);
  }
  return {
    x: c,
    y: f,
    placement: d,
    strategy: i,
    middlewareData: p
  };
};
async function Oxe(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: l,
    strategy: a
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: d = !1,
    padding: p = 0
  } = uC(e, t), m = Exe(p), b = l[d ? f === "floating" ? "reference" : "floating" : f], v = wv(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(b))) == null || n ? b : b.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: a
  })), _ = f === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), S = await (s.isElement == null ? void 0 : s.isElement(k)) ? await (s.getScale == null ? void 0 : s.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = wv(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: _,
    offsetParent: k,
    strategy: a
  }) : _);
  return {
    top: (v.top - C.top + m.top) / S.y,
    bottom: (C.bottom - v.bottom + m.bottom) / S.y,
    left: (v.left - C.left + m.left) / S.x,
    right: (C.right - v.right + m.right) / S.x
  };
}
const Fxe = /* @__PURE__ */ new Set(["left", "top"]);
async function Txe(t, e) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = t, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = z2(n), l = Y$(n), a = j2(n) === "y", u = Fxe.has(o) ? -1 : 1, c = s && a ? -1 : 1, f = uC(e, t);
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return l && typeof m == "number" && (p = l === "end" ? m * -1 : m), a ? {
    x: p * c,
    y: d * u
  } : {
    x: d * u,
    y: p * c
  };
}
const Rxe = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: l
      } = e, a = await Txe(e, t);
      return o === ((n = l.offset) == null ? void 0 : n.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: i + a.x,
        y: s + a.y,
        data: {
          ...a,
          placement: o
        }
      };
    }
  };
}, Mxe = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: (b) => {
            let {
              x: v,
              y: _
            } = b;
            return {
              x: v,
              y: _
            };
          }
        },
        ...a
      } = uC(t, e), u = {
        x: n,
        y: r
      }, c = await Oxe(e, a), f = j2(z2(i)), d = X$(f);
      let p = u[d], m = u[f];
      if (s) {
        const b = d === "y" ? "top" : "left", v = d === "y" ? "bottom" : "right", _ = p + c[b], k = p - c[v];
        p = SO(_, p, k);
      }
      if (o) {
        const b = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", _ = m + c[b], k = m - c[v];
        m = SO(_, m, k);
      }
      const y = l.fn({
        ...e,
        [d]: p,
        [f]: m
      });
      return {
        ...y,
        data: {
          x: y.x - n,
          y: y.y - r,
          enabled: {
            [d]: s,
            [f]: o
          }
        }
      };
    }
  };
};
function q2() {
  return typeof window < "u";
}
function v0(t) {
  return Q$(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Hs(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function fa(t) {
  var e;
  return (e = (Q$(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function Q$(t) {
  return q2() ? t instanceof Node || t instanceof Hs(t).Node : !1;
}
function Zo(t) {
  return q2() ? t instanceof Element || t instanceof Hs(t).Element : !1;
}
function ta(t) {
  return q2() ? t instanceof HTMLElement || t instanceof Hs(t).HTMLElement : !1;
}
function EO(t) {
  return !q2() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Hs(t).ShadowRoot;
}
const Pxe = /* @__PURE__ */ new Set(["inline", "contents"]);
function wm(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: i
  } = el(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !Pxe.has(i);
}
const Ixe = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Nxe(t) {
  return Ixe.has(v0(t));
}
const Bxe = [":popover-open", ":modal"];
function U2(t) {
  return Bxe.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const Lxe = ["transform", "translate", "scale", "rotate", "perspective"], $xe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], zxe = ["paint", "layout", "strict", "content"];
function cC(t) {
  const e = fC(), n = Zo(t) ? el(t) : t;
  return Lxe.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || $xe.some((r) => (n.willChange || "").includes(r)) || zxe.some((r) => (n.contain || "").includes(r));
}
function jxe(t) {
  let e = fc(t);
  for (; ta(e) && !zd(e); ) {
    if (cC(e))
      return e;
    if (U2(e))
      return null;
    e = fc(e);
  }
  return null;
}
function fC() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const qxe = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function zd(t) {
  return qxe.has(v0(t));
}
function el(t) {
  return Hs(t).getComputedStyle(t);
}
function H2(t) {
  return Zo(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function fc(t) {
  if (v0(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    EO(t) && t.host || // Fallback.
    fa(t)
  );
  return EO(e) ? e.host : e;
}
function J$(t) {
  const e = fc(t);
  return zd(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : ta(e) && wm(e) ? e : J$(e);
}
function zg(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const i = J$(t), s = i === ((r = t.ownerDocument) == null ? void 0 : r.body), o = Hs(i);
  if (s) {
    const l = kk(o);
    return e.concat(o, o.visualViewport || [], wm(i) ? i : [], l && n ? zg(l) : []);
  }
  return e.concat(i, zg(i, [], n));
}
function kk(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function Z$(t) {
  const e = el(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = ta(t), s = i ? t.offsetWidth : n, o = i ? t.offsetHeight : r, l = xv(n) !== s || xv(r) !== o;
  return l && (n = s, r = o), {
    width: n,
    height: r,
    $: l
  };
}
function hC(t) {
  return Zo(t) ? t : t.contextElement;
}
function ud(t) {
  const e = hC(t);
  if (!ta(e))
    return Kl(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = Z$(e);
  let o = (s ? xv(n.width) : n.width) / r, l = (s ? xv(n.height) : n.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
const Uxe = /* @__PURE__ */ Kl(0);
function ez(t) {
  const e = Hs(t);
  return !fC() || !e.visualViewport ? Uxe : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function Hxe(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Hs(t) ? !1 : e;
}
function Tf(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(), s = hC(t);
  let o = Kl(1);
  e && (r ? Zo(r) && (o = ud(r)) : o = ud(t));
  const l = Hxe(s, n, r) ? ez(s) : Kl(0);
  let a = (i.left + l.x) / o.x, u = (i.top + l.y) / o.y, c = i.width / o.x, f = i.height / o.y;
  if (s) {
    const d = Hs(s), p = r && Zo(r) ? Hs(r) : r;
    let m = d, y = kk(m);
    for (; y && r && p !== m; ) {
      const b = ud(y), v = y.getBoundingClientRect(), _ = el(y), k = v.left + (y.clientLeft + parseFloat(_.paddingLeft)) * b.x, S = v.top + (y.clientTop + parseFloat(_.paddingTop)) * b.y;
      a *= b.x, u *= b.y, c *= b.x, f *= b.y, a += k, u += S, m = Hs(y), y = kk(m);
    }
  }
  return wv({
    width: c,
    height: f,
    x: a,
    y: u
  });
}
function V2(t, e) {
  const n = H2(t).scrollLeft;
  return e ? e.left + n : Tf(fa(t)).left + n;
}
function tz(t, e) {
  const n = t.getBoundingClientRect(), r = n.left + e.scrollLeft - V2(t, n), i = n.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function Vxe(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: i
  } = t;
  const s = i === "fixed", o = fa(r), l = e ? U2(e.floating) : !1;
  if (r === o || l && s)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Kl(1);
  const c = Kl(0), f = ta(r);
  if ((f || !f && !s) && ((v0(r) !== "body" || wm(o)) && (a = H2(r)), ta(r))) {
    const p = Tf(r);
    u = ud(r), c.x = p.x + r.clientLeft, c.y = p.y + r.clientTop;
  }
  const d = o && !f && !s ? tz(o, a) : Kl(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - a.scrollLeft * u.x + c.x + d.x,
    y: n.y * u.y - a.scrollTop * u.y + c.y + d.y
  };
}
function Wxe(t) {
  return Array.from(t.getClientRects());
}
function Gxe(t) {
  const e = fa(t), n = H2(t), r = t.ownerDocument.body, i = df(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = df(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + V2(t);
  const l = -n.scrollTop;
  return el(r).direction === "rtl" && (o += df(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
const DO = 25;
function Kxe(t, e) {
  const n = Hs(t), r = fa(t), i = n.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, l = 0, a = 0;
  if (i) {
    s = i.width, o = i.height;
    const c = fC();
    (!c || c && e === "fixed") && (l = i.offsetLeft, a = i.offsetTop);
  }
  const u = V2(r);
  if (u <= 0) {
    const c = r.ownerDocument, f = c.body, d = getComputedStyle(f), p = c.compatMode === "CSS1Compat" && parseFloat(d.marginLeft) + parseFloat(d.marginRight) || 0, m = Math.abs(r.clientWidth - f.clientWidth - p);
    m <= DO && (s -= m);
  } else u <= DO && (s += u);
  return {
    width: s,
    height: o,
    x: l,
    y: a
  };
}
const Yxe = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Xxe(t, e) {
  const n = Tf(t, !0, e === "fixed"), r = n.top + t.clientTop, i = n.left + t.clientLeft, s = ta(t) ? ud(t) : Kl(1), o = t.clientWidth * s.x, l = t.clientHeight * s.y, a = i * s.x, u = r * s.y;
  return {
    width: o,
    height: l,
    x: a,
    y: u
  };
}
function OO(t, e, n) {
  let r;
  if (e === "viewport")
    r = Kxe(t, n);
  else if (e === "document")
    r = Gxe(fa(t));
  else if (Zo(e))
    r = Xxe(e, n);
  else {
    const i = ez(t);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return wv(r);
}
function nz(t, e) {
  const n = fc(t);
  return n === e || !Zo(n) || zd(n) ? !1 : el(n).position === "fixed" || nz(n, e);
}
function Qxe(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = zg(t, [], !1).filter((l) => Zo(l) && v0(l) !== "body"), i = null;
  const s = el(t).position === "fixed";
  let o = s ? fc(t) : t;
  for (; Zo(o) && !zd(o); ) {
    const l = el(o), a = cC(o);
    !a && l.position === "fixed" && (i = null), (s ? !a && !i : !a && l.position === "static" && !!i && Yxe.has(i.position) || wm(o) && !a && nz(t, o)) ? r = r.filter((c) => c !== o) : i = l, o = fc(o);
  }
  return e.set(t, r), r;
}
function Jxe(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = t;
  const o = [...n === "clippingAncestors" ? U2(e) ? [] : Qxe(e, this._c) : [].concat(n), r], l = o[0], a = o.reduce((u, c) => {
    const f = OO(e, c, i);
    return u.top = df(f.top, u.top), u.right = vv(f.right, u.right), u.bottom = vv(f.bottom, u.bottom), u.left = df(f.left, u.left), u;
  }, OO(e, l, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function Zxe(t) {
  const {
    width: e,
    height: n
  } = Z$(t);
  return {
    width: e,
    height: n
  };
}
function ewe(t, e, n) {
  const r = ta(e), i = fa(e), s = n === "fixed", o = Tf(t, !0, s, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = Kl(0);
  function u() {
    a.x = V2(i);
  }
  if (r || !r && !s)
    if ((v0(e) !== "body" || wm(i)) && (l = H2(e)), r) {
      const p = Tf(e, !0, s, e);
      a.x = p.x + e.clientLeft, a.y = p.y + e.clientTop;
    } else i && u();
  s && !r && i && u();
  const c = i && !r && !s ? tz(i, l) : Kl(0), f = o.left + l.scrollLeft - a.x - c.x, d = o.top + l.scrollTop - a.y - c.y;
  return {
    x: f,
    y: d,
    width: o.width,
    height: o.height
  };
}
function G3(t) {
  return el(t).position === "static";
}
function FO(t, e) {
  if (!ta(t) || el(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return fa(t) === n && (n = n.ownerDocument.body), n;
}
function rz(t, e) {
  const n = Hs(t);
  if (U2(t))
    return n;
  if (!ta(t)) {
    let i = fc(t);
    for (; i && !zd(i); ) {
      if (Zo(i) && !G3(i))
        return i;
      i = fc(i);
    }
    return n;
  }
  let r = FO(t, e);
  for (; r && Nxe(r) && G3(r); )
    r = FO(r, e);
  return r && zd(r) && G3(r) && !cC(r) ? n : r || jxe(t) || n;
}
const twe = async function(t) {
  const e = this.getOffsetParent || rz, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: ewe(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function nwe(t) {
  return el(t).direction === "rtl";
}
const rwe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Vxe,
  getDocumentElement: fa,
  getClippingRect: Jxe,
  getOffsetParent: rz,
  getElementRects: twe,
  getClientRects: Wxe,
  getDimensions: Zxe,
  getScale: ud,
  isElement: Zo,
  isRTL: nwe
};
function iz(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function iwe(t, e) {
  let n = null, r;
  const i = fa(t);
  function s() {
    var l;
    clearTimeout(r), (l = n) == null || l.disconnect(), n = null;
  }
  function o(l, a) {
    l === void 0 && (l = !1), a === void 0 && (a = 1), s();
    const u = t.getBoundingClientRect(), {
      left: c,
      top: f,
      width: d,
      height: p
    } = u;
    if (l || e(), !d || !p)
      return;
    const m = xy(f), y = xy(i.clientWidth - (c + d)), b = xy(i.clientHeight - (f + p)), v = xy(c), k = {
      rootMargin: -m + "px " + -y + "px " + -b + "px " + -v + "px",
      threshold: df(0, vv(1, a)) || 1
    };
    let S = !0;
    function C(E) {
      const A = E[0].intersectionRatio;
      if (A !== a) {
        if (!S)
          return o();
        A ? o(!1, A) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      A === 1 && !iz(u, t.getBoundingClientRect()) && o(), S = !1;
    }
    try {
      n = new IntersectionObserver(C, {
        ...k,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, k);
    }
    n.observe(t);
  }
  return o(!0), s;
}
function swe(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, u = hC(t), c = i || s ? [...u ? zg(u) : [], ...zg(e)] : [];
  c.forEach((v) => {
    i && v.addEventListener("scroll", n, {
      passive: !0
    }), s && v.addEventListener("resize", n);
  });
  const f = u && l ? iwe(u, n) : null;
  let d = -1, p = null;
  o && (p = new ResizeObserver((v) => {
    let [_] = v;
    _ && _.target === u && p && (p.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var k;
      (k = p) == null || k.observe(e);
    })), n();
  }), u && !a && p.observe(u), p.observe(e));
  let m, y = a ? Tf(t) : null;
  a && b();
  function b() {
    const v = Tf(t);
    y && !iz(y, v) && n(), y = v, m = requestAnimationFrame(b);
  }
  return n(), () => {
    var v;
    c.forEach((_) => {
      i && _.removeEventListener("scroll", n), s && _.removeEventListener("resize", n);
    }), f?.(), (v = p) == null || v.disconnect(), p = null, a && cancelAnimationFrame(m);
  };
}
const owe = Rxe, lwe = Mxe, awe = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: rwe,
    ...n
  }, s = {
    ...i.platform,
    _c: r
  };
  return Dxe(t, e, {
    ...i,
    platform: s
  });
};
var uwe = /* @__PURE__ */ ge('<div class="relative"><!> <div class="absolute px-3 py-3 rounded-md z-20 bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-700 shadow-lg" popover=""><!></div></div>');
function sz(t, e) {
  it(e, !0);
  let n = ct(e, "title", 3, ""), r = ct(e, "label", 3, null), i = ct(e, "icon", 3, null);
  ct(e, "anchor", 3, "right");
  let s = /* @__PURE__ */ Ee(!1), o;
  function l(m) {
    x(s) && m.key == "Escape" && (ae(s, !1), m.stopPropagation());
  }
  Vo(() => {
    if (o != null) {
      let m = (b) => {
        !x(s) || !o || b.target && !o.contains(b.target) && ae(s, !1);
      }, y = o.getRootNode();
      return y.addEventListener("mousedown", m), () => {
        y.removeEventListener("mousedown", m);
      };
    }
  });
  let a;
  Vo(() => {
    x(s) && Vo(() => u());
  });
  function u() {
    a.showPopover();
    function m() {
      awe(o, a, { placement: "bottom", middleware: [owe(3), lwe()] }).then(({ x: y, y: b }) => {
        a.style.left = y + "px", a.style.top = b + "px";
      });
    }
    return swe(o, a, m);
  }
  var c = uwe();
  c.__keydown = l;
  var f = J(c);
  Jy(f, {
    get icon() {
      return i();
    },
    get title() {
      return n();
    },
    get label() {
      return r();
    },
    get checked() {
      return x(s);
    },
    set checked(m) {
      ae(s, m, !0);
    }
  });
  var d = ue(f, 2);
  ht(d, "", {}, { width: "max-content" });
  var p = J(d);
  Xa(p, () => e.children ?? zt), Q(d), Yo(d, (m) => a = m, () => a), Q(c), Yo(c, (m) => o = m, () => o), X(t, c), st();
}
ir(["keydown"]);
var cwe = /* @__PURE__ */ ge('<div class="group relative" role="slider" tabindex="0"><div class="bg-slate-400 dark:bg-slate-500 rounded-full absolute"></div> <div class="bg-blue-500 rounded-full absolute group-hover:bg-blue-600 dark:group-hover:bg-blue-400"></div></div>');
function Ck(t, e) {
  it(e, !0);
  let n = ct(e, "value", 15, 0), r = ct(e, "min", 3, 0), i = ct(e, "max", 3, 100), s = ct(e, "step", 3, void 0), o = ct(e, "width", 3, 100), l = 15, a = /* @__PURE__ */ K(() => (C) => (C - r()) / (i() - r()) * (o() - l)), u = /* @__PURE__ */ K(() => (C) => C / (o() - l) * (i() - r()) + r()), c = /* @__PURE__ */ K(() => x(a)(n())), f = /* @__PURE__ */ Ee(void 0);
  function d(C) {
    let E = x(u)(C - l / 2);
    E = Math.max(r(), Math.min(i(), E)), s() != null && (E = Math.round(E / s()) * s()), n(E);
  }
  function p(C) {
    d(C.clientX - x(f).getBoundingClientRect().left);
    let E = (O) => {
      d(O.clientX - x(f).getBoundingClientRect().left);
    }, A = () => {
      window.removeEventListener("mousemove", E), window.removeEventListener("mouseup", A);
    };
    window.addEventListener("mousemove", E), window.addEventListener("mouseup", A);
  }
  function m(C) {
    C.key == "ArrowLeft" ? n(Math.max(n() - (s() ?? 1), r())) : C.key == "ArrowRight" && n(Math.min(n() + (s() ?? 1), i()));
  }
  var y = cwe();
  y.__mousedown = p, y.__keydown = m;
  let b;
  var v = J(y);
  let _;
  var k = ue(v, 2);
  let S;
  Q(y), Yo(y, (C) => ae(f, C), () => x(f)), ke(() => {
    te(y, "aria-valuenow", n()), te(y, "aria-valuemin", r()), te(y, "aria-valuemax", i()), b = ht(y, "", b, { width: `${o() ?? ""}px`, height: "28px" }), _ = ht(v, "", _, {
      left: "0px",
      top: "12px",
      width: `${o() ?? ""}px`,
      height: "4px"
    }), S = ht(k, "", S, {
      left: `${x(c) ?? ""}px`,
      top: "6.5px",
      width: "15px",
      height: "15px"
    });
  }), X(t, y), st();
}
ir(["mousedown", "keydown"]);
var fwe = /* @__PURE__ */ ge('<tr><td class="first:rounded-tl-md first:rounded-bl-md"><div class="block w-4 h-4 mx-2 rounded-full"></div></td><td><div class="whitespace-nowrap nowrap max-w-72 text-ellipsis overflow-hidden"> </div></td><td class="text-slate-400 px-2 text-xs text-right last:rounded-tr-md last:rounded-br-md" title="Count"> </td></tr>'), hwe = /* @__PURE__ */ ge("<table><tbody></tbody></table>");
function dwe(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ K(() => {
    let a = new Set(e.state.selection ?? []);
    return new Set(e.spec.items.filter((u) => a.has(u.label)));
  });
  class r extends Nk {
    reset() {
      e.onStateChange({ selection: void 0 });
    }
  }
  const i = new r();
  function s(a, u) {
    let c = new Set(e.state.selection ?? []);
    u.shiftKey || u.metaKey ? (c.has(a.label) ? c.delete(a.label) : c.add(a.label), e.onStateChange({ selection: Array.from(c) })) : c.has(a.label) && c.size == 1 ? e.onStateChange({ selection: void 0 }) : e.onStateChange({ selection: [a.label] });
  }
  pt(() => (pt(() => {
    let a = new Set(e.state.selection ?? []), u = e.spec.items.filter((d) => a.has(d.label)), c = u.length != 0 ? R.or(u.map((d) => d.predicate)) : null, f = {
      source: i,
      clients: /* @__PURE__ */ new Set([i]),
      value: u.length == 0 ? null : u,
      predicate: c
    };
    e.context.filter.update(f);
  }), () => {
    e.context.filter.update({
      source: i,
      clients: /* @__PURE__ */ new Set([i]),
      value: null,
      predicate: null
    });
  }));
  var o = hwe(), l = J(o);
  Bt(l, 21, () => e.spec.items, fn, (a, u) => {
    const c = /* @__PURE__ */ K(() => x(n).has(x(u)) || x(n).size == 0);
    var f = fwe();
    let d;
    f.__click = (C) => {
      s(x(u), C);
    };
    var p = J(f), m = J(p);
    let y;
    Q(p);
    var b = ue(p), v = J(b), _ = J(v, !0);
    Q(v), Q(b);
    var k = ue(b), S = J(k, !0);
    Q(k), Q(f), ke(
      (C) => {
        d = er(f, 1, "hover:bg-slate-200 dark:hover:bg-slate-700 select-none leading-7", null, d, { "opacity-20": !x(c) }), y = ht(m, "", y, { "background-color": x(u).color }), te(v, "title", x(u).label), ut(_, x(u).label), ut(S, C);
      },
      [() => x(u).count.toLocaleString()]
    ), X(a, f);
  }), Q(l), Q(o), X(t, o), st();
}
ir(["click"]);
function oz(t) {
  let e = 0;
  function n(r) {
    e += 1;
    try {
      r();
    } finally {
      e -= 1;
    }
  }
  return {
    set(r) {
      n(() => {
        t.set(r);
      });
    },
    update(r) {
      n(() => {
        t.update(r);
      });
    },
    subscribe(r) {
      return t.subscribe((i) => {
        e == 0 && r(i);
      });
    }
  };
}
async function pwe(t, e, n) {
  if (n == null)
    return null;
  let [r] = Array.from(await t.query(R.Query.describe(R.Query.from(e).select(n))));
  if (r == null)
    return null;
  let i = J5(r.column_type);
  return i == "string" ? await TO(t, e, n, 10) : i == "number" ? await F$(t, e, n) <= 10 ? await TO(t, e, n, 10) : await gwe(t, e, n) : null;
}
async function TO(t, e, n, r) {
  let i = `_ev_${n}_id`, s = Array.from(
    await t.query(
      R.Query.from(e).select({ value: R.cast(R.column(n), "TEXT"), count: R.count() }).where(R.not(R.isNull(R.cast(R.column(n), "TEXT")))).groupby(R.cast(R.column(n), "TEXT")).orderby(R.desc(R.count())).limit(r)
    )
  ), o = s.length, l = s.length + 1;
  await t.exec(`
    ALTER TABLE ${e} ADD COLUMN IF NOT EXISTS ${R.column(i)} INTEGER DEFAULT 0;
    UPDATE ${e}
    SET ${R.column(i)} = CASE ${R.column(n)}::TEXT
          ${s.map(({ value: m }, y) => R.sql`WHEN ${R.literal(m)} THEN ${R.literal(y)}`).join(" ")}
          ELSE (CASE WHEN ${R.column(n)} IS NULL THEN ${R.literal(l)} ELSE ${R.literal(o)} END) END
  `);
  let a = Array.from(
    await t.query(
      R.Query.from(e).select({ index: R.column(i), count: R.cast(R.count(), "INT") }).groupby(R.column(i))
    )
  ), u = /* @__PURE__ */ new Map();
  for (let m of a)
    u.set(m.index, m.count);
  let c = u.get(o) ?? 0, f = u.get(l) ?? 0, d = g0(s.length), p = s.map(({ value: m }, y) => ({
    label: m,
    color: d[y],
    predicate: R.eq(R.cast(R.column(n), "TEXT"), R.literal(m)),
    count: u.get(y) ?? 0
  }));
  if (c > 0) {
    let { otherCategoryCount: m } = (await t.query(`
        SELECT COUNT(DISTINCT(${R.column(n)}::TEXT)) AS otherCategoryCount
        FROM ${e}
        WHERE ${R.column(i)} = ${R.literal(o)} AND ${R.column(n)} IS NOT NULL
    `)).get(0);
    p.push({
      label: `(other ${m.toLocaleString()})`,
      color: "#9eabc2",
      predicate: s.length > 0 ? R.sql`${R.column(n)} IS NOT NULL AND ${R.column(n)}::TEXT NOT IN (${s.map((y) => R.literal(y.value)).join(",")})` : R.sql`${R.column(n)} IS NOT NULL`,
      count: c
    });
  }
  return f > 0 && (c <= 0 && (await t.exec(`
          UPDATE ${e}
          SET ${R.column(i)} = ${R.column(i)} - 1 WHERE ${R.column(i)} = ${R.literal(l)}
        `), l -= 1), p.push({
    label: "(null)",
    color: "#aaaaaa",
    predicate: R.isNull(R.column(n)),
    count: f
  })), {
    indexColumn: i,
    legend: p
  };
}
async function gwe(t, e, n) {
  let r = (await t.query(
    R.Query.from(e).select({
      count: R.count(),
      min: R.min(R.column(n)),
      max: R.max(R.column(n)),
      mean: R.avg(R.column(n)),
      median: R.median(R.column(n))
    }).where(R.isFinite(R.column(n)))
  )).get(0), i = T$(r), s = `_ev_${n}_id`, o = R.cast(R.column(n), "DOUBLE");
  o = i.scale.expr(o, i.scale.constant ?? 0);
  let l = R.cond(
    R.isFinite(R.cast(R.column(n), "DOUBLE")),
    R.floor(R.mul(R.sub(o, i.binStart), 1 / i.binSize)),
    R.literal(null)
  );
  await t.exec(`
    ALTER TABLE ${e} ADD COLUMN IF NOT EXISTS ${R.column(s)} INTEGER DEFAULT 0;
    UPDATE ${e}
    SET ${R.column(s)} = ${l}
  `);
  let a = Array.from(
    await t.query(`
      SELECT ${R.column(s)} AS index, COUNT(*)::INT AS count
      FROM ${e}
      GROUP BY ${R.column(s)}
      ORDER BY ${R.column(s)} ASC
    `)
  ), u = null, c = null, f = /* @__PURE__ */ new Map(), d = (y) => i.scale.reverse(y, i.scale.constant ?? 0);
  for (let { index: y, count: b } of a)
    y != null && ((u == null || y < u) && (u = y), (c == null || y > c) && (c = y)), f.set(y, b);
  let p = [], m = su(".6");
  if (u != null && c != null) {
    let y = C$(c - u + 1);
    for (let b = u; b <= c; b++) {
      let v = d(b * i.binSize + i.binStart), _ = d((b + 1) * i.binSize + i.binStart);
      p.push({
        label: `[${m(v)}, ${m(_)})`,
        color: y[b - u],
        predicate: R.eq(l, R.literal(b)),
        count: f.get(b) ?? 0
      });
    }
  }
  if (f.has(null)) {
    let y = p.length;
    await t.exec(`
        UPDATE ${e}
        SET ${R.column(s)} = ${R.literal(y)}
        WHERE ${R.column(s)} IS NULL
      `), p.push({
      label: "(null / nan / inf)",
      color: "#aaaaaa",
      predicate: R.isNull(l),
      count: f.get(null) ?? 0
    });
  }
  return {
    indexColumn: s,
    legend: p
  };
}
function wy(t, e, n) {
  return t + (e - t) * n;
}
function mwe(t, e, n) {
  let r = Math.log(t.scale), i = Math.log(e.scale);
  if (Math.abs(i - r) < 1e-5)
    return {
      x: wy(t.x, e.x, n),
      y: wy(t.y, e.y, n),
      scale: wy(t.scale, e.scale, n)
    };
  let s = Math.exp(wy(r, i, n));
  return {
    x: (e.x * e.scale - t.x * t.scale + (t.x - e.x) * (t.scale * e.scale / s)) / (e.scale - t.scale),
    y: (e.y * e.scale - t.y * t.scale + (t.y - e.y) * (t.scale * e.scale / s)) / (e.scale - t.scale),
    scale: s
  };
}
async function ywe(t, e, n, r) {
  let { stdX: i, stdY: s } = (await t.query(R.Query.from(e).select({
    stdX: R.sql`STDDEV(${R.column(n)})::FLOAT`,
    stdY: R.sql`STDDEV(${R.column(r)})::FLOAT`
  }))).get(0);
  return 1 / (Math.max(i, s, 1e-3) * 3);
}
const bwe = K$(xxe), vwe = K$(v2e);
var xwe = /* @__PURE__ */ ge('<div class="flex-none m-2 p-2 rounded-md bg-slate-100/75 dark:bg-slate-800/75 backdrop-blur-sm pointer-events-auto order-3"><!></div>'), wwe = /* @__PURE__ */ ge('<div class="flex flex-col gap-2 w-64"><div class="text-slate-500 dark:text-slate-400 select-none">Display Mode</div> <div class="flex gap-2 items-center"><!> <!></div> <div class="text-slate-500 dark:text-slate-400 select-none">Point Size</div> <div class="flex gap-2 items-center"><!> <!></div></div>'), _we = /* @__PURE__ */ ge('<div class="relative"><!> <div class="absolute top-0 left-0 right-0 flex flex-wrap justify-between items-start pointer-events-none"><!> <div class="flex-none p-2 rounded-ss-md rounded-ee-md bg-white/75 dark:bg-black/75 backdrop-blur-sm flex items-center gap-2 pointer-events-auto order-1"><!> <!></div></div></div>');
function kwe(t, e) {
  it(e, !0);
  const n = () => gi(a, "$colorScheme", i), r = () => gi(u, "$columnStyles", i), [i, s] = Xs(), o = Math.min(20, ube()), l = 1 / 16;
  let { colorScheme: a, columnStyles: u, searchResult: c } = e.context, f = oz(e.context.highlight), d = /* @__PURE__ */ K(() => e.spec.data.category), p = /* @__PURE__ */ Ee(null), m = /* @__PURE__ */ Ee(null), y = /* @__PURE__ */ Ee(null), b = /* @__PURE__ */ Ee(null);
  pt(() => {
    e.context.cache.value(`embedding/category/${x(d)}`, () => pwe(e.context.coordinator, e.context.table, x(d))).then((j) => {
      ae(p, j), (x(p)?.legend.length ?? 0) > o && e.onSpecChange({ mode: "points" });
    });
  }), pt(() => f.subscribe((N) => {
    N !== null && v(N);
  })), pt(() => c.subscribe(async (N) => {
    if (N == null || N.ids.length == 0) {
      ae(b, null);
      return;
    }
    let j = null;
    N.mode == "neighbors" && (j = N.query);
    let U = Array.from(await e.context.coordinator.query(R.Query.from(e.context.table).select({
      identifier: R.column(e.context.id),
      x: R.column(e.spec.data.x),
      y: R.column(e.spec.data.y)
    }).where(R.isIn(e.context.id, N.ids.concat(j != null ? [j] : []).map((H) => R.literal(H))))));
    ae(b, {
      center: U.filter((H) => H.identifier === j)[0] ?? null,
      points: U.filter((H) => H.identifier !== j)
    });
  }));
  async function v(N) {
    let U = await e.context.cache.value(`embedding/default-viewport-scale/${e.spec.data.x},${e.spec.data.y}`, () => ywe(e.context.coordinator, e.context.table, e.spec.data.x, e.spec.data.y)) * 2, H = await e.context.coordinator.query(R.Query.from(e.context.table).select({
      x: R.column(e.spec.data.x),
      y: R.column(e.spec.data.y)
    }).where(R.eq(R.column(e.context.id), R.literal(N)))), { x: G, y: re } = H.get(0);
    S({ x: G, y: re, scale: U }), ae(y, [N]), ae(m, N);
  }
  let _, k = /* @__PURE__ */ Ee(null);
  function S(N) {
    ae(m, null);
    let j = x(k) ?? e.state.viewport;
    if (j == null) {
      e.onStateChange({ viewport: N });
      return;
    }
    ae(k, j);
    let U = 800, H = (/* @__PURE__ */ new Date()).getTime(), G = () => {
      let re = ((/* @__PURE__ */ new Date()).getTime() - H) / U;
      re > 1 && (re = 1), ae(k, mwe(j, N, MT(re))), re < 1 ? _ = requestAnimationFrame(G) : e.onStateChange({ viewport: x(k) });
    };
    _ && cancelAnimationFrame(_), _ = requestAnimationFrame(G);
  }
  var C = { startViewportAnimation: S }, E = _we(), A = J(E);
  {
    let N = /* @__PURE__ */ K(() => x(p)?.indexColumn), j = /* @__PURE__ */ K(() => x(p)?.legend.map((oe) => oe.color)), U = /* @__PURE__ */ K(() => ({
      colorScheme: n(),
      ...e.context.embeddingViewConfig,
      mode: e.spec.mode ?? "points",
      ...e.spec.minimumDensity != null ? { minimumDensity: e.spec.minimumDensity } : {},
      ...e.spec.pointSize != null ? { pointSize: e.spec.pointSize } : {}
    })), H = /* @__PURE__ */ K(() => Object.fromEntries(e.context.columns.map((oe) => [oe.name, oe.name]))), G = /* @__PURE__ */ K(() => ({
      class: bwe,
      props: {
        darkMode: n(),
        columnStyles: r(),
        onNearestNeighborSearch: (e.context.searchModes ?? []).indexOf("neighbors") >= 0 ? (oe) => e.context.search?.(oe, "neighbors") : null
      }
    })), re = /* @__PURE__ */ K(() => ({
      class: vwe,
      props: { ...x(b) ?? { points: [], center: null } }
    })), se = /* @__PURE__ */ K(() => x(k) ?? e.state.viewport);
    _xe(A, {
      get width() {
        return e.width;
      },
      get height() {
        return e.height;
      },
      get coordinator() {
        return e.context.coordinator;
      },
      get table() {
        return e.context.table;
      },
      get filter() {
        return e.context.filter;
      },
      get rangeSelection() {
        return e.context.filter;
      },
      get identifier() {
        return e.context.id;
      },
      get x() {
        return e.spec.data.x;
      },
      get y() {
        return e.spec.data.y;
      },
      get text() {
        return e.spec.data.text;
      },
      get category() {
        return x(N);
      },
      get categoryColors() {
        return x(j);
      },
      get config() {
        return x(U);
      },
      get labels() {
        return e.context.embeddingViewLabels;
      },
      get cache() {
        return e.context.persistentCache;
      },
      get additionalFields() {
        return x(H);
      },
      get customTooltip() {
        return x(G);
      },
      get customOverlay() {
        return x(re);
      },
      get viewportState() {
        return x(se);
      },
      onViewportState: (oe) => e.onStateChange({ viewport: oe }),
      get rangeSelectionValue() {
        return e.state.brush;
      },
      onRangeSelection: (oe) => e.onStateChange({ brush: oe }),
      get tooltip() {
        return x(m);
      },
      onTooltip: (oe) => {
        ae(m, oe);
      },
      get selection() {
        return x(y);
      },
      onSelection: (oe) => {
        ae(y, oe), oe != null && oe.length == 1 && f.set(oe[0].identifier);
      }
    });
  }
  var O = ue(A, 2), T = J(O);
  {
    var $ = (N) => {
      var j = xwe(), U = J(j);
      {
        let H = /* @__PURE__ */ K(() => ({ items: x(p).legend })), G = /* @__PURE__ */ K(() => e.state.legend ?? {});
        dwe(U, {
          get context() {
            return e.context;
          },
          get spec() {
            return x(H);
          },
          get state() {
            return x(G);
          },
          onSpecChange: () => {
          },
          onStateChange: (re, se) => {
            e.onStateChange({ legend: re });
          }
        });
      }
      Q(j), X(N, j);
    };
    Fe(T, (N) => {
      x(p) != null && N($);
    });
  }
  var P = ue(T, 2), B = J(P);
  {
    let N = /* @__PURE__ */ K(() => [
      { value: null, label: "(none)" },
      ...e.context.columns.filter((j) => j.jsType == "string" || j.jsType == "number").map((j) => ({ value: j.name, label: `${j.name} (${j.type})` }))
    ]);
    Of(B, {
      class: "max-w-64",
      label: "Color",
      get value() {
        return x(d);
      },
      onChange: (j) => e.onSpecChange({ data: { ...e.spec.data, category: j } }),
      get options() {
        return x(N);
      }
    });
  }
  var M = ue(B, 2);
  sz(M, {
    get icon() {
      return LB;
    },
    title: "Options",
    children: (N, j) => {
      var U = wwe(), H = ue(J(U), 2), G = J(H);
      {
        let Pe = /* @__PURE__ */ K(() => e.spec.mode ?? "points"), Ce = /* @__PURE__ */ K(() => x(p) != null && x(p).legend.length > o);
        Of(G, {
          get value() {
            return x(Pe);
          },
          onChange: (fe) => e.onSpecChange({ mode: fe }),
          get disabled() {
            return x(Ce);
          },
          options: [
            { value: "points", label: "Points" },
            { value: "density", label: "Density" }
          ]
        });
      }
      var re = ue(G, 2);
      {
        var se = (Pe) => {
          var Ce = () => Math.log((e.spec.minimumDensity ?? l) / l), fe = (De) => e.onSpecChange({ minimumDensity: l * Math.exp(De) });
          Ck(Pe, {
            get value() {
              return Ce();
            },
            set value(De) {
              fe(De);
            },
            min: -4,
            max: 4,
            step: 0.05
          });
        };
        Fe(re, (Pe) => {
          (e.spec.mode ?? "points") == "density" && Pe(se);
        });
      }
      Q(H);
      var oe = ue(H, 4), ne = J(oe), ce = () => e.spec.pointSize ?? 1, we = (Pe) => e.onSpecChange({ pointSize: Pe });
      Ck(ne, {
        get value() {
          return ce();
        },
        set value(Pe) {
          we(Pe);
        },
        min: 1,
        max: 10,
        step: 0.05
      });
      var Me = ue(ne, 2);
      Tu(Me, {
        label: "Auto",
        onClick: () => e.onSpecChange({ pointSize: void 0 })
      }), Q(oe), Q(U), X(N, U);
    },
    $$slots: { default: !0 }
  }), Q(P), Q(O), Q(E), X(t, E);
  var L = st(C);
  return s(), L;
}
const bi = 2, W2 = 4, dC = 8, cu = 16, fu = 32, Jf = 64, G2 = 128, tl = 512, li = 1024, ps = 2048, hu = 4096, Vs = 8192, Ju = 16384, K2 = 32768, Rf = 65536, RO = 1 << 17, lz = 1 << 18, x0 = 1 << 19, Cwe = 1 << 20, jg = 32768, Sk = 1 << 21, pC = 1 << 22, Zu = 1 << 23, pf = Symbol("$state"), az = Symbol("legacy props"), Swe = Symbol(""), zh = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), gC = 3, w0 = 8, Awe = !1;
var mC = Array.isArray, Ewe = Array.prototype.indexOf, yC = Array.from, uz = Object.defineProperty, cd = Object.getOwnPropertyDescriptor, cz = Object.getOwnPropertyDescriptors, fz = Object.prototype, Dwe = Array.prototype, Y2 = Object.getPrototypeOf, MO = Object.isExtensible;
function Owe(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function hz() {
  var t, e, n = new Promise((r, i) => {
    t = r, e = i;
  });
  return { promise: n, resolve: t, reject: e };
}
function dz(t) {
  return t === this.v;
}
function pz(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function gz(t) {
  return !pz(t, this.v);
}
function mz(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function Fwe() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function Twe(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Rwe() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function Mwe(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function Pwe() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Iwe() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function Nwe() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Bwe() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Lwe() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function $we() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let _m = !1, zwe = !1;
function jwe() {
  _m = !0;
}
const bC = 1, vC = 2, yz = 4, qwe = 8, Uwe = 16, Hwe = 1, Vwe = 2, bz = "[", X2 = "[!", xC = "]", jd = {}, ei = Symbol(), Wwe = "http://www.w3.org/1999/xhtml", Gwe = [];
function vz(t, e = !1, n = !1) {
  return eb(t, /* @__PURE__ */ new Map(), "", Gwe, null, n);
}
function eb(t, e, n, r, i = null, s = !1) {
  if (typeof t == "object" && t !== null) {
    var o = e.get(t);
    if (o !== void 0) return o;
    if (t instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(t)
    );
    if (t instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(t)
    );
    if (mC(t)) {
      var l = (
        /** @type {Snapshot<any>} */
        Array(t.length)
      );
      e.set(t, l), i !== null && e.set(i, l);
      for (var a = 0; a < t.length; a += 1) {
        var u = t[a];
        a in t && (l[a] = eb(u, e, n, r, null, s));
      }
      return l;
    }
    if (Y2(t) === fz) {
      l = {}, e.set(t, l), i !== null && e.set(i, l);
      for (var c in t)
        l[c] = eb(
          // @ts-expect-error
          t[c],
          e,
          n,
          r,
          null,
          s
        );
      return l;
    }
    if (t instanceof Date)
      return (
        /** @type {Snapshot<T>} */
        structuredClone(t)
      );
    if (typeof /** @type {T & { toJSON?: any } } */
    t.toJSON == "function" && !s)
      return eb(
        /** @type {T & { toJSON(): any } } */
        t.toJSON(),
        e,
        n,
        r,
        // Associate the instance with the toJSON clone
        t
      );
  }
  if (t instanceof EventTarget)
    return (
      /** @type {Snapshot<T>} */
      t
    );
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(t)
    );
  } catch {
    return (
      /** @type {Snapshot<T>} */
      t
    );
  }
}
let Zn = null;
function qd(t) {
  Zn = t;
}
function Xi(t) {
  return (
    /** @type {T} */
    xz().get(t)
  );
}
function co(t, e) {
  return xz().set(t, e), e;
}
function sr(t, e = !1, n) {
  Zn = {
    p: Zn,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: _m && !e ? { s: null, u: null, $: [] } : null
  };
}
function or(t) {
  var e = (
    /** @type {ComponentContext} */
    Zn
  ), n = e.e;
  if (n !== null) {
    e.e = null;
    for (var r of n)
      Vz(r);
  }
  return e.i = !0, Zn = e.p, /** @type {T} */
  {};
}
function _0() {
  return !_m || Zn !== null && Zn.l === null;
}
function xz(t) {
  return Zn === null && mz(), Zn.c ??= new Map(Kwe(Zn) || void 0);
}
function Kwe(t) {
  let e = t.p;
  for (; e !== null; ) {
    const n = e.c;
    if (n !== null)
      return n;
    e = e.p;
  }
  return null;
}
let tf = [];
function wz() {
  var t = tf;
  tf = [], Owe(t);
}
function Zf(t) {
  if (tf.length === 0 && !jp) {
    var e = tf;
    queueMicrotask(() => {
      e === tf && wz();
    });
  }
  tf.push(t);
}
function Ywe() {
  for (; tf.length > 0; )
    wz();
}
function Q2(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function Xwe() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Ut = !1;
function qa(t) {
  Ut = t;
}
let pn;
function ls(t) {
  if (t === null)
    throw Q2(), jd;
  return pn = t;
}
function km() {
  return ls(
    /** @type {TemplateNode} */
    /* @__PURE__ */ ha(pn)
  );
}
function dn(t) {
  if (Ut) {
    if (/* @__PURE__ */ ha(pn) !== null)
      throw Q2(), jd;
    pn = t;
  }
}
function Qwe(t = 1) {
  if (Ut) {
    for (var e = t, n = pn; e--; )
      n = /** @type {TemplateNode} */
      /* @__PURE__ */ ha(n);
    pn = n;
  }
}
function _v(t = !0) {
  for (var e = 0, n = pn; ; ) {
    if (n.nodeType === w0) {
      var r = (
        /** @type {Comment} */
        n.data
      );
      if (r === xC) {
        if (e === 0) return n;
        e -= 1;
      } else (r === bz || r === X2) && (e += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ha(n)
    );
    t && n.remove(), n = i;
  }
}
function _z(t) {
  if (!t || t.nodeType !== w0)
    throw Q2(), jd;
  return (
    /** @type {Comment} */
    t.data
  );
}
function ai(t) {
  if (typeof t != "object" || t === null || pf in t)
    return t;
  const e = Y2(t);
  if (e !== fz && e !== Dwe)
    return t;
  var n = /* @__PURE__ */ new Map(), r = mC(t), i = /* @__PURE__ */ He(0), s = mf, o = (l) => {
    if (mf === s)
      return l();
    var a = Qt, u = mf;
    ss(null), LO(s);
    var c = l();
    return ss(a), LO(u), c;
  };
  return r && n.set("length", /* @__PURE__ */ He(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(l, a, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && Nwe();
        var c = n.get(a);
        return c === void 0 ? c = o(() => {
          var f = /* @__PURE__ */ He(u.value);
          return n.set(a, f), f;
        }) : be(c, u.value, !0), !0;
      },
      deleteProperty(l, a) {
        var u = n.get(a);
        if (u === void 0) {
          if (a in l) {
            const c = o(() => /* @__PURE__ */ He(ei));
            n.set(a, c), qp(i);
          }
        } else
          be(u, ei), qp(i);
        return !0;
      },
      get(l, a, u) {
        if (a === pf)
          return t;
        var c = n.get(a), f = a in l;
        if (c === void 0 && (!f || cd(l, a)?.writable) && (c = o(() => {
          var p = ai(f ? l[a] : ei), m = /* @__PURE__ */ He(p);
          return m;
        }), n.set(a, c)), c !== void 0) {
          var d = q(c);
          return d === ei ? void 0 : d;
        }
        return Reflect.get(l, a, u);
      },
      getOwnPropertyDescriptor(l, a) {
        var u = Reflect.getOwnPropertyDescriptor(l, a);
        if (u && "value" in u) {
          var c = n.get(a);
          c && (u.value = q(c));
        } else if (u === void 0) {
          var f = n.get(a), d = f?.v;
          if (f !== void 0 && d !== ei)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return u;
      },
      has(l, a) {
        if (a === pf)
          return !0;
        var u = n.get(a), c = u !== void 0 && u.v !== ei || Reflect.has(l, a);
        if (u !== void 0 || en !== null && (!c || cd(l, a)?.writable)) {
          u === void 0 && (u = o(() => {
            var d = c ? ai(l[a]) : ei, p = /* @__PURE__ */ He(d);
            return p;
          }), n.set(a, u));
          var f = q(u);
          if (f === ei)
            return !1;
        }
        return c;
      },
      set(l, a, u, c) {
        var f = n.get(a), d = a in l;
        if (r && a === "length")
          for (var p = u; p < /** @type {Source<number>} */
          f.v; p += 1) {
            var m = n.get(p + "");
            m !== void 0 ? be(m, ei) : p in l && (m = o(() => /* @__PURE__ */ He(ei)), n.set(p + "", m));
          }
        if (f === void 0)
          (!d || cd(l, a)?.writable) && (f = o(() => /* @__PURE__ */ He(void 0)), be(f, ai(u)), n.set(a, f));
        else {
          d = f.v !== ei;
          var y = o(() => ai(u));
          be(f, y);
        }
        var b = Reflect.getOwnPropertyDescriptor(l, a);
        if (b?.set && b.set.call(c, u), !d) {
          if (r && typeof a == "string") {
            var v = (
              /** @type {Source<number>} */
              n.get("length")
            ), _ = Number(a);
            Number.isInteger(_) && _ >= v.v && be(v, _ + 1);
          }
          qp(i);
        }
        return !0;
      },
      ownKeys(l) {
        q(i);
        var a = Reflect.ownKeys(l).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== ei;
        });
        for (var [u, c] of n)
          c.v !== ei && !(u in l) && a.push(u);
        return a;
      },
      setPrototypeOf() {
        Bwe();
      }
    }
  );
}
var Ak, kz, Cz, Sz;
function Ek() {
  if (Ak === void 0) {
    Ak = window, kz = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, n = Text.prototype;
    Cz = cd(e, "firstChild").get, Sz = cd(e, "nextSibling").get, MO(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), MO(n) && (n.__t = void 0);
  }
}
function na(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Mf(t) {
  return Cz.call(t);
}
// @__NO_SIDE_EFFECTS__
function ha(t) {
  return Sz.call(t);
}
function bn(t, e) {
  if (!Ut)
    return /* @__PURE__ */ Mf(t);
  var n = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ Mf(pn)
  );
  if (n === null)
    n = pn.appendChild(na());
  else if (e && n.nodeType !== gC) {
    var r = na();
    return n?.before(r), ls(r), r;
  }
  return ls(n), n;
}
function Ls(t, e = !1) {
  if (!Ut) {
    var n = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Mf(
        /** @type {Node} */
        t
      )
    );
    return n instanceof Comment && n.data === "" ? /* @__PURE__ */ ha(n) : n;
  }
  if (e && pn?.nodeType !== gC) {
    var r = na();
    return pn?.before(r), ls(r), r;
  }
  return pn;
}
function mo(t, e = 1, n = !1) {
  let r = Ut ? pn : t;
  for (var i; e--; )
    i = r, r = /** @type {TemplateNode} */
    /* @__PURE__ */ ha(r);
  if (!Ut)
    return r;
  if (n && r?.nodeType !== gC) {
    var s = na();
    return r === null ? i?.after(s) : r.before(s), ls(s), s;
  }
  return ls(r), /** @type {TemplateNode} */
  r;
}
function Az(t) {
  t.textContent = "";
}
function Jwe() {
  return !1;
}
function Ez(t) {
  var e = en;
  if (e === null)
    return Qt.f |= Zu, t;
  if ((e.f & K2) === 0) {
    if ((e.f & G2) === 0)
      throw t;
    e.b.error(t);
  } else
    Ud(t, e);
}
function Ud(t, e) {
  for (; e !== null; ) {
    if ((e.f & G2) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (n) {
        t = n;
      }
    e = e.parent;
  }
  throw t;
}
const _y = /* @__PURE__ */ new Set();
let Sr = null, $s = null, Fl = [], J2 = null, Dk = !1, jp = !1;
class $l {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #n = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #r = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #a = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #l = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #i = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Fl = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const r of e)
      this.#s(r, n);
    this.is_fork || this.#u(), this.#r > 0 || this.is_fork ? (this.#o(n.effects), this.#o(n.render_effects), this.#o(n.block_effects)) : (Sr = null, PO(n.render_effects), PO(n.effects), this.#a?.resolve()), $s = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #s(e, n) {
    e.f ^= li;
    for (var r = e.first; r !== null; ) {
      var i = r.f, s = (i & (fu | Jf)) !== 0, o = s && (i & li) !== 0, l = o || (i & Vs) !== 0 || this.skipped_effects.has(r);
      if ((r.f & G2) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !l && r.fn !== null) {
        s ? r.f ^= li : (i & W2) !== 0 ? n.effects.push(r) : Cm(r) && ((r.f & cu) !== 0 && n.block_effects.push(r), Ug(r));
        var a = r.first;
        if (a !== null) {
          r = a;
          continue;
        }
      }
      var u = r.parent;
      for (r = r.next; r === null && u !== null; )
        u === n.effect && (this.#o(n.effects), this.#o(n.render_effects), this.#o(n.block_effects), n = /** @type {EffectTarget} */
        n.parent), r = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #o(e) {
    for (const n of e)
      ((n.f & ps) !== 0 ? this.#l : this.#i).push(n), di(n, li);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, n) {
    this.previous.has(e) || this.previous.set(e, n), (e.f & Zu) === 0 && (this.current.set(e, e.v), $s?.set(e, e.v));
  }
  activate() {
    Sr = this, this.apply();
  }
  deactivate() {
    Sr = null, $s = null;
  }
  flush() {
    if (this.activate(), Fl.length > 0) {
      if (Dz(), Sr !== null && Sr !== this)
        return;
    } else this.#n === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #u() {
    if (this.#r === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#n === 0 && this.#c();
  }
  #c() {
    if (_y.size > 1) {
      this.previous.clear();
      var e = $s, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const i of _y) {
        if (i === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [l, a] of this.current) {
          if (i.current.has(l))
            if (n && a !== i.current.get(l))
              i.current.set(l, a);
            else
              continue;
          s.push(l);
        }
        if (s.length === 0)
          continue;
        const o = [...i.current.keys()].filter((l) => !this.current.has(l));
        if (o.length > 0) {
          const l = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Map();
          for (const u of s)
            Oz(u, o, l, a);
          if (Fl.length > 0) {
            Sr = i, i.apply();
            for (const u of Fl)
              i.#s(u, r);
            Fl = [], i.deactivate();
          }
        }
      }
      Sr = null, $s = e;
    }
    this.committed = !0, _y.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#n += 1, e && (this.#r += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#n -= 1, e && (this.#r -= 1), this.revive();
  }
  revive() {
    for (const e of this.#l)
      di(e, ps), Pf(e);
    for (const e of this.#i)
      di(e, hu), Pf(e);
    this.#l = [], this.#i = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#a ??= hz()).promise;
  }
  static ensure() {
    if (Sr === null) {
      const e = Sr = new $l();
      _y.add(Sr), jp || $l.enqueue(() => {
        Sr === e && e.flush();
      });
    }
    return Sr;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    Zf(e);
  }
  apply() {
  }
}
function Zwe(t) {
  var e = jp;
  jp = !0;
  try {
    for (var n; ; ) {
      if (Ywe(), Fl.length === 0 && (Sr?.flush(), Fl.length === 0))
        return J2 = null, /** @type {T} */
        n;
      Dz();
    }
  } finally {
    jp = e;
  }
}
function Dz() {
  var t = gf;
  Dk = !0;
  try {
    var e = 0;
    for (NO(!0); Fl.length > 0; ) {
      var n = $l.ensure();
      if (e++ > 1e3) {
        var r, i;
        e3e();
      }
      n.process(Fl), ec.clear();
    }
  } finally {
    Dk = !1, NO(t), J2 = null;
  }
}
function e3e() {
  try {
    Pwe();
  } catch (t) {
    Ud(t, J2);
  }
}
let Ta = null;
function PO(t) {
  var e = t.length;
  if (e !== 0) {
    for (var n = 0; n < e; ) {
      var r = t[n++];
      if ((r.f & (Ju | Vs)) === 0 && Cm(r) && (Ta = /* @__PURE__ */ new Set(), Ug(r), r.deps === null && r.first === null && r.nodes_start === null && (r.teardown === null && r.ac === null ? Kz(r) : r.fn = null), Ta?.size > 0)) {
        ec.clear();
        for (const i of Ta) {
          if ((i.f & (Ju | Vs)) !== 0) continue;
          const s = [i];
          let o = i.parent;
          for (; o !== null; )
            Ta.has(o) && (Ta.delete(o), s.push(o)), o = o.parent;
          for (let l = s.length - 1; l >= 0; l--) {
            const a = s[l];
            (a.f & (Ju | Vs)) === 0 && Ug(a);
          }
        }
        Ta.clear();
      }
    }
    Ta = null;
  }
}
function Oz(t, e, n, r) {
  if (!n.has(t) && (n.add(t), t.reactions !== null))
    for (const i of t.reactions) {
      const s = i.f;
      (s & bi) !== 0 ? Oz(
        /** @type {Derived} */
        i,
        e,
        n,
        r
      ) : (s & (pC | cu)) !== 0 && (s & ps) === 0 && // we may have scheduled this one already
      Fz(i, e, r) && (di(i, ps), Pf(
        /** @type {Effect} */
        i
      ));
    }
}
function Fz(t, e, n) {
  const r = n.get(t);
  if (r !== void 0) return r;
  if (t.deps !== null)
    for (const i of t.deps) {
      if (e.includes(i))
        return !0;
      if ((i.f & bi) !== 0 && Fz(
        /** @type {Derived} */
        i,
        e,
        n
      ))
        return n.set(
          /** @type {Derived} */
          i,
          !0
        ), !0;
    }
  return n.set(t, !1), !1;
}
function Pf(t) {
  for (var e = J2 = t; e.parent !== null; ) {
    e = e.parent;
    var n = e.f;
    if (Dk && e === en && (n & cu) !== 0 && (n & lz) === 0)
      return;
    if ((n & (Jf | fu)) !== 0) {
      if ((n & li) === 0) return;
      e.f ^= li;
    }
  }
  Fl.push(e);
}
function t3e(t) {
  let e = 0, n = If(0), r;
  return () => {
    ex() && (q(n), kC(() => (e === 0 && (r = Sm(() => t(() => qp(n)))), e += 1, () => {
      Zf(() => {
        e -= 1, e === 0 && (r?.(), r = void 0, qp(n));
      });
    })));
  };
}
var n3e = Rf | x0 | G2;
function r3e(t, e, n) {
  new i3e(t, e, n);
}
class i3e {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #n = Ut ? pn : null;
  /** @type {BoundaryProps} */
  #r;
  /** @type {((anchor: Node) => void)} */
  #a;
  /** @type {Effect} */
  #l;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #s = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #c = null;
  #d = 0;
  #f = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #h = null;
  #y = t3e(() => (this.#h = If(this.#d), () => {
    this.#h = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, n, r) {
    this.#t = e, this.#r = n, this.#a = r, this.parent = /** @type {Effect} */
    en.b, this.#e = !!this.#r.pending, this.#l = Em(() => {
      if (en.b = this, Ut) {
        const s = this.#n;
        km(), /** @type {Comment} */
        s.nodeType === w0 && /** @type {Comment} */
        s.data === X2 ? this.#v() : this.#b();
      } else {
        var i = this.#x();
        try {
          this.#i = Lo(() => r(i));
        } catch (s) {
          this.error(s);
        }
        this.#f > 0 ? this.#m() : this.#e = !1;
      }
      return () => {
        this.#c?.remove();
      };
    }, n3e), Ut && (this.#t = pn);
  }
  #b() {
    try {
      this.#i = Lo(() => this.#a(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #v() {
    const e = this.#r.pending;
    e && (this.#s = Lo(() => e(this.#t)), $l.enqueue(() => {
      var n = this.#x();
      this.#i = this.#g(() => ($l.ensure(), Lo(() => this.#a(n)))), this.#f > 0 ? this.#m() : (fd(
        /** @type {Effect} */
        this.#s,
        () => {
          this.#s = null;
        }
      ), this.#e = !1);
    }));
  }
  #x() {
    var e = this.#t;
    return this.#e && (this.#c = na(), this.#t.before(this.#c), e = this.#c), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #g(e) {
    var n = en, r = Qt, i = Zn;
    ra(this.#l), ss(this.#l), qd(this.#l.ctx);
    try {
      return e();
    } catch (s) {
      return Ez(s), null;
    } finally {
      ra(n), ss(r), qd(i);
    }
  }
  #m() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#r.pending
    );
    this.#i !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#c
    ), Qz(this.#i, this.#u)), this.#s === null && (this.#s = Lo(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #w(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#w(e);
      return;
    }
    this.#f += e, this.#f === 0 && (this.#e = !1, this.#s && fd(this.#s, () => {
      this.#s = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#w(e), this.#d += e, this.#h && Hd(this.#h, this.#d);
  }
  get_effect_pending() {
    return this.#y(), q(
      /** @type {Source<number>} */
      this.#h
    );
  }
  /** @param {unknown} error */
  error(e) {
    var n = this.#r.onerror;
    let r = this.#r.failed;
    if (this.#p || !n && !r)
      throw e;
    this.#i && (Li(this.#i), this.#i = null), this.#s && (Li(this.#s), this.#s = null), this.#o && (Li(this.#o), this.#o = null), Ut && (ls(
      /** @type {TemplateNode} */
      this.#n
    ), Qwe(), ls(_v()));
    var i = !1, s = !1;
    const o = () => {
      if (i) {
        Xwe();
        return;
      }
      i = !0, s && $we(), $l.ensure(), this.#d = 0, this.#o !== null && fd(this.#o, () => {
        this.#o = null;
      }), this.#e = this.has_pending_snippet(), this.#i = this.#g(() => (this.#p = !1, Lo(() => this.#a(this.#t)))), this.#f > 0 ? this.#m() : this.#e = !1;
    };
    var l = Qt;
    try {
      ss(null), s = !0, n?.(e, o), s = !1;
    } catch (a) {
      Ud(a, this.#l && this.#l.parent);
    } finally {
      ss(l);
    }
    r && Zf(() => {
      this.#o = this.#g(() => {
        $l.ensure(), this.#p = !0;
        try {
          return Lo(() => {
            r(
              this.#t,
              () => e,
              () => o
            );
          });
        } catch (a) {
          return Ud(
            a,
            /** @type {Effect} */
            this.#l.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function s3e(t, e, n, r) {
  const i = _0() ? Z2 : Tz;
  if (n.length === 0 && t.length === 0) {
    r(e.map(i));
    return;
  }
  var s = Sr, o = (
    /** @type {Effect} */
    en
  ), l = o3e();
  function a() {
    Promise.all(n.map((u) => /* @__PURE__ */ l3e(u))).then((u) => {
      l();
      try {
        r([...e.map(i), ...u]);
      } catch (c) {
        (o.f & Ju) === 0 && Ud(c, o);
      }
      s?.deactivate(), kv();
    }).catch((u) => {
      Ud(u, o);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    l();
    try {
      return a();
    } finally {
      s?.deactivate(), kv();
    }
  }) : a();
}
function o3e() {
  var t = en, e = Qt, n = Zn, r = Sr;
  return function(i = !0) {
    ra(t), ss(e), qd(n), i && r?.activate();
  };
}
function kv() {
  ra(null), ss(null), qd(null);
}
// @__NO_SIDE_EFFECTS__
function Z2(t) {
  var e = bi | ps, n = Qt !== null && (Qt.f & bi) !== 0 ? (
    /** @type {Derived} */
    Qt
  ) : null;
  return en !== null && (en.f |= x0), {
    ctx: Zn,
    deps: null,
    effects: null,
    equals: dz,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      ei
    ),
    wv: 0,
    parent: n ?? en,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function l3e(t, e) {
  let n = (
    /** @type {Effect | null} */
    en
  );
  n === null && Fwe();
  var r = (
    /** @type {Boundary} */
    n.b
  ), i = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), s = If(
    /** @type {V} */
    ei
  ), o = !Qt, l = /* @__PURE__ */ new Map();
  return b3e(() => {
    var a = hz();
    i = a.promise;
    try {
      Promise.resolve(t()).then(a.resolve, a.reject).then(() => {
        u === Sr && u.committed && u.deactivate(), kv();
      });
    } catch (d) {
      a.reject(d), kv();
    }
    var u = (
      /** @type {Batch} */
      Sr
    );
    if (o) {
      var c = !r.is_pending();
      r.update_pending_count(1), u.increment(c), l.get(u)?.reject(zh), l.delete(u), l.set(u, a);
    }
    const f = (d, p = void 0) => {
      if (u.activate(), p)
        p !== zh && (s.f |= Zu, Hd(s, p));
      else {
        (s.f & Zu) !== 0 && (s.f ^= Zu), Hd(s, d);
        for (const [m, y] of l) {
          if (l.delete(m), m === u) break;
          y.reject(zh);
        }
      }
      o && (r.update_pending_count(-1), u.decrement(c));
    };
    a.promise.then(f, (d) => f(null, d || "unknown"));
  }), Hz(() => {
    for (const a of l.values())
      a.reject(zh);
  }), new Promise((a) => {
    function u(c) {
      function f() {
        c === i ? a(s) : u(i);
      }
      c.then(f, f);
    }
    u(i);
  });
}
// @__NO_SIDE_EFFECTS__
function _e(t) {
  const e = /* @__PURE__ */ Z2(t);
  return Bz(e), e;
}
// @__NO_SIDE_EFFECTS__
function Tz(t) {
  const e = /* @__PURE__ */ Z2(t);
  return e.equals = gz, e;
}
function Rz(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var n = 0; n < e.length; n += 1)
      Li(
        /** @type {Effect} */
        e[n]
      );
  }
}
function a3e(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & bi) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function wC(t) {
  var e, n = en;
  ra(a3e(t));
  try {
    t.f &= ~jg, Rz(t), e = jz(t);
  } finally {
    ra(n);
  }
  return e;
}
function Mz(t) {
  var e = wC(t);
  if (t.equals(e) || (t.v = e, t.wv = $z()), !eh)
    if ($s !== null)
      ex() && $s.set(t, t.v);
    else {
      var n = (t.f & tl) === 0 ? hu : li;
      di(t, n);
    }
}
let Ok = /* @__PURE__ */ new Set();
const ec = /* @__PURE__ */ new Map();
let Pz = !1;
function If(t, e) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: dz,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function He(t, e) {
  const n = If(t);
  return Bz(n), n;
}
// @__NO_SIDE_EFFECTS__
function Iz(t, e = !1, n = !0) {
  const r = If(t);
  return e || (r.equals = gz), _m && n && Zn !== null && Zn.l !== null && (Zn.l.s ??= []).push(r), r;
}
function be(t, e, n = !1) {
  Qt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!zl || (Qt.f & RO) !== 0) && _0() && (Qt.f & (bi | cu | pC | RO)) !== 0 && !Ka?.includes(t) && Lwe();
  let r = n ? ai(e) : e;
  return Hd(t, r);
}
function Hd(t, e) {
  if (!t.equals(e)) {
    var n = t.v;
    eh ? ec.set(t, e) : ec.set(t, n), t.v = e;
    var r = $l.ensure();
    r.capture(t, n), (t.f & bi) !== 0 && ((t.f & ps) !== 0 && wC(
      /** @type {Derived} */
      t
    ), di(t, (t.f & tl) !== 0 ? li : hu)), t.wv = $z(), Nz(t, ps), _0() && en !== null && (en.f & li) !== 0 && (en.f & (fu | Jf)) === 0 && (uo === null ? f3e([t]) : uo.push(t)), !r.is_fork && Ok.size > 0 && !Pz && u3e();
  }
  return e;
}
function u3e() {
  Pz = !1;
  const t = Array.from(Ok);
  for (const e of t)
    (e.f & li) !== 0 && di(e, hu), Cm(e) && Ug(e);
  Ok.clear();
}
function qp(t) {
  be(t, t.v + 1);
}
function Nz(t, e) {
  var n = t.reactions;
  if (n !== null)
    for (var r = _0(), i = n.length, s = 0; s < i; s++) {
      var o = n[s], l = o.f;
      if (!(!r && o === en)) {
        var a = (l & ps) === 0;
        if (a && di(o, e), (l & bi) !== 0) {
          var u = (
            /** @type {Derived} */
            o
          );
          $s?.delete(u), (l & jg) === 0 && (l & tl && (o.f |= jg), Nz(u, hu));
        } else a && ((l & cu) !== 0 && Ta !== null && Ta.add(
          /** @type {Effect} */
          o
        ), Pf(
          /** @type {Effect} */
          o
        ));
      }
    }
}
let IO = !1;
function c3e() {
  IO || (IO = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function _C(t) {
  var e = Qt, n = en;
  ss(null), ra(null);
  try {
    return t();
  } finally {
    ss(e), ra(n);
  }
}
let gf = !1;
function NO(t) {
  gf = t;
}
let eh = !1;
function BO(t) {
  eh = t;
}
let Qt = null, zl = !1;
function ss(t) {
  Qt = t;
}
let en = null;
function ra(t) {
  en = t;
}
let Ka = null;
function Bz(t) {
  Qt !== null && (Ka === null ? Ka = [t] : Ka.push(t));
}
let Di = null, Fs = 0, uo = null;
function f3e(t) {
  uo = t;
}
let Lz = 1, qg = 0, mf = qg;
function LO(t) {
  mf = t;
}
function $z() {
  return ++Lz;
}
function Cm(t) {
  var e = t.f;
  if ((e & ps) !== 0)
    return !0;
  if (e & bi && (t.f &= ~jg), (e & hu) !== 0) {
    var n = t.deps;
    if (n !== null)
      for (var r = n.length, i = 0; i < r; i++) {
        var s = n[i];
        if (Cm(
          /** @type {Derived} */
          s
        ) && Mz(
          /** @type {Derived} */
          s
        ), s.wv > t.wv)
          return !0;
      }
    (e & tl) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    $s === null && di(t, li);
  }
  return !1;
}
function zz(t, e, n = !0) {
  var r = t.reactions;
  if (r !== null && !Ka?.includes(t))
    for (var i = 0; i < r.length; i++) {
      var s = r[i];
      (s.f & bi) !== 0 ? zz(
        /** @type {Derived} */
        s,
        e,
        !1
      ) : e === s && (n ? di(s, ps) : (s.f & li) !== 0 && di(s, hu), Pf(
        /** @type {Effect} */
        s
      ));
    }
}
function jz(t) {
  var e = Di, n = Fs, r = uo, i = Qt, s = Ka, o = Zn, l = zl, a = mf, u = t.f;
  Di = /** @type {null | Value[]} */
  null, Fs = 0, uo = null, Qt = (u & (fu | Jf)) === 0 ? t : null, Ka = null, qd(t.ctx), zl = !1, mf = ++qg, t.ac !== null && (_C(() => {
    t.ac.abort(zh);
  }), t.ac = null);
  try {
    t.f |= Sk;
    var c = (
      /** @type {Function} */
      t.fn
    ), f = c(), d = t.deps;
    if (Di !== null) {
      var p;
      if (Cv(t, Fs), d !== null && Fs > 0)
        for (d.length = Fs + Di.length, p = 0; p < Di.length; p++)
          d[Fs + p] = Di[p];
      else
        t.deps = d = Di;
      if (gf && ex() && (t.f & tl) !== 0)
        for (p = Fs; p < d.length; p++)
          (d[p].reactions ??= []).push(t);
    } else d !== null && Fs < d.length && (Cv(t, Fs), d.length = Fs);
    if (_0() && uo !== null && !zl && d !== null && (t.f & (bi | hu | ps)) === 0)
      for (p = 0; p < /** @type {Source[]} */
      uo.length; p++)
        zz(
          uo[p],
          /** @type {Effect} */
          t
        );
    return i !== null && i !== t && (qg++, uo !== null && (r === null ? r = uo : r.push(.../** @type {Source[]} */
    uo))), (t.f & Zu) !== 0 && (t.f ^= Zu), f;
  } catch (m) {
    return Ez(m);
  } finally {
    t.f ^= Sk, Di = e, Fs = n, uo = r, Qt = i, Ka = s, qd(o), zl = l, mf = a;
  }
}
function h3e(t, e) {
  let n = e.reactions;
  if (n !== null) {
    var r = Ewe.call(n, t);
    if (r !== -1) {
      var i = n.length - 1;
      i === 0 ? n = e.reactions = null : (n[r] = n[i], n.pop());
    }
  }
  n === null && (e.f & bi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Di === null || !Di.includes(e)) && (di(e, hu), (e.f & tl) !== 0 && (e.f ^= tl, e.f &= ~jg), Rz(
    /** @type {Derived} **/
    e
  ), Cv(
    /** @type {Derived} **/
    e,
    0
  ));
}
function Cv(t, e) {
  var n = t.deps;
  if (n !== null)
    for (var r = e; r < n.length; r++)
      h3e(t, n[r]);
}
function Ug(t) {
  var e = t.f;
  if ((e & Ju) === 0) {
    di(t, li);
    var n = en, r = gf;
    en = t, gf = !0;
    try {
      (e & cu) !== 0 ? v3e(t) : Gz(t), Wz(t);
      var i = jz(t);
      t.teardown = typeof i == "function" ? i : null, t.wv = Lz;
      var s;
      Awe && zwe && (t.f & ps) !== 0 && t.deps;
    } finally {
      gf = r, en = n;
    }
  }
}
function q(t) {
  var e = t.f, n = (e & bi) !== 0;
  if (Qt !== null && !zl) {
    var r = en !== null && (en.f & Ju) !== 0;
    if (!r && !Ka?.includes(t)) {
      var i = Qt.deps;
      if ((Qt.f & Sk) !== 0)
        t.rv < qg && (t.rv = qg, Di === null && i !== null && i[Fs] === t ? Fs++ : Di === null ? Di = [t] : Di.includes(t) || Di.push(t));
      else {
        (Qt.deps ??= []).push(t);
        var s = t.reactions;
        s === null ? t.reactions = [Qt] : s.includes(Qt) || s.push(Qt);
      }
    }
  }
  if (eh) {
    if (ec.has(t))
      return ec.get(t);
    if (n) {
      var o = (
        /** @type {Derived} */
        t
      ), l = o.v;
      return ((o.f & li) === 0 && o.reactions !== null || Uz(o)) && (l = wC(o)), ec.set(o, l), l;
    }
  } else if (n) {
    if (o = /** @type {Derived} */
    t, $s?.has(o))
      return $s.get(o);
    Cm(o) && Mz(o), gf && ex() && (o.f & tl) === 0 && qz(o);
  } else if ($s?.has(t))
    return $s.get(t);
  if ((t.f & Zu) !== 0)
    throw t.v;
  return t.v;
}
function qz(t) {
  if (t.deps !== null) {
    t.f ^= tl;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & bi) !== 0 && (e.f & tl) === 0 && qz(
        /** @type {Derived} */
        e
      );
  }
}
function Uz(t) {
  if (t.v === ei) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (ec.has(e) || (e.f & bi) !== 0 && Uz(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function Sm(t) {
  var e = zl;
  try {
    return zl = !0, t();
  } finally {
    zl = e;
  }
}
const d3e = -7169;
function di(t, e) {
  t.f = t.f & d3e | e;
}
function p3e(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (pf in t)
      Fk(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const n = t[e];
        typeof n == "object" && n && pf in n && Fk(n);
      }
  }
}
function Fk(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let r in t)
      try {
        Fk(t[r], e);
      } catch {
      }
    const n = Y2(t);
    if (n !== Object.prototype && n !== Array.prototype && n !== Map.prototype && n !== Set.prototype && n !== Date.prototype) {
      const r = cz(n);
      for (let i in r) {
        const s = r[i].get;
        if (s)
          try {
            s.call(t);
          } catch {
          }
      }
    }
  }
}
function g3e(t) {
  en === null && (Qt === null && Mwe(), Rwe()), eh && Twe();
}
function m3e(t, e) {
  var n = e.last;
  n === null ? e.last = e.first = t : (n.next = t, t.prev = n, e.last = t);
}
function du(t, e, n, r = !0) {
  var i = en;
  i !== null && (i.f & Vs) !== 0 && (t |= Vs);
  var s = {
    ctx: Zn,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | ps | tl,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: i,
    b: i && i.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (n)
    try {
      Ug(s), s.f |= K2;
    } catch (a) {
      throw Li(s), a;
    }
  else e !== null && Pf(s);
  if (r) {
    var o = s;
    if (n && o.deps === null && o.teardown === null && o.nodes_start === null && o.first === o.last && // either `null`, or a singular child
    (o.f & x0) === 0 && (o = o.first, (t & cu) !== 0 && (t & Rf) !== 0 && o !== null && (o.f |= Rf)), o !== null && (o.parent = i, i !== null && m3e(o, i), Qt !== null && (Qt.f & bi) !== 0 && (t & Jf) === 0)) {
      var l = (
        /** @type {Derived} */
        Qt
      );
      (l.effects ??= []).push(o);
    }
  }
  return s;
}
function ex() {
  return Qt !== null && !zl;
}
function Hz(t) {
  const e = du(dC, null, !1);
  return di(e, li), e.teardown = t, e;
}
function Xn(t) {
  g3e();
  var e = (
    /** @type {Effect} */
    en.f
  ), n = !Qt && (e & fu) !== 0 && (e & K2) === 0;
  if (n) {
    var r = (
      /** @type {ComponentContext} */
      Zn
    );
    (r.e ??= []).push(t);
  } else
    return Vz(t);
}
function Vz(t) {
  return du(W2 | Cwe, t, !1);
}
function y3e(t) {
  $l.ensure();
  const e = du(Jf | x0, t, !0);
  return (n = {}) => new Promise((r) => {
    n.outro ? fd(e, () => {
      Li(e), r(void 0);
    }) : (Li(e), r(void 0));
  });
}
function Am(t) {
  return du(W2, t, !1);
}
function b3e(t) {
  return du(pC | x0, t, !0);
}
function kC(t, e = 0) {
  return du(dC | e, t, !0);
}
function pr(t, e = [], n = [], r = [], i = !1) {
  s3e(r, e, n, (s) => {
    du(i ? W2 : dC, () => t(...s.map(q)), !0);
  });
}
function Em(t, e = 0) {
  var n = du(cu | e, t, !0);
  return n;
}
function Lo(t, e = !0) {
  return du(fu | x0, t, !0, e);
}
function Wz(t) {
  var e = t.teardown;
  if (e !== null) {
    const n = eh, r = Qt;
    BO(!0), ss(null);
    try {
      e.call(null);
    } finally {
      BO(n), ss(r);
    }
  }
}
function Gz(t, e = !1) {
  var n = t.first;
  for (t.first = t.last = null; n !== null; ) {
    const i = n.ac;
    i !== null && _C(() => {
      i.abort(zh);
    });
    var r = n.next;
    (n.f & Jf) !== 0 ? n.parent = null : Li(n, e), n = r;
  }
}
function v3e(t) {
  for (var e = t.first; e !== null; ) {
    var n = e.next;
    (e.f & fu) === 0 && Li(e), e = n;
  }
}
function Li(t, e = !0) {
  var n = !1;
  (e || (t.f & lz) !== 0) && t.nodes_start !== null && t.nodes_end !== null && (x3e(
    t.nodes_start,
    /** @type {TemplateNode} */
    t.nodes_end
  ), n = !0), Gz(t, e && !n), Cv(t, 0), di(t, Ju);
  var r = t.transitions;
  if (r !== null)
    for (const s of r)
      s.stop();
  Wz(t);
  var i = t.parent;
  i !== null && i.first !== null && Kz(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = t.ac = null;
}
function x3e(t, e) {
  for (; t !== null; ) {
    var n = t === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ha(t)
    );
    t.remove(), t = n;
  }
}
function Kz(t) {
  var e = t.parent, n = t.prev, r = t.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), e !== null && (e.first === t && (e.first = r), e.last === t && (e.last = n));
}
function fd(t, e, n = !0) {
  var r = [];
  CC(t, r, !0), Yz(r, () => {
    n && Li(t), e && e();
  });
}
function Yz(t, e) {
  var n = t.length;
  if (n > 0) {
    var r = () => --n || e();
    for (var i of t)
      i.out(r);
  } else
    e();
}
function CC(t, e, n) {
  if ((t.f & Vs) === 0) {
    if (t.f ^= Vs, t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || n) && e.push(o);
    for (var r = t.first; r !== null; ) {
      var i = r.next, s = (r.f & Rf) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (r.f & fu) !== 0 && (t.f & cu) !== 0;
      CC(r, e, s ? n : !1), r = i;
    }
  }
}
function SC(t) {
  Xz(t, !0);
}
function Xz(t, e) {
  if ((t.f & Vs) !== 0) {
    t.f ^= Vs, (t.f & li) === 0 && (di(t, ps), Pf(t));
    for (var n = t.first; n !== null; ) {
      var r = n.next, i = (n.f & Rf) !== 0 || (n.f & fu) !== 0;
      Xz(n, i ? e : !1), n = r;
    }
    if (t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || e) && s.in();
  }
}
function Qz(t, e) {
  for (var n = t.nodes_start, r = t.nodes_end; n !== null; ) {
    var i = n === r ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ha(n)
    );
    e.append(n), n = i;
  }
}
const Jz = /* @__PURE__ */ new Set(), Tk = /* @__PURE__ */ new Set();
function w3e(t) {
  if (!Ut) return;
  t.removeAttribute("onload"), t.removeAttribute("onerror");
  const e = t.__e;
  e !== void 0 && (t.__e = void 0, queueMicrotask(() => {
    t.isConnected && t.dispatchEvent(e);
  }));
}
function _3e(t, e, n, r = {}) {
  function i(s) {
    if (r.capture || _p.call(e, s), !s.cancelBubble)
      return _C(() => n?.call(this, s));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? Zf(() => {
    e.addEventListener(t, i, r);
  }) : e.addEventListener(t, i, r), i;
}
function Vd(t, e, n, r, i) {
  var s = { capture: r, passive: i }, o = _3e(t, e, n, s);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && Hz(() => {
    e.removeEventListener(t, o, s);
  });
}
function pu(t) {
  for (var e = 0; e < t.length; e++)
    Jz.add(t[e]);
  for (var n of Tk)
    n(t);
}
let $O = null;
function _p(t) {
  var e = this, n = (
    /** @type {Node} */
    e.ownerDocument
  ), r = t.type, i = t.composedPath?.() || [], s = (
    /** @type {null | Element} */
    i[0] || t.target
  );
  $O = t;
  var o = 0, l = $O === t && t.__root;
  if (l) {
    var a = i.indexOf(l);
    if (a !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = i.indexOf(e);
    if (u === -1)
      return;
    a <= u && (o = a);
  }
  if (s = /** @type {Element} */
  i[o] || t.target, s !== e) {
    uz(t, "currentTarget", {
      configurable: !0,
      get() {
        return s || n;
      }
    });
    var c = Qt, f = en;
    ss(null), ra(null);
    try {
      for (var d, p = []; s !== null; ) {
        var m = s.assignedSlot || s.parentNode || /** @type {any} */
        s.host || null;
        try {
          var y = s["__" + r];
          y != null && (!/** @type {any} */
          s.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === s) && y.call(s, t);
        } catch (b) {
          d ? p.push(b) : d = b;
        }
        if (t.cancelBubble || m === e || m === null)
          break;
        s = m;
      }
      if (d) {
        for (let b of p)
          queueMicrotask(() => {
            throw b;
          });
        throw d;
      }
    } finally {
      t.__root = e, delete t.currentTarget, ss(c), ra(f);
    }
  }
}
function k3e(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function hd(t, e) {
  var n = (
    /** @type {Effect} */
    en
  );
  n.nodes_start === null && (n.nodes_start = t, n.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function an(t, e) {
  var n = (e & Hwe) !== 0, r = (e & Vwe) !== 0, i, s = !t.startsWith("<!>");
  return () => {
    if (Ut)
      return hd(pn, null), pn;
    i === void 0 && (i = k3e(s ? t : "<!>" + t), n || (i = /** @type {Node} */
    /* @__PURE__ */ Mf(i)));
    var o = (
      /** @type {TemplateNode} */
      r || kz ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (n) {
      var l = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Mf(o)
      ), a = (
        /** @type {TemplateNode} */
        o.lastChild
      );
      hd(l, a);
    } else
      hd(o, o);
    return o;
  };
}
function zc() {
  if (Ut)
    return hd(pn, null), pn;
  var t = document.createDocumentFragment(), e = document.createComment(""), n = na();
  return t.append(e, n), hd(e, n), t;
}
function Rt(t, e) {
  if (Ut) {
    var n = (
      /** @type {Effect} */
      en
    );
    ((n.f & K2) === 0 || n.nodes_end === null) && (n.nodes_end = pn), km();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
const C3e = ["touchstart", "touchmove"];
function S3e(t) {
  return C3e.includes(t);
}
function da(t, e) {
  var n = e == null ? "" : typeof e == "object" ? e + "" : e;
  n !== (t.__t ??= t.nodeValue) && (t.__t = n, t.nodeValue = n + "");
}
function Zz(t, e) {
  return ej(t, e);
}
function A3e(t, e) {
  Ek(), e.intro = e.intro ?? !1;
  const n = e.target, r = Ut, i = pn;
  try {
    for (var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Mf(n)
    ); s && (s.nodeType !== w0 || /** @type {Comment} */
    s.data !== bz); )
      s = /** @type {TemplateNode} */
      /* @__PURE__ */ ha(s);
    if (!s)
      throw jd;
    qa(!0), ls(
      /** @type {Comment} */
      s
    );
    const o = ej(t, { ...e, anchor: s });
    return qa(!1), /**  @type {Exports} */
    o;
  } catch (o) {
    if (o instanceof Error && o.message.split(`
`).some((l) => l.startsWith("https://svelte.dev/e/")))
      throw o;
    return o !== jd && console.warn("Failed to hydrate: ", o), e.recover === !1 && Iwe(), Ek(), Az(n), qa(!1), Zz(t, e);
  } finally {
    qa(r), ls(i);
  }
}
const kh = /* @__PURE__ */ new Map();
function ej(t, { target: e, anchor: n, props: r = {}, events: i, context: s, intro: o = !0 }) {
  Ek();
  var l = /* @__PURE__ */ new Set(), a = (f) => {
    for (var d = 0; d < f.length; d++) {
      var p = f[d];
      if (!l.has(p)) {
        l.add(p);
        var m = S3e(p);
        e.addEventListener(p, _p, { passive: m });
        var y = kh.get(p);
        y === void 0 ? (document.addEventListener(p, _p, { passive: m }), kh.set(p, 1)) : kh.set(p, y + 1);
      }
    }
  };
  a(yC(Jz)), Tk.add(a);
  var u = void 0, c = y3e(() => {
    var f = n ?? e.appendChild(na());
    return r3e(
      /** @type {TemplateNode} */
      f,
      {
        pending: () => {
        }
      },
      (d) => {
        if (s) {
          sr({});
          var p = (
            /** @type {ComponentContext} */
            Zn
          );
          p.c = s;
        }
        if (i && (r.$$events = i), Ut && hd(
          /** @type {TemplateNode} */
          d,
          null
        ), u = t(d, r) || {}, Ut && (en.nodes_end = pn, pn === null || pn.nodeType !== w0 || /** @type {Comment} */
        pn.data !== xC))
          throw Q2(), jd;
        s && or();
      }
    ), () => {
      for (var d of l) {
        e.removeEventListener(d, _p);
        var p = (
          /** @type {number} */
          kh.get(d)
        );
        --p === 0 ? (document.removeEventListener(d, _p), kh.delete(d)) : kh.set(d, p);
      }
      Tk.delete(a), f !== n && f.parentNode?.removeChild(f);
    };
  });
  return Rk.set(u, c), u;
}
let Rk = /* @__PURE__ */ new WeakMap();
function E3e(t, e) {
  const n = Rk.get(t);
  return n ? (Rk.delete(t), n(e)) : Promise.resolve();
}
function D3e(t) {
  return new O3e(t);
}
class O3e {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var n = /* @__PURE__ */ new Map(), r = (s, o) => {
      var l = /* @__PURE__ */ Iz(o, !1, !1);
      return n.set(s, l), l;
    };
    const i = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(s, o) {
          return q(n.get(o) ?? r(o, Reflect.get(s, o)));
        },
        has(s, o) {
          return o === az ? !0 : (q(n.get(o) ?? r(o, Reflect.get(s, o))), Reflect.has(s, o));
        },
        set(s, o, l) {
          return be(n.get(o) ?? r(o, l), l), Reflect.set(s, o, l);
        }
      }
    );
    this.#t = (e.hydrate ? A3e : Zz)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: i,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && Zwe(), this.#e = i.$$events;
    for (const s of Object.keys(this.#t))
      s === "$set" || s === "$destroy" || s === "$on" || uz(this, s, {
        get() {
          return this.#t[s];
        },
        /** @param {any} value */
        set(o) {
          this.#t[s] = o;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (s) => {
      Object.assign(i, s);
    }, this.#t.$destroy = () => {
      E3e(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, n) {
    this.#e[e] = this.#e[e] || [];
    const r = (...i) => n.call(this, ...i);
    return this.#e[e].push(r), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (i) => i !== r
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
const F3e = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(F3e);
class AC {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #n = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #r = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, n = !0) {
    this.anchor = e, this.#r = n;
  }
  #a = () => {
    var e = (
      /** @type {Batch} */
      Sr
    );
    if (this.#e.has(e)) {
      var n = (
        /** @type {Key} */
        this.#e.get(e)
      ), r = this.#t.get(n);
      if (r)
        SC(r);
      else {
        var i = this.#n.get(n);
        i && (this.#t.set(n, i.effect), this.#n.delete(n), i.fragment.lastChild.remove(), this.anchor.before(i.fragment), r = i.effect);
      }
      for (const [s, o] of this.#e) {
        if (this.#e.delete(s), s === e)
          break;
        const l = this.#n.get(o);
        l && (Li(l.effect), this.#n.delete(o));
      }
      for (const [s, o] of this.#t) {
        if (s === n) continue;
        const l = () => {
          if (Array.from(this.#e.values()).includes(s)) {
            var a = document.createDocumentFragment();
            Qz(o, a), a.append(na()), this.#n.set(s, { effect: o, fragment: a });
          } else
            Li(o);
          this.#t.delete(s);
        };
        this.#r || !r ? fd(o, l, !1) : l();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #l = (e) => {
    this.#e.delete(e);
    const n = Array.from(this.#e.values());
    for (const [r, i] of this.#n)
      n.includes(r) || (Li(i.effect), this.#n.delete(r));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, n) {
    var r = (
      /** @type {Batch} */
      Sr
    ), i = Jwe();
    n && !this.#t.has(e) && !this.#n.has(e) && this.#t.set(
      e,
      Lo(() => n(this.anchor))
    ), this.#e.set(r, e), i || (Ut && (this.anchor = pn), this.#a());
  }
}
function EC(t, e, ...n) {
  var r = new AC(t);
  Em(() => {
    const i = e() ?? null;
    r.ensure(i, i && ((s) => i(s, ...n)));
  }, Rf);
}
function k0(t) {
  Zn === null && mz(), _m && Zn.l !== null ? T3e(Zn).m.push(t) : Xn(() => {
    const e = Sm(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function T3e(t) {
  var e = (
    /** @type {ComponentContextLegacy} */
    t.l
  );
  return e.u ??= { a: [], b: [], m: [] };
}
function Qi(t, e, n = !1) {
  Ut && km();
  var r = new AC(t), i = n ? Rf : 0;
  function s(o, l) {
    if (Ut) {
      const u = _z(t) === X2;
      if (o === u) {
        var a = _v();
        ls(a), r.anchor = a, qa(!1), r.ensure(o, l), qa(!0);
        return;
      }
    }
    r.ensure(o, l);
  }
  Em(() => {
    var o = !1;
    e((l, a = !0) => {
      o = !0, s(a, l);
    }), o || s(!1, null);
  }, i);
}
function R3e(t, e, n) {
  Ut && km();
  var r = new AC(t), i = !_0();
  Em(() => {
    var s = e();
    i && s !== null && typeof s == "object" && (s = /** @type {V} */
    {}), r.ensure(s, n);
  });
}
function M3e(t, e) {
  return e;
}
function P3e(t, e, n) {
  for (var r = t.items, i = [], s = e.length, o = 0; o < s; o++)
    CC(e[o].e, i, !0);
  var l = s > 0 && i.length === 0 && n !== null;
  if (l) {
    var a = (
      /** @type {Element} */
      /** @type {Element} */
      n.parentNode
    );
    Az(a), a.append(
      /** @type {Element} */
      n
    ), r.clear(), _l(t, e[0].prev, e[s - 1].next);
  }
  Yz(i, () => {
    for (var u = 0; u < s; u++) {
      var c = e[u];
      l || (r.delete(c.k), _l(t, c.prev, c.next)), Li(c.e, !l);
    }
  });
}
function Up(t, e, n, r, i, s = null) {
  var o = t, l = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, a = (e & yz) !== 0;
  if (a) {
    var u = (
      /** @type {Element} */
      t
    );
    o = Ut ? ls(
      /** @type {Comment | Text} */
      /* @__PURE__ */ Mf(u)
    ) : u.appendChild(na());
  }
  Ut && km();
  var c = null, f = !1, d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ Tz(() => {
    var v = n();
    return mC(v) ? v : v == null ? [] : yC(v);
  }), m, y;
  function b() {
    I3e(
      y,
      m,
      l,
      d,
      o,
      i,
      e,
      r,
      n
    ), s !== null && (m.length === 0 ? c ? SC(c) : c = Lo(() => s(o)) : c !== null && fd(c, () => {
      c = null;
    }));
  }
  Em(() => {
    y ??= /** @type {Effect} */
    en, m = /** @type {V[]} */
    q(p);
    var v = m.length;
    if (f && v === 0)
      return;
    f = v === 0;
    let _ = !1;
    if (Ut) {
      var k = _z(o) === X2;
      k !== (v === 0) && (o = _v(), ls(o), qa(!1), _ = !0);
    }
    if (Ut) {
      for (var S = null, C, E = 0; E < v; E++) {
        if (pn.nodeType === w0 && /** @type {Comment} */
        pn.data === xC) {
          o = /** @type {Comment} */
          pn, _ = !0, qa(!1);
          break;
        }
        var A = m[E], O = r(A, E);
        C = tj(
          pn,
          l,
          S,
          null,
          A,
          O,
          E,
          i,
          e,
          n
        ), l.items.set(O, C), S = C;
      }
      v > 0 && ls(_v());
    }
    Ut ? v === 0 && s && (c = Lo(() => s(o))) : b(), _ && qa(!0), q(p);
  }), Ut && (o = pn);
}
function I3e(t, e, n, r, i, s, o, l, a) {
  var u = (o & qwe) !== 0, c = (o & (bC | vC)) !== 0, f = e.length, d = n.items, p = n.first, m = p, y, b = null, v, _ = [], k = [], S, C, E, A;
  if (u)
    for (A = 0; A < f; A += 1)
      S = e[A], C = l(S, A), E = d.get(C), E !== void 0 && (E.a?.measure(), (v ??= /* @__PURE__ */ new Set()).add(E));
  for (A = 0; A < f; A += 1) {
    if (S = e[A], C = l(S, A), E = d.get(C), E === void 0) {
      var O = r.get(C);
      if (O !== void 0) {
        r.delete(C), d.set(C, O);
        var T = b ? b.next : m;
        _l(n, b, O), _l(n, O, T), K3(O, T, i), b = O;
      } else {
        var $ = m ? (
          /** @type {TemplateNode} */
          m.e.nodes_start
        ) : i;
        b = tj(
          $,
          n,
          b,
          b === null ? n.first : b.next,
          S,
          C,
          A,
          s,
          o,
          a
        );
      }
      d.set(C, b), _ = [], k = [], m = b.next;
      continue;
    }
    if (c && N3e(E, S, A, o), (E.e.f & Vs) !== 0 && (SC(E.e), u && (E.a?.unfix(), (v ??= /* @__PURE__ */ new Set()).delete(E))), E !== m) {
      if (y !== void 0 && y.has(E)) {
        if (_.length < k.length) {
          var P = k[0], B;
          b = P.prev;
          var M = _[0], L = _[_.length - 1];
          for (B = 0; B < _.length; B += 1)
            K3(_[B], P, i);
          for (B = 0; B < k.length; B += 1)
            y.delete(k[B]);
          _l(n, M.prev, L.next), _l(n, b, M), _l(n, L, P), m = P, b = L, A -= 1, _ = [], k = [];
        } else
          y.delete(E), K3(E, m, i), _l(n, E.prev, E.next), _l(n, E, b === null ? n.first : b.next), _l(n, b, E), b = E;
        continue;
      }
      for (_ = [], k = []; m !== null && m.k !== C; )
        (m.e.f & Vs) === 0 && (y ??= /* @__PURE__ */ new Set()).add(m), k.push(m), m = m.next;
      if (m === null)
        continue;
      E = m;
    }
    _.push(E), b = E, m = E.next;
  }
  if (m !== null || y !== void 0) {
    for (var N = y === void 0 ? [] : yC(y); m !== null; )
      (m.e.f & Vs) === 0 && N.push(m), m = m.next;
    var j = N.length;
    if (j > 0) {
      var U = (o & yz) !== 0 && f === 0 ? i : null;
      if (u) {
        for (A = 0; A < j; A += 1)
          N[A].a?.measure();
        for (A = 0; A < j; A += 1)
          N[A].a?.fix();
      }
      P3e(n, N, U);
    }
  }
  u && Zf(() => {
    if (v !== void 0)
      for (E of v)
        E.a?.apply();
  }), t.first = n.first && n.first.e, t.last = b && b.e;
  for (var H of r.values())
    Li(H.e);
  r.clear();
}
function N3e(t, e, n, r) {
  (r & bC) !== 0 && Hd(t.v, e), (r & vC) !== 0 ? Hd(
    /** @type {Value<number>} */
    t.i,
    n
  ) : t.i = n;
}
function tj(t, e, n, r, i, s, o, l, a, u, c) {
  var f = (a & bC) !== 0, d = (a & Uwe) === 0, p = f ? d ? /* @__PURE__ */ Iz(i, !1, !1) : If(i) : i, m = (a & vC) === 0 ? o : If(o), y = {
    i: m,
    v: p,
    k: s,
    a: null,
    // @ts-expect-error
    e: null,
    prev: n,
    next: r
  };
  try {
    if (t === null) {
      var b = document.createDocumentFragment();
      b.append(t = na());
    }
    return y.e = Lo(() => l(
      /** @type {Node} */
      t,
      p,
      m,
      u
    ), Ut), y.e.prev = n && n.e, y.e.next = r && r.e, n === null ? c || (e.first = y) : (n.next = y, n.e.next = y.e), r !== null && (r.prev = y, r.e.prev = y.e), y;
  } finally {
  }
}
function K3(t, e, n) {
  for (var r = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : n, i = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : n, s = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); s !== null && s !== r; ) {
    var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ha(s)
    );
    i.before(s), s = o;
  }
}
function _l(t, e, n) {
  e === null ? t.first = n : (e.next = n, e.e.next = n && n.e), n !== null && (n.prev = e, n.e.prev = e && e.e);
}
function lr(t, e) {
  Am(() => {
    var n = t.getRootNode(), r = (
      /** @type {ShadowRoot} */
      n.host ? (
        /** @type {ShadowRoot} */
        n
      ) : (
        /** @type {Document} */
        n.head ?? /** @type {Document} */
        n.ownerDocument.head
      )
    );
    if (!r.querySelector("#" + e.hash)) {
      const i = document.createElement("style");
      i.id = e.hash, i.textContent = e.code, r.appendChild(i);
    }
  });
}
function DC(t, e, n) {
  Am(() => {
    var r = Sm(() => e(t, n?.()) || {});
    if (n && r?.update) {
      var i = !1, s = (
        /** @type {any} */
        {}
      );
      kC(() => {
        var o = n();
        p3e(o), i && pz(s, o) && (s = o, r.update(o));
      }), i = !0;
    }
    if (r?.destroy)
      return () => (
        /** @type {Function} */
        r.destroy()
      );
  });
}
function B3e(t, e, n) {
  var r = t == null ? "" : "" + t;
  return e && (r = r ? r + " " + e : e), r === "" ? null : r;
}
function zO(t, e = !1) {
  var n = e ? " !important;" : ";", r = "";
  for (var i in t) {
    var s = t[i];
    s != null && s !== "" && (r += " " + i + ": " + s + n);
  }
  return r;
}
function L3e(t, e) {
  if (e) {
    var n = "", r, i;
    return Array.isArray(e) ? (r = e[0], i = e[1]) : r = e, r && (n += zO(r)), i && (n += zO(i, !0)), n = n.trim(), n === "" ? null : n;
  }
  return String(t);
}
function hc(t, e, n, r, i, s) {
  var o = t.__className;
  if (Ut || o !== n || o === void 0) {
    var l = B3e(n, r);
    (!Ut || l !== t.getAttribute("class")) && (l == null ? t.removeAttribute("class") : t.className = l), t.__className = n;
  }
  return s;
}
function Y3(t, e = {}, n, r) {
  for (var i in n) {
    var s = n[i];
    e[i] !== s && (n[i] == null ? t.style.removeProperty(i) : t.style.setProperty(i, s, r));
  }
}
function gs(t, e, n, r) {
  var i = t.__style;
  if (Ut || i !== e) {
    var s = L3e(e, r);
    (!Ut || s !== t.getAttribute("style")) && (s == null ? t.removeAttribute("style") : t.style.cssText = s), t.__style = e;
  } else r && (Array.isArray(r) ? (Y3(t, n?.[0], r[0]), Y3(t, n?.[1], r[1], "important")) : Y3(t, n, r));
  return r;
}
const $3e = Symbol("is custom element"), z3e = Symbol("is html");
function j3e(t) {
  if (Ut) {
    var e = !1, n = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var r = t.value;
          Hg(t, "value", null), t.value = r;
        }
        if (t.hasAttribute("checked")) {
          var i = t.checked;
          Hg(t, "checked", null), t.checked = i;
        }
      }
    };
    t.__on_r = n, Zf(n), c3e();
  }
}
function q3e(t, e) {
  var n = nj(t);
  n.checked !== (n.checked = // treat null and undefined the same for the initial value
  e ?? void 0) && (t.checked = e);
}
function Hg(t, e, n, r) {
  var i = nj(t);
  Ut && (i[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || i[e] !== (i[e] = n) && (e === "loading" && (t[Swe] = n), n == null ? t.removeAttribute(e) : typeof n != "string" && U3e(t).includes(e) ? t[e] = n : t.setAttribute(e, n));
}
function nj(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [$3e]: t.nodeName.includes("-"),
      [z3e]: t.namespaceURI === Wwe
    }
  );
}
var jO = /* @__PURE__ */ new Map();
function U3e(t) {
  var e = t.getAttribute("is") || t.nodeName, n = jO.get(e);
  if (n) return n;
  jO.set(e, n = []);
  for (var r, i = t, s = Element.prototype; s !== i; ) {
    r = cz(i);
    for (var o in r)
      r[o].set && n.push(o);
    i = Y2(i);
  }
  return n;
}
class OC {
  /** */
  #e = /* @__PURE__ */ new WeakMap();
  /** @type {ResizeObserver | undefined} */
  #t;
  /** @type {ResizeObserverOptions} */
  #n;
  /** @static */
  static entries = /* @__PURE__ */ new WeakMap();
  /** @param {ResizeObserverOptions} options */
  constructor(e) {
    this.#n = e;
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(e, n) {
    var r = this.#e.get(e) || /* @__PURE__ */ new Set();
    return r.add(n), this.#e.set(e, r), this.#r().observe(e, this.#n), () => {
      var i = this.#e.get(e);
      i.delete(n), i.size === 0 && (this.#e.delete(e), this.#t.unobserve(e));
    };
  }
  #r() {
    return this.#t ?? (this.#t = new ResizeObserver(
      /** @param {any} entries */
      (e) => {
        for (var n of e) {
          OC.entries.set(n.target, n);
          for (var r of this.#e.get(n.target) || [])
            r(n);
        }
      }
    ));
  }
}
var H3e = /* @__PURE__ */ new OC({
  box: "border-box"
});
function nl(t, e, n) {
  var r = H3e.observe(t, () => n(t[e]));
  Am(() => (Sm(() => n(t[e])), r));
}
function qO(t, e) {
  return t === e || t?.[pf] === e;
}
function $i(t = {}, e, n, r) {
  return Am(() => {
    var i, s;
    return kC(() => {
      i = s, s = [], Sm(() => {
        t !== n(...s) && (e(t, ...s), i && qO(n(...i), t) && e(null, ...i));
      });
    }), () => {
      Zf(() => {
        s && qO(n(...s), t) && e(null, ...s);
      });
    };
  }), t;
}
let ky = !1;
function V3e(t) {
  var e = ky;
  try {
    return ky = !1, [t(), ky];
  } finally {
    ky = e;
  }
}
function C0(t, e, n, r) {
  var i = (
    /** @type {V} */
    r
  ), s = !0, o = () => (s && (s = !1, i = /** @type {V} */
  r), i), l;
  {
    var a = pf in t || az in t;
    l = cd(t, e)?.set ?? (a && e in t ? (b) => t[e] = b : void 0);
  }
  var u, c = !1;
  [u, c] = V3e(() => (
    /** @type {V} */
    t[e]
  ));
  var f;
  if (f = () => {
    var b = (
      /** @type {V} */
      t[e]
    );
    return b === void 0 ? o() : (s = !0, b);
  }, l) {
    var d = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(b, v) {
        return arguments.length > 0 ? ((!v || d || c) && l(v ? f() : b), b) : f();
      })
    );
  }
  var p = !1, m = /* @__PURE__ */ Z2(() => (p = !1, f()));
  q(m);
  var y = (
    /** @type {Effect} */
    en
  );
  return (
    /** @type {() => V} */
    (function(b, v) {
      if (arguments.length > 0) {
        const _ = v ? q(m) : ai(b);
        return be(m, _), p = !0, i !== void 0 && (i = _), b;
      }
      return eh && p || (y.f & Ju) !== 0 ? m.v : q(m);
    })
  );
}
var $u = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function FC(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var tb = { exports: {} }, W3e = tb.exports, UO;
function G3e() {
  return UO || (UO = 1, (function(t, e) {
    (function() {
      var n, r = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", l = "Invalid `variable` option passed into `_.template`", a = "__lodash_hash_undefined__", u = 500, c = "__lodash_placeholder__", f = 1, d = 2, p = 4, m = 1, y = 2, b = 1, v = 2, _ = 4, k = 8, S = 16, C = 32, E = 64, A = 128, O = 256, T = 512, $ = 30, P = "...", B = 800, M = 16, L = 1, N = 2, j = 3, U = 1 / 0, H = 9007199254740991, G = 17976931348623157e292, re = NaN, se = 4294967295, oe = se - 1, ne = se >>> 1, ce = [
        ["ary", A],
        ["bind", b],
        ["bindKey", v],
        ["curry", k],
        ["curryRight", S],
        ["flip", T],
        ["partial", C],
        ["partialRight", E],
        ["rearg", O]
      ], we = "[object Arguments]", Me = "[object Array]", Pe = "[object AsyncFunction]", Ce = "[object Boolean]", fe = "[object Date]", De = "[object DOMException]", Se = "[object Error]", Ne = "[object Function]", Ye = "[object GeneratorFunction]", Ge = "[object Map]", gt = "[object Number]", Pt = "[object Null]", mt = "[object Object]", Wt = "[object Promise]", un = "[object Proxy]", Ke = "[object RegExp]", Ze = "[object Set]", It = "[object String]", vn = "[object Symbol]", Te = "[object Undefined]", Oe = "[object WeakMap]", et = "[object WeakSet]", kt = "[object ArrayBuffer]", tn = "[object DataView]", Tn = "[object Float32Array]", Gt = "[object Float64Array]", Je = "[object Int8Array]", gn = "[object Int16Array]", tr = "[object Int32Array]", xi = "[object Uint8Array]", pa = "[object Uint8ClampedArray]", qn = "[object Uint16Array]", qr = "[object Uint32Array]", ys = /\b__p \+= '';/g, al = /\b(__p \+=) '' \+/g, So = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Ao = /&(?:amp|lt|gt|quot|#39);/g, xc = /[&<>"']/g, tx = RegExp(Ao.source), nx = RegExp(xc.source), ul = /<%-([\s\S]+?)%>/g, Dm = /<%([\s\S]+?)%>/g, Om = /<%=([\s\S]+?)%>/g, Fm = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rx = /^\w*$/, Tm = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, S0 = /[\\^$.*+?()[\]{}|]/g, ix = RegExp(S0.source), A0 = /^\s+/, Rm = /\s/, sx = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ox = /\{\n\/\* \[wrapped with (.+)\] \*/, lx = /,? & /, ve = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Re = /[()=,{}\[\]\/\s]/, qe = /\\(\\)?/g, Xe = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, tt = /\w*$/, ft = /^[-+]0x[0-9a-f]+$/i, Ht = /^0b[01]+$/i, mn = /^\[object .+?Constructor\]$/, An = /^0o[0-7]+$/i, ar = /^(?:0|[1-9]\d*)$/, Qs = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Fr = /($^)/, bs = /['\n\r\u2028\u2029\\]/g, Eo = "\\ud800-\\udfff", E0 = "\\u0300-\\u036f", Do = "\\ufe20-\\ufe2f", ga = "\\u20d0-\\u20ff", ma = E0 + Do + ga, RC = "\\u2700-\\u27bf", MC = "a-z\\xdf-\\xf6\\xf8-\\xff", dj = "\\xac\\xb1\\xd7\\xf7", pj = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", gj = "\\u2000-\\u206f", mj = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", PC = "A-Z\\xc0-\\xd6\\xd8-\\xde", IC = "\\ufe0e\\ufe0f", NC = dj + pj + gj + mj, ax = "['â€™]", yj = "[" + Eo + "]", BC = "[" + NC + "]", Mm = "[" + ma + "]", LC = "\\d+", bj = "[" + RC + "]", $C = "[" + MC + "]", zC = "[^" + Eo + NC + LC + RC + MC + PC + "]", ux = "\\ud83c[\\udffb-\\udfff]", vj = "(?:" + Mm + "|" + ux + ")", jC = "[^" + Eo + "]", cx = "(?:\\ud83c[\\udde6-\\uddff]){2}", fx = "[\\ud800-\\udbff][\\udc00-\\udfff]", th = "[" + PC + "]", qC = "\\u200d", UC = "(?:" + $C + "|" + zC + ")", xj = "(?:" + th + "|" + zC + ")", HC = "(?:" + ax + "(?:d|ll|m|re|s|t|ve))?", VC = "(?:" + ax + "(?:D|LL|M|RE|S|T|VE))?", WC = vj + "?", GC = "[" + IC + "]?", wj = "(?:" + qC + "(?:" + [jC, cx, fx].join("|") + ")" + GC + WC + ")*", _j = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", kj = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", KC = GC + WC + wj, Cj = "(?:" + [bj, cx, fx].join("|") + ")" + KC, Sj = "(?:" + [jC + Mm + "?", Mm, cx, fx, yj].join("|") + ")", Aj = RegExp(ax, "g"), Ej = RegExp(Mm, "g"), hx = RegExp(ux + "(?=" + ux + ")|" + Sj + KC, "g"), Dj = RegExp([
        th + "?" + $C + "+" + HC + "(?=" + [BC, th, "$"].join("|") + ")",
        xj + "+" + VC + "(?=" + [BC, th + UC, "$"].join("|") + ")",
        th + "?" + UC + "+" + HC,
        th + "+" + VC,
        kj,
        _j,
        LC,
        Cj
      ].join("|"), "g"), Oj = RegExp("[" + qC + Eo + ma + IC + "]"), Fj = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Tj = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], Rj = -1, Nn = {};
      Nn[Tn] = Nn[Gt] = Nn[Je] = Nn[gn] = Nn[tr] = Nn[xi] = Nn[pa] = Nn[qn] = Nn[qr] = !0, Nn[we] = Nn[Me] = Nn[kt] = Nn[Ce] = Nn[tn] = Nn[fe] = Nn[Se] = Nn[Ne] = Nn[Ge] = Nn[gt] = Nn[mt] = Nn[Ke] = Nn[Ze] = Nn[It] = Nn[Oe] = !1;
      var Rn = {};
      Rn[we] = Rn[Me] = Rn[kt] = Rn[tn] = Rn[Ce] = Rn[fe] = Rn[Tn] = Rn[Gt] = Rn[Je] = Rn[gn] = Rn[tr] = Rn[Ge] = Rn[gt] = Rn[mt] = Rn[Ke] = Rn[Ze] = Rn[It] = Rn[vn] = Rn[xi] = Rn[pa] = Rn[qn] = Rn[qr] = !0, Rn[Se] = Rn[Ne] = Rn[Oe] = !1;
      var Mj = {
        // Latin-1 Supplement block.
        Ã€: "A",
        Ã: "A",
        Ã‚: "A",
        Ãƒ: "A",
        Ã„: "A",
        Ã…: "A",
        Ã : "a",
        Ã¡: "a",
        Ã¢: "a",
        Ã£: "a",
        Ã¤: "a",
        Ã¥: "a",
        Ã‡: "C",
        Ã§: "c",
        Ã: "D",
        Ã°: "d",
        Ãˆ: "E",
        Ã‰: "E",
        ÃŠ: "E",
        Ã‹: "E",
        Ã¨: "e",
        Ã©: "e",
        Ãª: "e",
        Ã«: "e",
        ÃŒ: "I",
        Ã: "I",
        ÃŽ: "I",
        Ã: "I",
        Ã¬: "i",
        Ã­: "i",
        Ã®: "i",
        Ã¯: "i",
        Ã‘: "N",
        Ã±: "n",
        Ã’: "O",
        Ã“: "O",
        Ã”: "O",
        Ã•: "O",
        Ã–: "O",
        Ã˜: "O",
        Ã²: "o",
        Ã³: "o",
        Ã´: "o",
        Ãµ: "o",
        Ã¶: "o",
        Ã¸: "o",
        Ã™: "U",
        Ãš: "U",
        Ã›: "U",
        Ãœ: "U",
        Ã¹: "u",
        Ãº: "u",
        Ã»: "u",
        Ã¼: "u",
        Ã: "Y",
        Ã½: "y",
        Ã¿: "y",
        Ã†: "Ae",
        Ã¦: "ae",
        Ãž: "Th",
        Ã¾: "th",
        ÃŸ: "ss",
        // Latin Extended-A block.
        Ä€: "A",
        Ä‚: "A",
        Ä„: "A",
        Ä: "a",
        Äƒ: "a",
        Ä…: "a",
        Ä†: "C",
        Äˆ: "C",
        ÄŠ: "C",
        ÄŒ: "C",
        Ä‡: "c",
        Ä‰: "c",
        Ä‹: "c",
        Ä: "c",
        ÄŽ: "D",
        Ä: "D",
        Ä: "d",
        Ä‘: "d",
        Ä’: "E",
        Ä”: "E",
        Ä–: "E",
        Ä˜: "E",
        Äš: "E",
        Ä“: "e",
        Ä•: "e",
        Ä—: "e",
        Ä™: "e",
        Ä›: "e",
        Äœ: "G",
        Äž: "G",
        Ä : "G",
        Ä¢: "G",
        Ä: "g",
        ÄŸ: "g",
        Ä¡: "g",
        Ä£: "g",
        Ä¤: "H",
        Ä¦: "H",
        Ä¥: "h",
        Ä§: "h",
        Ä¨: "I",
        Äª: "I",
        Ä¬: "I",
        Ä®: "I",
        Ä°: "I",
        Ä©: "i",
        Ä«: "i",
        Ä­: "i",
        Ä¯: "i",
        Ä±: "i",
        Ä´: "J",
        Äµ: "j",
        Ä¶: "K",
        Ä·: "k",
        Ä¸: "k",
        Ä¹: "L",
        Ä»: "L",
        Ä½: "L",
        Ä¿: "L",
        Å: "L",
        Äº: "l",
        Ä¼: "l",
        Ä¾: "l",
        Å€: "l",
        Å‚: "l",
        Åƒ: "N",
        Å…: "N",
        Å‡: "N",
        ÅŠ: "N",
        Å„: "n",
        Å†: "n",
        Åˆ: "n",
        Å‹: "n",
        ÅŒ: "O",
        ÅŽ: "O",
        Å: "O",
        Å: "o",
        Å: "o",
        Å‘: "o",
        Å”: "R",
        Å–: "R",
        Å˜: "R",
        Å•: "r",
        Å—: "r",
        Å™: "r",
        Åš: "S",
        Åœ: "S",
        Åž: "S",
        Å : "S",
        Å›: "s",
        Å: "s",
        ÅŸ: "s",
        Å¡: "s",
        Å¢: "T",
        Å¤: "T",
        Å¦: "T",
        Å£: "t",
        Å¥: "t",
        Å§: "t",
        Å¨: "U",
        Åª: "U",
        Å¬: "U",
        Å®: "U",
        Å°: "U",
        Å²: "U",
        Å©: "u",
        Å«: "u",
        Å­: "u",
        Å¯: "u",
        Å±: "u",
        Å³: "u",
        Å´: "W",
        Åµ: "w",
        Å¶: "Y",
        Å·: "y",
        Å¸: "Y",
        Å¹: "Z",
        Å»: "Z",
        Å½: "Z",
        Åº: "z",
        Å¼: "z",
        Å¾: "z",
        Ä²: "IJ",
        Ä³: "ij",
        Å’: "Oe",
        Å“: "oe",
        Å‰: "'n",
        Å¿: "s"
      }, Pj = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, Ij = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, Nj = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, Bj = parseFloat, Lj = parseInt, YC = typeof $u == "object" && $u && $u.Object === Object && $u, $j = typeof self == "object" && self && self.Object === Object && self, Ur = YC || $j || Function("return this")(), dx = e && !e.nodeType && e, wc = dx && !0 && t && !t.nodeType && t, XC = wc && wc.exports === dx, px = XC && YC.process, Js = (function() {
        try {
          var Z = wc && wc.require && wc.require("util").types;
          return Z || px && px.binding && px.binding("util");
        } catch {
        }
      })(), QC = Js && Js.isArrayBuffer, JC = Js && Js.isDate, ZC = Js && Js.isMap, eS = Js && Js.isRegExp, tS = Js && Js.isSet, nS = Js && Js.isTypedArray;
      function vs(Z, he, le) {
        switch (le.length) {
          case 0:
            return Z.call(he);
          case 1:
            return Z.call(he, le[0]);
          case 2:
            return Z.call(he, le[0], le[1]);
          case 3:
            return Z.call(he, le[0], le[1], le[2]);
        }
        return Z.apply(he, le);
      }
      function zj(Z, he, le, je) {
        for (var bt = -1, cn = Z == null ? 0 : Z.length; ++bt < cn; ) {
          var _r = Z[bt];
          he(je, _r, le(_r), Z);
        }
        return je;
      }
      function Zs(Z, he) {
        for (var le = -1, je = Z == null ? 0 : Z.length; ++le < je && he(Z[le], le, Z) !== !1; )
          ;
        return Z;
      }
      function jj(Z, he) {
        for (var le = Z == null ? 0 : Z.length; le-- && he(Z[le], le, Z) !== !1; )
          ;
        return Z;
      }
      function rS(Z, he) {
        for (var le = -1, je = Z == null ? 0 : Z.length; ++le < je; )
          if (!he(Z[le], le, Z))
            return !1;
        return !0;
      }
      function mu(Z, he) {
        for (var le = -1, je = Z == null ? 0 : Z.length, bt = 0, cn = []; ++le < je; ) {
          var _r = Z[le];
          he(_r, le, Z) && (cn[bt++] = _r);
        }
        return cn;
      }
      function Pm(Z, he) {
        var le = Z == null ? 0 : Z.length;
        return !!le && nh(Z, he, 0) > -1;
      }
      function gx(Z, he, le) {
        for (var je = -1, bt = Z == null ? 0 : Z.length; ++je < bt; )
          if (le(he, Z[je]))
            return !0;
        return !1;
      }
      function Un(Z, he) {
        for (var le = -1, je = Z == null ? 0 : Z.length, bt = Array(je); ++le < je; )
          bt[le] = he(Z[le], le, Z);
        return bt;
      }
      function yu(Z, he) {
        for (var le = -1, je = he.length, bt = Z.length; ++le < je; )
          Z[bt + le] = he[le];
        return Z;
      }
      function mx(Z, he, le, je) {
        var bt = -1, cn = Z == null ? 0 : Z.length;
        for (je && cn && (le = Z[++bt]); ++bt < cn; )
          le = he(le, Z[bt], bt, Z);
        return le;
      }
      function qj(Z, he, le, je) {
        var bt = Z == null ? 0 : Z.length;
        for (je && bt && (le = Z[--bt]); bt--; )
          le = he(le, Z[bt], bt, Z);
        return le;
      }
      function yx(Z, he) {
        for (var le = -1, je = Z == null ? 0 : Z.length; ++le < je; )
          if (he(Z[le], le, Z))
            return !0;
        return !1;
      }
      var Uj = bx("length");
      function Hj(Z) {
        return Z.split("");
      }
      function Vj(Z) {
        return Z.match(ve) || [];
      }
      function iS(Z, he, le) {
        var je;
        return le(Z, function(bt, cn, _r) {
          if (he(bt, cn, _r))
            return je = cn, !1;
        }), je;
      }
      function Im(Z, he, le, je) {
        for (var bt = Z.length, cn = le + (je ? 1 : -1); je ? cn-- : ++cn < bt; )
          if (he(Z[cn], cn, Z))
            return cn;
        return -1;
      }
      function nh(Z, he, le) {
        return he === he ? rq(Z, he, le) : Im(Z, sS, le);
      }
      function Wj(Z, he, le, je) {
        for (var bt = le - 1, cn = Z.length; ++bt < cn; )
          if (je(Z[bt], he))
            return bt;
        return -1;
      }
      function sS(Z) {
        return Z !== Z;
      }
      function oS(Z, he) {
        var le = Z == null ? 0 : Z.length;
        return le ? xx(Z, he) / le : re;
      }
      function bx(Z) {
        return function(he) {
          return he == null ? n : he[Z];
        };
      }
      function vx(Z) {
        return function(he) {
          return Z == null ? n : Z[he];
        };
      }
      function lS(Z, he, le, je, bt) {
        return bt(Z, function(cn, _r, En) {
          le = je ? (je = !1, cn) : he(le, cn, _r, En);
        }), le;
      }
      function Gj(Z, he) {
        var le = Z.length;
        for (Z.sort(he); le--; )
          Z[le] = Z[le].value;
        return Z;
      }
      function xx(Z, he) {
        for (var le, je = -1, bt = Z.length; ++je < bt; ) {
          var cn = he(Z[je]);
          cn !== n && (le = le === n ? cn : le + cn);
        }
        return le;
      }
      function wx(Z, he) {
        for (var le = -1, je = Array(Z); ++le < Z; )
          je[le] = he(le);
        return je;
      }
      function Kj(Z, he) {
        return Un(he, function(le) {
          return [le, Z[le]];
        });
      }
      function aS(Z) {
        return Z && Z.slice(0, hS(Z) + 1).replace(A0, "");
      }
      function xs(Z) {
        return function(he) {
          return Z(he);
        };
      }
      function _x(Z, he) {
        return Un(he, function(le) {
          return Z[le];
        });
      }
      function D0(Z, he) {
        return Z.has(he);
      }
      function uS(Z, he) {
        for (var le = -1, je = Z.length; ++le < je && nh(he, Z[le], 0) > -1; )
          ;
        return le;
      }
      function cS(Z, he) {
        for (var le = Z.length; le-- && nh(he, Z[le], 0) > -1; )
          ;
        return le;
      }
      function Yj(Z, he) {
        for (var le = Z.length, je = 0; le--; )
          Z[le] === he && ++je;
        return je;
      }
      var Xj = vx(Mj), Qj = vx(Pj);
      function Jj(Z) {
        return "\\" + Nj[Z];
      }
      function Zj(Z, he) {
        return Z == null ? n : Z[he];
      }
      function rh(Z) {
        return Oj.test(Z);
      }
      function eq(Z) {
        return Fj.test(Z);
      }
      function tq(Z) {
        for (var he, le = []; !(he = Z.next()).done; )
          le.push(he.value);
        return le;
      }
      function kx(Z) {
        var he = -1, le = Array(Z.size);
        return Z.forEach(function(je, bt) {
          le[++he] = [bt, je];
        }), le;
      }
      function fS(Z, he) {
        return function(le) {
          return Z(he(le));
        };
      }
      function bu(Z, he) {
        for (var le = -1, je = Z.length, bt = 0, cn = []; ++le < je; ) {
          var _r = Z[le];
          (_r === he || _r === c) && (Z[le] = c, cn[bt++] = le);
        }
        return cn;
      }
      function Nm(Z) {
        var he = -1, le = Array(Z.size);
        return Z.forEach(function(je) {
          le[++he] = je;
        }), le;
      }
      function nq(Z) {
        var he = -1, le = Array(Z.size);
        return Z.forEach(function(je) {
          le[++he] = [je, je];
        }), le;
      }
      function rq(Z, he, le) {
        for (var je = le - 1, bt = Z.length; ++je < bt; )
          if (Z[je] === he)
            return je;
        return -1;
      }
      function iq(Z, he, le) {
        for (var je = le + 1; je--; )
          if (Z[je] === he)
            return je;
        return je;
      }
      function ih(Z) {
        return rh(Z) ? oq(Z) : Uj(Z);
      }
      function Oo(Z) {
        return rh(Z) ? lq(Z) : Hj(Z);
      }
      function hS(Z) {
        for (var he = Z.length; he-- && Rm.test(Z.charAt(he)); )
          ;
        return he;
      }
      var sq = vx(Ij);
      function oq(Z) {
        for (var he = hx.lastIndex = 0; hx.test(Z); )
          ++he;
        return he;
      }
      function lq(Z) {
        return Z.match(hx) || [];
      }
      function aq(Z) {
        return Z.match(Dj) || [];
      }
      var uq = (function Z(he) {
        he = he == null ? Ur : sh.defaults(Ur.Object(), he, sh.pick(Ur, Tj));
        var le = he.Array, je = he.Date, bt = he.Error, cn = he.Function, _r = he.Math, En = he.Object, Cx = he.RegExp, cq = he.String, eo = he.TypeError, Bm = le.prototype, fq = cn.prototype, oh = En.prototype, Lm = he["__core-js_shared__"], $m = fq.toString, xn = oh.hasOwnProperty, hq = 0, dS = (function() {
          var h = /[^.]+$/.exec(Lm && Lm.keys && Lm.keys.IE_PROTO || "");
          return h ? "Symbol(src)_1." + h : "";
        })(), zm = oh.toString, dq = $m.call(En), pq = Ur._, gq = Cx(
          "^" + $m.call(xn).replace(S0, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), jm = XC ? he.Buffer : n, vu = he.Symbol, qm = he.Uint8Array, pS = jm ? jm.allocUnsafe : n, Um = fS(En.getPrototypeOf, En), gS = En.create, mS = oh.propertyIsEnumerable, Hm = Bm.splice, yS = vu ? vu.isConcatSpreadable : n, O0 = vu ? vu.iterator : n, _c = vu ? vu.toStringTag : n, Vm = (function() {
          try {
            var h = Ec(En, "defineProperty");
            return h({}, "", {}), h;
          } catch {
          }
        })(), mq = he.clearTimeout !== Ur.clearTimeout && he.clearTimeout, yq = je && je.now !== Ur.Date.now && je.now, bq = he.setTimeout !== Ur.setTimeout && he.setTimeout, Wm = _r.ceil, Gm = _r.floor, Sx = En.getOwnPropertySymbols, vq = jm ? jm.isBuffer : n, bS = he.isFinite, xq = Bm.join, wq = fS(En.keys, En), kr = _r.max, Xr = _r.min, _q = je.now, kq = he.parseInt, vS = _r.random, Cq = Bm.reverse, Ax = Ec(he, "DataView"), F0 = Ec(he, "Map"), Ex = Ec(he, "Promise"), lh = Ec(he, "Set"), T0 = Ec(he, "WeakMap"), R0 = Ec(En, "create"), Km = T0 && new T0(), ah = {}, Sq = Dc(Ax), Aq = Dc(F0), Eq = Dc(Ex), Dq = Dc(lh), Oq = Dc(T0), Ym = vu ? vu.prototype : n, M0 = Ym ? Ym.valueOf : n, xS = Ym ? Ym.toString : n;
        function I(h) {
          if (nr(h) && !xt(h) && !(h instanceof Lt)) {
            if (h instanceof to)
              return h;
            if (xn.call(h, "__wrapped__"))
              return w8(h);
          }
          return new to(h);
        }
        var uh = /* @__PURE__ */ (function() {
          function h() {
          }
          return function(g) {
            if (!Kn(g))
              return {};
            if (gS)
              return gS(g);
            h.prototype = g;
            var w = new h();
            return h.prototype = n, w;
          };
        })();
        function Xm() {
        }
        function to(h, g) {
          this.__wrapped__ = h, this.__actions__ = [], this.__chain__ = !!g, this.__index__ = 0, this.__values__ = n;
        }
        I.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: ul,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: Dm,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: Om,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: I
          }
        }, I.prototype = Xm.prototype, I.prototype.constructor = I, to.prototype = uh(Xm.prototype), to.prototype.constructor = to;
        function Lt(h) {
          this.__wrapped__ = h, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = se, this.__views__ = [];
        }
        function Fq() {
          var h = new Lt(this.__wrapped__);
          return h.__actions__ = zi(this.__actions__), h.__dir__ = this.__dir__, h.__filtered__ = this.__filtered__, h.__iteratees__ = zi(this.__iteratees__), h.__takeCount__ = this.__takeCount__, h.__views__ = zi(this.__views__), h;
        }
        function Tq() {
          if (this.__filtered__) {
            var h = new Lt(this);
            h.__dir__ = -1, h.__filtered__ = !0;
          } else
            h = this.clone(), h.__dir__ *= -1;
          return h;
        }
        function Rq() {
          var h = this.__wrapped__.value(), g = this.__dir__, w = xt(h), D = g < 0, F = w ? h.length : 0, z = HU(0, F, this.__views__), V = z.start, Y = z.end, ee = Y - V, pe = D ? Y : V - 1, me = this.__iteratees__, xe = me.length, Be = 0, Ve = Xr(ee, this.__takeCount__);
          if (!w || !D && F == ee && Ve == ee)
            return HS(h, this.__actions__);
          var ot = [];
          e:
            for (; ee-- && Be < Ve; ) {
              pe += g;
              for (var Ot = -1, lt = h[pe]; ++Ot < xe; ) {
                var Nt = me[Ot], qt = Nt.iteratee, ks = Nt.type, ki = qt(lt);
                if (ks == N)
                  lt = ki;
                else if (!ki) {
                  if (ks == L)
                    continue e;
                  break e;
                }
              }
              ot[Be++] = lt;
            }
          return ot;
        }
        Lt.prototype = uh(Xm.prototype), Lt.prototype.constructor = Lt;
        function kc(h) {
          var g = -1, w = h == null ? 0 : h.length;
          for (this.clear(); ++g < w; ) {
            var D = h[g];
            this.set(D[0], D[1]);
          }
        }
        function Mq() {
          this.__data__ = R0 ? R0(null) : {}, this.size = 0;
        }
        function Pq(h) {
          var g = this.has(h) && delete this.__data__[h];
          return this.size -= g ? 1 : 0, g;
        }
        function Iq(h) {
          var g = this.__data__;
          if (R0) {
            var w = g[h];
            return w === a ? n : w;
          }
          return xn.call(g, h) ? g[h] : n;
        }
        function Nq(h) {
          var g = this.__data__;
          return R0 ? g[h] !== n : xn.call(g, h);
        }
        function Bq(h, g) {
          var w = this.__data__;
          return this.size += this.has(h) ? 0 : 1, w[h] = R0 && g === n ? a : g, this;
        }
        kc.prototype.clear = Mq, kc.prototype.delete = Pq, kc.prototype.get = Iq, kc.prototype.has = Nq, kc.prototype.set = Bq;
        function ya(h) {
          var g = -1, w = h == null ? 0 : h.length;
          for (this.clear(); ++g < w; ) {
            var D = h[g];
            this.set(D[0], D[1]);
          }
        }
        function Lq() {
          this.__data__ = [], this.size = 0;
        }
        function $q(h) {
          var g = this.__data__, w = Qm(g, h);
          if (w < 0)
            return !1;
          var D = g.length - 1;
          return w == D ? g.pop() : Hm.call(g, w, 1), --this.size, !0;
        }
        function zq(h) {
          var g = this.__data__, w = Qm(g, h);
          return w < 0 ? n : g[w][1];
        }
        function jq(h) {
          return Qm(this.__data__, h) > -1;
        }
        function qq(h, g) {
          var w = this.__data__, D = Qm(w, h);
          return D < 0 ? (++this.size, w.push([h, g])) : w[D][1] = g, this;
        }
        ya.prototype.clear = Lq, ya.prototype.delete = $q, ya.prototype.get = zq, ya.prototype.has = jq, ya.prototype.set = qq;
        function ba(h) {
          var g = -1, w = h == null ? 0 : h.length;
          for (this.clear(); ++g < w; ) {
            var D = h[g];
            this.set(D[0], D[1]);
          }
        }
        function Uq() {
          this.size = 0, this.__data__ = {
            hash: new kc(),
            map: new (F0 || ya)(),
            string: new kc()
          };
        }
        function Hq(h) {
          var g = u1(this, h).delete(h);
          return this.size -= g ? 1 : 0, g;
        }
        function Vq(h) {
          return u1(this, h).get(h);
        }
        function Wq(h) {
          return u1(this, h).has(h);
        }
        function Gq(h, g) {
          var w = u1(this, h), D = w.size;
          return w.set(h, g), this.size += w.size == D ? 0 : 1, this;
        }
        ba.prototype.clear = Uq, ba.prototype.delete = Hq, ba.prototype.get = Vq, ba.prototype.has = Wq, ba.prototype.set = Gq;
        function Cc(h) {
          var g = -1, w = h == null ? 0 : h.length;
          for (this.__data__ = new ba(); ++g < w; )
            this.add(h[g]);
        }
        function Kq(h) {
          return this.__data__.set(h, a), this;
        }
        function Yq(h) {
          return this.__data__.has(h);
        }
        Cc.prototype.add = Cc.prototype.push = Kq, Cc.prototype.has = Yq;
        function Fo(h) {
          var g = this.__data__ = new ya(h);
          this.size = g.size;
        }
        function Xq() {
          this.__data__ = new ya(), this.size = 0;
        }
        function Qq(h) {
          var g = this.__data__, w = g.delete(h);
          return this.size = g.size, w;
        }
        function Jq(h) {
          return this.__data__.get(h);
        }
        function Zq(h) {
          return this.__data__.has(h);
        }
        function eU(h, g) {
          var w = this.__data__;
          if (w instanceof ya) {
            var D = w.__data__;
            if (!F0 || D.length < i - 1)
              return D.push([h, g]), this.size = ++w.size, this;
            w = this.__data__ = new ba(D);
          }
          return w.set(h, g), this.size = w.size, this;
        }
        Fo.prototype.clear = Xq, Fo.prototype.delete = Qq, Fo.prototype.get = Jq, Fo.prototype.has = Zq, Fo.prototype.set = eU;
        function wS(h, g) {
          var w = xt(h), D = !w && Oc(h), F = !w && !D && Cu(h), z = !w && !D && !F && dh(h), V = w || D || F || z, Y = V ? wx(h.length, cq) : [], ee = Y.length;
          for (var pe in h)
            (g || xn.call(h, pe)) && !(V && // Safari 9 has enumerable `arguments.length` in strict mode.
            (pe == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            F && (pe == "offset" || pe == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            z && (pe == "buffer" || pe == "byteLength" || pe == "byteOffset") || // Skip index properties.
            _a(pe, ee))) && Y.push(pe);
          return Y;
        }
        function _S(h) {
          var g = h.length;
          return g ? h[Lx(0, g - 1)] : n;
        }
        function tU(h, g) {
          return c1(zi(h), Sc(g, 0, h.length));
        }
        function nU(h) {
          return c1(zi(h));
        }
        function Dx(h, g, w) {
          (w !== n && !To(h[g], w) || w === n && !(g in h)) && va(h, g, w);
        }
        function P0(h, g, w) {
          var D = h[g];
          (!(xn.call(h, g) && To(D, w)) || w === n && !(g in h)) && va(h, g, w);
        }
        function Qm(h, g) {
          for (var w = h.length; w--; )
            if (To(h[w][0], g))
              return w;
          return -1;
        }
        function rU(h, g, w, D) {
          return xu(h, function(F, z, V) {
            g(D, F, w(F), V);
          }), D;
        }
        function kS(h, g) {
          return h && fl(g, Tr(g), h);
        }
        function iU(h, g) {
          return h && fl(g, qi(g), h);
        }
        function va(h, g, w) {
          g == "__proto__" && Vm ? Vm(h, g, {
            configurable: !0,
            enumerable: !0,
            value: w,
            writable: !0
          }) : h[g] = w;
        }
        function Ox(h, g) {
          for (var w = -1, D = g.length, F = le(D), z = h == null; ++w < D; )
            F[w] = z ? n : uw(h, g[w]);
          return F;
        }
        function Sc(h, g, w) {
          return h === h && (w !== n && (h = h <= w ? h : w), g !== n && (h = h >= g ? h : g)), h;
        }
        function no(h, g, w, D, F, z) {
          var V, Y = g & f, ee = g & d, pe = g & p;
          if (w && (V = F ? w(h, D, F, z) : w(h)), V !== n)
            return V;
          if (!Kn(h))
            return h;
          var me = xt(h);
          if (me) {
            if (V = WU(h), !Y)
              return zi(h, V);
          } else {
            var xe = Qr(h), Be = xe == Ne || xe == Ye;
            if (Cu(h))
              return GS(h, Y);
            if (xe == mt || xe == we || Be && !F) {
              if (V = ee || Be ? {} : h8(h), !Y)
                return ee ? IU(h, iU(V, h)) : PU(h, kS(V, h));
            } else {
              if (!Rn[xe])
                return F ? h : {};
              V = GU(h, xe, Y);
            }
          }
          z || (z = new Fo());
          var Ve = z.get(h);
          if (Ve)
            return Ve;
          z.set(h, V), j8(h) ? h.forEach(function(lt) {
            V.add(no(lt, g, w, lt, h, z));
          }) : $8(h) && h.forEach(function(lt, Nt) {
            V.set(Nt, no(lt, g, w, Nt, h, z));
          });
          var ot = pe ? ee ? Yx : Kx : ee ? qi : Tr, Ot = me ? n : ot(h);
          return Zs(Ot || h, function(lt, Nt) {
            Ot && (Nt = lt, lt = h[Nt]), P0(V, Nt, no(lt, g, w, Nt, h, z));
          }), V;
        }
        function sU(h) {
          var g = Tr(h);
          return function(w) {
            return CS(w, h, g);
          };
        }
        function CS(h, g, w) {
          var D = w.length;
          if (h == null)
            return !D;
          for (h = En(h); D--; ) {
            var F = w[D], z = g[F], V = h[F];
            if (V === n && !(F in h) || !z(V))
              return !1;
          }
          return !0;
        }
        function SS(h, g, w) {
          if (typeof h != "function")
            throw new eo(o);
          return j0(function() {
            h.apply(n, w);
          }, g);
        }
        function I0(h, g, w, D) {
          var F = -1, z = Pm, V = !0, Y = h.length, ee = [], pe = g.length;
          if (!Y)
            return ee;
          w && (g = Un(g, xs(w))), D ? (z = gx, V = !1) : g.length >= i && (z = D0, V = !1, g = new Cc(g));
          e:
            for (; ++F < Y; ) {
              var me = h[F], xe = w == null ? me : w(me);
              if (me = D || me !== 0 ? me : 0, V && xe === xe) {
                for (var Be = pe; Be--; )
                  if (g[Be] === xe)
                    continue e;
                ee.push(me);
              } else z(g, xe, D) || ee.push(me);
            }
          return ee;
        }
        var xu = JS(cl), AS = JS(Tx, !0);
        function oU(h, g) {
          var w = !0;
          return xu(h, function(D, F, z) {
            return w = !!g(D, F, z), w;
          }), w;
        }
        function Jm(h, g, w) {
          for (var D = -1, F = h.length; ++D < F; ) {
            var z = h[D], V = g(z);
            if (V != null && (Y === n ? V === V && !_s(V) : w(V, Y)))
              var Y = V, ee = z;
          }
          return ee;
        }
        function lU(h, g, w, D) {
          var F = h.length;
          for (w = At(w), w < 0 && (w = -w > F ? 0 : F + w), D = D === n || D > F ? F : At(D), D < 0 && (D += F), D = w > D ? 0 : U8(D); w < D; )
            h[w++] = g;
          return h;
        }
        function ES(h, g) {
          var w = [];
          return xu(h, function(D, F, z) {
            g(D, F, z) && w.push(D);
          }), w;
        }
        function Hr(h, g, w, D, F) {
          var z = -1, V = h.length;
          for (w || (w = YU), F || (F = []); ++z < V; ) {
            var Y = h[z];
            g > 0 && w(Y) ? g > 1 ? Hr(Y, g - 1, w, D, F) : yu(F, Y) : D || (F[F.length] = Y);
          }
          return F;
        }
        var Fx = ZS(), DS = ZS(!0);
        function cl(h, g) {
          return h && Fx(h, g, Tr);
        }
        function Tx(h, g) {
          return h && DS(h, g, Tr);
        }
        function Zm(h, g) {
          return mu(g, function(w) {
            return ka(h[w]);
          });
        }
        function Ac(h, g) {
          g = _u(g, h);
          for (var w = 0, D = g.length; h != null && w < D; )
            h = h[hl(g[w++])];
          return w && w == D ? h : n;
        }
        function OS(h, g, w) {
          var D = g(h);
          return xt(h) ? D : yu(D, w(h));
        }
        function wi(h) {
          return h == null ? h === n ? Te : Pt : _c && _c in En(h) ? UU(h) : nH(h);
        }
        function Rx(h, g) {
          return h > g;
        }
        function aU(h, g) {
          return h != null && xn.call(h, g);
        }
        function uU(h, g) {
          return h != null && g in En(h);
        }
        function cU(h, g, w) {
          return h >= Xr(g, w) && h < kr(g, w);
        }
        function Mx(h, g, w) {
          for (var D = w ? gx : Pm, F = h[0].length, z = h.length, V = z, Y = le(z), ee = 1 / 0, pe = []; V--; ) {
            var me = h[V];
            V && g && (me = Un(me, xs(g))), ee = Xr(me.length, ee), Y[V] = !w && (g || F >= 120 && me.length >= 120) ? new Cc(V && me) : n;
          }
          me = h[0];
          var xe = -1, Be = Y[0];
          e:
            for (; ++xe < F && pe.length < ee; ) {
              var Ve = me[xe], ot = g ? g(Ve) : Ve;
              if (Ve = w || Ve !== 0 ? Ve : 0, !(Be ? D0(Be, ot) : D(pe, ot, w))) {
                for (V = z; --V; ) {
                  var Ot = Y[V];
                  if (!(Ot ? D0(Ot, ot) : D(h[V], ot, w)))
                    continue e;
                }
                Be && Be.push(ot), pe.push(Ve);
              }
            }
          return pe;
        }
        function fU(h, g, w, D) {
          return cl(h, function(F, z, V) {
            g(D, w(F), z, V);
          }), D;
        }
        function N0(h, g, w) {
          g = _u(g, h), h = m8(h, g);
          var D = h == null ? h : h[hl(io(g))];
          return D == null ? n : vs(D, h, w);
        }
        function FS(h) {
          return nr(h) && wi(h) == we;
        }
        function hU(h) {
          return nr(h) && wi(h) == kt;
        }
        function dU(h) {
          return nr(h) && wi(h) == fe;
        }
        function B0(h, g, w, D, F) {
          return h === g ? !0 : h == null || g == null || !nr(h) && !nr(g) ? h !== h && g !== g : pU(h, g, w, D, B0, F);
        }
        function pU(h, g, w, D, F, z) {
          var V = xt(h), Y = xt(g), ee = V ? Me : Qr(h), pe = Y ? Me : Qr(g);
          ee = ee == we ? mt : ee, pe = pe == we ? mt : pe;
          var me = ee == mt, xe = pe == mt, Be = ee == pe;
          if (Be && Cu(h)) {
            if (!Cu(g))
              return !1;
            V = !0, me = !1;
          }
          if (Be && !me)
            return z || (z = new Fo()), V || dh(h) ? u8(h, g, w, D, F, z) : jU(h, g, ee, w, D, F, z);
          if (!(w & m)) {
            var Ve = me && xn.call(h, "__wrapped__"), ot = xe && xn.call(g, "__wrapped__");
            if (Ve || ot) {
              var Ot = Ve ? h.value() : h, lt = ot ? g.value() : g;
              return z || (z = new Fo()), F(Ot, lt, w, D, z);
            }
          }
          return Be ? (z || (z = new Fo()), qU(h, g, w, D, F, z)) : !1;
        }
        function gU(h) {
          return nr(h) && Qr(h) == Ge;
        }
        function Px(h, g, w, D) {
          var F = w.length, z = F, V = !D;
          if (h == null)
            return !z;
          for (h = En(h); F--; ) {
            var Y = w[F];
            if (V && Y[2] ? Y[1] !== h[Y[0]] : !(Y[0] in h))
              return !1;
          }
          for (; ++F < z; ) {
            Y = w[F];
            var ee = Y[0], pe = h[ee], me = Y[1];
            if (V && Y[2]) {
              if (pe === n && !(ee in h))
                return !1;
            } else {
              var xe = new Fo();
              if (D)
                var Be = D(pe, me, ee, h, g, xe);
              if (!(Be === n ? B0(me, pe, m | y, D, xe) : Be))
                return !1;
            }
          }
          return !0;
        }
        function TS(h) {
          if (!Kn(h) || QU(h))
            return !1;
          var g = ka(h) ? gq : mn;
          return g.test(Dc(h));
        }
        function mU(h) {
          return nr(h) && wi(h) == Ke;
        }
        function yU(h) {
          return nr(h) && Qr(h) == Ze;
        }
        function bU(h) {
          return nr(h) && m1(h.length) && !!Nn[wi(h)];
        }
        function RS(h) {
          return typeof h == "function" ? h : h == null ? Ui : typeof h == "object" ? xt(h) ? IS(h[0], h[1]) : PS(h) : eA(h);
        }
        function Ix(h) {
          if (!z0(h))
            return wq(h);
          var g = [];
          for (var w in En(h))
            xn.call(h, w) && w != "constructor" && g.push(w);
          return g;
        }
        function vU(h) {
          if (!Kn(h))
            return tH(h);
          var g = z0(h), w = [];
          for (var D in h)
            D == "constructor" && (g || !xn.call(h, D)) || w.push(D);
          return w;
        }
        function Nx(h, g) {
          return h < g;
        }
        function MS(h, g) {
          var w = -1, D = ji(h) ? le(h.length) : [];
          return xu(h, function(F, z, V) {
            D[++w] = g(F, z, V);
          }), D;
        }
        function PS(h) {
          var g = Qx(h);
          return g.length == 1 && g[0][2] ? p8(g[0][0], g[0][1]) : function(w) {
            return w === h || Px(w, h, g);
          };
        }
        function IS(h, g) {
          return Zx(h) && d8(g) ? p8(hl(h), g) : function(w) {
            var D = uw(w, h);
            return D === n && D === g ? cw(w, h) : B0(g, D, m | y);
          };
        }
        function e1(h, g, w, D, F) {
          h !== g && Fx(g, function(z, V) {
            if (F || (F = new Fo()), Kn(z))
              xU(h, g, V, w, e1, D, F);
            else {
              var Y = D ? D(tw(h, V), z, V + "", h, g, F) : n;
              Y === n && (Y = z), Dx(h, V, Y);
            }
          }, qi);
        }
        function xU(h, g, w, D, F, z, V) {
          var Y = tw(h, w), ee = tw(g, w), pe = V.get(ee);
          if (pe) {
            Dx(h, w, pe);
            return;
          }
          var me = z ? z(Y, ee, w + "", h, g, V) : n, xe = me === n;
          if (xe) {
            var Be = xt(ee), Ve = !Be && Cu(ee), ot = !Be && !Ve && dh(ee);
            me = ee, Be || Ve || ot ? xt(Y) ? me = Y : ur(Y) ? me = zi(Y) : Ve ? (xe = !1, me = GS(ee, !0)) : ot ? (xe = !1, me = KS(ee, !0)) : me = [] : q0(ee) || Oc(ee) ? (me = Y, Oc(Y) ? me = H8(Y) : (!Kn(Y) || ka(Y)) && (me = h8(ee))) : xe = !1;
          }
          xe && (V.set(ee, me), F(me, ee, D, z, V), V.delete(ee)), Dx(h, w, me);
        }
        function NS(h, g) {
          var w = h.length;
          if (w)
            return g += g < 0 ? w : 0, _a(g, w) ? h[g] : n;
        }
        function BS(h, g, w) {
          g.length ? g = Un(g, function(z) {
            return xt(z) ? function(V) {
              return Ac(V, z.length === 1 ? z[0] : z);
            } : z;
          }) : g = [Ui];
          var D = -1;
          g = Un(g, xs(rt()));
          var F = MS(h, function(z, V, Y) {
            var ee = Un(g, function(pe) {
              return pe(z);
            });
            return { criteria: ee, index: ++D, value: z };
          });
          return Gj(F, function(z, V) {
            return MU(z, V, w);
          });
        }
        function wU(h, g) {
          return LS(h, g, function(w, D) {
            return cw(h, D);
          });
        }
        function LS(h, g, w) {
          for (var D = -1, F = g.length, z = {}; ++D < F; ) {
            var V = g[D], Y = Ac(h, V);
            w(Y, V) && L0(z, _u(V, h), Y);
          }
          return z;
        }
        function _U(h) {
          return function(g) {
            return Ac(g, h);
          };
        }
        function Bx(h, g, w, D) {
          var F = D ? Wj : nh, z = -1, V = g.length, Y = h;
          for (h === g && (g = zi(g)), w && (Y = Un(h, xs(w))); ++z < V; )
            for (var ee = 0, pe = g[z], me = w ? w(pe) : pe; (ee = F(Y, me, ee, D)) > -1; )
              Y !== h && Hm.call(Y, ee, 1), Hm.call(h, ee, 1);
          return h;
        }
        function $S(h, g) {
          for (var w = h ? g.length : 0, D = w - 1; w--; ) {
            var F = g[w];
            if (w == D || F !== z) {
              var z = F;
              _a(F) ? Hm.call(h, F, 1) : jx(h, F);
            }
          }
          return h;
        }
        function Lx(h, g) {
          return h + Gm(vS() * (g - h + 1));
        }
        function kU(h, g, w, D) {
          for (var F = -1, z = kr(Wm((g - h) / (w || 1)), 0), V = le(z); z--; )
            V[D ? z : ++F] = h, h += w;
          return V;
        }
        function $x(h, g) {
          var w = "";
          if (!h || g < 1 || g > H)
            return w;
          do
            g % 2 && (w += h), g = Gm(g / 2), g && (h += h);
          while (g);
          return w;
        }
        function Tt(h, g) {
          return nw(g8(h, g, Ui), h + "");
        }
        function CU(h) {
          return _S(ph(h));
        }
        function SU(h, g) {
          var w = ph(h);
          return c1(w, Sc(g, 0, w.length));
        }
        function L0(h, g, w, D) {
          if (!Kn(h))
            return h;
          g = _u(g, h);
          for (var F = -1, z = g.length, V = z - 1, Y = h; Y != null && ++F < z; ) {
            var ee = hl(g[F]), pe = w;
            if (ee === "__proto__" || ee === "constructor" || ee === "prototype")
              return h;
            if (F != V) {
              var me = Y[ee];
              pe = D ? D(me, ee, Y) : n, pe === n && (pe = Kn(me) ? me : _a(g[F + 1]) ? [] : {});
            }
            P0(Y, ee, pe), Y = Y[ee];
          }
          return h;
        }
        var zS = Km ? function(h, g) {
          return Km.set(h, g), h;
        } : Ui, AU = Vm ? function(h, g) {
          return Vm(h, "toString", {
            configurable: !0,
            enumerable: !1,
            value: hw(g),
            writable: !0
          });
        } : Ui;
        function EU(h) {
          return c1(ph(h));
        }
        function ro(h, g, w) {
          var D = -1, F = h.length;
          g < 0 && (g = -g > F ? 0 : F + g), w = w > F ? F : w, w < 0 && (w += F), F = g > w ? 0 : w - g >>> 0, g >>>= 0;
          for (var z = le(F); ++D < F; )
            z[D] = h[D + g];
          return z;
        }
        function DU(h, g) {
          var w;
          return xu(h, function(D, F, z) {
            return w = g(D, F, z), !w;
          }), !!w;
        }
        function t1(h, g, w) {
          var D = 0, F = h == null ? D : h.length;
          if (typeof g == "number" && g === g && F <= ne) {
            for (; D < F; ) {
              var z = D + F >>> 1, V = h[z];
              V !== null && !_s(V) && (w ? V <= g : V < g) ? D = z + 1 : F = z;
            }
            return F;
          }
          return zx(h, g, Ui, w);
        }
        function zx(h, g, w, D) {
          var F = 0, z = h == null ? 0 : h.length;
          if (z === 0)
            return 0;
          g = w(g);
          for (var V = g !== g, Y = g === null, ee = _s(g), pe = g === n; F < z; ) {
            var me = Gm((F + z) / 2), xe = w(h[me]), Be = xe !== n, Ve = xe === null, ot = xe === xe, Ot = _s(xe);
            if (V)
              var lt = D || ot;
            else pe ? lt = ot && (D || Be) : Y ? lt = ot && Be && (D || !Ve) : ee ? lt = ot && Be && !Ve && (D || !Ot) : Ve || Ot ? lt = !1 : lt = D ? xe <= g : xe < g;
            lt ? F = me + 1 : z = me;
          }
          return Xr(z, oe);
        }
        function jS(h, g) {
          for (var w = -1, D = h.length, F = 0, z = []; ++w < D; ) {
            var V = h[w], Y = g ? g(V) : V;
            if (!w || !To(Y, ee)) {
              var ee = Y;
              z[F++] = V === 0 ? 0 : V;
            }
          }
          return z;
        }
        function qS(h) {
          return typeof h == "number" ? h : _s(h) ? re : +h;
        }
        function ws(h) {
          if (typeof h == "string")
            return h;
          if (xt(h))
            return Un(h, ws) + "";
          if (_s(h))
            return xS ? xS.call(h) : "";
          var g = h + "";
          return g == "0" && 1 / h == -U ? "-0" : g;
        }
        function wu(h, g, w) {
          var D = -1, F = Pm, z = h.length, V = !0, Y = [], ee = Y;
          if (w)
            V = !1, F = gx;
          else if (z >= i) {
            var pe = g ? null : $U(h);
            if (pe)
              return Nm(pe);
            V = !1, F = D0, ee = new Cc();
          } else
            ee = g ? [] : Y;
          e:
            for (; ++D < z; ) {
              var me = h[D], xe = g ? g(me) : me;
              if (me = w || me !== 0 ? me : 0, V && xe === xe) {
                for (var Be = ee.length; Be--; )
                  if (ee[Be] === xe)
                    continue e;
                g && ee.push(xe), Y.push(me);
              } else F(ee, xe, w) || (ee !== Y && ee.push(xe), Y.push(me));
            }
          return Y;
        }
        function jx(h, g) {
          return g = _u(g, h), h = m8(h, g), h == null || delete h[hl(io(g))];
        }
        function US(h, g, w, D) {
          return L0(h, g, w(Ac(h, g)), D);
        }
        function n1(h, g, w, D) {
          for (var F = h.length, z = D ? F : -1; (D ? z-- : ++z < F) && g(h[z], z, h); )
            ;
          return w ? ro(h, D ? 0 : z, D ? z + 1 : F) : ro(h, D ? z + 1 : 0, D ? F : z);
        }
        function HS(h, g) {
          var w = h;
          return w instanceof Lt && (w = w.value()), mx(g, function(D, F) {
            return F.func.apply(F.thisArg, yu([D], F.args));
          }, w);
        }
        function qx(h, g, w) {
          var D = h.length;
          if (D < 2)
            return D ? wu(h[0]) : [];
          for (var F = -1, z = le(D); ++F < D; )
            for (var V = h[F], Y = -1; ++Y < D; )
              Y != F && (z[F] = I0(z[F] || V, h[Y], g, w));
          return wu(Hr(z, 1), g, w);
        }
        function VS(h, g, w) {
          for (var D = -1, F = h.length, z = g.length, V = {}; ++D < F; ) {
            var Y = D < z ? g[D] : n;
            w(V, h[D], Y);
          }
          return V;
        }
        function Ux(h) {
          return ur(h) ? h : [];
        }
        function Hx(h) {
          return typeof h == "function" ? h : Ui;
        }
        function _u(h, g) {
          return xt(h) ? h : Zx(h, g) ? [h] : x8(yn(h));
        }
        var OU = Tt;
        function ku(h, g, w) {
          var D = h.length;
          return w = w === n ? D : w, !g && w >= D ? h : ro(h, g, w);
        }
        var WS = mq || function(h) {
          return Ur.clearTimeout(h);
        };
        function GS(h, g) {
          if (g)
            return h.slice();
          var w = h.length, D = pS ? pS(w) : new h.constructor(w);
          return h.copy(D), D;
        }
        function Vx(h) {
          var g = new h.constructor(h.byteLength);
          return new qm(g).set(new qm(h)), g;
        }
        function FU(h, g) {
          var w = g ? Vx(h.buffer) : h.buffer;
          return new h.constructor(w, h.byteOffset, h.byteLength);
        }
        function TU(h) {
          var g = new h.constructor(h.source, tt.exec(h));
          return g.lastIndex = h.lastIndex, g;
        }
        function RU(h) {
          return M0 ? En(M0.call(h)) : {};
        }
        function KS(h, g) {
          var w = g ? Vx(h.buffer) : h.buffer;
          return new h.constructor(w, h.byteOffset, h.length);
        }
        function YS(h, g) {
          if (h !== g) {
            var w = h !== n, D = h === null, F = h === h, z = _s(h), V = g !== n, Y = g === null, ee = g === g, pe = _s(g);
            if (!Y && !pe && !z && h > g || z && V && ee && !Y && !pe || D && V && ee || !w && ee || !F)
              return 1;
            if (!D && !z && !pe && h < g || pe && w && F && !D && !z || Y && w && F || !V && F || !ee)
              return -1;
          }
          return 0;
        }
        function MU(h, g, w) {
          for (var D = -1, F = h.criteria, z = g.criteria, V = F.length, Y = w.length; ++D < V; ) {
            var ee = YS(F[D], z[D]);
            if (ee) {
              if (D >= Y)
                return ee;
              var pe = w[D];
              return ee * (pe == "desc" ? -1 : 1);
            }
          }
          return h.index - g.index;
        }
        function XS(h, g, w, D) {
          for (var F = -1, z = h.length, V = w.length, Y = -1, ee = g.length, pe = kr(z - V, 0), me = le(ee + pe), xe = !D; ++Y < ee; )
            me[Y] = g[Y];
          for (; ++F < V; )
            (xe || F < z) && (me[w[F]] = h[F]);
          for (; pe--; )
            me[Y++] = h[F++];
          return me;
        }
        function QS(h, g, w, D) {
          for (var F = -1, z = h.length, V = -1, Y = w.length, ee = -1, pe = g.length, me = kr(z - Y, 0), xe = le(me + pe), Be = !D; ++F < me; )
            xe[F] = h[F];
          for (var Ve = F; ++ee < pe; )
            xe[Ve + ee] = g[ee];
          for (; ++V < Y; )
            (Be || F < z) && (xe[Ve + w[V]] = h[F++]);
          return xe;
        }
        function zi(h, g) {
          var w = -1, D = h.length;
          for (g || (g = le(D)); ++w < D; )
            g[w] = h[w];
          return g;
        }
        function fl(h, g, w, D) {
          var F = !w;
          w || (w = {});
          for (var z = -1, V = g.length; ++z < V; ) {
            var Y = g[z], ee = D ? D(w[Y], h[Y], Y, w, h) : n;
            ee === n && (ee = h[Y]), F ? va(w, Y, ee) : P0(w, Y, ee);
          }
          return w;
        }
        function PU(h, g) {
          return fl(h, Jx(h), g);
        }
        function IU(h, g) {
          return fl(h, c8(h), g);
        }
        function r1(h, g) {
          return function(w, D) {
            var F = xt(w) ? zj : rU, z = g ? g() : {};
            return F(w, h, rt(D, 2), z);
          };
        }
        function ch(h) {
          return Tt(function(g, w) {
            var D = -1, F = w.length, z = F > 1 ? w[F - 1] : n, V = F > 2 ? w[2] : n;
            for (z = h.length > 3 && typeof z == "function" ? (F--, z) : n, V && _i(w[0], w[1], V) && (z = F < 3 ? n : z, F = 1), g = En(g); ++D < F; ) {
              var Y = w[D];
              Y && h(g, Y, D, z);
            }
            return g;
          });
        }
        function JS(h, g) {
          return function(w, D) {
            if (w == null)
              return w;
            if (!ji(w))
              return h(w, D);
            for (var F = w.length, z = g ? F : -1, V = En(w); (g ? z-- : ++z < F) && D(V[z], z, V) !== !1; )
              ;
            return w;
          };
        }
        function ZS(h) {
          return function(g, w, D) {
            for (var F = -1, z = En(g), V = D(g), Y = V.length; Y--; ) {
              var ee = V[h ? Y : ++F];
              if (w(z[ee], ee, z) === !1)
                break;
            }
            return g;
          };
        }
        function NU(h, g, w) {
          var D = g & b, F = $0(h);
          function z() {
            var V = this && this !== Ur && this instanceof z ? F : h;
            return V.apply(D ? w : this, arguments);
          }
          return z;
        }
        function e8(h) {
          return function(g) {
            g = yn(g);
            var w = rh(g) ? Oo(g) : n, D = w ? w[0] : g.charAt(0), F = w ? ku(w, 1).join("") : g.slice(1);
            return D[h]() + F;
          };
        }
        function fh(h) {
          return function(g) {
            return mx(J8(Q8(g).replace(Aj, "")), h, "");
          };
        }
        function $0(h) {
          return function() {
            var g = arguments;
            switch (g.length) {
              case 0:
                return new h();
              case 1:
                return new h(g[0]);
              case 2:
                return new h(g[0], g[1]);
              case 3:
                return new h(g[0], g[1], g[2]);
              case 4:
                return new h(g[0], g[1], g[2], g[3]);
              case 5:
                return new h(g[0], g[1], g[2], g[3], g[4]);
              case 6:
                return new h(g[0], g[1], g[2], g[3], g[4], g[5]);
              case 7:
                return new h(g[0], g[1], g[2], g[3], g[4], g[5], g[6]);
            }
            var w = uh(h.prototype), D = h.apply(w, g);
            return Kn(D) ? D : w;
          };
        }
        function BU(h, g, w) {
          var D = $0(h);
          function F() {
            for (var z = arguments.length, V = le(z), Y = z, ee = hh(F); Y--; )
              V[Y] = arguments[Y];
            var pe = z < 3 && V[0] !== ee && V[z - 1] !== ee ? [] : bu(V, ee);
            if (z -= pe.length, z < w)
              return s8(
                h,
                g,
                i1,
                F.placeholder,
                n,
                V,
                pe,
                n,
                n,
                w - z
              );
            var me = this && this !== Ur && this instanceof F ? D : h;
            return vs(me, this, V);
          }
          return F;
        }
        function t8(h) {
          return function(g, w, D) {
            var F = En(g);
            if (!ji(g)) {
              var z = rt(w, 3);
              g = Tr(g), w = function(Y) {
                return z(F[Y], Y, F);
              };
            }
            var V = h(g, w, D);
            return V > -1 ? F[z ? g[V] : V] : n;
          };
        }
        function n8(h) {
          return wa(function(g) {
            var w = g.length, D = w, F = to.prototype.thru;
            for (h && g.reverse(); D--; ) {
              var z = g[D];
              if (typeof z != "function")
                throw new eo(o);
              if (F && !V && a1(z) == "wrapper")
                var V = new to([], !0);
            }
            for (D = V ? D : w; ++D < w; ) {
              z = g[D];
              var Y = a1(z), ee = Y == "wrapper" ? Xx(z) : n;
              ee && ew(ee[0]) && ee[1] == (A | k | C | O) && !ee[4].length && ee[9] == 1 ? V = V[a1(ee[0])].apply(V, ee[3]) : V = z.length == 1 && ew(z) ? V[Y]() : V.thru(z);
            }
            return function() {
              var pe = arguments, me = pe[0];
              if (V && pe.length == 1 && xt(me))
                return V.plant(me).value();
              for (var xe = 0, Be = w ? g[xe].apply(this, pe) : me; ++xe < w; )
                Be = g[xe].call(this, Be);
              return Be;
            };
          });
        }
        function i1(h, g, w, D, F, z, V, Y, ee, pe) {
          var me = g & A, xe = g & b, Be = g & v, Ve = g & (k | S), ot = g & T, Ot = Be ? n : $0(h);
          function lt() {
            for (var Nt = arguments.length, qt = le(Nt), ks = Nt; ks--; )
              qt[ks] = arguments[ks];
            if (Ve)
              var ki = hh(lt), Cs = Yj(qt, ki);
            if (D && (qt = XS(qt, D, F, Ve)), z && (qt = QS(qt, z, V, Ve)), Nt -= Cs, Ve && Nt < pe) {
              var cr = bu(qt, ki);
              return s8(
                h,
                g,
                i1,
                lt.placeholder,
                w,
                qt,
                cr,
                Y,
                ee,
                pe - Nt
              );
            }
            var Ro = xe ? w : this, Sa = Be ? Ro[h] : h;
            return Nt = qt.length, Y ? qt = rH(qt, Y) : ot && Nt > 1 && qt.reverse(), me && ee < Nt && (qt.length = ee), this && this !== Ur && this instanceof lt && (Sa = Ot || $0(Sa)), Sa.apply(Ro, qt);
          }
          return lt;
        }
        function r8(h, g) {
          return function(w, D) {
            return fU(w, h, g(D), {});
          };
        }
        function s1(h, g) {
          return function(w, D) {
            var F;
            if (w === n && D === n)
              return g;
            if (w !== n && (F = w), D !== n) {
              if (F === n)
                return D;
              typeof w == "string" || typeof D == "string" ? (w = ws(w), D = ws(D)) : (w = qS(w), D = qS(D)), F = h(w, D);
            }
            return F;
          };
        }
        function Wx(h) {
          return wa(function(g) {
            return g = Un(g, xs(rt())), Tt(function(w) {
              var D = this;
              return h(g, function(F) {
                return vs(F, D, w);
              });
            });
          });
        }
        function o1(h, g) {
          g = g === n ? " " : ws(g);
          var w = g.length;
          if (w < 2)
            return w ? $x(g, h) : g;
          var D = $x(g, Wm(h / ih(g)));
          return rh(g) ? ku(Oo(D), 0, h).join("") : D.slice(0, h);
        }
        function LU(h, g, w, D) {
          var F = g & b, z = $0(h);
          function V() {
            for (var Y = -1, ee = arguments.length, pe = -1, me = D.length, xe = le(me + ee), Be = this && this !== Ur && this instanceof V ? z : h; ++pe < me; )
              xe[pe] = D[pe];
            for (; ee--; )
              xe[pe++] = arguments[++Y];
            return vs(Be, F ? w : this, xe);
          }
          return V;
        }
        function i8(h) {
          return function(g, w, D) {
            return D && typeof D != "number" && _i(g, w, D) && (w = D = n), g = Ca(g), w === n ? (w = g, g = 0) : w = Ca(w), D = D === n ? g < w ? 1 : -1 : Ca(D), kU(g, w, D, h);
          };
        }
        function l1(h) {
          return function(g, w) {
            return typeof g == "string" && typeof w == "string" || (g = so(g), w = so(w)), h(g, w);
          };
        }
        function s8(h, g, w, D, F, z, V, Y, ee, pe) {
          var me = g & k, xe = me ? V : n, Be = me ? n : V, Ve = me ? z : n, ot = me ? n : z;
          g |= me ? C : E, g &= ~(me ? E : C), g & _ || (g &= -4);
          var Ot = [
            h,
            g,
            F,
            Ve,
            xe,
            ot,
            Be,
            Y,
            ee,
            pe
          ], lt = w.apply(n, Ot);
          return ew(h) && y8(lt, Ot), lt.placeholder = D, b8(lt, h, g);
        }
        function Gx(h) {
          var g = _r[h];
          return function(w, D) {
            if (w = so(w), D = D == null ? 0 : Xr(At(D), 292), D && bS(w)) {
              var F = (yn(w) + "e").split("e"), z = g(F[0] + "e" + (+F[1] + D));
              return F = (yn(z) + "e").split("e"), +(F[0] + "e" + (+F[1] - D));
            }
            return g(w);
          };
        }
        var $U = lh && 1 / Nm(new lh([, -0]))[1] == U ? function(h) {
          return new lh(h);
        } : gw;
        function o8(h) {
          return function(g) {
            var w = Qr(g);
            return w == Ge ? kx(g) : w == Ze ? nq(g) : Kj(g, h(g));
          };
        }
        function xa(h, g, w, D, F, z, V, Y) {
          var ee = g & v;
          if (!ee && typeof h != "function")
            throw new eo(o);
          var pe = D ? D.length : 0;
          if (pe || (g &= -97, D = F = n), V = V === n ? V : kr(At(V), 0), Y = Y === n ? Y : At(Y), pe -= F ? F.length : 0, g & E) {
            var me = D, xe = F;
            D = F = n;
          }
          var Be = ee ? n : Xx(h), Ve = [
            h,
            g,
            w,
            D,
            F,
            me,
            xe,
            z,
            V,
            Y
          ];
          if (Be && eH(Ve, Be), h = Ve[0], g = Ve[1], w = Ve[2], D = Ve[3], F = Ve[4], Y = Ve[9] = Ve[9] === n ? ee ? 0 : h.length : kr(Ve[9] - pe, 0), !Y && g & (k | S) && (g &= -25), !g || g == b)
            var ot = NU(h, g, w);
          else g == k || g == S ? ot = BU(h, g, Y) : (g == C || g == (b | C)) && !F.length ? ot = LU(h, g, w, D) : ot = i1.apply(n, Ve);
          var Ot = Be ? zS : y8;
          return b8(Ot(ot, Ve), h, g);
        }
        function l8(h, g, w, D) {
          return h === n || To(h, oh[w]) && !xn.call(D, w) ? g : h;
        }
        function a8(h, g, w, D, F, z) {
          return Kn(h) && Kn(g) && (z.set(g, h), e1(h, g, n, a8, z), z.delete(g)), h;
        }
        function zU(h) {
          return q0(h) ? n : h;
        }
        function u8(h, g, w, D, F, z) {
          var V = w & m, Y = h.length, ee = g.length;
          if (Y != ee && !(V && ee > Y))
            return !1;
          var pe = z.get(h), me = z.get(g);
          if (pe && me)
            return pe == g && me == h;
          var xe = -1, Be = !0, Ve = w & y ? new Cc() : n;
          for (z.set(h, g), z.set(g, h); ++xe < Y; ) {
            var ot = h[xe], Ot = g[xe];
            if (D)
              var lt = V ? D(Ot, ot, xe, g, h, z) : D(ot, Ot, xe, h, g, z);
            if (lt !== n) {
              if (lt)
                continue;
              Be = !1;
              break;
            }
            if (Ve) {
              if (!yx(g, function(Nt, qt) {
                if (!D0(Ve, qt) && (ot === Nt || F(ot, Nt, w, D, z)))
                  return Ve.push(qt);
              })) {
                Be = !1;
                break;
              }
            } else if (!(ot === Ot || F(ot, Ot, w, D, z))) {
              Be = !1;
              break;
            }
          }
          return z.delete(h), z.delete(g), Be;
        }
        function jU(h, g, w, D, F, z, V) {
          switch (w) {
            case tn:
              if (h.byteLength != g.byteLength || h.byteOffset != g.byteOffset)
                return !1;
              h = h.buffer, g = g.buffer;
            case kt:
              return !(h.byteLength != g.byteLength || !z(new qm(h), new qm(g)));
            case Ce:
            case fe:
            case gt:
              return To(+h, +g);
            case Se:
              return h.name == g.name && h.message == g.message;
            case Ke:
            case It:
              return h == g + "";
            case Ge:
              var Y = kx;
            case Ze:
              var ee = D & m;
              if (Y || (Y = Nm), h.size != g.size && !ee)
                return !1;
              var pe = V.get(h);
              if (pe)
                return pe == g;
              D |= y, V.set(h, g);
              var me = u8(Y(h), Y(g), D, F, z, V);
              return V.delete(h), me;
            case vn:
              if (M0)
                return M0.call(h) == M0.call(g);
          }
          return !1;
        }
        function qU(h, g, w, D, F, z) {
          var V = w & m, Y = Kx(h), ee = Y.length, pe = Kx(g), me = pe.length;
          if (ee != me && !V)
            return !1;
          for (var xe = ee; xe--; ) {
            var Be = Y[xe];
            if (!(V ? Be in g : xn.call(g, Be)))
              return !1;
          }
          var Ve = z.get(h), ot = z.get(g);
          if (Ve && ot)
            return Ve == g && ot == h;
          var Ot = !0;
          z.set(h, g), z.set(g, h);
          for (var lt = V; ++xe < ee; ) {
            Be = Y[xe];
            var Nt = h[Be], qt = g[Be];
            if (D)
              var ks = V ? D(qt, Nt, Be, g, h, z) : D(Nt, qt, Be, h, g, z);
            if (!(ks === n ? Nt === qt || F(Nt, qt, w, D, z) : ks)) {
              Ot = !1;
              break;
            }
            lt || (lt = Be == "constructor");
          }
          if (Ot && !lt) {
            var ki = h.constructor, Cs = g.constructor;
            ki != Cs && "constructor" in h && "constructor" in g && !(typeof ki == "function" && ki instanceof ki && typeof Cs == "function" && Cs instanceof Cs) && (Ot = !1);
          }
          return z.delete(h), z.delete(g), Ot;
        }
        function wa(h) {
          return nw(g8(h, n, C8), h + "");
        }
        function Kx(h) {
          return OS(h, Tr, Jx);
        }
        function Yx(h) {
          return OS(h, qi, c8);
        }
        var Xx = Km ? function(h) {
          return Km.get(h);
        } : gw;
        function a1(h) {
          for (var g = h.name + "", w = ah[g], D = xn.call(ah, g) ? w.length : 0; D--; ) {
            var F = w[D], z = F.func;
            if (z == null || z == h)
              return F.name;
          }
          return g;
        }
        function hh(h) {
          var g = xn.call(I, "placeholder") ? I : h;
          return g.placeholder;
        }
        function rt() {
          var h = I.iteratee || dw;
          return h = h === dw ? RS : h, arguments.length ? h(arguments[0], arguments[1]) : h;
        }
        function u1(h, g) {
          var w = h.__data__;
          return XU(g) ? w[typeof g == "string" ? "string" : "hash"] : w.map;
        }
        function Qx(h) {
          for (var g = Tr(h), w = g.length; w--; ) {
            var D = g[w], F = h[D];
            g[w] = [D, F, d8(F)];
          }
          return g;
        }
        function Ec(h, g) {
          var w = Zj(h, g);
          return TS(w) ? w : n;
        }
        function UU(h) {
          var g = xn.call(h, _c), w = h[_c];
          try {
            h[_c] = n;
            var D = !0;
          } catch {
          }
          var F = zm.call(h);
          return D && (g ? h[_c] = w : delete h[_c]), F;
        }
        var Jx = Sx ? function(h) {
          return h == null ? [] : (h = En(h), mu(Sx(h), function(g) {
            return mS.call(h, g);
          }));
        } : mw, c8 = Sx ? function(h) {
          for (var g = []; h; )
            yu(g, Jx(h)), h = Um(h);
          return g;
        } : mw, Qr = wi;
        (Ax && Qr(new Ax(new ArrayBuffer(1))) != tn || F0 && Qr(new F0()) != Ge || Ex && Qr(Ex.resolve()) != Wt || lh && Qr(new lh()) != Ze || T0 && Qr(new T0()) != Oe) && (Qr = function(h) {
          var g = wi(h), w = g == mt ? h.constructor : n, D = w ? Dc(w) : "";
          if (D)
            switch (D) {
              case Sq:
                return tn;
              case Aq:
                return Ge;
              case Eq:
                return Wt;
              case Dq:
                return Ze;
              case Oq:
                return Oe;
            }
          return g;
        });
        function HU(h, g, w) {
          for (var D = -1, F = w.length; ++D < F; ) {
            var z = w[D], V = z.size;
            switch (z.type) {
              case "drop":
                h += V;
                break;
              case "dropRight":
                g -= V;
                break;
              case "take":
                g = Xr(g, h + V);
                break;
              case "takeRight":
                h = kr(h, g - V);
                break;
            }
          }
          return { start: h, end: g };
        }
        function VU(h) {
          var g = h.match(ox);
          return g ? g[1].split(lx) : [];
        }
        function f8(h, g, w) {
          g = _u(g, h);
          for (var D = -1, F = g.length, z = !1; ++D < F; ) {
            var V = hl(g[D]);
            if (!(z = h != null && w(h, V)))
              break;
            h = h[V];
          }
          return z || ++D != F ? z : (F = h == null ? 0 : h.length, !!F && m1(F) && _a(V, F) && (xt(h) || Oc(h)));
        }
        function WU(h) {
          var g = h.length, w = new h.constructor(g);
          return g && typeof h[0] == "string" && xn.call(h, "index") && (w.index = h.index, w.input = h.input), w;
        }
        function h8(h) {
          return typeof h.constructor == "function" && !z0(h) ? uh(Um(h)) : {};
        }
        function GU(h, g, w) {
          var D = h.constructor;
          switch (g) {
            case kt:
              return Vx(h);
            case Ce:
            case fe:
              return new D(+h);
            case tn:
              return FU(h, w);
            case Tn:
            case Gt:
            case Je:
            case gn:
            case tr:
            case xi:
            case pa:
            case qn:
            case qr:
              return KS(h, w);
            case Ge:
              return new D();
            case gt:
            case It:
              return new D(h);
            case Ke:
              return TU(h);
            case Ze:
              return new D();
            case vn:
              return RU(h);
          }
        }
        function KU(h, g) {
          var w = g.length;
          if (!w)
            return h;
          var D = w - 1;
          return g[D] = (w > 1 ? "& " : "") + g[D], g = g.join(w > 2 ? ", " : " "), h.replace(sx, `{
/* [wrapped with ` + g + `] */
`);
        }
        function YU(h) {
          return xt(h) || Oc(h) || !!(yS && h && h[yS]);
        }
        function _a(h, g) {
          var w = typeof h;
          return g = g ?? H, !!g && (w == "number" || w != "symbol" && ar.test(h)) && h > -1 && h % 1 == 0 && h < g;
        }
        function _i(h, g, w) {
          if (!Kn(w))
            return !1;
          var D = typeof g;
          return (D == "number" ? ji(w) && _a(g, w.length) : D == "string" && g in w) ? To(w[g], h) : !1;
        }
        function Zx(h, g) {
          if (xt(h))
            return !1;
          var w = typeof h;
          return w == "number" || w == "symbol" || w == "boolean" || h == null || _s(h) ? !0 : rx.test(h) || !Fm.test(h) || g != null && h in En(g);
        }
        function XU(h) {
          var g = typeof h;
          return g == "string" || g == "number" || g == "symbol" || g == "boolean" ? h !== "__proto__" : h === null;
        }
        function ew(h) {
          var g = a1(h), w = I[g];
          if (typeof w != "function" || !(g in Lt.prototype))
            return !1;
          if (h === w)
            return !0;
          var D = Xx(w);
          return !!D && h === D[0];
        }
        function QU(h) {
          return !!dS && dS in h;
        }
        var JU = Lm ? ka : yw;
        function z0(h) {
          var g = h && h.constructor, w = typeof g == "function" && g.prototype || oh;
          return h === w;
        }
        function d8(h) {
          return h === h && !Kn(h);
        }
        function p8(h, g) {
          return function(w) {
            return w == null ? !1 : w[h] === g && (g !== n || h in En(w));
          };
        }
        function ZU(h) {
          var g = p1(h, function(D) {
            return w.size === u && w.clear(), D;
          }), w = g.cache;
          return g;
        }
        function eH(h, g) {
          var w = h[1], D = g[1], F = w | D, z = F < (b | v | A), V = D == A && w == k || D == A && w == O && h[7].length <= g[8] || D == (A | O) && g[7].length <= g[8] && w == k;
          if (!(z || V))
            return h;
          D & b && (h[2] = g[2], F |= w & b ? 0 : _);
          var Y = g[3];
          if (Y) {
            var ee = h[3];
            h[3] = ee ? XS(ee, Y, g[4]) : Y, h[4] = ee ? bu(h[3], c) : g[4];
          }
          return Y = g[5], Y && (ee = h[5], h[5] = ee ? QS(ee, Y, g[6]) : Y, h[6] = ee ? bu(h[5], c) : g[6]), Y = g[7], Y && (h[7] = Y), D & A && (h[8] = h[8] == null ? g[8] : Xr(h[8], g[8])), h[9] == null && (h[9] = g[9]), h[0] = g[0], h[1] = F, h;
        }
        function tH(h) {
          var g = [];
          if (h != null)
            for (var w in En(h))
              g.push(w);
          return g;
        }
        function nH(h) {
          return zm.call(h);
        }
        function g8(h, g, w) {
          return g = kr(g === n ? h.length - 1 : g, 0), function() {
            for (var D = arguments, F = -1, z = kr(D.length - g, 0), V = le(z); ++F < z; )
              V[F] = D[g + F];
            F = -1;
            for (var Y = le(g + 1); ++F < g; )
              Y[F] = D[F];
            return Y[g] = w(V), vs(h, this, Y);
          };
        }
        function m8(h, g) {
          return g.length < 2 ? h : Ac(h, ro(g, 0, -1));
        }
        function rH(h, g) {
          for (var w = h.length, D = Xr(g.length, w), F = zi(h); D--; ) {
            var z = g[D];
            h[D] = _a(z, w) ? F[z] : n;
          }
          return h;
        }
        function tw(h, g) {
          if (!(g === "constructor" && typeof h[g] == "function") && g != "__proto__")
            return h[g];
        }
        var y8 = v8(zS), j0 = bq || function(h, g) {
          return Ur.setTimeout(h, g);
        }, nw = v8(AU);
        function b8(h, g, w) {
          var D = g + "";
          return nw(h, KU(D, iH(VU(D), w)));
        }
        function v8(h) {
          var g = 0, w = 0;
          return function() {
            var D = _q(), F = M - (D - w);
            if (w = D, F > 0) {
              if (++g >= B)
                return arguments[0];
            } else
              g = 0;
            return h.apply(n, arguments);
          };
        }
        function c1(h, g) {
          var w = -1, D = h.length, F = D - 1;
          for (g = g === n ? D : g; ++w < g; ) {
            var z = Lx(w, F), V = h[z];
            h[z] = h[w], h[w] = V;
          }
          return h.length = g, h;
        }
        var x8 = ZU(function(h) {
          var g = [];
          return h.charCodeAt(0) === 46 && g.push(""), h.replace(Tm, function(w, D, F, z) {
            g.push(F ? z.replace(qe, "$1") : D || w);
          }), g;
        });
        function hl(h) {
          if (typeof h == "string" || _s(h))
            return h;
          var g = h + "";
          return g == "0" && 1 / h == -U ? "-0" : g;
        }
        function Dc(h) {
          if (h != null) {
            try {
              return $m.call(h);
            } catch {
            }
            try {
              return h + "";
            } catch {
            }
          }
          return "";
        }
        function iH(h, g) {
          return Zs(ce, function(w) {
            var D = "_." + w[0];
            g & w[1] && !Pm(h, D) && h.push(D);
          }), h.sort();
        }
        function w8(h) {
          if (h instanceof Lt)
            return h.clone();
          var g = new to(h.__wrapped__, h.__chain__);
          return g.__actions__ = zi(h.__actions__), g.__index__ = h.__index__, g.__values__ = h.__values__, g;
        }
        function sH(h, g, w) {
          (w ? _i(h, g, w) : g === n) ? g = 1 : g = kr(At(g), 0);
          var D = h == null ? 0 : h.length;
          if (!D || g < 1)
            return [];
          for (var F = 0, z = 0, V = le(Wm(D / g)); F < D; )
            V[z++] = ro(h, F, F += g);
          return V;
        }
        function oH(h) {
          for (var g = -1, w = h == null ? 0 : h.length, D = 0, F = []; ++g < w; ) {
            var z = h[g];
            z && (F[D++] = z);
          }
          return F;
        }
        function lH() {
          var h = arguments.length;
          if (!h)
            return [];
          for (var g = le(h - 1), w = arguments[0], D = h; D--; )
            g[D - 1] = arguments[D];
          return yu(xt(w) ? zi(w) : [w], Hr(g, 1));
        }
        var aH = Tt(function(h, g) {
          return ur(h) ? I0(h, Hr(g, 1, ur, !0)) : [];
        }), uH = Tt(function(h, g) {
          var w = io(g);
          return ur(w) && (w = n), ur(h) ? I0(h, Hr(g, 1, ur, !0), rt(w, 2)) : [];
        }), cH = Tt(function(h, g) {
          var w = io(g);
          return ur(w) && (w = n), ur(h) ? I0(h, Hr(g, 1, ur, !0), n, w) : [];
        });
        function fH(h, g, w) {
          var D = h == null ? 0 : h.length;
          return D ? (g = w || g === n ? 1 : At(g), ro(h, g < 0 ? 0 : g, D)) : [];
        }
        function hH(h, g, w) {
          var D = h == null ? 0 : h.length;
          return D ? (g = w || g === n ? 1 : At(g), g = D - g, ro(h, 0, g < 0 ? 0 : g)) : [];
        }
        function dH(h, g) {
          return h && h.length ? n1(h, rt(g, 3), !0, !0) : [];
        }
        function pH(h, g) {
          return h && h.length ? n1(h, rt(g, 3), !0) : [];
        }
        function gH(h, g, w, D) {
          var F = h == null ? 0 : h.length;
          return F ? (w && typeof w != "number" && _i(h, g, w) && (w = 0, D = F), lU(h, g, w, D)) : [];
        }
        function _8(h, g, w) {
          var D = h == null ? 0 : h.length;
          if (!D)
            return -1;
          var F = w == null ? 0 : At(w);
          return F < 0 && (F = kr(D + F, 0)), Im(h, rt(g, 3), F);
        }
        function k8(h, g, w) {
          var D = h == null ? 0 : h.length;
          if (!D)
            return -1;
          var F = D - 1;
          return w !== n && (F = At(w), F = w < 0 ? kr(D + F, 0) : Xr(F, D - 1)), Im(h, rt(g, 3), F, !0);
        }
        function C8(h) {
          var g = h == null ? 0 : h.length;
          return g ? Hr(h, 1) : [];
        }
        function mH(h) {
          var g = h == null ? 0 : h.length;
          return g ? Hr(h, U) : [];
        }
        function yH(h, g) {
          var w = h == null ? 0 : h.length;
          return w ? (g = g === n ? 1 : At(g), Hr(h, g)) : [];
        }
        function bH(h) {
          for (var g = -1, w = h == null ? 0 : h.length, D = {}; ++g < w; ) {
            var F = h[g];
            D[F[0]] = F[1];
          }
          return D;
        }
        function S8(h) {
          return h && h.length ? h[0] : n;
        }
        function vH(h, g, w) {
          var D = h == null ? 0 : h.length;
          if (!D)
            return -1;
          var F = w == null ? 0 : At(w);
          return F < 0 && (F = kr(D + F, 0)), nh(h, g, F);
        }
        function xH(h) {
          var g = h == null ? 0 : h.length;
          return g ? ro(h, 0, -1) : [];
        }
        var wH = Tt(function(h) {
          var g = Un(h, Ux);
          return g.length && g[0] === h[0] ? Mx(g) : [];
        }), _H = Tt(function(h) {
          var g = io(h), w = Un(h, Ux);
          return g === io(w) ? g = n : w.pop(), w.length && w[0] === h[0] ? Mx(w, rt(g, 2)) : [];
        }), kH = Tt(function(h) {
          var g = io(h), w = Un(h, Ux);
          return g = typeof g == "function" ? g : n, g && w.pop(), w.length && w[0] === h[0] ? Mx(w, n, g) : [];
        });
        function CH(h, g) {
          return h == null ? "" : xq.call(h, g);
        }
        function io(h) {
          var g = h == null ? 0 : h.length;
          return g ? h[g - 1] : n;
        }
        function SH(h, g, w) {
          var D = h == null ? 0 : h.length;
          if (!D)
            return -1;
          var F = D;
          return w !== n && (F = At(w), F = F < 0 ? kr(D + F, 0) : Xr(F, D - 1)), g === g ? iq(h, g, F) : Im(h, sS, F, !0);
        }
        function AH(h, g) {
          return h && h.length ? NS(h, At(g)) : n;
        }
        var EH = Tt(A8);
        function A8(h, g) {
          return h && h.length && g && g.length ? Bx(h, g) : h;
        }
        function DH(h, g, w) {
          return h && h.length && g && g.length ? Bx(h, g, rt(w, 2)) : h;
        }
        function OH(h, g, w) {
          return h && h.length && g && g.length ? Bx(h, g, n, w) : h;
        }
        var FH = wa(function(h, g) {
          var w = h == null ? 0 : h.length, D = Ox(h, g);
          return $S(h, Un(g, function(F) {
            return _a(F, w) ? +F : F;
          }).sort(YS)), D;
        });
        function TH(h, g) {
          var w = [];
          if (!(h && h.length))
            return w;
          var D = -1, F = [], z = h.length;
          for (g = rt(g, 3); ++D < z; ) {
            var V = h[D];
            g(V, D, h) && (w.push(V), F.push(D));
          }
          return $S(h, F), w;
        }
        function rw(h) {
          return h == null ? h : Cq.call(h);
        }
        function RH(h, g, w) {
          var D = h == null ? 0 : h.length;
          return D ? (w && typeof w != "number" && _i(h, g, w) ? (g = 0, w = D) : (g = g == null ? 0 : At(g), w = w === n ? D : At(w)), ro(h, g, w)) : [];
        }
        function MH(h, g) {
          return t1(h, g);
        }
        function PH(h, g, w) {
          return zx(h, g, rt(w, 2));
        }
        function IH(h, g) {
          var w = h == null ? 0 : h.length;
          if (w) {
            var D = t1(h, g);
            if (D < w && To(h[D], g))
              return D;
          }
          return -1;
        }
        function NH(h, g) {
          return t1(h, g, !0);
        }
        function BH(h, g, w) {
          return zx(h, g, rt(w, 2), !0);
        }
        function LH(h, g) {
          var w = h == null ? 0 : h.length;
          if (w) {
            var D = t1(h, g, !0) - 1;
            if (To(h[D], g))
              return D;
          }
          return -1;
        }
        function $H(h) {
          return h && h.length ? jS(h) : [];
        }
        function zH(h, g) {
          return h && h.length ? jS(h, rt(g, 2)) : [];
        }
        function jH(h) {
          var g = h == null ? 0 : h.length;
          return g ? ro(h, 1, g) : [];
        }
        function qH(h, g, w) {
          return h && h.length ? (g = w || g === n ? 1 : At(g), ro(h, 0, g < 0 ? 0 : g)) : [];
        }
        function UH(h, g, w) {
          var D = h == null ? 0 : h.length;
          return D ? (g = w || g === n ? 1 : At(g), g = D - g, ro(h, g < 0 ? 0 : g, D)) : [];
        }
        function HH(h, g) {
          return h && h.length ? n1(h, rt(g, 3), !1, !0) : [];
        }
        function VH(h, g) {
          return h && h.length ? n1(h, rt(g, 3)) : [];
        }
        var WH = Tt(function(h) {
          return wu(Hr(h, 1, ur, !0));
        }), GH = Tt(function(h) {
          var g = io(h);
          return ur(g) && (g = n), wu(Hr(h, 1, ur, !0), rt(g, 2));
        }), KH = Tt(function(h) {
          var g = io(h);
          return g = typeof g == "function" ? g : n, wu(Hr(h, 1, ur, !0), n, g);
        });
        function YH(h) {
          return h && h.length ? wu(h) : [];
        }
        function XH(h, g) {
          return h && h.length ? wu(h, rt(g, 2)) : [];
        }
        function QH(h, g) {
          return g = typeof g == "function" ? g : n, h && h.length ? wu(h, n, g) : [];
        }
        function iw(h) {
          if (!(h && h.length))
            return [];
          var g = 0;
          return h = mu(h, function(w) {
            if (ur(w))
              return g = kr(w.length, g), !0;
          }), wx(g, function(w) {
            return Un(h, bx(w));
          });
        }
        function E8(h, g) {
          if (!(h && h.length))
            return [];
          var w = iw(h);
          return g == null ? w : Un(w, function(D) {
            return vs(g, n, D);
          });
        }
        var JH = Tt(function(h, g) {
          return ur(h) ? I0(h, g) : [];
        }), ZH = Tt(function(h) {
          return qx(mu(h, ur));
        }), eV = Tt(function(h) {
          var g = io(h);
          return ur(g) && (g = n), qx(mu(h, ur), rt(g, 2));
        }), tV = Tt(function(h) {
          var g = io(h);
          return g = typeof g == "function" ? g : n, qx(mu(h, ur), n, g);
        }), nV = Tt(iw);
        function rV(h, g) {
          return VS(h || [], g || [], P0);
        }
        function iV(h, g) {
          return VS(h || [], g || [], L0);
        }
        var sV = Tt(function(h) {
          var g = h.length, w = g > 1 ? h[g - 1] : n;
          return w = typeof w == "function" ? (h.pop(), w) : n, E8(h, w);
        });
        function D8(h) {
          var g = I(h);
          return g.__chain__ = !0, g;
        }
        function oV(h, g) {
          return g(h), h;
        }
        function f1(h, g) {
          return g(h);
        }
        var lV = wa(function(h) {
          var g = h.length, w = g ? h[0] : 0, D = this.__wrapped__, F = function(z) {
            return Ox(z, h);
          };
          return g > 1 || this.__actions__.length || !(D instanceof Lt) || !_a(w) ? this.thru(F) : (D = D.slice(w, +w + (g ? 1 : 0)), D.__actions__.push({
            func: f1,
            args: [F],
            thisArg: n
          }), new to(D, this.__chain__).thru(function(z) {
            return g && !z.length && z.push(n), z;
          }));
        });
        function aV() {
          return D8(this);
        }
        function uV() {
          return new to(this.value(), this.__chain__);
        }
        function cV() {
          this.__values__ === n && (this.__values__ = q8(this.value()));
          var h = this.__index__ >= this.__values__.length, g = h ? n : this.__values__[this.__index__++];
          return { done: h, value: g };
        }
        function fV() {
          return this;
        }
        function hV(h) {
          for (var g, w = this; w instanceof Xm; ) {
            var D = w8(w);
            D.__index__ = 0, D.__values__ = n, g ? F.__wrapped__ = D : g = D;
            var F = D;
            w = w.__wrapped__;
          }
          return F.__wrapped__ = h, g;
        }
        function dV() {
          var h = this.__wrapped__;
          if (h instanceof Lt) {
            var g = h;
            return this.__actions__.length && (g = new Lt(this)), g = g.reverse(), g.__actions__.push({
              func: f1,
              args: [rw],
              thisArg: n
            }), new to(g, this.__chain__);
          }
          return this.thru(rw);
        }
        function pV() {
          return HS(this.__wrapped__, this.__actions__);
        }
        var gV = r1(function(h, g, w) {
          xn.call(h, w) ? ++h[w] : va(h, w, 1);
        });
        function mV(h, g, w) {
          var D = xt(h) ? rS : oU;
          return w && _i(h, g, w) && (g = n), D(h, rt(g, 3));
        }
        function yV(h, g) {
          var w = xt(h) ? mu : ES;
          return w(h, rt(g, 3));
        }
        var bV = t8(_8), vV = t8(k8);
        function xV(h, g) {
          return Hr(h1(h, g), 1);
        }
        function wV(h, g) {
          return Hr(h1(h, g), U);
        }
        function _V(h, g, w) {
          return w = w === n ? 1 : At(w), Hr(h1(h, g), w);
        }
        function O8(h, g) {
          var w = xt(h) ? Zs : xu;
          return w(h, rt(g, 3));
        }
        function F8(h, g) {
          var w = xt(h) ? jj : AS;
          return w(h, rt(g, 3));
        }
        var kV = r1(function(h, g, w) {
          xn.call(h, w) ? h[w].push(g) : va(h, w, [g]);
        });
        function CV(h, g, w, D) {
          h = ji(h) ? h : ph(h), w = w && !D ? At(w) : 0;
          var F = h.length;
          return w < 0 && (w = kr(F + w, 0)), y1(h) ? w <= F && h.indexOf(g, w) > -1 : !!F && nh(h, g, w) > -1;
        }
        var SV = Tt(function(h, g, w) {
          var D = -1, F = typeof g == "function", z = ji(h) ? le(h.length) : [];
          return xu(h, function(V) {
            z[++D] = F ? vs(g, V, w) : N0(V, g, w);
          }), z;
        }), AV = r1(function(h, g, w) {
          va(h, w, g);
        });
        function h1(h, g) {
          var w = xt(h) ? Un : MS;
          return w(h, rt(g, 3));
        }
        function EV(h, g, w, D) {
          return h == null ? [] : (xt(g) || (g = g == null ? [] : [g]), w = D ? n : w, xt(w) || (w = w == null ? [] : [w]), BS(h, g, w));
        }
        var DV = r1(function(h, g, w) {
          h[w ? 0 : 1].push(g);
        }, function() {
          return [[], []];
        });
        function OV(h, g, w) {
          var D = xt(h) ? mx : lS, F = arguments.length < 3;
          return D(h, rt(g, 4), w, F, xu);
        }
        function FV(h, g, w) {
          var D = xt(h) ? qj : lS, F = arguments.length < 3;
          return D(h, rt(g, 4), w, F, AS);
        }
        function TV(h, g) {
          var w = xt(h) ? mu : ES;
          return w(h, g1(rt(g, 3)));
        }
        function RV(h) {
          var g = xt(h) ? _S : CU;
          return g(h);
        }
        function MV(h, g, w) {
          (w ? _i(h, g, w) : g === n) ? g = 1 : g = At(g);
          var D = xt(h) ? tU : SU;
          return D(h, g);
        }
        function PV(h) {
          var g = xt(h) ? nU : EU;
          return g(h);
        }
        function IV(h) {
          if (h == null)
            return 0;
          if (ji(h))
            return y1(h) ? ih(h) : h.length;
          var g = Qr(h);
          return g == Ge || g == Ze ? h.size : Ix(h).length;
        }
        function NV(h, g, w) {
          var D = xt(h) ? yx : DU;
          return w && _i(h, g, w) && (g = n), D(h, rt(g, 3));
        }
        var BV = Tt(function(h, g) {
          if (h == null)
            return [];
          var w = g.length;
          return w > 1 && _i(h, g[0], g[1]) ? g = [] : w > 2 && _i(g[0], g[1], g[2]) && (g = [g[0]]), BS(h, Hr(g, 1), []);
        }), d1 = yq || function() {
          return Ur.Date.now();
        };
        function LV(h, g) {
          if (typeof g != "function")
            throw new eo(o);
          return h = At(h), function() {
            if (--h < 1)
              return g.apply(this, arguments);
          };
        }
        function T8(h, g, w) {
          return g = w ? n : g, g = h && g == null ? h.length : g, xa(h, A, n, n, n, n, g);
        }
        function R8(h, g) {
          var w;
          if (typeof g != "function")
            throw new eo(o);
          return h = At(h), function() {
            return --h > 0 && (w = g.apply(this, arguments)), h <= 1 && (g = n), w;
          };
        }
        var sw = Tt(function(h, g, w) {
          var D = b;
          if (w.length) {
            var F = bu(w, hh(sw));
            D |= C;
          }
          return xa(h, D, g, w, F);
        }), M8 = Tt(function(h, g, w) {
          var D = b | v;
          if (w.length) {
            var F = bu(w, hh(M8));
            D |= C;
          }
          return xa(g, D, h, w, F);
        });
        function P8(h, g, w) {
          g = w ? n : g;
          var D = xa(h, k, n, n, n, n, n, g);
          return D.placeholder = P8.placeholder, D;
        }
        function I8(h, g, w) {
          g = w ? n : g;
          var D = xa(h, S, n, n, n, n, n, g);
          return D.placeholder = I8.placeholder, D;
        }
        function N8(h, g, w) {
          var D, F, z, V, Y, ee, pe = 0, me = !1, xe = !1, Be = !0;
          if (typeof h != "function")
            throw new eo(o);
          g = so(g) || 0, Kn(w) && (me = !!w.leading, xe = "maxWait" in w, z = xe ? kr(so(w.maxWait) || 0, g) : z, Be = "trailing" in w ? !!w.trailing : Be);
          function Ve(cr) {
            var Ro = D, Sa = F;
            return D = F = n, pe = cr, V = h.apply(Sa, Ro), V;
          }
          function ot(cr) {
            return pe = cr, Y = j0(Nt, g), me ? Ve(cr) : V;
          }
          function Ot(cr) {
            var Ro = cr - ee, Sa = cr - pe, tA = g - Ro;
            return xe ? Xr(tA, z - Sa) : tA;
          }
          function lt(cr) {
            var Ro = cr - ee, Sa = cr - pe;
            return ee === n || Ro >= g || Ro < 0 || xe && Sa >= z;
          }
          function Nt() {
            var cr = d1();
            if (lt(cr))
              return qt(cr);
            Y = j0(Nt, Ot(cr));
          }
          function qt(cr) {
            return Y = n, Be && D ? Ve(cr) : (D = F = n, V);
          }
          function ks() {
            Y !== n && WS(Y), pe = 0, D = ee = F = Y = n;
          }
          function ki() {
            return Y === n ? V : qt(d1());
          }
          function Cs() {
            var cr = d1(), Ro = lt(cr);
            if (D = arguments, F = this, ee = cr, Ro) {
              if (Y === n)
                return ot(ee);
              if (xe)
                return WS(Y), Y = j0(Nt, g), Ve(ee);
            }
            return Y === n && (Y = j0(Nt, g)), V;
          }
          return Cs.cancel = ks, Cs.flush = ki, Cs;
        }
        var $V = Tt(function(h, g) {
          return SS(h, 1, g);
        }), zV = Tt(function(h, g, w) {
          return SS(h, so(g) || 0, w);
        });
        function jV(h) {
          return xa(h, T);
        }
        function p1(h, g) {
          if (typeof h != "function" || g != null && typeof g != "function")
            throw new eo(o);
          var w = function() {
            var D = arguments, F = g ? g.apply(this, D) : D[0], z = w.cache;
            if (z.has(F))
              return z.get(F);
            var V = h.apply(this, D);
            return w.cache = z.set(F, V) || z, V;
          };
          return w.cache = new (p1.Cache || ba)(), w;
        }
        p1.Cache = ba;
        function g1(h) {
          if (typeof h != "function")
            throw new eo(o);
          return function() {
            var g = arguments;
            switch (g.length) {
              case 0:
                return !h.call(this);
              case 1:
                return !h.call(this, g[0]);
              case 2:
                return !h.call(this, g[0], g[1]);
              case 3:
                return !h.call(this, g[0], g[1], g[2]);
            }
            return !h.apply(this, g);
          };
        }
        function qV(h) {
          return R8(2, h);
        }
        var UV = OU(function(h, g) {
          g = g.length == 1 && xt(g[0]) ? Un(g[0], xs(rt())) : Un(Hr(g, 1), xs(rt()));
          var w = g.length;
          return Tt(function(D) {
            for (var F = -1, z = Xr(D.length, w); ++F < z; )
              D[F] = g[F].call(this, D[F]);
            return vs(h, this, D);
          });
        }), ow = Tt(function(h, g) {
          var w = bu(g, hh(ow));
          return xa(h, C, n, g, w);
        }), B8 = Tt(function(h, g) {
          var w = bu(g, hh(B8));
          return xa(h, E, n, g, w);
        }), HV = wa(function(h, g) {
          return xa(h, O, n, n, n, g);
        });
        function VV(h, g) {
          if (typeof h != "function")
            throw new eo(o);
          return g = g === n ? g : At(g), Tt(h, g);
        }
        function WV(h, g) {
          if (typeof h != "function")
            throw new eo(o);
          return g = g == null ? 0 : kr(At(g), 0), Tt(function(w) {
            var D = w[g], F = ku(w, 0, g);
            return D && yu(F, D), vs(h, this, F);
          });
        }
        function GV(h, g, w) {
          var D = !0, F = !0;
          if (typeof h != "function")
            throw new eo(o);
          return Kn(w) && (D = "leading" in w ? !!w.leading : D, F = "trailing" in w ? !!w.trailing : F), N8(h, g, {
            leading: D,
            maxWait: g,
            trailing: F
          });
        }
        function KV(h) {
          return T8(h, 1);
        }
        function YV(h, g) {
          return ow(Hx(g), h);
        }
        function XV() {
          if (!arguments.length)
            return [];
          var h = arguments[0];
          return xt(h) ? h : [h];
        }
        function QV(h) {
          return no(h, p);
        }
        function JV(h, g) {
          return g = typeof g == "function" ? g : n, no(h, p, g);
        }
        function ZV(h) {
          return no(h, f | p);
        }
        function eW(h, g) {
          return g = typeof g == "function" ? g : n, no(h, f | p, g);
        }
        function tW(h, g) {
          return g == null || CS(h, g, Tr(g));
        }
        function To(h, g) {
          return h === g || h !== h && g !== g;
        }
        var nW = l1(Rx), rW = l1(function(h, g) {
          return h >= g;
        }), Oc = FS(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? FS : function(h) {
          return nr(h) && xn.call(h, "callee") && !mS.call(h, "callee");
        }, xt = le.isArray, iW = QC ? xs(QC) : hU;
        function ji(h) {
          return h != null && m1(h.length) && !ka(h);
        }
        function ur(h) {
          return nr(h) && ji(h);
        }
        function sW(h) {
          return h === !0 || h === !1 || nr(h) && wi(h) == Ce;
        }
        var Cu = vq || yw, oW = JC ? xs(JC) : dU;
        function lW(h) {
          return nr(h) && h.nodeType === 1 && !q0(h);
        }
        function aW(h) {
          if (h == null)
            return !0;
          if (ji(h) && (xt(h) || typeof h == "string" || typeof h.splice == "function" || Cu(h) || dh(h) || Oc(h)))
            return !h.length;
          var g = Qr(h);
          if (g == Ge || g == Ze)
            return !h.size;
          if (z0(h))
            return !Ix(h).length;
          for (var w in h)
            if (xn.call(h, w))
              return !1;
          return !0;
        }
        function uW(h, g) {
          return B0(h, g);
        }
        function cW(h, g, w) {
          w = typeof w == "function" ? w : n;
          var D = w ? w(h, g) : n;
          return D === n ? B0(h, g, n, w) : !!D;
        }
        function lw(h) {
          if (!nr(h))
            return !1;
          var g = wi(h);
          return g == Se || g == De || typeof h.message == "string" && typeof h.name == "string" && !q0(h);
        }
        function fW(h) {
          return typeof h == "number" && bS(h);
        }
        function ka(h) {
          if (!Kn(h))
            return !1;
          var g = wi(h);
          return g == Ne || g == Ye || g == Pe || g == un;
        }
        function L8(h) {
          return typeof h == "number" && h == At(h);
        }
        function m1(h) {
          return typeof h == "number" && h > -1 && h % 1 == 0 && h <= H;
        }
        function Kn(h) {
          var g = typeof h;
          return h != null && (g == "object" || g == "function");
        }
        function nr(h) {
          return h != null && typeof h == "object";
        }
        var $8 = ZC ? xs(ZC) : gU;
        function hW(h, g) {
          return h === g || Px(h, g, Qx(g));
        }
        function dW(h, g, w) {
          return w = typeof w == "function" ? w : n, Px(h, g, Qx(g), w);
        }
        function pW(h) {
          return z8(h) && h != +h;
        }
        function gW(h) {
          if (JU(h))
            throw new bt(s);
          return TS(h);
        }
        function mW(h) {
          return h === null;
        }
        function yW(h) {
          return h == null;
        }
        function z8(h) {
          return typeof h == "number" || nr(h) && wi(h) == gt;
        }
        function q0(h) {
          if (!nr(h) || wi(h) != mt)
            return !1;
          var g = Um(h);
          if (g === null)
            return !0;
          var w = xn.call(g, "constructor") && g.constructor;
          return typeof w == "function" && w instanceof w && $m.call(w) == dq;
        }
        var aw = eS ? xs(eS) : mU;
        function bW(h) {
          return L8(h) && h >= -H && h <= H;
        }
        var j8 = tS ? xs(tS) : yU;
        function y1(h) {
          return typeof h == "string" || !xt(h) && nr(h) && wi(h) == It;
        }
        function _s(h) {
          return typeof h == "symbol" || nr(h) && wi(h) == vn;
        }
        var dh = nS ? xs(nS) : bU;
        function vW(h) {
          return h === n;
        }
        function xW(h) {
          return nr(h) && Qr(h) == Oe;
        }
        function wW(h) {
          return nr(h) && wi(h) == et;
        }
        var _W = l1(Nx), kW = l1(function(h, g) {
          return h <= g;
        });
        function q8(h) {
          if (!h)
            return [];
          if (ji(h))
            return y1(h) ? Oo(h) : zi(h);
          if (O0 && h[O0])
            return tq(h[O0]());
          var g = Qr(h), w = g == Ge ? kx : g == Ze ? Nm : ph;
          return w(h);
        }
        function Ca(h) {
          if (!h)
            return h === 0 ? h : 0;
          if (h = so(h), h === U || h === -U) {
            var g = h < 0 ? -1 : 1;
            return g * G;
          }
          return h === h ? h : 0;
        }
        function At(h) {
          var g = Ca(h), w = g % 1;
          return g === g ? w ? g - w : g : 0;
        }
        function U8(h) {
          return h ? Sc(At(h), 0, se) : 0;
        }
        function so(h) {
          if (typeof h == "number")
            return h;
          if (_s(h))
            return re;
          if (Kn(h)) {
            var g = typeof h.valueOf == "function" ? h.valueOf() : h;
            h = Kn(g) ? g + "" : g;
          }
          if (typeof h != "string")
            return h === 0 ? h : +h;
          h = aS(h);
          var w = Ht.test(h);
          return w || An.test(h) ? Lj(h.slice(2), w ? 2 : 8) : ft.test(h) ? re : +h;
        }
        function H8(h) {
          return fl(h, qi(h));
        }
        function CW(h) {
          return h ? Sc(At(h), -H, H) : h === 0 ? h : 0;
        }
        function yn(h) {
          return h == null ? "" : ws(h);
        }
        var SW = ch(function(h, g) {
          if (z0(g) || ji(g)) {
            fl(g, Tr(g), h);
            return;
          }
          for (var w in g)
            xn.call(g, w) && P0(h, w, g[w]);
        }), V8 = ch(function(h, g) {
          fl(g, qi(g), h);
        }), b1 = ch(function(h, g, w, D) {
          fl(g, qi(g), h, D);
        }), AW = ch(function(h, g, w, D) {
          fl(g, Tr(g), h, D);
        }), EW = wa(Ox);
        function DW(h, g) {
          var w = uh(h);
          return g == null ? w : kS(w, g);
        }
        var OW = Tt(function(h, g) {
          h = En(h);
          var w = -1, D = g.length, F = D > 2 ? g[2] : n;
          for (F && _i(g[0], g[1], F) && (D = 1); ++w < D; )
            for (var z = g[w], V = qi(z), Y = -1, ee = V.length; ++Y < ee; ) {
              var pe = V[Y], me = h[pe];
              (me === n || To(me, oh[pe]) && !xn.call(h, pe)) && (h[pe] = z[pe]);
            }
          return h;
        }), FW = Tt(function(h) {
          return h.push(n, a8), vs(W8, n, h);
        });
        function TW(h, g) {
          return iS(h, rt(g, 3), cl);
        }
        function RW(h, g) {
          return iS(h, rt(g, 3), Tx);
        }
        function MW(h, g) {
          return h == null ? h : Fx(h, rt(g, 3), qi);
        }
        function PW(h, g) {
          return h == null ? h : DS(h, rt(g, 3), qi);
        }
        function IW(h, g) {
          return h && cl(h, rt(g, 3));
        }
        function NW(h, g) {
          return h && Tx(h, rt(g, 3));
        }
        function BW(h) {
          return h == null ? [] : Zm(h, Tr(h));
        }
        function LW(h) {
          return h == null ? [] : Zm(h, qi(h));
        }
        function uw(h, g, w) {
          var D = h == null ? n : Ac(h, g);
          return D === n ? w : D;
        }
        function $W(h, g) {
          return h != null && f8(h, g, aU);
        }
        function cw(h, g) {
          return h != null && f8(h, g, uU);
        }
        var zW = r8(function(h, g, w) {
          g != null && typeof g.toString != "function" && (g = zm.call(g)), h[g] = w;
        }, hw(Ui)), jW = r8(function(h, g, w) {
          g != null && typeof g.toString != "function" && (g = zm.call(g)), xn.call(h, g) ? h[g].push(w) : h[g] = [w];
        }, rt), qW = Tt(N0);
        function Tr(h) {
          return ji(h) ? wS(h) : Ix(h);
        }
        function qi(h) {
          return ji(h) ? wS(h, !0) : vU(h);
        }
        function UW(h, g) {
          var w = {};
          return g = rt(g, 3), cl(h, function(D, F, z) {
            va(w, g(D, F, z), D);
          }), w;
        }
        function HW(h, g) {
          var w = {};
          return g = rt(g, 3), cl(h, function(D, F, z) {
            va(w, F, g(D, F, z));
          }), w;
        }
        var VW = ch(function(h, g, w) {
          e1(h, g, w);
        }), W8 = ch(function(h, g, w, D) {
          e1(h, g, w, D);
        }), WW = wa(function(h, g) {
          var w = {};
          if (h == null)
            return w;
          var D = !1;
          g = Un(g, function(z) {
            return z = _u(z, h), D || (D = z.length > 1), z;
          }), fl(h, Yx(h), w), D && (w = no(w, f | d | p, zU));
          for (var F = g.length; F--; )
            jx(w, g[F]);
          return w;
        });
        function GW(h, g) {
          return G8(h, g1(rt(g)));
        }
        var KW = wa(function(h, g) {
          return h == null ? {} : wU(h, g);
        });
        function G8(h, g) {
          if (h == null)
            return {};
          var w = Un(Yx(h), function(D) {
            return [D];
          });
          return g = rt(g), LS(h, w, function(D, F) {
            return g(D, F[0]);
          });
        }
        function YW(h, g, w) {
          g = _u(g, h);
          var D = -1, F = g.length;
          for (F || (F = 1, h = n); ++D < F; ) {
            var z = h == null ? n : h[hl(g[D])];
            z === n && (D = F, z = w), h = ka(z) ? z.call(h) : z;
          }
          return h;
        }
        function XW(h, g, w) {
          return h == null ? h : L0(h, g, w);
        }
        function QW(h, g, w, D) {
          return D = typeof D == "function" ? D : n, h == null ? h : L0(h, g, w, D);
        }
        var K8 = o8(Tr), Y8 = o8(qi);
        function JW(h, g, w) {
          var D = xt(h), F = D || Cu(h) || dh(h);
          if (g = rt(g, 4), w == null) {
            var z = h && h.constructor;
            F ? w = D ? new z() : [] : Kn(h) ? w = ka(z) ? uh(Um(h)) : {} : w = {};
          }
          return (F ? Zs : cl)(h, function(V, Y, ee) {
            return g(w, V, Y, ee);
          }), w;
        }
        function ZW(h, g) {
          return h == null ? !0 : jx(h, g);
        }
        function eG(h, g, w) {
          return h == null ? h : US(h, g, Hx(w));
        }
        function tG(h, g, w, D) {
          return D = typeof D == "function" ? D : n, h == null ? h : US(h, g, Hx(w), D);
        }
        function ph(h) {
          return h == null ? [] : _x(h, Tr(h));
        }
        function nG(h) {
          return h == null ? [] : _x(h, qi(h));
        }
        function rG(h, g, w) {
          return w === n && (w = g, g = n), w !== n && (w = so(w), w = w === w ? w : 0), g !== n && (g = so(g), g = g === g ? g : 0), Sc(so(h), g, w);
        }
        function iG(h, g, w) {
          return g = Ca(g), w === n ? (w = g, g = 0) : w = Ca(w), h = so(h), cU(h, g, w);
        }
        function sG(h, g, w) {
          if (w && typeof w != "boolean" && _i(h, g, w) && (g = w = n), w === n && (typeof g == "boolean" ? (w = g, g = n) : typeof h == "boolean" && (w = h, h = n)), h === n && g === n ? (h = 0, g = 1) : (h = Ca(h), g === n ? (g = h, h = 0) : g = Ca(g)), h > g) {
            var D = h;
            h = g, g = D;
          }
          if (w || h % 1 || g % 1) {
            var F = vS();
            return Xr(h + F * (g - h + Bj("1e-" + ((F + "").length - 1))), g);
          }
          return Lx(h, g);
        }
        var oG = fh(function(h, g, w) {
          return g = g.toLowerCase(), h + (w ? X8(g) : g);
        });
        function X8(h) {
          return fw(yn(h).toLowerCase());
        }
        function Q8(h) {
          return h = yn(h), h && h.replace(Qs, Xj).replace(Ej, "");
        }
        function lG(h, g, w) {
          h = yn(h), g = ws(g);
          var D = h.length;
          w = w === n ? D : Sc(At(w), 0, D);
          var F = w;
          return w -= g.length, w >= 0 && h.slice(w, F) == g;
        }
        function aG(h) {
          return h = yn(h), h && nx.test(h) ? h.replace(xc, Qj) : h;
        }
        function uG(h) {
          return h = yn(h), h && ix.test(h) ? h.replace(S0, "\\$&") : h;
        }
        var cG = fh(function(h, g, w) {
          return h + (w ? "-" : "") + g.toLowerCase();
        }), fG = fh(function(h, g, w) {
          return h + (w ? " " : "") + g.toLowerCase();
        }), hG = e8("toLowerCase");
        function dG(h, g, w) {
          h = yn(h), g = At(g);
          var D = g ? ih(h) : 0;
          if (!g || D >= g)
            return h;
          var F = (g - D) / 2;
          return o1(Gm(F), w) + h + o1(Wm(F), w);
        }
        function pG(h, g, w) {
          h = yn(h), g = At(g);
          var D = g ? ih(h) : 0;
          return g && D < g ? h + o1(g - D, w) : h;
        }
        function gG(h, g, w) {
          h = yn(h), g = At(g);
          var D = g ? ih(h) : 0;
          return g && D < g ? o1(g - D, w) + h : h;
        }
        function mG(h, g, w) {
          return w || g == null ? g = 0 : g && (g = +g), kq(yn(h).replace(A0, ""), g || 0);
        }
        function yG(h, g, w) {
          return (w ? _i(h, g, w) : g === n) ? g = 1 : g = At(g), $x(yn(h), g);
        }
        function bG() {
          var h = arguments, g = yn(h[0]);
          return h.length < 3 ? g : g.replace(h[1], h[2]);
        }
        var vG = fh(function(h, g, w) {
          return h + (w ? "_" : "") + g.toLowerCase();
        });
        function xG(h, g, w) {
          return w && typeof w != "number" && _i(h, g, w) && (g = w = n), w = w === n ? se : w >>> 0, w ? (h = yn(h), h && (typeof g == "string" || g != null && !aw(g)) && (g = ws(g), !g && rh(h)) ? ku(Oo(h), 0, w) : h.split(g, w)) : [];
        }
        var wG = fh(function(h, g, w) {
          return h + (w ? " " : "") + fw(g);
        });
        function _G(h, g, w) {
          return h = yn(h), w = w == null ? 0 : Sc(At(w), 0, h.length), g = ws(g), h.slice(w, w + g.length) == g;
        }
        function kG(h, g, w) {
          var D = I.templateSettings;
          w && _i(h, g, w) && (g = n), h = yn(h), g = b1({}, g, D, l8);
          var F = b1({}, g.imports, D.imports, l8), z = Tr(F), V = _x(F, z), Y, ee, pe = 0, me = g.interpolate || Fr, xe = "__p += '", Be = Cx(
            (g.escape || Fr).source + "|" + me.source + "|" + (me === Om ? Xe : Fr).source + "|" + (g.evaluate || Fr).source + "|$",
            "g"
          ), Ve = "//# sourceURL=" + (xn.call(g, "sourceURL") ? (g.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Rj + "]") + `
`;
          h.replace(Be, function(lt, Nt, qt, ks, ki, Cs) {
            return qt || (qt = ks), xe += h.slice(pe, Cs).replace(bs, Jj), Nt && (Y = !0, xe += `' +
__e(` + Nt + `) +
'`), ki && (ee = !0, xe += `';
` + ki + `;
__p += '`), qt && (xe += `' +
((__t = (` + qt + `)) == null ? '' : __t) +
'`), pe = Cs + lt.length, lt;
          }), xe += `';
`;
          var ot = xn.call(g, "variable") && g.variable;
          if (!ot)
            xe = `with (obj) {
` + xe + `
}
`;
          else if (Re.test(ot))
            throw new bt(l);
          xe = (ee ? xe.replace(ys, "") : xe).replace(al, "$1").replace(So, "$1;"), xe = "function(" + (ot || "obj") + `) {
` + (ot ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Y ? ", __e = _.escape" : "") + (ee ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + xe + `return __p
}`;
          var Ot = Z8(function() {
            return cn(z, Ve + "return " + xe).apply(n, V);
          });
          if (Ot.source = xe, lw(Ot))
            throw Ot;
          return Ot;
        }
        function CG(h) {
          return yn(h).toLowerCase();
        }
        function SG(h) {
          return yn(h).toUpperCase();
        }
        function AG(h, g, w) {
          if (h = yn(h), h && (w || g === n))
            return aS(h);
          if (!h || !(g = ws(g)))
            return h;
          var D = Oo(h), F = Oo(g), z = uS(D, F), V = cS(D, F) + 1;
          return ku(D, z, V).join("");
        }
        function EG(h, g, w) {
          if (h = yn(h), h && (w || g === n))
            return h.slice(0, hS(h) + 1);
          if (!h || !(g = ws(g)))
            return h;
          var D = Oo(h), F = cS(D, Oo(g)) + 1;
          return ku(D, 0, F).join("");
        }
        function DG(h, g, w) {
          if (h = yn(h), h && (w || g === n))
            return h.replace(A0, "");
          if (!h || !(g = ws(g)))
            return h;
          var D = Oo(h), F = uS(D, Oo(g));
          return ku(D, F).join("");
        }
        function OG(h, g) {
          var w = $, D = P;
          if (Kn(g)) {
            var F = "separator" in g ? g.separator : F;
            w = "length" in g ? At(g.length) : w, D = "omission" in g ? ws(g.omission) : D;
          }
          h = yn(h);
          var z = h.length;
          if (rh(h)) {
            var V = Oo(h);
            z = V.length;
          }
          if (w >= z)
            return h;
          var Y = w - ih(D);
          if (Y < 1)
            return D;
          var ee = V ? ku(V, 0, Y).join("") : h.slice(0, Y);
          if (F === n)
            return ee + D;
          if (V && (Y += ee.length - Y), aw(F)) {
            if (h.slice(Y).search(F)) {
              var pe, me = ee;
              for (F.global || (F = Cx(F.source, yn(tt.exec(F)) + "g")), F.lastIndex = 0; pe = F.exec(me); )
                var xe = pe.index;
              ee = ee.slice(0, xe === n ? Y : xe);
            }
          } else if (h.indexOf(ws(F), Y) != Y) {
            var Be = ee.lastIndexOf(F);
            Be > -1 && (ee = ee.slice(0, Be));
          }
          return ee + D;
        }
        function FG(h) {
          return h = yn(h), h && tx.test(h) ? h.replace(Ao, sq) : h;
        }
        var TG = fh(function(h, g, w) {
          return h + (w ? " " : "") + g.toUpperCase();
        }), fw = e8("toUpperCase");
        function J8(h, g, w) {
          return h = yn(h), g = w ? n : g, g === n ? eq(h) ? aq(h) : Vj(h) : h.match(g) || [];
        }
        var Z8 = Tt(function(h, g) {
          try {
            return vs(h, n, g);
          } catch (w) {
            return lw(w) ? w : new bt(w);
          }
        }), RG = wa(function(h, g) {
          return Zs(g, function(w) {
            w = hl(w), va(h, w, sw(h[w], h));
          }), h;
        });
        function MG(h) {
          var g = h == null ? 0 : h.length, w = rt();
          return h = g ? Un(h, function(D) {
            if (typeof D[1] != "function")
              throw new eo(o);
            return [w(D[0]), D[1]];
          }) : [], Tt(function(D) {
            for (var F = -1; ++F < g; ) {
              var z = h[F];
              if (vs(z[0], this, D))
                return vs(z[1], this, D);
            }
          });
        }
        function PG(h) {
          return sU(no(h, f));
        }
        function hw(h) {
          return function() {
            return h;
          };
        }
        function IG(h, g) {
          return h == null || h !== h ? g : h;
        }
        var NG = n8(), BG = n8(!0);
        function Ui(h) {
          return h;
        }
        function dw(h) {
          return RS(typeof h == "function" ? h : no(h, f));
        }
        function LG(h) {
          return PS(no(h, f));
        }
        function $G(h, g) {
          return IS(h, no(g, f));
        }
        var zG = Tt(function(h, g) {
          return function(w) {
            return N0(w, h, g);
          };
        }), jG = Tt(function(h, g) {
          return function(w) {
            return N0(h, w, g);
          };
        });
        function pw(h, g, w) {
          var D = Tr(g), F = Zm(g, D);
          w == null && !(Kn(g) && (F.length || !D.length)) && (w = g, g = h, h = this, F = Zm(g, Tr(g)));
          var z = !(Kn(w) && "chain" in w) || !!w.chain, V = ka(h);
          return Zs(F, function(Y) {
            var ee = g[Y];
            h[Y] = ee, V && (h.prototype[Y] = function() {
              var pe = this.__chain__;
              if (z || pe) {
                var me = h(this.__wrapped__), xe = me.__actions__ = zi(this.__actions__);
                return xe.push({ func: ee, args: arguments, thisArg: h }), me.__chain__ = pe, me;
              }
              return ee.apply(h, yu([this.value()], arguments));
            });
          }), h;
        }
        function qG() {
          return Ur._ === this && (Ur._ = pq), this;
        }
        function gw() {
        }
        function UG(h) {
          return h = At(h), Tt(function(g) {
            return NS(g, h);
          });
        }
        var HG = Wx(Un), VG = Wx(rS), WG = Wx(yx);
        function eA(h) {
          return Zx(h) ? bx(hl(h)) : _U(h);
        }
        function GG(h) {
          return function(g) {
            return h == null ? n : Ac(h, g);
          };
        }
        var KG = i8(), YG = i8(!0);
        function mw() {
          return [];
        }
        function yw() {
          return !1;
        }
        function XG() {
          return {};
        }
        function QG() {
          return "";
        }
        function JG() {
          return !0;
        }
        function ZG(h, g) {
          if (h = At(h), h < 1 || h > H)
            return [];
          var w = se, D = Xr(h, se);
          g = rt(g), h -= se;
          for (var F = wx(D, g); ++w < h; )
            g(w);
          return F;
        }
        function eK(h) {
          return xt(h) ? Un(h, hl) : _s(h) ? [h] : zi(x8(yn(h)));
        }
        function tK(h) {
          var g = ++hq;
          return yn(h) + g;
        }
        var nK = s1(function(h, g) {
          return h + g;
        }, 0), rK = Gx("ceil"), iK = s1(function(h, g) {
          return h / g;
        }, 1), sK = Gx("floor");
        function oK(h) {
          return h && h.length ? Jm(h, Ui, Rx) : n;
        }
        function lK(h, g) {
          return h && h.length ? Jm(h, rt(g, 2), Rx) : n;
        }
        function aK(h) {
          return oS(h, Ui);
        }
        function uK(h, g) {
          return oS(h, rt(g, 2));
        }
        function cK(h) {
          return h && h.length ? Jm(h, Ui, Nx) : n;
        }
        function fK(h, g) {
          return h && h.length ? Jm(h, rt(g, 2), Nx) : n;
        }
        var hK = s1(function(h, g) {
          return h * g;
        }, 1), dK = Gx("round"), pK = s1(function(h, g) {
          return h - g;
        }, 0);
        function gK(h) {
          return h && h.length ? xx(h, Ui) : 0;
        }
        function mK(h, g) {
          return h && h.length ? xx(h, rt(g, 2)) : 0;
        }
        return I.after = LV, I.ary = T8, I.assign = SW, I.assignIn = V8, I.assignInWith = b1, I.assignWith = AW, I.at = EW, I.before = R8, I.bind = sw, I.bindAll = RG, I.bindKey = M8, I.castArray = XV, I.chain = D8, I.chunk = sH, I.compact = oH, I.concat = lH, I.cond = MG, I.conforms = PG, I.constant = hw, I.countBy = gV, I.create = DW, I.curry = P8, I.curryRight = I8, I.debounce = N8, I.defaults = OW, I.defaultsDeep = FW, I.defer = $V, I.delay = zV, I.difference = aH, I.differenceBy = uH, I.differenceWith = cH, I.drop = fH, I.dropRight = hH, I.dropRightWhile = dH, I.dropWhile = pH, I.fill = gH, I.filter = yV, I.flatMap = xV, I.flatMapDeep = wV, I.flatMapDepth = _V, I.flatten = C8, I.flattenDeep = mH, I.flattenDepth = yH, I.flip = jV, I.flow = NG, I.flowRight = BG, I.fromPairs = bH, I.functions = BW, I.functionsIn = LW, I.groupBy = kV, I.initial = xH, I.intersection = wH, I.intersectionBy = _H, I.intersectionWith = kH, I.invert = zW, I.invertBy = jW, I.invokeMap = SV, I.iteratee = dw, I.keyBy = AV, I.keys = Tr, I.keysIn = qi, I.map = h1, I.mapKeys = UW, I.mapValues = HW, I.matches = LG, I.matchesProperty = $G, I.memoize = p1, I.merge = VW, I.mergeWith = W8, I.method = zG, I.methodOf = jG, I.mixin = pw, I.negate = g1, I.nthArg = UG, I.omit = WW, I.omitBy = GW, I.once = qV, I.orderBy = EV, I.over = HG, I.overArgs = UV, I.overEvery = VG, I.overSome = WG, I.partial = ow, I.partialRight = B8, I.partition = DV, I.pick = KW, I.pickBy = G8, I.property = eA, I.propertyOf = GG, I.pull = EH, I.pullAll = A8, I.pullAllBy = DH, I.pullAllWith = OH, I.pullAt = FH, I.range = KG, I.rangeRight = YG, I.rearg = HV, I.reject = TV, I.remove = TH, I.rest = VV, I.reverse = rw, I.sampleSize = MV, I.set = XW, I.setWith = QW, I.shuffle = PV, I.slice = RH, I.sortBy = BV, I.sortedUniq = $H, I.sortedUniqBy = zH, I.split = xG, I.spread = WV, I.tail = jH, I.take = qH, I.takeRight = UH, I.takeRightWhile = HH, I.takeWhile = VH, I.tap = oV, I.throttle = GV, I.thru = f1, I.toArray = q8, I.toPairs = K8, I.toPairsIn = Y8, I.toPath = eK, I.toPlainObject = H8, I.transform = JW, I.unary = KV, I.union = WH, I.unionBy = GH, I.unionWith = KH, I.uniq = YH, I.uniqBy = XH, I.uniqWith = QH, I.unset = ZW, I.unzip = iw, I.unzipWith = E8, I.update = eG, I.updateWith = tG, I.values = ph, I.valuesIn = nG, I.without = JH, I.words = J8, I.wrap = YV, I.xor = ZH, I.xorBy = eV, I.xorWith = tV, I.zip = nV, I.zipObject = rV, I.zipObjectDeep = iV, I.zipWith = sV, I.entries = K8, I.entriesIn = Y8, I.extend = V8, I.extendWith = b1, pw(I, I), I.add = nK, I.attempt = Z8, I.camelCase = oG, I.capitalize = X8, I.ceil = rK, I.clamp = rG, I.clone = QV, I.cloneDeep = ZV, I.cloneDeepWith = eW, I.cloneWith = JV, I.conformsTo = tW, I.deburr = Q8, I.defaultTo = IG, I.divide = iK, I.endsWith = lG, I.eq = To, I.escape = aG, I.escapeRegExp = uG, I.every = mV, I.find = bV, I.findIndex = _8, I.findKey = TW, I.findLast = vV, I.findLastIndex = k8, I.findLastKey = RW, I.floor = sK, I.forEach = O8, I.forEachRight = F8, I.forIn = MW, I.forInRight = PW, I.forOwn = IW, I.forOwnRight = NW, I.get = uw, I.gt = nW, I.gte = rW, I.has = $W, I.hasIn = cw, I.head = S8, I.identity = Ui, I.includes = CV, I.indexOf = vH, I.inRange = iG, I.invoke = qW, I.isArguments = Oc, I.isArray = xt, I.isArrayBuffer = iW, I.isArrayLike = ji, I.isArrayLikeObject = ur, I.isBoolean = sW, I.isBuffer = Cu, I.isDate = oW, I.isElement = lW, I.isEmpty = aW, I.isEqual = uW, I.isEqualWith = cW, I.isError = lw, I.isFinite = fW, I.isFunction = ka, I.isInteger = L8, I.isLength = m1, I.isMap = $8, I.isMatch = hW, I.isMatchWith = dW, I.isNaN = pW, I.isNative = gW, I.isNil = yW, I.isNull = mW, I.isNumber = z8, I.isObject = Kn, I.isObjectLike = nr, I.isPlainObject = q0, I.isRegExp = aw, I.isSafeInteger = bW, I.isSet = j8, I.isString = y1, I.isSymbol = _s, I.isTypedArray = dh, I.isUndefined = vW, I.isWeakMap = xW, I.isWeakSet = wW, I.join = CH, I.kebabCase = cG, I.last = io, I.lastIndexOf = SH, I.lowerCase = fG, I.lowerFirst = hG, I.lt = _W, I.lte = kW, I.max = oK, I.maxBy = lK, I.mean = aK, I.meanBy = uK, I.min = cK, I.minBy = fK, I.stubArray = mw, I.stubFalse = yw, I.stubObject = XG, I.stubString = QG, I.stubTrue = JG, I.multiply = hK, I.nth = AH, I.noConflict = qG, I.noop = gw, I.now = d1, I.pad = dG, I.padEnd = pG, I.padStart = gG, I.parseInt = mG, I.random = sG, I.reduce = OV, I.reduceRight = FV, I.repeat = yG, I.replace = bG, I.result = YW, I.round = dK, I.runInContext = Z, I.sample = RV, I.size = IV, I.snakeCase = vG, I.some = NV, I.sortedIndex = MH, I.sortedIndexBy = PH, I.sortedIndexOf = IH, I.sortedLastIndex = NH, I.sortedLastIndexBy = BH, I.sortedLastIndexOf = LH, I.startCase = wG, I.startsWith = _G, I.subtract = pK, I.sum = gK, I.sumBy = mK, I.template = kG, I.times = ZG, I.toFinite = Ca, I.toInteger = At, I.toLength = U8, I.toLower = CG, I.toNumber = so, I.toSafeInteger = CW, I.toString = yn, I.toUpper = SG, I.trim = AG, I.trimEnd = EG, I.trimStart = DG, I.truncate = OG, I.unescape = FG, I.uniqueId = tK, I.upperCase = TG, I.upperFirst = fw, I.each = O8, I.eachRight = F8, I.first = S8, pw(I, (function() {
          var h = {};
          return cl(I, function(g, w) {
            xn.call(I.prototype, w) || (h[w] = g);
          }), h;
        })(), { chain: !1 }), I.VERSION = r, Zs(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(h) {
          I[h].placeholder = I;
        }), Zs(["drop", "take"], function(h, g) {
          Lt.prototype[h] = function(w) {
            w = w === n ? 1 : kr(At(w), 0);
            var D = this.__filtered__ && !g ? new Lt(this) : this.clone();
            return D.__filtered__ ? D.__takeCount__ = Xr(w, D.__takeCount__) : D.__views__.push({
              size: Xr(w, se),
              type: h + (D.__dir__ < 0 ? "Right" : "")
            }), D;
          }, Lt.prototype[h + "Right"] = function(w) {
            return this.reverse()[h](w).reverse();
          };
        }), Zs(["filter", "map", "takeWhile"], function(h, g) {
          var w = g + 1, D = w == L || w == j;
          Lt.prototype[h] = function(F) {
            var z = this.clone();
            return z.__iteratees__.push({
              iteratee: rt(F, 3),
              type: w
            }), z.__filtered__ = z.__filtered__ || D, z;
          };
        }), Zs(["head", "last"], function(h, g) {
          var w = "take" + (g ? "Right" : "");
          Lt.prototype[h] = function() {
            return this[w](1).value()[0];
          };
        }), Zs(["initial", "tail"], function(h, g) {
          var w = "drop" + (g ? "" : "Right");
          Lt.prototype[h] = function() {
            return this.__filtered__ ? new Lt(this) : this[w](1);
          };
        }), Lt.prototype.compact = function() {
          return this.filter(Ui);
        }, Lt.prototype.find = function(h) {
          return this.filter(h).head();
        }, Lt.prototype.findLast = function(h) {
          return this.reverse().find(h);
        }, Lt.prototype.invokeMap = Tt(function(h, g) {
          return typeof h == "function" ? new Lt(this) : this.map(function(w) {
            return N0(w, h, g);
          });
        }), Lt.prototype.reject = function(h) {
          return this.filter(g1(rt(h)));
        }, Lt.prototype.slice = function(h, g) {
          h = At(h);
          var w = this;
          return w.__filtered__ && (h > 0 || g < 0) ? new Lt(w) : (h < 0 ? w = w.takeRight(-h) : h && (w = w.drop(h)), g !== n && (g = At(g), w = g < 0 ? w.dropRight(-g) : w.take(g - h)), w);
        }, Lt.prototype.takeRightWhile = function(h) {
          return this.reverse().takeWhile(h).reverse();
        }, Lt.prototype.toArray = function() {
          return this.take(se);
        }, cl(Lt.prototype, function(h, g) {
          var w = /^(?:filter|find|map|reject)|While$/.test(g), D = /^(?:head|last)$/.test(g), F = I[D ? "take" + (g == "last" ? "Right" : "") : g], z = D || /^find/.test(g);
          F && (I.prototype[g] = function() {
            var V = this.__wrapped__, Y = D ? [1] : arguments, ee = V instanceof Lt, pe = Y[0], me = ee || xt(V), xe = function(Nt) {
              var qt = F.apply(I, yu([Nt], Y));
              return D && Be ? qt[0] : qt;
            };
            me && w && typeof pe == "function" && pe.length != 1 && (ee = me = !1);
            var Be = this.__chain__, Ve = !!this.__actions__.length, ot = z && !Be, Ot = ee && !Ve;
            if (!z && me) {
              V = Ot ? V : new Lt(this);
              var lt = h.apply(V, Y);
              return lt.__actions__.push({ func: f1, args: [xe], thisArg: n }), new to(lt, Be);
            }
            return ot && Ot ? h.apply(this, Y) : (lt = this.thru(xe), ot ? D ? lt.value()[0] : lt.value() : lt);
          });
        }), Zs(["pop", "push", "shift", "sort", "splice", "unshift"], function(h) {
          var g = Bm[h], w = /^(?:push|sort|unshift)$/.test(h) ? "tap" : "thru", D = /^(?:pop|shift)$/.test(h);
          I.prototype[h] = function() {
            var F = arguments;
            if (D && !this.__chain__) {
              var z = this.value();
              return g.apply(xt(z) ? z : [], F);
            }
            return this[w](function(V) {
              return g.apply(xt(V) ? V : [], F);
            });
          };
        }), cl(Lt.prototype, function(h, g) {
          var w = I[g];
          if (w) {
            var D = w.name + "";
            xn.call(ah, D) || (ah[D] = []), ah[D].push({ name: g, func: w });
          }
        }), ah[i1(n, v).name] = [{
          name: "wrapper",
          func: n
        }], Lt.prototype.clone = Fq, Lt.prototype.reverse = Tq, Lt.prototype.value = Rq, I.prototype.at = lV, I.prototype.chain = aV, I.prototype.commit = uV, I.prototype.next = cV, I.prototype.plant = hV, I.prototype.reverse = dV, I.prototype.toJSON = I.prototype.valueOf = I.prototype.value = pV, I.prototype.first = I.prototype.head, O0 && (I.prototype[O0] = fV), I;
      }), sh = uq();
      wc ? ((wc.exports = sh)._ = sh, dx._ = sh) : Ur._ = sh;
    }).call(W3e);
  })(tb, tb.exports)), tb.exports;
}
var Mk = G3e();
const rj = /* @__PURE__ */ FC(Mk), K3e = {
  headerHeight: null,
  columnConfigs: {},
  onColumnConfigsChange: () => {
  },
  minColumnWidths: {},
  rowRenderBatchSize: 4,
  minFetchSize: 1,
  renderWindowOffset: 400,
  verticalScrollbarPillHeight: 4,
  verticalScrollbarWidth: 24,
  horizontalScrollbarHeight: 16,
  lineHeight: 20,
  textMaxLines: 3,
  betweenRowPadding: 8,
  betweenColPadding: 24,
  scrollOverflowValue: 1e6,
  // keep this below chrome's maximum translate value
  onRowClick: null,
  highlightedRows: null,
  firstColLeftPadding: 8,
  showRowNumber: !0,
  onShowRowNumberChange: () => {
  },
  highlightHoveredRow: !1,
  get rowHeight() {
    return this.textMaxLines * this.lineHeight + this.betweenRowPadding;
  },
  DEFAULT_TEXT_MAX_LINES: 3,
  DEFAULT_LINE_HEIGHT: 20,
  DEFAULT_ROW_NUMBER_COL_WIDTH: 60
};
class Y3e {
  #e = /* @__PURE__ */ He(ai(K3e));
  get config() {
    return q(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const HO = Symbol("config");
class wn {
  static initialize() {
    co(HO, new Y3e());
  }
  static get config() {
    const e = Xi(HO);
    if (e == null)
      throw new Error("config context not yet set");
    return e.config;
  }
}
class X3e {
  tableModel;
  tableController;
  margin = 2;
  isDragging = !1;
  lastDragX = 0;
  #e = /* @__PURE__ */ He(0);
  get elementWidth() {
    return q(this.#e);
  }
  set elementWidth(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ _e(() => this.elementWidth - this.margin * 2);
  get scrollbarWidth() {
    return q(this.#t);
  }
  set scrollbarWidth(e) {
    be(this.#t, e);
  }
  #n = /* @__PURE__ */ _e(() => this.tableController.viewWidth / this.tableModel.colsRightmostPosition * this.scrollbarWidth);
  get pillWidth() {
    return q(this.#n);
  }
  set pillWidth(e) {
    be(this.#n, e);
  }
  #r = /* @__PURE__ */ _e(() => -this.tableController.xScroll / this.tableModel.colsRightmostPosition * this.scrollbarWidth);
  get pillLeft() {
    return q(this.#r);
  }
  set pillLeft(e) {
    be(this.#r, e);
  }
  constructor({ tableModel: e, tableController: n }) {
    this.tableModel = e, this.tableController = n;
  }
  handlePointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0, this.lastDragX = e.offsetX;
  };
  handlePointerMove = (e) => {
    this.isDragging && this.lastDragX !== null && this.tableController.scroll({ deltaX: e.offsetX - this.lastDragX, deltaY: 0 });
  };
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.lastDragX = null;
  };
}
const VO = Symbol("mosaic-coordinator");
class Pk {
  static get coordinator() {
    return Xi(VO) ?? _F();
  }
  static set coordinator(e) {
    co(VO, e);
  }
}
const Wi = "__oid", Q3e = 120;
class J3e {
  schema;
  #e = /* @__PURE__ */ He(ai({}));
  get data() {
    return q(this.#e);
  }
  set data(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ He(ai({}));
  get defaultColWidths() {
    return q(this.#t);
  }
  set defaultColWidths(e) {
    be(this.#t, e, !0);
  }
  #n = /* @__PURE__ */ He(ai([]));
  get columns() {
    return q(this.#n);
  }
  set columns(e) {
    be(this.#n, e, !0);
  }
  #r = /* @__PURE__ */ He(0);
  get numRows() {
    return q(this.#r);
  }
  set numRows(e) {
    be(this.#r, e, !0);
  }
  #a = /* @__PURE__ */ He(0);
  get renderOffset() {
    return q(this.#a);
  }
  set renderOffset(e) {
    be(this.#a, e, !0);
  }
  #l = /* @__PURE__ */ He(ai({}));
  get rowHeightAddition() {
    return q(this.#l);
  }
  set rowHeightAddition(e) {
    be(this.#l, e, !0);
  }
  #i = /* @__PURE__ */ _e(() => this.columns.reduce(
    (e, n) => (wn.config.columnConfigs[n]?.hidden && e.add(n), n === Wi && wn.config.showRowNumber === !1 && e.add(Wi), e),
    /* @__PURE__ */ new Set()
  ));
  get hiddenColumns() {
    return q(this.#i);
  }
  set hiddenColumns(e) {
    be(this.#i, e);
  }
  rowKeyColumn = null;
  constructor(e) {
    this.schema = e;
  }
  #s = /* @__PURE__ */ _e(() => Object.keys(this.data).sort((e, n) => this.data[e][Wi] - this.data[n][Wi]));
  get renderableRows() {
    return q(this.#s);
  }
  set renderableRows(e) {
    be(this.#s, e);
  }
  #o = /* @__PURE__ */ _e(() => this.columns.filter((e) => !this.hiddenColumns.has(e)));
  get renderableCols() {
    return q(this.#o);
  }
  set renderableCols(e) {
    be(this.#o, e);
  }
  #u = /* @__PURE__ */ _e(() => this.renderableRows.length === 0 ? this.zeroRowPosition : Math.min(...this.renderableRows.map((e) => this.rowPositions[e])));
  get minRowPosition() {
    return q(this.#u);
  }
  set minRowPosition(e) {
    be(this.#u, e);
  }
  #c = /* @__PURE__ */ _e(() => this.renderableRows.length === 0 ? this.finalRowPosition : Math.max(...this.renderableRows.map((e) => this.rowPositions[e])));
  get maxRowPosition() {
    return q(this.#c);
  }
  set maxRowPosition(e) {
    be(this.#c, e);
  }
  #d = /* @__PURE__ */ _e(() => {
    const e = Math.min(...this.renderableRows.map((n) => this.data[n][Wi]));
    return Number.isSafeInteger(e) ? e : 0;
  });
  get minRowOID() {
    return q(this.#d);
  }
  set minRowOID(e) {
    be(this.#d, e);
  }
  #f = /* @__PURE__ */ _e(() => {
    const e = Math.max(...this.renderableRows.map((n) => this.data[n][Wi]));
    return Number.isSafeInteger(e) ? e : 0;
  });
  get maxRowOID() {
    return q(this.#f);
  }
  set maxRowOID(e) {
    be(this.#f, e);
  }
  #p = /* @__PURE__ */ _e(() => 0);
  get zeroRowPosition() {
    return q(this.#p);
  }
  set zeroRowPosition(e) {
    be(this.#p, e);
  }
  #h = /* @__PURE__ */ _e(() => (this.numRows - 1) * wn.config.rowHeight + this.rowPositionOffsets.cumulative);
  get finalRowPosition() {
    return q(this.#h);
  }
  set finalRowPosition(e) {
    be(this.#h, e);
  }
  colsLeftmostPosition = 0;
  #y = /* @__PURE__ */ _e(() => {
    const e = this.renderableCols[this.renderableCols.length - 1];
    return this.colPositions[e] + this.colWidths[e];
  });
  get colsRightmostPosition() {
    return q(this.#y);
  }
  set colsRightmostPosition(e) {
    be(this.#y, e);
  }
  #b = /* @__PURE__ */ _e(() => this.renderableRows.reduce(
    ({ offsets: e, cumulative: n }, r) => {
      e[r] = n;
      const i = this.rowHeightAddition[r] ?? 0;
      return { offsets: e, cumulative: n + i };
    },
    { offsets: {}, cumulative: 0 }
  ));
  get rowPositionOffsets() {
    return q(this.#b);
  }
  set rowPositionOffsets(e) {
    be(this.#b, e);
  }
  #v = /* @__PURE__ */ _e(() => this.renderableRows.reduce(
    (e, n) => {
      const r = (this.data[n][Wi] - 1) * wn.config.rowHeight + this.rowPositionOffsets.offsets[n];
      return e[n] = r, e;
    },
    {}
  ));
  get rowPositions() {
    return q(this.#v);
  }
  set rowPositions(e) {
    be(this.#v, e);
  }
  #x = /* @__PURE__ */ _e(() => {
    let e = 0;
    return this.columns.reduce(
      (n, r, i) => (this.hiddenColumns.has(r) || (n[r] = e, e += this.colWidths[r]), n),
      {}
    );
  });
  get colPositions() {
    return q(this.#x);
  }
  set colPositions(e) {
    be(this.#x, e);
  }
  #g = /* @__PURE__ */ _e(() => this.renderableRows.reduce(
    (e, n) => (e[n] = wn.config.rowHeight + (this.rowHeightAddition[n] ?? 0), e),
    {}
  ));
  get rowHeights() {
    return q(this.#g);
  }
  set rowHeights(e) {
    be(this.#g, e);
  }
  #m = /* @__PURE__ */ _e(() => this.columns.reduce(
    (e, n, r) => (e[n] = Math.max(wn.config.columnConfigs[n]?.width ?? this.defaultColWidths[n] ?? Q3e, wn.config.minColumnWidths[n] ?? 0), this.isFirstCol(n) && (e[n] += wn.config.firstColLeftPadding), this.isLastCol(n) && (e[n] += wn.config.verticalScrollbarWidth), e),
    {}
  ));
  get colWidths() {
    return q(this.#m);
  }
  set colWidths(e) {
    be(this.#m, e);
  }
  getContent({ row: e, col: n }) {
    return this.data[e] ? this.data[e][n] : null;
  }
  getRowData(e) {
    return this.data[e] ? this.data[e] : null;
  }
  getPosition({ row: e, col: n }) {
    const r = this.colPositions[n], i = this.rowPositions[e];
    return { x: r, y: i };
  }
  getDimensions({ row: e, col: n }) {
    const r = this.colWidths[n], i = this.rowHeights[e];
    return { width: r, height: i };
  }
  getRowParity(e) {
    return this.data[e] && this.data[e][Wi] % 2 === 0 ? "even" : "odd";
  }
  isFirstCol(e) {
    return this.renderableCols.indexOf(e) === 0;
  }
  isLastCol(e) {
    return this.renderableCols.indexOf(e) === this.renderableCols.length - 1;
  }
  // Deletes the given row and returns the offset necessary to remove from scroll position.
  deleteRow(e) {
    delete this.data[e];
    const n = this.rowHeightAddition[e] ?? 0;
    return delete this.rowHeightAddition[e], n;
  }
  collapseRow(e) {
    const n = this.rowHeightAddition[e] ?? 0;
    return delete this.rowHeightAddition[e], n;
  }
  reset() {
    this.data = {}, this.rowHeightAddition = {};
  }
  teardown() {
    this.reset();
  }
}
class Z3e extends Nk {
  tableName;
  onResult;
  constructor(e, n, r) {
    super(n ?? void 0), this.tableName = e, this.onResult = r;
  }
  queryResult(e) {
    const n = e.toArray()[0].count;
    return this.onResult(n), this;
  }
  query(e = []) {
    return pd.from(this.tableName).select({ count: CK() }).where(e);
  }
}
const Gi = "__oid";
class e_e extends Nk {
  tableName;
  columns;
  onResult;
  onColumnInfo;
  limit = 20;
  offset = 0;
  sort = null;
  info = null;
  columnInfo = null;
  isReady = !1;
  constructor(e, n, r, i, s) {
    super(r ?? void 0), this.tableName = e, this.columns = n, this.onResult = i, this.onColumnInfo = s;
  }
  async prepare() {
    if (this.coordinator == null)
      return;
    const e = (await bK(this.coordinator, [{ table: this.tableName, column: "*" }])).reduce((n, r) => (n[r.column] = r, n), {});
    this.columnInfo = e, this.onColumnInfo(e), this.isReady = !0;
  }
  getSelect({ includeRowNumber: e } = { includeRowNumber: !0 }) {
    const n = this.columns.reduce((r, i) => (this.columnInfo?.[i]?.sqlType === "BIGINT" ? r[i] = rA(ap(i), "TEXT") : r[i] = ap(i), r), {});
    return e || delete n[Gi], n;
  }
  queryResult(e) {
    return this.onResult(e), this;
  }
  query(e = []) {
    if (!this.isReady)
      return null;
    const n = this.columns.reduce((r, i) => (this.columnInfo?.[i]?.sqlType === "BIGINT" ? r[i] = rA(ap(i), "TEXT") : r[i] = ap(i), r), {});
    if (n[Gi] = _K(), this.sort) {
      const r = this.sort.direction === "ascending" ? this.sort.column : kK(this.sort.column);
      n[Gi] = n[Gi].orderby(r);
    }
    return pd.from(this.tableName).select(n).where(e).limit(this.limit).offset(this.offset);
  }
  fetchRows(e, n) {
    this.offset = e, this.limit = n, this.requestUpdate();
  }
}
class t_e {
  model;
  schema;
  config;
  #e = /* @__PURE__ */ _e(() => Pk.coordinator);
  get coordinator() {
    return q(this.#e);
  }
  set coordinator(e) {
    be(this.#e, e);
  }
  filterBy = null;
  rowsClient = null;
  numRowsClient = null;
  rowKeyColumn = null;
  #t = /* @__PURE__ */ He(null);
  get element() {
    return q(this.#t);
  }
  set element(e) {
    be(this.#t, e, !0);
  }
  #n = /* @__PURE__ */ He(0);
  get viewHeight() {
    return q(this.#n);
  }
  set viewHeight(e) {
    be(this.#n, e, !0);
  }
  #r = /* @__PURE__ */ He(0);
  get viewWidth() {
    return q(this.#r);
  }
  set viewWidth(e) {
    be(this.#r, e, !0);
  }
  #a = /* @__PURE__ */ He(0);
  get yScroll() {
    return q(this.#a);
  }
  set yScroll(e) {
    be(this.#a, e, !0);
  }
  #l = /* @__PURE__ */ He(0);
  get xScroll() {
    return q(this.#l);
  }
  set xScroll(e) {
    be(this.#l, e, !0);
  }
  #i = /* @__PURE__ */ He(!1);
  get isFetching() {
    return q(this.#i);
  }
  set isFetching(e) {
    be(this.#i, e, !0);
  }
  #s = /* @__PURE__ */ He(!1);
  get isJumping() {
    return q(this.#s);
  }
  set isJumping(e) {
    be(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ He(null);
  get sort() {
    return q(this.#o);
  }
  set sort(e) {
    be(this.#o, e, !0);
  }
  #u = /* @__PURE__ */ He(!1);
  get isReady() {
    return q(this.#u);
  }
  set isReady(e) {
    be(this.#u, e, !0);
  }
  #c = /* @__PURE__ */ He(0);
  get updateKey() {
    return q(this.#c);
  }
  set updateKey(e) {
    be(this.#c, e, !0);
  }
  #d = /* @__PURE__ */ He(!1);
  get isStale() {
    return q(this.#d);
  }
  set isStale(e) {
    be(this.#d, e, !0);
  }
  #f = /* @__PURE__ */ He(null);
  get flashedRowId() {
    return q(this.#f);
  }
  set flashedRowId(e) {
    be(this.#f, e, !0);
  }
  #p = /* @__PURE__ */ He(null);
  get hoveredRowId() {
    return q(this.#p);
  }
  set hoveredRowId(e) {
    be(this.#p, e, !0);
  }
  #h = /* @__PURE__ */ _e(() => Math.ceil(this.viewHeight / wn.config.rowHeight));
  get rowsOnScreen() {
    return q(this.#h);
  }
  set rowsOnScreen(e) {
    be(this.#h, e);
  }
  #y = /* @__PURE__ */ _e(() => this.isJumping ? 0 : wn.config.renderWindowOffset);
  get renderWindowOffset() {
    return q(this.#y);
  }
  set renderWindowOffset(e) {
    be(this.#y, e);
  }
  #b = /* @__PURE__ */ _e(() => {
    if (this.model.renderableRows.length === 0)
      return null;
    const e = this.model.renderableRows.filter((r) => {
      const i = this.model.rowPositions[r] + this.yScroll;
      return i + this.model.rowHeights[r] > 0 && i < this.viewHeight;
    });
    if (e.length === 0)
      return null;
    const n = e[0];
    return this.model.data[n][Gi];
  });
  get firstVisibleRowOID() {
    return q(this.#b);
  }
  set firstVisibleRowOID(e) {
    be(this.#b, e);
  }
  #v = /* @__PURE__ */ _e(() => Math.max(0, Math.floor(-this.yScroll / wn.config.rowHeight)));
  get offset() {
    return q(this.#v);
  }
  set offset(e) {
    be(this.#v, e);
  }
  onFetchResolveBegin = null;
  onFetchResolveEnd = null;
  constructor(e, n) {
    this.model = e, this.schema = n, this.config = wn.config;
  }
  handleFilterBy = () => {
    this.rowsClient && (this.rowsClient.offset = 0, this.rowsClient.limit = this.rowsOnScreen, this.isJumping = !0, this.markStale());
  };
  updateData = (e) => {
    if (!this.model || !this.rowKeyColumn)
      return;
    this.onFetchResolveBegin && (this.onFetchResolveBegin(), this.onFetchResolveBegin = null);
    const n = e.toArray(), r = {};
    for (const i of n) {
      const s = i[this.rowKeyColumn];
      r[s] = i;
    }
    this.model.data = { ...this.model.data, ...r }, this.onFetchResolveEnd && (this.onFetchResolveEnd(), this.onFetchResolveEnd = null), this.isFetching = !1;
  };
  initialize({ tableName: e, rowKey: n, columns: r, filterBy: i }) {
    if (this.model.columns = r, this.model.rowKeyColumn = n, this.rowKeyColumn = n, i && (this.filterBy = i, this.filterBy.addEventListener("value", this.handleFilterBy)), !this.rowKeyColumn)
      throw new Error("rowkey cannot be null");
    let s = r.includes(this.rowKeyColumn) ? r : [...r, this.rowKeyColumn];
    this.rowsClient = new e_e(
      e,
      s,
      i,
      (o) => {
        this.updateData(o);
      },
      (o) => {
        this.schema.columnInfo = o, this.computeColWidths(e, r), this.isReady = !0;
      }
    ), this.coordinator.connect(this.rowsClient), this.numRowsClient = new Z3e(e, i, (o) => {
      this.model && (this.model.numRows = o);
    }), this.coordinator.connect(this.numRowsClient), Xn(() => {
      if (!this.rowsClient || this.isFetching || !this.isReady)
        return;
      const o = -this.renderWindowOffset, l = this.viewHeight + this.renderWindowOffset, a = this.model.maxRowPosition + this.yScroll + this.config.rowHeight, u = this.model.minRowPosition + this.yScroll;
      if (u < 0 && a < 0 || u > this.viewHeight && a > this.viewHeight) {
        const y = this.rowsOnScreen;
        this.isFetching = !0, this.rowsClient.fetchRows(this.offset, y);
      } else {
        if (a < l) {
          const b = Mk.clamp(Math.ceil((l - a) / this.config.rowHeight), this.config.minFetchSize, this.rowsOnScreen);
          b > 0 && this.model.maxRowOID !== this.model.numRows && (this.isFetching = !0, this.rowsClient.fetchRows(this.model.maxRowOID, b));
        }
        const y = this.model.minRowPosition + this.yScroll;
        if (y > o && this.model.minRowOID !== 1) {
          const b = Mk.clamp(Math.ceil((y - o) / this.config.rowHeight), this.config.minFetchSize, this.rowsOnScreen);
          b > 0 && (this.isFetching = !0, this.rowsClient.fetchRows(Math.max(0, this.model.minRowOID - 1 - b), b));
        }
      }
      const c = vz(this.model.renderableRows);
      let f = 0;
      for (; this.model.rowPositions[c[f]] + this.yScroll + this.model.rowHeights[c[f]] < 0; )
        this.yScroll += this.model.collapseRow(c[f]), f += 1;
      let d = c.length - 1;
      for (; this.model.rowPositions[c[d]] + this.yScroll > this.viewHeight; )
        this.model.collapseRow(c[d]), d -= 1;
      let p = 0;
      for (; this.model.rowPositions[c[p]] + this.yScroll + this.model.rowHeights[c[p]] < o; )
        this.model.deleteRow(c[p]), p += 1;
      let m = c.length - 1;
      for (; this.model.rowPositions[c[m]] + this.yScroll > l; )
        this.model.deleteRow(c[m]), m -= 1;
    });
  }
  teardown() {
    this.filterBy && this.filterBy.removeEventListener("value", this.handleFilterBy);
  }
  cellIsVisible(e) {
    const { x: n, y: r } = this.model.getPosition(e), { width: i, height: s } = this.model.getDimensions(e), o = n + this.xScroll, l = r + this.yScroll;
    return o + i >= 0 && o <= this.viewWidth && l + s >= 0 && l <= this.viewHeight;
  }
  rowIsVisible(e) {
    const n = this.model.rowPositions[e], r = this.model.rowHeights[e], i = n + this.yScroll;
    return i + r >= 0 && i <= this.viewHeight;
  }
  rowStillExists(e) {
    return this.model.data[e] != null;
  }
  colIsVisible(e) {
    const n = this.model.colPositions[e], r = this.model.colWidths[e], i = n + this.xScroll;
    return i + r >= 0 && i <= this.viewWidth;
  }
  scroll({ deltaX: e, deltaY: n }) {
    if (Math.abs(n) > Math.abs(e)) {
      const r = this.yScroll - n;
      this.model.zeroRowPosition + r > 0 ? this.yScroll = -this.model.zeroRowPosition : this.model.finalRowPosition + r < 0 ? this.yScroll = -this.model.finalRowPosition : this.yScroll = r;
    } else {
      const r = this.xScroll - e;
      -r < 0 ? this.xScroll = 0 : -r > Math.max(this.model.colsRightmostPosition, this.viewWidth) - this.viewWidth ? this.xScroll = -Math.max(this.model.colsRightmostPosition, this.viewWidth) + this.viewWidth : this.xScroll = r;
    }
  }
  handleWheel = (e) => {
    e.preventDefault(), this.isJumping = !1, this.scroll({ deltaX: e.deltaX, deltaY: e.deltaY });
  };
  jumpToOffset(e) {
    if (!this.rowsClient)
      return;
    this.isFetching = !0;
    const n = this.rowsOnScreen, r = this.onFetchResolveEnd;
    this.onFetchResolveEnd = () => {
      r && r(), this.yScroll = -(e * this.config.rowHeight);
    }, this.markStale(), this.rowsClient.fetchRows(e, n);
  }
  handleSort = (e) => {
    this.rowsClient && (this.sort = e, this.rowsClient.sort = e, this.resetRows());
  };
  resetRows() {
    this.model.reset(), this.yScroll = 0;
  }
  flashRow(e) {
    this.flashedRowId = e, setTimeout(
      () => {
        this.flashedRowId = null;
      },
      400
    );
  }
  async scrollToRow(e, n = !0) {
    if (!this.rowsClient)
      return;
    this.isFetching = !0;
    const r = pd.with({
      original: this.rowsClient.query(this.rowsClient.filterBy?.predicate(this.rowsClient)).offset(0).limit(this.model.numRows)
    }).select([Gi]).from("original").where(xK(ap(this.rowKeyColumn), wK(e))), i = (await this.coordinator.query(r)).toArray();
    if (i.length > 0) {
      const s = i[0][Gi] - 1;
      this.onFetchResolveEnd = () => {
        n && this.flashRow(e);
      }, this.jumpToOffset(s);
    } else
      this.isFetching = !1, console.error("no row", e, "found");
  }
  addHeightToRow(e, n) {
    this.model.rowHeightAddition[e] = (this.model.rowHeightAddition[e] ?? 0) + n;
  }
  hideColumn(e) {
    e === Gi ? this.config.onShowRowNumberChange ? this.config.onShowRowNumberChange(!1) : this.config.showRowNumber = !1 : (this.config.columnConfigs[e] || (this.config.columnConfigs[e] = {}), this.config.columnConfigs[e].hidden = !0);
  }
  showColumn(e) {
    e === Gi ? this.config.onShowRowNumberChange ? this.config.onShowRowNumberChange(!0) : this.config.showRowNumber = !0 : (this.config.columnConfigs[e] || (this.config.columnConfigs[e] = {}), this.config.columnConfigs[e].hidden = !1);
  }
  // Marks the current state stale, telling the view to destroy any existing cells on next render.
  markStale() {
    this.isStale = !0;
    const e = this.onFetchResolveBegin;
    this.onFetchResolveBegin = () => {
      e && e(), this.resetRows();
    };
    const n = this.onFetchResolveEnd;
    this.onFetchResolveEnd = () => {
      n && n(), this.updateKey += 1, this.isStale = !1;
    };
  }
  async computeColWidths(e, n) {
    const r = n.filter((a) => a !== Gi), i = this.rowsClient?.getSelect({ includeRowNumber: !1 }), s = r.reduce(
      (a, u) => (a[u] = 0, a),
      {}
    ), o = pd.from(e).select(i).offset(0).limit(10), l = (await this.coordinator.query(o)).toArray();
    for (const a of l)
      for (const u of r)
        s[u] = Math.max(s[u], n_e(a[u]));
    n.includes(Gi) && (s[Gi] = this.config.DEFAULT_ROW_NUMBER_COL_WIDTH), this.model.defaultColWidths = s;
  }
}
function n_e(t) {
  const e = String(t).length;
  return e > 200 ? 600 : e > 100 ? 300 : e > 20 ? 200 : e > 10 ? 150 : 120;
}
class r_e {
  tableController;
  #e = /* @__PURE__ */ _e(() => this.tableController.element);
  get tableElement() {
    return q(this.#e);
  }
  set tableElement(e) {
    be(this.#e, e);
  }
  constructor(e) {
    this.tableController = e;
  }
  mount(e, n, r, i, s) {
    if (!this.tableElement)
      return;
    const o = n.getBoundingClientRect(), l = this.tableElement.getBoundingClientRect(), a = l.top, u = l.left;
    switch (r) {
      case "inside":
        switch (s) {
          case "top":
            e.style.top = o.top - a + "px";
            break;
          case "middle":
          case "bottom":
            throw new Error("not yet implemented" + r + s);
        }
        switch (i) {
          case "left":
            e.style.left = o.left - u + "px";
          case "center":
          case "right":
            throw new Error("not yet implemented" + r + i);
        }
        break;
      case "outside":
        switch (s) {
          case "top":
            e.style.top = o.bottom - a + "px";
            break;
          case "middle":
          case "bottom":
            throw new Error("not yet implemented" + r + s);
        }
        switch (i) {
          case "left":
            e.style.left = o.left - u + "px";
            break;
          case "center":
          case "right":
            throw new Error("not yet implemented" + r + i);
        }
        break;
    }
    this.tableElement.appendChild(e);
  }
  destroy(e) {
    this.tableElement && this.tableElement.contains(e) && this.tableElement.removeChild(e);
  }
}
var X3, WO;
function i_e() {
  if (WO) return X3;
  WO = 1;
  function t(e, n, r) {
    return e === e && (r !== void 0 && (e = e <= r ? e : r), n !== void 0 && (e = e >= n ? e : n)), e;
  }
  return X3 = t, X3;
}
var Q3, GO;
function s_e() {
  if (GO) return Q3;
  GO = 1;
  var t = /\s/;
  function e(n) {
    for (var r = n.length; r-- && t.test(n.charAt(r)); )
      ;
    return r;
  }
  return Q3 = e, Q3;
}
var J3, KO;
function o_e() {
  if (KO) return J3;
  KO = 1;
  var t = s_e(), e = /^\s+/;
  function n(r) {
    return r && r.slice(0, t(r) + 1).replace(e, "");
  }
  return J3 = n, J3;
}
var Z3, YO;
function TC() {
  if (YO) return Z3;
  YO = 1;
  function t(e) {
    var n = typeof e;
    return e != null && (n == "object" || n == "function");
  }
  return Z3 = t, Z3;
}
var e_, XO;
function l_e() {
  if (XO) return e_;
  XO = 1;
  var t = typeof $u == "object" && $u && $u.Object === Object && $u;
  return e_ = t, e_;
}
var t_, QO;
function ij() {
  if (QO) return t_;
  QO = 1;
  var t = l_e(), e = typeof self == "object" && self && self.Object === Object && self, n = t || e || Function("return this")();
  return t_ = n, t_;
}
var n_, JO;
function sj() {
  if (JO) return n_;
  JO = 1;
  var t = ij(), e = t.Symbol;
  return n_ = e, n_;
}
var r_, ZO;
function a_e() {
  if (ZO) return r_;
  ZO = 1;
  var t = sj(), e = Object.prototype, n = e.hasOwnProperty, r = e.toString, i = t ? t.toStringTag : void 0;
  function s(o) {
    var l = n.call(o, i), a = o[i];
    try {
      o[i] = void 0;
      var u = !0;
    } catch {
    }
    var c = r.call(o);
    return u && (l ? o[i] = a : delete o[i]), c;
  }
  return r_ = s, r_;
}
var i_, eF;
function u_e() {
  if (eF) return i_;
  eF = 1;
  var t = Object.prototype, e = t.toString;
  function n(r) {
    return e.call(r);
  }
  return i_ = n, i_;
}
var s_, tF;
function c_e() {
  if (tF) return s_;
  tF = 1;
  var t = sj(), e = a_e(), n = u_e(), r = "[object Null]", i = "[object Undefined]", s = t ? t.toStringTag : void 0;
  function o(l) {
    return l == null ? l === void 0 ? i : r : s && s in Object(l) ? e(l) : n(l);
  }
  return s_ = o, s_;
}
var o_, nF;
function f_e() {
  if (nF) return o_;
  nF = 1;
  function t(e) {
    return e != null && typeof e == "object";
  }
  return o_ = t, o_;
}
var l_, rF;
function h_e() {
  if (rF) return l_;
  rF = 1;
  var t = c_e(), e = f_e(), n = "[object Symbol]";
  function r(i) {
    return typeof i == "symbol" || e(i) && t(i) == n;
  }
  return l_ = r, l_;
}
var a_, iF;
function oj() {
  if (iF) return a_;
  iF = 1;
  var t = o_e(), e = TC(), n = h_e(), r = NaN, i = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, o = /^0o[0-7]+$/i, l = parseInt;
  function a(u) {
    if (typeof u == "number")
      return u;
    if (n(u))
      return r;
    if (e(u)) {
      var c = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(c) ? c + "" : c;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = t(u);
    var f = s.test(u);
    return f || o.test(u) ? l(u.slice(2), f ? 2 : 8) : i.test(u) ? r : +u;
  }
  return a_ = a, a_;
}
var u_, sF;
function d_e() {
  if (sF) return u_;
  sF = 1;
  var t = i_e(), e = oj();
  function n(r, i, s) {
    return s === void 0 && (s = i, i = void 0), s !== void 0 && (s = e(s), s = s === s ? s : 0), i !== void 0 && (i = e(i), i = i === i ? i : 0), t(e(r), i, s);
  }
  return u_ = n, u_;
}
var p_e = d_e();
const g_e = /* @__PURE__ */ FC(p_e);
var c_, oF;
function m_e() {
  if (oF) return c_;
  oF = 1;
  var t = ij(), e = function() {
    return t.Date.now();
  };
  return c_ = e, c_;
}
var f_, lF;
function y_e() {
  if (lF) return f_;
  lF = 1;
  var t = TC(), e = m_e(), n = oj(), r = "Expected a function", i = Math.max, s = Math.min;
  function o(l, a, u) {
    var c, f, d, p, m, y, b = 0, v = !1, _ = !1, k = !0;
    if (typeof l != "function")
      throw new TypeError(r);
    a = n(a) || 0, t(u) && (v = !!u.leading, _ = "maxWait" in u, d = _ ? i(n(u.maxWait) || 0, a) : d, k = "trailing" in u ? !!u.trailing : k);
    function S(M) {
      var L = c, N = f;
      return c = f = void 0, b = M, p = l.apply(N, L), p;
    }
    function C(M) {
      return b = M, m = setTimeout(O, a), v ? S(M) : p;
    }
    function E(M) {
      var L = M - y, N = M - b, j = a - L;
      return _ ? s(j, d - N) : j;
    }
    function A(M) {
      var L = M - y, N = M - b;
      return y === void 0 || L >= a || L < 0 || _ && N >= d;
    }
    function O() {
      var M = e();
      if (A(M))
        return T(M);
      m = setTimeout(O, E(M));
    }
    function T(M) {
      return m = void 0, k && c ? S(M) : (c = f = void 0, p);
    }
    function $() {
      m !== void 0 && clearTimeout(m), b = 0, c = y = f = m = void 0;
    }
    function P() {
      return m === void 0 ? p : T(e());
    }
    function B() {
      var M = e(), L = A(M);
      if (c = arguments, f = this, y = M, L) {
        if (m === void 0)
          return C(y);
        if (_)
          return clearTimeout(m), m = setTimeout(O, a), S(y);
      }
      return m === void 0 && (m = setTimeout(O, a)), p;
    }
    return B.cancel = $, B.flush = P, B;
  }
  return f_ = o, f_;
}
var h_, aF;
function b_e() {
  if (aF) return h_;
  aF = 1;
  var t = y_e(), e = TC(), n = "Expected a function";
  function r(i, s, o) {
    var l = !0, a = !0;
    if (typeof i != "function")
      throw new TypeError(n);
    return e(o) && (l = "leading" in o ? !!o.leading : l, a = "trailing" in o ? !!o.trailing : a), t(i, s, {
      leading: l,
      maxWait: s,
      trailing: a
    });
  }
  return h_ = r, h_;
}
var v_e = b_e();
const uF = /* @__PURE__ */ FC(v_e);
class x_e {
  tableModel;
  tableController;
  isDragging = !1;
  #e = /* @__PURE__ */ He(0);
  get elementHeight() {
    return q(this.#e);
  }
  set elementHeight(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ He(0);
  get labelHeight() {
    return q(this.#t);
  }
  set labelHeight(e) {
    be(this.#t, e, !0);
  }
  #n = /* @__PURE__ */ _e(() => wn.config.verticalScrollbarPillHeight);
  get pillHeight() {
    return q(this.#n);
  }
  set pillHeight(e) {
    be(this.#n, e);
  }
  #r = /* @__PURE__ */ _e(() => this.elementHeight - this.pillHeight);
  get scrollbarHeight() {
    return q(this.#r);
  }
  set scrollbarHeight(e) {
    be(this.#r, e);
  }
  #a = /* @__PURE__ */ _e(() => this.tableController.firstVisibleRowOID ? this.tableController.firstVisibleRowOID : this.tableController.offset + 1);
  get displayRow() {
    return q(this.#a);
  }
  set displayRow(e) {
    be(this.#a, e);
  }
  #l = /* @__PURE__ */ _e(() => (this.displayRow - 1) / (this.tableModel.numRows - 1) * this.scrollbarHeight);
  get pillPosition() {
    return q(this.#l);
  }
  set pillPosition(e) {
    be(this.#l, e);
  }
  #i = /* @__PURE__ */ _e(() => {
    if (this.pillPosition === null)
      return 0;
    const e = this.pillPosition + this.pillHeight / 2 - this.labelHeight / 2;
    if (e < 0)
      return e;
    const n = this.pillPosition + this.pillHeight / 2 + this.labelHeight / 2;
    return n > this.elementHeight ? n - this.elementHeight : 0;
  });
  get labelOffset() {
    return q(this.#i);
  }
  set labelOffset(e) {
    be(this.#i, e);
  }
  constructor({ tableModel: e, tableController: n }) {
    this.tableModel = e, this.tableController = n;
  }
  computeOffsetFromPointer = (e) => {
    this.isDragging = !0;
    let n = Math.round(e.offsetY / this.scrollbarHeight * (this.tableModel.numRows - 1));
    return g_e(n, 0, this.tableModel.numRows - 1);
  };
  pointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0;
    const n = this.computeOffsetFromPointer(e);
    this.tableController.isJumping = !0, this.tableController.jumpToOffset(n);
  };
  handlePointerDown = uF(this.pointerDown, 50);
  pointerMove = (e) => {
    if (this.isDragging) {
      const n = this.computeOffsetFromPointer(e);
      this.tableController.jumpToOffset(n);
    }
  };
  handlePointerMove = uF(this.pointerMove, 50);
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.tableController.isJumping = !1;
  };
}
class w_e {
  #e = /* @__PURE__ */ He(null);
  get columnInfo() {
    return q(this.#e);
  }
  set columnInfo(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ _e(() => this.columnInfo ? Object.keys(this.columnInfo).reduce(
    (e, n) => (e[n] = this.columnInfo[n].type, e),
    {}
  ) : {});
  get dataType() {
    return q(this.#t);
  }
  set dataType(e) {
    be(this.#t, e);
  }
  #n = /* @__PURE__ */ _e(() => this.columnInfo ? Object.keys(this.columnInfo).reduce(
    (e, n) => (e[n] = this.columnInfo[n].sqlType, e),
    {}
  ) : {});
  get sqlType() {
    return q(this.#n);
  }
  set sqlType(e) {
    be(this.#n, e);
  }
}
class __e {
  tableController;
  #e = /* @__PURE__ */ _e(() => Math.floor(-this.tableController.yScroll / wn.config.scrollOverflowValue) * wn.config.scrollOverflowValue);
  get offset() {
    return q(this.#e);
  }
  set offset(e) {
    be(this.#e, e);
  }
  constructor(e) {
    this.tableController = e;
  }
  y(e) {
    return e - this.offset;
  }
  yScroll(e) {
    return e + this.offset;
  }
}
const cF = Symbol("schema"), fF = Symbol("model"), hF = Symbol("controller"), dF = Symbol("vertical-scrollbar-controller"), pF = Symbol("horizontal-scrollbar-controller"), gF = Symbol("table-portal-controller"), mF = Symbol("overscroll-modifier");
class Cn {
  static initialize() {
    const e = new w_e(), n = new J3e(e), r = new t_e(n, e), i = new x_e({ tableModel: n, tableController: r }), s = new X3e({ tableModel: n, tableController: r }), o = new r_e(r), l = new __e(r);
    co(cF, e), co(fF, n), co(hF, r), co(dF, i), co(pF, s), co(gF, o), co(mF, l);
  }
  static get schema() {
    return Xi(cF);
  }
  static get model() {
    return Xi(fF);
  }
  static get controller() {
    return Xi(hF);
  }
  static get verticalScrollbarController() {
    return Xi(dF);
  }
  static get horizontalScrollbarController() {
    return Xi(pF);
  }
  static get tablePortalController() {
    return Xi(gF);
  }
  static get overscrollModifier() {
    return Xi(mF);
  }
}
var k_e = /* @__PURE__ */ an('<div class="horizontal-scrollbar svelte-csucem"><div class="pill svelte-csucem"></div></div>');
const C_e = {
  hash: "svelte-csucem",
  code: ".horizontal-scrollbar.svelte-csucem {position:absolute;bottom:0;left:0;width:100%;height:var(--height);transition:opacity 200ms linear;background-color:var(--scrollbar-bg);}.horizontal-scrollbar.svelte-csucem:hover {opacity:1 !important;}.pill.svelte-csucem {width:var(--width);height:calc(var(--height) - var(--margin) * 2);margin:var(--margin);border-radius:2px;background-color:var(--scrollbar-pill-bg);}"
};
function S_e(t, e) {
  sr(e, !0), lr(t, C_e);
  const n = Cn.horizontalScrollbarController, r = Cn.controller, i = wn.config;
  let s = /* @__PURE__ */ He(0), o = /* @__PURE__ */ He(null), l = /* @__PURE__ */ He(null), a = 0;
  k0(() => (a = requestAnimationFrame(f), () => {
    cancelAnimationFrame(a);
  }));
  function u() {
    q(o) && (q(o).style.opacity = "0");
  }
  const c = rj.debounce(u, 1e3);
  Xn(() => {
    q(o) && (r.xScroll, q(o).style.opacity = "1", c());
  });
  function f() {
    be(s, n.pillWidth, !0), q(l) && (q(l).style.transform = `translate(${n.pillLeft}px, 0)`), a = requestAnimationFrame(f);
  }
  var d = k_e();
  let p;
  var m = bn(d);
  m.__pointerdown = function(...b) {
    n.handlePointerDown?.apply(this, b);
  }, m.__pointermove = function(...b) {
    n.handlePointerMove?.apply(this, b);
  }, m.__pointerup = function(...b) {
    n.handlePointerUp?.apply(this, b);
  };
  let y;
  $i(m, (b) => be(l, b), () => q(l)), dn(d), $i(d, (b) => be(o, b), () => q(o)), pr(() => {
    p = gs(d, "", p, { "--height": i.horizontalScrollbarHeight + "px" }), y = gs(m, "", y, {
      "--width": q(s) + "px",
      "--margin": n.margin + "px"
    });
  }), nl(d, "clientWidth", (b) => n.elementWidth = b), Rt(t, d), or();
}
pu(["pointerdown", "pointermove", "pointerup"]);
var A_e = /* @__PURE__ */ an('<div class="vertical-scrollbar svelte-d1fz7o"><div class="pill svelte-d1fz7o"><div class="label svelte-d1fz7o"> </div></div></div>');
const E_e = {
  hash: "svelte-d1fz7o",
  code: ".vertical-scrollbar.svelte-d1fz7o {position:absolute;right:0;top:0;width:var(--width);height:calc(100% - var(--offset-bottom));contain:layout;cursor:row-resize;transition:opacity 200ms linear;user-select:none;background-color:var(--scrollbar-bg);}.vertical-scrollbar.svelte-d1fz7o:hover {opacity:1 !important;}.pill.svelte-d1fz7o {--pill-height: 4px;position:relative;pointer-events:none; /* let the container respond to pointer events */top:0;left:0;width:calc(var(--width) - 2px);margin-left:1px;margin-right:1px;height:var(--pill-height);border-radius:2px;will-change:transform;background-color:var(--scrollbar-pill-bg);}.label.svelte-d1fz7o {--offset: 0;position:absolute;pointer-events:none;top:0;left:-4px;font-family:var(--font-family);font-size:14px;white-space:nowrap;padding:2px 4px;box-shadow:var(--shadow);transform:translate(-100%, calc(-50% + var(--pill-height) / 2 - var(--offset)));border-radius:2px;color:var(--secondary-text-color);background-color:var(--scrollbar-label-bg);border:var(--outline);}"
};
function D_e(t, e) {
  sr(e, !0), lr(t, E_e);
  const n = Cn.verticalScrollbarController, r = Cn.controller, i = wn.config;
  let s = /* @__PURE__ */ He(0), o = /* @__PURE__ */ He(0), l = /* @__PURE__ */ He(null), a = /* @__PURE__ */ He(null), u = /* @__PURE__ */ He(null), c = /* @__PURE__ */ _e(() => new Intl.NumberFormat().format(q(o))), f = 0;
  k0(() => (f = requestAnimationFrame(m), () => {
    cancelAnimationFrame(f);
  }));
  function d() {
    q(l) && (q(l).style.opacity = "0");
  }
  const p = rj.debounce(d, 1e3);
  Xn(() => {
    q(l) && (r.yScroll, q(l).style.opacity = "1", p());
  });
  function m() {
    be(s, n.pillPosition ?? q(s), !0), be(o, n.displayRow ?? q(o), !0), q(a) && (q(a).style.transform = `translate3d(0, ${q(s)}px, 0)`), q(u) && q(u).style.setProperty("--offset", n.labelOffset - 1 + "px"), f = requestAnimationFrame(m);
  }
  var y = A_e();
  y.__pointerdown = function(...C) {
    n.handlePointerDown?.apply(this, C);
  }, y.__pointermove = function(...C) {
    n.handlePointerMove?.apply(this, C);
  }, y.__pointerup = function(...C) {
    n.handlePointerUp?.apply(this, C);
  };
  let b;
  var v = bn(y);
  let _;
  var k = bn(v), S = bn(k, !0);
  dn(k), $i(k, (C) => be(u, C), () => q(u)), dn(v), $i(v, (C) => be(a, C), () => q(a)), dn(y), $i(y, (C) => be(l, C), () => q(l)), pr(() => {
    b = gs(y, "", b, {
      "--offset-bottom": i.horizontalScrollbarHeight + "px",
      "--width": i.verticalScrollbarWidth + "px"
    }), _ = gs(v, "", _, {
      "--pill-height": n.pillHeight + "px"
    }), da(S, q(c));
  }), nl(k, "clientHeight", (C) => n.labelHeight = C), nl(y, "clientHeight", (C) => n.elementHeight = C), Rt(t, y), or();
}
pu(["pointerdown", "pointermove", "pointerup"]);
var O_e = /* @__PURE__ */ an('<div class="bigint-content svelte-1x1osq0"> </div>');
const F_e = {
  hash: "svelte-1x1osq0",
  code: ".bigint-content.svelte-1x1osq0 {text-align:right;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function T_e(t, e) {
  sr(e, !0), lr(t, F_e);
  let n = C0(e, "height");
  function r(o) {
    return o === null ? null : o.toLocaleString();
  }
  var i = O_e(), s = bn(i, !0);
  dn(i), pr((o) => da(s, o), [() => r(e.bigint)]), nl(i, "clientHeight", n), Rt(t, i), or();
}
var R_e = /* @__PURE__ */ an("<div></div>");
const M_e = { hash: "svelte-ubqfz9", code: "" };
function P_e(t, e) {
  sr(e, !0), lr(t, M_e);
  let n = C0(e, "height");
  const r = Cn.model, i = (u) => typeof u == "function" ? (c, f) => {
    let d = new u(c, f);
    return {
      ...d.update ? { update: d.update.bind(d) } : {},
      ...d.destroy ? { destroy: d.destroy.bind(d) } : {}
    };
  } : (c, f) => {
    let d = new u.class(c, f);
    return {
      ...d.update ? { update: d.update.bind(d) } : {},
      ...d.destroy ? { destroy: d.destroy.bind(d) } : {}
    };
  };
  let s = /* @__PURE__ */ _e(() => i(e.customCell)), o = /* @__PURE__ */ _e(() => r.getContent({ row: e.row, col: e.col })), l = /* @__PURE__ */ _e(() => r.getRowData(e.row));
  var a = R_e();
  DC(a, (u, c) => q(s)?.(u, c), () => ({ value: q(o), rowData: q(l) })), Am(() => nl(a, "clientHeight", n)), Rt(t, a), or();
}
var I_e = /* @__PURE__ */ an('<img alt=""/>');
function N_e(t, e) {
  sr(e, !0);
  let n = C0(e, "height");
  wn.config;
  let r = /* @__PURE__ */ He(null);
  function i(c) {
    let f = "";
    for (let d = 0; d < c.length; d++)
      f += String.fromCharCode(c[d]);
    return btoa(f);
  }
  function s(c) {
    const f = atob(c);
    return new Uint8Array([...f].map((d) => d.charCodeAt(0)));
  }
  function o(c, f) {
    if (c.length < f.length)
      return !1;
    for (let d = 0; d < f.length; d++)
      if (c[d] != f[d])
        return !1;
    return !0;
  }
  function l(c) {
    return o(c, [137, 80, 78, 71, 13, 10, 26, 10]) ? "image/png" : o(c, [255, 216, 255]) ? "image/jpeg" : o(c, [73, 73, 42, 0]) ? "image/tiff" : o(c, [66, 77]) ? "image/bmp" : o(c, [71, 73, 70, 56, 55, 97]) || o(c, [71, 73, 70, 56, 55, 97]) ? "image/gif" : "application/octet-stream";
  }
  function a(c) {
    if (c == null)
      return null;
    if (typeof c == "string")
      return c.startsWith("data:") ? c : `data:${l(s(c))};base64,` + c;
    {
      let f = null;
      if (c.bytes && c.bytes instanceof Uint8Array && (f = c.bytes), c instanceof Uint8Array && (f = c), f != null)
        return `data:${l(f)};base64,` + i(f);
    }
    return null;
  }
  var u = I_e();
  $i(u, (c) => be(r, c), () => q(r)), pr((c) => Hg(u, "src", c), [() => a(e.image)]), Vd("load", u, () => {
    q(r) && n(q(r).scrollHeight);
  }), w3e(u), Rt(t, u), or();
}
var B_e = /* @__PURE__ */ an('<a target="_blank"> </a>'), L_e = /* @__PURE__ */ an('<div class="link-content"><!></div>');
const $_e = { hash: "svelte-1wimtwv", code: "" };
function z_e(t, e) {
  sr(e, !0), lr(t, $_e);
  let n = C0(e, "height");
  var r = L_e(), i = bn(r);
  {
    var s = (o) => {
      var l = B_e(), a = bn(l, !0);
      dn(l), pr(() => {
        Hg(l, "href", e.url), da(a, e.url);
      }), Rt(o, l);
    };
    Qi(i, (o) => {
      e.url && o(s);
    });
  }
  dn(r), nl(r, "clientHeight", n), Rt(t, r), or();
}
var j_e = /* @__PURE__ */ an('<div class="number-content svelte-1xfvszy"> </div>');
const q_e = {
  hash: "svelte-1xfvszy",
  code: ".number-content.svelte-1xfvszy {text-align:right;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function U_e(t, e) {
  sr(e, !0), lr(t, q_e);
  let n = C0(e, "height");
  function r(o) {
    return o === null ? null : Number.isInteger(o) ? o.toString() : o.toPrecision(4).toString();
  }
  var i = j_e(), s = bn(i, !0);
  dn(i), pr((o) => da(s, o), [() => r(e.number)]), nl(i, "clientHeight", n), Rt(t, i), or();
}
var H_e = /* @__PURE__ */ an("<div> </div>");
const V_e = {
  hash: "svelte-1ngffx0",
  code: ".clamped.svelte-1ngffx0 {display:-webkit-box;-webkit-box-orient:vertical;line-clamp:var(--lines, var(--num-lines)); /* fallback to numlines from parent */-webkit-line-clamp:var(--lines, var(--num-lines));overflow:hidden;text-overflow:ellipsis;}"
};
function yF(t, e) {
  sr(e, !0), lr(t, V_e);
  let n = C0(e, "height");
  const r = wn.config;
  let i = /* @__PURE__ */ He(null), s = /* @__PURE__ */ He(null);
  Xn(() => {
    q(i) && (n(q(i).scrollHeight), be(s, Math.floor(e.parentHeight / r.lineHeight), !0));
  });
  var o = H_e();
  let l;
  var a = bn(o, !0);
  dn(o), $i(o, (u) => be(i, u), () => q(i)), pr(() => {
    hc(o, 1, `text-content ${(e.clamped ? "clamped" : null) ?? ""}`, "svelte-1ngffx0"), l = gs(o, "", l, { "--lines": q(s) }), da(a, e.text);
  }), Rt(t, o), or();
}
class W_e {
  #e = /* @__PURE__ */ He(ai({}));
  get config() {
    return q(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const d_ = Symbol("custom-cells");
class nb {
  static initialize() {
    co(d_, new W_e());
  }
  static set config(e) {
    const n = Xi(d_);
    n.config = e;
  }
  static get config() {
    return Xi(d_).config;
  }
}
var G_e = /* @__PURE__ */ an("<button>â†˜</button>"), K_e = /* @__PURE__ */ an('<div class="cell-content clamp svelte-8bpcsh"><!> <!></div>');
const Y_e = {
  hash: "svelte-8bpcsh",
  code: ".cell-content.svelte-8bpcsh {position:relative;flex-grow:1;line-height:var(--lineHeight);overflow-wrap:anywhere;overflow:hidden;}.expand-button.svelte-8bpcsh {all:unset;visibility:hidden;position:absolute;bottom:0;right:0;cursor:pointer;font-size:12px;line-height:18px;padding-left:4px;padding-right:4px;border-radius:2px;color:var(--secondary-text-color);background-color:var(--background-color);border:var(--outline);}.expand-button.show.svelte-8bpcsh {visibility:visible;}"
};
function X_e(t, e) {
  sr(e, !0), lr(t, Y_e);
  const n = Cn.model, r = Cn.controller, i = Cn.schema, s = wn.config;
  let o = /* @__PURE__ */ _e(() => nb.config), l = /* @__PURE__ */ He(0), a = /* @__PURE__ */ He(0), u = /* @__PURE__ */ _e(() => q(a) > q(l));
  const c = n.getContent({ row: e.row, col: e.col }), f = i.dataType[e.col] ?? "string", d = i.sqlType[e.col] ?? "TEXT";
  function p(E) {
    return typeof E == "string" && (E.startsWith("http://") || E.startsWith("https://"));
  }
  function m(E) {
    return E == null ? !1 : !!(typeof E == "string" && E.startsWith("data:image/") || E.bytes && E.bytes instanceof Uint8Array);
  }
  var y = K_e();
  let b;
  var v = bn(y);
  {
    var _ = (E) => {
      P_e(E, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        },
        get customCell() {
          return q(o)[e.col];
        },
        get height() {
          return q(a);
        },
        set height(A) {
          be(a, A, !0);
        }
      });
    }, k = (E) => {
      var A = zc(), O = Ls(A);
      {
        var T = (P) => {
          var B = zc(), M = Ls(B);
          {
            var L = (j) => {
              z_e(j, {
                get url() {
                  return c;
                },
                get height() {
                  return q(a);
                },
                set height(U) {
                  be(a, U, !0);
                }
              });
            }, N = (j) => {
              yF(j, {
                get text() {
                  return c;
                },
                get clamped() {
                  return q(u);
                },
                get parentHeight() {
                  return q(l);
                },
                get height() {
                  return q(a);
                },
                set height(U) {
                  be(a, U, !0);
                }
              });
            };
            Qi(M, (j) => {
              c && p(c) ? j(L) : j(N, !1);
            });
          }
          Rt(P, B);
        }, $ = (P) => {
          var B = zc(), M = Ls(B);
          {
            var L = (j) => {
              var U = zc(), H = Ls(U);
              {
                var G = (se) => {
                  {
                    let oe = /* @__PURE__ */ _e(() => BigInt(c ?? ""));
                    T_e(se, {
                      get bigint() {
                        return q(oe);
                      },
                      get height() {
                        return q(a);
                      },
                      set height(ne) {
                        be(a, ne, !0);
                      }
                    });
                  }
                }, re = (se) => {
                  U_e(se, {
                    get number() {
                      return c;
                    },
                    get height() {
                      return q(a);
                    },
                    set height(oe) {
                      be(a, oe, !0);
                    }
                  });
                };
                Qi(H, (se) => {
                  d === "BIGINT" ? se(G) : se(re, !1);
                });
              }
              Rt(j, U);
            }, N = (j) => {
              var U = zc(), H = Ls(U);
              {
                var G = (se) => {
                  N_e(se, {
                    get image() {
                      return c;
                    },
                    get height() {
                      return q(a);
                    },
                    set height(oe) {
                      be(a, oe, !0);
                    }
                  });
                }, re = (se) => {
                  yF(se, {
                    get text() {
                      return c;
                    },
                    get clamped() {
                      return q(u);
                    },
                    get parentHeight() {
                      return q(l);
                    },
                    get height() {
                      return q(a);
                    },
                    set height(oe) {
                      be(a, oe, !0);
                    }
                  });
                };
                Qi(
                  H,
                  (se) => {
                    m(c) ? se(G) : se(re, !1);
                  },
                  !0
                );
              }
              Rt(j, U);
            };
            Qi(
              M,
              (j) => {
                f === "number" ? j(L) : j(N, !1);
              },
              !0
            );
          }
          Rt(P, B);
        };
        Qi(
          O,
          (P) => {
            f === "string" ? P(T) : P($, !1);
          },
          !0
        );
      }
      Rt(E, A);
    };
    Qi(v, (E) => {
      q(o)[e.col] ? E(_) : E(k, !1);
    });
  }
  var S = mo(v, 2);
  {
    var C = (E) => {
      var A = G_e();
      A.__click = () => {
        r.addHeightToRow(e.row, q(a) - q(l));
      }, pr(() => hc(A, 1, `expand-button ${e.hovered ? "show" : "hide"}`, "svelte-8bpcsh")), Rt(E, A);
    };
    Qi(S, (E) => {
      q(u) && E(C);
    });
  }
  dn(y), pr(() => b = gs(y, "", b, {
    "--lineHeight": s.lineHeight + "px",
    "--num-lines": s.textMaxLines
  })), nl(y, "clientHeight", (E) => be(l, E)), Rt(t, y), or();
}
pu(["click"]);
var Q_e = /* @__PURE__ */ an('<div class="row-number svelte-1e2x749"> </div>');
const J_e = {
  hash: "svelte-1e2x749",
  code: ".row-number.svelte-1e2x749 {flex-grow:1;text-align:right;color:var(--secondary-text-color);text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}"
};
function Z_e(t, e) {
  sr(e, !0), lr(t, J_e);
  const n = Cn.model.getContent({ row: e.row, col: e.col }), r = /* @__PURE__ */ _e(() => new Intl.NumberFormat().format(n ?? 0));
  var i = Q_e(), s = bn(i, !0);
  dn(i), pr(() => da(s, q(r))), Rt(t, i), or();
}
var e4e = /* @__PURE__ */ an('<div class="cell svelte-16dgxhm"><!></div>');
const t4e = {
  hash: "svelte-16dgxhm",
  code: ".cell.svelte-16dgxhm {--x: 0px;--y: 0px;--width: 0px;--height: 0px;display:flex;box-sizing:border-box;padding-top:calc(var(--padding-y) / 2);padding-bottom:calc(var(--padding-y) / 2);padding-right:calc(calc(var(--padding-x) / 2) + var(--extra-right-padding));padding-left:calc(calc(var(--padding-x) / 2) + var(--extra-left-padding));position:absolute;left:0;top:0;width:var(--width);height:var(--height);transform:translate(var(--x), var(--y));contain:layout paint;color:var(--primary-text-color);font-family:var(--cell-font-family);font-size:var(--cell-font-size);}"
};
function n4e(t, e) {
  sr(e, !0), lr(t, t4e);
  const n = Cn.model, r = Cn.controller, i = Cn.overscrollModifier, s = wn.config;
  let o = /* @__PURE__ */ _e(() => n.getPosition({ row: e.row, col: e.col })), l = /* @__PURE__ */ _e(() => q(o).x), a = /* @__PURE__ */ _e(() => q(o).y), u = /* @__PURE__ */ _e(() => i.y(q(a))), c = /* @__PURE__ */ _e(() => n.getDimensions({ row: e.row, col: e.col })), f = /* @__PURE__ */ _e(() => q(c).width), d = /* @__PURE__ */ _e(() => q(c).height), p = /* @__PURE__ */ _e(() => n.isFirstCol(e.col)), m = /* @__PURE__ */ _e(() => n.isLastCol(e.col)), y = /* @__PURE__ */ _e(() => n.getRowParity(e.row) === "even" ? "var(--primary-bg)" : "var(--secondary-bg)"), b = () => {
    s.onRowClick && s.onRowClick(e.row);
  }, v = /* @__PURE__ */ He(!1);
  var _ = e4e();
  _.__click = b, _.__keydown = (A) => {
    A.key === "Enter" && b();
  };
  let k;
  var S = bn(_);
  {
    var C = (A) => {
      X_e(A, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        },
        get hovered() {
          return q(v);
        }
      });
    }, E = (A) => {
      Z_e(A, {
        get row() {
          return e.row;
        },
        get col() {
          return e.col;
        }
      });
    };
    Qi(S, (A) => {
      e.col !== Wi ? A(C) : A(E, !1);
    });
  }
  dn(_), pr(() => k = gs(_, "", k, {
    "--x": q(l) + "px",
    "--y": q(u) + "px",
    "--width": q(f) + "px",
    "--height": q(d) + "px",
    "--padding-x": s.betweenColPadding + "px",
    "--padding-y": s.betweenRowPadding + "px",
    "--extra-right-padding": (q(m) ? s.verticalScrollbarWidth : 0) + "px",
    "--extra-left-padding": (q(p) ? s.firstColLeftPadding : 0) + "px",
    "--background-color": q(y)
  })), Vd("pointerenter", _, () => {
    be(v, !0), r.hoveredRowId = e.row;
  }), Vd("pointerleave", _, () => {
    be(v, !1), r.hoveredRowId = null;
  }), Rt(t, _), or();
}
pu(["click", "keydown"]);
var r4e = /* @__PURE__ */ an('<div class="header-title svelte-1si5830"> </div>');
const i4e = {
  hash: "svelte-1si5830",
  code: ".header-title.svelte-1si5830 {flex-shrink:1;margin-right:2px;}"
};
function s4e(t, e) {
  sr(e, !0), lr(t, i4e);
  const n = wn.config;
  var r = r4e(), i = bn(r, !0);
  dn(r), pr(() => da(i, n.columnConfigs[e.col]?.title ?? e.col)), Rt(t, r), or();
}
jwe();
var o4e = /* @__PURE__ */ an('<div class="row-number-header svelte-v1uha2">#</div>');
const l4e = {
  hash: "svelte-v1uha2",
  code: ".row-number-header.svelte-v1uha2 {flex-grow:1;text-align:right;margin-right:4px;box-sizing:border-box;color:var(--secondary-text-color);}"
};
function a4e(t) {
  lr(t, l4e);
  var e = o4e();
  Rt(t, e);
}
var u4e = /* @__PURE__ */ an('<button class="sort-buttons svelte-mgubjs"><div> </div></button>');
const c4e = {
  hash: "svelte-mgubjs",
  code: ".sort-buttons.svelte-mgubjs {all:unset;flex-shrink:0;width:16px;cursor:pointer;display:flex;justify-content:center;flex-direction:row;margin-left:4px;border-radius:2px;padding-left:4px;padding-right:4px;color:var(--tertiary-text-color);}.sort-buttons.svelte-mgubjs:hover {--placeholder: 0;background-color:var(--hover-bg);}.sort-glyph.svelte-mgubjs {color:var(--tertiary-text-color);}.sort-buttons.svelte-mgubjs:hover .sort-glyph:where(.svelte-mgubjs) {color:var(--tertiary-text-color);}.selected.svelte-mgubjs {color:var(--primary-text-color) !important;}"
};
function f4e(t, e) {
  sr(e, !0), lr(t, c4e);
  const n = Cn.controller;
  let r = /* @__PURE__ */ _e(() => n.sort ? n.sort.column === e.col : !1), i = /* @__PURE__ */ _e(() => n.sort ? n.sort.direction : null), s = /* @__PURE__ */ _e(() => q(r) ? q(i) === "ascending" ? "â†‘" : "â†“" : "â‡…");
  var o = u4e();
  o.__click = () => {
    const u = q(r) ? q(i) === "ascending" ? "descending" : null : "ascending";
    u ? n.handleSort({ column: e.col, direction: u }) : n.handleSort(null);
  };
  var l = bn(o), a = bn(l, !0);
  dn(l), dn(o), pr(() => {
    hc(l, 1, `sort-button ${(q(r) ? "selected" : null) ?? ""} sort-glyph`, "svelte-mgubjs"), da(a, q(s));
  }), Rt(t, o), or();
}
pu(["click"]);
class h4e {
  #e = /* @__PURE__ */ He(ai({}));
  get config() {
    return q(this.#e);
  }
  set config(e) {
    be(this.#e, e, !0);
  }
}
const p_ = Symbol("custom-headers");
class rb {
  static initialize() {
    co(p_, new h4e());
  }
  static set config(e) {
    const n = Xi(p_);
    n.config = e;
  }
  static get config() {
    return Xi(p_).config;
  }
}
var d4e = /* @__PURE__ */ an("<div></div>");
const p4e = { hash: "svelte-v680az", code: "" };
function g4e(t, e) {
  sr(e, !0), lr(t, p4e), Cn.model;
  const n = (s) => typeof s == "function" ? (o, l) => {
    let a = new s(o, l);
    return {
      ...a.update ? { update: a.update.bind(a) } : {},
      ...a.destroy ? { destroy: a.destroy.bind(a) } : {}
    };
  } : (o, l) => {
    let a = new s.class(o, l);
    return {
      ...a.update ? { update: a.update.bind(a) } : {},
      ...a.destroy ? { destroy: a.destroy.bind(a) } : {}
    };
  };
  let r = /* @__PURE__ */ _e(() => n(e.customHeader));
  var i = d4e();
  DC(i, (s, o) => q(r)?.(s, o), () => ({ column: e.col })), Rt(t, i), or();
}
var m4e = /* @__PURE__ */ an("<!> <!>", 1), y4e = /* @__PURE__ */ an('<div><div class="header-content svelte-1vl6s3u"><!> <div class="header-title svelte-1vl6s3u"><!></div></div></div>');
const b4e = {
  hash: "svelte-1vl6s3u",
  code: ".header-cell.svelte-1vl6s3u {position:relative;display:flex;flex-direction:row;align-items:end;width:var(--width);min-height:var(--height);flex-shrink:0;box-sizing:border-box;padding:0.25em;padding-right:calc(calc(var(--padding-x) / 2) + var(--extra-padding-right));padding-left:calc(calc(var(--padding-x) / 2) + var(--extra-padding-left));color:var(--secondary-text-color);font-family:var(--header-font-family);font-size:var(--header-font-size);}.header-cell.number.svelte-1vl6s3u {justify-content:end;}.header-content.svelte-1vl6s3u {display:flex;flex-direction:column;flex-shrink:0;}.header-title.svelte-1vl6s3u {height:1.5em;align-items:center;display:flex;flex-direction:row;flex-shrink:0;}"
};
function v4e(t, e) {
  sr(e, !0), lr(t, b4e);
  const n = Cn.model, r = Cn.schema, i = wn.config;
  let s = /* @__PURE__ */ _e(() => rb.config), o = /* @__PURE__ */ He(null), l = /* @__PURE__ */ He(0);
  Xn(() => {
    i.minColumnWidths[e.col] = q(l) + i.betweenColPadding;
  });
  const a = /* @__PURE__ */ _e(() => n.colWidths[e.col]), u = /* @__PURE__ */ _e(() => (r.dataType[e.col] ?? "string") === "number"), c = /* @__PURE__ */ _e(() => q(u) || e.col === Wi ? "number" : ""), f = /* @__PURE__ */ _e(() => n.isFirstCol(e.col)), d = /* @__PURE__ */ _e(() => n.isLastCol(e.col));
  let p = /* @__PURE__ */ _e(() => i.headerHeight ? i.headerHeight + "px" : "auto");
  var m = y4e();
  let y;
  var b = bn(m), v = bn(b);
  {
    var _ = (A) => {
      g4e(A, {
        get col() {
          return e.col;
        },
        get customHeader() {
          return q(s)[e.col];
        }
      });
    };
    Qi(v, (A) => {
      q(s)[e.col] && A(_);
    });
  }
  var k = mo(v, 2), S = bn(k);
  {
    var C = (A) => {
      var O = m4e(), T = Ls(O);
      s4e(T, {
        get col() {
          return e.col;
        }
      });
      var $ = mo(T, 2);
      f4e($, {
        get col() {
          return e.col;
        }
      }), Rt(A, O);
    }, E = (A) => {
      a4e(A);
    };
    Qi(S, (A) => {
      e.col !== Wi ? A(C) : A(E, !1);
    });
  }
  dn(k), dn(b), dn(m), $i(m, (A) => be(o, A), () => q(o)), pr(() => {
    hc(m, 1, `header-cell ${q(c) ?? ""}`, "svelte-1vl6s3u"), y = gs(m, "", y, {
      "--width": q(a) + "px",
      "--height": q(p),
      "--padding-x": i.betweenColPadding + "px",
      "--extra-padding-right": (q(d) ? i.verticalScrollbarWidth : 0) + "px",
      "--extra-padding-left": (q(f) ? i.firstColLeftPadding : 0) + "px"
    });
  }), nl(b, "clientWidth", (A) => be(l, A)), Rt(t, m), or();
}
class x4e {
  tableModel;
  tableController;
  col;
  config;
  isDragging = !1;
  startDragX = 0;
  constructor({ tableModel: e, tableController: n, col: r }) {
    this.tableModel = e, this.tableController = n, this.col = r, this.config = wn.config;
  }
  handlePointerDown = (e) => {
    e.preventDefault(), e.target.setPointerCapture(e.pointerId), this.isDragging = !0, this.startDragX = e.offsetX;
  };
  handlePointerMove = (e) => {
    if (this.isDragging && this.startDragX !== null) {
      const n = e.offsetX - this.startDragX, r = this.tableModel.colWidths[this.col], i = Math.max(0, Math.round(r + n));
      this.config.columnConfigs[this.col] || (this.config.columnConfigs[this.col] = {}), this.config.columnConfigs[this.col].width = i, this.config.onColumnConfigsChange(this.col, vz(this.config.columnConfigs));
    }
  };
  handlePointerUp = (e) => {
    e.target.releasePointerCapture(e.pointerId), this.isDragging = !1, this.startDragX = null;
  };
}
var w4e = /* @__PURE__ */ an('<div class="header-resize-indicator svelte-1y4d3p9"><div class="pill svelte-1y4d3p9"></div></div>');
const _4e = {
  hash: "svelte-1y4d3p9",
  code: ".header-resize-indicator.svelte-1y4d3p9 {position:absolute;z-index:2;box-sizing:border-box;width:12px;height:calc(100% - 0.25rem);margin:2px;cursor:col-resize;justify-content:center;display:flex;align-items:center;justify-content:center;transform:translateX(calc(var(--x) - 4px - 50%));}.pill.svelte-1y4d3p9 {width:2px;height:calc(100% - 4px);margin-top:2px;margin-bottom:2px;background-color:var(--secondary-text-color);opacity:0.2;border-radius:2px;}"
};
function k4e(t, e) {
  sr(e, !0), lr(t, _4e);
  const n = Cn.model;
  let r = new x4e({
    tableModel: n,
    tableController: Cn.controller,
    col: e.col
  });
  const i = /* @__PURE__ */ _e(() => n.colPositions[e.col] + n.colWidths[e.col]);
  var s = w4e();
  s.__pointerdown = function(...l) {
    r.handlePointerDown?.apply(this, l);
  }, s.__pointermove = function(...l) {
    r.handlePointerMove?.apply(this, l);
  }, s.__pointerup = function(...l) {
    r.handlePointerUp?.apply(this, l);
  };
  let o;
  pr(() => o = gs(s, "", o, { "--x": q(i) + "px" })), Rt(t, s), or();
}
pu(["pointerdown", "pointermove", "pointerup"]);
var C4e = /* @__PURE__ */ an('<div class="table-portal svelte-i8g41o" tabindex="-1"><!></div>');
const S4e = {
  hash: "svelte-i8g41o",
  code: ".table-portal.svelte-i8g41o {position:absolute;}"
};
function A4e(t, e) {
  sr(e, !0), lr(t, S4e);
  const n = Cn.controller, r = Cn.tablePortalController;
  let i = /* @__PURE__ */ He(null);
  const s = (c) => {
    Xn(() => (r.mount(c, e.relativeTo, e.anchor, e.horizontalAlign, e.verticalAlign), c.focus(), () => {
      r.destroy(c);
    }));
  };
  let o = 0;
  k0(() => {
    o = n.xScroll, requestAnimationFrame(l);
  });
  function l() {
    q(i) && e.stickyX && (q(i).style.transform = `translateX(${n.xScroll - o}px)`), requestAnimationFrame(l);
  }
  var a = C4e();
  a.__click = (c) => {
    c.stopPropagation();
  };
  var u = bn(a);
  EC(u, () => e.children), dn(a), $i(a, (c) => be(i, c), () => q(i)), DC(a, (c) => s?.(c)), Vd("wheel", a, (c) => {
    c.stopPropagation();
  }), Rt(t, a), or();
}
pu(["click"]);
var E4e = /* @__PURE__ */ an("<button> </button> <!>", 1);
const D4e = {
  hash: "svelte-3t0u29",
  code: '.dropdown.svelte-3t0u29 {all:unset;padding-left:8px;padding-right:8px;border-radius:2px;cursor:pointer;color:var(--secondary-text-color);position:relative;user-select:none;}.dropdown.svelte-3t0u29::before {content:"";position:absolute;top:0;left:0;height:100%;width:100%;background-color:var(--primary-bg);z-index:-1;}.dropdown.svelte-3t0u29:hover {background-color:var(--hover-bg);}.unclickable.svelte-3t0u29 {pointer-events:none;}'
};
function O4e(t, e) {
  lr(t, D4e);
  let n = /* @__PURE__ */ He(!1), r = /* @__PURE__ */ He(null), i = /* @__PURE__ */ He(null);
  var s = E4e();
  Vd("click", Ak, (c) => {
    q(n) && c.target !== q(r) && be(n, !1);
  });
  var o = Ls(s);
  o.__click = (c) => {
    be(n, !0);
  };
  var l = bn(o, !0);
  dn(o), $i(o, (c) => be(r, c), () => q(r));
  var a = mo(o, 2);
  {
    var u = (c) => {
      A4e(c, {
        get relativeTo() {
          return e.relativeTo;
        },
        anchor: "outside",
        horizontalAlign: "left",
        verticalAlign: "top",
        stickyX: !1,
        get element() {
          return q(i);
        },
        set element(f) {
          be(i, f, !0);
        },
        children: (f, d) => {
          var p = zc(), m = Ls(p);
          EC(m, () => e.children), Rt(f, p);
        },
        $$slots: { default: !0 }
      });
    };
    Qi(a, (c) => {
      q(n) && c(u);
    });
  }
  pr(() => {
    hc(o, 1, `dropdown ${q(n) ? "unclickable" : "clickable"}`, "svelte-3t0u29"), da(l, e.label);
  }), Rt(t, s);
}
pu(["click"]);
var F4e = /* @__PURE__ */ an('<li class="column-entry svelte-bmvlb6"><label class="column-label svelte-bmvlb6"> <input type="checkbox"/></label></li>'), T4e = /* @__PURE__ */ an('<ul class="column-toggle svelte-bmvlb6"></ul>'), R4e = /* @__PURE__ */ an("<!> <!>", 1), M4e = /* @__PURE__ */ an('<div class="header-row svelte-bmvlb6"><div class="scroll-container svelte-bmvlb6"><div class="dropdown-label-container svelte-bmvlb6"><div class="dropdown-label svelte-bmvlb6"><!></div></div> <!></div></div>');
const P4e = {
  hash: "svelte-bmvlb6",
  code: ".header-row.svelte-bmvlb6 {flex-shrink:0;border-bottom:1px solid var(--secondary-bg);background-color:var(--primary-bg);}.scroll-container.svelte-bmvlb6 {display:flex;flex-direction:row;}.dropdown-label-container.svelte-bmvlb6 {position:absolute;z-index:20;left:0px;box-sizing:border-box;height:100%;padding:0.25em;display:flex;flex-direction:row;align-items:end;}.dropdown-label.svelte-bmvlb6 {height:1.5em;align-items:center;display:flex;}.column-toggle.svelte-bmvlb6 {margin:0;margin-top:4px;margin-left:8px;padding:12px;background-color:var(--primary-bg);border-radius:4px;box-shadow:var(--shadow);border:var(--outline);max-height:var(--max-height);max-width:var(--max-width);overflow:scroll;}.column-entry.svelte-bmvlb6 {list-style-type:none;padding:4px;user-select:none;}.column-label.svelte-bmvlb6 {display:flex;align-items:center;justify-content:space-between;gap:16px;color:var(--secondary-text-color);}"
};
function I4e(t, e) {
  sr(e, !0), lr(t, P4e);
  const n = Cn.model, r = Cn.controller, i = wn.config;
  let s = /* @__PURE__ */ He(null), o = /* @__PURE__ */ He(null), l = /* @__PURE__ */ He(null), a = /* @__PURE__ */ _e(() => n.renderableCols), u = 0;
  k0(() => (u = requestAnimationFrame(c), () => {
    cancelAnimationFrame(u);
  }));
  function c() {
    q(o) && (q(o).style.transform = `translate3d(${r.xScroll}px, 0, 0)`), q(l) && (q(l).style.transform = `translate3d(${-r.xScroll}px, 0, 0)`), u = requestAnimationFrame(c);
  }
  var f = M4e(), d = bn(f), p = bn(d), m = bn(p), y = bn(m);
  O4e(y, {
    label: "â‹®",
    get relativeTo() {
      return q(s);
    },
    children: (v, _) => {
      var k = T4e();
      let S;
      Up(k, 21, () => n.columns, M3e, (C, E) => {
        var A = F4e(), O = bn(A), T = bn(O), $ = mo(T);
        j3e($), $.__change = (P) => {
          P.target.checked ? r.showColumn(q(E)) : r.hideColumn(q(E));
        }, gs($, "", {}, { float: "right" }), dn(O), dn(A), pr(() => {
          da(T, `${(q(E) === Wi ? "row #" : i.columnConfigs[q(E)]?.title ?? q(E)) ?? ""} `), Hg($, "id", `${q(E) ?? ""}-checkbox`), q3e($, q(E) === Wi ? i.showRowNumber !== !1 : !i.columnConfigs[q(E)]?.hidden);
        }), Rt(C, A);
      }), dn(k), pr(() => S = gs(k, "", S, {
        "--max-height": r.viewHeight - 48 + "px",
        "--max-width": r.viewWidth - 48 + "px"
      })), Rt(v, k);
    }
  }), dn(m), $i(m, (v) => be(l, v), () => q(l)), dn(p);
  var b = mo(p, 2);
  Up(b, 16, () => q(a), (v) => v, (v, _) => {
    var k = R4e(), S = Ls(k);
    v4e(S, {
      get col() {
        return _;
      }
    });
    var C = mo(S, 2);
    k4e(C, {
      get col() {
        return _;
      }
    }), Rt(v, k);
  }), dn(d), $i(d, (v) => be(o, v), () => q(o)), dn(f), $i(f, (v) => be(s, v), () => q(s)), Rt(t, f), or();
}
pu(["change"]);
class N4e {
  #e = /* @__PURE__ */ He(null);
  get colorScheme() {
    return q(this.#e);
  }
  set colorScheme(e) {
    be(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ He(ai({}));
  get theme() {
    return q(this.#t);
  }
  set theme(e) {
    be(this.#t, e, !0);
  }
}
const bF = Symbol("style");
class Ik {
  static initialize() {
    co(bF, new N4e());
  }
  static get style() {
    return Xi(bF);
  }
}
function B4e(t, e) {
  return { ...t, ...t[e] != null ? t[e] : {} };
}
var L4e = /* @__PURE__ */ an("<div><!></div>");
const $4e = {
  hash: "svelte-c7n1rn",
  code: ".table-defaults.light.svelte-c7n1rn {--default-primary-text-color: black;--default-secondary-text-color: gray;--default-tertiary-text-color: lightgray;--default-font-family: sans-serif;--default-font-size: 1rem;--default-primary-bg: white;--default-secondary-bg: rgb(246, 246, 247);--default-tertiary-bg: rgb(234, 234, 235);--default-hover-bg: rgba(0, 0, 0, 0.05);--default-scrollbar-bg: rgba(0, 0, 0, 0.05);--default-scrollbar-pill-bg: rgba(0, 0, 0, 0.5);--default-scrollbar-label-bg: rgba(255, 255, 255, 0.9);--default-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--default-outline-color: rgb(0 0 0 / 0.2);--default-dimmed-row-color: rgb(0 0 0 / 0.2);--default-row-scroll-to-color: rgb(202 225 255);--default-row-hover-color: rgb(220, 235, 255);}.table-defaults.dark.svelte-c7n1rn {--default-primary-text-color: lightgray;--default-secondary-text-color: gray;--default-tertiary-text-color: dimgray;--default-font-family: sans-serif;--default-font-size: 1rem;--default-primary-bg: #060607;--default-secondary-bg: #161617;--default-hover-bg: rgba(255, 255, 255, 0.05);--default-scrollbar-bg: rgba(255, 255, 255, 0.05);--default-scrollbar-pill-bg: rgba(255, 255, 255, 0.5);--default-scrollbar-label-bg: rgba(0, 0, 0, 0.9);--default-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--default-outline-color: rgb(255 255 255 / 0.2);--default-dimmed-row-color: rgb(0 0 0 / 0.6);--default-row-scroll-to-color: rgb(1, 24, 106);--default-row-hover-color: rgb(0, 6, 35);}.style-wrapper.svelte-c7n1rn {width:100%;height:100%;--primary-text-color: var(--user-primary-text-color, var(--default-primary-text-color));--secondary-text-color: var(--user-secondary-text-color, var(--default-secondary-text-color));--tertiary-text-color: var(--user-tertiary-text-color, var(--default-tertiary-text-color));--font-family: var(--user-font-family, var(--default-font-family));--font-size: var(--user-font-size, var(--default-font-size));--primary-bg: var(--user-primary-bg, var(--default-primary-bg));--secondary-bg: var(--user-secondary-bg, var(--default-secondary-bg));--tertiary-bg: var(--user-tertiarty-bg, var(--default-tertiary-bg));--hover-bg: var(--user-hover-bg, var(--default-hover-bg));--header-font-family: var(--user-header-font-family, var(--font-family));--header-font-size: var(--user-header-font-size, var(--font-size));--cell-font-family: var(--user-cell-font-family, var(--font-family));--cell-font-size: var(--user-cell-font-size, var(--font-size));--scrollbar-bg: var(--user-scrollbar-bg, var(--default-scrollbar-bg));--scrollbar-pill-bg: var(--user-scrollbar-pill-bg, var(--default-scrollbar-pill-bg));--scrollbar-label-bg: var(--user-scrollbar-label-bg, var(--default-scrollbar-label-bg));--shadow: var(--user-shadow, var(--default-shadow));--outline-color: var(--user-outline-color, var(--default-outline-color));--outline: 0.5px solid var(--outline-color);--dimmed-row-color: var(--user-dimmed-row-color, var(--default-dimmed-row-color));--row-scroll-to-color: var(--user-row-scroll-to-color, var(--default-row-scroll-to-color));--row-hover-color: var(--user-row-hover-color, var(--default-row-hover-color));}"
};
function z4e(t, e) {
  sr(e, !0), lr(t, $4e);
  const n = Ik.style;
  let r = /* @__PURE__ */ _e(() => n.colorScheme), i = /* @__PURE__ */ _e(() => n.theme), s = /* @__PURE__ */ He(null), o = /* @__PURE__ */ _e(() => q(r) ?? q(s) ?? "light");
  const l = (U) => {
    U.matches ? be(s, "dark") : be(s, "light");
  }, a = "(prefers-color-scheme: dark";
  k0(() => (be(s, window.matchMedia(a).matches ? "dark" : "light", !0), window.matchMedia(a).addEventListener("change", l), () => {
    window.matchMedia(a).removeEventListener("change", l);
  }));
  let u = /* @__PURE__ */ _e(() => B4e(q(i), q(o))), c = /* @__PURE__ */ _e(() => q(u).primaryTextColor), f = /* @__PURE__ */ _e(() => q(u).secondaryTextColor), d = /* @__PURE__ */ _e(() => q(u).tertiaryTextColor), p = /* @__PURE__ */ _e(() => q(u).fontFamily), m = /* @__PURE__ */ _e(() => q(u).fontSize), y = /* @__PURE__ */ _e(() => q(u).primaryBackgroundColor), b = /* @__PURE__ */ _e(() => q(u).secondaryBackgroundColor), v = /* @__PURE__ */ _e(() => q(u).hoverBackgroundColor), _ = /* @__PURE__ */ _e(() => q(u).headerFontFamily), k = /* @__PURE__ */ _e(() => q(u).headerFontSize), S = /* @__PURE__ */ _e(() => q(u).cellFontFamily), C = /* @__PURE__ */ _e(() => q(u).cellFontSize), E = /* @__PURE__ */ _e(() => q(u).scrollbarBackgroundColor), A = /* @__PURE__ */ _e(() => q(u).scrollbarPillColor), O = /* @__PURE__ */ _e(() => q(u).scrollbarLabelBackgroundColor), T = /* @__PURE__ */ _e(() => q(u).shadow), $ = /* @__PURE__ */ _e(() => q(u).outlineColor), P = /* @__PURE__ */ _e(() => q(u).dimmedRowColor), B = /* @__PURE__ */ _e(() => q(u).rowScrollToColor), M = /* @__PURE__ */ _e(() => q(u).rowHoverColor);
  Xn(() => {
  });
  var L = L4e();
  let N;
  var j = bn(L);
  EC(j, () => e.children), dn(L), pr(() => {
    hc(L, 1, `style-wrapper table-defaults ${q(o) ?? ""}`, "svelte-c7n1rn"), N = gs(L, "", N, {
      "--user-primary-text-color": q(c),
      "--user-secondary-text-color": q(f),
      "--user-tertiary-text-color": q(d),
      "--user-font-family": q(p),
      "--user-font-size": q(m),
      "--user-primary-bg": q(y),
      "--user-secondary-bg": q(b),
      "--user-hover-bg": q(v),
      "--user-header-font-family": q(_),
      "--user-header-font-size": q(k),
      "--user-cell-font-family": q(S),
      "--user-cell-font-size": q(C),
      "--user-scrollbar-bg": q(E),
      "--user-scrollbar-pill-bg": q(A),
      "--user-scrollbar-label-bg": q(O),
      "--user-shadow": q(T),
      "--user-outline-color": q($),
      "--user-dimmed-row-color": q(P),
      "--user-row-scroll-to-color": q(B),
      "--user-row-hover-color": q(M)
    });
  }), Rt(t, L), or();
}
function j4e() {
  return Wi;
}
function q4e(t, e) {
  const n = new Set(t), r = new Set(e);
  return {
    left: t.filter((i) => !r.has(i)),
    right: e.filter((i) => !n.has(i))
  };
}
function U4e(t, e) {
  const n = new Set(e);
  return t.filter((r) => !n.has(r));
}
function H4e(t, e) {
  return t.concat(e);
}
var V4e = /* @__PURE__ */ an("<div></div>"), W4e = /* @__PURE__ */ an("<div></div> <!>", 1);
const G4e = {
  hash: "svelte-14dgpd0",
  code: ".row-background.svelte-14dgpd0 {position:absolute;width:var(--width);height:var(--height);box-sizing:border-box;z-index:-1;transform:translate3d(0, var(--y), 0);transition:background-color 100ms linear;}.odd.svelte-14dgpd0 {background-color:var(--secondary-bg);}.even.svelte-14dgpd0 {background-color:var(--primary-bg);}.dimmer.svelte-14dgpd0 {background-color:var(--dimmed-row-color);z-index:10;pointer-events:none;}.flashed.svelte-14dgpd0 {background-color:var(--row-scroll-to-color);}.hovered.svelte-14dgpd0 {background-color:var(--row-hover-color);}"
};
function K4e(t, e) {
  sr(e, !0), lr(t, G4e);
  const n = Cn.controller, r = Cn.model, i = Cn.overscrollModifier, s = wn.config;
  let o = /* @__PURE__ */ _e(() => r.rowHeights[e.row]), l = /* @__PURE__ */ _e(() => Math.max(r.colsRightmostPosition, n.viewWidth)), a = /* @__PURE__ */ _e(() => i.y(r.rowPositions[e.row])), u = /* @__PURE__ */ _e(() => r.getRowParity(e.row)), c = /* @__PURE__ */ _e(() => n.flashedRowId === e.row), f = /* @__PURE__ */ _e(() => n.hoveredRowId === e.row), d = /* @__PURE__ */ _e(() => s.highlightedRows ? s.highlightedRows?.has(e.row) : null);
  var p = W4e(), m = Ls(p);
  let y;
  var b = mo(m, 2);
  {
    var v = (_) => {
      var k = V4e();
      let S;
      pr(() => {
        hc(k, 1, `row-background ${q(u) ?? ""} dimmer`, "svelte-14dgpd0"), S = gs(k, "", S, {
          "--width": q(l) + "px",
          "--height": q(o) + "px",
          "--y": q(a) + "px"
        });
      }), Rt(_, k);
    };
    Qi(b, (_) => {
      q(d) !== null && !q(d) && _(v);
    });
  }
  pr(() => {
    hc(m, 1, `row-background ${q(u) ?? ""} ${(q(c) ? "flashed" : null) ?? ""} ${(q(f) && s.highlightHoveredRow ? "hovered" : null) ?? ""}`, "svelte-14dgpd0"), y = gs(m, "", y, {
      "--width": q(l) + "px",
      "--height": q(o) + "px",
      "--y": q(a) + "px"
    });
  }), Rt(t, p), or();
}
var Y4e = /* @__PURE__ */ an("<!> <!>", 1), X4e = /* @__PURE__ */ an('<div class="scroll-container svelte-1v3p82v"><!></div> <!> <!>', 1), Q4e = /* @__PURE__ */ an('<div class="table svelte-1v3p82v"><!> <div class="table-contents svelte-1v3p82v"><!></div></div>');
const J4e = {
  hash: "svelte-1v3p82v",
  code: ".table.svelte-1v3p82v {width:100%;max-width:var(--max-width);height:100%;display:flex;flex-direction:column;position:relative;}.table-contents.svelte-1v3p82v {position:relative;overflow:hidden;flex-grow:1;}.scroll-container.svelte-1v3p82v {position:absolute;width:0;height:0;will-change:transform;contain:layout size;}"
};
function Z4e(t, e) {
  sr(e, !0), lr(t, J4e), wn.initialize(), nb.initialize(), rb.initialize(), Ik.initialize(), Cn.initialize();
  const n = Cn.controller, r = Cn.model, i = Cn.overscrollModifier, s = wn.config, o = Ik.style;
  Xn(() => {
    e.scrollTo != null && n.scrollToRow(String(e.scrollTo));
  }), Xn(() => {
    e.highlightedRows && e.highlightedRows.length > 0 ? s.highlightedRows = new Set(e.highlightedRows.map((_) => String(_))) : s.highlightedRows = null;
  }), Xn(() => {
    e.onRowClick != null ? s.onRowClick = e.onRowClick : s.onRowClick = null;
  }), Xn(() => {
    e.coordinator ? Pk.coordinator = e.coordinator : Pk.coordinator = null;
  }), Xn(() => {
    e.numLines != null ? s.textMaxLines = e.numLines : s.textMaxLines = s.DEFAULT_TEXT_MAX_LINES, e.lineHeight != null ? s.lineHeight = e.lineHeight : s.lineHeight = s.DEFAULT_LINE_HEIGHT;
  }), Xn(() => {
    e.colorScheme != null ? o.colorScheme = e.colorScheme : o.colorScheme = null;
  }), Xn(() => {
    e.theme != null ? o.theme = e.theme : o.theme = {}, e.colorScheme != null ? o.colorScheme = e.colorScheme : o.colorScheme = null;
  }), Xn(() => {
    e.columnConfigs != null ? s.columnConfigs = e.columnConfigs : s.columnConfigs = {}, e.onColumnConfigsChange != null ? s.onColumnConfigsChange = e.onColumnConfigsChange : s.onColumnConfigsChange = () => {
    };
  }), Xn(() => {
    s.showRowNumber = e.showRowNumber ?? null;
  }), Xn(() => {
    s.onShowRowNumberChange = e.onShowRowNumberChange ?? null;
  }), Xn(() => {
    n.initialize({
      tableName: e.table,
      rowKey: e.rowKey,
      columns: [j4e(), ...e.columns],
      filterBy: e.filter ?? null
    });
  }), Xn(() => {
    e.customCells != null ? nb.config = e.customCells : nb.config = {};
  }), Xn(() => {
    e.additionalHeaderContents != null ? rb.config = e.additionalHeaderContents : rb.config = {};
  }), Xn(() => {
    e.headerHeight != null ? s.headerHeight = e.headerHeight : s.headerHeight = null;
  }), Xn(() => {
    e.highlightHoveredRow != null ? s.highlightHoveredRow = e.highlightHoveredRow : s.highlightHoveredRow = !1;
  });
  let l = /* @__PURE__ */ He([]), a = /* @__PURE__ */ He(0), u = /* @__PURE__ */ He(null), c = /* @__PURE__ */ He(ai([])), f = /* @__PURE__ */ He(ai([])), d = /* @__PURE__ */ _e(() => q(c).filter((_) => n.rowStillExists(_))), p = /* @__PURE__ */ _e(() => q(f)), m = 0;
  k0(() => (m = requestAnimationFrame(v), () => {
    n.teardown(), r.teardown(), cancelAnimationFrame(m);
  }));
  function y(_, k) {
    if (k.length > 0) {
      const S = k[k.length - 1];
      return Math.abs(r.data[_][Gi] - r.data[S][Gi]);
    }
    return 0;
  }
  function b() {
    const { left: _, right: k } = q4e(q(l), r.renderableRows);
    _.length === 0 && k.length === 0 || (be(l, U4e(q(
      l
      // remove the rows that have been deleted from the model
    ), _)), be(l, H4e(q(
      l
      // add the rows that have been added by the model
    ), k.sort((S, C) => y(S, q(l)) - y(C, q(l))).slice(0, n.isJumping ? n.rowsOnScreen : s.rowRenderBatchSize))));
  }
  function v() {
    b(), be(c, q(l).filter((S) => n.rowIsVisible(S)), !0), be(f, r.renderableCols.filter((S) => n.colIsVisible(S)), !0);
    const _ = n.xScroll, k = i.yScroll(n.yScroll);
    q(u) && (q(u).style.transform = `translate3d(${_}px, ${k}px, 0)`), be(a, n.updateKey, !0), m = requestAnimationFrame(v);
  }
  z4e(t, {
    children: (_, k) => {
      var S = Q4e(), C = bn(S);
      I4e(C, {});
      var E = mo(C, 2), A = bn(E);
      {
        var O = (T) => {
          var $ = X4e(), P = Ls($), B = bn(P);
          R3e(B, () => q(a), (N) => {
            var j = Y4e(), U = Ls(j);
            Up(U, 16, () => q(d), (G) => G, (G, re) => {
              var se = zc(), oe = Ls(se);
              Up(oe, 16, () => q(p), (ne) => ne, (ne, ce) => {
                n4e(ne, {
                  get row() {
                    return re;
                  },
                  get col() {
                    return ce;
                  }
                });
              }), Rt(G, se);
            });
            var H = mo(U, 2);
            Up(H, 16, () => r.renderableRows, (G) => G, (G, re) => {
              K4e(G, {
                get row() {
                  return re;
                }
              });
            }), Rt(N, j);
          }), dn(P), $i(P, (N) => be(u, N), () => q(u));
          var M = mo(P, 2);
          D_e(M, {});
          var L = mo(M, 2);
          S_e(L, {}), Rt(T, $);
        };
        Qi(A, (T) => {
          n.isReady && T(O);
        });
      }
      dn(E), dn(S), $i(S, (T) => n.element = T, () => n?.element), Vd("wheel", S, function(...T) {
        n.handleWheel?.apply(this, T);
      }), nl(E, "clientHeight", (T) => n.viewHeight = T), nl(E, "clientWidth", (T) => n.viewWidth = T), Rt(_, S);
    },
    $$slots: { default: !0 }
  }), or();
}
class eke {
  component;
  currentProps;
  constructor(e, n) {
    this.currentProps = { ...n }, this.component = D3e({ component: Z4e, target: e, props: n });
  }
  update(e) {
    let n = {};
    for (let r in e)
      e[r] !== this.currentProps[r] && (n[r] = e[r], this.currentProps[r] = e[r]);
    this.component.$set(n);
  }
  destroy() {
    this.component.$destroy();
  }
}
var tke = /* @__PURE__ */ ge("<div></div>");
function nke(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]), r;
  Kg(() => {
    let s = new eke(r, n);
    Vo(() => {
      s.update(n);
    }), kT(() => {
      s.destroy();
    });
  });
  var i = tke();
  ht(i, "", {}, { width: "100%", height: "100%" }), Yo(i, (s) => r = s, () => r), X(t, i), st();
}
const rke = {
  fontSize: "13px",
  fontFamily: "system-ui",
  light: {
    primaryBackgroundColor: "white",
    secondaryBackgroundColor: "var(--color-slate-100)",
    // bg-slate-100
    primaryTextColor: "var(--color-slate-500)",
    // text-slate-500
    secondaryTextColor: "var(--color-slate-400)",
    // text-slate-400
    tertiaryTextColor: "var(--color-slate-300)",
    // text-slate-300
    scrollbarPillColor: "var(--color-slate-400)",
    // bg-slate-400
    scrollbarLabelBackgroundColor: "white",
    rowScrollToColor: "var(--color-blue-200)",
    // bg-blue-200
    rowHoverColor: "var(--color-blue-100)"
    // bg-blue-100
  },
  dark: {
    primaryBackgroundColor: "black",
    secondaryBackgroundColor: "var(--color-slate-900)",
    // bg-slate-900
    primaryTextColor: "var(--color-slate-400)",
    // bg-slate-400
    secondaryTextColor: "var(--color-slate-500)",
    // bg-slate-500
    tertiaryTextColor: "var(--color-slate-600)",
    // bg-slate-600
    scrollbarPillColor: "var(--color-slate-500)",
    // bg-slate-500
    scrollbarLabelBackgroundColor: "var(--color-slate-900)",
    // bg-slate-900
    rowScrollToColor: "var(--color-blue-900)",
    // bg-slate-900
    rowHoverColor: "var(--color-blue-950)"
    // bg-slate-950
  }
};
function ike(t, e) {
  it(e, !0);
  const n = () => gi(l, "$columnStyles", i), r = () => gi(o, "$colorScheme", i), [i, s] = Xs();
  let { colorScheme: o, columnStyles: l } = e.context, a = oz(e.context.highlight), u = /* @__PURE__ */ Ee(null);
  pt(() => a.subscribe((d) => {
    x(u) !== d && ae(u, d, !0);
  }));
  function c(d, p, m) {
    let y = {};
    for (let b of d)
      m?.[b.name] != null && (y[b.name] = kO(m[b.name])), p[b.name]?.renderer != null && (y[b.name] = kO(p[b.name]?.renderer));
    return y;
  }
  let f = /* @__PURE__ */ K(() => c(e.context.columns, n(), e.context.tableCellRenderers));
  nke(t, {
    get coordinator() {
      return e.context.coordinator;
    },
    get table() {
      return e.context.table;
    },
    get rowKey() {
      return e.context.id;
    },
    get columns() {
      return e.spec.columns;
    },
    get filter() {
      return e.context.filter;
    },
    get scrollTo() {
      return x(u);
    },
    onRowClick: async (d) => {
      a.set(d);
    },
    numLines: 3,
    get colorScheme() {
      return r();
    },
    get theme() {
      return rke;
    },
    highlightHoveredRow: !0,
    get customCells() {
      return x(f);
    }
  }), st(), s();
}
const lj = {}, aj = [];
function Co(t, e) {
  lj[t] = e;
}
function gu(t) {
  aj.push(t);
}
function ske(t) {
  if (typeof t != "object")
    return W3;
  if (typeof t.type == "string") {
    let e = lj[t.type];
    return e ?? W3;
  }
  return W3;
}
function oke() {
  return aj;
}
Co("builder", g2e);
Co("count-plot", Jbe);
Co("count-plot-list", ave);
Co("histogram", pve);
Co("histogram-stack", Eve);
Co("histogram-2d", xve);
Co("box-plot", qbe);
Co("mosaic-spec", Pve);
Co("line-plot", Rve);
Co("embedding", kwe);
Co("predicates", qve);
Co("table", ike);
gu({
  icon: "chart-h-bar",
  description: "Create a count plot of a categorical field",
  ui: [
    { field: { key: "x", label: "Field", types: ["number", "string", "string[]"], required: !0 } }
    //
  ],
  create: ({ x: t }) => t.type == "discrete[]" ? {
    title: t.name,
    type: "count-plot-list",
    data: { field: t.name }
  } : {
    title: t.name,
    type: "count-plot",
    data: { field: t.name }
  }
});
gu({
  icon: "chart-v-histogram",
  description: "Create a histogram of a field",
  ui: [
    { field: { key: "x", label: "Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t }) => ({
    type: "histogram",
    title: t.name,
    data: { field: t.name },
    binCount: 20
  })
});
gu({
  icon: "chart-line",
  description: "Create a line plot over time",
  ui: [
    { field: { key: "x", label: "Time Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t }, e) => ({
    type: "line-plot",
    title: `${t.name} over time`,
    data: { table: e.table, x: t.name }
  })
});
gu({
  icon: "chart-stacked",
  description: "Create a stacked histogram",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number", "string"], required: !0 } },
    //
    { field: { key: "y", label: "Group Field", types: ["number", "string"] } }
    //
  ],
  create: ({ x: t, y: e }) => e == null ? {
    type: "histogram",
    title: `${t.name}`,
    data: {
      field: t.name
    },
    binCount: 20
  } : {
    type: "histogram-stack",
    title: `${t.name} by ${e.name}`,
    data: {
      x: t.name,
      group: e.name
    },
    xBinCount: 20,
    groupBinCount: 5
  }
});
gu({
  icon: "chart-heatmap",
  description: "Create a 2D heatmap of two fields",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number", "string"], required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number", "string"], required: !0 } }
    //
  ],
  create: ({ x: t, y: e }) => ({
    type: "histogram-2d",
    title: `${t.name}, ${e.name}`,
    data: { x: t.name, y: e.name },
    xBinCount: 20,
    yBinCount: 20
  })
});
gu({
  icon: "chart-boxplot",
  description: "Create a box plot",
  ui: [
    { field: { key: "x", label: "X Field", required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number"], required: !0 } }
    //
  ],
  create: ({ x: t, y: e }) => ({
    type: "box-plot",
    title: `${e.name} by ${t.name}`,
    data: { x: t.name, y: e.name },
    xBinCount: 20
  })
});
gu({
  icon: "chart-embedding",
  description: "Create an embedding view",
  ui: [
    { field: { key: "x", label: "X Field", types: ["number"], required: !0 } },
    //
    { field: { key: "y", label: "Y Field", types: ["number"], required: !0 } },
    //
    { field: { key: "text", label: "Text Field", types: ["string"] } },
    //
    { field: { key: "category", label: "Category Field", types: ["string", "number"] } }
    //
  ],
  preview: !1,
  create: ({ x: t, y: e, text: n, category: r }, i) => ({
    type: "embedding",
    title: "Embedding",
    data: {
      x: t.name,
      y: e.name,
      text: n?.name,
      category: r?.name
    }
  })
});
gu({
  icon: "chart-predicates",
  description: "Create a filter with custom SQL predicates",
  ui: [],
  create: () => ({
    type: "predicates",
    title: "SQL Predicates"
  })
});
gu({
  icon: "chart-spec",
  description: "Create a chart with custom spec",
  preview: !1,
  ui: [{ code: { key: "spec", language: "json" } }],
  create: ({ spec: t }) => JSON.parse(t)
});
var lke = /* @__PURE__ */ ge("<button>An occured with this chart. Click to retry.</button>"), ake = /* @__PURE__ */ ge("<div><!></div>");
function uj(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]), r = /* @__PURE__ */ K(() => ske(e.spec)), i = /* @__PURE__ */ Ee(100), s = /* @__PURE__ */ Ee(100);
  function o(c, f) {
    console.trace("Error happened in chart with spec", f.spec, f.error);
  }
  var l = ake();
  let a;
  var u = J(l);
  KF(u, { failed: (f, d = zt, p = zt) => {
    var m = lke();
    m.__click = function(...y) {
      p()?.apply(this, y);
    }, Ts(m, (y, b) => o?.(y, b), () => ({ spec: e.spec, error: d() })), X(f, m);
  } }, (f) => {
    var d = kn(), p = We(d);
    {
      let m = /* @__PURE__ */ K(() => e.width == "container" ? x(i) : e.width), y = /* @__PURE__ */ K(() => e.height == "container" ? x(s) : e.height);
      Yd(p, () => x(r), (b, v) => {
        v(b, sX(() => n, {
          get width() {
            return x(m);
          },
          get height() {
            return x(y);
          }
        }));
      });
    }
    X(f, d);
  }), Q(l), ke(() => a = ht(l, "", a, {
    width: e.width == "container" ? "100%" : e.width != null ? `${e.width}px` : "fit-content",
    height: e.height == "container" ? "100%" : e.height != null ? `${e.height}px` : "fit-content"
  })), Ko(l, "clientWidth", (c) => ae(i, c)), Ko(l, "clientHeight", (c) => ae(s, c)), X(t, l), st();
}
ir(["click"]);
function uke(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ K(() => ppe(e.layout)), r = /* @__PURE__ */ K(() => e.layoutStates[e.layout] ?? {});
  function i(f, d, p = "merge") {
    Cy(e.charts, f, d, p, (m) => e.onChartsChange?.(m));
  }
  function s(f, d, p = "merge") {
    Cy(e.chartStates, f, d, p, (m) => e.onChartStatesChange?.(m));
  }
  function o(f, d = "merge") {
    dd(e.charts, f, d, (p) => e.onChartsChange?.(p));
  }
  function l(f, d = "merge") {
    dd(e.chartStates, f, d, (p) => e.onChartStatesChange?.(p));
  }
  function a(f, d, p = "merge") {
    Cy(e.layoutStates, f, d, p, (m) => e.onLayoutStatesChange?.(m));
  }
  var u = kn(), c = We(u);
  {
    const f = (p, m) => {
      let y = () => m?.().id, b = () => m?.().width, v = () => m?.().height;
      {
        let _ = /* @__PURE__ */ K(() => e.chartStates[y()] ?? {}), k = /* @__PURE__ */ K(() => i.bind(null, y())), S = /* @__PURE__ */ K(() => s.bind(null, y()));
        uj(p, {
          get context() {
            return e.context;
          },
          get width() {
            return b();
          },
          get height() {
            return v();
          },
          get spec() {
            return e.charts[y()];
          },
          get state() {
            return x(_);
          },
          get onSpecChange() {
            return x(k);
          },
          get onStateChange() {
            return x(S);
          }
        });
      }
    };
    let d = /* @__PURE__ */ K(() => a.bind(null, e.layout));
    Yd(c, () => x(n), (p, m) => {
      m(p, {
        get context() {
          return e.context;
        },
        get charts() {
          return e.charts;
        },
        get state() {
          return x(r);
        },
        get onStateChange() {
          return x(d);
        },
        onChartsChange: o,
        onChartStatesChange: l,
        chartView: f,
        $$slots: { chartView: !0 }
      });
    });
  }
  X(t, u), st();
}
var cke = /* @__PURE__ */ ge('<tr class="leading-10"><td class="w-full"><div class="max-w-80 whitespace-nowrap text-ellipsis overflow-x-hidden"> </div></td><td class="pr-2"><div class="flex items-center gap-2"><!> <!></div></td><td><div class="flex items-center gap-2"><!></div></td></tr>');
function fke(t, e) {
  it(e, !0);
  function n(y) {
    e.onChange({ ...e.style, ...y });
  }
  var r = cke(), i = J(r), s = J(i), o = J(s, !0);
  Q(s), Q(i);
  var l = ue(i), a = J(l), u = J(a);
  {
    let y = /* @__PURE__ */ K(() => e.style.renderer ?? null), b = /* @__PURE__ */ K(() => [
      { value: null, label: "(default)" },
      ...uxe.map((v) => ({ value: v.renderer, label: v.label }))
    ]);
    Of(u, {
      get value() {
        return x(y);
      },
      onChange: (v) => n({ renderer: v }),
      get options() {
        return x(b);
      }
    });
  }
  var c = ue(u, 2);
  {
    var f = (y) => {
      var b = () => e.style.rendererOptions?.size ?? 100, v = (_) => {
        n({ rendererOptions: { size: _ } });
      };
      Ck(y, {
        get value() {
          return b();
        },
        set value(_) {
          v(_);
        },
        width: 80,
        min: 16,
        max: 400,
        step: 1
      });
    };
    Fe(c, (y) => {
      e.style.renderer == "image" && y(f);
    });
  }
  Q(a), Q(l);
  var d = ue(l), p = J(d), m = J(p);
  {
    let y = /* @__PURE__ */ K(() => e.style.display ?? "badge");
    Of(m, {
      get value() {
        return x(y);
      },
      onChange: (b) => {
        n({ display: b });
      },
      options: [
        { value: "full", label: "Full" },
        { value: "badge", label: "Badge" },
        { value: "hidden", label: "Hidden" }
      ]
    });
  }
  Q(p), Q(d), Q(r), ke(() => ut(o, e.column.name)), X(t, r), st();
}
var hke = /* @__PURE__ */ ge('<div class="max-h-60 overflow-x-hidden overflow-y-scroll border border-slate-300 dark:border-slate-700 p-2 rounded-md"><table><thead><tr class="select-none"><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Column</th><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Format</th><th class="pb-2 text-slate-500 dark:text-slate-400 text-left font-normal text-sm">Style</th></tr></thead><tbody></tbody></table></div>');
function dke(t, e) {
  it(e, !0);
  var n = hke(), r = J(n), i = ue(J(r));
  Bt(i, 21, () => e.columns, fn, (s, o) => {
    {
      let l = /* @__PURE__ */ K(() => e.styles[x(o).name] ?? {});
      fke(s, {
        get column() {
          return x(o);
        },
        get style() {
          return x(l);
        },
        onChange: (a) => {
          let u = { ...e.styles };
          u[x(o).name] = a, e.onStylesChange(u);
        }
      });
    }
  }), Q(i), Q(r), Q(n), X(t, n), st();
}
var pke = /* @__PURE__ */ ge('<div> <span class="text-slate-500"> </span></div>');
function gke(t, e) {
  it(e, !0);
  let n = /* @__PURE__ */ Ee(null), r = /* @__PURE__ */ Ee(null);
  Vo(() => {
    ae(n, null), ae(r, null);
    let a = ia({
      coordinator: e.coordinator,
      selection: e.filter,
      prepare: async () => {
        let u = await e.coordinator.query(pd.from(e.table).select({ count: iA`COUNT(*)::INT` }));
        ae(n, u.get(0).count, !0);
      },
      query: (u) => pd.from(e.table).select({ count: iA`COUNT(*)::INT` }).where(u),
      queryResult: (u) => {
        ae(r, u.getChild("count").get(0), !0);
      }
    });
    return () => {
      a.destroy();
    };
  });
  var i = pke(), s = J(i), o = ue(s), l = J(o);
  Q(o), Q(i), ke(
    (a, u) => {
      ut(s, `${a ?? ""} `), ut(l, `/ ${u ?? ""} points`);
    },
    [
      () => x(r)?.toLocaleString() ?? "",
      () => x(n)?.toLocaleString() ?? ""
    ]
  ), X(t, i), st();
}
var ib = { exports: {} };
var mke = ib.exports, vF;
function yke() {
  return vF || (vF = 1, (function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(mke, (function() {
      var n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
        return typeof u;
      } : function(u) {
        return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
      }, r = function(u, c) {
        if (!(u instanceof c))
          throw new TypeError("Cannot call a class as a function");
      }, i = /* @__PURE__ */ (function() {
        function u(c, f) {
          for (var d = 0; d < f.length; d++) {
            var p = f[d];
            p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(c, p.key, p);
          }
        }
        return function(c, f, d) {
          return f && u(c.prototype, f), d && u(c, d), c;
        };
      })(), s = Object.assign || function(u) {
        for (var c = 1; c < arguments.length; c++) {
          var f = arguments[c];
          for (var d in f)
            Object.prototype.hasOwnProperty.call(f, d) && (u[d] = f[d]);
        }
        return u;
      }, o = (function() {
        function u(c) {
          var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          r(this, u), this.ctx = c, this.iframes = f, this.exclude = d, this.iframesTimeout = p;
        }
        return i(u, [{
          key: "getContexts",
          value: function() {
            var f = void 0, d = [];
            return typeof this.ctx > "u" || !this.ctx ? f = [] : NodeList.prototype.isPrototypeOf(this.ctx) ? f = Array.prototype.slice.call(this.ctx) : Array.isArray(this.ctx) ? f = this.ctx : typeof this.ctx == "string" ? f = Array.prototype.slice.call(document.querySelectorAll(this.ctx)) : f = [this.ctx], f.forEach(function(p) {
              var m = d.filter(function(y) {
                return y.contains(p);
              }).length > 0;
              d.indexOf(p) === -1 && !m && d.push(p);
            }), d;
          }
        }, {
          key: "getIframeContents",
          value: function(f, d) {
            var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            }, m = void 0;
            try {
              var y = f.contentWindow;
              if (m = y.document, !y || !m)
                throw new Error("iframe inaccessible");
            } catch {
              p();
            }
            m && d(m);
          }
        }, {
          key: "isIframeBlank",
          value: function(f) {
            var d = "about:blank", p = f.getAttribute("src").trim(), m = f.contentWindow.location.href;
            return m === d && p !== d && p;
          }
        }, {
          key: "observeIframeLoad",
          value: function(f, d, p) {
            var m = this, y = !1, b = null, v = function _() {
              if (!y) {
                y = !0, clearTimeout(b);
                try {
                  m.isIframeBlank(f) || (f.removeEventListener("load", _), m.getIframeContents(f, d, p));
                } catch {
                  p();
                }
              }
            };
            f.addEventListener("load", v), b = setTimeout(v, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function(f, d, p) {
            try {
              f.contentWindow.document.readyState === "complete" ? this.isIframeBlank(f) ? this.observeIframeLoad(f, d, p) : this.getIframeContents(f, d, p) : this.observeIframeLoad(f, d, p);
            } catch {
              p();
            }
          }
        }, {
          key: "waitForIframes",
          value: function(f, d) {
            var p = this, m = 0;
            this.forEachIframe(f, function() {
              return !0;
            }, function(y) {
              m++, p.waitForIframes(y.querySelector("html"), function() {
                --m || d();
              });
            }, function(y) {
              y || d();
            });
          }
        }, {
          key: "forEachIframe",
          value: function(f, d, p) {
            var m = this, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, b = f.querySelectorAll("iframe"), v = b.length, _ = 0;
            b = Array.prototype.slice.call(b);
            var k = function() {
              --v <= 0 && y(_);
            };
            v || k(), b.forEach(function(S) {
              u.matches(S, m.exclude) ? k() : m.onIframeReady(S, function(C) {
                d(S) && (_++, p(C)), k();
              }, k);
            });
          }
        }, {
          key: "createIterator",
          value: function(f, d, p) {
            return document.createNodeIterator(f, d, p, !1);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function(f) {
            return new u(f.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function(f, d, p) {
            var m = f.compareDocumentPosition(p), y = Node.DOCUMENT_POSITION_PRECEDING;
            if (m & y)
              if (d !== null) {
                var b = d.compareDocumentPosition(p), v = Node.DOCUMENT_POSITION_FOLLOWING;
                if (b & v)
                  return !0;
              } else
                return !0;
            return !1;
          }
        }, {
          key: "getIteratorNode",
          value: function(f) {
            var d = f.previousNode(), p = void 0;
            return d === null ? p = f.nextNode() : p = f.nextNode() && f.nextNode(), {
              prevNode: d,
              node: p
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function(f, d, p, m) {
            var y = !1, b = !1;
            return m.forEach(function(v, _) {
              v.val === p && (y = _, b = v.handled);
            }), this.compareNodeIframe(f, d, p) ? (y === !1 && !b ? m.push({
              val: p,
              handled: !0
            }) : y !== !1 && !b && (m[y].handled = !0), !0) : (y === !1 && m.push({
              val: p,
              handled: !1
            }), !1);
          }
        }, {
          key: "handleOpenIframes",
          value: function(f, d, p, m) {
            var y = this;
            f.forEach(function(b) {
              b.handled || y.getIframeContents(b.val, function(v) {
                y.createInstanceOnIframe(v).forEachNode(d, p, m);
              });
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function(f, d, p, m, y) {
            for (var b = this, v = this.createIterator(d, f, m), _ = [], k = [], S = void 0, C = void 0, E = function() {
              var O = b.getIteratorNode(v);
              return C = O.prevNode, S = O.node, S;
            }; E(); )
              this.iframes && this.forEachIframe(d, function(A) {
                return b.checkIframeFilter(S, C, A, _);
              }, function(A) {
                b.createInstanceOnIframe(A).forEachNode(f, function(O) {
                  return k.push(O);
                }, m);
              }), k.push(S);
            k.forEach(function(A) {
              p(A);
            }), this.iframes && this.handleOpenIframes(_, f, p, m), y();
          }
        }, {
          key: "forEachNode",
          value: function(f, d, p) {
            var m = this, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, b = this.getContexts(), v = b.length;
            v || y(), b.forEach(function(_) {
              var k = function() {
                m.iterateThroughNodes(f, _, d, p, function() {
                  --v <= 0 && y();
                });
              };
              m.iframes ? m.waitForIframes(_, k) : k();
            });
          }
        }], [{
          key: "matches",
          value: function(f, d) {
            var p = typeof d == "string" ? [d] : d, m = f.matches || f.matchesSelector || f.msMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.webkitMatchesSelector;
            if (m) {
              var y = !1;
              return p.every(function(b) {
                return m.call(f, b) ? (y = !0, !1) : !0;
              }), y;
            } else
              return !1;
          }
        }]), u;
      })(), l = (function() {
        function u(c) {
          r(this, u), this.ctx = c, this.ie = !1;
          var f = window.navigator.userAgent;
          (f.indexOf("MSIE") > -1 || f.indexOf("Trident") > -1) && (this.ie = !0);
        }
        return i(u, [{
          key: "log",
          value: function(f) {
            var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug", p = this.opt.log;
            this.opt.debug && (typeof p > "u" ? "undefined" : n(p)) === "object" && typeof p[d] == "function" && p[d]("mark.js: " + f);
          }
        }, {
          key: "escapeStr",
          value: function(f) {
            return f.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function(f) {
            return this.opt.wildcards !== "disabled" && (f = this.setupWildcardsRegExp(f)), f = this.escapeStr(f), Object.keys(this.opt.synonyms).length && (f = this.createSynonymsRegExp(f)), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (f = this.setupIgnoreJoinersRegExp(f)), this.opt.diacritics && (f = this.createDiacriticsRegExp(f)), f = this.createMergedBlanksRegExp(f), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (f = this.createJoinersRegExp(f)), this.opt.wildcards !== "disabled" && (f = this.createWildcardsRegExp(f)), f = this.createAccuracyRegExp(f), f;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function(f) {
            var d = this.opt.synonyms, p = this.opt.caseSensitive ? "" : "i", m = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var y in d)
              if (d.hasOwnProperty(y)) {
                var b = d[y], v = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(y) : this.escapeStr(y), _ = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(b) : this.escapeStr(b);
                v !== "" && _ !== "" && (f = f.replace(new RegExp("(" + this.escapeStr(v) + "|" + this.escapeStr(_) + ")", "gm" + p), m + ("(" + this.processSynomyms(v) + "|") + (this.processSynomyms(_) + ")") + m));
              }
            return f;
          }
        }, {
          key: "processSynomyms",
          value: function(f) {
            return (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (f = this.setupIgnoreJoinersRegExp(f)), f;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function(f) {
            return f = f.replace(/(?:\\)*\?/g, function(d) {
              return d.charAt(0) === "\\" ? "?" : "";
            }), f.replace(/(?:\\)*\*/g, function(d) {
              return d.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function(f) {
            var d = this.opt.wildcards === "withSpaces";
            return f.replace(/\u0001/g, d ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, d ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function(f) {
            return f.replace(/[^(|)\\]/g, function(d, p, m) {
              var y = m.charAt(p + 1);
              return /[(|)\\]/.test(y) || y === "" ? d : d + "\0";
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function(f) {
            var d = [], p = this.opt.ignorePunctuation;
            return Array.isArray(p) && p.length && d.push(this.escapeStr(p.join(""))), this.opt.ignoreJoiners && d.push("\\u00ad\\u200b\\u200c\\u200d"), d.length ? f.split(/\u0000+/).join("[" + d.join("") + "]*") : f;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function(f) {
            var d = this.opt.caseSensitive ? "" : "i", p = this.opt.caseSensitive ? ["aÃ Ã¡áº£Ã£áº¡Äƒáº±áº¯áº³áºµáº·Ã¢áº§áº¥áº©áº«áº­Ã¤Ã¥ÄÄ…", "AÃ€Ãáº¢Ãƒáº Ä‚áº°áº®áº²áº´áº¶Ã‚áº¦áº¤áº¨áºªáº¬Ã„Ã…Ä€Ä„", "cÃ§Ä‡Ä", "CÃ‡Ä†ÄŒ", "dÄ‘Ä", "DÄÄŽ", "eÃ¨Ã©áº»áº½áº¹Ãªá»áº¿á»ƒá»…á»‡Ã«Ä›Ä“Ä™", "EÃˆÃ‰áººáº¼áº¸ÃŠá»€áº¾á»‚á»„á»†Ã‹ÄšÄ’Ä˜", "iÃ¬Ã­á»‰Ä©á»‹Ã®Ã¯Ä«", "IÃŒÃá»ˆÄ¨á»ŠÃŽÃÄª", "lÅ‚", "LÅ", "nÃ±ÅˆÅ„", "NÃ‘Å‡Åƒ", "oÃ²Ã³á»Ãµá»Ã´á»“á»‘á»•á»—á»™Æ¡á»Ÿá»¡á»›á»á»£Ã¶Ã¸Å", "OÃ’Ã“á»ŽÃ•á»ŒÃ”á»’á»á»”á»–á»˜Æ á»žá» á»šá»œá»¢Ã–Ã˜ÅŒ", "rÅ™", "RÅ˜", "sÅ¡Å›È™ÅŸ", "SÅ ÅšÈ˜Åž", "tÅ¥È›Å£", "TÅ¤ÈšÅ¢", "uÃ¹Ãºá»§Å©á»¥Æ°á»«á»©á»­á»¯á»±Ã»Ã¼Å¯Å«", "UÃ™Ãšá»¦Å¨á»¤Æ¯á»ªá»¨á»¬á»®á»°Ã›ÃœÅ®Åª", "yÃ½á»³á»·á»¹á»µÃ¿", "YÃá»²á»¶á»¸á»´Å¸", "zÅ¾Å¼Åº", "ZÅ½Å»Å¹"] : ["aÃ Ã¡áº£Ã£áº¡Äƒáº±áº¯áº³áºµáº·Ã¢áº§áº¥áº©áº«áº­Ã¤Ã¥ÄÄ…AÃ€Ãáº¢Ãƒáº Ä‚áº°áº®áº²áº´áº¶Ã‚áº¦áº¤áº¨áºªáº¬Ã„Ã…Ä€Ä„", "cÃ§Ä‡ÄCÃ‡Ä†ÄŒ", "dÄ‘ÄDÄÄŽ", "eÃ¨Ã©áº»áº½áº¹Ãªá»áº¿á»ƒá»…á»‡Ã«Ä›Ä“Ä™EÃˆÃ‰áººáº¼áº¸ÃŠá»€áº¾á»‚á»„á»†Ã‹ÄšÄ’Ä˜", "iÃ¬Ã­á»‰Ä©á»‹Ã®Ã¯Ä«IÃŒÃá»ˆÄ¨á»ŠÃŽÃÄª", "lÅ‚LÅ", "nÃ±ÅˆÅ„NÃ‘Å‡Åƒ", "oÃ²Ã³á»Ãµá»Ã´á»“á»‘á»•á»—á»™Æ¡á»Ÿá»¡á»›á»á»£Ã¶Ã¸ÅOÃ’Ã“á»ŽÃ•á»ŒÃ”á»’á»á»”á»–á»˜Æ á»žá» á»šá»œá»¢Ã–Ã˜ÅŒ", "rÅ™RÅ˜", "sÅ¡Å›È™ÅŸSÅ ÅšÈ˜Åž", "tÅ¥È›Å£TÅ¤ÈšÅ¢", "uÃ¹Ãºá»§Å©á»¥Æ°á»«á»©á»­á»¯á»±Ã»Ã¼Å¯Å«UÃ™Ãšá»¦Å¨á»¤Æ¯á»ªá»¨á»¬á»®á»°Ã›ÃœÅ®Åª", "yÃ½á»³á»·á»¹á»µÃ¿YÃá»²á»¶á»¸á»´Å¸", "zÅ¾Å¼ÅºZÅ½Å»Å¹"], m = [];
            return f.split("").forEach(function(y) {
              p.every(function(b) {
                if (b.indexOf(y) !== -1) {
                  if (m.indexOf(b) > -1)
                    return !1;
                  f = f.replace(new RegExp("[" + b + "]", "gm" + d), "[" + b + "]"), m.push(b);
                }
                return !0;
              });
            }), f;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function(f) {
            return f.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function(f) {
            var d = this, p = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~Â¡Â¿", m = this.opt.accuracy, y = typeof m == "string" ? m : m.value, b = typeof m == "string" ? [] : m.limiters, v = "";
            switch (b.forEach(function(_) {
              v += "|" + d.escapeStr(_);
            }), y) {
              case "partially":
              default:
                return "()(" + f + ")";
              case "complementary":
                return v = "\\s" + (v || this.escapeStr(p)), "()([^" + v + "]*" + f + "[^" + v + "]*)";
              case "exactly":
                return "(^|\\s" + v + ")(" + f + ")(?=$|\\s" + v + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function(f) {
            var d = this, p = [];
            return f.forEach(function(m) {
              d.opt.separateWordSearch ? m.split(" ").forEach(function(y) {
                y.trim() && p.indexOf(y) === -1 && p.push(y);
              }) : m.trim() && p.indexOf(m) === -1 && p.push(m);
            }), {
              keywords: p.sort(function(m, y) {
                return y.length - m.length;
              }),
              length: p.length
            };
          }
        }, {
          key: "isNumeric",
          value: function(f) {
            return Number(parseFloat(f)) == f;
          }
        }, {
          key: "checkRanges",
          value: function(f) {
            var d = this;
            if (!Array.isArray(f) || Object.prototype.toString.call(f[0]) !== "[object Object]")
              return this.log("markRanges() will only accept an array of objects"), this.opt.noMatch(f), [];
            var p = [], m = 0;
            return f.sort(function(y, b) {
              return y.start - b.start;
            }).forEach(function(y) {
              var b = d.callNoMatchOnInvalidRanges(y, m), v = b.start, _ = b.end, k = b.valid;
              k && (y.start = v, y.length = _ - v, p.push(y), m = _);
            }), p;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function(f, d) {
            var p = void 0, m = void 0, y = !1;
            return f && typeof f.start < "u" ? (p = parseInt(f.start, 10), m = p + parseInt(f.length, 10), this.isNumeric(f.start) && this.isNumeric(f.length) && m - d > 0 && m - p > 0 ? y = !0 : (this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(f))), this.opt.noMatch(f))) : (this.log("Ignoring invalid range: " + JSON.stringify(f)), this.opt.noMatch(f)), {
              start: p,
              end: m,
              valid: y
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function(f, d, p) {
            var m = void 0, y = !0, b = p.length, v = d - b, _ = parseInt(f.start, 10) - v;
            return _ = _ > b ? b : _, m = _ + parseInt(f.length, 10), m > b && (m = b, this.log("End range automatically set to the max value of " + b)), _ < 0 || m - _ < 0 || _ > b || m > b ? (y = !1, this.log("Invalid range: " + JSON.stringify(f)), this.opt.noMatch(f)) : p.substring(_, m).replace(/\s+/g, "") === "" && (y = !1, this.log("Skipping whitespace only range: " + JSON.stringify(f)), this.opt.noMatch(f)), {
              start: _,
              end: m,
              valid: y
            };
          }
        }, {
          key: "getTextNodes",
          value: function(f) {
            var d = this, p = "", m = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(y) {
              m.push({
                start: p.length,
                end: (p += y.textContent).length,
                node: y
              });
            }, function(y) {
              return d.matchesExclude(y.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, function() {
              f({
                value: p,
                nodes: m
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function(f) {
            return o.matches(f, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function(f, d, p) {
            var m = this.opt.element ? this.opt.element : "mark", y = f.splitText(d), b = y.splitText(p - d), v = document.createElement(m);
            return v.setAttribute("data-markjs", "true"), this.opt.className && v.setAttribute("class", this.opt.className), v.textContent = y.textContent, y.parentNode.replaceChild(v, y), b;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function(f, d, p, m, y) {
            var b = this;
            f.nodes.every(function(v, _) {
              var k = f.nodes[_ + 1];
              if (typeof k > "u" || k.start > d) {
                if (!m(v.node))
                  return !1;
                var S = d - v.start, C = (p > v.end ? v.end : p) - v.start, E = f.value.substr(0, v.start), A = f.value.substr(C + v.start);
                if (v.node = b.wrapRangeInTextNode(v.node, S, C), f.value = E + A, f.nodes.forEach(function(O, T) {
                  T >= _ && (f.nodes[T].start > 0 && T !== _ && (f.nodes[T].start -= C), f.nodes[T].end -= C);
                }), p -= C, y(v.node.previousSibling, v.start), p > v.end)
                  d = v.end;
                else
                  return !1;
              }
              return !0;
            });
          }
        }, {
          key: "wrapMatches",
          value: function(f, d, p, m, y) {
            var b = this, v = d === 0 ? 0 : d + 1;
            this.getTextNodes(function(_) {
              _.nodes.forEach(function(k) {
                k = k.node;
                for (var S = void 0; (S = f.exec(k.textContent)) !== null && S[v] !== ""; )
                  if (p(S[v], k)) {
                    var C = S.index;
                    if (v !== 0)
                      for (var E = 1; E < v; E++)
                        C += S[E].length;
                    k = b.wrapRangeInTextNode(k, C, C + S[v].length), m(k.previousSibling), f.lastIndex = 0;
                  }
              }), y();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function(f, d, p, m, y) {
            var b = this, v = d === 0 ? 0 : d + 1;
            this.getTextNodes(function(_) {
              for (var k = void 0; (k = f.exec(_.value)) !== null && k[v] !== ""; ) {
                var S = k.index;
                if (v !== 0)
                  for (var C = 1; C < v; C++)
                    S += k[C].length;
                var E = S + k[v].length;
                b.wrapRangeInMappedTextNode(_, S, E, function(A) {
                  return p(k[v], A);
                }, function(A, O) {
                  f.lastIndex = O, m(A);
                });
              }
              y();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function(f, d, p, m) {
            var y = this;
            this.getTextNodes(function(b) {
              var v = b.value.length;
              f.forEach(function(_, k) {
                var S = y.checkWhitespaceRanges(_, v, b.value), C = S.start, E = S.end, A = S.valid;
                A && y.wrapRangeInMappedTextNode(b, C, E, function(O) {
                  return d(O, _, b.value.substring(C, E), k);
                }, function(O) {
                  p(O, _);
                });
              }), m();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function(f) {
            for (var d = f.parentNode, p = document.createDocumentFragment(); f.firstChild; )
              p.appendChild(f.removeChild(f.firstChild));
            d.replaceChild(p, f), this.ie ? this.normalizeTextNode(d) : d.normalize();
          }
        }, {
          key: "normalizeTextNode",
          value: function(f) {
            if (f) {
              if (f.nodeType === 3)
                for (; f.nextSibling && f.nextSibling.nodeType === 3; )
                  f.nodeValue += f.nextSibling.nodeValue, f.parentNode.removeChild(f.nextSibling);
              else
                this.normalizeTextNode(f.firstChild);
              this.normalizeTextNode(f.nextSibling);
            }
          }
        }, {
          key: "markRegExp",
          value: function(f, d) {
            var p = this;
            this.opt = d, this.log('Searching with expression "' + f + '"');
            var m = 0, y = "wrapMatches", b = function(_) {
              m++, p.opt.each(_);
            };
            this.opt.acrossElements && (y = "wrapMatchesAcrossElements"), this[y](f, this.opt.ignoreGroups, function(v, _) {
              return p.opt.filter(_, v, m);
            }, b, function() {
              m === 0 && p.opt.noMatch(f), p.opt.done(m);
            });
          }
        }, {
          key: "mark",
          value: function(f, d) {
            var p = this;
            this.opt = d;
            var m = 0, y = "wrapMatches", b = this.getSeparatedKeywords(typeof f == "string" ? [f] : f), v = b.keywords, _ = b.length, k = this.opt.caseSensitive ? "" : "i", S = function C(E) {
              var A = new RegExp(p.createRegExp(E), "gm" + k), O = 0;
              p.log('Searching with expression "' + A + '"'), p[y](A, 1, function(T, $) {
                return p.opt.filter($, E, m, O);
              }, function(T) {
                O++, m++, p.opt.each(T);
              }, function() {
                O === 0 && p.opt.noMatch(E), v[_ - 1] === E ? p.opt.done(m) : C(v[v.indexOf(E) + 1]);
              });
            };
            this.opt.acrossElements && (y = "wrapMatchesAcrossElements"), _ === 0 ? this.opt.done(m) : S(v[0]);
          }
        }, {
          key: "markRanges",
          value: function(f, d) {
            var p = this;
            this.opt = d;
            var m = 0, y = this.checkRanges(f);
            y && y.length ? (this.log("Starting to mark with the following ranges: " + JSON.stringify(y)), this.wrapRangeFromIndex(y, function(b, v, _, k) {
              return p.opt.filter(b, v, _, k);
            }, function(b, v) {
              m++, p.opt.each(b, v);
            }, function() {
              p.opt.done(m);
            })) : this.opt.done(m);
          }
        }, {
          key: "unmark",
          value: function(f) {
            var d = this;
            this.opt = f;
            var p = this.opt.element ? this.opt.element : "*";
            p += "[data-markjs]", this.opt.className && (p += "." + this.opt.className), this.log('Removal selector "' + p + '"'), this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(m) {
              d.unwrapMatches(m);
            }, function(m) {
              var y = o.matches(m, p), b = d.matchesExclude(m);
              return !y || b ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function(f) {
            this._opt = s({}, {
              element: "",
              className: "",
              exclude: [],
              iframes: !1,
              iframesTimeout: 5e3,
              separateWordSearch: !0,
              diacritics: !0,
              synonyms: {},
              accuracy: "partially",
              acrossElements: !1,
              caseSensitive: !1,
              ignoreJoiners: !1,
              ignoreGroups: 0,
              ignorePunctuation: [],
              wildcards: "disabled",
              each: function() {
              },
              noMatch: function() {
              },
              filter: function() {
                return !0;
              },
              done: function() {
              },
              debug: !1,
              log: window.console
            }, f);
          },
          get: function() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function() {
            return new o(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]), u;
      })();
      function a(u) {
        var c = this, f = new l(u);
        return this.mark = function(d, p) {
          return f.mark(d, p), c;
        }, this.markRegExp = function(d, p) {
          return f.markRegExp(d, p), c;
        }, this.markRanges = function(d, p) {
          return f.markRanges(d, p), c;
        }, this.unmark = function(d) {
          return f.unmark(d), c;
        }, this;
      }
      return a;
    }));
  })(ib)), ib.exports;
}
var bke = yke();
const vke = /* @__PURE__ */ zf(bke);
var xke = /* @__PURE__ */ ge('<div class="flex pb-1 text-sm"><span class="px-2 flex gap-2 bg-slate-200 text-slate-500 dark:bg-slate-600 dark:text-slate-300 rounded-md"><div class="text-slate-400 dark:text-slate-400 font-medium">Distance</div> <div class="text-ellipsis whitespace-nowrap overflow-hidden max-w-72"> </div></span></div>'), wke = /* @__PURE__ */ ge('<button class="m-1 p-2 text-left rounded-md hover:outline outline-slate-500"><!> <div class="overflow-hidden text-ellipsis line-clamp-4 leading-5"><!></div></button> <hr class="border-slate-300 dark:border-slate-600"/>', 1), _ke = /* @__PURE__ */ ge('<div class="flex flex-col w-full h-full"><div class="ml-3 mr-2 my-1 flex items-center text-slate-400 dark:text-slate-500 items-start"><div class="flex-1"><div> </div> <div> </div></div> <div class="flex-none mt-1"><button class="block hover:text-slate-500 dark:hover:text-slate-400"><!></button></div></div> <hr class="border-slate-300 dark:border-slate-600"/> <div class="flex flex-col overflow-x-hidden overflow-y-scroll"></div></div>');
function kke(t, e) {
  it(e, !0);
  let n = ct(e, "limit", 3, 100);
  function r(b, v) {
    new vke(b).mark(v);
  }
  let i = /* @__PURE__ */ K(() => e.items.length == 0 ? "No result found." : e.items.length == 1 ? `${e.items.length.toLocaleString()} result.` : e.items.length >= n() ? `More than ${e.items.length.toLocaleString()} results, showing top ${n().toLocaleString()}.` : `${e.items.length.toLocaleString()} results.`);
  var s = _ke(), o = J(s), l = J(o), a = J(l), u = J(a, !0);
  Q(a);
  var c = ue(a, 2), f = J(c, !0);
  Q(c), Q(l);
  var d = ue(l, 2), p = J(d);
  p.__click = () => {
    e.onClose?.();
  };
  var m = J(p);
  _2(m, {}), Q(p), Q(d), Q(o);
  var y = ue(o, 4);
  Bt(y, 20, () => e.items, (b) => b, (b, v) => {
    var _ = wke(), k = We(_);
    k.__click = () => {
      e.onClick?.(v);
    };
    var S = J(k);
    {
      var C = (O) => {
        var T = xke(), $ = J(T), P = ue(J($), 2), B = J(P, !0);
        Q(P), Q($), Q(T), ke((M) => ut(B, M), [() => v.distance.toFixed(5)]), X(O, T);
      };
      Fe(S, (O) => {
        v.distance != null && O(C);
      });
    }
    var E = ue(S, 2), A = J(E);
    {
      let O = /* @__PURE__ */ K(() => e.columnStyles ?? {});
      G$(A, {
        get values() {
          return v.fields;
        },
        get columnStyles() {
          return x(O);
        }
      });
    }
    Q(E), Ts(E, (O, T) => r?.(O, T), () => e.highlight), Q(k), Vk(2), X(b, _);
  }), Q(y), Q(s), ke(() => {
    ut(u, e.label), ut(f, x(i));
  }), X(t, s), st();
}
ir(["click"]);
var Cke = /* @__PURE__ */ Dt('<svg><path fill="currentColor" d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z" opacity=".25"></path><path fill="currentColor" d="M10.72,19.9a8,8,0,0,1-6.5-9.79A7.77,7.77,0,0,1,10.4,4.16a8,8,0,0,1,9.49,6.52A1.54,1.54,0,0,0,21.38,12h.13a1.37,1.37,0,0,0,1.38-1.54,11,11,0,1,0-12.7,12.39A1.54,1.54,0,0,0,12,21.34h0A1.47,1.47,0,0,0,10.72,19.9Z"><animateTransform attributeName="transform" dur="0.75s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"></animateTransform></path></svg>');
function cj(t, e) {
  const n = /* @__PURE__ */ zr(e, ["$$slots", "$$events", "$$legacy"]);
  var r = Cke();
  Ys(r, () => ({ viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ...n })), X(t, r);
}
function xF(t, e) {
  it(e, !0);
  let n = ct(e, "label", 3, null), r = ct(e, "icon", 3, null), i = ct(e, "title", 3, ""), s = ct(e, "order", 3, null), o = /* @__PURE__ */ Ee("ready");
  async function l() {
    if (e.onClick) {
      ae(o, "running");
      try {
        await e.onClick(), ae(o, "ready");
      } catch {
        ae(o, "error");
      }
    }
  }
  {
    let a = /* @__PURE__ */ K(() => x(o) == "ready" ? r() : x(o) == "running" ? cj : _2);
    Tu(t, {
      get label() {
        return n();
      },
      get icon() {
        return x(a);
      },
      get title() {
        return i();
      },
      get order() {
        return s();
      },
      get class() {
        return e.class;
      },
      onClick: l
    });
  }
  st();
}
var Ske = /* @__PURE__ */ ge('<span class="pl-2 text-slate-500 dark:text-slate-500"> </span>'), Ake = /* @__PURE__ */ ge('<div role="status" class="flex flex-row items-center"><!> <!></div>');
function Eke(t, e) {
  let n = ct(e, "status", 3, "Loading...");
  var r = Ake(), i = J(r);
  cj(i, { class: "text-blue-500" });
  var s = ue(i, 2);
  {
    var o = (l) => {
      var a = Ske(), u = J(a, !0);
      Q(a), ke(() => ut(u, n())), X(l, a);
    };
    Fe(s, (l) => {
      n() != null && l(o);
    });
  }
  Q(r), X(t, r);
}
class Dke {
  contents;
  constructor() {
    this.contents = /* @__PURE__ */ new Map();
  }
  get(e) {
    return this.contents.get(e) ?? null;
  }
  set(e, n) {
    this.contents.set(e, n);
  }
  value(e, n) {
    if (this.contents.has(e))
      return this.contents.get(e);
    const r = n();
    return this.contents.set(e, r), r;
  }
}
async function Oke(t, e, n, r = {}) {
  let i = r.exclude ?? [], s = (await O$(t, e)).filter((l) => !l.name.startsWith("__")), o = [];
  r?.projection != null && o.push({
    type: "embedding",
    title: "Embedding",
    data: {
      x: r.projection.x,
      y: r.projection.y,
      text: r.projection.text
    }
  }), o.push({ type: "predicates", title: "SQL Predicates" }), o.push({ type: "table", title: "Table", columns: s.map((l) => l.name) });
  for (let l of s) {
    if (l.jsType == null || i.indexOf(l.name) >= 0)
      continue;
    let a = await F$(t, e, l.name);
    if (!(a <= 1))
      switch (l.jsType) {
        case "string":
          a <= 1e3 && o.push({
            type: "count-plot",
            title: l.name,
            data: { field: l.name }
          });
          break;
        case "string[]":
          o.push({
            type: "count-plot-list",
            title: l.name,
            data: { field: l.name }
          });
          break;
        case "number":
          a <= 10 ? o.push({
            type: "count-plot",
            title: l.name,
            data: { field: l.name }
          }) : o.push({
            type: "histogram",
            title: l.name,
            data: { field: l.name },
            binCount: 20
          });
          break;
      }
  }
  return o;
}
const wF = "0.12.0";
class Fke {
  worker;
  callbacks;
  constructor() {
    this.worker = new Worker(new URL("./search.worker.js", import.meta.url), { type: "module" }), this.callbacks = /* @__PURE__ */ new Map(), this.worker.onmessage = (e) => {
      let n = this.callbacks.get(e.data.identifier);
      n != null && (this.callbacks.delete(e.data.identifier), n(e.data));
    };
  }
  rpc(e) {
    return new Promise((n, r) => {
      let i = (/* @__PURE__ */ new Date()).getTime() + "-" + Math.random();
      this.callbacks.set(i, n), this.worker.postMessage({ ...e, identifier: i });
    });
  }
  async clear() {
    await this.rpc({ type: "clear" });
  }
  async addPoints(e) {
    await this.rpc({ type: "points", points: e });
  }
  async query(e, n) {
    return (await this.rpc({ type: "query", query: e, limit: n })).result;
  }
}
class Tke {
  coordinator;
  table;
  columns;
  backend;
  currentIndex = null;
  constructor(e, n, r) {
    this.coordinator = e, this.table = n, this.columns = r, this.currentIndex = null, this.backend = new Fke();
  }
  predicateString(e) {
    return e != null && e.toString() != "" ? e.toString() : null;
  }
  async buildIndexIfNeeded(e) {
    let n = this.predicateString(e);
    if (this.currentIndex != null && this.currentIndex.predicate == n)
      return;
    let r;
    n != null ? r = await this.coordinator.query(`
        SELECT
          ${R.column(this.columns.id)} AS id,
          ${R.column(this.columns.text)} AS text
        FROM ${this.table}
        WHERE ${n}
      `) : r = await this.coordinator.query(`
        SELECT
          ${R.column(this.columns.id)} AS id,
          ${R.column(this.columns.text)} AS text
        FROM ${this.table}
      `), await this.backend.clear(), await this.backend.addPoints(Array.from(r)), this.currentIndex = { predicate: n };
  }
  async fullTextSearch(e, n = {}) {
    let r = n.limit ?? 100, i = n.predicate;
    return await this.buildIndexIfNeeded(i), (await this.backend.query(e, r)).map((o) => ({ id: o }));
  }
}
async function Rke(t, e, n, r, i, s) {
  let o = [`${R.column(n.id, e)} AS id`];
  n.x && o.push(`${R.column(n.x, e)} AS x`), n.y && o.push(`${R.column(n.y, e)} AS y`), n.text && o.push(`${R.column(n.text, e)} AS text`);
  let l = r ?? {};
  for (let p in l) {
    let m = l[p];
    typeof m == "string" ? o.push(`${R.column(m, e)} AS "field_${p}"`) : o.push(`${R.sql(m.sql)} AS "field_${p}"`);
  }
  let a = s.map((p) => p.id), u = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
  for (let p = 0; p < a.length; p++)
    u.set(a[p], p), c.set(a[p], s[p]);
  let f = await t.query(`
    SELECT
      ${o.join(", ")}
    FROM (
      SELECT ${R.column(n.id, e)} AS __search_result_id__
      FROM ${e}
      WHERE
        ${R.column(n.id, e)} IN [${a.map((p) => R.literal(p)).join(", ")}]
        ${i ? `AND (${i})` : ""}
    )
    LEFT JOIN ${e} ON ${R.column(n.id, e)} = __search_result_id__
  `), d = Array.from(f).map((p) => {
    let m = { id: p.id, distance: c.get(p.id)?.distance, fields: {} };
    for (let y in p)
      y.startsWith("field_") ? m.fields[y.substring(6)] = p[y] : m[y] = p[y];
    return m;
  });
  return d = d.sort((p, m) => (u.get(p.id) ?? 0) - (u.get(m.id) ?? 0)), d;
}
function Mke(t) {
  let { coordinator: e, table: n, idColumn: r, searcher: i, textColumn: s, neighborsColumn: o } = t, l = {};
  if (i != null && i.fullTextSearch != null)
    l.fullTextSearch = i.fullTextSearch.bind(i);
  else if (s != null) {
    let a = new Tke(e, n, { id: r, text: s });
    l.fullTextSearch = a.fullTextSearch.bind(a);
  }
  return i != null && i.vectorSearch != null && (l.vectorSearch = i.vectorSearch.bind(i)), i != null && i.nearestNeighbors != null ? l.nearestNeighbors = i.nearestNeighbors.bind(i) : o != null && (l.nearestNeighbors = async (a) => {
    let u = R.Query.from(n).select({ knn: R.column(o) }).where(R.eq(R.column(r), R.literal(a))), c = await e.query(u), f = Array.from(c);
    if (f.length != 1)
      return [];
    let { distances: d, ids: p } = f[0].knn;
    return Array.from(p).map((y, b) => ({ id: y, distance: d[b] })).filter((y) => y.id != a);
  }), l;
}
let fj = typeof window < "u" ? window.matchMedia?.("(prefers-color-scheme: dark)") : null, hj = qh(fj?.matches ? "dark" : "light");
fj?.addEventListener("change", (t) => {
  hj.set(t.matches ? "dark" : "light");
});
function Pke() {
  let t = qh(null);
  return { colorScheme: eX([hj, t], ([n, r]) => r ?? n), userColorScheme: t };
}
var Ike = /* @__PURE__ */ ge('<div class="p-2"><!></div>'), Nke = /* @__PURE__ */ ge('<div class="absolute w-96 left-0 top-[32px] rounded-md right-0 z-20 border border-slate-300 dark:border-slate-600 overflow-hidden resize shadow-lg bg-white/75 dark:bg-slate-800/75 backdrop-blur-sm"><!></div>'), Bke = /* @__PURE__ */ ge('<div class="relative w-full"><!> <!> <!></div>'), Lke = /* @__PURE__ */ ge('<div class="text-slate-500 dark:text-slate-400">Embedding Atlas</div>'), $ke = /* @__PURE__ */ ge('<h4 class="text-slate-500 dark:text-slate-400 select-none">Column Styles</h4> <!>', 1), zke = /* @__PURE__ */ ge('<div class="flex flex-row gap-2"><!> <!></div>'), jke = /* @__PURE__ */ ge('<div class="min-w-[420px] flex flex-col gap-2"><!> <h4 class="text-slate-500 dark:text-slate-400 select-none">Export</h4> <div class="flex flex-col gap-2"><!> <!></div> <h4 class="text-slate-500 dark:text-slate-400 select-none">About</h4> <div> </div></div>'), qke = /* @__PURE__ */ ge('<div class="embedding-atlas-root"><div><div class="m-2 flex flex-row items-center gap-2 flex-wrap"><div class="flex flex-row flex-1 justify-between min-w-[180px]"><!></div> <div class="flex flex-none gap-2 items-center"><!> <div class="flex flex-row gap-1 items-center"><button class="flex px-2.5 mr-1 select-none items-center justify-center text-slate-500 dark:text-slate-300 rounded-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 focus-visible:outline-2 outline-blue-600 -outline-offset-1" title="Clear filters">Clear</button></div></div> <div class="flex flex-none flex-row gap-0.5"><!> <!> <!></div></div> <div class="flex-1 overflow-hidden h-full ml-2 mr-2 mb-2"><!></div></div></div>');
function Uke(t, e) {
  it(e, !0);
  const n = () => gi(u, "$colorScheme", i), r = () => gi(v, "$resolvedColumnStyles", i), [i, s] = Xs(), o = 500;
  let l = ct(e, "embeddingViewConfig", 3, null), a = ct(e, "embeddingViewLabels", 3, null);
  const { colorScheme: u, userColorScheme: c } = Pke();
  pt(() => {
    _A(c, e.colorScheme);
  });
  let f = /* @__PURE__ */ Ee(!1), d = /* @__PURE__ */ Ee("parquet");
  const p = vK.crossfilter();
  function m() {
    return D$(p.predicate(null));
  }
  let y = /* @__PURE__ */ Ee([]), b = /* @__PURE__ */ Ee({}), v = qh({});
  pt(() => {
    let Te = _(x(y), x(b));
    v.set(Te);
  });
  function _(Te, Oe) {
    let et = {};
    for (let kt of Te) {
      let tn = Oe[kt.name];
      tn == null && (tn = { display: e.data.text == kt.name ? "full" : "badge" }), et[kt.name] = tn;
    }
    return et;
  }
  let k = Mke({
    coordinator: e.coordinator,
    table: e.data.table,
    idColumn: e.data.id,
    textColumn: e.data.text,
    neighborsColumn: e.data.neighbors,
    searcher: e.searcher
  }), S = [
    ...k.fullTextSearch != null ? ["full-text"] : [],
    ...k.vectorSearch != null ? ["vector"] : [],
    ...k.nearestNeighbors != null ? ["neighbors"] : []
  ];
  const C = {
    "full-text": { value: "full-text", label: "Full Text" },
    vector: { value: "vector", label: "Vector" },
    neighbors: { value: "neighbors", label: "Neighbors" }
  };
  let E = /* @__PURE__ */ Ee("full-text"), A = /* @__PURE__ */ Ee(""), O = /* @__PURE__ */ Ee(""), T = /* @__PURE__ */ Ee(!1), $ = /* @__PURE__ */ Ee(null), P = qh(null);
  async function B(Te, Oe) {
    if (k == null || S.indexOf(Oe) < 0) {
      L();
      return;
    }
    ae(T, !0), ae(O, "Searching...");
    let et = m(), kt = [], tn = "", Tn = Te.toString();
    Oe == "full-text" && k.fullTextSearch != null ? (Te = Te.trim(), kt = await k.fullTextSearch(Te, {
      limit: o,
      predicate: et,
      onStatus: (Je) => {
        ae(O, Je, !0);
      }
    }), tn = Te) : Oe == "vector" && k.vectorSearch != null ? (Te = Te.trim(), kt = await k.vectorSearch(Te, {
      limit: o,
      predicate: et,
      onStatus: (Je) => {
        ae(O, Je, !0);
      }
    }), tn = Te) : Oe == "neighbors" && k.nearestNeighbors != null && (Tn = "Neighbors of #" + Te.toString(), kt = await k.nearestNeighbors(Te, {
      limit: o,
      predicate: et,
      onStatus: (Je) => {
        ae(O, Je, !0);
      }
    }));
    let Gt = await Rke(
      e.coordinator,
      e.data.table,
      {
        id: e.data.id,
        x: e.data.projection?.x,
        y: e.data.projection?.y,
        text: e.data.text
      },
      Object.fromEntries(x(y).map((Je) => [Je.name, Je.name])),
      et,
      kt
    );
    ae(O, ""), ae($, { label: Tn, highlight: tn, items: Gt }), P.set({ query: Te, mode: Oe, ids: Gt.map((Je) => Je.id) });
  }
  const M = yK(B, 500);
  function L() {
    ae($, null), P.set(null), ae(T, !1);
  }
  pt(() => {
    x(A) == "" ? L() : M(x(A), x(E));
  });
  function N() {
    for (let Te of p.clauses)
      Te.source?.reset?.(), p.update({ ...Te, value: null, predicate: null });
  }
  function j(Te) {
    typeof Te.version == "string" && (ae(G, Te.charts ?? {}), ae(re, Te.chartStates ?? {}), ae(se, Te.layout ?? "list"), ae(oe, Te.layoutStates ?? {}));
  }
  Vo(() => {
    if (!x(f))
      return;
    let Te = {
      version: wF,
      timestamp: (/* @__PURE__ */ new Date()).getTime() / 1e3,
      charts: x(G),
      chartStates: x(re),
      layout: x(se),
      layoutStates: x(oe),
      predicate: m()
    };
    e.onStateChange?.(Te);
  }), Kg(async () => {
    let Te = [e.data.projection?.x, e.data.projection?.y].filter((Oe) => Oe != null);
    if (ae(y, (await O$(e.coordinator, e.data.table)).filter((Oe) => !Oe.name.startsWith("__"))), H.columns = x(y), e.initialState && j(e.initialState), Object.keys(x(G)).length == 0) {
      let Oe = await Oke(e.coordinator, e.data.table, e.data.id, {
        exclude: Te,
        projection: e.data.projection ? {
          ...e.data.projection,
          text: e.data.text ?? void 0
        } : void 0
      });
      ae(G, Object.fromEntries(Oe.map((et, kt) => [`${kt + 1}`, et])));
    }
    ae(f, !0);
  });
  function U(Te) {
    if (Te.key == "Escape") {
      N(), Te.preventDefault();
      try {
        document.activeElement?.blur?.();
      } catch {
      }
    }
  }
  let H = {
    coordinator: e.coordinator,
    filter: p,
    table: e.data.table,
    id: e.data.id,
    columns: [],
    colorScheme: u,
    columnStyles: v,
    cache: new Dke(),
    persistentCache: e.cache ?? { get: async () => null, set: async (Te, Oe) => {
    } },
    searchModes: S,
    search: B,
    searchResult: P,
    highlight: qh(null),
    embeddingViewConfig: l(),
    embeddingViewLabels: a(),
    tableCellRenderers: e.tableCellRenderers
  }, G = /* @__PURE__ */ Ee({}), re = /* @__PURE__ */ Ee({}), se = /* @__PURE__ */ Ee("list"), oe = /* @__PURE__ */ Ee({});
  var ne = qke();
  SY("keydown", y_, U), ht(ne, "", {}, { width: "100%", height: "100%" });
  var ce = J(ne);
  let we, Me;
  var Pe = J(ce), Ce = J(Pe), fe = J(Ce);
  {
    var De = (Te) => {
      var Oe = Bke(), et = J(Oe);
      R$(et, {
        type: "search",
        placeholder: "Search...",
        className: "w-full max-w-[400px] ",
        get value() {
          return x(A);
        },
        set value(Je) {
          ae(A, Je, !0);
        }
      });
      var kt = ue(et, 2);
      {
        var tn = (Je) => {
          {
            let gn = /* @__PURE__ */ K(() => S.filter((tr) => tr != "neighbors").map((tr) => C[tr]));
            Of(Je, {
              get options() {
                return x(gn);
              },
              get value() {
                return x(E);
              },
              onChange: (tr) => ae(E, tr, !0)
            });
          }
        };
        Fe(kt, (Je) => {
          S.filter((gn) => gn != "neighbors").length > 1 && Je(tn);
        });
      }
      var Tn = ue(kt, 2);
      {
        var Gt = (Je) => {
          var gn = Nke();
          ht(gn, "", {}, { height: "48em" });
          var tr = J(gn);
          {
            var xi = (qn) => {
              kke(qn, {
                get items() {
                  return x($).items;
                },
                get label() {
                  return x($).label;
                },
                get highlight() {
                  return x($).highlight;
                },
                limit: o,
                onClick: async (qr) => {
                  H.highlight.set(qr.id);
                },
                onClose: L,
                get columnStyles() {
                  return r();
                }
              });
            }, pa = (qn) => {
              var qr = kn(), ys = We(qr);
              {
                var al = (So) => {
                  var Ao = Ike(), xc = J(Ao);
                  Eke(xc, {
                    get status() {
                      return x(O);
                    }
                  }), Q(Ao), X(So, Ao);
                };
                Fe(
                  ys,
                  (So) => {
                    x(O) != null && So(al);
                  },
                  !0
                );
              }
              X(qn, qr);
            };
            Fe(tr, (qn) => {
              x($) != null ? qn(xi) : qn(pa, !1);
            });
          }
          Q(gn), X(Je, gn);
        };
        Fe(Tn, (Je) => {
          x(T) && Je(Gt);
        });
      }
      Q(Oe), X(Te, Oe);
    }, Se = (Te) => {
      var Oe = Lke();
      X(Te, Oe);
    };
    Fe(fe, (Te) => {
      k ? Te(De) : Te(Se, !1);
    });
  }
  Q(Ce);
  var Ne = ue(Ce, 2), Ye = J(Ne);
  gke(Ye, {
    get coordinator() {
      return e.coordinator;
    },
    get filter() {
      return p;
    },
    get table() {
      return e.data.table;
    }
  });
  var Ge = ue(Ye, 2), gt = J(Ge);
  gt.__click = N, Q(Ge), Q(Ne);
  var Pt = ue(Ne, 2), mt = J(Pt);
  sz(mt, {
    get icon() {
      return LB;
    },
    title: "Options",
    children: (Te, Oe) => {
      var et = jke(), kt = J(et);
      {
        var tn = (qn) => {
          var qr = $ke(), ys = ue(We(qr), 2);
          dke(ys, {
            get columns() {
              return x(y);
            },
            get styles() {
              return r();
            },
            onStylesChange: (al) => {
              ae(b, al);
            }
          }), X(qn, qr);
        };
        Fe(kt, (qn) => {
          x(y).length > 0 && qn(tn);
        });
      }
      var Tn = ue(kt, 4), Gt = J(Tn);
      {
        var Je = (qn) => {
          var qr = zke(), ys = J(qr);
          xF(ys, {
            get icon() {
              return u9;
            },
            label: "Export Selection",
            title: "Export the selected points",
            class: "w-48",
            onClick: () => e.onExportSelection(m(), x(d))
          });
          var al = ue(ys, 2);
          Of(al, {
            label: "Format",
            get value() {
              return x(d);
            },
            onChange: (So) => ae(d, So, !0),
            options: [
              { value: "parquet", label: "Parquet" },
              { value: "jsonl", label: "JSONL" },
              { value: "json", label: "JSON" },
              { value: "csv", label: "CSV" }
            ]
          }), Q(qr), X(qn, qr);
        };
        Fe(Gt, (qn) => {
          e.onExportSelection && qn(Je);
        });
      }
      var gn = ue(Gt, 2);
      {
        var tr = (qn) => {
          xF(qn, {
            get icon() {
              return u9;
            },
            label: "Export Application",
            title: "Download a self-contained static web application",
            class: "w-48",
            get onClick() {
              return e.onExportApplication;
            }
          });
        };
        Fe(gn, (qn) => {
          e.onExportApplication && qn(tr);
        });
      }
      Q(Tn);
      var xi = ue(Tn, 4), pa = J(xi);
      Q(xi), Q(et), ke(() => ut(pa, `Embedding Atlas, ${wF}`)), X(Te, et);
    },
    $$slots: { default: !0 }
  });
  var Wt = ue(mt, 2);
  {
    var un = (Te) => {
      {
        let Oe = /* @__PURE__ */ K(() => n() == "dark" ? G0e : V0e);
        Tu(Te, {
          get icon() {
            return x(Oe);
          },
          title: "Toggle dark mode",
          onClick: () => {
            _A(c, n() == "light" ? "dark" : "light");
          }
        });
      }
    };
    Fe(Wt, (Te) => {
      e.colorScheme == null && Te(un);
    });
  }
  var Ke = ue(Wt, 2);
  mpe(Ke, {
    get context() {
      return H;
    },
    get charts() {
      return x(G);
    },
    get chartStates() {
      return x(re);
    },
    get layout() {
      return x(se);
    },
    get layoutStates() {
      return x(oe);
    },
    onChartsChange: (Te) => ae(G, Te),
    onChartStatesChange: (Te) => ae(re, Te),
    onLayoutStatesChange: (Te) => ae(oe, Te)
  }), Q(Pt), Q(Pe);
  var Ze = ue(Pe, 2), It = J(Ze);
  {
    var vn = (Te) => {
      uke(Te, {
        get context() {
          return H;
        },
        get layout() {
          return x(se);
        },
        get layoutStates() {
          return x(oe);
        },
        get charts() {
          return x(G);
        },
        get chartStates() {
          return x(re);
        },
        onChartsChange: (Oe) => ae(G, Oe),
        onChartStatesChange: (Oe) => ae(re, Oe),
        onLayoutStatesChange: (Oe) => ae(oe, Oe)
      });
    };
    Fe(It, (Te) => {
      x(f) && Te(vn);
    });
  }
  Q(Ze), Q(ce), Q(ne), ke(() => {
    we = er(ce, 1, "w-full h-full flex flex-col text-slate-800 bg-slate-200 dark:text-slate-200 dark:bg-slate-800", null, we, { dark: n() == "dark" }), Me = ht(ce, "", Me, { "color-scheme": n() });
  }), X(t, ne), st(), s();
}
ir(["click"]);
const Hke = `@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-ease:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-400:oklch(70.4% .191 22.216);--color-red-600:oklch(57.7% .245 27.325);--color-orange-500:oklch(70.5% .213 47.604);--color-orange-700:oklch(55.3% .195 38.402);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-800:oklch(42.4% .199 265.638);--color-blue-900:oklch(37.9% .146 265.522);--color-blue-950:oklch(28.2% .091 267.935);--color-slate-50:oklch(98.4% .003 247.858);--color-slate-100:oklch(96.8% .007 247.896);--color-slate-200:oklch(92.9% .013 255.508);--color-slate-300:oklch(86.9% .022 252.894);--color-slate-400:oklch(70.4% .04 256.788);--color-slate-500:oklch(55.4% .046 257.417);--color-slate-600:oklch(44.6% .043 257.281);--color-slate-700:oklch(37.2% .044 257.287);--color-slate-800:oklch(27.9% .041 260.031);--color-slate-900:oklch(20.8% .042 265.755);--color-slate-950:oklch(12.9% .042 264.695);--color-gray-200:oklch(92.8% .006 264.531);--color-gray-300:oklch(87.2% .01 258.338);--color-gray-400:oklch(70.7% .022 261.325);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-black:#000;--color-white:#fff;--spacing:.25rem;--font-weight-normal:400;--font-weight-medium:500;--ease-in-out:cubic-bezier(.4,0,.2,1);--blur-sm:8px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root,:host{overscroll-behavior:none;--tw-border-style:solid;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;font-size:13px}}@layer components;@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.top-0{top:calc(var(--spacing)*0)}.top-\\[32px\\]{top:32px}.right-0{right:calc(var(--spacing)*0)}.bottom-0{bottom:calc(var(--spacing)*0)}.left-0{left:calc(var(--spacing)*0)}.z-10{z-index:10}.z-20{z-index:20}.order-1{order:1}.order-3{order:3}.container{width:100%}@media(min-width:520px){.container{max-width:520px}}@media(min-width:624px){.container{max-width:624px}}@media(min-width:832px){.container{max-width:832px}}@media(min-width:1040px){.container{max-width:1040px}}@media(min-width:1248px){.container{max-width:1248px}}.-m-2{margin:-6.5px}.m-1{margin:3.25px}.m-2{margin:6.5px}.mx-1{margin-inline:3.25px}.mx-2{margin-inline:6.5px}.my-0{margin-block:calc(var(--spacing)*0)}.my-1{margin-block:3.25px}.my-2{margin-block:6.5px}.mt-1{margin-top:3.25px}.mt-2{margin-top:6.5px}.mt-4{margin-top:13px}.mr-1{margin-right:3.25px}.mr-2{margin-right:6.5px}.mb-1{margin-bottom:3.25px}.mb-2{margin-bottom:6.5px}.ml-2{margin-left:6.5px}.ml-3{margin-left:9.75px}.form-input{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-input:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-input::placeholder{color:#6a7282;opacity:1}.form-input::-webkit-datetime-edit-fields-wrapper{padding:0}.form-input::-webkit-date-and-time-value{min-height:1.5em}.form-input::-webkit-date-and-time-value{text-align:inherit}.form-input::-webkit-datetime-edit{display:inline-flex}.form-input::-webkit-datetime-edit{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-year-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-month-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-day-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-hour-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-minute-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-second-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-millisecond-field{padding-top:0;padding-bottom:0}.form-input::-webkit-datetime-edit-meridiem-field{padding-top:0;padding-bottom:0}.line-clamp-4{-webkit-line-clamp:4;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.block{display:block}.contents{display:contents}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline{display:inline}.table{display:table}.size-fit{width:fit-content;height:fit-content}.\\!h-32{height:104px!important}.h-2{height:6.5px}.h-3{height:9.75px}.h-4{height:13px}.h-5{height:16.25px}.h-8{height:26px}.h-12{height:39px}.h-64{height:208px}.h-96{height:312px}.h-\\[28px\\]{height:28px}.h-full{height:100%}.max-h-24{max-height:78px}.max-h-60{max-height:195px}.min-h-0{min-height:calc(var(--spacing)*0)}.w-0{width:calc(var(--spacing)*0)}.w-2{width:6.5px}.w-3{width:9.75px}.w-4{width:13px}.w-5{width:16.25px}.w-7{width:22.75px}.w-12{width:39px}.w-24{width:78px}.w-40{width:130px}.w-48{width:156px}.w-64{width:208px}.w-72{width:234px}.w-96{width:312px}.w-\\[4rem\\]{width:4rem}.w-\\[40rem\\]{width:40rem}.w-\\[420px\\]{width:420px}.w-full{width:100%}.max-w-24{max-width:78px}.max-w-32{max-width:104px}.max-w-64{max-width:208px}.max-w-72{max-width:234px}.max-w-80{max-width:260px}.max-w-\\[400px\\]{max-width:400px}.min-w-\\[180px\\]{min-width:180px}.min-w-\\[420px\\]{min-width:420px}.flex-1{flex:1}.flex-none{flex:none}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-col-resize{cursor:col-resize}.cursor-row-resize{cursor:row-resize}.resize{resize:both}.form-select{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-select:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-select{print-color-adjust:exact;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='oklch(55.1%25 0.027 264.364)' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");background-position:right .5rem center;background-repeat:no-repeat;background-size:1.5em 1.5em;padding-right:2.5rem}.form-select:where([size]:not([size="1"])){background-image:initial;background-position:initial;background-repeat:unset;background-size:initial;print-color-adjust:unset;padding-right:.75rem}.form-textarea{appearance:none;--tw-shadow:0 0 #0000;background-color:#fff;border-width:1px;border-color:#6a7282;border-radius:0;padding:.5rem .75rem;font-size:1rem;line-height:1.5rem}.form-textarea:focus{outline-offset:2px;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:oklch(54.6% .245 262.881);--tw-ring-offset-shadow:var(--tw-ring-inset)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);border-color:#155dfc;outline:2px solid #0000}.form-textarea::placeholder{color:#6a7282;opacity:1}.flex-col{flex-direction:column}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.place-content-center{place-content:center}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-0\\.5{gap:1.625px}.gap-1{gap:3.25px}.gap-2{gap:6.5px}.gap-4{gap:13px}.gap-\\[1px\\]{gap:1px}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(6.5px*var(--tw-space-y-reverse));margin-block-end:calc(6.5px*calc(1 - var(--tw-space-y-reverse)))}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-scroll{overflow-y:scroll}.rounded{border-radius:3.25px}.rounded-full{border-radius:3.40282e38px}.rounded-md{border-radius:4.875px}.rounded-sm{border-radius:1.625px}.rounded-ss-md{border-start-start-radius:4.875px}.rounded-ee-md{border-end-end-radius:4.875px}.border{border-style:var(--tw-border-style);border-width:1px}.border-0{border-style:var(--tw-border-style);border-width:0}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-dotted{--tw-border-style:dotted;border-style:dotted}.\\!border-blue-400{border-color:var(--color-blue-400)!important}.\\!border-slate-600{border-color:var(--color-slate-600)!important}.border-slate-200{border-color:var(--color-slate-200)}.border-slate-300{border-color:var(--color-slate-300)}.border-slate-400{border-color:var(--color-slate-400)}.border-slate-500{border-color:var(--color-slate-500)}.\\!bg-blue-100{background-color:var(--color-blue-100)!important}.\\!bg-slate-100{background-color:var(--color-slate-100)!important}.\\!bg-slate-500{background-color:var(--color-slate-500)!important}.bg-blue-100{background-color:var(--color-blue-100)}.bg-blue-200{background-color:var(--color-blue-200)}.bg-blue-500{background-color:var(--color-blue-500)}.bg-gray-300{background-color:var(--color-gray-300)}.bg-slate-50{background-color:var(--color-slate-50)}.bg-slate-100{background-color:var(--color-slate-100)}.bg-slate-100\\/25{background-color:#f1f5f940}@supports (color:color-mix(in lab,red,red)){.bg-slate-100\\/25{background-color:color-mix(in oklab,var(--color-slate-100)25%,transparent)}}.bg-slate-100\\/75{background-color:#f1f5f9bf}@supports (color:color-mix(in lab,red,red)){.bg-slate-100\\/75{background-color:color-mix(in oklab,var(--color-slate-100)75%,transparent)}}.bg-slate-200{background-color:var(--color-slate-200)}.bg-slate-400{background-color:var(--color-slate-400)}.bg-slate-500{background-color:var(--color-slate-500)}.bg-slate-600{background-color:var(--color-slate-600)}.bg-slate-900{background-color:var(--color-slate-900)}.bg-slate-950{background-color:var(--color-slate-950)}.bg-white{background-color:var(--color-white)}.bg-white\\/75{background-color:#ffffffbf}@supports (color:color-mix(in lab,red,red)){.bg-white\\/75{background-color:color-mix(in oklab,var(--color-white)75%,transparent)}}.fill-orange-500{fill:var(--color-orange-500)}.stroke-orange-500{stroke:var(--color-orange-500)}.stroke-orange-700{stroke:var(--color-orange-700)}.stroke-2{stroke-width:2px}.p-1{padding:3.25px}.p-2{padding:6.5px}.p-4{padding:13px}.px-1{padding-inline:3.25px}.px-1\\.5{padding-inline:4.875px}.px-2{padding-inline:6.5px}.px-2\\.5{padding-inline:8.125px}.px-3{padding-inline:9.75px}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\\.5{padding-block:1.625px}.py-1{padding-block:3.25px}.py-1\\.5{padding-block:4.875px}.py-2{padding-block:6.5px}.py-3{padding-block:9.75px}.py-20{padding-block:65px}.pt-2{padding-top:6.5px}.pr-0\\.5{padding-right:1.625px}.pr-1{padding-right:3.25px}.pr-2{padding-right:6.5px}.pr-\\[16px\\]{padding-right:16px}.pb-1{padding-bottom:3.25px}.pb-2{padding-bottom:6.5px}.pb-4{padding-bottom:13px}.pl-2{padding-left:6.5px}.pl-40{padding-left:130px}.pl-\\[4px\\]{padding-left:4px}.text-center{text-align:center}.text-left{text-align:left}.text-right{text-align:right}.font-mono{font-family:var(--font-mono)}.text-sm{font-size:11.375px;line-height:var(--tw-leading,16.25px)}.text-sm\\!{font-size:11.375px!important;line-height:var(--tw-leading,16.25px)!important}.text-xs{font-size:9.75px;line-height:var(--tw-leading,13px)}.leading-5{--tw-leading:16.25px;line-height:16.25px}.leading-7{--tw-leading:22.75px;line-height:22.75px}.leading-10{--tw-leading:32.5px;line-height:32.5px}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.text-nowrap{text-wrap:nowrap}.break-all{word-break:break-all}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.\\!text-gray-200{color:var(--color-gray-200)!important}.\\!text-slate-100{color:var(--color-slate-100)!important}.text-blue-500{color:var(--color-blue-500)}.text-gray-400{color:var(--color-gray-400)}.text-red-400{color:var(--color-red-400)}.text-red-600{color:var(--color-red-600)}.text-slate-300{color:var(--color-slate-300)}.text-slate-400{color:var(--color-slate-400)}.text-slate-500{color:var(--color-slate-500)}.text-slate-600{color:var(--color-slate-600)}.text-slate-700{color:var(--color-slate-700)}.text-slate-800{color:var(--color-slate-800)}.text-white{color:var(--color-white)}.ordinal{--tw-ordinal:ordinal;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.underline{text-decoration-line:underline}.opacity-20{opacity:.2}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.-outline-offset-1{outline-offset:-1px}.outline-blue-600{outline-color:var(--color-blue-600)}.outline-slate-500{outline-color:var(--color-slate-500)}.invert{--tw-invert:invert(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.select-none{-webkit-user-select:none;user-select:none}@media(hover:hover){.group-hover\\:bg-blue-600:is(:where(.group):hover *){background-color:var(--color-blue-600)}.group-hover\\:opacity-100:is(:where(.group):hover *){opacity:1}}.first\\:rounded-tl-md:first-child{border-top-left-radius:4.875px}.first\\:rounded-bl-md:first-child{border-bottom-left-radius:4.875px}.last\\:rounded-tr-md:last-child{border-top-right-radius:4.875px}.last\\:rounded-br-md:last-child{border-bottom-right-radius:4.875px}@media(hover:hover){.hover\\:bg-slate-200:hover{background-color:var(--color-slate-200)}.hover\\:text-slate-500:hover{color:var(--color-slate-500)}.hover\\:text-slate-800:hover{color:var(--color-slate-800)}.hover\\:text-slate-900:hover{color:var(--color-slate-900)}.hover\\:outline:hover{outline-style:var(--tw-outline-style);outline-width:1px}}.focus-visible\\:outline-2:focus-visible{outline-style:var(--tw-outline-style);outline-width:2px}@media(min-width:520px){.sm\\:opacity-0{opacity:0}}.dark\\:\\!border-blue-600:where(.dark,.dark *){border-color:var(--color-blue-600)!important}.dark\\:\\!border-slate-400:where(.dark,.dark *){border-color:var(--color-slate-400)!important}.dark\\:border-slate-500:where(.dark,.dark *){border-color:var(--color-slate-500)}.dark\\:border-slate-600:where(.dark,.dark *){border-color:var(--color-slate-600)}.dark\\:border-slate-700:where(.dark,.dark *){border-color:var(--color-slate-700)}.dark\\:\\!bg-blue-800:where(.dark,.dark *){background-color:var(--color-blue-800)!important}.dark\\:\\!bg-slate-700:where(.dark,.dark *){background-color:var(--color-slate-700)!important}.dark\\:bg-black:where(.dark,.dark *){background-color:var(--color-black)}.dark\\:bg-black\\/75:where(.dark,.dark *){background-color:#000000bf}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-black\\/75:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-black)75%,transparent)}}.dark\\:bg-gray-700:where(.dark,.dark *){background-color:var(--color-gray-700)}.dark\\:bg-slate-500:where(.dark,.dark *){background-color:var(--color-slate-500)}.dark\\:bg-slate-600:where(.dark,.dark *){background-color:var(--color-slate-600)}.dark\\:bg-slate-700:where(.dark,.dark *){background-color:var(--color-slate-700)}.dark\\:bg-slate-700\\/25:where(.dark,.dark *){background-color:#31415840}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-slate-700\\/25:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-slate-700)25%,transparent)}}.dark\\:bg-slate-800:where(.dark,.dark *){background-color:var(--color-slate-800)}.dark\\:bg-slate-800\\/75:where(.dark,.dark *){background-color:#1d293dbf}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-slate-800\\/75:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-slate-800)75%,transparent)}}.dark\\:bg-slate-900:where(.dark,.dark *){background-color:var(--color-slate-900)}.dark\\:\\!text-gray-600:where(.dark,.dark *){color:var(--color-gray-600)!important}.dark\\:text-gray-400:where(.dark,.dark *){color:var(--color-gray-400)}.dark\\:text-gray-500:where(.dark,.dark *){color:var(--color-gray-500)}.dark\\:text-slate-200:where(.dark,.dark *){color:var(--color-slate-200)}.dark\\:text-slate-300:where(.dark,.dark *){color:var(--color-slate-300)}.dark\\:text-slate-400:where(.dark,.dark *){color:var(--color-slate-400)}.dark\\:text-slate-500:where(.dark,.dark *){color:var(--color-slate-500)}.dark\\:text-slate-600:where(.dark,.dark *){color:var(--color-slate-600)}@media(hover:hover){.dark\\:group-hover\\:bg-blue-400:where(.dark,.dark *):is(:where(.group):hover *){background-color:var(--color-blue-400)}.dark\\:hover\\:bg-slate-700:where(.dark,.dark *):hover{background-color:var(--color-slate-700)}.dark\\:hover\\:text-slate-100:where(.dark,.dark *):hover{color:var(--color-slate-100)}.dark\\:hover\\:text-slate-200:where(.dark,.dark *):hover{color:var(--color-slate-200)}.dark\\:hover\\:text-slate-300:where(.dark,.dark *):hover{color:var(--color-slate-300)}.dark\\:hover\\:text-slate-400:where(.dark,.dark *):hover{color:var(--color-slate-400)}}}.form-input,.form-textarea,.form-select,.form-multiselect{font-size:13px;line-height:19.5px}mark{background-color:#f9ceaf}.markdown-content{line-height:1.2em}.markdown-content a{text-decoration:underline}.markdown-content pre,.markdown-content code{font-family:Menlo,monospace;font-size:11px}.markdown-content pre{margin-bottom:.5em}.markdown-content h1,.markdown-content h2,.markdown-content h3,.markdown-content h4{margin-bottom:.5em;font-weight:700}.markdown-content p{margin-bottom:.5em;list-style:outside}.markdown-content ul{margin-bottom:.5em;margin-left:2em;list-style:outside}.markdown-content ol{margin-bottom:.5em;margin-left:2em;list-style:decimal}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-ordinal{syntax:"*";inherits:false}@property --tw-slashed-zero{syntax:"*";inherits:false}@property --tw-numeric-figure{syntax:"*";inherits:false}@property --tw-numeric-spacing{syntax:"*";inherits:false}@property --tw-numeric-fraction{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}`;
class g6e {
  component;
  container;
  currentProps;
  constructor(e, n) {
    this.currentProps = { ...n }, this.container = document.createElement("div"), this.container.style.display = "flex", this.container.style.width = "100%", this.container.style.height = "100%", e.appendChild(this.container);
    let r = this.container.attachShadow({ mode: "open" }), i = document.createElement("style");
    i.innerText = Hke, r.appendChild(i);
    let s = document.createElement("div");
    s.style.display = "flex", s.style.width = "100%", s.style.height = "100%", r.appendChild(s), this.component = _T({ component: Uke, target: s, props: n });
  }
  update(e) {
    let n = {};
    for (let r in e)
      e[r] !== this.currentProps[r] && (n[r] = e[r], this.currentProps[r] = e[r]);
    this.component.$set(n);
  }
  destroy() {
    this.component.$destroy(), this.container.remove();
  }
}
export {
  g6e as EmbeddingAtlas,
  Oke as defaultCharts
};
